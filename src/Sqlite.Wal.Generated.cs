// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int sqlite3WalBeginReadTransaction(Wal pWal, int* pChanged)
		{
			int rc = 0;
			int cnt = (int)(0);
			do
			{
				rc = (int)(walTryBeginRead(pWal, pChanged, (int)(0), (int)(++cnt)));
			}
			while ((rc) == (-1));
			return (int)(rc);
		}
		public static int sqlite3WalBeginWriteTransaction(Wal pWal)
		{
			int rc = 0;
			if ((pWal.readOnly) != 0)
			{
				return (int)(8);
			}

			rc = (int)(walLockExclusive(pWal, (int)(0), (int)(1)));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			pWal.writeLock = (byte)(1);
			if (memcmp(&pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr))) != 0)
			{
				walUnlockExclusive(pWal, (int)(0), (int)(1));
				pWal.writeLock = (byte)(0);
				rc = (int)(5 | (2 << 8));
			}

			return (int)(rc);
		}
		public static int sqlite3WalCallback(Wal pWal)
		{
			uint ret = (uint)(0);
			if ((pWal) != null)
			{
				ret = (uint)(pWal.iCallback);
				pWal.iCallback = (uint)(0);
			}

			return (int)(ret);
		}
		public static int sqlite3WalCheckpoint(Wal pWal, sqlite3 db, int eMode, delegate19 xBusy, void* pBusyArg, int sync_flags, int nBuf, byte* zBuf, int* pnLog, int* pnCkpt)
		{
			int rc = 0;
			int isChanged = (int)(0);
			int eMode2 = (int)(eMode);
			delegate19 xBusy2 = xBusy;
			if ((pWal.readOnly) != 0)
				return (int)(8);
			(void)(0);
			rc = (int)(walLockExclusive(pWal, (int)(1), (int)(1)));
			if ((rc) == (0))
			{
				pWal.ckptLock = (byte)(1);
				if (eMode != 0)
				{
					rc = (int)(walBusyLock(pWal, xBusy2, pBusyArg, (int)(0), (int)(1)));
					if ((rc) == (0))
					{
						pWal.writeLock = (byte)(1);
					}
					else if ((rc) == (5))
					{
						eMode2 = (int)(0);
						xBusy2 = null;
						rc = (int)(0);
					}
				}
			}

			if ((rc) == (0))
			{
				rc = (int)(walIndexReadHdr(pWal, &isChanged));
				(void)(0);
				if (((isChanged) != 0) && ((pWal.pDbFd.pMethods.iVersion) >= (3)))
				{
					sqlite3OsUnfetch(pWal.pDbFd, (long)(0), null);
				}
			}

			if ((rc) == (0))
			{
				if (((pWal.hdr.mxFrame) != 0) && (walPagesize(pWal) != nBuf))
				{
					rc = (int)(sqlite3CorruptError((int)(64882)));
				}
				else
				{
					rc = (int)(walCheckpoint(pWal, db, (int)(eMode2), xBusy2, pBusyArg, (int)(sync_flags), zBuf));
				}

				if (((rc) == (0)) || ((rc) == (5)))
				{
					if ((pnLog) != null)
						*pnLog = ((int)(pWal.hdr.mxFrame));
					if ((pnCkpt) != null)
						*pnCkpt = ((int)(walCkptInfo(pWal)->nBackfill));
				}
			}

			if ((isChanged) != 0)
			{
				CRuntime.memset(&pWal.hdr, (int)(0), (ulong)(sizeof(WalIndexHdr)));
			}

			sqlite3WalEndWriteTransaction(pWal);
			if ((pWal.ckptLock) != 0)
			{
				walUnlockExclusive(pWal, (int)(1), (int)(1));
				pWal.ckptLock = (byte)(0);
			}

			return (int)(((rc) == (0)) && (eMode != eMode2) ? 5 : rc);
		}
		public static int sqlite3WalClose(Wal pWal, sqlite3 db, int sync_flags, int nBuf, byte* zBuf)
		{
			int rc = (int)(0);
			if ((pWal) != null)
			{
				int isDelete = (int)(0);
				if ((zBuf != null) && ((0) == (rc = (int)(sqlite3OsLock(pWal.pDbFd, (int)(4))))))
				{
					if ((pWal.exclusiveMode) == (0))
					{
						pWal.exclusiveMode = (byte)(1);
					}

					rc = (int)(sqlite3WalCheckpoint(pWal, db, (int)(0), null, null, (int)(sync_flags), (int)(nBuf), zBuf, null, null));
					if ((rc) == (0))
					{
						int bPersist = (int)(-1);
						sqlite3OsFileControlHint(pWal.pDbFd, (int)(10), &bPersist);
						if (bPersist != 1)
						{
							isDelete = (int)(1);
						}
						else if ((pWal.mxWalSize) >= (0))
						{
							walLimitSize(pWal, (long)(0));
						}
					}
				}

				walIndexClose(pWal, (int)(isDelete));
				sqlite3OsClose(pWal.pWalFd);
				if ((isDelete) != 0)
				{
					sqlite3BeginBenignMalloc();
					sqlite3OsDelete(pWal.pVfs, pWal.zWalName, (int)(0));
					sqlite3EndBenignMalloc();
				}

				sqlite3_free((void*)(pWal.apWiData));
				sqlite3_free(pWal);
			}

			return (int)(rc);
		}
		public static uint sqlite3WalDbsize(Wal pWal)
		{
			if (((pWal) != null) && ((pWal.readLock) >= (0)))
			{
				return (uint)(pWal.hdr.nPage);
			}

			return (uint)(0);
		}
		public static void sqlite3WalEndReadTransaction(Wal pWal)
		{
			sqlite3WalEndWriteTransaction(pWal);
			if ((pWal.readLock) >= (0))
			{
				walUnlockShared(pWal, (int)(3 + (pWal.readLock)));
				pWal.readLock = (short)(-1);
			}
		}
		public static int sqlite3WalEndWriteTransaction(Wal pWal)
		{
			if ((pWal.writeLock) != 0)
			{
				walUnlockExclusive(pWal, (int)(0), (int)(1));
				pWal.writeLock = (byte)(0);
				pWal.iReCksum = (uint)(0);
				pWal.truncateOnCommit = (byte)(0);
			}

			return (int)(0);
		}
		public static int sqlite3WalExclusiveMode(Wal pWal, int op)
		{
			int rc = 0;
			if ((op) == (0))
			{
				if (pWal.exclusiveMode != 0)
				{
					pWal.exclusiveMode = (byte)(0);
					if (walLockShared(pWal, (int)(3 + (pWal.readLock))) != 0)
					{
						pWal.exclusiveMode = (byte)(1);
					}

					rc = (int)((pWal.exclusiveMode) == (0) ? 1 : 0);
				}
				else
				{
					rc = (int)(0);
				}
			}
			else if ((op) > (0))
			{
				walUnlockShared(pWal, (int)(3 + (pWal.readLock)));
				pWal.exclusiveMode = (byte)(1);
				rc = (int)(1);
			}
			else
			{
				rc = (int)((pWal.exclusiveMode) == (0) ? 1 : 0);
			}

			return (int)(rc);
		}
		public static sqlite3_file sqlite3WalFile(Wal pWal)
		{
			return pWal.pWalFd;
		}
		public static int sqlite3WalFindFrame(Wal pWal, uint pgno, uint* piRead)
		{
			uint iRead = (uint)(0);
			uint iLast = (uint)(pWal.hdr.mxFrame);
			int iHash = 0;
			int iMinHash = 0;
			if (((iLast) == (0)) || (((pWal.readLock) == (0)) && ((pWal.bShmUnreliable) == (0))))
			{
				*piRead = (uint)(0);
				return (int)(0);
			}

			iMinHash = (int)(walFramePage((uint)(pWal.minFrame)));
			for (iHash = (int)(walFramePage((uint)(iLast))); (iHash) >= (iMinHash); iHash--)
			{
				WalHashLoc sLoc = new WalHashLoc();
				int iKey = 0;
				int nCollide = 0;
				int rc = 0;
				uint iH = 0;
				rc = (int)(walHashGet(pWal, (int)(iHash), &sLoc));
				if (rc != 0)
				{
					return (int)(rc);
				}

				nCollide = (int)(4096 * 2);
				iKey = (int)(walHash((uint)(pgno)));
				while ((iH = (uint)(0)) != 0)
				{
					uint iFrame = (uint)(iH + sLoc.iZero);
					if ((((iFrame) <= (iLast)) && ((iFrame) >= (pWal.minFrame))) && ((sLoc.aPgno[iH - 1]) == (pgno)))
					{
						iRead = (uint)(iFrame);
					}

					if ((nCollide--) == (0))
					{
						return (int)(sqlite3CorruptError((int)(64163)));
					}

					iKey = (int)(walNextHash((int)(iKey)));
				}

				if ((iRead) != 0)
					break;
			}

			*piRead = (uint)(iRead);
			return (int)(0);
		}
		public static int sqlite3WalFrames(Wal pWal, int szPage, PgHdr pList, uint nTruncate, int isCommit, int sync_flags)
		{
			int rc = 0;
			uint iFrame = 0;
			PgHdr p;
			PgHdr pLast = null;
			int nExtra = (int)(0);
			int szFrame = 0;
			long iOffset = 0;
			WalWriter w = new WalWriter();
			uint iFirst = (uint)(0);
			WalIndexHdr* pLive;
			pLive = (WalIndexHdr*)(walIndexHdr(pWal));
			if (memcmp(&pWal.hdr, (void*)(pLive), (ulong)(sizeof(WalIndexHdr))) != 0)
			{
				iFirst = (uint)(pLive->mxFrame + 1);
			}

			if (0 != (rc = (int)(walRestartLog(pWal))))
			{
				return (int)(rc);
			}

			iFrame = (uint)(pWal.hdr.mxFrame);
			if ((iFrame) == (0))
			{
				byte* aWalHdr = stackalloc byte[32];
				uint* aCksum = stackalloc uint[2];
				sqlite3Put4byte(&aWalHdr[0], (uint)(0x377f0682 | 0));
				sqlite3Put4byte(&aWalHdr[4], (uint)(3007000));
				sqlite3Put4byte(&aWalHdr[8], (uint)(szPage));
				sqlite3Put4byte(&aWalHdr[12], (uint)(pWal.nCkpt));
				if ((pWal.nCkpt) == (0))
					sqlite3_randomness((int)(8), pWal.hdr.aSalt);
				CRuntime.memcpy(&aWalHdr[16], pWal.hdr.aSalt, (ulong)(8));
				walChecksumBytes((int)(1), aWalHdr, (int)(32 - 2 * 4), null, aCksum);
				sqlite3Put4byte(&aWalHdr[24], (uint)(aCksum[0]));
				sqlite3Put4byte(&aWalHdr[28], (uint)(aCksum[1]));
				pWal.szPage = (uint)(szPage);
				pWal.hdr.bigEndCksum = (byte)(0);
				pWal.hdr.aFrameCksum[0] = (uint)(aCksum[0]);
				pWal.hdr.aFrameCksum[1] = (uint)(aCksum[1]);
				pWal.truncateOnCommit = (byte)(1);
				rc = (int)(sqlite3OsWrite(pWal.pWalFd, aWalHdr, (int)(32 * sizeof(byte)), (long)(0)));
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((pWal.syncHeader) != 0)
				{
					rc = (int)(sqlite3OsSync(pWal.pWalFd, (int)(((sync_flags) >> 2) & 0x03)));
					if ((rc) != 0)
						return (int)(rc);
				}
			}

			w.pWal = pWal;
			w.pFd = pWal.pWalFd;
			w.iSyncPoint = (long)(0);
			w.syncFlags = (int)(sync_flags);
			w.szPage = (int)(szPage);
			iOffset = (long)(32 + ((iFrame + 1) - 1) * (long)((szPage) + 24));
			szFrame = (int)(szPage + 24);
			for (p = pList; p; p = p.pDirty)
			{
				int nDbSize = 0;
				if (((iFirst) != 0) && (((p.pDirty) != null) || ((isCommit) == (0))))
				{
					uint iWrite = (uint)(0);
					sqlite3WalFindFrame(pWal, (uint)(p.pgno), &iWrite);
					if ((iWrite) >= (iFirst))
					{
						long iOff = (long)((32 + ((iWrite) - 1) * (long)((szPage) + 24)) + 24);
						void* pData;
						if (((pWal.iReCksum) == (0)) || ((iWrite) < (pWal.iReCksum)))
						{
							pWal.iReCksum = (uint)(iWrite);
						}

						pData = p.pData;
						rc = (int)(sqlite3OsWrite(pWal.pWalFd, pData, (int)(szPage), (long)(iOff)));
						if ((rc) != 0)
							return (int)(rc);
						p.flags &= (ushort)(~0x040);
						continue;
					}
				}

				iFrame++;
				nDbSize = (int)((((isCommit) != 0) && ((p.pDirty) == (null))) ? nTruncate : 0);
				rc = (int)(walWriteOneFrame(w, p, (int)(nDbSize), (long)(iOffset)));
				if ((rc) != 0)
					return (int)(rc);
				pLast = p;
				iOffset += (long)(szFrame);
				p.flags |= (ushort)(0x040);
			}

			if (((isCommit) != 0) && ((pWal.iReCksum) != 0))
			{
				rc = (int)(walRewriteChecksums(pWal, (uint)(iFrame)));
				if ((rc) != 0)
					return (int)(rc);
			}

			if (((isCommit) != 0) && (((sync_flags) & 0x03) != 0))
			{
				int bSync = (int)(1);
				if ((pWal.padToSectorBoundary) != 0)
				{
					int sectorSize = (int)(sqlite3SectorSize(pWal.pWalFd));
					w.iSyncPoint = (long)(((iOffset + sectorSize - 1) / sectorSize) * sectorSize);
					bSync = (int)((w.iSyncPoint) == (iOffset) ? 1 : 0);
					while ((iOffset) < (w.iSyncPoint))
					{
						rc = (int)(walWriteOneFrame(w, pLast, (int)(nTruncate), (long)(iOffset)));
						if ((rc) != 0)
							return (int)(rc);
						iOffset += (long)(szFrame);
						nExtra++;
					}
				}

				if ((bSync) != 0)
				{
					rc = (int)(sqlite3OsSync(w.pFd, (int)((sync_flags) & 0x03)));
				}
			}

			if ((((isCommit) != 0) && ((pWal.truncateOnCommit) != 0)) && ((pWal.mxWalSize) >= (0)))
			{
				long sz = (long)(pWal.mxWalSize);
				if ((32 + ((iFrame + nExtra + 1) - 1) * (long)((szPage) + 24)) > (pWal.mxWalSize))
				{
					sz = (long)(32 + ((iFrame + nExtra + 1) - 1) * (long)((szPage) + 24));
				}

				walLimitSize(pWal, (long)(sz));
				pWal.truncateOnCommit = (byte)(0);
			}

			iFrame = (uint)(pWal.hdr.mxFrame);
			for (p = pList; ((p) != null) && ((rc) == (0)); p = p.pDirty)
			{
				if ((p.flags & 0x040) == (0))
					continue;
				iFrame++;
				rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(p.pgno)));
			}

			while (((rc) == (0)) && ((nExtra) > (0)))
			{
				iFrame++;
				nExtra--;
				rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(pLast.pgno)));
			}

			if ((rc) == (0))
			{
				pWal.hdr.szPage = ((ushort)((szPage & 0xff00) | (szPage >> 16)));
				pWal.hdr.mxFrame = (uint)(iFrame);
				if ((isCommit) != 0)
				{
					pWal.hdr.iChange++;
					pWal.hdr.nPage = (uint)(nTruncate);
				}

				if ((isCommit) != 0)
				{
					walIndexWriteHdr(pWal);
					pWal.iCallback = (uint)(iFrame);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3WalHeapMemory(Wal pWal)
		{
			return ((((pWal) != null) && ((pWal.exclusiveMode) == (2))) ? 1 : 0);
		}
		public static void sqlite3WalLimit(Wal pWal, long iLimit)
		{
			if ((pWal) != null)
				pWal.mxWalSize = (long)(iLimit);
		}
		public static int sqlite3WalReadFrame(Wal pWal, uint iRead, int nOut, byte* pOut)
		{
			int sz = 0;
			long iOffset = 0;
			sz = (int)(pWal.hdr.szPage);
			sz = (int)((sz & 0xfe00) + ((sz & 0x0001) << 16));
			iOffset = (long)((32 + ((iRead) - 1) * (long)((sz) + 24)) + 24);
			return (int)(sqlite3OsRead(pWal.pWalFd, pOut, (int)((nOut) > (sz) ? sz : nOut), (long)(iOffset)));
		}
		public static void sqlite3WalSavepoint(Wal pWal, uint* aWalData)
		{
			aWalData[0] = (uint)(pWal.hdr.mxFrame);
			aWalData[1] = (uint)(pWal.hdr.aFrameCksum[0]);
			aWalData[2] = (uint)(pWal.hdr.aFrameCksum[1]);
			aWalData[3] = (uint)(pWal.nCkpt);
		}
		public static int sqlite3WalSavepointUndo(Wal pWal, uint* aWalData)
		{
			int rc = (int)(0);
			if (aWalData[3] != pWal.nCkpt)
			{
				aWalData[0] = (uint)(0);
				aWalData[3] = (uint)(pWal.nCkpt);
			}

			if ((aWalData[0]) < (pWal.hdr.mxFrame))
			{
				pWal.hdr.mxFrame = (uint)(aWalData[0]);
				pWal.hdr.aFrameCksum[0] = (uint)(aWalData[1]);
				pWal.hdr.aFrameCksum[1] = (uint)(aWalData[2]);
				walCleanupHash(pWal);
			}

			return (int)(rc);
		}
		public static int sqlite3WalUndo(Wal pWal, delegate59 xUndo, void* pUndoCtx)
		{
			int rc = (int)(0);
			if ((pWal.writeLock) != 0)
			{
				uint iMax = (uint)(pWal.hdr.mxFrame);
				uint iFrame = 0;
				CRuntime.memcpy(&pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr)));
				for (iFrame = (uint)(pWal.hdr.mxFrame + 1); ((rc) == (0)) && ((iFrame) <= (iMax)); iFrame++)
				{
					rc = (int)(xUndo(pUndoCtx, (uint)(walFramePgno(pWal, (uint)(iFrame)))));
				}

				if (iMax != pWal.hdr.mxFrame)
					walCleanupHash(pWal);
			}

			return (int)(rc);
		}
		public static int walBeginShmUnreliable(Wal pWal, int* pChanged)
		{
			long szWal = 0;
			long iOffset = 0;
			byte* aBuf = stackalloc byte[32];
			byte* aFrame = null;
			int szFrame = 0;
			byte* aData;
			void* pDummy;
			int rc = 0;
			uint* aSaveCksum = stackalloc uint[2];
			rc = (int)(walLockShared(pWal, (int)(3 + (0))));
			if (rc != 0)
			{
				if ((rc) == (5))
					rc = (int)(-1);
				goto begin_unreliable_shm_out;
			}

			pWal.readLock = (short)(0);
			rc = (int)(sqlite3OsShmMap(pWal.pDbFd, (int)(0), (int)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)), (int)(0), &pDummy));
			if (rc != (8 | (5 << 8)))
			{
				rc = (int)((rc) == (8) ? (-1) : rc);
				goto begin_unreliable_shm_out;
			}

			CRuntime.memcpy(&pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr)));
			rc = (int)(sqlite3OsFileSize(pWal.pWalFd, &szWal));
			if (rc != 0)
			{
				goto begin_unreliable_shm_out;
			}

			if ((szWal) < (32))
			{
				*pChanged = (int)(1);
				rc = (int)((pWal.hdr.mxFrame) == (0) ? 0 : (-1));
				goto begin_unreliable_shm_out;
			}

			rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(32), (long)(0)));
			if (rc != 0)
			{
				goto begin_unreliable_shm_out;
			}

			if ((memcmp(&pWal.hdr.aSalt, &aBuf[16], (ulong)(8))) != 0)
			{
				rc = (int)(-1);
				goto begin_unreliable_shm_out;
			}

			szFrame = (int)(pWal.szPage + 24);
			aFrame = (byte*)(sqlite3_malloc64((ulong)(szFrame)));
			if ((aFrame) == (null))
			{
				rc = (int)(7);
				goto begin_unreliable_shm_out;
			}

			aData = &aFrame[24];
			aSaveCksum[0] = (uint)(pWal.hdr.aFrameCksum[0]);
			aSaveCksum[1] = (uint)(pWal.hdr.aFrameCksum[1]);
			for (iOffset = (long)(32 + ((pWal.hdr.mxFrame + 1) - 1) * (long)((pWal.szPage) + 24)); (iOffset + szFrame) <= (szWal); iOffset += (long)(szFrame))
			{
				uint pgno = 0;
				uint nTruncate = 0;
				rc = (int)(sqlite3OsRead(pWal.pWalFd, aFrame, (int)(szFrame), (long)(iOffset)));
				if (rc != 0)
					break;
				if (walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) == 0)
					break;
				if ((nTruncate) != 0)
				{
					rc = (int)(-1);
					break;
				}
			}

			pWal.hdr.aFrameCksum[0] = (uint)(aSaveCksum[0]);
			pWal.hdr.aFrameCksum[1] = (uint)(aSaveCksum[1]);
		begin_unreliable_shm_out:
			; sqlite3_free(aFrame);
			if (rc != 0)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWal.nWiData); i++)
				{
					sqlite3_free((void*)(pWal.apWiData[i]));
					pWal.apWiData[i] = null;
				}

				pWal.bShmUnreliable = (byte)(0);
				sqlite3WalEndReadTransaction(pWal);
				*pChanged = (int)(1);
			}

			return (int)(rc);
		}
		public static int walBusyLock(Wal pWal, delegate19 xBusy, void* pBusyArg, int lockIdx, int n)
		{
			int rc = 0;
			do
			{
				rc = (int)(walLockExclusive(pWal, (int)(lockIdx), (int)(n)));
			}
			while ((((xBusy) != null) && ((rc) == (5))) && ((xBusy(pBusyArg)) != 0));
			return (int)(rc);
		}
		public static int walCheckpoint(Wal pWal, sqlite3 db, int eMode, delegate19 xBusy, void* pBusyArg, int sync_flags, byte* zBuf)
		{
			int rc = (int)(0);
			int szPage = 0;
			WalIterator pIter = null;
			uint iDbpage = (uint)(0);
			uint iFrame = (uint)(0);
			uint mxSafeFrame = 0;
			uint mxPage = 0;
			int i = 0;
			volatile WalCkptInfo* pInfo;
			szPage = (int)(walPagesize(pWal));
			pInfo = walCkptInfo(pWal);
			if ((pInfo->nBackfill) < (pWal.hdr.mxFrame))
			{
				mxSafeFrame = (uint)(pWal.hdr.mxFrame);
				mxPage = (uint)(pWal.hdr.nPage);
				for (i = (int)(1); (i) < (8 - 3); i++)
				{
					uint y = (uint)(0);
					if ((mxSafeFrame) > (y))
					{
						rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (i)), (int)(1)));
						if ((rc) == (0))
						{
							uint iMark = (uint)((i) == (1) ? mxSafeFrame : 0xffffffff);
							(iMark);
							walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1));
						}
						else if ((rc) == (5))
						{
							mxSafeFrame = (uint)(y);
							xBusy = null;
						}
						else
						{
							goto walcheckpoint_out;
						}
					}
				}

				if ((pInfo->nBackfill) < (mxSafeFrame))
				{
					rc = (int)(walIteratorInit(pWal, (uint)(pInfo->nBackfill), pIter));
				}

				if (((pIter) != null) && ((rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (0)), (int)(1)))) == (0)))
				{
					uint nBackfill = (uint)(pInfo->nBackfill);
					pInfo->nBackfillAttempted = (uint)(mxSafeFrame);
					rc = (int)(sqlite3OsSync(pWal.pWalFd, (int)(((sync_flags) >> 2) & 0x03)));
					if ((rc) == (0))
					{
						long nReq = (long)((long)(mxPage) * szPage);
						long nSize = 0;
						sqlite3OsFileControl(pWal.pDbFd, (int)(39), null);
						rc = (int)(sqlite3OsFileSize(pWal.pDbFd, &nSize));
						if (((rc) == (0)) && ((nSize) < (nReq)))
						{
							if ((nSize + 65536 + (long)(pWal.hdr.mxFrame) * szPage) < (nReq))
							{
								rc = (int)(sqlite3CorruptError((int)(63077)));
							}
							else
							{
								sqlite3OsFileControlHint(pWal.pDbFd, (int)(5), &nReq);
							}
						}
					}

					while (((rc) == (0)) && ((0) == (walIteratorNext(pIter, &iDbpage, &iFrame))))
					{
						long iOffset = 0;
						if ((0) != 0)
						{
							rc = (int)((db.mallocFailed) != 0 ? 7 : 9);
							break;
						}

						if ((((iFrame) <= (nBackfill)) || ((iFrame) > (mxSafeFrame))) || ((iDbpage) > (mxPage)))
						{
							continue;
						}

						iOffset = (long)((32 + ((iFrame) - 1) * (long)((szPage) + 24)) + 24);
						rc = (int)(sqlite3OsRead(pWal.pWalFd, zBuf, (int)(szPage), (long)(iOffset)));
						if (rc != 0)
							break;
						iOffset = (long)((iDbpage - 1) * (long)(szPage));
						rc = (int)(sqlite3OsWrite(pWal.pDbFd, zBuf, (int)(szPage), (long)(iOffset)));
						if (rc != 0)
							break;
					}

					sqlite3OsFileControl(pWal.pDbFd, (int)(37), null);
					if ((rc) == (0))
					{
						if ((mxSafeFrame) == (walIndexHdr(pWal)->mxFrame))
						{
							long szDb = (long)(pWal.hdr.nPage * (long)(szPage));
							rc = (int)(sqlite3OsTruncate(pWal.pDbFd, (long)(szDb)));
							if ((rc) == (0))
							{
								rc = (int)(sqlite3OsSync(pWal.pDbFd, (int)(((sync_flags) >> 2) & 0x03)));
							}
						}

						if ((rc) == (0))
						{
							(mxSafeFrame);
						}
					}

					walUnlockExclusive(pWal, (int)(3 + (0)), (int)(1));
				}

				if ((rc) == (5))
				{
					rc = (int)(0);
				}
			}

			if (((rc) == (0)) && (eMode != 0))
			{
				if ((pInfo->nBackfill) < (pWal.hdr.mxFrame))
				{
					rc = (int)(5);
				}
				else if ((eMode) >= (2))
				{
					uint salt1 = 0;
					sqlite3_randomness((int)(4), &salt1);
					rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (1)), (int)((8 - 3) - 1)));
					if ((rc) == (0))
					{
						if ((eMode) == (3))
						{
							walRestartHdr(pWal, (uint)(salt1));
							rc = (int)(sqlite3OsTruncate(pWal.pWalFd, (long)(0)));
						}

						walUnlockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1));
					}
				}
			}

		walcheckpoint_out:
			; walIteratorFree(pIter);
			return (int)(rc);
		}
		public static void walCleanupHash(Wal pWal)
		{
			WalHashLoc sLoc = new WalHashLoc();
			int iLimit = (int)(0);
			int nByte = 0;
			int i = 0;
			if ((pWal.hdr.mxFrame) == (0))
				return;
			i = (int)(walHashGet(pWal, (int)(walFramePage((uint)(pWal.hdr.mxFrame))), &sLoc));
			if ((i) != 0)
				return;
			iLimit = (int)(pWal.hdr.mxFrame - sLoc.iZero);
			for (i = (int)(0); (i) < (4096 * 2); i++)
			{
				if ((sLoc.aHash[i]) > (iLimit))
				{
					sLoc.aHash[i] = (ushort)(0);
				}
			}

			nByte = ((int)((sbyte*)(sLoc.aHash) - (sbyte*)(&sLoc.aPgno[iLimit])));
			CRuntime.memset((void*)(&sLoc.aPgno[iLimit]), (int)(0), (ulong)(nByte));
		}
		public static int walDecodeFrame(Wal pWal, uint* piPage, uint* pnTruncate, byte* aData, byte* aFrame)
		{
			int nativeCksum = 0;
			uint* aCksum = pWal.hdr.aFrameCksum;
			uint pgno = 0;
			if (memcmp(&pWal.hdr.aSalt, &aFrame[8], (ulong)(8)) != 0)
			{
				return (int)(0);
			}

			pgno = (uint)(sqlite3Get4byte(&aFrame[0]));
			if ((pgno) == (0))
			{
				return (int)(0);
			}

			nativeCksum = (int)((pWal.hdr.bigEndCksum) == (0) ? 1 : 0);
			walChecksumBytes((int)(nativeCksum), aFrame, (int)(8), aCksum, aCksum);
			walChecksumBytes((int)(nativeCksum), aData, (int)(pWal.szPage), aCksum, aCksum);
			if ((aCksum[0] != sqlite3Get4byte(&aFrame[16])) || (aCksum[1] != sqlite3Get4byte(&aFrame[20])))
			{
				return (int)(0);
			}

			*piPage = (uint)(pgno);
			*pnTruncate = (uint)(sqlite3Get4byte(&aFrame[4]));
			return (int)(1);
		}
		public static void walEncodeFrame(Wal pWal, uint iPage, uint nTruncate, byte* aData, byte* aFrame)
		{
			int nativeCksum = 0;
			uint* aCksum = pWal.hdr.aFrameCksum;
			sqlite3Put4byte(&aFrame[0], (uint)(iPage));
			sqlite3Put4byte(&aFrame[4], (uint)(nTruncate));
			if ((pWal.iReCksum) == (0))
			{
				CRuntime.memcpy(&aFrame[8], pWal.hdr.aSalt, (ulong)(8));
				nativeCksum = (int)((pWal.hdr.bigEndCksum) == (0) ? 1 : 0);
				walChecksumBytes((int)(nativeCksum), aFrame, (int)(8), aCksum, aCksum);
				walChecksumBytes((int)(nativeCksum), aData, (int)(pWal.szPage), aCksum, aCksum);
				sqlite3Put4byte(&aFrame[16], (uint)(aCksum[0]));
				sqlite3Put4byte(&aFrame[20], (uint)(aCksum[1]));
			}
			else
			{
				CRuntime.memset(&aFrame[8], (int)(0), (ulong)(16));
			}
		}
		public static uint walFramePgno(Wal pWal, uint iFrame)
		{
			int iHash = (int)(walFramePage((uint)(iFrame)));
			if ((iHash) == (0))
			{
				return (uint)(pWal.apWiData[0][(sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint) + iFrame - 1]);
			}

			return (uint)(pWal.apWiData[iHash][(iFrame - 1 - (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint)))) % 4096]);
		}
		public static int walHashGet(Wal pWal, int iHash, WalHashLoc* pLoc)
		{
			int rc = 0;
			rc = (int)(walIndexPage(pWal, (int)(iHash), &pLoc->aPgno));
			if ((pLoc->aPgno) != null)
			{
				pLoc->aHash = (ushort*)(&pLoc->aPgno[4096]);
				if ((iHash) == (0))
				{
					pLoc->aPgno = &pLoc->aPgno[(sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint)];
					pLoc->iZero = (uint)(0);
				}
				else
				{
					pLoc->iZero = (uint)((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + (iHash - 1) * 4096);
				}
			}
			else if (((rc) == (0)))
			{
				rc = (int)(1);
			}

			return (int)(rc);
		}
		public static int walIndexAppend(Wal pWal, uint iFrame, uint iPage)
		{
			int rc = 0;
			WalHashLoc sLoc = new WalHashLoc();
			rc = (int)(walHashGet(pWal, (int)(walFramePage((uint)(iFrame))), &sLoc));
			if ((rc) == (0))
			{
				int iKey = 0;
				int idx = 0;
				int nCollide = 0;
				idx = (int)(iFrame - sLoc.iZero);
				if ((idx) == (1))
				{
					int nByte = (int)((byte*)(&sLoc.aHash[(4096 * 2)]) - (byte*)(sLoc.aPgno));
					CRuntime.memset((void*)(sLoc.aPgno), (int)(0), (ulong)(nByte));
				}

				if ((sLoc.aPgno[idx - 1]) != 0)
				{
					walCleanupHash(pWal);
				}

				nCollide = (int)(idx);
				for (iKey = (int)(walHash((uint)(iPage))); sLoc.aHash[iKey]; iKey = (int)(walNextHash((int)(iKey))))
				{
					if ((nCollide--) == (0))
						return (int)(sqlite3CorruptError((int)(62131)));
				}

				sLoc.aPgno[idx - 1] = (uint)(iPage);
				((ushort)(idx));
			}

			return (int)(rc);
		}
		public static void walIndexClose(Wal pWal, int isDelete)
		{
			if (((pWal.exclusiveMode) == (2)) || ((pWal.bShmUnreliable) != 0))
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWal.nWiData); i++)
				{
					sqlite3_free((void*)(pWal.apWiData[i]));
					pWal.apWiData[i] = null;
				}
			}

			if (pWal.exclusiveMode != 2)
			{
				sqlite3OsShmUnmap(pWal.pDbFd, (int)(isDelete));
			}
		}
		public static int walIndexPage(Wal pWal, int iPage, uint** ppPage)
		{
			if (((pWal.nWiData) <= (iPage)) || ((*ppPage = pWal.apWiData[iPage]) == (null)))
			{
				return (int)(walIndexPageRealloc(pWal, (int)(iPage), ppPage));
			}

			return (int)(0);
		}
		public static int walIndexPageRealloc(Wal pWal, int iPage, uint** ppPage)
		{
			int rc = (int)(0);
			if ((pWal.nWiData) <= (iPage))
			{
				long nByte = (long)(sizeof(uint) * (iPage + 1));
				uint** apNew;
				apNew = (uint**)(sqlite3Realloc((void*)(pWal.apWiData), (ulong)(nByte)));
				if (apNew == null)
				{
					*ppPage = null;
					return (int)(7);
				}

				CRuntime.memset((void*)(&apNew[pWal.nWiData]), (int)(0), (ulong)(sizeof(uint) * (iPage + 1 - pWal.nWiData)));
				pWal.apWiData = apNew;
				pWal.nWiData = (int)(iPage + 1);
			}

			if ((pWal.exclusiveMode) == (2))
			{
				pWal.apWiData[iPage] = (uint*)(sqlite3MallocZero((ulong)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint))));
				if (pWal.apWiData[iPage] == null)
					rc = (int)(7);
			}
			else
			{
				rc = (int)(sqlite3OsShmMap(pWal.pDbFd, (int)(iPage), (int)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)), (int)(pWal.writeLock), (void**)(&pWal.apWiData[iPage])));
				if ((rc) == (0))
				{
					if (((iPage) > (0)) && ((sqlite3FaultSim((int)(600))) != 0))
						rc = (int)(7);
				}
				else if ((rc & 0xff) == (8))
				{
					pWal.readOnly |= (byte)(2);
					if ((rc) == (8))
					{
						rc = (int)(0);
					}
				}
			}

			*ppPage = pWal.apWiData[iPage];
			return (int)(rc);
		}
		public static int walIndexReadHdr(Wal pWal, int* pChanged)
		{
			int rc = 0;
			int badHdr = 0;
			uint* page0;
			rc = (int)(walIndexPage(pWal, (int)(0), &page0));
			if (rc != 0)
			{
				if ((rc) == (8 | (5 << 8)))
				{
					pWal.bShmUnreliable = (byte)(1);
					pWal.exclusiveMode = (byte)(2);
					*pChanged = (int)(1);
				}
				else
				{
					return (int)(rc);
				}
			}
			else
			{
			}

			badHdr = (int)((page0) != 0 ? walIndexTryHdr(pWal, pChanged) : 1);
			if ((badHdr) != 0)
			{
				if (((pWal.bShmUnreliable) == (0)) && ((pWal.readOnly & 2) != 0))
				{
					if ((0) == (rc = (int)(walLockShared(pWal, (int)(0)))))
					{
						walUnlockShared(pWal, (int)(0));
						rc = (int)(8 | (1 << 8));
					}
				}
				else
				{
					int bWriteLock = (int)(pWal.writeLock);
					if (((bWriteLock) != 0) || ((0) == (rc = (int)(walLockExclusive((pWal), (int)(0), (int)(1))))))
					{
						pWal.writeLock = (byte)(1);
						if ((0) == (rc = (int)(walIndexPage(pWal, (int)(0), &page0))))
						{
							badHdr = (int)(walIndexTryHdr(pWal, pChanged));
							if ((badHdr) != 0)
							{
								rc = (int)(walIndexRecover(pWal));
								*pChanged = (int)(1);
							}
						}

						if ((bWriteLock) == (0))
						{
							pWal.writeLock = (byte)(0);
							walUnlockExclusive(pWal, (int)(0), (int)(1));
						}
					}
				}
			}

			if (((badHdr) == (0)) && (pWal.hdr.iVersion != 3007000))
			{
				rc = (int)(sqlite3CantopenError((int)(63426)));
			}

			if ((pWal.bShmUnreliable) != 0)
			{
				if (rc != 0)
				{
					walIndexClose(pWal, (int)(0));
					pWal.bShmUnreliable = (byte)(0);
					if ((rc) == (10 | (2 << 8)))
						rc = (int)(-1);
				}

				pWal.exclusiveMode = (byte)(0);
			}

			return (int)(rc);
		}
		public static int walIndexRecover(Wal pWal)
		{
			int rc = 0;
			long nSize = 0;
			uint* aFrameCksum = stackalloc uint[] { 0, 0 };
			int iLock = 0;
			iLock = (int)(1 + pWal.ckptLock);
			rc = (int)(walLockExclusive(pWal, (int)(iLock), (int)((3 + (0)) - iLock)));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			CRuntime.memset(&pWal.hdr, (int)(0), (ulong)(sizeof(WalIndexHdr)));
			rc = (int)(sqlite3OsFileSize(pWal.pWalFd, &nSize));
			if (rc != 0)
			{
				goto recovery_error;
			}

			if ((nSize) > (32))
			{
				byte* aBuf = stackalloc byte[32];
				uint* aPrivate = null;
				byte* aFrame = null;
				int szFrame = 0;
				byte* aData;
				int szPage = 0;
				uint magic = 0;
				uint version = 0;
				int isValid = 0;
				uint iPg = 0;
				uint iLastFrame = 0;
				rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(32), (long)(0)));
				if (rc != 0)
				{
					goto recovery_error;
				}

				magic = (uint)(sqlite3Get4byte(&aBuf[0]));
				szPage = (int)(sqlite3Get4byte(&aBuf[8]));
				if (((((magic & 0xFFFFFFFE) != 0x377f0682) || ((szPage & (szPage - 1)) != 0)) || ((szPage) > (65536))) || ((szPage) < (512)))
				{
					goto finished;
				}

				pWal.hdr.bigEndCksum = ((byte)(magic & 0x00000001));
				pWal.szPage = (uint)(szPage);
				pWal.nCkpt = (uint)(sqlite3Get4byte(&aBuf[12]));
				CRuntime.memcpy(&pWal.hdr.aSalt, &aBuf[16], (ulong)(8));
				walChecksumBytes(((pWal.hdr.bigEndCksum) == (0) ? 1 : 0), aBuf, (int)(32 - 2 * 4), null, pWal.hdr.aFrameCksum);
				if ((pWal.hdr.aFrameCksum[0] != sqlite3Get4byte(&aBuf[24])) || (pWal.hdr.aFrameCksum[1] != sqlite3Get4byte(&aBuf[28])))
				{
					goto finished;
				}

				version = (uint)(sqlite3Get4byte(&aBuf[4]));
				if (version != 3007000)
				{
					rc = (int)(sqlite3CantopenError((int)(62263)));
					goto finished;
				}

				szFrame = (int)(szPage + 24);
				aFrame = (byte*)(sqlite3_malloc64((ulong)(szFrame + (sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)))));
				if (aFrame == null)
				{
					rc = (int)(7);
					goto recovery_error;
				}

				aData = &aFrame[24];
				aPrivate = (uint*)(&aData[szPage]);
				iLastFrame = (uint)((nSize - 32) / szFrame);
				for (iPg = (uint)(0); (iPg) <= ((uint)(walFramePage((uint)(iLastFrame)))); iPg++)
				{
					uint* aShare;
					uint iFrame = 0;
					uint iLast = (uint)((iLastFrame) < ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + iPg * 4096) ? (iLastFrame) : ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + iPg * 4096));
					uint iFirst = (uint)(1 + ((iPg) == (0) ? 0 : (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + (iPg - 1) * 4096));
					uint nHdr = 0;
					uint nHdr32 = 0;
					rc = (int)(walIndexPage(pWal, (int)(iPg), &aShare));
					if ((aShare) == (null))
						break;
					pWal.apWiData[iPg] = aPrivate;
					for (iFrame = (uint)(iFirst); (iFrame) <= (iLast); iFrame++)
					{
						long iOffset = (long)(32 + ((iFrame) - 1) * (long)((szPage) + 24));
						uint pgno = 0;
						uint nTruncate = 0;
						rc = (int)(sqlite3OsRead(pWal.pWalFd, aFrame, (int)(szFrame), (long)(iOffset)));
						if (rc != 0)
							break;
						isValid = (int)(walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame));
						if (isValid == 0)
							break;
						rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(pgno)));
						if ((rc != 0))
							break;
						if ((nTruncate) != 0)
						{
							pWal.hdr.mxFrame = (uint)(iFrame);
							pWal.hdr.nPage = (uint)(nTruncate);
							pWal.hdr.szPage = ((ushort)((szPage & 0xff00) | (szPage >> 16)));
							aFrameCksum[0] = (uint)(pWal.hdr.aFrameCksum[0]);
							aFrameCksum[1] = (uint)(pWal.hdr.aFrameCksum[1]);
						}
					}

					pWal.apWiData[iPg] = aShare;
					nHdr = (uint)((iPg) == (0) ? (sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) : 0);
					nHdr32 = (uint)(nHdr / sizeof(uint));
					CRuntime.memcpy(&aShare[nHdr32], &aPrivate[nHdr32], (ulong)((sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)) - nHdr));
					if ((iFrame) <= (iLast))
						break;
				}

				sqlite3_free(aFrame);
			}

		finished:
			; if ((rc) == (0)) { volatile WalCkptInfo* pInfo; int i = 0; pWal.hdr.aFrameCksum[0] = (uint)(aFrameCksum[0]); pWal.hdr.aFrameCksum[1] = (uint)(aFrameCksum[1]); walIndexWriteHdr(pWal); pInfo = walCkptInfo(pWal); pInfo->nBackfill = (uint)(0); pInfo->nBackfillAttempted = (uint)(pWal.hdr.mxFrame); pInfo->aReadMark[0] = (uint)(0); for (i = (int)(1); (i) < (8 - 3); i++) { rc = (int)(walLockExclusive(pWal, (int)(3 + (i)), (int)(1))); if ((rc) == (0)) { if (((i) == (1)) && ((pWal.hdr.mxFrame) != 0)) { pInfo->aReadMark[i] = (uint)(pWal.hdr.mxFrame); } else { pInfo->aReadMark[i] = (uint)(0xffffffff); } walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1)); } else if (rc != 5) { goto recovery_error; } } if ((pWal.hdr.nPage) != 0) { sqlite3_log((int)(27 | (1 << 8)), "recovered %d frames from WAL file %s", (uint)(pWal.hdr.mxFrame), pWal.zWalName); } }
		recovery_error:
			;
			walUnlockExclusive(pWal, (int)(iLock), (int)((3 + (0)) - iLock));
			return (int)(rc);
		}
		public static int walIndexTryHdr(Wal pWal, int* pChanged)
		{
			uint* aCksum = stackalloc uint[2];
			WalIndexHdr h1 = new WalIndexHdr(); WalIndexHdr h2 = new WalIndexHdr();
			volatile WalIndexHdr* aHdr;
			aHdr = walIndexHdr(pWal);
			CRuntime.memcpy(&h1, (void*)(&aHdr[0]), (ulong)(sizeof(WalIndexHdr)));
			walShmBarrier(pWal);
			CRuntime.memcpy(&h2, (void*)(&aHdr[1]), (ulong)(sizeof(WalIndexHdr)));
			if (memcmp(&h1, &h2, (ulong)(sizeof(WalIndexHdr))) != 0)
			{
				return (int)(1);
			}

			if ((h1.isInit) == (0))
			{
				return (int)(1);
			}

			walChecksumBytes((int)(1), (byte*)(&h1), (int)(sizeof(WalIndexHdr) - 2 * sizeof(uint)), null, aCksum);
			if ((aCksum[0] != h1.aCksum[0]) || (aCksum[1] != h1.aCksum[1]))
			{
				return (int)(1);
			}

			if ((memcmp(&pWal.hdr, &h1, (ulong)(sizeof(WalIndexHdr)))) != 0)
			{
				*pChanged = (int)(1);
				CRuntime.memcpy(&pWal.hdr, &h1, (ulong)(sizeof(WalIndexHdr)));
				pWal.szPage = (uint)((pWal.hdr.szPage & 0xfe00) + ((pWal.hdr.szPage & 0x0001) << 16));
			}

			return (int)(0);
		}
		public static void walIndexWriteHdr(Wal pWal)
		{
			volatile WalIndexHdr* aHdr = walIndexHdr(pWal);
			int nCksum = (int)((ulong)(&((0)->aCksum)));
			pWal.hdr.isInit = (byte)(1);
			pWal.hdr.iVersion = (uint)(3007000);
			walChecksumBytes((int)(1), (byte*)(&pWal.hdr), (int)(nCksum), null, pWal.hdr.aCksum);
			CRuntime.memcpy((void*)(&aHdr[1]), (void*)(&pWal.hdr), (ulong)(sizeof(WalIndexHdr)));
			walShmBarrier(pWal);
			CRuntime.memcpy((void*)(&aHdr[0]), (void*)(&pWal.hdr), (ulong)(sizeof(WalIndexHdr)));
		}
		public static int walIteratorInit(Wal pWal, uint nBackfill, WalIterator pp)
		{
			WalIterator p;
			int nSegment = 0;
			uint iLast = 0;
			long nByte = 0;
			int i = 0;
			ushort* aTmp;
			int rc = (int)(0);
			iLast = (uint)(pWal.hdr.mxFrame);
			nSegment = (int)(walFramePage((uint)(iLast)) + 1);
			nByte = (long)(sizeof(WalIterator) + (nSegment - 1) * sizeof(WalSegment) + iLast * sizeof(ushort));
			p = (WalIterator)(sqlite3_malloc64((ulong)(nByte)));
			if (p == null)
			{
				return (int)(7);
			}

			CRuntime.memset(p, (int)(0), (ulong)(nByte));
			p.nSegment = (int)(nSegment);
			aTmp = (ushort*)(sqlite3_malloc64((ulong)(sizeof(ushort) * ((iLast) > (4096) ? 4096 : iLast))));
			if (aTmp == null)
			{
				rc = (int)(7);
			}

			for (i = (int)(walFramePage((uint)(nBackfill + 1))); ((rc) == (0)) && ((i) < (nSegment)); i++)
			{
				WalHashLoc sLoc = new WalHashLoc();
				rc = (int)(walHashGet(pWal, (int)(i), &sLoc));
				if ((rc) == (0))
				{
					int j = 0;
					int nEntry = 0;
					ushort* aIndex;
					if ((i + 1) == (nSegment))
					{
						nEntry = ((int)(iLast - sLoc.iZero));
					}
					else
					{
						nEntry = ((int)((uint*)(sLoc.aHash) - sLoc.aPgno));
					}

					aIndex = &((ushort*)(&p.aSegment[p.nSegment]))[sLoc.iZero];
					sLoc.iZero++;
					for (j = (int)(0); (j) < (nEntry); j++)
					{
						aIndex[j] = ((ushort)(j));
					}

					walMergesort(sLoc.aPgno, aTmp, aIndex, &nEntry);
					p.aSegment[i].iZero = (int)(sLoc.iZero);
					p.aSegment[i].nEntry = (int)(nEntry);
					p.aSegment[i].aIndex = aIndex;
					p.aSegment[i].aPgno = sLoc.aPgno;
				}
			}

			sqlite3_free(aTmp);
			if (rc != 0)
			{
				walIteratorFree(p);
				p = null;
			}

			pp = p;
			return (int)(rc);
		}
		public static void walLimitSize(Wal pWal, long nMax)
		{
			long sz = 0;
			int rx = 0;
			sqlite3BeginBenignMalloc();
			rx = (int)(sqlite3OsFileSize(pWal.pWalFd, &sz));
			if (((rx) == (0)) && ((sz) > (nMax)))
			{
				rx = (int)(sqlite3OsTruncate(pWal.pWalFd, (long)(nMax)));
			}

			sqlite3EndBenignMalloc();
			if ((rx) != 0)
			{
				sqlite3_log((int)(rx), "cannot limit WAL size: %s", pWal.zWalName);
			}
		}
		public static int walLockExclusive(Wal pWal, int lockIdx, int n)
		{
			int rc = 0;
			if ((pWal.exclusiveMode) != 0)
				return (int)(0);
			rc = (int)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(n), (int)(2 | 8)));
			return (int)(rc);
		}
		public static int walLockShared(Wal pWal, int lockIdx)
		{
			int rc = 0;
			if ((pWal.exclusiveMode) != 0)
				return (int)(0);
			rc = (int)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(1), (int)(2 | 4)));
			return (int)(rc);
		}
		public static int walPagesize(Wal pWal)
		{
			return (int)((pWal.hdr.szPage & 0xfe00) + ((pWal.hdr.szPage & 0x0001) << 16));
		}
		public static void walRestartHdr(Wal pWal, uint salt1)
		{
			volatile WalCkptInfo* pInfo = walCkptInfo(pWal);
			int i = 0;
			uint* aSalt = pWal.hdr.aSalt;
			pWal.nCkpt++;
			pWal.hdr.mxFrame = (uint)(0);
			sqlite3Put4byte((byte*)(&aSalt[0]), (uint)(1 + sqlite3Get4byte((byte*)(&aSalt[0]))));
			CRuntime.memcpy(&pWal.hdr.aSalt[1], &salt1, (ulong)(4));
			walIndexWriteHdr(pWal);
			(0);
			pInfo->nBackfillAttempted = (uint)(0);
			pInfo->aReadMark[1] = (uint)(0);
			for (i = (int)(2); (i) < (8 - 3); i++)
			{
				pInfo->aReadMark[i] = (uint)(0xffffffff);
			}
		}
		public static int walRestartLog(Wal pWal)
		{
			int rc = (int)(0);
			int cnt = 0;
			if ((pWal.readLock) == (0))
			{
				volatile WalCkptInfo* pInfo = walCkptInfo(pWal);
				if ((pInfo->nBackfill) > (0))
				{
					uint salt1 = 0;
					sqlite3_randomness((int)(4), &salt1);
					rc = (int)(walLockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1)));
					if ((rc) == (0))
					{
						walRestartHdr(pWal, (uint)(salt1));
						walUnlockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1));
					}
					else if (rc != 5)
					{
						return (int)(rc);
					}
				}

				walUnlockShared(pWal, (int)(3 + (0)));
				pWal.readLock = (short)(-1);
				cnt = (int)(0);
				do
				{
					int notUsed = 0;
					rc = (int)(walTryBeginRead(pWal, &notUsed, (int)(1), (int)(++cnt)));
				}
				while ((rc) == (-1));
			}

			return (int)(rc);
		}
		public static int walRewriteChecksums(Wal pWal, uint iLast)
		{
			int szPage = (int)(pWal.szPage);
			int rc = (int)(0);
			byte* aBuf;
			byte* aFrame = stackalloc byte[24];
			uint iRead = 0;
			long iCksumOff = 0;
			aBuf = sqlite3_malloc((int)(szPage + 24));
			if ((aBuf) == (null))
				return (int)(7);
			if ((pWal.iReCksum) == (1))
			{
				iCksumOff = (long)(24);
			}
			else
			{
				iCksumOff = (long)((32 + ((pWal.iReCksum - 1) - 1) * (long)((szPage) + 24)) + 16);
			}

			rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(sizeof(uint) * 2), (long)(iCksumOff)));
			pWal.hdr.aFrameCksum[0] = (uint)(sqlite3Get4byte(aBuf));
			pWal.hdr.aFrameCksum[1] = (uint)(sqlite3Get4byte(&aBuf[sizeof(uint)]));
			iRead = (uint)(pWal.iReCksum);
			pWal.iReCksum = (uint)(0);
			for (; ((rc) == (0)) && ((iRead) <= (iLast)); iRead++)
			{
				long iOff = (long)(32 + ((iRead) - 1) * (long)((szPage) + 24));
				rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(szPage + 24), (long)(iOff)));
				if ((rc) == (0))
				{
					uint iPgno = 0;
					uint nDbSize = 0;
					iPgno = (uint)(sqlite3Get4byte(aBuf));
					nDbSize = (uint)(sqlite3Get4byte(&aBuf[4]));
					walEncodeFrame(pWal, (uint)(iPgno), (uint)(nDbSize), &aBuf[24], aFrame);
					rc = (int)(sqlite3OsWrite(pWal.pWalFd, aFrame, (int)(24 * sizeof(byte)), (long)(iOff)));
				}
			}

			sqlite3_free(aBuf);
			return (int)(rc);
		}
		public static void walShmBarrier(Wal pWal)
		{
			if (pWal.exclusiveMode != 2)
			{
				sqlite3OsShmBarrier(pWal.pDbFd);
			}
		}
		public static int walTryBeginRead(Wal pWal, int* pChanged, int useWal, int cnt)
		{
			volatile WalCkptInfo* pInfo;
			uint mxReadMark = 0;
			int mxI = 0;
			int i = 0;
			int rc = (int)(0);
			uint mxFrame = 0;
			if ((cnt) > (5))
			{
				int nDelay = (int)(1);
				if ((cnt) > (100))
				{
					return (int)(15);
				}

				if ((cnt) >= (10))
					nDelay = (int)((cnt - 9) * (cnt - 9) * 39);
				sqlite3OsSleep(pWal.pVfs, (int)(nDelay));
			}

			if (useWal == 0)
			{
				if ((pWal.bShmUnreliable) == (0))
				{
					rc = (int)(walIndexReadHdr(pWal, pChanged));
				}

				if ((rc) == (5))
				{
					if ((pWal.apWiData[0]) == (null))
					{
						rc = (int)(-1);
					}
					else if ((0) == (rc = (int)(walLockShared(pWal, (int)(2)))))
					{
						walUnlockShared(pWal, (int)(2));
						rc = (int)(-1);
					}
					else if ((rc) == (5))
					{
						rc = (int)(5 | (1 << 8));
					}
				}

				if (rc != 0)
				{
					return (int)(rc);
				}
				else if ((pWal.bShmUnreliable) != 0)
				{
					return (int)(walBeginShmUnreliable(pWal, pChanged));
				}
			}

			pInfo = walCkptInfo(pWal);
			if ((useWal == 0) && ((0) == (pWal.hdr.mxFrame)))
			{
				rc = (int)(walLockShared(pWal, (int)(3 + (0))));
				walShmBarrier(pWal);
				if ((rc) == (0))
				{
					if ((memcmp((void*)(walIndexHdr(pWal)), &pWal.hdr, (ulong)(sizeof(WalIndexHdr)))) != 0)
					{
						walUnlockShared(pWal, (int)(3 + (0)));
						return (int)(-1);
					}

					pWal.readLock = (short)(0);
					return (int)(0);
				}
				else if (rc != 5)
				{
					return (int)(rc);
				}
			}

			mxReadMark = (uint)(0);
			mxI = (int)(0);
			mxFrame = (uint)(pWal.hdr.mxFrame);
			for (i = (int)(1); (i) < (8 - 3); i++)
			{
				uint thisMark = (uint)(0);
				if (((mxReadMark) <= (thisMark)) && ((thisMark) <= (mxFrame)))
				{
					mxReadMark = (uint)(thisMark);
					mxI = (int)(i);
				}
			}

			if (((pWal.readOnly & 2) == (0)) && (((mxReadMark) < (mxFrame)) || ((mxI) == (0))))
			{
				for (i = (int)(1); (i) < (8 - 3); i++)
				{
					rc = (int)(walLockExclusive(pWal, (int)(3 + (i)), (int)(1)));
					if ((rc) == (0))
					{
						(mxFrame);
						mxReadMark = (uint)(mxFrame);
						mxI = (int)(i);
						walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1));
						break;
					}
					else if (rc != 5)
					{
						return (int)(rc);
					}
				}
			}

			if ((mxI) == (0))
			{
				return (int)((rc) == (5) ? (-1) : (8 | (5 << 8)));
			}

			rc = (int)(walLockShared(pWal, (int)(3 + (mxI))));
			if ((rc) != 0)
			{
				return (int)((rc) == (5) ? (-1) : rc);
			}

			pWal.minFrame = (uint)(0 + 1);
			walShmBarrier(pWal);
			if ((0 != mxReadMark) || ((memcmp((void*)(walIndexHdr(pWal)), &pWal.hdr, (ulong)(sizeof(WalIndexHdr)))) != 0))
			{
				walUnlockShared(pWal, (int)(3 + (mxI)));
				return (int)(-1);
			}
			else
			{
				pWal.readLock = ((short)(mxI));
			}

			return (int)(rc);
		}
		public static void walUnlockExclusive(Wal pWal, int lockIdx, int n)
		{
			if ((pWal.exclusiveMode) != 0)
				return;
			(void)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(n), (int)(1 | 8)));
		}
		public static void walUnlockShared(Wal pWal, int lockIdx)
		{
			if ((pWal.exclusiveMode) != 0)
				return;
			(void)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(1), (int)(1 | 4)));
		}
	}
}