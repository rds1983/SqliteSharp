// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int jsonLabelCompare(JsonNode* pNode, sbyte* zKey, uint nKey)
		{
			if ((pNode->jnFlags & 0x01) != 0)
			{
				if (pNode->n != nKey)
					return (int)(0);
				return ((CRuntime.strncmp(pNode->u.zJContent, zKey, (ulong)(nKey))) == (0) ? 1 : 0);
			}
			else
			{
				if (pNode->n != nKey + 2)
					return (int)(0);
				return ((CRuntime.strncmp(pNode->u.zJContent + 1, zKey, (ulong)(nKey))) == (0) ? 1 : 0);
			}
		}
		public static uint jsonNodeSize(JsonNode* pNode)
		{
			return (uint)((pNode->eType) >= (6) ? pNode->n + 1 : 1);
		}
		public static void jsonRemoveAllNulls(JsonNode* pNode)
		{
			int i = 0; int n = 0;
			n = (int)(pNode->n);
			for (i = (int)(2); (i) <= (n); i += (int)(jsonNodeSize(&pNode[i]) + 1))
			{
				switch (pNode[i].eType)
				{
					case 0:
						pNode[i].jnFlags |= (byte)(0x04);
						break;
					case 7:
						jsonRemoveAllNulls(&pNode[i]);
						break;
				}
			}
		}
		public static void jsonRenderNode(JsonNode* pNode, JsonString pOut, sqlite3_value aReplace)
		{
			if ((pNode->jnFlags & (0x08 | 0x10)) != 0)
			{
				if (((pNode->jnFlags & 0x08) != 0) && (aReplace != null))
				{
					jsonAppendValue(pOut, aReplace[pNode->u.iReplace]);
					return;
				}

				pNode = pNode->u.pPatch;
			}

			switch (pNode->eType)
			{
				default:
					{
						jsonAppendRaw(pOut, "null", (uint)(4));
						break;
					}

				case 1:
					{
						jsonAppendRaw(pOut, "true", (uint)(4));
						break;
					}

				case 2:
					{
						jsonAppendRaw(pOut, "false", (uint)(5));
						break;
					}

				case 5:
					{
						if ((pNode->jnFlags & 0x01) != 0)
						{
							jsonAppendString(pOut, pNode->u.zJContent, (uint)(pNode->n));
							break;
						}
					}

				case 4:
				case 3:
					{
						jsonAppendRaw(pOut, pNode->u.zJContent, (uint)(pNode->n));
						break;
					}

				case 6:
					{
						uint j = (uint)(1);
						jsonAppendChar(pOut, (sbyte)(91));
						for (; ; )
						{
							while ((j) <= (pNode->n))
							{
								if ((pNode[j].jnFlags & 0x04) == (0))
								{
									jsonAppendSeparator(pOut);
									jsonRenderNode(&pNode[j], pOut, aReplace);
								}

								j += (uint)(jsonNodeSize(&pNode[j]));
							}

							if ((pNode->jnFlags & 0x20) == (0))
								break;
							pNode = &pNode[pNode->u.iAppend];
							j = (uint)(1);
						}

						jsonAppendChar(pOut, (sbyte)(93));
						break;
					}

				case 7:
					{
						uint j = (uint)(1);
						jsonAppendChar(pOut, (sbyte)(123));
						for (; ; )
						{
							while ((j) <= (pNode->n))
							{
								if ((pNode[j + 1].jnFlags & 0x04) == (0))
								{
									jsonAppendSeparator(pOut);
									jsonRenderNode(&pNode[j], pOut, aReplace);
									jsonAppendChar(pOut, (sbyte)(58));
									jsonRenderNode(&pNode[j + 1], pOut, aReplace);
								}

								j += (uint)(1 + jsonNodeSize(&pNode[j + 1]));
							}

							if ((pNode->jnFlags & 0x20) == (0))
								break;
							pNode = &pNode[pNode->u.iAppend];
							j = (uint)(1);
						}

						jsonAppendChar(pOut, (sbyte)(125));
						break;
					}
			}
		}
		public static void jsonReturn(JsonNode* pNode, sqlite3_context pCtx, sqlite3_value aReplace)
		{
			switch (pNode->eType)
			{
				default:
					{
						sqlite3_result_null(pCtx);
						break;
					}

				case 1:
					{
						sqlite3_result_int(pCtx, (int)(1));
						break;
					}

				case 2:
					{
						sqlite3_result_int(pCtx, (int)(0));
						break;
					}

				case 3:
					{
						long i = (long)(0);
						sbyte* z;
						z = pNode->u.zJContent;
						if ((z[0]) == (45))
						{
							z++;
						}

						while (((z[0]) >= (48)) && ((z[0]) <= (57)))
						{
							uint v = (uint)(*(z++) - 48);
							if ((i) >= ((0xffffffff | (((long)(0x7fffffff)) << 32)) / 10))
							{
								if ((i) > ((0xffffffff | (((long)(0x7fffffff)) << 32)) / 10))
									goto int_as_real;
								if (((z[0]) >= (48)) && ((z[0]) <= (57)))
									goto int_as_real;
								if ((v) == (9))
									goto int_as_real;
								if ((v) == (8))
								{
									if ((pNode->u.zJContent[0]) == (45))
									{
										sqlite3_result_int64(pCtx, (long)(((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))));
										goto int_done;
									}
									else
									{
										goto int_as_real;
									}
								}
							}

							i = (long)(i * 10 + v);
						}

						if ((pNode->u.zJContent[0]) == (45))
						{
							i = (long)(-i);
						}

						sqlite3_result_int64(pCtx, (long)(i));
					int_done:
						;
						break;
					int_as_real:
						;
					}

				case 4:
					{
						double r = 0;
						sbyte* z;
						z = pNode->u.zJContent;
						sqlite3AtoF(z, &r, (int)(sqlite3Strlen30(z)), (byte)(1));
						sqlite3_result_double(pCtx, (double)(r));
						break;
					}

				case 5:
					{
						if ((pNode->jnFlags & 0x02) == (0))
						{
							sqlite3_result_text(pCtx, pNode->u.zJContent + 1, (int)(pNode->n - 2), ((Void(Void * ))(-1)));
						}
						else
						{
							uint i = 0;
							uint n = (uint)(pNode->n);
							sbyte* z;
							sbyte* zOut;
							uint j = 0;
							z = pNode->u.zJContent;
							zOut = sqlite3_malloc((int)(n + 1));
							if ((zOut) == (null))
							{
								sqlite3_result_error_nomem(pCtx);
								break;
							}

							for (i = (uint)(1), j = (uint)(0); (i) < (n - 1); i++)
							{
								sbyte c = (sbyte)(z[i]);
								if (c != 92)
								{
									zOut[j++] = (sbyte)(c);
								}
								else
								{
									c = (sbyte)(z[++i]);
									if ((c) == (117))
									{
										uint v = (uint)(jsonHexToInt4(z + i + 1));
										i += (uint)(4);
										if ((v) == (0))
											break;
										if ((v) <= (0x7f))
										{
											zOut[j++] = ((sbyte)(v));
										}
										else if ((v) <= (0x7ff))
										{
											zOut[j++] = ((sbyte)(0xc0 | (v >> 6)));
											zOut[j++] = (sbyte)(0x80 | (v & 0x3f));
										}
										else
										{
											uint vlo = 0;
											if ((((((v & 0xfc00) == (0xd800)) && ((i) < (n - 6))) && ((z[i + 1]) == (92))) && ((z[i + 2]) == (117))) && (((vlo = (uint)(jsonHexToInt4(z + i + 3))) & 0xfc00) == (0xdc00)))
											{
												v = (uint)(((v & 0x3ff) << 10) + (vlo & 0x3ff) + 0x10000);
												i += (uint)(6);
												zOut[j++] = (sbyte)(0xf0 | (v >> 18));
												zOut[j++] = (sbyte)(0x80 | ((v >> 12) & 0x3f));
												zOut[j++] = (sbyte)(0x80 | ((v >> 6) & 0x3f));
												zOut[j++] = (sbyte)(0x80 | (v & 0x3f));
											}
											else
											{
												zOut[j++] = (sbyte)(0xe0 | (v >> 12));
												zOut[j++] = (sbyte)(0x80 | ((v >> 6) & 0x3f));
												zOut[j++] = (sbyte)(0x80 | (v & 0x3f));
											}
										}
									}
									else
									{
										if ((c) == (98))
										{
											c = (sbyte)(8);
										}
										else if ((c) == (102))
										{
											c = (sbyte)(12);
										}
										else if ((c) == (110))
										{
											c = (sbyte)(10);
										}
										else if ((c) == (114))
										{
											c = (sbyte)(13);
										}
										else if ((c) == (116))
										{
											c = (sbyte)(9);
										}

										zOut[j++] = (sbyte)(c);
									}
								}
							}

							zOut[j] = (sbyte)(0);
							sqlite3_result_text(pCtx, zOut, (int)(j), sqlite3_free);
						}

						break;
					}

				case 6:
				case 7:
					{
						jsonReturnJson(pNode, pCtx, aReplace);
						break;
					}
			}
		}
		public static void jsonReturnJson(JsonNode* pNode, sqlite3_context pCtx, sqlite3_value aReplace)
		{
			JsonString s = new JsonString();
			jsonInit(s, pCtx);
			jsonRenderNode(pNode, s, aReplace);
			jsonResult(s);
			sqlite3_result_subtype(pCtx, (uint)(74));
		}
	}
}