// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int addAggInfoColumn(sqlite3 db, AggInfo pInfo)
		{
			int i = 0;
			pInfo.aCol = sqlite3ArrayAllocate(db, pInfo.aCol, (int)(sizeof(AggInfo_col)), &pInfo.nColumn, &i);
			return (int)(i);
		}
		public static int addAggInfoFunc(sqlite3 db, AggInfo pInfo)
		{
			int i = 0;
			pInfo.aFunc = sqlite3ArrayAllocate(db, pInfo.aFunc, (int)(sizeof(AggInfo_func)), &pInfo.nFunc, &i);
			return (int)(i);
		}
		public static void addToVTrans(sqlite3 db, VTable pVTab)
		{
			db.aVTrans[db.nVTrans++] = pVTab;
			sqlite3VtabLock(pVTab);
		}
		public static void agginfoFree(sqlite3 db, AggInfo p)
		{
			sqlite3DbFree(db, p.aCol);
			sqlite3DbFree(db, p.aFunc);
			sqlite3DbFreeNN(db, p);
		}
		public static int apiHandleError(sqlite3 db, int rc)
		{
			if (((db.mallocFailed) != 0) || ((rc) == (10 | (12 << 8))))
			{
				sqlite3OomClear(db);
				sqlite3Error(db, (int)(7));
				return (int)(7);
			}

			return (int)(rc & db.errMask);
		}
		public static int areDoubleQuotedStringsEnabled(sqlite3 db, NameContext pTopNC)
		{
			if ((db.init.busy) != 0)
				return (int)(1);
			if ((pTopNC.ncFlags & 0x010000) != 0)
			{
				if (((sqlite3WritableSchema(db)) != 0) && ((db.flags & 0x40000000) != 0))
				{
					return (int)(1);
				}

				return (int)((db.flags & 0x20000000) != 0);
			}
			else
			{
				return (int)((db.flags & 0x40000000) != 0);
			}
		}
		public static void btreeEnterAll(sqlite3 db)
		{
			int i = 0;
			int skipOk = (int)(1);
			Btree p;
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				p = db.aDb[i].pBt;
				if (((p) != null) && ((p.sharable) != 0))
				{
					sqlite3BtreeEnter(p);
					skipOk = (int)(0);
				}
			}

			db.noSharedCache = (byte)(skipOk);
		}
		public static void btreeLeaveAll(sqlite3 db)
		{
			int i = 0;
			Btree p;
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				p = db.aDb[i].pBt;
				if ((p) != null)
					sqlite3BtreeLeave(p);
			}
		}
		public static void callCollNeeded(sqlite3 db, int enc, sbyte* zName)
		{
			if ((db.xCollNeeded) != null)
			{
				sbyte* zExternal = sqlite3DbStrDup(db, zName);
				if (zExternal == null)
					return;
				db.xCollNeeded(db.pCollNeededArg, db, (int)(enc), zExternal);
				sqlite3DbFree(db, zExternal);
			}

			if ((db.xCollNeeded16) != null)
			{
				sbyte* zExternal;
				sqlite3_value pTmp = sqlite3ValueNew(db);
				sqlite3ValueSetStr(pTmp, (int)(-1), zName, (byte)(1), null);
				zExternal = sqlite3ValueText(pTmp, (byte)(2));
				if ((zExternal) != null)
				{
					db.xCollNeeded16(db.pCollNeededArg, db, (int)((db).enc), zExternal);
				}

				sqlite3ValueFree(pTmp);
			}
		}
		public static void callFinaliser(sqlite3 db, int offset)
		{
			int i = 0;
			if ((db.aVTrans) != null)
			{
				VTable aVTrans = db.aVTrans;
				db.aVTrans = null;
				for (i = (int)(0); (i) < (db.nVTrans); i++)
				{
					VTable pVTab = aVTrans[i];
					sqlite3_vtab p = pVTab.pVtab;
					if ((p) != null)
					{
						delegate23 x;
						x = *(Int(sqlite3_vtab * ))((sbyte*)(p.pModule) + offset);
						if ((x) != null)
							x(p);
					}

					pVTab.iSavepoint = (int)(0);
					sqlite3VtabUnlock(pVTab);
				}

				sqlite3DbFree(db, aVTrans);
				db.nVTrans = (int)(0);
			}
		}
		public static int checkReadTransaction(sqlite3 db, Btree p)
		{
			if (sqlite3BtreeTxnState(p) != 0)
			{
				sqlite3ErrorWithMsg(db, (int)(1), "destination database is in use");
				return (int)(1);
			}

			return (int)(0);
		}
		public static void clearSelect(sqlite3 db, Select p, int bFree)
		{
			while ((p) != null)
			{
				Select pPrior = p.pPrior;
				sqlite3ExprListDelete(db, p.pEList);
				sqlite3SrcListDelete(db, p.pSrc);
				sqlite3ExprDelete(db, p.pWhere);
				sqlite3ExprListDelete(db, p.pGroupBy);
				sqlite3ExprDelete(db, p.pHaving);
				sqlite3ExprListDelete(db, p.pOrderBy);
				sqlite3ExprDelete(db, p.pLimit);
				if ((p.pWith) != null)
					sqlite3WithDelete(db, p.pWith);
				if ((p.pWinDefn) != null)
				{
					sqlite3WindowListDelete(db, p.pWinDefn);
				}

				while ((p.pWin) != null)
				{
					sqlite3WindowUnlinkFromSelect(p.pWin);
				}

				if ((bFree) != 0)
					sqlite3DbFreeNN(db, p);
				p = pPrior;
				bFree = (int)(1);
			}
		}
		public static int connectionIsBusy(sqlite3 db)
		{
			int j = 0;
			if ((db.pVdbe) != null)
				return (int)(1);
			for (j = (int)(0); (j) < (db.nDb); j++)
			{
				Btree pBt = db.aDb[j].pBt;
				if (((pBt) != null) && ((sqlite3BtreeIsInBackup(pBt)) != 0))
					return (int)(1);
			}

			return (int)(0);
		}
		public static int createCollation(sqlite3 db, sbyte* zName, byte enc, void* pCtx, delegate70 xCompare, delegate17 xDel)
		{
			CollSeq pColl;
			int enc2 = 0;
			enc2 = (int)(enc);
			if (((enc2) == (4)) || ((enc2) == (8)))
			{
				enc2 = (int)(2);
			}

			if (((enc2) < (1)) || ((enc2) > (3)))
			{
				return (int)(sqlite3MisuseError((int)(171202)));
			}

			pColl = sqlite3FindCollSeq(db, (byte)(enc2), zName, (int)(0));
			if (((pColl) != null) && ((pColl.xCmp) != null))
			{
				if ((db.nVdbeActive) != 0)
				{
					sqlite3ErrorWithMsg(db, (int)(5), "unable to delete/modify collation sequence due to active statements");
					return (int)(5);
				}

				sqlite3ExpirePreparedStatements(db, (int)(0));
				if ((pColl.enc & ~8) == (enc2))
				{
					CollSeq aColl = sqlite3HashFind(&db.aCollSeq, zName);
					int j = 0;
					for (j = (int)(0); (j) < (3); j++)
					{
						CollSeq p = aColl[j];
						if ((p.enc) == (pColl.enc))
						{
							if ((p.xDel) != null)
							{
								p.xDel(p.pUser);
							}

							p.xCmp = null;
						}
					}
				}
			}

			pColl = sqlite3FindCollSeq(db, (byte)(enc2), zName, (int)(1));
			if ((pColl) == (null))
				return (int)(7);
			pColl.xCmp = xCompare;
			pColl.pUser = pCtx;
			pColl.xDel = xDel;
			pColl.enc = ((byte)(enc2 | (enc & 8)));
			sqlite3Error(db, (int)(0));
			return (int)(0);
		}
		public static int createFunctionApi(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal, delegate69 xValue, delegate68 xInverse, delegate17 xDestroy)
		{
			int rc = (int)(1);
			FuncDestructor pArg = null;
			sqlite3_mutex_enter(db.mutex);
			if ((xDestroy) != null)
			{
				pArg = (FuncDestructor)(sqlite3Malloc((ulong)(sizeof(FuncDestructor))));
				if (pArg == null)
				{
					sqlite3OomFault(db);
					xDestroy(p);
					goto  out
            ;
				}

				pArg.nRef = (int)(0);
				pArg.xDestroy = xDestroy;
				pArg.pUserData = p;
			}

			rc = (int)(sqlite3CreateFunc(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, xValue, xInverse, pArg));
			if (((pArg) != null) && ((pArg.nRef) == (0)))
			{
				xDestroy(p);
				sqlite3_free(pArg);
			}

     out :  ; rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int createModule(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
		{
			int rc = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			(void)(sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			if ((rc != 0) && ((xDestroy) != null))
				xDestroy(pAux);
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static void cteClear(sqlite3 db, Cte pCte)
		{
			sqlite3ExprListDelete(db, pCte.pCols);
			sqlite3SelectDelete(db, pCte.pSelect);
			sqlite3DbFree(db, pCte.zName);
		}
		public static void deleteTable(sqlite3 db, Table pTable)
		{
			Index pIndex; Index pNext;
			for (pIndex = pTable.pIndex; pIndex; pIndex = pNext)
			{
				pNext = pIndex.pNext;
				if ((((db) == (null)) || ((db.pnBytesFreed) == (null))) && (!(((pTable).eTabType) == (1))))
				{
					sbyte* zName = pIndex.zName;
					sqlite3HashInsert(&pIndex.pSchema.idxHash, zName, null);
				}

				sqlite3FreeIndex(db, pIndex);
			}

			if ((((pTable).eTabType) == (0)))
			{
				sqlite3FkDelete(db, pTable);
			}
			else if ((((pTable).eTabType) == (1)))
			{
				sqlite3VtabClear(db, pTable);
			}
			else
			{
				sqlite3SelectDelete(db, pTable.u.view.pSelect);
			}

			sqlite3DeleteColumnNames(db, pTable);
			sqlite3DbFree(db, pTable.zName);
			sqlite3DbFree(db, pTable.zColAff);
			sqlite3ExprListDelete(db, pTable.pCheck);
			sqlite3DbFree(db, pTable);
		}
		public static void disconnectAllVtab(sqlite3 db)
		{
			int i = 0;
			HashElem* p;
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Schema pSchema = db.aDb[i].pSchema;
				if ((pSchema) != null)
				{
					for (p = ((&pSchema.tblHash)->first); p; p = ((p)->next))
					{
						Table pTab = (Table)((p)->data);
						if ((((pTab).eTabType) == (1)))
							sqlite3VtabDisconnect(db, pTab);
					}
				}
			}

			for (p = ((&db.aModule)->first); p; p = ((p)->next))
			{
				Module pMod = (Module)((p)->data);
				if ((pMod.pEpoTab) != null)
				{
					sqlite3VtabDisconnect(db, pMod.pEpoTab);
				}
			}

			sqlite3VtabUnlockList(db);
			sqlite3BtreeLeaveAll(db);
		}
		public static int doWalCallbacks(sqlite3 db)
		{
			int rc = (int)(0);
			int i = 0;
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if ((pBt) != null)
				{
					int nEntry = 0;
					sqlite3BtreeEnter(pBt);
					nEntry = (int)(sqlite3PagerWalCallback(sqlite3BtreePager(pBt)));
					sqlite3BtreeLeave(pBt);
					if ((((nEntry) > (0)) && ((db.xWalCallback) != null)) && ((rc) == (0)))
					{
						rc = (int)(db.xWalCallback(db.pWalArg, db, db.aDb[i].zDbSName, (int)(nEntry)));
					}
				}
			}

			return (int)(rc);
		}
		public static int execSql(sqlite3 db, sbyte** pzErrMsg, sbyte* zSql)
		{
			sqlite3_stmt* pStmt;
			int rc = 0;
			rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, null));
			if (rc != 0)
				return (int)(rc);
			while ((100) == (rc = (int)(sqlite3_step(pStmt))))
			{
				sbyte* zSubSql = (sbyte*)(sqlite3_column_text(pStmt, (int)(0)));
				if (((zSubSql) != null) && (((CRuntime.strncmp(zSubSql, "CRE", (ulong)(3))) == (0)) || ((CRuntime.strncmp(zSubSql, "INS", (ulong)(3))) == (0))))
				{
					rc = (int)(execSql(db, pzErrMsg, zSubSql));
					if (rc != 0)
						break;
				}
			}

			if ((rc) == (101))
				rc = (int)(0);
			if ((rc) != 0)
			{
				sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
			}

			(void)(sqlite3_finalize(pStmt));
			return (int)(rc);
		}
		public static int execSqlF(sqlite3 db, sbyte** pzErrMsg, sbyte* zSql)
		{
			sbyte* z;
			sbyte* ap;
			int rc = 0;
			(__va_start(&ap, zSql));
			z = sqlite3VMPrintf(db, zSql, ap);
			((void)(ap = null));
			if ((z) == (null))
				return (int)(7);
			rc = (int)(execSql(db, pzErrMsg, z));
			sqlite3DbFree(db, z);
			return (int)(rc);
		}
		public static Expr exprDup(sqlite3 db, Expr p, int dupFlags, byte** pzBuffer)
		{
			Expr pNew;
			byte* zAlloc;
			uint staticFlag = 0;
			if ((pzBuffer) != null)
			{
				zAlloc = *pzBuffer;
				staticFlag = (uint)(0x8000000);
			}
			else
			{
				zAlloc = sqlite3DbMallocRawNN(db, (ulong)(dupedExprSize(p, (int)(dupFlags))));
				staticFlag = (uint)(0);
			}

			pNew = (Expr)(zAlloc);
			if ((pNew) != null)
			{
				uint nStructSize = (uint)(dupedExprStructSize(p, (int)(dupFlags)));
				int nNewSize = (int)(nStructSize & 0xfff);
				int nToken = 0;
				if ((!(((p).flags & (0x000400)) != 0)) && ((p.u.zToken) != null))
				{
					nToken = (int)(sqlite3Strlen30(p.u.zToken) + 1);
				}
				else
				{
					nToken = (int)(0);
				}

				if ((dupFlags) != 0)
				{
					CRuntime.memcpy(zAlloc, p, (ulong)(nNewSize));
				}
				else
				{
					uint nSize = (uint)(exprStructSize(p));
					CRuntime.memcpy(zAlloc, p, (ulong)(nSize));
					if ((nSize) < (sizeof(Expr)))
					{
						CRuntime.memset(&zAlloc[nSize], (int)(0), (ulong)(sizeof(Expr) - nSize));
					}
				}

				pNew.flags &= (uint)(~(0x002000 | 0x004000 | 0x8000000 | 0x010000));
				pNew.flags |= (uint)(nStructSize & (0x002000 | 0x004000));
				pNew.flags |= (uint)(staticFlag);
				if ((dupFlags) != 0)
				{
				}

				if ((nToken) != 0)
				{
					sbyte* zToken = pNew.u.zToken = (sbyte*)(&zAlloc[nNewSize]);
					CRuntime.memcpy(zToken, p.u.zToken, (ulong)(nToken));
				}

				if ((0) == ((p.flags | pNew.flags) & (0x004000 | 0x800000)))
				{
					if ((((p).flags & 0x000800) != 0))
					{
						pNew.x.pSelect = sqlite3SelectDup(db, p.x.pSelect, (int)(dupFlags));
					}
					else
					{
						pNew.x.pList = sqlite3ExprListDup(db, p.x.pList, (int)(dupFlags));
					}
				}

				if ((((pNew).flags & (0x002000 | 0x004000 | 0x1000000)) != 0))
				{
					zAlloc += dupedExprNodeSize(p, (int)(dupFlags));
					if (!(((pNew).flags & (0x004000 | 0x800000)) != 0))
					{
						pNew.pLeft = p.pLeft ? exprDup(db, p.pLeft, (int)(0x0001), &zAlloc) : null;
						pNew.pRight = p.pRight ? exprDup(db, p.pRight, (int)(0x0001), &zAlloc) : null;
					}

					if ((((p).flags & (0x1000000)) != 0))
					{
						pNew.y.pWin = sqlite3WindowDup(db, pNew, p.y.pWin);
					}

					if ((pzBuffer) != null)
					{
						*pzBuffer = zAlloc;
					}
				}
				else
				{
					if (!(((p).flags & (0x004000 | 0x800000)) != 0))
					{
						if ((pNew.op) == (178))
						{
							pNew.pLeft = p.pLeft;
						}
						else
						{
							pNew.pLeft = sqlite3ExprDup(db, p.pLeft, (int)(0));
						}

						pNew.pRight = sqlite3ExprDup(db, p.pRight, (int)(0));
					}
				}
			}

			return pNew;
		}
		public static void exprListDeleteNN(sqlite3 db, ExprList pList)
		{
			int i = (int)(pList.nExpr);
			ExprList_item* pItem = pList.a;
			do
			{
				sqlite3ExprDelete(db, pItem->pExpr);
				sqlite3DbFree(db, pItem->zEName);
				pItem++;
			}
			while ((--i) > (0));
			sqlite3DbFreeNN(db, pList);
		}
		public static Expr exprTableColumn(sqlite3 db, Table pTab, int iCursor, short iCol)
		{
			Expr pExpr = sqlite3Expr(db, (int)(167), null);
			if ((pExpr) != null)
			{
				pExpr.y.pTab = pTab;
				pExpr.iTable = (int)(iCursor);
				pExpr.iColumn = (short)(iCol);
			}

			return pExpr;
		}
		public static Btree findBtree(sqlite3 pErrorDb, sqlite3 pDb, sbyte* zDb)
		{
			int i = (int)(sqlite3FindDbName(pDb, zDb));
			if ((i) == (1))
			{
				Parse sParse = new Parse();
				int rc = (int)(0);
				sqlite3ParseObjectInit(sParse, pDb);
				if ((sqlite3OpenTempDatabase(sParse)) != 0)
				{
					sqlite3ErrorWithMsg(pErrorDb, (int)(sParse.rc), "%s", sParse.zErrMsg);
					rc = (int)(1);
				}

				sqlite3DbFree(pErrorDb, sParse.zErrMsg);
				sqlite3ParseObjectReset(sParse);
				if ((rc) != 0)
				{
					return null;
				}
			}

			if ((i) < (0))
			{
				sqlite3ErrorWithMsg(pErrorDb, (int)(1), "unknown database %s", zDb);
				return null;
			}

			return pDb.aDb[i].pBt;
		}
		public static CollSeq findCollSeqEntry(sqlite3 db, sbyte* zName, int create)
		{
			CollSeq pColl;
			pColl = sqlite3HashFind(&db.aCollSeq, zName);
			if (((null) == (pColl)) && ((create) != 0))
			{
				int nName = (int)(sqlite3Strlen30(zName) + 1);
				pColl = sqlite3DbMallocZero(db, (ulong)(3 * sizeof(CollSeq) + nName));
				if ((pColl) != null)
				{
					CollSeq pDel = null;
					pColl[0].zName = (sbyte*)(pColl[3]);
					pColl[0].enc = (byte)(1);
					pColl[1].zName = (sbyte*)(pColl[3]);
					pColl[1].enc = (byte)(2);
					pColl[2].zName = (sbyte*)(pColl[3]);
					pColl[2].enc = (byte)(3);
					CRuntime.memcpy(pColl[0].zName, zName, (ulong)(nName));
					pDel = sqlite3HashInsert(&db.aCollSeq, pColl[0].zName, pColl);
					if (pDel != null)
					{
						sqlite3OomFault(db);
						sqlite3DbFree(db, pDel);
						pColl = null;
					}
				}
			}

			return pColl;
		}
		public static void fkTriggerDelete(sqlite3 dbMem, Trigger p)
		{
			if ((p) != null)
			{
				TriggerStep pStep = p.step_list;
				sqlite3ExprDelete(dbMem, pStep.pWhere);
				sqlite3ExprListDelete(dbMem, pStep.pExprList);
				sqlite3SelectDelete(dbMem, pStep.pSelect);
				sqlite3ExprDelete(dbMem, p.pWhen);
				sqlite3DbFree(dbMem, p);
			}
		}
		public static void freeEphemeralFunction(sqlite3 db, FuncDef pDef)
		{
			if ((pDef.funcFlags & 0x0010) != 0)
			{
				sqlite3DbFreeNN(db, pDef);
			}
		}
		public static void freeIndexInfo(sqlite3 db, sqlite3_index_info* pIdxInfo)
		{
			HiddenIndexInfo pHidden;
			int i = 0;
			pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			for (i = (int)(0); (i) < (pIdxInfo->nConstraint); i++)
			{
				sqlite3ValueFree(pHidden.aRhs[i]);
				pHidden.aRhs[i] = null;
			}

			sqlite3DbFree(db, pIdxInfo);
		}
		public static void freeP4(sqlite3 db, int p4type, void* p4)
		{
			switch (p4type)
			{
				case (-16):
					{
						freeP4FuncCtx(db, (sqlite3_context)(p4));
						break;
					}

				case (-13):
				case (-14):
				case (-7):
				case (-17):
				case (-15):
					{
						sqlite3DbFree(db, p4);
						break;
					}

				case (-9):
					{
						if ((db.pnBytesFreed) == (null))
							sqlite3KeyInfoUnref((KeyInfo)(p4));
						break;
					}

				case (-8):
					{
						freeEphemeralFunction(db, (FuncDef)(p4));
						break;
					}

				case (-11):
					{
						if ((db.pnBytesFreed) == (null))
						{
							sqlite3ValueFree((sqlite3_value)(p4));
						}
						else
						{
							freeP4Mem(db, (sqlite3_value)(p4));
						}

						break;
					}

				case (-12):
					{
						if ((db.pnBytesFreed) == (null))
							sqlite3VtabUnlock((VTable)(p4));
						break;
					}
			}
		}
		public static void freeP4FuncCtx(sqlite3 db, sqlite3_context p)
		{
			freeEphemeralFunction(db, p.pFunc);
			sqlite3DbFreeNN(db, p);
		}
		public static void freeP4Mem(sqlite3 db, sqlite3_value p)
		{
			if ((p.szMalloc) != 0)
				sqlite3DbFree(db, p.zMalloc);
			sqlite3DbFreeNN(db, p);
		}
		public static void functionDestroy(sqlite3 db, FuncDef p)
		{
			FuncDestructor pDestructor;
			pDestructor = p.u.pDestructor;
			if ((pDestructor) != null)
			{
				pDestructor.nRef--;
				if ((pDestructor.nRef) == (0))
				{
					pDestructor.xDestroy(pDestructor.pUserData);
					sqlite3DbFree(db, pDestructor);
				}
			}
		}
		public static int growVTrans(sqlite3 db)
		{
			int ARRAY_INCR = (int)(5);
			if ((db.nVTrans % ARRAY_INCR) == (0))
			{
				VTable aVTrans;
				long nBytes = (long)(sizeof(sqlite3_vtab) * ((long)(db.nVTrans) + ARRAY_INCR));
				aVTrans = sqlite3DbRealloc(db, (void*)(db.aVTrans), (ulong)(nBytes));
				if (aVTrans == null)
				{
					return (int)(7);
				}

				CRuntime.memset(aVTrans[db.nVTrans], (int)(0), (ulong)(sizeof(sqlite3_vtab) * ARRAY_INCR));
				db.aVTrans = aVTrans;
			}

			return (int)(0);
		}
		public static void invokeProfileCallback(sqlite3 db, Vdbe p)
		{
			long iNow = 0;
			long iElapse = 0;
			sqlite3OsCurrentTimeInt64(db.pVfs, &iNow);
			iElapse = (long)((iNow - p.startTime) * 1000000);
			if ((db.xProfile) != null)
			{
				db.xProfile(db.pProfileArg, p.zSql, (ulong)(iElapse));
			}

			if ((db.mTrace & 0x02) != 0)
			{
				db.trace.xV2((uint)(0x02), db.pTraceArg, p, (void*)(&iElapse));
			}

			p.startTime = (long)(0);
		}
		public static int isAuxiliaryVtabOperator(sqlite3 db, Expr pExpr, byte* peOp2, Expr ppLeft, Expr ppRight)
		{
			if ((pExpr.op) == (172))
			{
				ExprList pList;
				Expr pCol;
				int i = 0;
				pList = pExpr.x.pList;
				if (((pList) == (null)) || (pList.nExpr != 2))
				{
					return (int)(0);
				}

				pCol = pList.a[1].pExpr;
				if ((((((pCol).op) == (167)) && ((pCol).y.pTab != null)) && (((pCol).y.pTab.eTabType) == (1))))
				{
					for (i = (int)(0); (i) < ((int)(4 * sizeof(Op2) / sizeof(Op2))); i++)
					{
						if ((sqlite3StrICmp(pExpr.u.zToken, isAuxiliaryVtabOperator_aOp[i].zOp)) == (0))
						{
							*peOp2 = (byte)(isAuxiliaryVtabOperator_aOp[i].eOp2);
							ppRight = pList.a[0].pExpr;
							ppLeft = pCol;
							return (int)(1);
						}
					}
				}

				pCol = pList.a[0].pExpr;
				if ((((((pCol).op) == (167)) && ((pCol).y.pTab != null)) && (((pCol).y.pTab.eTabType) == (1))))
				{
					sqlite3_vtab pVtab;
					sqlite3_module pMod;
					delegate68 xNotUsed;
					void* pNotUsed;
					pVtab = sqlite3GetVTable(db, pCol.y.pTab).pVtab;
					pMod = pVtab.pModule;
					if (pMod.xFindFunction != null)
					{
						i = (int)(pMod.xFindFunction(pVtab, (int)(2), pExpr.u.zToken, &xNotUsed, &pNotUsed));
						if ((i) >= (150))
						{
							*peOp2 = (byte)(i);
							ppRight = pList.a[1].pExpr;
							ppLeft = pCol;
							return (int)(1);
						}
					}
				}
			}
			else if ((((pExpr.op) == (52)) || ((pExpr.op) == (171))) || ((pExpr.op) == (51)))
			{
				int res = (int)(0);
				Expr pLeft = pExpr.pLeft;
				Expr pRight = pExpr.pRight;
				if ((((((pLeft).op) == (167)) && ((pLeft).y.pTab != null)) && (((pLeft).y.pTab.eTabType) == (1))))
				{
					res++;
				}

				if (((pRight) != null) && (((((pRight).op) == (167)) && ((pRight).y.pTab != null)) && (((pRight).y.pTab.eTabType) == (1))))
				{
					res++;
					{
						Expr t = pLeft;
						pLeft = pRight;
						pRight = t;
					}
				}

				ppLeft = pLeft;
				ppRight = pRight;
				if ((pExpr.op) == (52))
					*peOp2 = (byte)(68);
				if ((pExpr.op) == (171))
					*peOp2 = (byte)(69);
				if ((pExpr.op) == (51))
					*peOp2 = (byte)(70);
				return (int)(res);
			}

			return (int)(0);
		}
		public static int isLookaside(sqlite3 db, void* p)
		{
			return (((((ulong)(p)) >= ((ulong)(db.lookaside.pStart))) && (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))) ? 1 : 0);
		}
		public static int jsonEachConnect(sqlite3 db, void* pAux, int argc, sbyte** argv, sqlite3_vtab ppVtab, sbyte** pzErr)
		{
			sqlite3_vtab pNew;
			int rc = 0;
			rc = (int)(sqlite3_declare_vtab(db, "CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,json HIDDEN,root HIDDEN)"));
			if ((rc) == (0))
			{
				pNew = ppVtab = sqlite3_malloc((int)(sizeof(sqlite3_vtab)));
				if ((pNew) == (null))
					return (int)(7);
				CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(sqlite3_vtab)));
				sqlite3_vtab_config(db, (int)(2));
			}

			return (int)(rc);
		}
		public static int lookasideMallocSize(sqlite3 db, void* p)
		{
			return (int)((p) < (db.lookaside.pMiddle) ? db.lookaside.szTrue : 128);
		}
		public static void measureAllocationSize(sqlite3 db, void* p)
		{
			*db.pnBytesFreed += (int)(sqlite3DbMallocSize(db, p));
		}
		public static MemFile memdbFromDbSchema(sqlite3 db, sbyte* zSchema)
		{
			MemFile p = null;
			MemStore* pStore;
			int rc = (int)(sqlite3_file_control(db, zSchema, (int)(7), p));
			if ((rc) != 0)
				return null;
			if (p._base_.pMethods != memdb_io_methods)
				return null;
			pStore = p.pStore;
			memdbEnter(pStore);
			if (pStore->zFName != null)
				p = null;
			memdbLeave(pStore);
			return p;
		}
		public static byte minMaxQuery(sqlite3 db, Expr pFunc, ExprList ppMinMax)
		{
			int eRet = (int)(0x0000);
			ExprList pEList;
			sbyte* zFunc;
			ExprList pOrderBy;
			byte sortFlags = (byte)(0);
			pEList = pFunc.x.pList;
			if (((((pEList) == (null)) || (pEList.nExpr != 1)) || (((pFunc).flags & (0x1000000)) != 0)) || (((db).dbOptFlags & (0x00010000)) != 0))
			{
				return (byte)(eRet);
			}

			zFunc = pFunc.u.zToken;
			if ((sqlite3StrICmp(zFunc, "min")) == (0))
			{
				eRet = (int)(0x0001);
				if ((sqlite3ExprCanBeNull(pEList.a[0].pExpr)) != 0)
				{
					sortFlags = (byte)(0x02);
				}
			}
			else if ((sqlite3StrICmp(zFunc, "max")) == (0))
			{
				eRet = (int)(0x0002);
				sortFlags = (byte)(0x01);
			}
			else
			{
				return (byte)(eRet);
			}

			ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, (int)(0));
			if ((pOrderBy) != null)
				pOrderBy.a[0].sortFlags = (byte)(sortFlags);
			return (byte)(eRet);
		}
		public static int pragmaVtabConnect(sqlite3 db, void* pAux, int argc, sbyte** argv, sqlite3_vtab ppVtab, sbyte** pzErr)
		{
			PragmaName* pPragma = (PragmaName*)(pAux);
			PragmaVtab pTab = null;
			int rc = 0;
			int i = 0; int j = 0;
			sbyte cSep = (sbyte)(40);
			sqlite3_str acc = new sqlite3_str();
			sbyte* zBuf = stackalloc sbyte[200];
			sqlite3StrAccumInit(acc, null, zBuf, (int)(200 * sizeof(sbyte)), (int)(0));
			sqlite3_str_appendall(acc, "CREATE TABLE x");
			for (i = (int)(0), j = (int)(pPragma->iPragCName); (i) < (pPragma->nPragCName); i++, j++)
			{
				sqlite3_str_appendf(acc, "%c\"%s\"", (int)(cSep), pragCName[j]);
				cSep = (sbyte)(44);
			}

			if ((i) == (0))
			{
				sqlite3_str_appendf(acc, "(\"%s\"", pPragma->zName);
				i++;
			}

			j = (int)(0);
			if ((pPragma->mPragFlg & 0x20) != 0)
			{
				sqlite3_str_appendall(acc, ",arg HIDDEN");
				j++;
			}

			if ((pPragma->mPragFlg & (0x40 | 0x80)) != 0)
			{
				sqlite3_str_appendall(acc, ",schema HIDDEN");
				j++;
			}

			sqlite3_str_append(acc, ")", (int)(1));
			sqlite3StrAccumFinish(acc);
			rc = (int)(sqlite3_declare_vtab(db, zBuf));
			if ((rc) == (0))
			{
				pTab = (PragmaVtab)(sqlite3_malloc((int)(sizeof(PragmaVtab))));
				if ((pTab) == (null))
				{
					rc = (int)(7);
				}
				else
				{
					CRuntime.memset(pTab, (int)(0), (ulong)(sizeof(PragmaVtab)));
					pTab.pName = pPragma;
					pTab.db = db;
					pTab.iHidden = (byte)(i);
					pTab.nHidden = (byte)(j);
				}
			}
			else
			{
				*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
			}

			ppVtab = (sqlite3_vtab)(pTab);
			return (int)(rc);
		}
		public static void renameTokenFree(sqlite3 db, RenameToken* pToken)
		{
			RenameToken* pNext;
			RenameToken* p;
			for (p = pToken; p; p = pNext)
			{
				pNext = p->pNext;
				sqlite3DbFree(db, p);
			}
		}
		public static int resizeIndexObject(sqlite3 db, Index pIdx, int N)
		{
			sbyte* zExtra;
			int nByte = 0;
			if ((pIdx.nColumn) >= (N))
				return (int)(0);
			nByte = (int)((sizeof(char*) + sizeof(short) + sizeof(short) + 1) * N);
			zExtra = sqlite3DbMallocZero(db, (ulong)(nByte));
			if ((zExtra) == (null))
				return (int)(7);
			CRuntime.memcpy(zExtra, pIdx.azColl, (ulong)(sizeof(char*) * pIdx.nColumn));
			pIdx.azColl = (sbyte**)(zExtra);
			zExtra += sizeof(char*) * N;
			CRuntime.memcpy(zExtra, pIdx.aiRowLogEst, (ulong)(sizeof(short) * (pIdx.nKeyCol + 1)));
			pIdx.aiRowLogEst = (short*)(zExtra);
			zExtra += sizeof(short) * N;
			CRuntime.memcpy(zExtra, pIdx.aiColumn, (ulong)(sizeof(short) * pIdx.nColumn));
			pIdx.aiColumn = (short*)(zExtra);
			zExtra += sizeof(short) * N;
			CRuntime.memcpy(zExtra, pIdx.aSortOrder, (ulong)(pIdx.nColumn));
			pIdx.aSortOrder = (byte*)(zExtra);
			pIdx.nColumn = (ushort)(N);
			pIdx.isResized = (uint)(1);
			return (int)(0);
		}
		public static void setAllPagerFlags(sqlite3 db)
		{
			if ((db.autoCommit) != 0)
			{
				Db pDb = db.aDb;
				int n = (int)(db.nDb);
				while ((n--) > (0))
				{
					if ((pDb.pBt) != null)
					{
						sqlite3BtreeSetPagerFlags(pDb.pBt, (uint)(pDb.safety_level | (db.flags & 0x38)));
					}

					pDb++;
				}
			}
		}
		public static int setupLookaside(sqlite3 db, void* pBuf, int sz, int cnt)
		{
			void* pStart;
			long szAlloc = (long)(sz * (long)(cnt));
			int nBig = 0;
			int nSm = 0;
			if ((sqlite3LookasideUsed(db, null)) > (0))
			{
				return (int)(5);
			}

			if ((db.lookaside.bMalloced) != 0)
			{
				sqlite3_free(db.lookaside.pStart);
			}

			sz = (int)((sz) & ~7);
			if ((sz) <= ((int)(sizeof(LookasideSlot))))
				sz = (int)(0);
			if ((cnt) < (0))
				cnt = (int)(0);
			if (((sz) == (0)) || ((cnt) == (0)))
			{
				sz = (int)(0);
				pStart = null;
			}
			else if ((pBuf) == (null))
			{
				sqlite3BeginBenignMalloc();
				pStart = sqlite3Malloc((ulong)(szAlloc));
				sqlite3EndBenignMalloc();
				if ((pStart) != null)
					szAlloc = (long)(sqlite3MallocSize(pStart));
			}
			else
			{
				pStart = pBuf;
			}

			if ((sz) >= (128 * 3))
			{
				nBig = (int)(szAlloc / (3 * 128 + sz));
				nSm = (int)((szAlloc - sz * nBig) / 128);
			}
			else if ((sz) >= (128 * 2))
			{
				nBig = (int)(szAlloc / (128 + sz));
				nSm = (int)((szAlloc - sz * nBig) / 128);
			}
			else if ((sz) > (0))
			{
				nBig = (int)(szAlloc / sz);
				nSm = (int)(0);
			}
			else
			{
				nBig = (int)(nSm = (int)(0));
			}

			db.lookaside.pStart = pStart;
			db.lookaside.pInit = null;
			db.lookaside.pFree = null;
			db.lookaside.sz = ((ushort)(sz));
			db.lookaside.szTrue = ((ushort)(sz));
			if ((pStart) != null)
			{
				int i = 0;
				LookasideSlot* p;
				p = (LookasideSlot*)(pStart);
				for (i = (int)(0); (i) < (nBig); i++)
				{
					p->pNext = db.lookaside.pInit;
					db.lookaside.pInit = p;
					p = (LookasideSlot*)(&((byte*)(p))[sz]);
				}

				db.lookaside.pSmallInit = null;
				db.lookaside.pSmallFree = null;
				db.lookaside.pMiddle = p;
				for (i = (int)(0); (i) < (nSm); i++)
				{
					p->pNext = db.lookaside.pSmallInit;
					db.lookaside.pSmallInit = p;
					p = (LookasideSlot*)(&((byte*)(p))[128]);
				}

				db.lookaside.pEnd = p;
				db.lookaside.bDisable = (uint)(0);
				db.lookaside.bMalloced = (byte)((pBuf) == (null) ? 1 : 0);
				db.lookaside.nSlot = (uint)(nBig + nSm);
			}
			else
			{
				db.lookaside.pStart = db;
				db.lookaside.pSmallInit = null;
				db.lookaside.pSmallFree = null;
				db.lookaside.pMiddle = db;
				db.lookaside.pEnd = db;
				db.lookaside.bDisable = (uint)(1);
				db.lookaside.sz = (ushort)(0);
				db.lookaside.bMalloced = (byte)(0);
				db.lookaside.nSlot = (uint)(0);
			}

			return (int)(0);
		}
		public static int sqlite3_autovacuum_pages(sqlite3 db, delegate65 xCallback, void* pArg, delegate17 xDestructor)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((db.xAutovacDestr) != null)
			{
				db.xAutovacDestr(db.pAutovacPagesArg);
			}

			db.xAutovacPages = xCallback;
			db.pAutovacPagesArg = pArg;
			db.xAutovacDestr = xDestructor;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static sqlite3_backup sqlite3_backup_init(sqlite3 pDestDb, sbyte* zDestDb, sqlite3 pSrcDb, sbyte* zSrcDb)
		{
			sqlite3_backup p;
			sqlite3_mutex_enter(pSrcDb.mutex);
			sqlite3_mutex_enter(pDestDb.mutex);
			if ((pSrcDb) == (pDestDb))
			{
				sqlite3ErrorWithMsg(pDestDb, (int)(1), "source and destination must be distinct");
				p = null;
			}
			else
			{
				p = (sqlite3_backup)(sqlite3MallocZero((ulong)(sizeof(sqlite3_backup))));
				if (p == null)
				{
					sqlite3Error(pDestDb, (int)(7));
				}
			}

			if ((p) != null)
			{
				p.pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
				p.pDest = findBtree(pDestDb, pDestDb, zDestDb);
				p.pDestDb = pDestDb;
				p.pSrcDb = pSrcDb;
				p.iNext = (uint)(1);
				p.isAttached = (int)(0);
				if ((((null) == (p.pSrc)) || ((null) == (p.pDest))) || (checkReadTransaction(pDestDb, p.pDest) != 0))
				{
					sqlite3_free(p);
					p = null;
				}
			}

			if ((p) != null)
			{
				p.pSrc.nBackup++;
			}

			sqlite3_mutex_leave(pDestDb.mutex);
			sqlite3_mutex_leave(pSrcDb.mutex);
			return p;
		}
		public static int sqlite3_blob_open(sqlite3 db, sbyte* zDb, sbyte* zTable, sbyte* zColumn, long iRow, int wrFlag, sqlite3_blob** ppBlob)
		{
			int nAttempt = (int)(0);
			int iCol = 0;
			int rc = (int)(0);
			sbyte* zErr = null;
			Table pTab;
			Incrblob pBlob = null;
			Parse sParse = new Parse();
			*ppBlob = null;
			wrFlag = (int)(!!wrFlag);
			sqlite3_mutex_enter(db.mutex);
			pBlob = (Incrblob)(sqlite3DbMallocZero(db, (ulong)(sizeof(Incrblob))));
			while ((1) != 0)
			{
				sqlite3ParseObjectInit(sParse, db);
				if (pBlob == null)
					goto blob_open_out;
				sqlite3DbFree(db, zErr);
				zErr = null;
				sqlite3BtreeEnterAll(db);
				pTab = sqlite3LocateTable(sParse, (uint)(0), zTable, zDb);
				if (((pTab) != null) && (((pTab).eTabType) == (1)))
				{
					pTab = null;
					sqlite3ErrorMsg(sParse, "cannot open virtual table: %s", zTable);
				}

				if (((pTab) != null) && (!(((pTab).tabFlags & 0x00000080) == (0))))
				{
					pTab = null;
					sqlite3ErrorMsg(sParse, "cannot open table without rowid: %s", zTable);
				}

				if (((pTab) != null) && (((pTab).eTabType) == (2)))
				{
					pTab = null;
					sqlite3ErrorMsg(sParse, "cannot open view: %s", zTable);
				}

				if (pTab == null)
				{
					if ((sParse.zErrMsg) != null)
					{
						sqlite3DbFree(db, zErr);
						zErr = sParse.zErrMsg;
						sParse.zErrMsg = null;
					}

					rc = (int)(1);
					sqlite3BtreeLeaveAll(db);
					goto blob_open_out;
				}

				pBlob.pTab = pTab;
				pBlob.zDb = db.aDb[sqlite3SchemaToIndex(db, pTab.pSchema)].zDbSName;
				for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
				{
					if ((sqlite3StrICmp(pTab.aCol[iCol].zCnName, zColumn)) == (0))
					{
						break;
					}
				}

				if ((iCol) == (pTab.nCol))
				{
					sqlite3DbFree(db, zErr);
					zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
					rc = (int)(1);
					sqlite3BtreeLeaveAll(db);
					goto blob_open_out;
				}

				if ((wrFlag) != 0)
				{
					sbyte* zFault = null;
					Index pIdx;
					if ((db.flags & 0x00004000) != 0)
					{
						FKey pFKey;
						for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
						{
							int j = 0;
							for (j = (int)(0); (j) < (pFKey.nCol); j++)
							{
								if ((pFKey.aCol[j].iFrom) == (iCol))
								{
									zFault = "foreign key";
								}
							}
						}
					}

					for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
					{
						int j = 0;
						for (j = (int)(0); (j) < (pIdx.nKeyCol); j++)
						{
							if (((pIdx.aiColumn[j]) == (iCol)) || ((pIdx.aiColumn[j]) == (-2)))
							{
								zFault = "indexed";
							}
						}
					}

					if ((zFault) != null)
					{
						sqlite3DbFree(db, zErr);
						zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
						rc = (int)(1);
						sqlite3BtreeLeaveAll(db);
						goto blob_open_out;
					}
				}

				pBlob.pStmt = (sqlite3_stmt*)(sqlite3VdbeCreate(sParse));
				if ((pBlob.pStmt) != null)
				{
					Vdbe v = (Vdbe)(pBlob.pStmt);
					int iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
					VdbeOp* aOp;
					sqlite3VdbeAddOp4Int(v, (int)(2), (int)(iDb), (int)(wrFlag), (int)(pTab.pSchema.schema_cookie), (int)(pTab.pSchema.iGeneration));
					sqlite3VdbeChangeP5(v, (ushort)(1));
					aOp = sqlite3VdbeAddOpList(v, ((int)(6 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3_blob_open_openBlob, (int)(sqlite3_blob_open_iLn));
					sqlite3VdbeUsesBtree(v, (int)(iDb));
					if ((db.mallocFailed) == (0))
					{
						aOp[0].p1 = (int)(iDb);
						aOp[0].p2 = (int)(pTab.tnum);
						aOp[0].p3 = (int)(wrFlag);
						sqlite3VdbeChangeP4(v, (int)(2), pTab.zName, (int)(0));
					}

					if ((db.mallocFailed) == (0))
					{
						if ((wrFlag) != 0)
							aOp[1].opcode = (byte)(112);
						aOp[1].p2 = (int)(pTab.tnum);
						aOp[1].p3 = (int)(iDb);
						aOp[1].p4type = (sbyte)(-3);
						aOp[1].p4.i = (int)(pTab.nCol + 1);
						aOp[3].p2 = (int)(pTab.nCol);
						sParse.nVar = (short)(0);
						sParse.nMem = (int)(1);
						sParse.nTab = (int)(1);
						sqlite3VdbeMakeReady(v, sParse);
					}
				}

				pBlob.iCol = (ushort)(iCol);
				pBlob.db = db;
				sqlite3BtreeLeaveAll(db);
				if ((db.mallocFailed) != 0)
				{
					goto blob_open_out;
				}

				rc = (int)(blobSeekToRow(pBlob, (long)(iRow), &zErr));
				if (((++nAttempt) >= (50)) || (rc != 17))
					break;
				sqlite3ParseObjectReset(sParse);
			}

		blob_open_out:
			; if (((rc) == (0)) && ((db.mallocFailed) == (0))) { *ppBlob = (sqlite3_blob*)(pBlob); } else { if (((pBlob) != null) && ((pBlob.pStmt) != null)) sqlite3VdbeFinalize((Vdbe)(pBlob.pStmt)); sqlite3DbFree(db, pBlob); }
			sqlite3ErrorWithMsg(db, (int)(rc), ((zErr) != 0 ? "%s" : null), zErr);
			sqlite3DbFree(db, zErr);
			sqlite3ParseObjectReset(sParse);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_busy_handler(sqlite3 db, delegate59 xBusy, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			db.busyHandler.xBusyHandler = xBusy;
			db.busyHandler.pBusyArg = pArg;
			db.busyHandler.nBusy = (int)(0);
			db.busyTimeout = (int)(0);
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_busy_timeout(sqlite3 db, int ms)
		{
			if ((ms) > (0))
			{
				sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)(db));
				db.busyTimeout = (int)(ms);
			}
			else
			{
				sqlite3_busy_handler(db, null, null);
			}

			return (int)(0);
		}
		public static int sqlite3_changes(sqlite3 db)
		{
			return (int)(sqlite3_changes64(db));
		}
		public static long sqlite3_changes64(sqlite3 db)
		{
			return (long)(db.nChange);
		}
		public static int sqlite3_close(sqlite3 db)
		{
			return (int)(sqlite3Close(db, (int)(0)));
		}
		public static int sqlite3_close_v2(sqlite3 db)
		{
			return (int)(sqlite3Close(db, (int)(1)));
		}
		public static int sqlite3_collation_needed(sqlite3 db, void* pCollNeededArg, delegate66 xCollNeeded)
		{
			sqlite3_mutex_enter(db.mutex);
			db.xCollNeeded = xCollNeeded;
			db.xCollNeeded16 = null;
			db.pCollNeededArg = pCollNeededArg;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_collation_needed16(sqlite3 db, void* pCollNeededArg, delegate66 xCollNeeded16)
		{
			sqlite3_mutex_enter(db.mutex);
			db.xCollNeeded = null;
			db.xCollNeeded16 = xCollNeeded16;
			db.pCollNeededArg = pCollNeededArg;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_create_collation(sqlite3 db, sbyte* zName, int enc, void* pCtx, delegate70 xCompare)
		{
			return (int)(sqlite3_create_collation_v2(db, zName, (int)(enc), pCtx, xCompare, null));
		}
		public static int sqlite3_create_collation_v2(sqlite3 db, sbyte* zName, int enc, void* pCtx, delegate70 xCompare, delegate17 xDel)
		{
			int rc = 0;
			sqlite3_mutex_enter(db.mutex);
			rc = (int)(createCollation(db, zName, (byte)(enc), pCtx, xCompare, xDel));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_create_collation16(sqlite3 db, void* zName, int enc, void* pCtx, delegate70 xCompare)
		{
			int rc = (int)(0);
			sbyte* zName8;
			sqlite3_mutex_enter(db.mutex);
			zName8 = sqlite3Utf16to8(db, zName, (int)(-1), (byte)(2));
			if ((zName8) != null)
			{
				rc = (int)(createCollation(db, zName8, (byte)(enc), pCtx, xCompare, null));
				sqlite3DbFree(db, zName8);
			}

			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_create_function(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal)
		{
			return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, null, null, null));
		}
		public static int sqlite3_create_function_v2(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal, delegate17 xDestroy)
		{
			return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, null, null, xDestroy));
		}
		public static int sqlite3_create_function16(sqlite3 db, void* zFunctionName, int nArg, int eTextRep, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal)
		{
			int rc = 0;
			sbyte* zFunc8;
			sqlite3_mutex_enter(db.mutex);
			zFunc8 = sqlite3Utf16to8(db, zFunctionName, (int)(-1), (byte)(2));
			rc = (int)(sqlite3CreateFunc(db, zFunc8, (int)(nArg), (int)(eTextRep), p, xSFunc, xStep, xFinal, null, null, null));
			sqlite3DbFree(db, zFunc8);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_create_module(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux)
		{
			return (int)(createModule(db, zName, pModule, pAux, null));
		}
		public static int sqlite3_create_module_v2(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
		{
			return (int)(createModule(db, zName, pModule, pAux, xDestroy));
		}
		public static int sqlite3_create_window_function(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xStep, delegate69 xFinal, delegate69 xValue, delegate68 xInverse, delegate17 xDestroy)
		{
			return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, null, xStep, xFinal, xValue, xInverse, xDestroy));
		}
		public static int sqlite3_db_cacheflush(sqlite3 db)
		{
			int i = 0;
			int rc = (int)(0);
			int bSeenBusy = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if (((pBt) != null) && ((sqlite3BtreeTxnState(pBt)) == (2)))
				{
					Pager pPager = sqlite3BtreePager(pBt);
					rc = (int)(sqlite3PagerFlush(pPager));
					if ((rc) == (5))
					{
						bSeenBusy = (int)(1);
						rc = (int)(0);
					}
				}
			}

			sqlite3BtreeLeaveAll(db);
			sqlite3_mutex_leave(db.mutex);
			return (int)((((rc) == (0)) && ((bSeenBusy) != 0)) ? 5 : rc);
		}
		public static int sqlite3_db_config(sqlite3 db, int op)
		{
			sbyte* ap;
			int rc = 0;
			(__va_start(&ap, (int)(op)));
			switch (op)
			{
				case 1000:
					{
						db.aDb[0].zDbSName = (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
						rc = (int)(0);
						break;
					}

				case 1001:
					{
						void* pBuf = (((() > ()) || ((&(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
						int sz = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						int cnt = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						rc = (int)(setupLookaside(db, pBuf, (int)(sz), (int)(cnt)));
						break;
					}

				default:
					{
						uint i = 0;
						rc = (int)(1);
						for (i = (uint)(0); (i) < ((int)(16 * sizeof(aFlagOpType) / sizeof(aFlagOpType))); i++)
						{
							if ((sqlite3_db_config_aFlagOp[i].op) == (op))
							{
								int onoff = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
								int* pRes = (((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ));
								ulong oldFlags = (ulong)(db.flags);
								if ((onoff) > (0))
								{
									db.flags |= (ulong)(sqlite3_db_config_aFlagOp[i].mask);
								}
								else if ((onoff) == (0))
								{
									db.flags &= (ulong)(~(ulong)(sqlite3_db_config_aFlagOp[i].mask));
								}

								if (oldFlags != db.flags)
								{
									sqlite3ExpirePreparedStatements(db, (int)(0));
								}

								if ((pRes) != null)
								{
									*pRes = (int)((db.flags & sqlite3_db_config_aFlagOp[i].mask) != 0);
								}

								rc = (int)(0);
								break;
							}
						}

						break;
					}
			}

			((void)(ap = null));
			return (int)(rc);
		}
		public static int sqlite3_db_readonly(sqlite3 db, sbyte* zDbName)
		{
			Btree pBt;
			pBt = sqlite3DbNameToBtree(db, zDbName);
			return (int)(pBt ? sqlite3BtreeIsReadonly(pBt) : -1);
		}
		public static int sqlite3_db_release_memory(sqlite3 db)
		{
			int i = 0;
			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if ((pBt) != null)
				{
					Pager pPager = sqlite3BtreePager(pBt);
					sqlite3PagerShrink(pPager);
				}
			}

			sqlite3BtreeLeaveAll(db);
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_db_status(sqlite3 db, int op, int* pCurrent, int* pHighwater, int resetFlag)
		{
			int rc = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			switch (op)
			{
				case 0:
					{
						*pCurrent = (int)(sqlite3LookasideUsed(db, pHighwater));
						if ((resetFlag) != 0)
						{
							LookasideSlot* p = db.lookaside.pFree;
							if ((p) != null)
							{
								while ((p->pNext) != null)
								{
									p = p->pNext;
								}

								p->pNext = db.lookaside.pInit;
								db.lookaside.pInit = db.lookaside.pFree;
								db.lookaside.pFree = null;
							}

							p = db.lookaside.pSmallFree;
							if ((p) != null)
							{
								while ((p->pNext) != null)
								{
									p = p->pNext;
								}

								p->pNext = db.lookaside.pSmallInit;
								db.lookaside.pSmallInit = db.lookaside.pSmallFree;
								db.lookaside.pSmallFree = null;
							}
						}

						break;
					}

				case 4:
				case 5:
				case 6:
					{
						*pCurrent = (int)(0);
						*pHighwater = (int)(db.lookaside.anStat[op - 4]);
						if ((resetFlag) != 0)
						{
							db.lookaside.anStat[op - 4] = (uint)(0);
						}

						break;
					}

				case 11:
				case 1:
					{
						int totalUsed = (int)(0);
						int i = 0;
						sqlite3BtreeEnterAll(db);
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							Btree pBt = db.aDb[i].pBt;
							if ((pBt) != null)
							{
								Pager pPager = sqlite3BtreePager(pBt);
								int nByte = (int)(sqlite3PagerMemUsed(pPager));
								if ((op) == (11))
								{
									nByte = (int)(nByte / sqlite3BtreeConnectionCount(pBt));
								}

								totalUsed += (int)(nByte);
							}
						}

						sqlite3BtreeLeaveAll(db);
						*pCurrent = (int)(totalUsed);
						*pHighwater = (int)(0);
						break;
					}

				case 2:
					{
						int i = 0;
						int nByte = (int)(0);
						sqlite3BtreeEnterAll(db);
						db.pnBytesFreed = &nByte;
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							Schema pSchema = db.aDb[i].pSchema;
							if ((pSchema != null))
							{
								HashElem* p;
								nByte += (int)(sqlite3Config.m.xRoundup((int)(sizeof(HashElem))) * (pSchema.tblHash.count + pSchema.trigHash.count + pSchema.idxHash.count + pSchema.fkeyHash.count));
								nByte += (int)(sqlite3_msize(pSchema.tblHash.ht));
								nByte += (int)(sqlite3_msize(pSchema.trigHash.ht));
								nByte += (int)(sqlite3_msize(pSchema.idxHash.ht));
								nByte += (int)(sqlite3_msize(pSchema.fkeyHash.ht));
								for (p = ((&pSchema.trigHash)->first); p; p = ((p)->next))
								{
									sqlite3DeleteTrigger(db, (Trigger)((p)->data));
								}

								for (p = ((&pSchema.tblHash)->first); p; p = ((p)->next))
								{
									sqlite3DeleteTable(db, (Table)((p)->data));
								}
							}
						}

						db.pnBytesFreed = null;
						sqlite3BtreeLeaveAll(db);
						*pHighwater = (int)(0);
						*pCurrent = (int)(nByte);
						break;
					}

				case 3:
					{
						Vdbe pVdbe;
						int nByte = (int)(0);
						db.pnBytesFreed = &nByte;
						for (pVdbe = db.pVdbe; pVdbe; pVdbe = pVdbe.pNext)
						{
							sqlite3VdbeClearObject(db, pVdbe);
							sqlite3DbFree(db, pVdbe);
						}

						db.pnBytesFreed = null;
						*pHighwater = (int)(0);
						*pCurrent = (int)(nByte);
						break;
					}

				case 12:
					op = (int)(9 + 1);
				case 7:
				case 8:
				case 9:
					{
						int i = 0;
						int nRet = (int)(0);
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							if ((db.aDb[i].pBt) != null)
							{
								Pager pPager = sqlite3BtreePager(db.aDb[i].pBt);
								sqlite3PagerCacheStat(pPager, (int)(op), (int)(resetFlag), &nRet);
							}
						}

						*pHighwater = (int)(0);
						*pCurrent = (int)(nRet);
						break;
					}

				case 10:
					{
						*pHighwater = (int)(0);
						*pCurrent = (int)(((db.nDeferredImmCons) > (0)) || ((db.nDeferredCons) > (0)) ? 1 : 0);
						break;
					}

				default:
					{
						rc = (int)(1);
					}
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_declare_vtab(sqlite3 db, sbyte* zCreateTable)
		{
			VtabCtx pCtx;
			int rc = (int)(0);
			Table pTab;
			Parse sParse = new Parse();
			int initBusy = 0;
			sqlite3_mutex_enter(db.mutex);
			pCtx = db.pVtabCtx;
			if ((pCtx == null) || ((pCtx.bDeclared) != 0))
			{
				sqlite3Error(db, (int)(21));
				sqlite3_mutex_leave(db.mutex);
				return (int)(sqlite3MisuseError((int)(146305)));
			}

			pTab = pCtx.pTab;
			sqlite3ParseObjectInit(sParse, db);
			sParse.eParseMode = (byte)(1);
			sParse.disableTriggers = (byte)(1);
			initBusy = (int)(db.init.busy);
			db.init.busy = (byte)(0);
			sParse.nQueryLoop = (uint)(1);
			if (((((0) == (sqlite3RunParser(sParse, zCreateTable))) && (sParse.pNewTable != null)) && ((!db.mallocFailed) != 0)) && (((sParse.pNewTable).eTabType) == (0)))
			{
				if (pTab.aCol == null)
				{
					Table pNew = sParse.pNewTable;
					Index pIdx;
					pTab.aCol = pNew.aCol;
					sqlite3ExprListDelete(db, pNew.u.tab.pDfltList);
					pTab.nNVCol = (short)(pTab.nCol = (short)(pNew.nCol));
					pTab.tabFlags |= (uint)(pNew.tabFlags & (0x00000080 | 0x00000200));
					pNew.nCol = (short)(0);
					pNew.aCol = null;
					if (((!(((pNew).tabFlags & 0x00000080) == (0))) && (pCtx.pVTable.pMod.pModule.xUpdate != null)) && (sqlite3PrimaryKeyIndex(pNew).nKeyCol != 1))
					{
						rc = (int)(1);
					}

					pIdx = pNew.pIndex;
					if ((pIdx) != null)
					{
						pTab.pIndex = pIdx;
						pNew.pIndex = null;
						pIdx.pTable = pTab;
					}
				}

				pCtx.bDeclared = (int)(1);
			}
			else
			{
				sqlite3ErrorWithMsg(db, (int)(1), ((sParse.zErrMsg) != 0 ? "%s" : null), sParse.zErrMsg);
				sqlite3DbFree(db, sParse.zErrMsg);
				rc = (int)(1);
			}

			sParse.eParseMode = (byte)(0);
			if ((sParse.pVdbe) != null)
			{
				sqlite3VdbeFinalize(sParse.pVdbe);
			}

			sqlite3DeleteTable(db, sParse.pNewTable);
			sqlite3ParseObjectReset(sParse);
			db.init.busy = (byte)(initBusy);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_deserialize(sqlite3 db, sbyte* zSchema, byte* pData, long szDb, long szBuf, uint mFlags)
		{
			MemFile p;
			sbyte* zSql;
			sqlite3_stmt* pStmt = null;
			int rc = 0;
			int iDb = 0;
			sqlite3_mutex_enter(db.mutex);
			if ((zSchema) == (null))
				zSchema = db.aDb[0].zDbSName;
			iDb = (int)(sqlite3FindDbName(db, zSchema));
			if (((iDb) < (2)) && (iDb != 0))
			{
				rc = (int)(1);
				goto end_deserialize;
			}

			zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);
			if ((zSql) == (null))
			{
				rc = (int)(7);
			}
			else
			{
				rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, null));
				sqlite3_free(zSql);
			}

			if ((rc) != 0)
				goto end_deserialize;
			db.init.iDb = ((byte)(iDb));
			db.init.reopenMemdb = (uint)(1);
			rc = (int)(sqlite3_step(pStmt));
			db.init.reopenMemdb = (uint)(0);
			if (rc != 101)
			{
				rc = (int)(1);
				goto end_deserialize;
			}

			p = memdbFromDbSchema(db, zSchema);
			if ((p) == (null))
			{
				rc = (int)(1);
			}
			else
			{
				MemStore* pStore = p.pStore;
				pStore->aData = pData;
				pData = null;
				pStore->sz = (long)(szDb);
				pStore->szAlloc = (long)(szBuf);
				pStore->szMax = (long)(szBuf);
				if ((pStore->szMax) < (sqlite3Config.mxMemdbSize))
				{
					pStore->szMax = (long)(sqlite3Config.mxMemdbSize);
				}

				pStore->mFlags = (uint)(mFlags);
				rc = (int)(0);
			}

		end_deserialize:
			; sqlite3_finalize(pStmt);
			if (((pData) != null) && ((mFlags & 1) != 0))
			{
				sqlite3_free(pData);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_drop_modules(sqlite3 db, sbyte** azNames)
		{
			HashElem* pThis; HashElem* pNext;
			for (pThis = ((&db.aModule)->first); pThis; pThis = pNext)
			{
				Module pMod = (Module)((pThis)->data);
				pNext = ((pThis)->next);
				if ((azNames) != null)
				{
					int ii = 0;
					for (ii = (int)(0); (azNames[ii] != null) && (CRuntime.strcmp(azNames[ii], pMod.zName) != 0); ii++)
					{
					}

					if (azNames[ii] != null)
						continue;
				}

				createModule(db, pMod.zName, null, null, null);
			}

			return (int)(0);
		}
		public static int sqlite3_enable_load_extension(sqlite3 db, int onoff)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((onoff) != 0)
			{
				db.flags |= (ulong)(0x00010000 | 0x00020000);
			}
			else
			{
				db.flags &= (ulong)(~(ulong)(0x00010000 | 0x00020000));
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_errcode(sqlite3 db)
		{
			if (((db) != null) && (sqlite3SafetyCheckSickOrOk(db) == 0))
			{
				return (int)(sqlite3MisuseError((int)(171145)));
			}

			if ((db == null) || ((db.mallocFailed) != 0))
			{
				return (int)(7);
			}

			return (int)(db.errCode & db.errMask);
		}
		public static int sqlite3_error_offset(sqlite3 db)
		{
			int iOffset = (int)(-1);
			if ((((db) != null) && ((sqlite3SafetyCheckSickOrOk(db)) != 0)) && ((db.errCode) != 0))
			{
				sqlite3_mutex_enter(db.mutex);
				iOffset = (int)(db.errByteOffset);
				sqlite3_mutex_leave(db.mutex);
			}

			return (int)(iOffset);
		}
		public static int sqlite3_exec(sqlite3 db, sbyte* zSql, delegate54 xCallback, void* pArg, sbyte** pzErrMsg)
		{
			int rc = (int)(0);
			sbyte* zLeftover;
			sqlite3_stmt* pStmt = null;
			sbyte** azCols = null;
			int callbackIsInit = 0;
			if (sqlite3SafetyCheckOk(db) == 0)
				return (int)(sqlite3MisuseError((int)(128113)));
			if ((zSql) == (null))
				zSql = "";
			sqlite3_mutex_enter(db.mutex);
			sqlite3Error(db, (int)(0));
			while (((rc) == (0)) && ((zSql[0]) != 0))
			{
				int nCol = (int)(0);
				sbyte** azVals = null;
				pStmt = null;
				rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, &zLeftover));
				if (rc != 0)
				{
					continue;
				}

				if (pStmt == null)
				{
					zSql = zLeftover;
					continue;
				}

				callbackIsInit = (int)(0);
				while ((1) != 0)
				{
					int i = 0;
					rc = (int)(sqlite3_step(pStmt));
					if (((xCallback) != null) && (((100) == (rc)) || ((((101) == (rc)) && (callbackIsInit == 0)) && ((db.flags & 0x00000100) != 0))))
					{
						if (callbackIsInit == 0)
						{
							nCol = (int)(sqlite3_column_count(pStmt));
							azCols = sqlite3DbMallocRaw(db, (ulong)((2 * nCol + 1) * sizeof(constchar*)));
							if ((azCols) == (null))
							{
								goto exec_out;
							}

							for (i = (int)(0); (i) < (nCol); i++)
							{
								azCols[i] = sqlite3_column_name(pStmt, (int)(i));
							}

							callbackIsInit = (int)(1);
						}

						if ((rc) == (100))
						{
							azVals = &azCols[nCol];
							for (i = (int)(0); (i) < (nCol); i++)
							{
								azVals[i] = (sbyte*)(sqlite3_column_text(pStmt, (int)(i)));
								if ((azVals[i] == null) && (sqlite3_column_type(pStmt, (int)(i)) != 5))
								{
									sqlite3OomFault(db);
									goto exec_out;
								}
							}

							azVals[i] = null;
						}

						if ((xCallback(pArg, (int)(nCol), azVals, azCols)) != 0)
						{
							rc = (int)(4);
							sqlite3VdbeFinalize((Vdbe)(pStmt));
							pStmt = null;
							sqlite3Error(db, (int)(4));
							goto exec_out;
						}
					}

					if (rc != 100)
					{
						rc = (int)(sqlite3VdbeFinalize((Vdbe)(pStmt)));
						pStmt = null;
						zSql = zLeftover;
						while ((sqlite3CtypeMap[(byte)(zSql[0])] & 0x01) != 0)
						{
							zSql++;
						}

						break;
					}
				}

				sqlite3DbFree(db, azCols);
				azCols = null;
			}

		exec_out:
			; if ((pStmt) != null) sqlite3VdbeFinalize((Vdbe)(pStmt));
			sqlite3DbFree(db, azCols);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			if ((rc != 0) && ((pzErrMsg) != null))
			{
				*pzErrMsg = sqlite3DbStrDup(null, sqlite3_errmsg(db));
				if ((*pzErrMsg) == (null))
				{
					rc = (int)(7);
					sqlite3Error(db, (int)(7));
				}
			}
			else if ((pzErrMsg) != null)
			{
				*pzErrMsg = null;
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_extended_errcode(sqlite3 db)
		{
			if (((db) != null) && (sqlite3SafetyCheckSickOrOk(db) == 0))
			{
				return (int)(sqlite3MisuseError((int)(171154)));
			}

			if ((db == null) || ((db.mallocFailed) != 0))
			{
				return (int)(7);
			}

			return (int)(db.errCode);
		}
		public static int sqlite3_extended_result_codes(sqlite3 db, int onoff)
		{
			sqlite3_mutex_enter(db.mutex);
			db.errMask = (int)((onoff) != 0 ? 0xffffffff : 0xff);
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_file_control(sqlite3 db, sbyte* zDbName, int op, void* pArg)
		{
			int rc = (int)(1);
			Btree pBtree;
			sqlite3_mutex_enter(db.mutex);
			pBtree = sqlite3DbNameToBtree(db, zDbName);
			if ((pBtree) != null)
			{
				Pager pPager;
				sqlite3_file fd;
				sqlite3BtreeEnter(pBtree);
				pPager = sqlite3BtreePager(pBtree);
				fd = sqlite3PagerFile(pPager);
				if ((op) == (7))
				{
					(sqlite3_file)(pArg) = fd;
					rc = (int)(0);
				}
				else if ((op) == (27))
				{
					(sqlite3_vfs)(pArg) = sqlite3PagerVfs(pPager);
					rc = (int)(0);
				}
				else if ((op) == (28))
				{
					(sqlite3_file)(pArg) = sqlite3PagerJrnlFile(pPager);
					rc = (int)(0);
				}
				else if ((op) == (35))
				{
					*(uint*)(pArg) = (uint)(sqlite3PagerDataVersion(pPager));
					rc = (int)(0);
				}
				else if ((op) == (38))
				{
					int iNew = (int)(*(int*)(pArg));
					*(int*)(pArg) = (int)(sqlite3BtreeGetRequestedReserve(pBtree));
					if (((iNew) >= (0)) && ((iNew) <= (255)))
					{
						sqlite3BtreeSetPageSize(pBtree, (int)(0), (int)(iNew), (int)(0));
					}

					rc = (int)(0);
				}
				else
				{
					int nSave = (int)(db.busyHandler.nBusy);
					rc = (int)(sqlite3OsFileControl(fd, (int)(op), pArg));
					db.busyHandler.nBusy = (int)(nSave);
				}

				sqlite3BtreeLeave(pBtree);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_get_autocommit(sqlite3 db)
		{
			return (int)(db.autoCommit);
		}
		public static int sqlite3_get_table(sqlite3 db, sbyte* zSql, sbyte*** pazResult, int* pnRow, int* pnColumn, sbyte** pzErrMsg)
		{
			int rc = 0;
			TabResult res = new TabResult();
			*pazResult = null;
			if ((pnColumn) != null)
				*pnColumn = (int)(0);
			if ((pnRow) != null)
				*pnRow = (int)(0);
			if ((pzErrMsg) != null)
				*pzErrMsg = null;
			res.zErrMsg = null;
			res.nRow = (uint)(0);
			res.nColumn = (uint)(0);
			res.nData = (uint)(1);
			res.nAlloc = (uint)(20);
			res.rc = (int)(0);
			res.azResult = sqlite3_malloc64((ulong)(sizeof(char*) * res.nAlloc));
			if ((res.azResult) == (null))
			{
				db.errCode = (int)(7);
				return (int)(7);
			}

			res.azResult[0] = null;
			rc = (int)(sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg));
			res.azResult[0] = ((void*)((long)(res.nData)));
			if ((rc & 0xff) == (4))
			{
				sqlite3_free_table(&res.azResult[1]);
				if ((res.zErrMsg) != null)
				{
					if ((pzErrMsg) != null)
					{
						sqlite3_free(*pzErrMsg);
						*pzErrMsg = sqlite3_mprintf("%s", res.zErrMsg);
					}

					sqlite3_free(res.zErrMsg);
				}

				db.errCode = (int)(res.rc);
				return (int)(res.rc);
			}

			sqlite3_free(res.zErrMsg);
			if (rc != 0)
			{
				sqlite3_free_table(&res.azResult[1]);
				return (int)(rc);
			}

			if ((res.nAlloc) > (res.nData))
			{
				sbyte** azNew;
				azNew = sqlite3Realloc(res.azResult, (ulong)(sizeof(char*) * res.nData));
				if ((azNew) == (null))
				{
					sqlite3_free_table(&res.azResult[1]);
					db.errCode = (int)(7);
					return (int)(7);
				}

				res.azResult = azNew;
			}

			*pazResult = &res.azResult[1];
			if ((pnColumn) != null)
				*pnColumn = (int)(res.nColumn);
			if ((pnRow) != null)
				*pnRow = (int)(res.nRow);
			return (int)(rc);
		}
		public static void sqlite3_interrupt(sqlite3 db)
		{
			(1);
		}
		public static long sqlite3_last_insert_rowid(sqlite3 db)
		{
			return (long)(db.lastRowid);
		}
		public static int sqlite3_limit(sqlite3 db, int limitId, int newLimit)
		{
			int oldLimit = 0;
			if (((limitId) < (0)) || ((limitId) >= (11 + 1)))
			{
				return (int)(-1);
			}

			oldLimit = (int)(db.aLimit[limitId]);
			if ((newLimit) >= (0))
			{
				if ((newLimit) > (aHardLimit[limitId]))
				{
					newLimit = (int)(aHardLimit[limitId]);
				}
				else if (((newLimit) < (1)) && ((limitId) == (0)))
				{
					newLimit = (int)(1);
				}

				db.aLimit[limitId] = (int)(newLimit);
			}

			return (int)(oldLimit);
		}
		public static int sqlite3_load_extension(sqlite3 db, sbyte* zFile, sbyte* zProc, sbyte** pzErrMsg)
		{
			int rc = 0;
			sqlite3_mutex_enter(db.mutex);
			rc = (int)(sqlite3LoadExtension(db, zFile, zProc, pzErrMsg));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_overload_function(sqlite3 db, sbyte* zName, int nArg)
		{
			int rc = 0;
			sbyte* zCopy;
			sqlite3_mutex_enter(db.mutex);
			rc = (int)(sqlite3FindFunction(db, zName, (int)(nArg), (byte)(1), (byte)(0)) != null);
			sqlite3_mutex_leave(db.mutex);
			if ((rc) != 0)
				return (int)(0);
			zCopy = sqlite3_mprintf(zName);
			if ((zCopy) == (null))
				return (int)(7);
			return (int)(sqlite3_create_function_v2(db, zName, (int)(nArg), (int)(1), zCopy, sqlite3InvalidFunction, null, null, sqlite3_free));
		}
		public static int sqlite3_prepare(sqlite3 db, sbyte* zSql, int nBytes, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0), null, ppStmt, pzTail));
			return (int)(rc);
		}
		public static int sqlite3_prepare_v2(sqlite3 db, sbyte* zSql, int nBytes, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0x80), null, ppStmt, pzTail));
			return (int)(rc);
		}
		public static int sqlite3_prepare_v3(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0x80 | (prepFlags & 0x0f)), null, ppStmt, pzTail));
			return (int)(rc);
		}
		public static int sqlite3_prepare16(sqlite3 db, void* zSql, int nBytes, sqlite3_stmt** ppStmt, void** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0), ppStmt, pzTail));
			return (int)(rc);
		}
		public static int sqlite3_prepare16_v2(sqlite3 db, void* zSql, int nBytes, sqlite3_stmt** ppStmt, void** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0x80), ppStmt, pzTail));
			return (int)(rc);
		}
		public static int sqlite3_prepare16_v3(sqlite3 db, void* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, void** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0x80 | (prepFlags & 0x0f)), ppStmt, pzTail));
			return (int)(rc);
		}
		public static void sqlite3_progress_handler(sqlite3 db, int nOps, delegate19 xProgress, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((nOps) > (0))
			{
				db.xProgress = xProgress;
				db.nProgressOps = ((uint)(nOps));
				db.pProgressArg = pArg;
			}
			else
			{
				db.xProgress = null;
				db.nProgressOps = (uint)(0);
				db.pProgressArg = null;
			}

			sqlite3_mutex_leave(db.mutex);
		}
		public static int sqlite3_set_authorizer(sqlite3 db, delegate67 xAuth, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			db.xAuth = xAuth;
			db.pAuthArg = pArg;
			if ((db.xAuth) != null)
				sqlite3ExpirePreparedStatements(db, (int)(1));
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static void sqlite3_set_last_insert_rowid(sqlite3 db, long iRowid)
		{
			sqlite3_mutex_enter(db.mutex);
			db.lastRowid = (long)(iRowid);
			sqlite3_mutex_leave(db.mutex);
		}
		public static sqlite3_str sqlite3_str_new(sqlite3 db)
		{
			sqlite3_str p = sqlite3_malloc64((ulong)(sizeof(sqlite3_str)));
			if ((p) != null)
			{
				sqlite3StrAccumInit(p, null, null, (int)(0), (int)(db ? db.aLimit[0] : 1000000000));
			}
			else
			{
				p = sqlite3OomStr;
			}

			return p;
		}
		public static int sqlite3_system_errno(sqlite3 db)
		{
			return (int)(db ? db.iSysErrno : 0);
		}
		public static int sqlite3_table_column_metadata(sqlite3 db, sbyte* zDbName, sbyte* zTableName, sbyte* zColumnName, sbyte** pzDataType, sbyte** pzCollSeq, int* pNotNull, int* pPrimaryKey, int* pAutoinc)
		{
			int rc = 0;
			sbyte* zErrMsg = null;
			Table pTab = null;
			Column* pCol = null;
			int iCol = (int)(0);
			sbyte* zDataType = null;
			sbyte* zCollSeq = null;
			int notnull = (int)(0);
			int primarykey = (int)(0);
			int autoinc = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			rc = (int)(sqlite3Init(db, &zErrMsg));
			if (0 != rc)
			{
				goto error_out;
			}

			pTab = sqlite3FindTable(db, zTableName, zDbName);
			if ((pTab == null) || (((pTab).eTabType) == (2)))
			{
				pTab = null;
				goto error_out;
			}

			if ((zColumnName) == (null))
			{
			}
			else
			{
				for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
				{
					pCol = &pTab.aCol[iCol];
					if ((0) == (sqlite3StrICmp(pCol->zCnName, zColumnName)))
					{
						break;
					}
				}

				if ((iCol) == (pTab.nCol))
				{
					if ((((pTab).tabFlags & 0x00000080) == (0)) && ((sqlite3IsRowid(zColumnName)) != 0))
					{
						iCol = (int)(pTab.iPKey);
						pCol = (iCol) >= (0) ? &pTab.aCol[iCol] : null;
					}
					else
					{
						pTab = null;
						goto error_out;
					}
				}
			}

			if ((pCol) != null)
			{
				zDataType = sqlite3ColumnType(pCol, null);
				zCollSeq = sqlite3ColumnColl(pCol);
				notnull = (int)(pCol->notNull != 0);
				primarykey = (int)((pCol->colFlags & 0x0001) != 0);
				autoinc = (int)(((pTab.iPKey) == (iCol)) && ((pTab.tabFlags & 0x00000008) != 0) ? 1 : 0);
			}
			else
			{
				zDataType = "INTEGER";
				primarykey = (int)(1);
			}

			if (zCollSeq == null)
			{
				zCollSeq = sqlite3StrBINARY;
			}

		error_out:
			; sqlite3BtreeLeaveAll(db);
			if ((pzDataType) != null)
				*pzDataType = zDataType;
			if ((pzCollSeq) != null)
				*pzCollSeq = zCollSeq;
			if ((pNotNull) != null)
				*pNotNull = (int)(notnull);
			if ((pPrimaryKey) != null)
				*pPrimaryKey = (int)(primarykey);
			if ((pAutoinc) != null)
				*pAutoinc = (int)(autoinc);
			if (((0) == (rc)) && (pTab == null))
			{
				sqlite3DbFree(db, zErrMsg);
				zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName, zColumnName);
				rc = (int)(1);
			}

			sqlite3ErrorWithMsg(db, (int)(rc), ((zErrMsg) != 0 ? "%s" : null), zErrMsg);
			sqlite3DbFree(db, zErrMsg);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_total_changes(sqlite3 db)
		{
			return (int)(sqlite3_total_changes64(db));
		}
		public static long sqlite3_total_changes64(sqlite3 db)
		{
			return (long)(db.nTotalChange);
		}
		public static int sqlite3_trace_v2(sqlite3 db, uint mTrace, delegate62 xTrace, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((mTrace) == (0))
				xTrace = null;
			if ((xTrace) == (null))
				mTrace = (uint)(0);
			db.mTrace = (byte)(mTrace);
			db.trace.xV2 = xTrace;
			db.pTraceArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_txn_state(sqlite3 db, sbyte* zSchema)
		{
			int iDb = 0; int nDb = 0;
			int iTxn = (int)(-1);
			sqlite3_mutex_enter(db.mutex);
			if ((zSchema) != null)
			{
				nDb = (int)(iDb = (int)(sqlite3FindDbName(db, zSchema)));
				if ((iDb) < (0))
					nDb--;
			}
			else
			{
				iDb = (int)(0);
				nDb = (int)(db.nDb - 1);
			}

			for (; (iDb) <= (nDb); iDb++)
			{
				Btree pBt = db.aDb[iDb].pBt;
				int x = (int)(pBt != null ? sqlite3BtreeTxnState(pBt) : 0);
				if ((x) > (iTxn))
					iTxn = (int)(x);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(iTxn);
		}
		public static int sqlite3_vtab_config(sqlite3 db, int op)
		{
			sbyte* ap;
			int rc = (int)(0);
			VtabCtx p;
			sqlite3_mutex_enter(db.mutex);
			p = db.pVtabCtx;
			if (p == null)
			{
				rc = (int)(sqlite3MisuseError((int)(146796)));
			}
			else
			{
				(__va_start(&ap, (int)(op)));
				switch (op)
				{
					case 1:
						{
							p.pVTable.bConstraint = ((byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )));
							break;
						}

					case 2:
						{
							p.pVTable.eVtabRisk = (byte)(0);
							break;
						}

					case 3:
						{
							p.pVTable.eVtabRisk = (byte)(2);
							break;
						}

					default:
						{
							rc = (int)(sqlite3MisuseError((int)(146814)));
							break;
						}
				}

				((void)(ap = null));
			}

			if (rc != 0)
				sqlite3Error(db, (int)(rc));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_vtab_on_conflict(sqlite3 db)
		{
			return (int)(sqlite3_vtab_on_conflict_aMap[db.vtabOnConflict - 1]);
		}
		public static int sqlite3_wal_autocheckpoint(sqlite3 db, int nFrame)
		{
			if ((nFrame) > (0))
			{
				sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void*)((long)(nFrame))));
			}
			else
			{
				sqlite3_wal_hook(db, null, null);
			}

			return (int)(0);
		}
		public static int sqlite3_wal_checkpoint(sqlite3 db, sbyte* zDb)
		{
			return (int)(sqlite3_wal_checkpoint_v2(db, zDb, (int)(0), null, null));
		}
		public static int sqlite3_wal_checkpoint_v2(sqlite3 db, sbyte* zDb, int eMode, int* pnLog, int* pnCkpt)
		{
			int rc = 0;
			int iDb = 0;
			if ((pnLog) != null)
				*pnLog = (int)(-1);
			if ((pnCkpt) != null)
				*pnCkpt = (int)(-1);
			if (((eMode) < (0)) || ((eMode) > (3)))
			{
				return (int)(21);
			}

			sqlite3_mutex_enter(db.mutex);
			if (((zDb) != null) && ((zDb[0]) != 0))
			{
				iDb = (int)(sqlite3FindDbName(db, zDb));
			}
			else
			{
				iDb = (int)(10 + 2);
			}

			if ((iDb) < (0))
			{
				rc = (int)(1);
				sqlite3ErrorWithMsg(db, (int)(1), "unknown database: %s", zDb);
			}
			else
			{
				db.busyHandler.nBusy = (int)(0);
				rc = (int)(sqlite3Checkpoint(db, (int)(iDb), (int)(eMode), pnLog, pnCkpt));
				sqlite3Error(db, (int)(rc));
			}

			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			if ((db.nVdbeActive) == (0))
			{
				(0);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static Index sqlite3AllocateIndexObject(sqlite3 db, short nCol, int nExtra, sbyte** ppExtra)
		{
			Index p;
			int nByte = 0;
			nByte = (int)((((sizeof(Index)) + 7) & ~7) + (((sizeof(char*) * nCol) + 7) & ~7) + (((sizeof(short) * (nCol + 1) + sizeof(short) * nCol + sizeof(byte) * nCol) + 7) & ~7));
			p = sqlite3DbMallocZero(db, (ulong)(nByte + nExtra));
			if ((p) != null)
			{
				sbyte* pExtra = ((sbyte*)(p)) + (((sizeof(Index)) + 7) & ~7);
				p.azColl = (sbyte**)(pExtra);
				pExtra += (((sizeof(char*) * nCol) + 7) & ~7);
				p.aiRowLogEst = (short*)(pExtra);
				pExtra += sizeof(short) * (nCol + 1);
				p.aiColumn = (short*)(pExtra);
				pExtra += sizeof(short) * nCol;
				p.aSortOrder = (byte*)(pExtra);
				p.nColumn = (ushort)(nCol);
				p.nKeyCol = (ushort)(nCol - 1);
				*ppExtra = ((sbyte*)(p)) + nByte;
			}

			return p;
		}
		public static int sqlite3AnalysisLoad(sqlite3 db, int iDb)
		{
			analysisInfo sInfo = new analysisInfo();
			HashElem* i;
			sbyte* zSql;
			int rc = (int)(0);
			Schema pSchema = db.aDb[iDb].pSchema;
			Table pStat1;
			for (i = ((&pSchema.tblHash)->first); i; i = ((i)->next))
			{
				Table pTab = ((i)->data);
				pTab.tabFlags &= (uint)(~0x00000010);
			}

			for (i = ((&pSchema.idxHash)->first); i; i = ((i)->next))
			{
				Index pIdx = ((i)->data);
				pIdx.hasStat1 = (uint)(0);
			}

			sInfo.db = db;
			sInfo.zDatabase = db.aDb[iDb].zDbSName;
			if ((pStat1 = sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase)) && (((pStat1).eTabType) == (0)))
			{
				zSql = sqlite3MPrintf(db, "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
				if ((zSql) == (null))
				{
					rc = (int)(7);
				}
				else
				{
					rc = (int)(sqlite3_exec(db, zSql, analysisLoader, sInfo, null));
					sqlite3DbFree(db, zSql);
				}
			}

			for (i = ((&pSchema.idxHash)->first); i; i = ((i)->next))
			{
				Index pIdx = ((i)->data);
				if (pIdx.hasStat1 == 0)
					sqlite3DefaultRowEst(pIdx);
			}

			if ((rc) == (7))
			{
				sqlite3OomFault(db);
			}

			return (int)(rc);
		}
		public static int sqlite3ApiExit(sqlite3 db, int rc)
		{
			if (((db.mallocFailed) != 0) || ((rc) != 0))
			{
				return (int)(apiHandleError(db, (int)(rc)));
			}

			return (int)(rc & db.errMask);
		}
		public static void sqlite3AutoLoadExtensions(sqlite3 db)
		{
			uint i = 0;
			int go = (int)(1);
			int rc = 0;
			delegate88 xInit;
			if ((sqlite3Autoext.nExt) == (0))
			{
				return;
			}

			for (i = (uint)(0); go; i++)
			{
				sbyte* zErrmsg;
				sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
				sqlite3_api_routines pThunk = sqlite3Apis;
				sqlite3_mutex_enter(mutex);
				if ((i) >= (sqlite3Autoext.nExt))
				{
					xInit = null;
					go = (int)(0);
				}
				else
				{
					xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3Autoext.aExt[i]);
				}

				sqlite3_mutex_leave(mutex);
				zErrmsg = null;
				if (((xInit) != null) && ((rc = (int)(xInit(db, &zErrmsg, pThunk))) != 0))
				{
					sqlite3ErrorWithMsg(db, (int)(rc), "automatic extension loading failed: %s", zErrmsg);
					go = (int)(0);
				}

				sqlite3_free(zErrmsg);
			}
		}
		public static int sqlite3BtreeCount(sqlite3 db, BtCursor pCur, long* pnEntry)
		{
			long nEntry = (long)(0);
			int rc = 0;
			rc = (int)(moveToRoot(pCur));
			if ((rc) == (16))
			{
				*pnEntry = (long)(0);
				return (int)(0);
			}

			while (((rc) == (0)) && (0 == 0))
			{
				int iIdx = 0;
				MemPage pPage;
				pPage = pCur.pPage;
				if (((pPage.leaf) != 0) || (pPage.intKey == 0))
				{
					nEntry += (long)(pPage.nCell);
				}

				if ((pPage.leaf) != 0)
				{
					do
					{
						if ((pCur.iPage) == (0))
						{
							*pnEntry = (long)(nEntry);
							return (int)(moveToRoot(pCur));
						}

						moveToParent(pCur);
					}
					while ((pCur.ix) >= (pCur.pPage.nCell));
					pCur.ix++;
					pPage = pCur.pPage;
				}

				iIdx = (int)(pCur.ix);
				if ((iIdx) == (pPage.nCell))
				{
					rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]))));
				}
				else
				{
					rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (iIdx)])))))))));
				}
			}

			return (int)(rc);
		}
		public static void sqlite3BtreeEnterAll(sqlite3 db)
		{
			if ((db.noSharedCache) == (0))
				btreeEnterAll(db);
		}
		public static void sqlite3BtreeLeaveAll(sqlite3 db)
		{
			if ((db.noSharedCache) == (0))
				btreeLeaveAll(db);
		}
		public static int sqlite3Checkpoint(sqlite3 db, int iDb, int eMode, int* pnLog, int* pnCkpt)
		{
			int rc = (int)(0);
			int i = 0;
			int bBusy = (int)(0);
			for (i = (int)(0); ((i) < (db.nDb)) && ((rc) == (0)); i++)
			{
				if (((i) == (iDb)) || ((iDb) == (10 + 2)))
				{
					rc = (int)(sqlite3BtreeCheckpoint(db.aDb[i].pBt, (int)(eMode), pnLog, pnCkpt));
					pnLog = null;
					pnCkpt = null;
					if ((rc) == (5))
					{
						bBusy = (int)(1);
						rc = (int)(0);
					}
				}
			}

			return (int)((((rc) == (0)) && ((bBusy) != 0)) ? 5 : rc);
		}
		public static int sqlite3Close(sqlite3 db, int forceZombie)
		{
			if (db == null)
			{
				return (int)(0);
			}

			if (sqlite3SafetyCheckSickOrOk(db) == 0)
			{
				return (int)(sqlite3MisuseError((int)(169692)));
			}

			sqlite3_mutex_enter(db.mutex);
			if ((db.mTrace & 0x08) != 0)
			{
				db.trace.xV2((uint)(0x08), db.pTraceArg, db, null);
			}

			disconnectAllVtab(db);
			sqlite3VtabRollback(db);
			if ((forceZombie == 0) && ((connectionIsBusy(db)) != 0))
			{
				sqlite3ErrorWithMsg(db, (int)(5), "unable to close due to unfinalized statements or unfinished backups");
				sqlite3_mutex_leave(db.mutex);
				return (int)(5);
			}

			db.eOpenState = (byte)(0xa7);
			sqlite3LeaveMutexAndCloseZombie(db);
			return (int)(0);
		}
		public static void sqlite3CloseExtensions(sqlite3 db)
		{
			int i = 0;
			for (i = (int)(0); (i) < (db.nExtension); i++)
			{
				sqlite3OsDlClose(db.pVfs, db.aExtension[i]);
			}

			sqlite3DbFree(db, db.aExtension);
		}
		public static void sqlite3CloseSavepoints(sqlite3 db)
		{
			while ((db.pSavepoint) != null)
			{
				Savepoint* pTmp = db.pSavepoint;
				db.pSavepoint = pTmp->pNext;
				sqlite3DbFree(db, pTmp);
			}

			db.nSavepoint = (int)(0);
			db.nStatement = (int)(0);
			db.isTransactionSavepoint = (byte)(0);
		}
		public static void sqlite3CollapseDatabaseArray(sqlite3 db)
		{
			int i = 0; int j = 0;
			for (i = (int)(j = (int)(2)); (i) < (db.nDb); i++)
			{
				Db pDb = db.aDb[i];
				if ((pDb.pBt) == (null))
				{
					sqlite3DbFree(db, pDb.zDbSName);
					pDb.zDbSName = null;
					continue;
				}

				if ((j) < (i))
				{
					db.aDb[j] = (Db)(db.aDb[i]);
				}

				j++;
			}

			db.nDb = (int)(j);
			if (((db.nDb) <= (2)) && (db.aDb != db.aDbStatic))
			{
				CRuntime.memcpy(db.aDbStatic, db.aDb, (ulong)(2 * sizeof(Db)));
				sqlite3DbFree(db, db.aDb);
				db.aDb = db.aDbStatic;
			}
		}
		public static void sqlite3ColumnSetColl(sqlite3 db, Column* pCol, sbyte* zColl)
		{
			long nColl = 0;
			long n = 0;
			sbyte* zNew;
			n = (long)(sqlite3Strlen30(pCol->zCnName) + 1);
			if ((pCol->colFlags & 0x0004) != 0)
			{
				n += (long)(sqlite3Strlen30(pCol->zCnName + n) + 1);
			}

			nColl = (long)(sqlite3Strlen30(zColl) + 1);
			zNew = sqlite3DbRealloc(db, pCol->zCnName, (ulong)(nColl + n));
			if ((zNew) != null)
			{
				pCol->zCnName = zNew;
				CRuntime.memcpy(pCol->zCnName + n, zColl, (ulong)(nColl));
				pCol->colFlags |= (ushort)(0x0200);
			}
		}
		public static void sqlite3CommitInternalChanges(sqlite3 db)
		{
			db.mDbFlags &= (uint)(~0x0001);
		}
		public static Expr sqlite3CreateColumnExpr(sqlite3 db, SrcList pSrc, int iSrc, int iCol)
		{
			Expr p = sqlite3ExprAlloc(db, (int)(167), null, (int)(0));
			if ((p) != null)
			{
				SrcItem pItem = pSrc.a[iSrc];
				Table pTab;
				pTab = p.y.pTab = pItem.pTab;
				p.iTable = (int)(pItem.iCursor);
				if ((p.y.pTab.iPKey) == (iCol))
				{
					p.iColumn = (short)(-1);
				}
				else
				{
					p.iColumn = ((short)(iCol));
					if (((pTab.tabFlags & 0x00000060) != 0) && ((pTab.aCol[iCol].colFlags & 0x0060) != 0))
					{
						pItem.colUsed = (ulong)((pTab.nCol) >= (64) ? ((ulong)(-1)) : (((ulong)(1)) << (pTab.nCol)) - 1);
					}
					else
					{
						pItem.colUsed |= (ulong)(((ulong)(1)) << ((iCol) >= ((int)(sizeof(ulong) * 8)) ? ((int)(sizeof(ulong) * 8)) - 1 : iCol));
					}
				}
			}

			return p;
		}
		public static int sqlite3CreateFunc(sqlite3 db, sbyte* zFunctionName, int nArg, int enc, void* pUserData, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal, delegate69 xValue, delegate68 xInverse, FuncDestructor pDestructor)
		{
			FuncDef p;
			int extraFlags = 0;
			if (((((((zFunctionName) == (null)) || ((xSFunc != null) && (xFinal != null))) || (((xFinal) == (null)) != ((xStep) == (null)))) || (((xValue) == (null)) != ((xInverse) == (null)))) || (((nArg) < (-1)) || ((nArg) > (127)))) || ((255) < (sqlite3Strlen30(zFunctionName))))
			{
				return (int)(sqlite3MisuseError((int)(170321)));
			}

			extraFlags = (int)(enc & (0x000000800 | 0x000080000 | 0x000100000 | 0x000200000));
			enc &= (int)(0x0003 | 5);
			extraFlags ^= (int)(0x00200000);
			switch (enc)
			{
				case 4:
					enc = (int)(2);
					break;
				case 5:
					{
						int rc = 0;
						rc = (int)(sqlite3CreateFunc(db, zFunctionName, (int)(nArg), (int)((1 | extraFlags) ^ 0x00200000), pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor));
						if ((rc) == (0))
						{
							rc = (int)(sqlite3CreateFunc(db, zFunctionName, (int)(nArg), (int)((2 | extraFlags) ^ 0x00200000), pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor));
						}

						if (rc != 0)
						{
							return (int)(rc);
						}

						enc = (int)(3);
						break;
					}

				case 1:
				case 2:
				case 3:
					break;
				default:
					enc = (int)(1);
					break;
			}

			p = sqlite3FindFunction(db, zFunctionName, (int)(nArg), (byte)(enc), (byte)(0));
			if ((((p) != null) && ((p.funcFlags & 0x0003) == ((uint)(enc)))) && ((p.nArg) == (nArg)))
			{
				if ((db.nVdbeActive) != 0)
				{
					sqlite3ErrorWithMsg(db, (int)(5), "unable to delete/modify user-function due to active statements");
					return (int)(5);
				}
				else
				{
					sqlite3ExpirePreparedStatements(db, (int)(0));
				}
			}
			else if (((xSFunc) == (null)) && ((xFinal) == (null)))
			{
				return (int)(0);
			}

			p = sqlite3FindFunction(db, zFunctionName, (int)(nArg), (byte)(enc), (byte)(1));
			if (p == null)
			{
				return (int)(7);
			}

			functionDestroy(db, p);
			if ((pDestructor) != null)
			{
				pDestructor.nRef++;
			}

			p.u.pDestructor = pDestructor;
			p.funcFlags = (uint)((p.funcFlags & 0x0003) | extraFlags);
			p.xSFunc = xSFunc ? xSFunc : xStep;
			p.xFinalize = xFinal;
			p.xValue = xValue;
			p.xInverse = xInverse;
			p.pUserData = pUserData;
			p.nArg = (sbyte)((ushort)(nArg));
			return (int)(0);
		}
		public static void sqlite3CteDelete(sqlite3 db, Cte pCte)
		{
			cteClear(db, pCte);
			sqlite3DbFree(db, pCte);
		}
		public static void sqlite3DbFree(sqlite3 db, void* p)
		{
			if ((p) != null)
				sqlite3DbFreeNN(db, p);
		}
		public static void sqlite3DbFreeNN(sqlite3 db, void* p)
		{
			if ((db) != null)
			{
				if ((db.pnBytesFreed) != null)
				{
					measureAllocationSize(db, p);
					return;
				}

				if (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))
				{
					if (((ulong)(p)) >= ((ulong)(db.lookaside.pMiddle)))
					{
						LookasideSlot* pBuf = (LookasideSlot*)(p);
						pBuf->pNext = db.lookaside.pSmallFree;
						db.lookaside.pSmallFree = pBuf;
						return;
					}

					if (((ulong)(p)) >= ((ulong)(db.lookaside.pStart)))
					{
						LookasideSlot* pBuf = (LookasideSlot*)(p);
						pBuf->pNext = db.lookaside.pFree;
						db.lookaside.pFree = pBuf;
						return;
					}
				}
			}

			sqlite3_free(p);
		}
		public static int sqlite3DbIsNamed(sqlite3 db, int iDb, sbyte* zName)
		{
			return ((((sqlite3StrICmp(db.aDb[iDb].zDbSName, zName)) == (0)) || (((iDb) == (0)) && ((sqlite3StrICmp("main", zName)) == (0)))) ? 1 : 0);
		}
		public static int sqlite3DbMallocSize(sqlite3 db, void* p)
		{
			if ((db) != null)
			{
				if (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))
				{
					if (((ulong)(p)) >= ((ulong)(db.lookaside.pMiddle)))
					{
						return (int)(128);
					}

					if (((ulong)(p)) >= ((ulong)(db.lookaside.pStart)))
					{
						return (int)(db.lookaside.szTrue);
					}
				}
			}

			return (int)(sqlite3Config.m.xSize(p));
		}
		public static Btree sqlite3DbNameToBtree(sqlite3 db, sbyte* zDbName)
		{
			int iDb = (int)((zDbName) != 0 ? sqlite3FindDbName(db, zDbName) : 0);
			return (iDb) < (0) ? null : db.aDb[iDb].pBt;
		}
		public static void sqlite3DeleteColumnNames(sqlite3 db, Table pTable)
		{
			int i = 0;
			Column* pCol;
			if ((pCol = pTable.aCol) != null)
			{
				for (i = (int)(0); (i) < (pTable.nCol); i++, pCol++)
				{
					sqlite3DbFree(db, pCol->zCnName);
				}

				sqlite3DbFree(db, pTable.aCol);
				if ((((pTable).eTabType) == (0)))
				{
					sqlite3ExprListDelete(db, pTable.u.tab.pDfltList);
				}

				if (((db) == (null)) || ((db.pnBytesFreed) == (null)))
				{
					pTable.aCol = null;
					pTable.nCol = (short)(0);
					if ((((pTable).eTabType) == (0)))
					{
						pTable.u.tab.pDfltList = null;
					}
				}
			}
		}
		public static void sqlite3DeleteIndexSamples(sqlite3 db, Index pIdx)
		{
		}
		public static void sqlite3DeleteReturning(sqlite3 db, Returning pRet)
		{
			Hash* pHash;
			pHash = &(db.aDb[1].pSchema.trigHash);
			sqlite3HashInsert(pHash, "sqlite_returning", null);
			sqlite3ExprListDelete(db, pRet.pReturnEL);
			sqlite3DbFree(db, pRet);
		}
		public static void sqlite3DeleteTable(sqlite3 db, Table pTable)
		{
			if (pTable == null)
				return;
			if ((((db == null) || ((db.pnBytesFreed) == (null))) && ((--pTable.nTabRef) > (0))))
				return;
			deleteTable(db, pTable);
		}
		public static void sqlite3DeleteTrigger(sqlite3 db, Trigger pTrigger)
		{
			if (((pTrigger) == (null)) || ((pTrigger.bReturning) != 0))
				return;
			sqlite3DeleteTriggerStep(db, pTrigger.step_list);
			sqlite3DbFree(db, pTrigger.zName);
			sqlite3DbFree(db, pTrigger.table);
			sqlite3ExprDelete(db, pTrigger.pWhen);
			sqlite3IdListDelete(db, pTrigger.pColumns);
			sqlite3DbFree(db, pTrigger);
		}
		public static void sqlite3DeleteTriggerStep(sqlite3 db, TriggerStep pTriggerStep)
		{
			while ((pTriggerStep) != null)
			{
				TriggerStep pTmp = pTriggerStep;
				pTriggerStep = pTriggerStep.pNext;
				sqlite3ExprDelete(db, pTmp.pWhere);
				sqlite3ExprListDelete(db, pTmp.pExprList);
				sqlite3SelectDelete(db, pTmp.pSelect);
				sqlite3IdListDelete(db, pTmp.pIdList);
				sqlite3UpsertDelete(db, pTmp.pUpsert);
				sqlite3SrcListDelete(db, pTmp.pFrom);
				sqlite3DbFree(db, pTmp.zSpan);
				sqlite3DbFree(db, pTmp);
			}
		}
		public static void sqlite3Error(sqlite3 db, int err_code)
		{
			db.errCode = (int)(err_code);
			if (((err_code) != 0) || ((db.pErr) != null))
			{
				sqlite3ErrorFinish(db, (int)(err_code));
			}
			else
			{
				db.errByteOffset = (int)(-1);
			}
		}
		public static void sqlite3ErrorClear(sqlite3 db)
		{
			db.errCode = (int)(0);
			db.errByteOffset = (int)(-1);
			if ((db.pErr) != null)
				sqlite3ValueSetNull(db.pErr);
		}
		public static void sqlite3ErrorFinish(sqlite3 db, int err_code)
		{
			if ((db.pErr) != null)
				sqlite3ValueSetNull(db.pErr);
			sqlite3SystemError(db, (int)(err_code));
		}
		public static int sqlite3ErrorToParser(sqlite3 db, int errCode)
		{
			Parse pParse;
			if (((db) == (null)) || ((pParse = db.pParse) == (null)))
				return (int)(errCode);
			pParse.rc = (int)(errCode);
			pParse.nErr++;
			return (int)(errCode);
		}
		public static void sqlite3ErrorWithMsg(sqlite3 db, int err_code, sbyte* zFormat)
		{
			db.errCode = (int)(err_code);
			sqlite3SystemError(db, (int)(err_code));
			if ((zFormat) == (null))
			{
				sqlite3Error(db, (int)(err_code));
			}
			else if (((db.pErr) != null) || ((db.pErr = sqlite3ValueNew(db)) != null))
			{
				sbyte* z;
				sbyte* ap;
				(__va_start(&ap, zFormat));
				z = sqlite3VMPrintf(db, zFormat, ap);
				((void)(ap = null));
				sqlite3ValueSetStr(db.pErr, (int)(-1), z, (byte)(1), ((Void(Void * ))(sqlite3OomFault)));
			}
		}
		public static void sqlite3ExpirePreparedStatements(sqlite3 db, int iCode)
		{
			Vdbe p;
			for (p = db.pVdbe; p; p = p.pNext)
			{
				p.expired = (uint)(iCode + 1);
			}
		}
		public static Expr sqlite3Expr(sqlite3 db, int op, sbyte* zToken)
		{
			Token x = new Token();
			x.z = zToken;
			x.n = (uint)(sqlite3Strlen30(zToken));
			return sqlite3ExprAlloc(db, (int)(op), &x, (int)(0));
		}
		public static Expr sqlite3ExprAlloc(sqlite3 db, int op, Token* pToken, int dequote)
		{
			Expr pNew;
			int nExtra = (int)(0);
			int iValue = (int)(0);
			if ((pToken) != null)
			{
				if (((op != 155) || ((pToken->z) == (null))) || ((sqlite3GetInt32(pToken->z, &iValue)) == (0)))
				{
					nExtra = (int)(pToken->n + 1);
				}
			}

			pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Expr) + nExtra));
			if ((pNew) != null)
			{
				CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(Expr)));
				pNew.op = ((byte)(op));
				pNew.iAgg = (short)(-1);
				if ((pToken) != null)
				{
					if ((nExtra) == (0))
					{
						pNew.flags |= (uint)(0x000400 | 0x800000 | ((iValue) != 0 ? 0x10000000 : 0x20000000));
						pNew.u.iValue = (int)(iValue);
					}
					else
					{
						pNew.u.zToken = (sbyte*)(pNew[1]);
						if ((pToken->n) != 0)
							CRuntime.memcpy(pNew.u.zToken, pToken->z, (ulong)(pToken->n));
						pNew.u.zToken[pToken->n] = (sbyte)(0);
						if (((dequote) != 0) && ((sqlite3CtypeMap[(byte)(pNew.u.zToken[0])] & 0x80) != 0))
						{
							sqlite3DequoteExpr(pNew);
						}
					}
				}

				pNew.nHeight = (int)(1);
			}

			return pNew;
		}
		public static void sqlite3ExprAttachSubtrees(sqlite3 db, Expr pRoot, Expr pLeft, Expr pRight)
		{
			if ((pRoot) == (null))
			{
				sqlite3ExprDelete(db, pLeft);
				sqlite3ExprDelete(db, pRight);
			}
			else
			{
				if ((pRight) != null)
				{
					pRoot.pRight = pRight;
					pRoot.flags |= (uint)((0x000100 | 0x200000 | 0x000004) & pRight.flags);
				}

				if ((pLeft) != null)
				{
					pRoot.pLeft = pLeft;
					pRoot.flags |= (uint)((0x000100 | 0x200000 | 0x000004) & pLeft.flags);
				}

				exprSetHeight(pRoot);
			}
		}
		public static void sqlite3ExprDelete(sqlite3 db, Expr p)
		{
			if ((p) != null)
				sqlite3ExprDeleteNN(db, p);
		}
		public static void sqlite3ExprDeleteNN(sqlite3 db, Expr p)
		{
			if (!(((p).flags & (0x004000 | 0x800000)) != 0))
			{
				if (((p.pLeft) != null) && (p.op != 178))
					sqlite3ExprDeleteNN(db, p.pLeft);
				if ((p.pRight) != null)
				{
					sqlite3ExprDeleteNN(db, p.pRight);
				}
				else if ((((p).flags & 0x000800) != 0))
				{
					sqlite3SelectDelete(db, p.x.pSelect);
				}
				else
				{
					sqlite3ExprListDelete(db, p.x.pList);
					if ((((p).flags & (0x1000000)) != 0))
					{
						sqlite3WindowDelete(db, p.y.pWin);
					}
				}
			}

			if ((((p).flags & (0x010000)) != 0))
			{
				sqlite3DbFree(db, p.u.zToken);
			}

			if (!(((p).flags & (0x8000000)) != 0))
			{
				sqlite3DbFreeNN(db, p);
			}
		}
		public static Expr sqlite3ExprDup(sqlite3 db, Expr p, int flags)
		{
			return p ? exprDup(db, p, (int)(flags), null) : null;
		}
		public static ExprList sqlite3ExprListAppendGrow(sqlite3 db, ExprList pList, Expr pExpr)
		{
			ExprList_item* pItem;
			ExprList pNew;
			pList.nAlloc *= (int)(2);
			pNew = sqlite3DbRealloc(db, pList, (ulong)(sizeof(ExprList) + (pList.nAlloc - 1) * sizeof(ExprList_item)));
			if ((pNew) == (null))
			{
				sqlite3ExprListDelete(db, pList);
				sqlite3ExprDelete(db, pExpr);
				return null;
			}
			else
			{
				pList = pNew;
			}

			pItem = &pList.a[pList.nExpr++];
			*pItem = (ExprList_item)(zeroItem);
			pItem->pExpr = pExpr;
			return pList;
		}
		public static ExprList sqlite3ExprListAppendNew(sqlite3 db, Expr pExpr)
		{
			ExprList_item* pItem;
			ExprList pList;
			pList = sqlite3DbMallocRawNN(db, (ulong)(sizeof(ExprList) + sizeof(ExprList_item) * 4));
			if ((pList) == (null))
			{
				sqlite3ExprDelete(db, pExpr);
				return null;
			}

			pList.nAlloc = (int)(4);
			pList.nExpr = (int)(1);
			pItem = &pList.a[0];
			*pItem = (ExprList_item)(zeroItem);
			pItem->pExpr = pExpr;
			return pList;
		}
		public static void sqlite3ExprListDelete(sqlite3 db, ExprList pList)
		{
			if ((pList) != null)
				exprListDeleteNN(db, pList);
		}
		public static ExprList sqlite3ExprListDup(sqlite3 db, ExprList p, int flags)
		{
			ExprList pNew;
			ExprList_item* pItem;
			ExprList_item* pOldItem;
			int i = 0;
			Expr pPriorSelectColOld = null;
			Expr pPriorSelectColNew = null;
			if ((p) == (null))
				return null;
			pNew = sqlite3DbMallocRawNN(db, (ulong)(sqlite3DbMallocSize(db, p)));
			if ((pNew) == (null))
				return null;
			pNew.nExpr = (int)(p.nExpr);
			pNew.nAlloc = (int)(p.nAlloc);
			pItem = pNew.a;
			pOldItem = p.a;
			for (i = (int)(0); (i) < (p.nExpr); i++, pItem++, pOldItem++)
			{
				Expr pOldExpr = pOldItem->pExpr;
				Expr pNewExpr;
				pItem->pExpr = sqlite3ExprDup(db, pOldExpr, (int)(flags));
				if ((((pOldExpr) != null) && ((pOldExpr.op) == (178))) && ((pNewExpr = pItem->pExpr) != null))
				{
					if ((pNewExpr.pRight) != null)
					{
						pPriorSelectColOld = pOldExpr.pRight;
						pPriorSelectColNew = pNewExpr.pRight;
						pNewExpr.pLeft = pNewExpr.pRight;
					}
					else
					{
						if (pOldExpr.pLeft != pPriorSelectColOld)
						{
							pPriorSelectColOld = pOldExpr.pLeft;
							pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, (int)(flags));
							pNewExpr.pRight = pPriorSelectColNew;
						}

						pNewExpr.pLeft = pPriorSelectColNew;
					}
				}

				pItem->zEName = sqlite3DbStrDup(db, pOldItem->zEName);
				pItem->sortFlags = (byte)(pOldItem->sortFlags);
				pItem->eEName = (uint)(pOldItem->eEName);
				pItem->done = (uint)(0);
				pItem->bNulls = (uint)(pOldItem->bNulls);
				pItem->bSorterRef = (uint)(pOldItem->bSorterRef);
				pItem->u = pOldItem->u;
			}

			return pNew;
		}
		public static CollSeq sqlite3FindCollSeq(sqlite3 db, byte enc, sbyte* zName, int create)
		{
			CollSeq pColl;
			if ((zName) != null)
			{
				pColl = findCollSeqEntry(db, zName, (int)(create));
				if ((pColl) != null)
					pColl += enc - 1;
			}
			else
			{
				pColl = db.pDfltColl;
			}

			return pColl;
		}
		public static int sqlite3FindDb(sqlite3 db, Token* pName)
		{
			int i = 0;
			sbyte* zName;
			zName = sqlite3NameFromToken(db, pName);
			i = (int)(sqlite3FindDbName(db, zName));
			sqlite3DbFree(db, zName);
			return (int)(i);
		}
		public static int sqlite3FindDbName(sqlite3 db, sbyte* zName)
		{
			int i = (int)(-1);
			if ((zName) != null)
			{
				Db pDb;
				for (i = (int)(db.nDb - 1), pDb = db.aDb[i]; (i) >= (0); i--, pDb--)
				{
					if ((0) == (sqlite3_stricmp(pDb.zDbSName, zName)))
						break;
					if (((i) == (0)) && ((0) == (sqlite3_stricmp("main", zName))))
						break;
				}
			}

			return (int)(i);
		}
		public static FuncDef sqlite3FindFunction(sqlite3 db, sbyte* zName, int nArg, byte enc, byte createFlag)
		{
			FuncDef p;
			FuncDef pBest = null;
			int bestScore = (int)(0);
			int h = 0;
			int nName = 0;
			nName = (int)(sqlite3Strlen30(zName));
			p = (FuncDef)(sqlite3HashFind(&db.aFunc, zName));
			while ((p) != null)
			{
				int score = (int)(matchQuality(p, (int)(nArg), (byte)(enc)));
				if ((score) > (bestScore))
				{
					pBest = p;
					bestScore = (int)(score);
				}

				p = p.pNext;
			}

			if ((createFlag == 0) && (((pBest) == (null)) || ((db.mDbFlags & 0x0002) != 0)))
			{
				bestScore = (int)(0);
				h = (int)(((sqlite3UpperToLower[(byte)(zName[0])]) + (nName)) % 23);
				p = sqlite3FunctionSearch((int)(h), zName);
				while ((p) != null)
				{
					int score = (int)(matchQuality(p, (int)(nArg), (byte)(enc)));
					if ((score) > (bestScore))
					{
						pBest = p;
						bestScore = (int)(score);
					}

					p = p.pNext;
				}
			}

			if ((((createFlag) != 0) && ((bestScore) < (6))) && ((pBest = sqlite3DbMallocZero(db, (ulong)(sizeof(FuncDef) + nName + 1))) != null))
			{
				FuncDef pOther;
				byte* z;
				pBest.zName = (sbyte*)(pBest[1]);
				pBest.nArg = (sbyte)((ushort)(nArg));
				pBest.funcFlags = (uint)(enc);
				CRuntime.memcpy((sbyte*)(pBest[1]), zName, (ulong)(nName + 1));
				for (z = (byte*)(pBest.zName); *z; z++)
				{
					*z = (byte)(sqlite3UpperToLower[*z]);
				}

				pOther = (FuncDef)(sqlite3HashInsert(&db.aFunc, pBest.zName, pBest));
				if ((pOther) == (pBest))
				{
					sqlite3DbFree(db, pBest);
					sqlite3OomFault(db);
					return null;
				}
				else
				{
					pBest.pNext = pOther;
				}
			}

			if (((pBest) != null) && (((pBest.xSFunc) != null) || ((createFlag) != 0)))
			{
				return pBest;
			}

			return null;
		}
		public static Index sqlite3FindIndex(sqlite3 db, sbyte* zName, sbyte* zDb)
		{
			Index p = null;
			int i = 0;
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				int j = (int)(((i) < (2)) ? i ^ 1 : i);
				Schema pSchema = db.aDb[j].pSchema;
				if (((zDb) != null) && ((sqlite3DbIsNamed(db, (int)(j), zDb)) == (0)))
					continue;
				p = sqlite3HashFind(&pSchema.idxHash, zName);
				if ((p) != null)
					break;
			}

			return p;
		}
		public static Table sqlite3FindTable(sqlite3 db, sbyte* zName, sbyte* zDatabase)
		{
			Table p = null;
			int i = 0;
			if ((zDatabase) != null)
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((sqlite3StrICmp(zDatabase, db.aDb[i].zDbSName)) == (0))
						break;
				}

				if ((i) >= (db.nDb))
				{
					if ((sqlite3StrICmp(zDatabase, "main")) == (0))
					{
						i = (int)(0);
					}
					else
					{
						return null;
					}
				}

				p = sqlite3HashFind(&db.aDb[i].pSchema.tblHash, zName);
				if (((p) == (null)) && ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0)))
				{
					if ((i) == (1))
					{
						if ((((sqlite3StrICmp(zName + 7, &"sqlite_temp_schema"[7])) == (0)) || ((sqlite3StrICmp(zName + 7, &"sqlite_schema"[7])) == (0))) || ((sqlite3StrICmp(zName + 7, &"sqlite_master"[7])) == (0)))
						{
							p = sqlite3HashFind(&db.aDb[1].pSchema.tblHash, "sqlite_temp_master");
						}
					}
					else
					{
						if ((sqlite3StrICmp(zName + 7, &"sqlite_schema"[7])) == (0))
						{
							p = sqlite3HashFind(&db.aDb[i].pSchema.tblHash, "sqlite_master");
						}
					}
				}
			}
			else
			{
				p = sqlite3HashFind(&db.aDb[1].pSchema.tblHash, zName);
				if ((p) != null)
					return p;
				p = sqlite3HashFind(&db.aDb[0].pSchema.tblHash, zName);
				if ((p) != null)
					return p;
				for (i = (int)(2); (i) < (db.nDb); i++)
				{
					p = sqlite3HashFind(&db.aDb[i].pSchema.tblHash, zName);
					if ((p) != null)
						break;
				}

				if (((p) == (null)) && ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0)))
				{
					if ((sqlite3StrICmp(zName + 7, &"sqlite_schema"[7])) == (0))
					{
						p = sqlite3HashFind(&db.aDb[0].pSchema.tblHash, "sqlite_master");
					}
					else if ((sqlite3StrICmp(zName + 7, &"sqlite_temp_schema"[7])) == (0))
					{
						p = sqlite3HashFind(&db.aDb[1].pSchema.tblHash, "sqlite_temp_master");
					}
				}
			}

			return p;
		}
		public static void sqlite3FkClearTriggerCache(sqlite3 db, int iDb)
		{
			HashElem* k;
			Hash* pHash = &db.aDb[iDb].pSchema.tblHash;
			for (k = ((pHash)->first); k; k = ((k)->next))
			{
				Table pTab = ((k)->data);
				FKey pFKey;
				if (!(((pTab).eTabType) == (0)))
					continue;
				for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
				{
					fkTriggerDelete(db, pFKey.apTrigger[0]);
					pFKey.apTrigger[0] = null;
					fkTriggerDelete(db, pFKey.apTrigger[1]);
					pFKey.apTrigger[1] = null;
				}
			}
		}
		public static void sqlite3FkDelete(sqlite3 db, Table pTab)
		{
			FKey pFKey;
			FKey pNext;
			for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pNext)
			{
				if ((db == null) || ((db.pnBytesFreed) == (null)))
				{
					if ((pFKey.pPrevTo) != null)
					{
						pFKey.pPrevTo.pNextTo = pFKey.pNextTo;
					}
					else
					{
						void* p = (void*)(pFKey.pNextTo);
						sbyte* z = (p ? pFKey.pNextTo.zTo : pFKey.zTo);
						sqlite3HashInsert(&pTab.pSchema.fkeyHash, z, p);
					}

					if ((pFKey.pNextTo) != null)
					{
						pFKey.pNextTo.pPrevTo = pFKey.pPrevTo;
					}
				}

				fkTriggerDelete(db, pFKey.apTrigger[0]);
				fkTriggerDelete(db, pFKey.apTrigger[1]);
				pNext = pFKey.pNextFrom;
				sqlite3DbFree(db, pFKey);
			}
		}
		public static void sqlite3FreeIndex(sqlite3 db, Index p)
		{
			sqlite3DeleteIndexSamples(db, p);
			sqlite3ExprDelete(db, p.pPartIdxWhere);
			sqlite3ExprListDelete(db, p.aColExpr);
			sqlite3DbFree(db, p.zColAff);
			if ((p.isResized) != 0)
				sqlite3DbFree(db, (void*)(p.azColl));
			sqlite3DbFree(db, p);
		}
		public static VTable sqlite3GetVTable(sqlite3 db, Table pTab)
		{
			VTable pVtab;
			for (pVtab = pTab.u.vtab.p; ((pVtab) != null) && (pVtab.db != db); pVtab = pVtab.pNext)
			{
			}

			return pVtab;
		}
		public static void sqlite3IdListDelete(sqlite3 db, IdList* pList)
		{
			int i = 0;
			if ((pList) == (null))
				return;
			for (i = (int)(0); (i) < (pList->nId); i++)
			{
				sqlite3DbFree(db, pList->a[i].zName);
			}

			sqlite3DbFree(db, pList->a);
			sqlite3DbFreeNN(db, pList);
		}
		public static int sqlite3Init(sqlite3 db, sbyte** pzErrMsg)
		{
			int i = 0; int rc = 0;
			int commit_internal = (int)(!(db.mDbFlags & 0x0001));
			((db).enc) = (byte)((db).aDb[0].pSchema.enc);
			if (!(((db).aDb[0].pSchema.schemaFlags & (0x0001)) == (0x0001)))
			{
				rc = (int)(sqlite3InitOne(db, (int)(0), pzErrMsg, (uint)(0)));
				if ((rc) != 0)
					return (int)(rc);
			}

			for (i = (int)(db.nDb - 1); (i) > (0); i--)
			{
				if (!(((db).aDb[i].pSchema.schemaFlags & (0x0001)) == (0x0001)))
				{
					rc = (int)(sqlite3InitOne(db, (int)(i), pzErrMsg, (uint)(0)));
					if ((rc) != 0)
						return (int)(rc);
				}
			}

			if ((commit_internal) != 0)
			{
				sqlite3CommitInternalChanges(db);
			}

			return (int)(0);
		}
		public static int sqlite3InitOne(sqlite3 db, int iDb, sbyte** pzErrMsg, uint mFlags)
		{
			int rc = 0;
			int i = 0;
			int size = 0;
			Db pDb;
			sbyte** azArg = stackalloc sbyte[6];
			int* meta = stackalloc int[5];
			InitData initData = new InitData();
			sbyte* zSchemaTabName;
			int openedTransaction = (int)(0);
			int mask = (int)((db.mDbFlags & 0x0040) | ~0x0040);
			db.init.busy = (byte)(1);
			azArg[0] = "table";
			azArg[1] = zSchemaTabName = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
			azArg[2] = azArg[1];
			azArg[3] = "1";
			azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)";
			azArg[5] = null;
			initData.db = db;
			initData.iDb = (int)(iDb);
			initData.rc = (int)(0);
			initData.pzErrMsg = pzErrMsg;
			initData.mInitFlags = (uint)(mFlags);
			initData.nInitRow = (uint)(0);
			initData.mxPage = (uint)(0);
			sqlite3InitCallback(initData, (int)(5), azArg, null);
			db.mDbFlags &= (uint)(mask);
			if ((initData.rc) != 0)
			{
				rc = (int)(initData.rc);
				goto error_out;
			}

			pDb = db.aDb[iDb];
			if ((pDb.pBt) == (null))
			{
				(db).aDb[1].pSchema.schemaFlags |= (ushort)(0x0001);
				rc = (int)(0);
				goto error_out;
			}

			sqlite3BtreeEnter(pDb.pBt);
			if ((sqlite3BtreeTxnState(pDb.pBt)) == (0))
			{
				rc = (int)(sqlite3BtreeBeginTrans(pDb.pBt, (int)(0), null));
				if (rc != 0)
				{
					sqlite3SetString(pzErrMsg, db, sqlite3ErrStr((int)(rc)));
					goto initone_error_out;
				}

				openedTransaction = (int)(1);
			}

			for (i = (int)(0); (i) < ((int)(5 * sizeof(int) / sizeof(int))); i++)
			{
				sqlite3BtreeGetMeta(pDb.pBt, (int)(i + 1), (uint*)(&meta[i]));
			}

			if ((db.flags & 0x02000000) != 0)
			{
				CRuntime.memset(meta, (int)(0), (ulong)(5 * sizeof(int)));
			}

			pDb.pSchema.schema_cookie = (int)(meta[1 - 1]);
			if ((meta[5 - 1]) != 0)
			{
				if (((iDb) == (0)) && ((db.mDbFlags & 0x0040) == (0)))
				{
					byte encoding = 0;
					encoding = (byte)((byte)(meta[5 - 1]) & 3);
					if ((encoding) == (0))
						encoding = (byte)(1);
					sqlite3SetTextEncoding(db, (byte)(encoding));
				}
				else
				{
					if ((meta[5 - 1] & 3) != ((db).enc))
					{
						sqlite3SetString(pzErrMsg, db, "attached databases must use the same text encoding as main database");
						rc = (int)(1);
						goto initone_error_out;
					}
				}
			}

			pDb.pSchema.enc = (byte)((db).enc);
			if ((pDb.pSchema.cache_size) == (0))
			{
				size = (int)(sqlite3AbsInt32((int)(meta[3 - 1])));
				if ((size) == (0))
				{
					size = (int)(-2000);
				}

				pDb.pSchema.cache_size = (int)(size);
				sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
			}

			pDb.pSchema.file_format = ((byte)(meta[2 - 1]));
			if ((pDb.pSchema.file_format) == (0))
			{
				pDb.pSchema.file_format = (byte)(1);
			}

			if ((pDb.pSchema.file_format) > (4))
			{
				sqlite3SetString(pzErrMsg, db, "unsupported file format");
				rc = (int)(1);
				goto initone_error_out;
			}

			if (((iDb) == (0)) && ((meta[2 - 1]) >= (4)))
			{
				db.flags &= (ulong)(~(ulong)(0x00000002));
			}

			initData.mxPage = (uint)(sqlite3BtreeLastPage(pDb.pBt));
			{
				sbyte* zSql;
				zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\".%s ORDER BY rowid", db.aDb[iDb].zDbSName, zSchemaTabName);
				{
					delegate67 xAuth;
					xAuth = db.xAuth;
					db.xAuth = null;
					rc = (int)(sqlite3_exec(db, zSql, sqlite3InitCallback, initData, null));
					db.xAuth = xAuth;
				}

				if ((rc) == (0))
					rc = (int)(initData.rc);
				sqlite3DbFree(db, zSql);
				if ((rc) == (0))
				{
					sqlite3AnalysisLoad(db, (int)(iDb));
				}
			}

			if ((db.mallocFailed) != 0)
			{
				rc = (int)(7);
				sqlite3ResetAllSchemasOfConnection(db);
				pDb = db.aDb[iDb];
			}
			else if (((rc) == (0)) || (((db.flags & 0x08000000) != 0) && (rc != 7)))
			{
				(db).aDb[iDb].pSchema.schemaFlags |= (ushort)(0x0001);
				rc = (int)(0);
			}

		initone_error_out:
			; if ((openedTransaction) != 0) { sqlite3BtreeCommit(pDb.pBt); }
			sqlite3BtreeLeave(pDb.pBt);
		error_out:
			; if ((rc) != 0) { if (((rc) == (7)) || ((rc) == (10 | (12 << 8)))) { sqlite3OomFault(db); } sqlite3ResetOneSchema(db, (int)(iDb)); }
			db.init.busy = (byte)(0);
			return (int)(rc);
		}
		public static int sqlite3IsLikeFunction(sqlite3 db, Expr pExpr, int* pIsNocase, sbyte* aWc)
		{
			FuncDef pDef;
			int nExpr = 0;
			if (pExpr.x.pList == null)
			{
				return (int)(0);
			}

			nExpr = (int)(pExpr.x.pList.nExpr);
			pDef = sqlite3FindFunction(db, pExpr.u.zToken, (int)(nExpr), (byte)(1), (byte)(0));
			if (((pDef) == (null)) || ((pDef.funcFlags & 0x0004) == (0)))
			{
				return (int)(0);
			}

			CRuntime.memcpy(aWc, pDef.pUserData, (ulong)(3));
			if ((nExpr) < (3))
			{
				aWc[3] = (sbyte)(0);
			}
			else
			{
				Expr pEscape = pExpr.x.pList.a[2].pExpr;
				sbyte* zEscape;
				if (pEscape.op != 117)
					return (int)(0);
				zEscape = pEscape.u.zToken;
				if (((zEscape[0]) == (0)) || (zEscape[1] != 0))
					return (int)(0);
				if ((zEscape[0]) == (aWc[0]))
					return (int)(0);
				if ((zEscape[0]) == (aWc[1]))
					return (int)(0);
				aWc[3] = (sbyte)(zEscape[0]);
			}

			*pIsNocase = (int)((pDef.funcFlags & 0x0008) == (0) ? 1 : 0);
			return (int)(1);
		}
		public static int sqlite3IsShadowTableOf(sqlite3 db, Table pTab, sbyte* zName)
		{
			int nName = 0;
			Module pMod;
			if (!(((pTab).eTabType) == (1)))
				return (int)(0);
			nName = (int)(sqlite3Strlen30(pTab.zName));
			if (sqlite3_strnicmp(zName, pTab.zName, (int)(nName)) != 0)
				return (int)(0);
			if (zName[nName] != 95)
				return (int)(0);
			pMod = (Module)(sqlite3HashFind(&db.aModule, pTab.u.vtab.azArg[0]));
			if ((pMod) == (null))
				return (int)(0);
			if ((pMod.pModule.iVersion) < (3))
				return (int)(0);
			if ((pMod.pModule.xShadowName) == (null))
				return (int)(0);
			return (int)(pMod.pModule.xShadowName(zName + nName + 1));
		}
		public static int sqlite3JsonTableFunctions(sqlite3 db)
		{
			int rc = (int)(0);
			uint i = 0;
			for (i = (uint)(0); ((i) < (2 * sizeof(aModType) / sizeof(aModType))) && ((rc) == (0)); i++)
			{
				rc = (int)(sqlite3_create_module(db, sqlite3JsonTableFunctions_aMod[i].zName, sqlite3JsonTableFunctions_aMod[i].pModule, null));
			}

			return (int)(rc);
		}
		public static KeyInfo sqlite3KeyInfoAlloc(sqlite3 db, int N, int X)
		{
			int nExtra = (int)((N + X) * (sizeof(CollSeq) + 1) - sizeof(CollSeq));
			KeyInfo p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(KeyInfo) + nExtra));
			if ((p) != null)
			{
				p.aSortFlags = (byte*)(p.aColl[N + X]);
				p.nKeyField = ((ushort)(N));
				p.nAllField = ((ushort)(N + X));
				p.enc = (byte)((db).enc);
				p.db = db;
				p.nRef = (uint)(1);
				CRuntime.memset(p[1], (int)(0), (ulong)(nExtra));
			}
			else
			{
				return (KeyInfo)(sqlite3OomFault(db));
			}

			return p;
		}
		public static void sqlite3LeaveMutexAndCloseZombie(sqlite3 db)
		{
			HashElem* i;
			int j = 0;
			if ((db.eOpenState != 0xa7) || ((connectionIsBusy(db)) != 0))
			{
				sqlite3_mutex_leave(db.mutex);
				return;
			}

			sqlite3RollbackAll(db, (int)(0));
			sqlite3CloseSavepoints(db);
			for (j = (int)(0); (j) < (db.nDb); j++)
			{
				Db pDb = db.aDb[j];
				if ((pDb.pBt) != null)
				{
					sqlite3BtreeClose(pDb.pBt);
					pDb.pBt = null;
					if (j != 1)
					{
						pDb.pSchema = null;
					}
				}
			}

			if ((db.aDb[1].pSchema) != null)
			{
				sqlite3SchemaClear(db.aDb[1].pSchema);
			}

			sqlite3VtabUnlockList(db);
			sqlite3CollapseDatabaseArray(db);
			for (i = ((&db.aFunc)->first); i; i = ((i)->next))
			{
				FuncDef pNext;
				FuncDef p;
				p = ((i)->data);
				do
				{
					functionDestroy(db, p);
					pNext = p.pNext;
					sqlite3DbFree(db, p);
					p = pNext;
				}
				while ((p) != null);
			}

			sqlite3HashClear(&db.aFunc);
			for (i = ((&db.aCollSeq)->first); i; i = ((i)->next))
			{
				CollSeq pColl = (CollSeq)((i)->data);
				for (j = (int)(0); (j) < (3); j++)
				{
					if ((pColl[j].xDel) != null)
					{
						pColl[j].xDel(pColl[j].pUser);
					}
				}

				sqlite3DbFree(db, pColl);
			}

			sqlite3HashClear(&db.aCollSeq);
			for (i = ((&db.aModule)->first); i; i = ((i)->next))
			{
				Module pMod = (Module)((i)->data);
				sqlite3VtabEponymousTableClear(db, pMod);
				sqlite3VtabModuleUnref(db, pMod);
			}

			sqlite3HashClear(&db.aModule);
			sqlite3Error(db, (int)(0));
			sqlite3ValueFree(db.pErr);
			sqlite3CloseExtensions(db);
			db.eOpenState = (byte)(0xd5);
			sqlite3DbFree(db, db.aDb[1].pSchema);
			if ((db.xAutovacDestr) != null)
			{
				db.xAutovacDestr(db.pAutovacPagesArg);
			}

			sqlite3_mutex_leave(db.mutex);
			db.eOpenState = (byte)(0xce);
			sqlite3_mutex_free(db.mutex);
			if ((db.lookaside.bMalloced) != 0)
			{
				sqlite3_free(db.lookaside.pStart);
			}

			sqlite3_free(db);
		}
		public static int sqlite3LoadExtension(sqlite3 db, sbyte* zFile, sbyte* zProc, sbyte** pzErrMsg)
		{
			sqlite3_vfs pVfs = db.pVfs;
			void* handle;
			delegate88 xInit;
			sbyte* zErrmsg = null;
			sbyte* zEntry;
			sbyte* zAltEntry = null;
			void** aHandle;
			ulong nMsg = (ulong)(CRuntime.strlen(zFile));
			int ii = 0;
			int rc = 0;
			if ((pzErrMsg) != null)
				*pzErrMsg = null;
			if ((db.flags & 0x00010000) == (0))
			{
				if ((pzErrMsg) != null)
				{
					*pzErrMsg = sqlite3_mprintf("not authorized");
				}

				return (int)(1);
			}

			zEntry = (zProc) != 0 ? zProc : "sqlite3_extension_init";
			if ((nMsg) > (260))
				goto extension_not_found;
			handle = sqlite3OsDlOpen(pVfs, zFile);
			for (ii = (int)(0); ((ii) < ((int)(1 * sizeof(sbyte) / sizeof(sbyte*)))) && ((handle) == (null)); ii++)
			{
				sbyte* zAltFile = sqlite3_mprintf("%s.%s", zFile, sqlite3LoadExtension_azEndings[ii]);
				if ((zAltFile) == (null))
					return (int)(7);
				handle = sqlite3OsDlOpen(pVfs, zAltFile);
				sqlite3_free(zAltFile);
			}

			if ((handle) == (null))
				goto extension_not_found;
			xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3OsDlSym(pVfs, handle, zEntry));
			if (((xInit) == (null)) && ((zProc) == (null)))
			{
				int iFile = 0;
				int iEntry = 0;
				int c = 0;
				int ncFile = (int)(sqlite3Strlen30(zFile));
				zAltEntry = sqlite3_malloc64((ulong)(ncFile + 30));
				if ((zAltEntry) == (null))
				{
					sqlite3OsDlClose(pVfs, handle);
					return (int)(7);
				}

				CRuntime.memcpy(zAltEntry, "sqlite3_", (ulong)(8));
				for (iFile = (int)(ncFile - 1); ((iFile) >= (0)) && (!(((zFile[iFile]) == (47)) || ((zFile[iFile]) == (92)))); iFile--)
				{
				}

				iFile++;
				if ((sqlite3_strnicmp(zFile + iFile, "lib", (int)(3))) == (0))
					iFile += (int)(3);
				for (iEntry = (int)(8); ((c = (int)(zFile[iFile])) != 0) && (c != 46); iFile++)
				{
					if ((sqlite3CtypeMap[(byte)(c)] & 0x02) != 0)
					{
						zAltEntry[iEntry++] = ((sbyte)(sqlite3UpperToLower[(uint)(c)]));
					}
				}

				CRuntime.memcpy(zAltEntry + iEntry, "_init", (ulong)(6));
				zEntry = zAltEntry;
				xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3OsDlSym(pVfs, handle, zEntry));
			}

			if ((xInit) == (null))
			{
				if ((pzErrMsg) != null)
				{
					nMsg += (ulong)(CRuntime.strlen(zEntry) + 300);
					*pzErrMsg = zErrmsg = sqlite3_malloc64((ulong)(nMsg));
					if ((zErrmsg) != null)
					{
						sqlite3_snprintf((int)(nMsg), zErrmsg, "no entry point [%s] in shared library [%s]", zEntry, zFile);
						sqlite3OsDlError(pVfs, (int)(nMsg - 1), zErrmsg);
					}
				}

				sqlite3OsDlClose(pVfs, handle);
				sqlite3_free(zAltEntry);
				return (int)(1);
			}

			sqlite3_free(zAltEntry);
			rc = (int)(xInit(db, &zErrmsg, sqlite3Apis));
			if ((rc) != 0)
			{
				if ((rc) == (0 | (1 << 8)))
					return (int)(0);
				if ((pzErrMsg) != null)
				{
					*pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
				}

				sqlite3_free(zErrmsg);
				sqlite3OsDlClose(pVfs, handle);
				return (int)(1);
			}

			aHandle = sqlite3DbMallocZero(db, (ulong)(sizeof(void*) * (db.nExtension + 1)));
			if ((aHandle) == (null))
			{
				return (int)(7);
			}

			if ((db.nExtension) > (0))
			{
				CRuntime.memcpy(aHandle, db.aExtension, (ulong)(sizeof(void*) * db.nExtension));
			}

			sqlite3DbFree(db, db.aExtension);
			db.aExtension = aHandle;
			db.aExtension[db.nExtension++] = handle;
			return (int)(0);
		extension_not_found:
			; if ((pzErrMsg) != null) { nMsg += (ulong)(300); *pzErrMsg = zErrmsg = sqlite3_malloc64((ulong)(nMsg)); if ((zErrmsg) != null) { sqlite3_snprintf((int)(nMsg), zErrmsg, "unable to open shared library [%.*s]", (int)(260), zFile); sqlite3OsDlError(pVfs, (int)(nMsg - 1), zErrmsg); } }
			return (int)(1);
		}
		public static int sqlite3LockAndPrepare(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, Vdbe pOld, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			int cnt = (int)(0);
			*ppStmt = null;
			if ((sqlite3SafetyCheckOk(db) == 0) || ((zSql) == (null)))
			{
				return (int)(sqlite3MisuseError((int)(134001)));
			}

			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			do
			{
				rc = (int)(sqlite3Prepare(db, zSql, (int)(nBytes), (uint)(prepFlags), pOld, ppStmt, pzTail));
				if (((rc) == (0)) || ((db.mallocFailed) != 0))
					break;
			}
			while (((rc) == (1 | (2 << 8))) || (((rc) == (17)) && ((sqlite3ResetOneSchema(db, (int)(-1)), cnt++) == (0))));
			sqlite3BtreeLeaveAll(db);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			db.busyHandler.nBusy = (int)(0);
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3LookasideUsed(sqlite3 db, int* pHighwater)
		{
			uint nInit = (uint)(countLookasideSlots(db.lookaside.pInit));
			uint nFree = (uint)(countLookasideSlots(db.lookaside.pFree));
			nInit += (uint)(countLookasideSlots(db.lookaside.pSmallInit));
			nFree += (uint)(countLookasideSlots(db.lookaside.pSmallFree));
			if ((pHighwater) != null)
				*pHighwater = (int)(db.lookaside.nSlot - nInit);
			return (int)(db.lookaside.nSlot - (nInit + nFree));
		}
		public static void sqlite3MarkAllShadowTablesOf(sqlite3 db, Table pTab)
		{
			int nName = 0;
			Module pMod;
			HashElem* k;
			pMod = (Module)(sqlite3HashFind(&db.aModule, pTab.u.vtab.azArg[0]));
			if ((pMod) == (null))
				return;
			if (((pMod.pModule) == (null)))
				return;
			if ((pMod.pModule.iVersion) < (3))
				return;
			if ((pMod.pModule.xShadowName) == (null))
				return;
			nName = (int)(sqlite3Strlen30(pTab.zName));
			for (k = ((&pTab.pSchema.tblHash)->first); k; k = ((k)->next))
			{
				Table pOther = ((k)->data);
				if (!(((pOther).eTabType) == (0)))
					continue;
				if ((pOther.tabFlags & 0x00001000) != 0)
					continue;
				if ((((sqlite3_strnicmp(pOther.zName, pTab.zName, (int)(nName))) == (0)) && ((pOther.zName[nName]) == (95))) && ((pMod.pModule.xShadowName(pOther.zName + nName + 1)) != 0))
				{
					pOther.tabFlags |= (uint)(0x00001000);
				}
			}
		}
		public static void sqlite3OomClear(sqlite3 db)
		{
			if (((db.mallocFailed) != 0) && ((db.nVdbeExec) == (0)))
			{
				db.mallocFailed = (byte)(0);
				(0);
				db.lookaside.bDisable--;
				db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
			}
		}
		public static Module sqlite3PragmaVtabRegister(sqlite3 db, sbyte* zName)
		{
			PragmaName* pName;
			pName = pragmaLocate(zName + 7);
			if ((pName) == (null))
				return null;
			if ((pName->mPragFlg & (0x10 | 0x20)) == (0))
				return null;
			return sqlite3VtabCreateModule(db, zName, pragmaVtabModule, (void*)(pName), null);
		}
		public static int sqlite3Prepare(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, Vdbe pReprepare, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = (int)(0);
			int i = 0;
			Parse sParse = new Parse();
			CRuntime.memset((((sbyte*)(sParse)) + ((ulong)(&((0).zErrMsg)))), (int)(0), (ulong)(((ulong)(&((0).aTempReg))) - ((ulong)(&((0).zErrMsg)))));
			CRuntime.memset((((sbyte*)(sParse)) + ((ulong)(&((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
			sParse.pOuterParse = db.pParse;
			db.pParse = sParse;
			sParse.db = db;
			sParse.pReprepare = pReprepare;
			if ((db.mallocFailed) != 0)
				sqlite3ErrorMsg(sParse, "out of memory");
			if ((prepFlags & 0x01) != 0)
			{
				sParse.disableLookaside++;
				db.lookaside.bDisable++;
				db.lookaside.sz = (ushort)(0);
			}

			sParse.disableVtab = (byte)((prepFlags & 0x04) != 0);
			if (db.noSharedCache == 0)
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeSchemaLocked(pBt));
						if ((rc) != 0)
						{
							sbyte* zDb = db.aDb[i].zDbSName;
							sqlite3ErrorWithMsg(db, (int)(rc), "database schema is locked: %s", zDb);
							goto end_prepare;
						}
					}
				}
			}

			sqlite3VtabUnlockList(db);
			if (((nBytes) >= (0)) && (((nBytes) == (0)) || (zSql[nBytes - 1] != 0)))
			{
				sbyte* zSqlCopy;
				int mxLen = (int)(db.aLimit[1]);
				if ((nBytes) > (mxLen))
				{
					sqlite3ErrorWithMsg(db, (int)(18), "statement too long");
					rc = (int)(sqlite3ApiExit(db, (int)(18)));
					goto end_prepare;
				}

				zSqlCopy = sqlite3DbStrNDup(db, zSql, (ulong)(nBytes));
				if ((zSqlCopy) != null)
				{
					sqlite3RunParser(sParse, zSqlCopy);
					sParse.zTail = &zSql[sParse.zTail - zSqlCopy];
					sqlite3DbFree(db, zSqlCopy);
				}
				else
				{
					sParse.zTail = &zSql[nBytes];
				}
			}
			else
			{
				sqlite3RunParser(sParse, zSql);
			}

			if ((pzTail) != null)
			{
				*pzTail = sParse.zTail;
			}

			if ((db.init.busy) == (0))
			{
				sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail - zSql), (byte)(prepFlags));
			}

			if ((db.mallocFailed) != 0)
			{
				sParse.rc = (int)(7);
				sParse.checkSchema = (byte)(0);
			}

			if ((sParse.rc != 0) && (sParse.rc != 101))
			{
				if (((sParse.checkSchema) != 0) && ((db.init.busy) == (0)))
				{
					schemaIsValid(sParse);
				}

				if ((sParse.pVdbe) != null)
				{
					sqlite3VdbeFinalize(sParse.pVdbe);
				}

				rc = (int)(sParse.rc);
				if ((sParse.zErrMsg) != null)
				{
					sqlite3ErrorWithMsg(db, (int)(rc), "%s", sParse.zErrMsg);
					sqlite3DbFree(db, sParse.zErrMsg);
				}
				else
				{
					sqlite3Error(db, (int)(rc));
				}
			}
			else
			{
				*ppStmt = (sqlite3_stmt*)(sParse.pVdbe);
				rc = (int)(0);
				sqlite3ErrorClear(db);
			}

			while ((sParse.pTriggerPrg) != null)
			{
				TriggerPrg pT = sParse.pTriggerPrg;
				sParse.pTriggerPrg = pT.pNext;
				sqlite3DbFree(db, pT);
			}

		end_prepare:
			; sqlite3ParseObjectReset(sParse);
			return (int)(rc);
		}
		public static int sqlite3Prepare16(sqlite3 db, void* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, void** pzTail)
		{
			sbyte* zSql8;
			sbyte* zTail8 = null;
			int rc = (int)(0);
			*ppStmt = null;
			if ((sqlite3SafetyCheckOk(db) == 0) || ((zSql) == (null)))
			{
				return (int)(sqlite3MisuseError((int)(134149)));
			}

			if ((nBytes) >= (0))
			{
				int sz = 0;
				sbyte* z = (sbyte*)(zSql);
				for (sz = (int)(0); ((sz) < (nBytes)) && ((z[sz] != 0) || (z[sz + 1] != 0)); sz += (int)(2))
				{
				}

				nBytes = (int)(sz);
			}

			sqlite3_mutex_enter(db.mutex);
			zSql8 = sqlite3Utf16to8(db, zSql, (int)(nBytes), (byte)(2));
			if ((zSql8) != null)
			{
				rc = (int)(sqlite3LockAndPrepare(db, zSql8, (int)(-1), (uint)(prepFlags), null, ppStmt, &zTail8));
			}

			if (((zTail8) != null) && ((pzTail) != null))
			{
				int chars_parsed = (int)(sqlite3Utf8CharLen(zSql8, (int)(zTail8 - zSql8)));
				*pzTail = (byte*)(zSql) + sqlite3Utf16ByteLen(zSql, (int)(chars_parsed));
			}

			sqlite3DbFree(db, zSql8);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3ReadOnlyShadowTables(sqlite3 db)
		{
			if (((((db.flags & 0x10000000) != 0) && ((db.pVtabCtx) == (null))) && ((db.nVdbeExec) == (0))) && (!((((db).nVTrans) > (0)) && (((db).aVTrans) == (null)))))
			{
				return (int)(1);
			}

			return (int)(0);
		}
		public static void sqlite3RecordErrorByteOffset(sqlite3 db, sbyte* z)
		{
			Parse pParse;
			sbyte* zText;
			sbyte* zEnd;
			if (((db) == (null)))
				return;
			if (db.errByteOffset != (-2))
				return;
			pParse = db.pParse;
			if (((pParse) == (null)))
				return;
			zText = pParse.zTail;
			if (((zText) == (null)))
				return;
			zEnd = &zText[CRuntime.strlen(zText)];
			if (((((ulong)(z)) >= ((ulong)(zText))) && (((ulong)(z)) < ((ulong)(zEnd)))))
			{
				db.errByteOffset = ((int)(z - zText));
			}
		}
		public static void sqlite3RecordErrorOffsetOfExpr(sqlite3 db, Expr pExpr)
		{
			while (((pExpr) != null) && ((((pExpr).flags & (0x000001)) != 0) || ((pExpr.w.iOfst) <= (0))))
			{
				pExpr = pExpr.pLeft;
			}

			if ((pExpr) == (null))
				return;
			db.errByteOffset = (int)(pExpr.w.iOfst);
		}
		public static void sqlite3RegisterLikeFunctions(sqlite3 db, int caseSensitive)
		{
			compareInfo* pInfo;
			int flags = 0;
			if ((caseSensitive) != 0)
			{
				pInfo = &likeInfoAlt;
				flags = (int)(0x0004 | 0x0008);
			}
			else
			{
				pInfo = &likeInfoNorm;
				flags = (int)(0x0004);
			}

			sqlite3CreateFunc(db, "like", (int)(2), (int)(1), pInfo, likeFunc, null, null, null, null, null);
			sqlite3CreateFunc(db, "like", (int)(3), (int)(1), pInfo, likeFunc, null, null, null, null, null);
			sqlite3FindFunction(db, "like", (int)(2), (byte)(1), (byte)(0)).funcFlags |= (uint)(flags);
			sqlite3FindFunction(db, "like", (int)(3), (byte)(1), (byte)(0)).funcFlags |= (uint)(flags);
		}
		public static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 db)
		{
			int rc = (int)(sqlite3_overload_function(db, "MATCH", (int)(2)));
			if ((rc) == (7))
			{
				sqlite3OomFault(db);
			}
		}
		public static void sqlite3ResetAllSchemasOfConnection(sqlite3 db)
		{
			int i = 0;
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Db pDb = db.aDb[i];
				if ((pDb.pSchema) != null)
				{
					if ((db.nSchemaLock) == (0))
					{
						sqlite3SchemaClear(pDb.pSchema);
					}
					else
					{
						(db).aDb[i].pSchema.schemaFlags |= (ushort)(0x0008);
					}
				}
			}

			db.mDbFlags &= (uint)(~(0x0001 | 0x0010));
			sqlite3VtabUnlockList(db);
			sqlite3BtreeLeaveAll(db);
			if ((db.nSchemaLock) == (0))
			{
				sqlite3CollapseDatabaseArray(db);
			}
		}
		public static void sqlite3ResetOneSchema(sqlite3 db, int iDb)
		{
			int i = 0;
			if ((iDb) >= (0))
			{
				(db).aDb[iDb].pSchema.schemaFlags |= (ushort)(0x0008);
				(db).aDb[1].pSchema.schemaFlags |= (ushort)(0x0008);
				db.mDbFlags &= (uint)(~0x0010);
			}

			if ((db.nSchemaLock) == (0))
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((((db).aDb[i].pSchema.schemaFlags & (0x0008)) == (0x0008)))
					{
						sqlite3SchemaClear(db.aDb[i].pSchema);
					}
				}
			}
		}
		public static void sqlite3RollbackAll(sqlite3 db, int tripCode)
		{
			int i = 0;
			int inTrans = (int)(0);
			int schemaChange = 0;
			sqlite3BeginBenignMalloc();
			sqlite3BtreeEnterAll(db);
			schemaChange = (int)(((db.mDbFlags & 0x0001) != 0) && ((db.init.busy) == (0)) ? 1 : 0);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Btree p = db.aDb[i].pBt;
				if ((p) != null)
				{
					if ((sqlite3BtreeTxnState(p)) == (2))
					{
						inTrans = (int)(1);
					}

					sqlite3BtreeRollback(p, (int)(tripCode), (int)(!schemaChange));
				}
			}

			sqlite3VtabRollback(db);
			sqlite3EndBenignMalloc();
			if ((schemaChange) != 0)
			{
				sqlite3ExpirePreparedStatements(db, (int)(0));
				sqlite3ResetAllSchemasOfConnection(db);
			}

			sqlite3BtreeLeaveAll(db);
			db.nDeferredCons = (long)(0);
			db.nDeferredImmCons = (long)(0);
			db.flags &= (ulong)(~(0x00080000 | ((ulong)(0x00002) << 32)));
			if (((db.xRollbackCallback) != null) && (((inTrans) != 0) || (db.autoCommit == 0)))
			{
				db.xRollbackCallback(db.pRollbackArg);
			}
		}
		public static void sqlite3RootPageMoved(sqlite3 db, int iDb, uint iFrom, uint iTo)
		{
			HashElem* pElem;
			Hash* pHash;
			Db pDb;
			pDb = db.aDb[iDb];
			pHash = &pDb.pSchema.tblHash;
			for (pElem = ((pHash)->first); pElem; pElem = ((pElem)->next))
			{
				Table pTab = ((pElem)->data);
				if ((pTab.tnum) == (iFrom))
				{
					pTab.tnum = (uint)(iTo);
				}
			}

			pHash = &pDb.pSchema.idxHash;
			for (pElem = ((pHash)->first); pElem; pElem = ((pElem)->next))
			{
				Index pIdx = ((pElem)->data);
				if ((pIdx.tnum) == (iFrom))
				{
					pIdx.tnum = (uint)(iTo);
				}
			}
		}
		public static RowSet sqlite3RowSetInit(sqlite3 db)
		{
			RowSet p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(RowSet)));
			if ((p) != null)
			{
				int N = (int)(sqlite3DbMallocSize(db, p));
				p.pChunk = null;
				p.db = db;
				p.pEntry = null;
				p.pLast = null;
				p.pForest = null;
				p.pFresh = (RowSetEntry*)((((sizeof(RowSet)) + 7) & ~7) + (sbyte*)(p));
				p.nFresh = ((ushort)((N - (((sizeof(RowSet)) + 7) & ~7)) / sizeof(RowSetEntry)));
				p.rsFlags = (ushort)(0x01);
				p.iBatch = (int)(0);
			}

			return p;
		}
		public static int sqlite3SafetyCheckOk(sqlite3 db)
		{
			byte eOpenState = 0;
			if ((db) == (null))
			{
				logBadConnection("NULL");
				return (int)(0);
			}

			eOpenState = (byte)(db.eOpenState);
			if (eOpenState != 0x76)
			{
				if ((sqlite3SafetyCheckSickOrOk(db)) != 0)
				{
					logBadConnection("unopened");
				}

				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static int sqlite3SafetyCheckSickOrOk(sqlite3 db)
		{
			byte eOpenState = 0;
			eOpenState = (byte)(db.eOpenState);
			if (((eOpenState != 0xba) && (eOpenState != 0x76)) && (eOpenState != 0x6d))
			{
				logBadConnection("invalid");
				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static Schema sqlite3SchemaGet(sqlite3 db, Btree pBt)
		{
			Schema p;
			if ((pBt) != null)
			{
				p = (Schema)(sqlite3BtreeSchema(pBt, (int)(sizeof(Schema)), sqlite3SchemaClear));
			}
			else
			{
				p = (Schema)(sqlite3DbMallocZero(null, (ulong)(sizeof(Schema))));
			}

			if (p == null)
			{
				sqlite3OomFault(db);
			}
			else if ((0) == (p.file_format))
			{
				sqlite3HashInit(&p.tblHash);
				sqlite3HashInit(&p.idxHash);
				sqlite3HashInit(&p.trigHash);
				sqlite3HashInit(&p.fkeyHash);
				p.enc = (byte)(1);
			}

			return p;
		}
		public static int sqlite3SchemaToIndex(sqlite3 db, Schema pSchema)
		{
			int i = (int)(-32768);
			if ((pSchema) != null)
			{
				for (i = (int)(0); 1; i++)
				{
					if ((db.aDb[i].pSchema) == (pSchema))
					{
						break;
					}
				}
			}

			return (int)(i);
		}
		public static void sqlite3SelectDelete(sqlite3 db, Select p)
		{
			if ((p) != null)
				clearSelect(db, p, (int)(1));
		}
		public static Select sqlite3SelectDup(sqlite3 db, Select pDup, int flags)
		{
			Select pRet = null;
			Select pNext = null;
			Select pp = pRet;
			Select p;
			for (p = pDup; p; p = p.pPrior)
			{
				Select pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Select)));
				if ((pNew) == (null))
					break;
				pNew.pEList = sqlite3ExprListDup(db, p.pEList, (int)(flags));
				pNew.pSrc = sqlite3SrcListDup(db, p.pSrc, (int)(flags));
				pNew.pWhere = sqlite3ExprDup(db, p.pWhere, (int)(flags));
				pNew.pGroupBy = sqlite3ExprListDup(db, p.pGroupBy, (int)(flags));
				pNew.pHaving = sqlite3ExprDup(db, p.pHaving, (int)(flags));
				pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, (int)(flags));
				pNew.op = (byte)(p.op);
				pNew.pNext = pNext;
				pNew.pPrior = null;
				pNew.pLimit = sqlite3ExprDup(db, p.pLimit, (int)(flags));
				pNew.iLimit = (int)(0);
				pNew.iOffset = (int)(0);
				pNew.selFlags = (uint)(p.selFlags & ~0x0000020);
				pNew.addrOpenEphm[0] = (int)(-1);
				pNew.addrOpenEphm[1] = (int)(-1);
				pNew.nSelectRow = (short)(p.nSelectRow);
				pNew.pWith = sqlite3WithDup(db, p.pWith);
				pNew.pWin = null;
				pNew.pWinDefn = sqlite3WindowListDup(db, p.pWinDefn);
				if (((p.pWin) != null) && ((db.mallocFailed) == (0)))
					gatherSelectWindows(pNew);
				pNew.selId = (uint)(p.selId);
				if ((db.mallocFailed) != 0)
				{
					pNew.pNext = null;
					sqlite3SelectDelete(db, pNew);
					break;
				}

				pp = pNew;
				pp = pNew.pPrior;
				pNext = pNew;
			}

			return pRet;
		}
		public static void sqlite3SetTextEncoding(sqlite3 db, byte enc)
		{
			db.enc = (byte)(enc);
			db.pDfltColl = sqlite3FindCollSeq(db, (byte)(enc), sqlite3StrBINARY, (int)(0));
		}
		public static int sqlite3ShadowTableName(sqlite3 db, sbyte* zName)
		{
			sbyte* zTail;
			Table pTab;
			zTail = strrchr(zName, (int)(95));
			if ((zTail) == (null))
				return (int)(0);
			*zTail = (sbyte)(0);
			pTab = sqlite3FindTable(db, zName, null);
			*zTail = (sbyte)(95);
			if ((pTab) == (null))
				return (int)(0);
			if (!(((pTab).eTabType) == (1)))
				return (int)(0);
			return (int)(sqlite3IsShadowTableOf(db, pTab, zName));
		}
		public static void sqlite3SrcListDelete(sqlite3 db, SrcList pList)
		{
			int i = 0;
			SrcItem pItem;
			if ((pList) == (null))
				return;
			for (pItem = pList.a, i = (int)(0); (i) < (pList.nSrc); i++, pItem++)
			{
				if ((pItem.zDatabase) != null)
					sqlite3DbFreeNN(db, pItem.zDatabase);
				sqlite3DbFree(db, pItem.zName);
				if ((pItem.zAlias) != null)
					sqlite3DbFreeNN(db, pItem.zAlias);
				if ((pItem.fg.isIndexedBy) != 0)
					sqlite3DbFree(db, pItem.u1.zIndexedBy);
				if ((pItem.fg.isTabFunc) != 0)
					sqlite3ExprListDelete(db, pItem.u1.pFuncArg);
				sqlite3DeleteTable(db, pItem.pTab);
				if ((pItem.pSelect) != null)
					sqlite3SelectDelete(db, pItem.pSelect);
				if ((pItem.pOn) != null)
					sqlite3ExprDelete(db, pItem.pOn);
				if ((pItem.pUsing) != null)
					sqlite3IdListDelete(db, pItem.pUsing);
			}

			sqlite3DbFreeNN(db, pList);
		}
		public static SrcList sqlite3SrcListDup(sqlite3 db, SrcList p, int flags)
		{
			SrcList pNew;
			int i = 0;
			int nByte = 0;
			if ((p) == (null))
				return null;
			nByte = (int)(sizeof(SrcList) + ((p.nSrc) > (0) ? sizeof(SrcItem) * (p.nSrc - 1) : 0));
			pNew = sqlite3DbMallocRawNN(db, (ulong)(nByte));
			if ((pNew) == (null))
				return null;
			pNew.nSrc = (int)(pNew.nAlloc = (uint)(p.nSrc));
			for (i = (int)(0); (i) < (p.nSrc); i++)
			{
				SrcItem pNewItem = pNew.a[i];
				SrcItem pOldItem = p.a[i];
				Table pTab;
				pNewItem.pSchema = pOldItem.pSchema;
				pNewItem.zDatabase = sqlite3DbStrDup(db, pOldItem.zDatabase);
				pNewItem.zName = sqlite3DbStrDup(db, pOldItem.zName);
				pNewItem.zAlias = sqlite3DbStrDup(db, pOldItem.zAlias);
				pNewItem.fg = (SrcItem::(unnamed at sqlite3.c : 18322 : 3))(pOldItem.fg);
				pNewItem.iCursor = (int)(pOldItem.iCursor);
				pNewItem.addrFillSub = (int)(pOldItem.addrFillSub);
				pNewItem.regReturn = (int)(pOldItem.regReturn);
				if ((pNewItem.fg.isIndexedBy) != 0)
				{
					pNewItem.u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem.u1.zIndexedBy);
				}

				pNewItem.u2 = pOldItem.u2; if ((pNewItem.fg.isCte) != 0) { pNewItem.u2.pCteUse->nUse++; }
				if ((pNewItem.fg.isTabFunc) != 0) { pNewItem.u1.pFuncArg = sqlite3ExprListDup(db, pOldItem.u1.pFuncArg, (int)(flags)); }
				pTab = pNewItem.pTab = pOldItem.pTab; if ((pTab) != null) { pTab.nTabRef++; }
				pNewItem.pSelect = sqlite3SelectDup(db, pOldItem.pSelect, (int)(flags)); pNewItem.pOn = sqlite3ExprDup(db, pOldItem.pOn, (int)(flags)); pNewItem.pUsing = sqlite3IdListDup(db, pOldItem.pUsing); pNewItem.colUsed = (ulong)(pOldItem.colUsed);
			}

			return pNew;
		}
		public static void sqlite3SystemError(sqlite3 db, int rc)
		{
			if ((rc) == (10 | (12 << 8)))
				return;
			rc &= (int)(0xff);
			if (((rc) == (14)) || ((rc) == (10)))
			{
				db.iSysErrno = (int)(sqlite3OsGetLastError(db.pVfs));
			}
		}
		public static int sqlite3TempInMemory(sqlite3 db)
		{
			return (((db.temp_store) == (2)) ? 1 : 0);
		}
		public static int sqlite3TestExtInit(sqlite3 db)
		{
			(void)(db);
			return (int)(sqlite3FaultSim((int)(500)));
		}
		public static TriggerStep sqlite3TriggerSelectStep(sqlite3 db, Select pSelect, sbyte* zStart, sbyte* zEnd)
		{
			TriggerStep pTriggerStep = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerStep)));
			if ((pTriggerStep) == (null))
			{
				sqlite3SelectDelete(db, pSelect);
				return null;
			}

			pTriggerStep.op = (byte)(138);
			pTriggerStep.pSelect = pSelect;
			pTriggerStep.orconf = (byte)(11);
			pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd);
			return pTriggerStep;
		}
		public static void sqlite3UnlinkAndDeleteIndex(sqlite3 db, int iDb, sbyte* zIdxName)
		{
			Index pIndex;
			Hash* pHash;
			pHash = &db.aDb[iDb].pSchema.idxHash;
			pIndex = sqlite3HashInsert(pHash, zIdxName, null);
			if ((pIndex) != null)
			{
				if ((pIndex.pTable.pIndex) == (pIndex))
				{
					pIndex.pTable.pIndex = pIndex.pNext;
				}
				else
				{
					Index p;
					p = pIndex.pTable.pIndex;
					while (((p) != null) && (p.pNext != pIndex))
					{
						p = p.pNext;
					}

					if ((((p) != null) && ((p.pNext) == (pIndex))))
					{
						p.pNext = pIndex.pNext;
					}
				}

				sqlite3FreeIndex(db, pIndex);
			}

			db.mDbFlags |= (uint)(0x0001);
		}
		public static void sqlite3UnlinkAndDeleteTable(sqlite3 db, int iDb, sbyte* zTabName)
		{
			Table p;
			Db pDb;
			pDb = db.aDb[iDb];
			p = sqlite3HashInsert(&pDb.pSchema.tblHash, zTabName, null);
			sqlite3DeleteTable(db, p);
			db.mDbFlags |= (uint)(0x0001);
		}
		public static void sqlite3UnlinkAndDeleteTrigger(sqlite3 db, int iDb, sbyte* zName)
		{
			Trigger pTrigger;
			Hash* pHash;
			pHash = &(db.aDb[iDb].pSchema.trigHash);
			pTrigger = sqlite3HashInsert(pHash, zName, null);
			if ((pTrigger) != null)
			{
				if ((pTrigger.pSchema) == (pTrigger.pTabSchema))
				{
					Table pTab = tableOfTrigger(pTrigger);
					if ((pTab) != null)
					{
						Trigger pp;
						for (pp = pTab.pTrigger; pp; pp = ((pp).pNext))
						{
							if ((pp) == (pTrigger))
							{
								pp = (pp).pNext;
								break;
							}
						}
					}
				}

				sqlite3DeleteTrigger(db, pTrigger);
				db.mDbFlags |= (uint)(0x0001);
			}
		}
		public static void sqlite3UpsertDelete(sqlite3 db, Upsert p)
		{
			if ((p) != null)
				upsertDelete(db, p);
		}
		public static Upsert sqlite3UpsertDup(sqlite3 db, Upsert p)
		{
			if ((p) == (null))
				return null;
			return sqlite3UpsertNew(db, sqlite3ExprListDup(db, p.pUpsertTarget, (int)(0)), sqlite3ExprDup(db, p.pUpsertTargetWhere, (int)(0)), sqlite3ExprListDup(db, p.pUpsertSet, (int)(0)), sqlite3ExprDup(db, p.pUpsertWhere, (int)(0)), sqlite3UpsertDup(db, p.pNextUpsert));
		}
		public static Upsert sqlite3UpsertNew(sqlite3 db, ExprList pTarget, Expr pTargetWhere, ExprList pSet, Expr pWhere, Upsert pNext)
		{
			Upsert pNew;
			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Upsert)));
			if ((pNew) == (null))
			{
				sqlite3ExprListDelete(db, pTarget);
				sqlite3ExprDelete(db, pTargetWhere);
				sqlite3ExprListDelete(db, pSet);
				sqlite3ExprDelete(db, pWhere);
				sqlite3UpsertDelete(db, pNext);
				return null;
			}
			else
			{
				pNew.pUpsertTarget = pTarget;
				pNew.pUpsertTargetWhere = pTargetWhere;
				pNew.pUpsertSet = pSet;
				pNew.pUpsertWhere = pWhere;
				pNew.isDoUpdate = (byte)(pSet != null);
				pNew.pNextUpsert = pNext;
			}

			return pNew;
		}
		public static int sqlite3ValueFromExpr(sqlite3 db, Expr pExpr, byte enc, byte affinity, sqlite3_value ppVal)
		{
			return (int)(pExpr ? valueFromExpr(db, pExpr, (byte)(enc), (byte)(affinity), ppVal, null) : 0);
		}
		public static sqlite3_value sqlite3ValueNew(sqlite3 db)
		{
			sqlite3_value p = sqlite3DbMallocZero(db, (ulong)(sizeof(sqlite3_value)));
			if ((p) != null)
			{
				p.flags = (ushort)(0x0001);
				p.db = db;
			}

			return p;
		}
		public static void sqlite3VdbeClearObject(sqlite3 db, Vdbe p)
		{
			SubProgram* pSub; SubProgram* pNext;
			releaseMemArray(p.aColName, (int)(p.nResColumn * 2));
			for (pSub = p.pProgram; pSub; pSub = pNext)
			{
				pNext = pSub->pNext;
				vdbeFreeOpArray(db, pSub->aOp, (int)(pSub->nOp));
				sqlite3DbFree(db, pSub);
			}

			if (p.iVdbeMagic != 0x16bceaa5)
			{
				releaseMemArray(p.aVar, (int)(p.nVar));
				sqlite3DbFree(db, p.pVList);
				sqlite3DbFree(db, p.pFree);
			}

			vdbeFreeOpArray(db, p.aOp, (int)(p.nOp));
			sqlite3DbFree(db, p.aColName);
			sqlite3DbFree(db, p.zSql);
		}
		public static void sqlite3VdbeDeleteAuxData(sqlite3 db, AuxData pp, int iOp, int mask)
		{
			while ((pp) != null)
			{
				AuxData pAux = pp;
				if (((iOp) < (0)) || ((((pAux.iAuxOp) == (iOp)) && ((pAux.iAuxArg) >= (0))) && (((pAux.iAuxArg) > (31)) || ((mask & (((uint)(1)) << (pAux.iAuxArg))) == 0))))
				{
					if ((pAux.xDeleteAux) != null)
					{
						pAux.xDeleteAux(pAux.pAux);
					}

					pp = pAux.pNextAux;
					sqlite3DbFree(db, pAux);
				}
				else
				{
					pp = pAux.pNextAux;
				}
			}
		}
		public static int sqlite3VdbeIdxKeyCompare(sqlite3 db, VdbeCursor pC, UnpackedRecord pUnpacked, int* res)
		{
			long nCellKey = (long)(0);
			int rc = 0;
			BtCursor pCur;
			sqlite3_value m = new sqlite3_value();
			pCur = pC.uc.pCursor;
			nCellKey = (long)(sqlite3BtreePayloadSize(pCur));
			if (((nCellKey) <= (0)) || ((nCellKey) > (0x7fffffff)))
			{
				*res = (int)(0);
				return (int)(sqlite3CorruptError((int)(84809)));
			}

			sqlite3VdbeMemInit(m, db, (ushort)(0));
			rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			*res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(m.n), m.z, pUnpacked, (int)(0)));
			sqlite3VdbeMemRelease(m);
			return (int)(0);
		}
		public static int sqlite3VdbeIdxRowid(sqlite3 db, BtCursor pCur, long* rowid)
		{
			long nCellKey = (long)(0);
			int rc = 0;
			uint szHdr = 0;
			uint typeRowid = 0;
			uint lenRowid = 0;
			sqlite3_value m = new sqlite3_value(); sqlite3_value v = new sqlite3_value();
			nCellKey = (long)(sqlite3BtreePayloadSize(pCur));
			sqlite3VdbeMemInit(m, db, (ushort)(0));
			rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			szHdr = ((uint)(*((byte*)(m.z))));
			if ((szHdr) >= (0x80))
				sqlite3GetVarint32(((byte*)(m.z)), &(szHdr));
			if ((((szHdr) < (3)) || ((szHdr) > ((uint)(m.n)))))
			{
				goto idx_rowid_corruption;
			}

			typeRowid = ((uint)(*((byte*)(&m.z[szHdr - 1]))));
			if ((typeRowid) >= (0x80))
				sqlite3GetVarint32(((byte*)(&m.z[szHdr - 1])), &(typeRowid));
			if (((((typeRowid) < (1)) || ((typeRowid) > (9))) || ((typeRowid) == (7))))
			{
				goto idx_rowid_corruption;
			}

			lenRowid = (uint)(sqlite3SmallTypeSizes[typeRowid]);
			if ((((uint)(m.n)) < (szHdr + lenRowid)))
			{
				goto idx_rowid_corruption;
			}

			sqlite3VdbeSerialGet((byte*)(&m.z[m.n - lenRowid]), (uint)(typeRowid), v);
			*rowid = (long)(v.u.i);
			sqlite3VdbeMemRelease(m);
			return (int)(0);
		idx_rowid_corruption:
			;
			sqlite3VdbeMemRelease(m);
			return (int)(sqlite3CorruptError((int)(84776)));
		}
		public static void sqlite3VdbeSetChanges(sqlite3 db, long nChange)
		{
			db.nChange = (long)(nChange);
			db.nTotalChange += (long)(nChange);
		}
		public static void sqlite3VdbeSorterClose(sqlite3 db, VdbeCursor pCsr)
		{
			VdbeSorter pSorter;
			pSorter = pCsr.uc.pSorter;
			if ((pSorter) != null)
			{
				sqlite3VdbeSorterReset(db, pSorter);
				sqlite3_free(pSorter.list.aMemory);
				sqlite3DbFree(db, pSorter);
				pCsr.uc.pSorter = null;
			}
		}
		public static int sqlite3VdbeSorterInit(sqlite3 db, int nField, VdbeCursor pCsr)
		{
			int pgsz = 0;
			int i = 0;
			VdbeSorter pSorter;
			KeyInfo pKeyInfo;
			int szKeyInfo = 0;
			int sz = 0;
			int rc = (int)(0);
			int nWorker = 0;
			if (((sqlite3TempInMemory(db)) != 0) || ((sqlite3Config.bCoreMutex) == (0)))
			{
				nWorker = (int)(0);
			}
			else
			{
				nWorker = (int)(db.aLimit[11]);
			}

			szKeyInfo = (int)(sizeof(KeyInfo) + (pCsr.pKeyInfo.nKeyField - 1) * sizeof(CollSeq));
			sz = (int)(sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask));
			pSorter = (VdbeSorter)(sqlite3DbMallocZero(db, (ulong)(sz + szKeyInfo)));
			pCsr.uc.pSorter = pSorter;
			if ((pSorter) == (null))
			{
				rc = (int)(7);
			}
			else
			{
				Btree pBt = db.aDb[0].pBt;
				pSorter.pKeyInfo = pKeyInfo = (KeyInfo)((byte*)(pSorter) + sz);
				CRuntime.memcpy(pKeyInfo, pCsr.pKeyInfo, (ulong)(szKeyInfo));
				pKeyInfo.db = null;
				if (((nField) != 0) && ((nWorker) == (0)))
				{
					pKeyInfo.nKeyField = (ushort)(nField);
				}

				sqlite3BtreeEnter(pBt);
				pSorter.pgsz = (int)(pgsz = (int)(sqlite3BtreeGetPageSize(pBt)));
				sqlite3BtreeLeave(pBt);
				pSorter.nTask = (byte)(nWorker + 1);
				pSorter.iPrev = ((byte)(nWorker - 1));
				pSorter.bUseThreads = (byte)((pSorter.nTask) > (1));
				pSorter.db = db;
				for (i = (int)(0); (i) < (pSorter.nTask); i++)
				{
					SortSubtask pTask = pSorter.aTask[i];
					pTask.pSorter = pSorter;
				}

				if (sqlite3TempInMemory(db) == 0)
				{
					long mxCache = 0;
					uint szPma = (uint)(sqlite3Config.szPma);
					pSorter.mnPmaSize = (int)(szPma * pgsz);
					mxCache = (long)(db.aDb[0].pSchema.cache_size);
					if ((mxCache) < (0))
					{
						mxCache = (long)(mxCache * -1024);
					}
					else
					{
						mxCache = (long)(mxCache * pgsz);
					}

					mxCache = (long)((mxCache) < (1 << 29) ? (mxCache) : (1 << 29));
					pSorter.mxPmaSize = (int)((pSorter.mnPmaSize) > ((int)(mxCache)) ? (pSorter.mnPmaSize) : ((int)(mxCache)));
					if ((sqlite3Config.bSmallMalloc) == (0))
					{
						pSorter.nMemory = (int)(pgsz);
						pSorter.list.aMemory = (byte*)(sqlite3Malloc((ulong)(pgsz)));
						if (pSorter.list.aMemory == null)
							rc = (int)(7);
					}
				}

				if ((((pKeyInfo.nAllField) < (13)) && (((pKeyInfo.aColl[0]) == (null)) || ((pKeyInfo.aColl[0]) == (db.pDfltColl)))) && ((pKeyInfo.aSortFlags[0] & 0x02) == (0)))
				{
					pSorter.typeMask = (byte)(0x01 | 0x02);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeSorterNext(sqlite3 db, VdbeCursor pCsr)
		{
			VdbeSorter pSorter;
			int rc = 0;
			pSorter = pCsr.uc.pSorter;
			if ((pSorter.bUsePMA) != 0)
			{
				if ((pSorter.bUseThreads) != 0)
				{
					rc = (int)(vdbePmaReaderNext(pSorter.pReader));
					if (((rc) == (0)) && ((pSorter.pReader.pFd) == (null)))
						rc = (int)(101);
				}
				else
				{
					int res = (int)(0);
					rc = (int)(vdbeMergeEngineStep(pSorter.pMerger, &res));
					if (((rc) == (0)) && ((res) != 0))
						rc = (int)(101);
				}
			}
			else
			{
				SorterRecord* pFree = pSorter.list.pList;
				pSorter.list.pList = pFree->u.pNext;
				pFree->u.pNext = null;
				if ((pSorter.list.aMemory) == (null))
					vdbeSorterRecordFree(db, pFree);
				rc = (int)(pSorter.list.pList ? 0 : 101);
			}

			return (int)(rc);
		}
		public static void sqlite3VdbeSorterReset(sqlite3 db, VdbeSorter pSorter)
		{
			int i = 0;
			(void)(vdbeSorterJoinAll(pSorter, (int)(0)));
			if ((pSorter.pReader) != null)
			{
				vdbePmaReaderClear(pSorter.pReader);
				sqlite3DbFree(db, pSorter.pReader);
				pSorter.pReader = null;
			}

			vdbeMergeEngineFree(pSorter.pMerger);
			pSorter.pMerger = null;
			for (i = (int)(0); (i) < (pSorter.nTask); i++)
			{
				SortSubtask pTask = pSorter.aTask[i];
				vdbeSortSubtaskCleanup(db, pTask);
				pTask.pSorter = pSorter;
			}

			if ((pSorter.list.aMemory) == (null))
			{
				vdbeSorterRecordFree(null, pSorter.list.pList);
			}

			pSorter.list.pList = null;
			pSorter.list.szPMA = (int)(0);
			pSorter.bUsePMA = (byte)(0);
			pSorter.iMemory = (int)(0);
			pSorter.mxKeysize = (int)(0);
			sqlite3DbFree(db, pSorter.pUnpacked);
			pSorter.pUnpacked = null;
		}
		public static int sqlite3VtabBegin(sqlite3 db, VTable pVTab)
		{
			int rc = (int)(0);
			sqlite3_module pModule;
			if (((((db).nVTrans) > (0)) && (((db).aVTrans) == (null))))
			{
				return (int)(6);
			}

			if (pVTab == null)
			{
				return (int)(0);
			}

			pModule = pVTab.pVtab.pModule;
			if ((pModule.xBegin) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (db.nVTrans); i++)
				{
					if ((db.aVTrans[i]) == (pVTab))
					{
						return (int)(0);
					}
				}

				rc = (int)(growVTrans(db));
				if ((rc) == (0))
				{
					rc = (int)(pModule.xBegin(pVTab.pVtab));
					if ((rc) == (0))
					{
						int iSvpt = (int)(db.nStatement + db.nSavepoint);
						addToVTrans(db, pVTab);
						if (((iSvpt) != 0) && ((pModule.xSavepoint) != null))
						{
							pVTab.iSavepoint = (int)(iSvpt);
							rc = (int)(pModule.xSavepoint(pVTab.pVtab, (int)(iSvpt - 1)));
						}
					}
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VtabCallCreate(sqlite3 db, int iDb, sbyte* zTab, sbyte** pzErr)
		{
			int rc = (int)(0);
			Table pTab;
			Module pMod;
			sbyte* zMod;
			pTab = sqlite3FindTable(db, zTab, db.aDb[iDb].zDbSName);
			zMod = pTab.u.vtab.azArg[0];
			pMod = (Module)(sqlite3HashFind(&db.aModule, zMod));
			if ((((pMod) == (null)) || ((pMod.pModule.xCreate) == (null))) || ((pMod.pModule.xDestroy) == (null)))
			{
				*pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
				rc = (int)(1);
			}
			else
			{
				rc = (int)(vtabCallConstructor(db, pTab, pMod, pMod.pModule.xCreate, pzErr));
			}

			if (((rc) == (0)) && ((sqlite3GetVTable(db, pTab)) != null))
			{
				rc = (int)(growVTrans(db));
				if ((rc) == (0))
				{
					addToVTrans(db, sqlite3GetVTable(db, pTab));
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VtabCallDestroy(sqlite3 db, int iDb, sbyte* zTab)
		{
			int rc = (int)(0);
			Table pTab;
			pTab = sqlite3FindTable(db, zTab, db.aDb[iDb].zDbSName);
			if (((pTab != null) && ((((pTab).eTabType) == (1)) != 0)) && (pTab.u.vtab.p != null))
			{
				VTable p;
				delegate23 xDestroy;
				for (p = pTab.u.vtab.p; p; p = p.pNext)
				{
					if ((p.pVtab.nRef) > (0))
					{
						return (int)(6);
					}
				}

				p = vtabDisconnectAll(db, pTab);
				xDestroy = p.pMod.pModule.xDestroy;
				if ((xDestroy) == (null))
					xDestroy = p.pMod.pModule.xDisconnect;
				pTab.nTabRef++;
				rc = (int)(xDestroy(p.pVtab));
				if ((rc) == (0))
				{
					p.pVtab = null;
					pTab.u.vtab.p = null;
					sqlite3VtabUnlock(p);
				}

				sqlite3DeleteTable(db, pTab);
			}

			return (int)(rc);
		}
		public static void sqlite3VtabClear(sqlite3 db, Table p)
		{
			if ((db == null) || ((db.pnBytesFreed) == (null)))
				vtabDisconnectAll(null, p);
			if ((p.u.vtab.azArg) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (p.u.vtab.nArg); i++)
				{
					if (i != 1)
						sqlite3DbFree(db, p.u.vtab.azArg[i]);
				}

				sqlite3DbFree(db, p.u.vtab.azArg);
			}
		}
		public static int sqlite3VtabCommit(sqlite3 db)
		{
			callFinaliser(db, (int)((ulong)(&((0).xCommit))));
			return (int)(0);
		}
		public static Module sqlite3VtabCreateModule(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
		{
			Module pMod;
			Module pDel;
			sbyte* zCopy;
			if ((pModule) == (null))
			{
				zCopy = zName;
				pMod = null;
			}
			else
			{
				int nName = (int)(sqlite3Strlen30(zName));
				pMod = (Module)(sqlite3Malloc((ulong)(sizeof(Module) + nName + 1)));
				if ((pMod) == (null))
				{
					sqlite3OomFault(db);
					return null;
				}

				zCopy = (sbyte*)(pMod[1]);
				CRuntime.memcpy(zCopy, zName, (ulong)(nName + 1));
				pMod.zName = zCopy;
				pMod.pModule = pModule;
				pMod.pAux = pAux;
				pMod.xDestroy = xDestroy;
				pMod.pEpoTab = null;
				pMod.nRefModule = (int)(1);
			}

			pDel = (Module)(sqlite3HashInsert(&db.aModule, zCopy, (void*)(pMod)));
			if ((pDel) != null)
			{
				if ((pDel) == (pMod))
				{
					sqlite3OomFault(db);
					sqlite3DbFree(db, pDel);
					pMod = null;
				}
				else
				{
					sqlite3VtabEponymousTableClear(db, pDel);
					sqlite3VtabModuleUnref(db, pDel);
				}
			}

			return pMod;
		}
		public static void sqlite3VtabDisconnect(sqlite3 db, Table p)
		{
			VTable ppVTab;
			for (ppVTab = p.u.vtab.p; ppVTab; ppVTab = (ppVTab).pNext)
			{
				if (((ppVTab).db) == (db))
				{
					VTable pVTab = ppVTab;
					ppVTab = pVTab.pNext;
					sqlite3VtabUnlock(pVTab);
					break;
				}
			}
		}
		public static void sqlite3VtabEponymousTableClear(sqlite3 db, Module pMod)
		{
			Table pTab = pMod.pEpoTab;
			if (pTab != null)
			{
				pTab.tabFlags |= (uint)(0x00004000);
				sqlite3DeleteTable(db, pTab);
				pMod.pEpoTab = null;
			}
		}
		public static void sqlite3VtabModuleUnref(sqlite3 db, Module pMod)
		{
			pMod.nRefModule--;
			if ((pMod.nRefModule) == (0))
			{
				if ((pMod.xDestroy) != null)
				{
					pMod.xDestroy(pMod.pAux);
				}

				sqlite3DbFree(db, pMod);
			}
		}
		public static FuncDef sqlite3VtabOverloadFunction(sqlite3 db, FuncDef pDef, int nArg, Expr pExpr)
		{
			Table pTab;
			sqlite3_vtab pVtab;
			sqlite3_module pMod;
			delegate68 xSFunc = null;
			void* pArg = null;
			FuncDef pNew;
			int rc = (int)(0);
			if (((pExpr) == (null)))
				return pDef;
			if (pExpr.op != 167)
				return pDef;
			pTab = pExpr.y.pTab;
			if ((pTab) == (null))
				return pDef;
			if (!(((pTab).eTabType) == (1)))
				return pDef;
			pVtab = sqlite3GetVTable(db, pTab).pVtab;
			pMod = pVtab.pModule;
			if ((pMod.xFindFunction) == (null))
				return pDef;
			rc = (int)(pMod.xFindFunction(pVtab, (int)(nArg), pDef.zName, &xSFunc, &pArg));
			if ((rc) == (0))
			{
				return pDef;
			}

			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(FuncDef) + sqlite3Strlen30(pDef.zName) + 1));
			if ((pNew) == (null))
			{
				return pDef;
			}

			pNew = (FuncDef)(pDef);
			pNew.zName = (sbyte*)(pNew[1]);
			CRuntime.memcpy((sbyte*)(pNew[1]), pDef.zName, (ulong)(sqlite3Strlen30(pDef.zName) + 1));
			pNew.xSFunc = xSFunc;
			pNew.pUserData = pArg;
			pNew.funcFlags |= (uint)(0x0010);
			return pNew;
		}
		public static int sqlite3VtabRollback(sqlite3 db)
		{
			callFinaliser(db, (int)((ulong)(&((0).xRollback))));
			return (int)(0);
		}
		public static int sqlite3VtabSavepoint(sqlite3 db, int op, int iSavepoint)
		{
			int rc = (int)(0);
			if ((db.aVTrans) != null)
			{
				int i = 0;
				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nVTrans)); i++)
				{
					VTable pVTab = db.aVTrans[i];
					sqlite3_module pMod = pVTab.pMod.pModule;
					if (((pVTab.pVtab) != null) && ((pMod.iVersion) >= (2)))
					{
						delegate22 xMethod;
						sqlite3VtabLock(pVTab);
						switch (op)
						{
							case 0:
								xMethod = pMod.xSavepoint;
								pVTab.iSavepoint = (int)(iSavepoint + 1);
								break;
							case 2:
								xMethod = pMod.xRollbackTo;
								break;
							default:
								xMethod = pMod.xRelease;
								break;
						}

						if (((xMethod) != null) && ((pVTab.iSavepoint) > (iSavepoint)))
						{
							rc = (int)(xMethod(pVTab.pVtab, (int)(iSavepoint)));
						}

						sqlite3VtabUnlock(pVTab);
					}
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VtabSync(sqlite3 db, Vdbe p)
		{
			int i = 0;
			int rc = (int)(0);
			VTable aVTrans = db.aVTrans;
			db.aVTrans = null;
			for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nVTrans)); i++)
			{
				delegate23 x;
				sqlite3_vtab pVtab = aVTrans[i].pVtab;
				if (((pVtab) != null) && ((x = pVtab.pModule.xSync) != null))
				{
					rc = (int)(x(pVtab));
					sqlite3VtabImportErrmsg(p, pVtab);
				}
			}

			db.aVTrans = aVTrans;
			return (int)(rc);
		}
		public static void sqlite3VtabUnlockList(sqlite3 db)
		{
			VTable p = db.pDisconnect;
			if ((p) != null)
			{
				db.pDisconnect = null;
				sqlite3ExpirePreparedStatements(db, (int)(0));
				do
				{
					VTable pNext = p.pNext;
					sqlite3VtabUnlock(p);
					p = pNext;
				}
				while ((p) != null);
			}
		}
		public static void sqlite3WindowDelete(sqlite3 db, Window p)
		{
			if ((p) != null)
			{
				sqlite3WindowUnlinkFromSelect(p);
				sqlite3ExprDelete(db, p.pFilter);
				sqlite3ExprListDelete(db, p.pPartition);
				sqlite3ExprListDelete(db, p.pOrderBy);
				sqlite3ExprDelete(db, p.pEnd);
				sqlite3ExprDelete(db, p.pStart);
				sqlite3DbFree(db, p.zName);
				sqlite3DbFree(db, p.zBase);
				sqlite3DbFree(db, p);
			}
		}
		public static Window sqlite3WindowDup(sqlite3 db, Expr pOwner, Window p)
		{
			Window pNew = null;
			if ((p) != null)
			{
				pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Window)));
				if ((pNew) != null)
				{
					pNew.zName = sqlite3DbStrDup(db, p.zName);
					pNew.zBase = sqlite3DbStrDup(db, p.zBase);
					pNew.pFilter = sqlite3ExprDup(db, p.pFilter, (int)(0));
					pNew.pFunc = p.pFunc;
					pNew.pPartition = sqlite3ExprListDup(db, p.pPartition, (int)(0));
					pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, (int)(0));
					pNew.eFrmType = (byte)(p.eFrmType);
					pNew.eEnd = (byte)(p.eEnd);
					pNew.eStart = (byte)(p.eStart);
					pNew.eExclude = (byte)(p.eExclude);
					pNew.regResult = (int)(p.regResult);
					pNew.regAccum = (int)(p.regAccum);
					pNew.iArgCol = (int)(p.iArgCol);
					pNew.iEphCsr = (int)(p.iEphCsr);
					pNew.bExprArgs = (byte)(p.bExprArgs);
					pNew.pStart = sqlite3ExprDup(db, p.pStart, (int)(0));
					pNew.pEnd = sqlite3ExprDup(db, p.pEnd, (int)(0));
					pNew.pOwner = pOwner;
					pNew.bImplicitFrame = (byte)(p.bImplicitFrame);
				}
			}

			return pNew;
		}
		public static void sqlite3WindowListDelete(sqlite3 db, Window p)
		{
			while ((p) != null)
			{
				Window pNext = p.pNextWin;
				sqlite3WindowDelete(db, p);
				p = pNext;
			}
		}
		public static Window sqlite3WindowListDup(sqlite3 db, Window p)
		{
			Window pWin;
			Window pRet = null;
			Window pp = pRet;
			for (pWin = p; pWin; pWin = pWin.pNextWin)
			{
				pp = sqlite3WindowDup(db, null, pWin);
				if ((pp) == (null))
					break;
				pp = ((pp).pNextWin);
			}

			return pRet;
		}
		public static void sqlite3WithDelete(sqlite3 db, With pWith)
		{
			if ((pWith) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWith.nCte); i++)
				{
					cteClear(db, pWith.a[i]);
				}

				sqlite3DbFree(db, pWith);
			}
		}
		public static With sqlite3WithDup(sqlite3 db, With p)
		{
			With pRet = null;
			if ((p) != null)
			{
				long nByte = (long)(sizeof(With) + sizeof(Cte) * (p.nCte - 1));
				pRet = sqlite3DbMallocZero(db, (ulong)(nByte));
				if ((pRet) != null)
				{
					int i = 0;
					pRet.nCte = (int)(p.nCte);
					for (i = (int)(0); (i) < (p.nCte); i++)
					{
						pRet.a[i].pSelect = sqlite3SelectDup(db, p.a[i].pSelect, (int)(0));
						pRet.a[i].pCols = sqlite3ExprListDup(db, p.a[i].pCols, (int)(0));
						pRet.a[i].zName = sqlite3DbStrDup(db, p.a[i].zName);
					}
				}
			}

			return pRet;
		}
		public static int sqlite3WritableSchema(sqlite3 db)
		{
			return ((db.flags & (0x00000001 | 0x10000000)) == (0x00000001) ? 1 : 0);
		}
		public static void sqliteViewResetAll(sqlite3 db, int idx)
		{
			HashElem* i;
			if (!(((db).aDb[idx].pSchema.schemaFlags & (0x0002)) == (0x0002)))
				return;
			for (i = ((&db.aDb[idx].pSchema.tblHash)->first); i; i = ((i)->next))
			{
				Table pTab = ((i)->data);
				if ((((pTab).eTabType) == (2)))
				{
					sqlite3DeleteColumnNames(db, pTab);
				}
			}

			(db).aDb[idx].pSchema.schemaFlags &= (ushort)(~(0x0002));
		}
		public static int synthCollSeq(sqlite3 db, CollSeq pColl)
		{
			CollSeq pColl2;
			sbyte* z = pColl.zName;
			int i = 0;
			for (i = (int)(0); (i) < (3); i++)
			{
				pColl2 = sqlite3FindCollSeq(db, (byte)(synthCollSeq_aEnc[i]), z, (int)(0));
				if (pColl2.xCmp != null)
				{
					CRuntime.memcpy(pColl, pColl2, (ulong)(sizeof(CollSeq)));
					pColl.xDel = null;
					return (int)(0);
				}
			}

			return (int)(1);
		}
		public static int tableMayNotBeDropped(sqlite3 db, Table pTab)
		{
			if ((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0))
			{
				if ((sqlite3_strnicmp(pTab.zName + 7, "stat", (int)(4))) == (0))
					return (int)(0);
				if ((sqlite3_strnicmp(pTab.zName + 7, "parameters", (int)(10))) == (0))
					return (int)(0);
				return (int)(1);
			}

			if (((pTab.tabFlags & 0x00001000) != 0) && ((sqlite3ReadOnlyShadowTables(db)) != 0))
			{
				return (int)(1);
			}

			if ((pTab.tabFlags & 0x00008000) != 0)
			{
				return (int)(1);
			}

			return (int)(0);
		}
		public static void upsertDelete(sqlite3 db, Upsert p)
		{
			do
			{
				Upsert pNext = p.pNextUpsert;
				sqlite3ExprListDelete(db, p.pUpsertTarget);
				sqlite3ExprDelete(db, p.pUpsertTargetWhere);
				sqlite3ExprListDelete(db, p.pUpsertSet);
				sqlite3ExprDelete(db, p.pUpsertWhere);
				sqlite3DbFree(db, p.pToFree);
				sqlite3DbFree(db, p);
				p = pNext;
			}
			while ((p) != null);
		}
		public static int valueFromExpr(sqlite3 db, Expr pExpr, byte enc, byte affinity, sqlite3_value ppVal, ValueNewStat4Ctx pCtx)
		{
			int op = 0;
			sbyte* zVal = null;
			sqlite3_value pVal = null;
			int negInt = (int)(1);
			sbyte* zNeg = "";
			int rc = (int)(0);
			while (((op = (int)(pExpr.op)) == (174)) || ((op) == (181)))
			{
				pExpr = pExpr.pLeft;
			}

			if ((op) == (176))
				op = (int)(pExpr.op2);
			if ((op) == (36))
			{
				byte aff = 0;
				aff = (byte)(sqlite3AffinityType(pExpr.u.zToken, null));
				rc = (int)(valueFromExpr(db, pExpr.pLeft, (byte)(enc), (byte)(aff), ppVal, pCtx));
				if ((ppVal) != null)
				{
					sqlite3VdbeMemCast(ppVal, (byte)(aff), (byte)(1));
					sqlite3ValueApplyAffinity(ppVal, (byte)(affinity), (byte)(1));
				}

				return (int)(rc);
			}

			if (((op) == (173)) && (((pExpr.pLeft.op) == (155)) || ((pExpr.pLeft.op) == (153))))
			{
				pExpr = pExpr.pLeft;
				op = (int)(pExpr.op);
				negInt = (int)(-1);
				zNeg = "-";
			}

			if ((((op) == (117)) || ((op) == (153))) || ((op) == (155)))
			{
				pVal = valueNew(db, pCtx);
				if ((pVal) == (null))
					goto no_mem;
				if ((((pExpr).flags & (0x000400)) != 0))
				{
					sqlite3VdbeMemSetInt64(pVal, (long)((long)(pExpr.u.iValue) * negInt));
				}
				else
				{
					zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr.u.zToken);
					if ((zVal) == (null))
						goto no_mem;
					sqlite3ValueSetStr(pVal, (int)(-1), zVal, (byte)(1), ((Void(Void * ))(sqlite3OomFault)));
				}

				if ((((op) == (155)) || ((op) == (153))) && ((affinity) == (0x41)))
				{
					sqlite3ValueApplyAffinity(pVal, (byte)(0x43), (byte)(1));
				}
				else
				{
					sqlite3ValueApplyAffinity(pVal, (byte)(affinity), (byte)(1));
				}

				if ((pVal.flags & (0x0004 | 0x0020 | 0x0008)) != 0)
				{
					pVal.flags &= (ushort)(~0x0002);
				}

				if (enc != 1)
				{
					rc = (int)(sqlite3VdbeChangeEncoding(pVal, (int)(enc)));
				}
			}
			else if ((op) == (173))
			{
				if (((0) == (valueFromExpr(db, pExpr.pLeft, (byte)(enc), (byte)(affinity), pVal, pCtx))) && (pVal != null))
				{
					sqlite3VdbeMemNumerify(pVal);
					if ((pVal.flags & 0x0008) != 0)
					{
						pVal.u.r = (double)(-pVal.u.r);
					}
					else if ((pVal.u.i) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
					{
						pVal.u.r = (double)(-(double)(((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))));
						((pVal).flags = (ushort)(((pVal).flags & ~(0xc1bf | 0x4000)) | 0x0008));
					}
					else
					{
						pVal.u.i = (long)(-pVal.u.i);
					}

					sqlite3ValueApplyAffinity(pVal, (byte)(affinity), (byte)(enc));
				}
			}
			else if ((op) == (121))
			{
				pVal = valueNew(db, pCtx);
				if ((pVal) == (null))
					goto no_mem;
				sqlite3VdbeMemSetNull(pVal);
			}
			else if ((op) == (154))
			{
				int nVal = 0;
				pVal = valueNew(db, pCtx);
				if (pVal == null)
					goto no_mem;
				zVal = &pExpr.u.zToken[2];
				nVal = (int)(sqlite3Strlen30(zVal) - 1);
				sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, (int)(nVal)), (long)(nVal / 2), (byte)(0), ((Void(Void * ))(sqlite3OomFault)));
			}
			else if ((op) == (170))
			{
				pVal = valueNew(db, pCtx);
				if ((pVal) != null)
				{
					pVal.flags = (ushort)(0x0004);
					pVal.u.i = (long)((pExpr.u.zToken[4]) == (0));
				}
			}

			ppVal = pVal;
			return (int)(rc);
		no_mem:
			; sqlite3OomFault(db);
			sqlite3DbFree(db, zVal);
			sqlite3ValueFree(pVal);
			return (int)(7);
		}
		public static sqlite3_value valueNew(sqlite3 db, ValueNewStat4Ctx p)
		{
			return sqlite3ValueNew(db);
		}
		public static int vdbeCommit(sqlite3 db, Vdbe p)
		{
			int i = 0;
			int nTrans = (int)(0);
			int rc = (int)(0);
			int needXcommit = (int)(0);
			rc = (int)(sqlite3VtabSync(db, p));
			for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if ((sqlite3BtreeTxnState(pBt)) == (2))
				{
					Pager pPager;
					needXcommit = (int)(1);
					sqlite3BtreeEnter(pBt);
					pPager = sqlite3BtreePager(pBt);
					if (((db.aDb[i].safety_level != 0x01) && ((vdbeCommit_aMJNeeded[sqlite3PagerGetJournalMode(pPager)]) != 0)) && ((sqlite3PagerIsMemdb(pPager)) == (0)))
					{
						nTrans++;
					}

					rc = (int)(sqlite3PagerExclusiveLock(pPager));
					sqlite3BtreeLeave(pBt);
				}
			}

			if (rc != 0)
			{
				return (int)(rc);
			}

			if (((needXcommit) != 0) && ((db.xCommitCallback) != null))
			{
				rc = (int)(db.xCommitCallback(db.pCommitArg));
				if ((rc) != 0)
				{
					return (int)(19 | (2 << 8));
				}
			}

			if (((0) == (sqlite3Strlen30(sqlite3BtreeGetFilename(db.aDb[0].pBt)))) || ((nTrans) <= (1)))
			{
				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeCommitPhaseOne(pBt, null));
					}
				}

				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeCommitPhaseTwo(pBt, (int)(0)));
					}
				}

				if ((rc) == (0))
				{
					sqlite3VtabCommit(db);
				}
			}
			else
			{
				sqlite3_vfs pVfs = db.pVfs;
				sbyte* zSuper = null;
				sbyte* zMainFile = sqlite3BtreeGetFilename(db.aDb[0].pBt);
				sqlite3_file pSuperJrnl = null;
				long offset = (long)(0);
				int res = 0;
				int retryCount = (int)(0);
				int nMainFile = 0;
				nMainFile = (int)(sqlite3Strlen30(zMainFile));
				zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", (int)(0), zMainFile, (int)(0));
				if ((zSuper) == (null))
					return (int)(7);
				zSuper += 4;
				do
				{
					uint iRandom = 0;
					if ((retryCount) != 0)
					{
						if ((retryCount) > (100))
						{
							sqlite3_log((int)(13), "MJ delete: %s", zSuper);
							sqlite3OsDelete(pVfs, zSuper, (int)(0));
							break;
						}
						else if ((retryCount) == (1))
						{
							sqlite3_log((int)(13), "MJ collide: %s", zSuper);
						}
					}

					retryCount++;
					sqlite3_randomness((int)(sizeof(uint)), &iRandom);
					sqlite3_snprintf((int)(13), &zSuper[nMainFile], "-mj%06X9%02X", (uint)((iRandom >> 8) & 0xffffff), (uint)(iRandom & 0xff));
					rc = (int)(sqlite3OsAccess(pVfs, zSuper, (int)(0), &res));
				}
				while (((rc) == (0)) && ((res) != 0));
				if ((rc) == (0))
				{
					rc = (int)(sqlite3OsOpenMalloc(pVfs, zSuper, pSuperJrnl, (int)(0x00000002 | 0x00000004 | 0x00000010 | 0x00004000), null));
				}

				if (rc != 0)
				{
					sqlite3DbFree(db, zSuper - 4);
					return (int)(rc);
				}

				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((sqlite3BtreeTxnState(pBt)) == (2))
					{
						sbyte* zFile = sqlite3BtreeGetJournalname(pBt);
						if ((zFile) == (null))
						{
							continue;
						}

						rc = (int)(sqlite3OsWrite(pSuperJrnl, zFile, (int)(sqlite3Strlen30(zFile) + 1), (long)(offset)));
						offset += (long)(sqlite3Strlen30(zFile) + 1);
						if (rc != 0)
						{
							sqlite3OsCloseFree(pSuperJrnl);
							sqlite3OsDelete(pVfs, zSuper, (int)(0));
							sqlite3DbFree(db, zSuper - 4);
							return (int)(rc);
						}
					}
				}

				if (((0) == (sqlite3OsDeviceCharacteristics(pSuperJrnl) & 0x00000400)) && (0 != (rc = (int)(sqlite3OsSync(pSuperJrnl, (int)(0x00002))))))
				{
					sqlite3OsCloseFree(pSuperJrnl);
					sqlite3OsDelete(pVfs, zSuper, (int)(0));
					sqlite3DbFree(db, zSuper - 4);
					return (int)(rc);
				}

				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeCommitPhaseOne(pBt, zSuper));
					}
				}

				sqlite3OsCloseFree(pSuperJrnl);
				if (rc != 0)
				{
					sqlite3DbFree(db, zSuper - 4);
					return (int)(rc);
				}

				rc = (int)(sqlite3OsDelete(pVfs, zSuper, (int)(1)));
				sqlite3DbFree(db, zSuper - 4);
				zSuper = null;
				if ((rc) != 0)
				{
					return (int)(rc);
				}

				sqlite3BeginBenignMalloc();
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						sqlite3BtreeCommitPhaseTwo(pBt, (int)(1));
					}
				}

				sqlite3EndBenignMalloc();
				sqlite3VtabCommit(db);
			}

			return (int)(rc);
		}
		public static void vdbeFreeOpArray(sqlite3 db, VdbeOp* aOp, int nOp)
		{
			if ((aOp) != null)
			{
				VdbeOp* pOp;
				for (pOp = &aOp[nOp - 1]; (pOp) >= (aOp); pOp--)
				{
					if ((pOp->p4type) <= (-7))
						freeP4(db, (int)(pOp->p4type), pOp->p4.p);
				}

				sqlite3DbFreeNN(db, aOp);
			}
		}
		public static void vdbeSorterExtendFile(sqlite3 db, sqlite3_file pFd, long nByte)
		{
			if (((nByte) <= ((long)(db.nMaxSorterMmap))) && ((pFd.pMethods.iVersion) >= (3)))
			{
				void* p = null;
				int chunksize = (int)(4 * 1024);
				sqlite3OsFileControlHint(pFd, (int)(6), &chunksize);
				sqlite3OsFileControlHint(pFd, (int)(5), &nByte);
				sqlite3OsFetch(pFd, (long)(0), (int)(nByte), &p);
				if ((p) != null)
					sqlite3OsUnfetch(pFd, (long)(0), p);
			}
		}
		public static int vdbeSorterOpenTempFile(sqlite3 db, long nExtend, sqlite3_file ppFd)
		{
			int rc = 0;
			if ((sqlite3FaultSim((int)(202))) != 0)
				return (int)(10 | (13 << 8));
			rc = (int)(sqlite3OsOpenMalloc(db.pVfs, null, ppFd, (int)(0x00001000 | 0x00000002 | 0x00000004 | 0x00000010 | 0x00000008), &rc));
			if ((rc) == (0))
			{
				long max = (long)(0x7fff0000);
				sqlite3OsFileControlHint(ppFd, (int)(18), (void*)(&max));
				if ((nExtend) > (0))
				{
					vdbeSorterExtendFile(db, ppFd, (long)(nExtend));
				}
			}

			return (int)(rc);
		}
		public static void vdbeSorterRecordFree(sqlite3 db, SorterRecord* pRecord)
		{
			SorterRecord* p;
			SorterRecord* pNext;
			for (p = pRecord; p; p = pNext)
			{
				pNext = p->u.pNext;
				sqlite3DbFree(db, p);
			}
		}
		public static void vdbeSortSubtaskCleanup(sqlite3 db, SortSubtask pTask)
		{
			sqlite3DbFree(db, pTask.pUnpacked);
			if ((pTask.list.aMemory) != null)
			{
				sqlite3_free(pTask.list.aMemory);
			}
			else
			{
				vdbeSorterRecordFree(null, pTask.list.pList);
			}

			if ((pTask.file.pFd) != null)
			{
				sqlite3OsCloseFree(pTask.file.pFd);
			}

			if ((pTask.file2.pFd) != null)
			{
				sqlite3OsCloseFree(pTask.file2.pFd);
			}

			CRuntime.memset(pTask, (int)(0), (ulong)(sizeof(SortSubtask)));
		}
		public static int vtabCallConstructor(sqlite3 db, Table pTab, Module pMod, delegate21 xConstruct, sbyte** pzErr)
		{
			VtabCtx sCtx = new VtabCtx();
			VTable pVTable;
			int rc = 0;
			sbyte** azArg;
			int nArg = (int)(pTab.u.vtab.nArg);
			sbyte* zErr = null;
			sbyte* zModuleName;
			int iDb = 0;
			VtabCtx pCtx;
			azArg = pTab.u.vtab.azArg;
			for (pCtx = db.pVtabCtx; pCtx; pCtx = pCtx.pPrior)
			{
				if ((pCtx.pTab) == (pTab))
				{
					*pzErr = sqlite3MPrintf(db, "vtable constructor called recursively: %s", pTab.zName);
					return (int)(6);
				}
			}

			zModuleName = sqlite3DbStrDup(db, pTab.zName);
			if (zModuleName == null)
			{
				return (int)(7);
			}

			pVTable = sqlite3MallocZero((ulong)(sizeof(VTable)));
			if (pVTable == null)
			{
				sqlite3OomFault(db);
				sqlite3DbFree(db, zModuleName);
				return (int)(7);
			}

			pVTable.db = db;
			pVTable.pMod = pMod;
			pVTable.eVtabRisk = (byte)(1);
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			pTab.u.vtab.azArg[1] = db.aDb[iDb].zDbSName;
			sCtx.pTab = pTab;
			sCtx.pVTable = pVTable;
			sCtx.pPrior = db.pVtabCtx;
			sCtx.bDeclared = (int)(0);
			db.pVtabCtx = sCtx;
			rc = (int)(xConstruct(db, pMod.pAux, (int)(nArg), azArg, pVTable.pVtab, &zErr));
			db.pVtabCtx = sCtx.pPrior;
			if ((rc) == (7))
				sqlite3OomFault(db);
			if (0 != rc)
			{
				if ((zErr) == (null))
				{
					*pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
				}
				else
				{
					*pzErr = sqlite3MPrintf(db, "%s", zErr);
					sqlite3_free(zErr);
				}

				sqlite3DbFree(db, pVTable);
			}
			else if ((pVTable.pVtab) != null)
			{
				CRuntime.memset(pVTable.pVtab, (int)(0), (ulong)(sizeof(sqlite3_vtab)));
				pVTable.pVtab.pModule = pMod.pModule;
				pMod.nRefModule++;
				pVTable.nRef = (int)(1);
				if ((sCtx.bDeclared) == (0))
				{
					sbyte* zFormat = "vtable constructor did not declare schema: %s";
					*pzErr = sqlite3MPrintf(db, zFormat, pTab.zName);
					sqlite3VtabUnlock(pVTable);
					rc = (int)(1);
				}
				else
				{
					int iCol = 0;
					ushort oooHidden = (ushort)(0);
					pVTable.pNext = pTab.u.vtab.p;
					pTab.u.vtab.p = pVTable;
					for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
					{
						sbyte* zType = sqlite3ColumnType(&pTab.aCol[iCol], "");
						int nType = 0;
						int i = (int)(0);
						nType = (int)(sqlite3Strlen30(zType));
						for (i = (int)(0); (i) < (nType); i++)
						{
							if ((((0) == (sqlite3_strnicmp("hidden", &zType[i], (int)(6)))) && (((i) == (0)) || ((zType[i - 1]) == (32)))) && (((zType[i + 6]) == (0)) || ((zType[i + 6]) == (32))))
							{
								break;
							}
						}

						if ((i) < (nType))
						{
							int j = 0;
							int nDel = (int)(6 + ((zType[i + 6]) != 0 ? 1 : 0));
							for (j = (int)(i); (j + nDel) <= (nType); j++)
							{
								zType[j] = (sbyte)(zType[j + nDel]);
							}

							if (((zType[i]) == (0)) && ((i) > (0)))
							{
								zType[i - 1] = (sbyte)(0);
							}

							pTab.aCol[iCol].colFlags |= (ushort)(0x0002);
							pTab.tabFlags |= (uint)(0x00000002);
							oooHidden = (ushort)(0x00000400);
						}
						else
						{
							pTab.tabFlags |= (uint)(oooHidden);
						}
					}
				}
			}

			sqlite3DbFree(db, zModuleName);
			return (int)(rc);
		}
		public static VTable vtabDisconnectAll(sqlite3 db, Table p)
		{
			VTable pRet = null;
			VTable pVTable;
			pVTable = p.u.vtab.p;
			p.u.vtab.p = null;
			while ((pVTable) != null)
			{
				sqlite3 db2 = pVTable.db;
				VTable pNext = pVTable.pNext;
				if ((db2) == (db))
				{
					pRet = pVTable;
					p.u.vtab.p = pRet;
					pRet.pNext = null;
				}
				else
				{
					pVTable.pNext = db2.pDisconnect;
					db2.pDisconnect = pVTable;
				}

				pVTable = pNext;
			}

			return pRet;
		}
		public static void whereAndInfoDelete(sqlite3 db, WhereAndInfo p)
		{
			sqlite3WhereClauseClear(p.wc);
			sqlite3DbFree(db, p);
		}
		public static void whereInfoFree(sqlite3 db, WhereInfo pWInfo)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pWInfo.nLevel); i++)
			{
				WhereLevel pLevel = pWInfo.a[i];
				if (((pLevel.pWLoop) != null) && ((pLevel.pWLoop.wsFlags & 0x00000800) != 0))
				{
					sqlite3DbFree(db, pLevel.u._in_.aInLoop);
				}
			}

			sqlite3WhereClauseClear(pWInfo.sWC);
			while ((pWInfo.pLoops) != null)
			{
				WhereLoop p = pWInfo.pLoops;
				pWInfo.pLoops = p.pNextLoop;
				whereLoopDelete(db, p);
			}

			sqlite3DbFreeNN(db, pWInfo);
		}
		public static void whereLoopClear(sqlite3 db, WhereLoop p)
		{
			if (p.aLTerm != p.aLTermSpace)
				sqlite3DbFreeNN(db, p.aLTerm);
			whereLoopClearUnion(db, p);
			whereLoopInit(p);
		}
		public static void whereLoopClearUnion(sqlite3 db, WhereLoop p)
		{
			if ((p.wsFlags & (0x00000400 | 0x00004000)) != 0)
			{
				if (((p.wsFlags & 0x00000400) != 0) && ((p.u.vtab.needFree) != 0))
				{
					sqlite3_free(p.u.vtab.idxStr);
					p.u.vtab.needFree = (uint)(0);
					p.u.vtab.idxStr = null;
				}
				else if (((p.wsFlags & 0x00004000) != 0) && (p.u.btree.pIndex != null))
				{
					sqlite3DbFree(db, p.u.btree.pIndex.zColAff);
					sqlite3DbFreeNN(db, p.u.btree.pIndex);
					p.u.btree.pIndex = null;
				}
			}
		}
		public static void whereLoopDelete(sqlite3 db, WhereLoop p)
		{
			whereLoopClear(db, p);
			sqlite3DbFreeNN(db, p);
		}
		public static int whereLoopResize(sqlite3 db, WhereLoop p, int n)
		{
			WhereTerm paNew;
			if ((p.nLSlot) >= (n))
				return (int)(0);
			n = (int)((n + 7) & ~7);
			paNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereTerm) * n));
			if ((paNew) == (null))
				return (int)(7);
			CRuntime.memcpy(paNew, p.aLTerm, (ulong)(sizeof(WhereTerm) * p.nLSlot));
			if (p.aLTerm != p.aLTermSpace)
				sqlite3DbFreeNN(db, p.aLTerm);
			p.aLTerm = paNew;
			p.nLSlot = (ushort)(n);
			return (int)(0);
		}
		public static int whereLoopXfer(sqlite3 db, WhereLoop pTo, WhereLoop pFrom)
		{
			whereLoopClearUnion(db, pTo);
			if ((whereLoopResize(db, pTo, (int)(pFrom.nLTerm))) != 0)
			{
				CRuntime.memset(pTo, (int)(0), ((ulong)(&((0).nLSlot))));
				return (int)(7);
			}

			CRuntime.memcpy(pTo, pFrom, ((ulong)(&((0).nLSlot))));
			CRuntime.memcpy(pTo.aLTerm, pFrom.aLTerm, (ulong)(pTo.nLTerm * sizeof(WhereTerm)));
			if ((pFrom.wsFlags & 0x00000400) != 0)
			{
				pFrom.u.vtab.needFree = (uint)(0);
			}
			else if ((pFrom.wsFlags & 0x00004000) != 0)
			{
				pFrom.u.btree.pIndex = null;
			}

			return (int)(0);
		}
		public static void whereOrInfoDelete(sqlite3 db, WhereOrInfo p)
		{
			sqlite3WhereClauseClear(p.wc);
			sqlite3DbFree(db, p);
		}
	}
}