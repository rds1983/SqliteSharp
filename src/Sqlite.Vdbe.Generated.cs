// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static VdbeCursor allocateCursor(Vdbe p, int iCur, int nField, byte eCurType)
		{
			sqlite3_value pMem = (iCur) > (0) ? p.aMem[p.nMem - iCur] : p.aMem;
			int nByte = 0;
			VdbeCursor pCx = null;
			nByte = (int)((((sizeof(VdbeCursor)) + 7) & ~7) + 2 * sizeof(uint) * nField + ((eCurType) == (0) ? sqlite3BtreeCursorSize() : 0));
			if ((p.apCsr[iCur]) != null)
			{
				sqlite3VdbeFreeCursor(p, p.apCsr[iCur]);
				p.apCsr[iCur] = null;
			}

			if ((pMem.szMalloc) < (nByte))
			{
				if ((pMem.szMalloc) > (0))
				{
					sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
				}

				pMem.z = pMem.zMalloc = sqlite3DbMallocRaw(pMem.db, (ulong)(nByte));
				if ((pMem.zMalloc) == (null))
				{
					pMem.szMalloc = (int)(0);
					return null;
				}

				pMem.szMalloc = (int)(nByte);
			}

			p.apCsr[iCur] = pCx = (VdbeCursor)(pMem.zMalloc);
			CRuntime.memset(pCx, (int)(0), ((ulong)((0).pAltCursor)));
			pCx.eCurType = (byte)(eCurType);
			pCx.nField = (short)(nField);
			pCx.aOffset = &pCx.aType[nField];
			if ((eCurType) == (0))
			{
				pCx.uc.pCursor = (BtCursor)(&pMem.z[(((sizeof(VdbeCursor)) + 7) & ~7) + 2 * sizeof(uint) * nField]);
				sqlite3BtreeCursorZero(pCx.uc.pCursor);
			}

			return pCx;
		}
		public static void closeAllCursors(Vdbe p)
		{
			if ((p.pFrame) != null)
			{
				VdbeFrame pFrame;
				for (pFrame = p.pFrame; pFrame.pParent; pFrame = pFrame.pParent)
				{
				}

				sqlite3VdbeFrameRestore(pFrame);
				p.pFrame = null;
				p.nFrame = (int)(0);
			}

			closeCursorsInFrame(p);
			if ((p.aMem) != null)
			{
				releaseMemArray(p.aMem, (int)(p.nMem));
			}

			while ((p.pDelFrame) != null)
			{
				VdbeFrame pDel = p.pDelFrame;
				p.pDelFrame = pDel.pParent;
				sqlite3VdbeFrameDelete(pDel);
			}

			if ((p.pAuxData) != null)
				sqlite3VdbeDeleteAuxData(p.db, p.pAuxData, (int)(-1), (int)(0));
		}
		public static void closeCursorsInFrame(Vdbe p)
		{
			if ((p.apCsr) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (p.nCursor); i++)
				{
					VdbeCursor pC = p.apCsr[i];
					if ((pC) != null)
					{
						sqlite3VdbeFreeCursor(p, pC);
						p.apCsr[i] = null;
					}
				}
			}
		}
		public static void codeOffset(Vdbe v, int iOffset, int iContinue)
		{
			if ((iOffset) > (0))
			{
				sqlite3VdbeAddOp3(v, (int)(49), (int)(iOffset), (int)(iContinue), (int)(1));
			}
		}
		public static void codeReal(Vdbe v, sbyte* z, int negateFlag, int iMem)
		{
			if ((z != null))
			{
				double value = 0;
				sqlite3AtoF(z, &value, (int)(sqlite3Strlen30(z)), (byte)(1));
				if ((negateFlag) != 0)
					value = (double)(-value);
				sqlite3VdbeAddOp4Dup8(v, (int)(153), (int)(0), (int)(iMem), (int)(0), (byte*)(&value), (int)(-13));
			}
		}
		public static int growOp3(Vdbe p, int op, int p1, int p2, int p3)
		{
			if ((growOpArray(p, (int)(1))) != 0)
				return (int)(1);
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
		}
		public static int growOpArray(Vdbe v, int nOp)
		{
			VdbeOp* pNew;
			Parse p = v.pParse;
			long nNew = (long)((v.nOpAlloc) != 0 ? 2 * (long)(v.nOpAlloc) : (long)(1024 / sizeof(VdbeOp)));
			if ((nNew) > (p.db.aLimit[5]))
			{
				sqlite3OomFault(p.db);
				return (int)(7);
			}

			pNew = sqlite3DbRealloc(p.db, v.aOp, (ulong)(nNew * sizeof(VdbeOp)));
			if ((pNew) != null)
			{
				p.szOpAlloc = (int)(sqlite3DbMallocSize(p.db, pNew));
				v.nOpAlloc = (int)(p.szOpAlloc / sizeof(VdbeOp));
				v.aOp = pNew;
			}

			return (int)(pNew ? 0 : 7);
		}
		public static int integrityCheckResultRow(Vdbe v)
		{
			int addr = 0;
			sqlite3VdbeAddOp2(v, (int)(83), (int)(3), (int)(1));
			addr = (int)(sqlite3VdbeAddOp3(v, (int)(49), (int)(1), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(1)));
			sqlite3VdbeAddOp0(v, (int)(70));
			return (int)(addr);
		}
		public static sqlite3_value out2Prerelease(Vdbe p, VdbeOp* pOp)
		{
			sqlite3_value pOut;
			pOut = p.aMem[pOp->p2];
			if ((((pOut).flags & (0x2000 | 0x0400)) != 0))
			{
				return out2PrereleaseWithClear(pOut);
			}
			else
			{
				pOut.flags = (ushort)(0x0004);
				return pOut;
			}
		}
		public static void pragmaFunclistLine(Vdbe v, FuncDef p, int isBuiltin, int showInternFuncs)
		{
			for (p; ; p = p.pNext)
			{
				sbyte* zType;
				if ((p.xSFunc) == (null))
					continue;
				if (((p.funcFlags & 0x00040000) != 0) && ((showInternFuncs) == (0)))
				{
					continue;
				}

				if (p.xValue != null)
				{
					zType = "w";
				}
				else if (p.xFinalize != null)
				{
					zType = "a";
				}
				else
				{
					zType = "s";
				}

				sqlite3VdbeMultiLoad(v, (int)(1), "sissii", p.zName, (int)(isBuiltin), zType, pragmaFunclistLine_azEnc[p.funcFlags & 0x0003], (int)(p.nArg), (uint)((p.funcFlags & pragmaFunclistLine_mask) ^ 0x000200000));
			}
		}
		public static void resolveP2Values(Vdbe p, int* pMaxFuncArgs)
		{
			int nMaxArgs = (int)(*pMaxFuncArgs);
			VdbeOp* pOp;
			Parse pParse = p.pParse;
			int* aLabel = pParse.aLabel;
			p.readOnly = (uint)(1);
			p.bIsReader = (uint)(0);
			pOp = &p.aOp[p.nOp - 1];
			while ((1) != 0)
			{
				if ((pOp->opcode) <= (64))
				{
					switch (pOp->opcode)
					{
						case 2:
							{
								if (pOp->p2 != 0)
									p.readOnly = (uint)(0);
							}

						case 1:
						case 0:
							{
								p.bIsReader = (uint)(1);
								break;
							}

						case 6:
						case 8:
						case 7:
							{
								p.readOnly = (uint)(0);
								p.bIsReader = (uint)(1);
								break;
							}

						case 5:
						case 3:
							{
								pOp->p4.xAdvance = sqlite3BtreeNext;
								pOp->p4type = (sbyte)(-5);
								break;
							}

						case 4:
							{
								pOp->p4.xAdvance = sqlite3BtreePrevious;
								pOp->p4type = (sbyte)(-5);
								break;
							}

						case 10:
							{
								if ((pOp->p2) > (nMaxArgs))
									nMaxArgs = (int)(pOp->p2);
								break;
							}

						case 9:
							{
								int n = 0;
								n = (int)(pOp[-1].p1);
								if ((n) > (nMaxArgs))
									nMaxArgs = (int)(n);
							}

						default:
							{
								if ((pOp->p2) < (0))
								{
									pOp->p2 = (int)(aLabel[(~(pOp->p2))]);
								}

								break;
							}
					}
				}

				if ((pOp) == (p.aOp))
					break;
				pOp--;
			}

			sqlite3DbFree(p.db, pParse.aLabel);
			pParse.aLabel = null;
			pParse.nLabel = (int)(0);
			*pMaxFuncArgs = (int)(nMaxArgs);
		}
		public static void returnSingleInt(Vdbe v, long value)
		{
			sqlite3VdbeAddOp4Dup8(v, (int)(72), (int)(0), (int)(1), (int)(0), (byte*)(&value), (int)(-14));
			sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
		}
		public static void returnSingleText(Vdbe v, sbyte* zValue)
		{
			if ((zValue) != null)
			{
				sqlite3VdbeLoadString(v, (int)(1), zValue);
				sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
			}
		}
		public static void setDoNotMergeFlagOnCopy(Vdbe v)
		{
			if ((sqlite3VdbeGetOp(v, (int)(-1))->opcode) == (79))
			{
				sqlite3VdbeChangeP5(v, (ushort)(1));
			}
		}
		public static void setPragmaResultColumnNames(Vdbe v, PragmaName* pPragma)
		{
			byte n = (byte)(pPragma->nPragCName);
			sqlite3VdbeSetNumCols(v, (int)((n) == (0) ? 1 : n));
			if ((n) == (0))
			{
				sqlite3VdbeSetColName(v, (int)(0), (int)(0), pPragma->zName, null);
			}
			else
			{
				int i = 0;
				int j = 0;
				for (i = (int)(0), j = (int)(pPragma->iPragCName); (i) < (n); i++, j++)
				{
					sqlite3VdbeSetColName(v, (int)(i), (int)(0), pragCName[j], null);
				}
			}
		}
		public static void sqlite3CodeChangeCount(Vdbe v, int regCounter, sbyte* zColName)
		{
			sqlite3VdbeAddOp0(v, (int)(82));
			sqlite3VdbeAddOp2(v, (int)(83), (int)(regCounter), (int)(1));
			sqlite3VdbeSetNumCols(v, (int)(1));
			sqlite3VdbeSetColName(v, (int)(0), (int)(0), zColName, null);
		}
		public static void sqlite3ColumnDefault(Vdbe v, Table pTab, int i, int iReg)
		{
			if (!(((pTab).eTabType) == (2)))
			{
				sqlite3_value pValue = null;
				byte enc = (byte)((sqlite3VdbeDb(v)).enc);
				Column* pCol = &pTab.aCol[i];
				sqlite3ValueFromExpr(sqlite3VdbeDb(v), sqlite3ColumnExpr(pTab, pCol), (byte)(enc), (byte)(pCol->affinity), pValue);
				if ((pValue) != null)
				{
					sqlite3VdbeAppendP4(v, pValue, (int)(-11));
				}
			}

			if (((pTab.aCol[i].affinity) == (0x45)) && (!(((pTab).eTabType) == (1))))
			{
				sqlite3VdbeAddOp1(v, (int)(86), (int)(iReg));
			}
		}
		public static void sqlite3ExprCodeGetColumnOfTable(Vdbe v, Table pTab, int iTabCur, int iCol, int regOut)
		{
			Column* pCol;
			if ((pTab) == (null))
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(iTabCur), (int)(iCol), (int)(regOut));
				return;
			}

			if (((iCol) < (0)) || ((iCol) == (pTab.iPKey)))
			{
				sqlite3VdbeAddOp2(v, (int)(134), (int)(iTabCur), (int)(regOut));
			}
			else
			{
				int op = 0;
				int x = 0;
				if ((((pTab).eTabType) == (1)))
				{
					op = (int)(174);
					x = (int)(iCol);
				}
				else if (((pCol = &pTab.aCol[iCol])->colFlags & 0x0020) != 0)
				{
					Parse pParse = sqlite3VdbeParser(v);
					if ((pCol->colFlags & 0x0100) != 0)
					{
						sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol->zCnName);
					}
					else
					{
						int savedSelfTab = (int)(pParse.iSelfTab);
						pCol->colFlags |= (ushort)(0x0100);
						pParse.iSelfTab = (int)(iTabCur + 1);
						sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(regOut));
						pParse.iSelfTab = (int)(savedSelfTab);
						pCol->colFlags &= (ushort)(~0x0100);
					}

					return;
				}
				else if (!(((pTab).tabFlags & 0x00000080) == (0)))
				{
					x = (int)(sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), (short)(iCol)));
					op = (int)(93);
				}
				else
				{
					x = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)));
					op = (int)(93);
				}

				sqlite3VdbeAddOp3(v, (int)(op), (int)(iTabCur), (int)(x), (int)(regOut));
				sqlite3ColumnDefault(v, pTab, (int)(iCol), (int)(regOut));
			}
		}
		public static int sqlite3Reprepare(Vdbe p)
		{
			int rc = 0;
			sqlite3_stmt* pNew;
			sbyte* zSql;
			sqlite3 db;
			byte prepFlags = 0;
			zSql = sqlite3_sql((sqlite3_stmt*)(p));
			db = sqlite3VdbeDb(p);
			prepFlags = (byte)(sqlite3VdbePrepareFlags(p));
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(-1), (uint)(prepFlags), p, &pNew, null));
			if ((rc) != 0)
			{
				if ((rc) == (7))
				{
					sqlite3OomFault(db);
				}

				return (int)(rc);
			}
			else
			{
			}

			sqlite3VdbeSwap((Vdbe)(pNew), p);
			sqlite3TransferBindings(pNew, (sqlite3_stmt*)(p));
			sqlite3VdbeResetStepResult((Vdbe)(pNew));
			sqlite3VdbeFinalize((Vdbe)(pNew));
			return (int)(0);
		}
		public static void sqlite3SetHasNullFlag(Vdbe v, int iCur, int regHasNull)
		{
			int addr1 = 0;
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regHasNull));
			addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
			sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(0), (int)(regHasNull));
			sqlite3VdbeChangeP5(v, (ushort)(0x80));
			sqlite3VdbeJumpHere(v, (int)(addr1));
		}
		public static int sqlite3Step(Vdbe p)
		{
			sqlite3 db;
			int rc = 0;
			if (p.iVdbeMagic != 0x2df20da3)
			{
				sqlite3_reset((sqlite3_stmt*)(p));
			}

			db = p.db;
			if ((db.mallocFailed) != 0)
			{
				p.rc = (int)(7);
				return (int)(7);
			}

			if (((p.pc) < (0)) && ((p.expired) != 0))
			{
				p.rc = (int)(17);
				rc = (int)(1);
				if ((p.prepFlags & 0x80) != 0)
				{
					rc = (int)(sqlite3VdbeTransferError(p));
				}

				goto end_of_step;
			}

			if ((p.pc) < (0))
			{
				if ((db.nVdbeActive) == (0))
				{
					(0);
				}

				if ((((db.mTrace & (0x02 | 0x80)) != 0) && (db.init.busy == 0)) && ((p.zSql) != null))
				{
					sqlite3OsCurrentTimeInt64(db.pVfs, &p.startTime);
				}
				else
				{
				}

				db.nVdbeActive++;
				if ((p.readOnly) == (0))
					db.nVdbeWrite++;
				if ((p.bIsReader) != 0)
					db.nVdbeRead++;
				p.pc = (int)(0);
			}

			if ((p.explain) != 0)
			{
				rc = (int)(sqlite3VdbeList(p));
			}
			else
			{
				db.nVdbeExec++;
				rc = (int)(sqlite3VdbeExec(p));
				db.nVdbeExec--;
			}

			if (rc != 100)
			{
				if (((p).startTime) > (0))
				{
					invokeProfileCallback(db, p);
				}

				if (((rc) == (101)) && ((db.autoCommit) != 0))
				{
					p.rc = (int)(doWalCallbacks(db));
					if (p.rc != 0)
					{
						rc = (int)(1);
					}
				}
				else if ((rc != 101) && ((p.prepFlags & 0x80) != 0))
				{
					rc = (int)(sqlite3VdbeTransferError(p));
				}
			}

			db.errCode = (int)(rc);
			if ((7) == (sqlite3ApiExit(p.db, (int)(p.rc))))
			{
				p.rc = (int)(7);
				if ((p.prepFlags & 0x80) != 0)
					rc = (int)(p.rc);
			}

		end_of_step:
			;
			return (int)(rc & db.errMask);
		}
		public static void sqlite3TableAffinity(Vdbe v, Table pTab, int iReg)
		{
			int i = 0; int j = 0;
			sbyte* zColAff;
			if ((pTab.tabFlags & 0x00010000) != 0)
			{
				if ((iReg) == (0))
				{
					VdbeOp* pPrev;
					sqlite3VdbeAppendP4(v, pTab, (int)(-6));
					pPrev = sqlite3VdbeGetOp(v, (int)(-1));
					pPrev->opcode = (byte)(94);
					sqlite3VdbeAddOp3(v, (int)(96), (int)(pPrev->p1), (int)(pPrev->p2), (int)(pPrev->p3));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(94), (int)(iReg), (int)(pTab.nNVCol));
					sqlite3VdbeAppendP4(v, pTab, (int)(-6));
				}

				return;
			}

			zColAff = pTab.zColAff;
			if ((zColAff) == (null))
			{
				sqlite3 db = sqlite3VdbeDb(v);
				zColAff = (sbyte*)(sqlite3DbMallocRaw(null, (ulong)(pTab.nCol + 1)));
				if (zColAff == null)
				{
					sqlite3OomFault(db);
					return;
				}

				for (i = (int)(j = (int)(0)); (i) < (pTab.nCol); i++)
				{
					if ((pTab.aCol[i].colFlags & 0x0020) == (0))
					{
						zColAff[j++] = (sbyte)(pTab.aCol[i].affinity);
					}
				}

				do
				{
					zColAff[j--] = (sbyte)(0);
				}
				while (((j) >= (0)) && ((zColAff[j]) <= (0x41)));
				pTab.zColAff = zColAff;
			}

			i = (int)(CRuntime.strlen(zColAff) & 0x3fffffff);
			if ((i) != 0)
			{
				if ((iReg) != 0)
				{
					sqlite3VdbeAddOp4(v, (int)(95), (int)(iReg), (int)(i), (int)(0), zColAff, (int)(i));
				}
				else
				{
					sqlite3VdbeChangeP4(v, (int)(-1), zColAff, (int)(i));
				}
			}
		}
		public static int sqlite3VdbeAddOp0(Vdbe p, int op)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(0), (int)(0), (int)(0)));
		}
		public static int sqlite3VdbeAddOp1(Vdbe p, int op, int p1)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(0), (int)(0)));
		}
		public static int sqlite3VdbeAddOp2(Vdbe p, int op, int p1, int p2)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(0)));
		}
		public static int sqlite3VdbeAddOp3(Vdbe p, int op, int p1, int p2, int p3)
		{
			int i = 0;
			VdbeOp* pOp;
			i = (int)(p.nOp);
			if ((p.nOpAlloc) <= (i))
			{
				return (int)(growOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
			}

			p.nOp++;
			pOp = &p.aOp[i];
			pOp->opcode = ((byte)(op));
			pOp->p5 = (ushort)(0);
			pOp->p1 = (int)(p1);
			pOp->p2 = (int)(p2);
			pOp->p3 = (int)(p3);
			pOp->p4.p = null;
			pOp->p4type = (sbyte)(0);
			return (int)(i);
		}
		public static int sqlite3VdbeAddOp4(Vdbe p, int op, int p1, int p2, int p3, sbyte* zP4, int p4type)
		{
			int addr = (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
			sqlite3VdbeChangeP4(p, (int)(addr), zP4, (int)(p4type));
			return (int)(addr);
		}
		public static int sqlite3VdbeAddOp4Dup8(Vdbe p, int op, int p1, int p2, int p3, byte* zP4, int p4type)
		{
			sbyte* p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), (ulong)(8));
			if ((p4copy) != null)
				CRuntime.memcpy(p4copy, zP4, (ulong)(8));
			return (int)(sqlite3VdbeAddOp4(p, (int)(op), (int)(p1), (int)(p2), (int)(p3), p4copy, (int)(p4type)));
		}
		public static int sqlite3VdbeAddOp4Int(Vdbe p, int op, int p1, int p2, int p3, int p4)
		{
			int addr = (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
			if ((p.db.mallocFailed) == (0))
			{
				VdbeOp* pOp = &p.aOp[addr];
				pOp->p4type = (sbyte)(-3);
				pOp->p4.i = (int)(p4);
			}

			return (int)(addr);
		}
		public static void sqlite3VdbeAddParseSchemaOp(Vdbe p, int iDb, sbyte* zWhere, ushort p5)
		{
			int j = 0;
			sqlite3VdbeAddOp4(p, (int)(148), (int)(iDb), (int)(0), (int)(0), zWhere, (int)(-7));
			sqlite3VdbeChangeP5(p, (ushort)(p5));
			for (j = (int)(0); (j) < (p.db.nDb); j++)
			{
				sqlite3VdbeUsesBtree(p, (int)(j));
			}

			sqlite3MayAbort(p.pParse);
		}
		public static void sqlite3VdbeAppendP4(Vdbe p, void* pP4, int n)
		{
			VdbeOp* pOp;
			if ((p.db.mallocFailed) != 0)
			{
				freeP4(p.db, (int)(n), pP4);
			}
			else
			{
				pOp = &p.aOp[p.nOp - 1];
				pOp->p4type = (sbyte)(n);
				pOp->p4.p = pP4;
			}
		}
		public static void sqlite3VdbeChangeOpcode(Vdbe p, int addr, byte iNewOpcode)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->opcode = (byte)(iNewOpcode);
		}
		public static void sqlite3VdbeChangeP1(Vdbe p, int addr, int val)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->p1 = (int)(val);
		}
		public static void sqlite3VdbeChangeP2(Vdbe p, int addr, int val)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->p2 = (int)(val);
		}
		public static void sqlite3VdbeChangeP3(Vdbe p, int addr, int val)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->p3 = (int)(val);
		}
		public static void sqlite3VdbeChangeP4(Vdbe p, int addr, sbyte* zP4, int n)
		{
			VdbeOp* pOp;
			sqlite3 db;
			db = p.db;
			if ((db.mallocFailed) != 0)
			{
				if (n != (-12))
					freeP4(db, (int)(n), (void*)(*&zP4));
				return;
			}

			if ((addr) < (0))
			{
				addr = (int)(p.nOp - 1);
			}

			pOp = &p.aOp[addr];
			if (((n) >= (0)) || ((pOp->p4type) != 0))
			{
				vdbeChangeP4Full(p, pOp, zP4, (int)(n));
				return;
			}

			if ((n) == (-3))
			{
				pOp->p4.i = ((int)((long)(zP4)));
				pOp->p4type = (sbyte)(-3);
			}
			else if (zP4 != null)
			{
				pOp->p4.p = (void*)(zP4);
				pOp->p4type = ((sbyte)(n));
				if ((n) == (-12))
					sqlite3VtabLock((VTable)(zP4));
			}
		}
		public static void sqlite3VdbeChangeP5(Vdbe p, ushort p5)
		{
			if ((p.nOp) > (0))
				p.aOp[p.nOp - 1].p5 = (ushort)(p5);
		}
		public static int sqlite3VdbeChangeToNoop(Vdbe p, int addr)
		{
			VdbeOp* pOp;
			if ((p.db.mallocFailed) != 0)
				return (int)(0);
			pOp = &p.aOp[addr];
			freeP4(p.db, (int)(pOp->p4type), pOp->p4.p);
			pOp->p4type = (sbyte)(0);
			pOp->p4.z = null;
			pOp->opcode = (byte)(182);
			return (int)(1);
		}
		public static int sqlite3VdbeCheckFk(Vdbe p, int deferred)
		{
			sqlite3 db = p.db;
			if ((((deferred) != 0) && ((db.nDeferredCons + db.nDeferredImmCons) > (0))) || ((deferred == 0) && ((p.nFkConstraint) > (0))))
			{
				p.rc = (int)(19 | (3 << 8));
				p.errorAction = (byte)(2);
				sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
				return (int)(1);
			}

			return (int)(0);
		}
		public static int sqlite3VdbeCloseStatement(Vdbe p, int eOp)
		{
			if (((p.db.nStatement) != 0) && ((p.iStatement) != 0))
			{
				return (int)(vdbeCloseStatement(p, (int)(eOp)));
			}

			return (int)(0);
		}
		public static void sqlite3VdbeCountChanges(Vdbe v)
		{
			v.changeCntOn = (uint)(1);
		}
		public static int sqlite3VdbeCurrentAddr(Vdbe p)
		{
			return (int)(p.nOp);
		}
		public static sqlite3 sqlite3VdbeDb(Vdbe v)
		{
			return v.db;
		}
		public static void sqlite3VdbeDelete(Vdbe p)
		{
			sqlite3 db;
			db = p.db;
			sqlite3VdbeClearObject(db, p);
			if ((p.pPrev) != null)
			{
				p.pPrev.pNext = p.pNext;
			}
			else
			{
				db.pVdbe = p.pNext;
			}

			if ((p.pNext) != null)
			{
				p.pNext.pPrev = p.pPrev;
			}

			p.iVdbeMagic = (uint)(0x5606c3c8);
			p.db = null;
			sqlite3DbFreeNN(db, p);
		}
		public static int sqlite3VdbeDeletePriorOpcode(Vdbe p, byte op)
		{
			if (((p.nOp) > (0)) && ((p.aOp[p.nOp - 1].opcode) == (op)))
			{
				return (int)(sqlite3VdbeChangeToNoop(p, (int)(p.nOp - 1)));
			}
			else
			{
				return (int)(0);
			}
		}
		public static void sqlite3VdbeEndCoroutine(Vdbe v, int regYield)
		{
			sqlite3VdbeAddOp1(v, (int)(68), (int)(regYield));
			v.pParse.nTempReg = (byte)(0);
			v.pParse.nRangeReg = (int)(0);
		}
		public static void sqlite3VdbeEnter(Vdbe p)
		{
			int i = 0;
			sqlite3 db;
			Db aDb;
			int nDb = 0;
			if ((p.lockMask) == (0))
				return;
			db = p.db;
			aDb = db.aDb;
			nDb = (int)(db.nDb);
			for (i = (int)(0); (i) < (nDb); i++)
			{
				if (((i != 1) && (((p.lockMask) & (((uint)(1)) << (i))) != 0)) && (aDb[i].pBt != null))
				{
					sqlite3BtreeEnter(aDb[i].pBt);
				}
			}
		}
		public static void sqlite3VdbeError(Vdbe p, sbyte* zFormat)
		{
			sbyte* ap;
			sqlite3DbFree(p.db, p.zErrMsg);
			(__va_start(&ap, zFormat));
			p.zErrMsg = sqlite3VMPrintf(p.db, zFormat, ap);
			((void)(ap = null));
		}
		public static int sqlite3VdbeExec(Vdbe p)
		{
			VdbeOp* aOp = p.aOp;
			VdbeOp* pOp = aOp;
			int rc = (int)(0);
			sqlite3 db = p.db;
			byte resetSchemaOnFault = (byte)(0);
			byte encoding = (byte)((db).enc);
			int iCompare = (int)(0);
			ulong nVmStep = (ulong)(0);
			ulong nProgressLimit = 0;
			sqlite3_value aMem = p.aMem;
			sqlite3_value pIn1 = null;
			sqlite3_value pIn2 = null;
			sqlite3_value pIn3 = null;
			sqlite3_value pOut = null;
			sqlite3VdbeEnter(p);
			if ((db.xProgress) != null)
			{
				uint iPrior = (uint)(p.aCounter[4]);
				nProgressLimit = (ulong)(db.nProgressOps - (iPrior % db.nProgressOps));
			}
			else
			{
				nProgressLimit = (ulong)(0xffffffff | (((ulong)(0xffffffff)) << 32));
			}

			if ((p.rc) == (7))
			{
				goto no_mem;
			}

			p.rc = (int)(0);
			p.iCurrentTime = (long)(0);
			p.pResultSet = null;
			db.busyHandler.nBusy = (int)(0);
			if ((0) != 0)
				goto abort_due_to_interrupt;
			for (pOp = &aOp[p.pc]; 1; pOp++)
			{
				nVmStep++;
				switch (pOp->opcode)
				{
					case 11:
						{
						jump_to_p2_and_check_for_interrupt:
							;
							pOp = &aOp[pOp->p2 - 1];
						check_for_interrupt:
							;
							if ((0) != 0)
								goto abort_due_to_interrupt;
							while (((nVmStep) >= (nProgressLimit)) && (db.xProgress != null))
							{
								nProgressLimit += (ulong)(db.nProgressOps);
								if ((db.xProgress(db.pProgressArg)) != 0)
								{
									nProgressLimit = (ulong)(0xffffffff | (((ulong)(0xffffffff)) << 32));
									rc = (int)(9);
									goto abort_due_to_error;
								}
							}

							break;
						}

					case 12:
						{
							pIn1 = aMem[pOp->p1];
							pIn1.flags = (ushort)(0x0004);
							pIn1.u.i = (long)((int)(pOp - aOp));
						jump_to_p2:
							;
							pOp = &aOp[pOp->p2 - 1];
							break;
						}

					case 67:
						{
							pIn1 = aMem[pOp->p1];
							pOp = &aOp[pIn1.u.i];
							pIn1.flags = (ushort)(0x0080);
							break;
						}

					case 13:
						{
							pOut = aMem[pOp->p1];
							pOut.u.i = (long)(pOp->p3 - 1);
							pOut.flags = (ushort)(0x0004);
							if ((pOp->p2) != 0)
								goto jump_to_p2;
							break;
						}

					case 68:
						{
							VdbeOp* pCaller;
							pIn1 = aMem[pOp->p1];
							pCaller = &aOp[pIn1.u.i];
							pOp = &aOp[pCaller->p2 - 1];
							pIn1.flags = (ushort)(0x0080);
							break;
						}

					case 14:
						{
							int pcDest = 0;
							pIn1 = aMem[pOp->p1];
							pIn1.flags = (ushort)(0x0004);
							pcDest = ((int)(pIn1.u.i));
							pIn1.u.i = (long)((int)(pOp - aOp));
							pOp = &aOp[pcDest];
							break;
						}

					case 69:
						{
							pIn3 = aMem[pOp->p3];
							if ((pIn3.flags & 0x0001) == (0))
								break;
						}

					case 70:
						{
							VdbeFrame pFrame;
							int pcx = 0;
							pcx = ((int)(pOp - aOp));
							if (((pOp->p1) == (0)) && ((p.pFrame) != null))
							{
								pFrame = p.pFrame;
								p.pFrame = pFrame.pParent;
								p.nFrame--;
								sqlite3VdbeSetChanges(db, (long)(p.nChange));
								pcx = (int)(sqlite3VdbeFrameRestore(pFrame));
								if ((pOp->p2) == (4))
								{
									pcx = (int)(p.aOp[pcx].p2 - 1);
								}

								aOp = p.aOp;
								aMem = p.aMem;
								pOp = &aOp[pcx];
								break;
							}

							p.rc = (int)(pOp->p1);
							p.errorAction = ((byte)(pOp->p2));
							p.pc = (int)(pcx);
							if ((p.rc) != 0)
							{
								if ((pOp->p5) != 0)
								{
									sqlite3VdbeError(p, "%s constraint failed", sqlite3VdbeExec_azType[pOp->p5 - 1]);
									if ((pOp->p4.z) != null)
									{
										p.zErrMsg = sqlite3MPrintf(db, "%z: %s", p.zErrMsg, pOp->p4.z);
									}
								}
								else
								{
									sqlite3VdbeError(p, "%s", pOp->p4.z);
								}

								sqlite3_log((int)(pOp->p1), "abort at %d in [%s]: %s", (int)(pcx), p.zSql, p.zErrMsg);
							}

							rc = (int)(sqlite3VdbeHalt(p));
							if ((rc) == (5))
							{
								p.rc = (int)(5);
							}
							else
							{
								rc = (int)((p.rc) != 0 ? 1 : 101);
							}

							goto vdbe_return;
						}

					case 71:
						{
							pOut = out2Prerelease(p, pOp);
							pOut.u.i = (long)(pOp->p1);
							break;
						}

					case 72:
						{
							pOut = out2Prerelease(p, pOp);
							pOut.u.i = (long)(*pOp->p4.pI64);
							break;
						}

					case 153:
						{
							pOut = out2Prerelease(p, pOp);
							pOut.flags = (ushort)(0x0008);
							pOut.u.r = (double)(*pOp->p4.pReal);
							break;
						}

					case 117:
						{
							pOut = out2Prerelease(p, pOp);
							pOp->p1 = (int)(sqlite3Strlen30(pOp->p4.z));
							if (encoding != 1)
							{
								rc = (int)(sqlite3VdbeMemSetStr(pOut, pOp->p4.z, (long)(-1), (byte)(1), null));
								if ((rc) != 0)
									goto too_big;
								if (0 != sqlite3VdbeChangeEncoding(pOut, (int)(encoding)))
									goto no_mem;
								pOut.szMalloc = (int)(0);
								pOut.flags |= (ushort)(0x0800);
								if ((pOp->p4type) == (-7))
								{
									sqlite3DbFree(db, pOp->p4.z);
								}

								pOp->p4type = (sbyte)(-7);
								pOp->p4.z = pOut.z;
								pOp->p1 = (int)(pOut.n);
							}

							if ((pOp->p1) > (db.aLimit[0]))
							{
								goto too_big;
							}

							pOp->opcode = (byte)(73);
						}

					case 73:
						{
							pOut = out2Prerelease(p, pOp);
							pOut.flags = (ushort)(0x0002 | 0x0800 | 0x0200);
							pOut.z = pOp->p4.z;
							pOut.n = (int)(pOp->p1);
							pOut.enc = (byte)(encoding);
							if ((pOp->p3) > (0))
							{
								pIn3 = aMem[pOp->p3];
								if ((pIn3.u.i) == (pOp->p5))
									pOut.flags = (ushort)(0x0010 | 0x0800 | 0x0200);
							}

							break;
						}

					case 74:
						{
							int cnt = 0;
							ushort nullFlag = 0;
							pOut = out2Prerelease(p, pOp);
							cnt = (int)(pOp->p3 - pOp->p2);
							pOut.flags = (ushort)(nullFlag = (ushort)((pOp->p1) != 0 ? (0x0001 | 0x0100) : 0x0001));
							pOut.n = (int)(0);
							while ((cnt) > (0))
							{
								pOut++;
								sqlite3VdbeMemSetNull(pOut);
								pOut.flags = (ushort)(nullFlag);
								pOut.n = (int)(0);
								cnt--;
							}

							break;
						}

					case 75:
						{
							pOut = aMem[pOp->p1];
							pOut.flags = (ushort)((pOut.flags & ~(0x0080 | 0x003f)) | 0x0001);
							break;
						}

					case 76:
						{
							pOut = out2Prerelease(p, pOp);
							if ((pOp->p4.z) == (null))
							{
								sqlite3VdbeMemSetZeroBlob(pOut, (int)(pOp->p1));
								if ((sqlite3VdbeMemExpandBlob(pOut)) != 0)
									goto no_mem;
							}
							else
							{
								sqlite3VdbeMemSetStr(pOut, pOp->p4.z, (long)(pOp->p1), (byte)(0), null);
							}

							pOut.enc = (byte)(encoding);
							break;
						}

					case 77:
						{
							sqlite3_value pVar;
							pVar = p.aVar[pOp->p1 - 1];
							if ((sqlite3VdbeMemTooBig(pVar)) != 0)
							{
								goto too_big;
							}

							pOut = aMem[pOp->p2];
							if ((((pOut).flags & (0x2000 | 0x0400)) != 0))
								sqlite3VdbeMemSetNull(pOut);
							CRuntime.memcpy(pOut, pVar, ((ulong)(&((0).zMalloc))));
							pOut.flags &= (ushort)(~(0x0400 | 0x1000));
							pOut.flags |= (ushort)(0x0800 | 0x0040);
							break;
						}

					case 78:
						{
							int n = 0;
							int p1 = 0;
							int p2 = 0;
							n = (int)(pOp->p3);
							p1 = (int)(pOp->p1);
							p2 = (int)(pOp->p2);
							pIn1 = aMem[p1];
							pOut = aMem[p2];
							do
							{
								sqlite3VdbeMemMove(pOut, pIn1);
								if ((((pOut).flags & 0x1000) != 0) && ((sqlite3VdbeMemMakeWriteable(pOut)) != 0))
								{
									goto no_mem;
								}

								pIn1++;
								pOut++;
							}
							while ((--n) != 0);
							break;
						}

					case 79:
						{
							int n = 0;
							n = (int)(pOp->p3);
							pIn1 = aMem[pOp->p1];
							pOut = aMem[pOp->p2];
							while ((1) != 0)
							{
								sqlite3VdbeMemShallowCopy(pOut, pIn1, (int)(0x1000));
								if ((((pOut).flags & 0x1000) != 0) && ((sqlite3VdbeMemMakeWriteable(pOut)) != 0))
								{
									goto no_mem;
								}

								if ((n--) == (0))
									break;
								pOut++;
								pIn1++;
							}

							break;
						}

					case 80:
						{
							pIn1 = aMem[pOp->p1];
							pOut = aMem[pOp->p2];
							sqlite3VdbeMemShallowCopy(pOut, pIn1, (int)(0x1000));
							break;
						}

					case 81:
						{
							pIn1 = aMem[pOp->p1];
							pOut = aMem[pOp->p2];
							sqlite3VdbeMemSetInt64(pOut, (long)(pIn1.u.i));
							break;
						}

					case 82:
						{
							if ((rc = (int)(sqlite3VdbeCheckFk(p, (int)(0)))) != 0)
							{
								goto abort_due_to_error;
							}

							break;
						}

					case 83:
						{
							sqlite3_value pMem;
							int i = 0;
							p.cacheCtr = (uint)((p.cacheCtr + 2) | 1);
							pMem = p.pResultSet = aMem[pOp->p1];
							for (i = (int)(0); (i) < (pOp->p2); i++)
							{
								if ((((pMem[i]).flags & 0x1000) != 0) && ((sqlite3VdbeMemMakeWriteable(pMem[i])) != 0))
								{
									goto no_mem;
								}

								sqlite3VdbeMemNulTerminate(pMem[i]);
							}

							if ((db.mallocFailed) != 0)
								goto no_mem;
							if ((db.mTrace & 0x04) != 0)
							{
								db.trace.xV2((uint)(0x04), db.pTraceArg, p, null);
							}

							p.pc = (int)((int)(pOp - aOp) + 1);
							rc = (int)(100);
							goto vdbe_return;
						}

					case 111:
						{
							long nByte = 0;
							ushort flags1 = 0;
							ushort flags2 = 0;
							pIn1 = aMem[pOp->p1];
							pIn2 = aMem[pOp->p2];
							pOut = aMem[pOp->p3];
							flags1 = (ushort)(pIn1.flags);
							if (((flags1 | pIn2.flags) & 0x0001) != 0)
							{
								sqlite3VdbeMemSetNull(pOut);
								break;
							}

							if ((flags1 & (0x0002 | 0x0010)) == (0))
							{
								if ((sqlite3VdbeMemStringify(pIn1, (byte)(encoding), (byte)(0))) != 0)
									goto no_mem;
								flags1 = (ushort)(pIn1.flags & ~0x0002);
							}
							else if ((flags1 & 0x4000) != 0)
							{
								if ((sqlite3VdbeMemExpandBlob(pIn1)) != 0)
									goto no_mem;
								flags1 = (ushort)(pIn1.flags & ~0x0002);
							}

							flags2 = (ushort)(pIn2.flags);
							if ((flags2 & (0x0002 | 0x0010)) == (0))
							{
								if ((sqlite3VdbeMemStringify(pIn2, (byte)(encoding), (byte)(0))) != 0)
									goto no_mem;
								flags2 = (ushort)(pIn2.flags & ~0x0002);
							}
							else if ((flags2 & 0x4000) != 0)
							{
								if ((sqlite3VdbeMemExpandBlob(pIn2)) != 0)
									goto no_mem;
								flags2 = (ushort)(pIn2.flags & ~0x0002);
							}

							nByte = (long)(pIn1.n + pIn2.n);
							if ((nByte) > (db.aLimit[0]))
							{
								goto too_big;
							}

							if ((sqlite3VdbeMemGrow(pOut, (int)((int)(nByte) + 3), ((pOut) == (pIn2) ? 1 : 0))) != 0)
							{
								goto no_mem;
							}

						((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0002));
							if (pOut != pIn2)
							{
								CRuntime.memcpy(pOut.z, pIn2.z, (ulong)(pIn2.n));
								pIn2.flags = (ushort)(flags2);
							}

							CRuntime.memcpy(&pOut.z[pIn2.n], pIn1.z, (ulong)(pIn1.n));
							pIn1.flags = (ushort)(flags1);
							pOut.z[nByte] = (sbyte)(0);
							pOut.z[nByte + 1] = (sbyte)(0);
							pOut.z[nByte + 2] = (sbyte)(0);
							pOut.flags |= (ushort)(0x0200);
							pOut.n = ((int)(nByte));
							pOut.enc = (byte)(encoding);
							break;
						}

					case 106:
					case 107:
					case 108:
					case 109:
					case 110:
						{
							ushort flags = 0;
							ushort type1 = 0;
							ushort type2 = 0;
							long iA = 0;
							long iB = 0;
							double rA = 0;
							double rB = 0;
							pIn1 = aMem[pOp->p1];
							type1 = (ushort)(numericType(pIn1));
							pIn2 = aMem[pOp->p2];
							type2 = (ushort)(numericType(pIn2));
							pOut = aMem[pOp->p3];
							flags = (ushort)(pIn1.flags | pIn2.flags);
							if ((type1 & type2 & 0x0004) != 0)
							{
								iA = (long)(pIn1.u.i);
								iB = (long)(pIn2.u.i);
								switch (pOp->opcode)
								{
									case 106:
										if ((sqlite3AddInt64(&iB, (long)(iA))) != 0)
											goto fp_math;
										break;
									case 107:
										if ((sqlite3SubInt64(&iB, (long)(iA))) != 0)
											goto fp_math;
										break;
									case 108:
										if ((sqlite3MulInt64(&iB, (long)(iA))) != 0)
											goto fp_math;
										break;
									case 109:
										{
											if ((iA) == (0))
												goto arithmetic_result_is_null;
											if (((iA) == (-1)) && ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32)))))
												goto fp_math;
											iB /= (long)(iA);
											break;
										}

									default:
										{
											if ((iA) == (0))
												goto arithmetic_result_is_null;
											if ((iA) == (-1))
												iA = (long)(1);
											iB %= (long)(iA);
											break;
										}
								}

								pOut.u.i = (long)(iB);
								((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0004));
							}
							else if ((flags & 0x0001) != 0)
							{
								goto arithmetic_result_is_null;
							}
							else
							{
							fp_math:
								;
								rA = (double)(sqlite3VdbeRealValue(pIn1));
								rB = (double)(sqlite3VdbeRealValue(pIn2));
								switch (pOp->opcode)
								{
									case 106:
										rB += (double)(rA);
										break;
									case 107:
										rB -= (double)(rA);
										break;
									case 108:
										rB *= (double)(rA);
										break;
									case 109:
										{
											if ((rA) == ((double)(0)))
												goto arithmetic_result_is_null;
											rB /= (double)(rA);
											break;
										}

									default:
										{
											iA = (long)(sqlite3VdbeIntValue(pIn1));
											iB = (long)(sqlite3VdbeIntValue(pIn2));
											if ((iA) == (0))
												goto arithmetic_result_is_null;
											if ((iA) == (-1))
												iA = (long)(1);
											rB = ((double)(iB % iA));
											break;
										}
								}

								if ((sqlite3IsNaN((double)(rB))) != 0)
								{
									goto arithmetic_result_is_null;
								}

								pOut.u.r = (double)(rB);
								((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0008));
							}

							break;
						arithmetic_result_is_null:
							;
							sqlite3VdbeMemSetNull(pOut);
							break;
						}

					case 84:
						{
							if ((pOp->p1) != 0)
							{
								sqlite3VdbeMemSetInt64(aMem[pOp->p1], (long)(0));
							}

							break;
						}

					case 102:
					case 103:
					case 104:
					case 105:
						{
							long iA = 0;
							ulong uA = 0;
							long iB = 0;
							byte op = 0;
							pIn1 = aMem[pOp->p1];
							pIn2 = aMem[pOp->p2];
							pOut = aMem[pOp->p3];
							if (((pIn1.flags | pIn2.flags) & 0x0001) != 0)
							{
								sqlite3VdbeMemSetNull(pOut);
								break;
							}

							iA = (long)(sqlite3VdbeIntValue(pIn2));
							iB = (long)(sqlite3VdbeIntValue(pIn1));
							op = (byte)(pOp->opcode);
							if ((op) == (102))
							{
								iA &= (long)(iB);
							}
							else if ((op) == (103))
							{
								iA |= (long)(iB);
							}
							else if (iB != 0)
							{
								if ((iB) < (0))
								{
									op = (byte)(2 * 104 + 1 - op);
									iB = (long)((iB) > (-64) ? -iB : 64);
								}

								if ((iB) >= (64))
								{
									iA = (long)((((iA) >= (0)) || ((op) == (104))) ? 0 : -1);
								}
								else
								{
									CRuntime.memcpy(&uA, &iA, (ulong)(sizeof(ulong)));
									if ((op) == (104))
									{
										uA <<= iB;
									}
									else
									{
										uA >>= iB;
										if ((iA) < (0))
											uA |= (ulong)(((((ulong)(0xffffffff)) << 32) | 0xffffffff) << (64 - iB));
									}

									CRuntime.memcpy(&iA, &uA, (ulong)(sizeof(long)));
								}
							}

							pOut.u.i = (long)(iA);
							((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0004));
							break;
						}

					case 85:
						{
							pIn1 = aMem[pOp->p1];
							sqlite3VdbeMemIntegerify(pIn1);
							pIn1.u.i += (long)(pOp->p2);
							break;
						}

					case 15:
						{
							pIn1 = aMem[pOp->p1];
							if ((pIn1.flags & 0x0004) == (0))
							{
								applyAffinity(pIn1, (sbyte)(0x43), (byte)(encoding));
								if ((pIn1.flags & 0x0004) == (0))
								{
									if ((pOp->p2) == (0))
									{
										rc = (int)(20);
										goto abort_due_to_error;
									}
									else
									{
										goto jump_to_p2;
									}
								}
							}

						((pIn1).flags = (ushort)(((pIn1).flags & ~(0xc1bf | 0x4000)) | 0x0004));
							break;
						}

					case 86:
						{
							pIn1 = aMem[pOp->p1];
							if ((pIn1.flags & (0x0004 | 0x0020)) != 0)
							{
								sqlite3VdbeMemRealify(pIn1);
							}

							break;
						}

					case 87:
						{
							pIn1 = aMem[pOp->p1];
							rc = (int)(((pIn1).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);
							if ((rc) != 0)
								goto abort_due_to_error;
							rc = (int)(sqlite3VdbeMemCast(pIn1, (byte)(pOp->p2), (byte)(encoding)));
							if ((rc) != 0)
								goto abort_due_to_error;
							break;
						}

					case 53:
					case 52:
					case 56:
					case 55:
					case 54:
					case 57:
						{
							int res = 0;
							int res2 = 0;
							sbyte affinity = 0;
							ushort flags1 = 0;
							ushort flags3 = 0;
							pIn1 = aMem[pOp->p1];
							pIn3 = aMem[pOp->p3];
							flags1 = (ushort)(pIn1.flags);
							flags3 = (ushort)(pIn3.flags);
							if ((flags1 & flags3 & 0x0004) != 0)
							{
								if ((pIn3.u.i) > (pIn1.u.i))
								{
									iCompare = (int)(+1);
									if ((sqlite3aGTb[pOp->opcode]) != 0)
									{
										goto jump_to_p2;
									}
								}
								else if ((pIn3.u.i) < (pIn1.u.i))
								{
									iCompare = (int)(-1);
									if ((sqlite3aLTb[pOp->opcode]) != 0)
									{
										goto jump_to_p2;
									}
								}
								else
								{
									iCompare = (int)(0);
									if ((sqlite3aEQb[pOp->opcode]) != 0)
									{
										goto jump_to_p2;
									}
								}

								break;
							}

							if (((flags1 | flags3) & 0x0001) != 0)
							{
								if ((pOp->p5 & 0x80) != 0)
								{
									if (((flags1 & flags3 & 0x0001) != 0) && ((flags3 & 0x0100) == (0)))
									{
										res = (int)(0);
									}
									else
									{
										res = (int)((flags3 & 0x0001) ? -1 : +1);
									}
								}
								else
								{
									iCompare = (int)(1);
									if ((pOp->p5 & 0x10) != 0)
									{
										goto jump_to_p2;
									}

									break;
								}
							}
							else
							{
								affinity = (sbyte)(pOp->p5 & 0x47);
								if ((affinity) >= (0x43))
								{
									if (((flags1 | flags3) & 0x0002) != 0)
									{
										if ((flags1 & (0x0004 | 0x0020 | 0x0008 | 0x0002)) == (0x0002))
										{
											applyNumericAffinity(pIn1, (int)(0));
											flags3 = (ushort)(pIn3.flags);
										}

										if ((flags3 & (0x0004 | 0x0020 | 0x0008 | 0x0002)) == (0x0002))
										{
											applyNumericAffinity(pIn3, (int)(0));
										}
									}
								}
								else if ((affinity) == (0x42))
								{
									if (((flags1 & 0x0002) == (0)) && ((flags1 & (0x0004 | 0x0008 | 0x0020)) != 0))
									{
										sqlite3VdbeMemStringify(pIn1, (byte)(encoding), (byte)(1));
										flags1 = (ushort)((pIn1.flags & ~0xc1bf) | (flags1 & 0xc1bf));
										if ((pIn1) == (pIn3))
											flags3 = (ushort)(flags1 | 0x0002);
									}

									if (((flags3 & 0x0002) == (0)) && ((flags3 & (0x0004 | 0x0008 | 0x0020)) != 0))
									{
										sqlite3VdbeMemStringify(pIn3, (byte)(encoding), (byte)(1));
										flags3 = (ushort)((pIn3.flags & ~0xc1bf) | (flags3 & 0xc1bf));
									}
								}

								res = (int)(sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl));
							}

							if ((res) < (0))
							{
								res2 = (int)(sqlite3aLTb[pOp->opcode]);
							}
							else if ((res) == (0))
							{
								res2 = (int)(sqlite3aEQb[pOp->opcode]);
							}
							else
							{
								res2 = (int)(sqlite3aGTb[pOp->opcode]);
							}

							iCompare = (int)(res);
							pIn3.flags = (ushort)(flags3);
							pIn1.flags = (ushort)(flags1);
							if ((res2) != 0)
							{
								goto jump_to_p2;
							}

							break;
						}

					case 58:
						{
							if ((iCompare) == (0))
								goto jump_to_p2;
							break;
						}

					case 88:
						{
							break;
						}

					case 89:
						{
							int n = 0;
							int i = 0;
							int p1 = 0;
							int p2 = 0;
							KeyInfo pKeyInfo;
							uint idx = 0;
							CollSeq pColl;
							int bRev = 0;
							uint* aPermute;
							if ((pOp->p5 & 0x01) == (0))
							{
								aPermute = null;
							}
							else
							{
								aPermute = pOp[-1].p4.ai + 1;
							}

							n = (int)(pOp->p3);
							pKeyInfo = pOp->p4.pKeyInfo;
							p1 = (int)(pOp->p1);
							p2 = (int)(pOp->p2);
							for (i = (int)(0); (i) < (n); i++)
							{
								idx = (uint)((aPermute) != 0 ? aPermute[i] : (uint)(i));
								pColl = pKeyInfo.aColl[i];
								bRev = (int)(pKeyInfo.aSortFlags[i] & 0x01);
								iCompare = (int)(sqlite3MemCompare(aMem[p1 + idx], aMem[p2 + idx], pColl));
								if ((iCompare) != 0)
								{
									if (((pKeyInfo.aSortFlags[i] & 0x02) != 0) && (((aMem[p1 + idx].flags & 0x0001) != 0) || ((aMem[p2 + idx].flags & 0x0001) != 0)))
									{
										iCompare = (int)(-iCompare);
									}

									if ((bRev) != 0)
										iCompare = (int)(-iCompare);
									break;
								}
							}

							break;
						}

					case 16:
						{
							if ((iCompare) < (0))
							{
								pOp = &aOp[pOp->p1 - 1];
							}
							else if ((iCompare) == (0))
							{
								pOp = &aOp[pOp->p2 - 1];
							}
							else
							{
								pOp = &aOp[pOp->p3 - 1];
							}

							break;
						}

					case 44:
					case 43:
						{
							int v1 = 0;
							int v2 = 0;
							v1 = (int)(sqlite3VdbeBooleanValue(aMem[pOp->p1], (int)(2)));
							v2 = (int)(sqlite3VdbeBooleanValue(aMem[pOp->p2], (int)(2)));
							if ((pOp->opcode) == (44))
							{
								v1 = (int)(sqlite3VdbeExec_and_logic[v1 * 3 + v2]);
							}
							else
							{
								v1 = (int)(sqlite3VdbeExec_or_logic[v1 * 3 + v2]);
							}

							pOut = aMem[pOp->p3];
							if ((v1) == (2))
							{
								((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0001));
							}
							else
							{
								pOut.u.i = (long)(v1);
								((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0004));
							}

							break;
						}

					case 90:
						{
							sqlite3VdbeMemSetInt64(aMem[pOp->p2], (long)(sqlite3VdbeBooleanValue(aMem[pOp->p1], (int)(pOp->p3)) ^ pOp->p4.i));
							break;
						}

					case 19:
						{
							pIn1 = aMem[pOp->p1];
							pOut = aMem[pOp->p2];
							if ((pIn1.flags & 0x0001) == (0))
							{
								sqlite3VdbeMemSetInt64(pOut, (long)(!sqlite3VdbeBooleanValue(pIn1, (int)(0))));
							}
							else
							{
								sqlite3VdbeMemSetNull(pOut);
							}

							break;
						}

					case 114:
						{
							pIn1 = aMem[pOp->p1];
							pOut = aMem[pOp->p2];
							sqlite3VdbeMemSetNull(pOut);
							if ((pIn1.flags & 0x0001) == (0))
							{
								pOut.flags = (ushort)(0x0004);
								pOut.u.i = (long)(~sqlite3VdbeIntValue(pIn1));
							}

							break;
						}

					case 17:
						{
							uint iAddr = 0;
							if ((p.pFrame) != null)
							{
								iAddr = (uint)((int)(pOp - p.aOp));
								if ((p.pFrame.aOnce[iAddr / 8] & (1 << (iAddr & 7))) != 0)
								{
									goto jump_to_p2;
								}

								p.pFrame.aOnce[iAddr / 8] |= (byte)(1 << (iAddr & 7));
							}
							else
							{
								if ((p.aOp[0].p1) == (pOp->p1))
								{
									goto jump_to_p2;
								}
							}

							pOp->p1 = (int)(p.aOp[0].p1);
							break;
						}

					case 18:
						{
							int c = 0;
							c = (int)(sqlite3VdbeBooleanValue(aMem[pOp->p1], (int)(pOp->p3)));
							if ((c) != 0)
								goto jump_to_p2;
							break;
						}

					case 20:
						{
							int c = 0;
							c = (int)(!sqlite3VdbeBooleanValue(aMem[pOp->p1], (int)(!pOp->p3)));
							if ((c) != 0)
								goto jump_to_p2;
							break;
						}

					case 50:
						{
							pIn1 = aMem[pOp->p1];
							if ((pIn1.flags & 0x0001) != 0)
							{
								goto jump_to_p2;
							}

							break;
						}

					case 21:
						{
							int doTheJump = 0;
							pIn1 = aMem[pOp->p1];
							doTheJump = (int)(((pIn1.flags & 0x0001) != 0) || ((sqlite3_value_type(pIn1)) == (pOp->p3)) ? 1 : 0);
							if ((doTheJump) != 0)
								goto jump_to_p2;
							break;
						}

					case 91:
						{
							if (((aMem[pOp->p1].flags & 0x0001) != 0) || ((aMem[pOp->p3].flags & 0x0001) != 0))
							{
								sqlite3VdbeMemSetNull(aMem[pOp->p2]);
							}
							else
							{
								sqlite3VdbeMemSetInt64(aMem[pOp->p2], (long)(0));
							}

							break;
						}

					case 51:
						{
							pIn1 = aMem[pOp->p1];
							if ((pIn1.flags & 0x0001) == (0))
							{
								goto jump_to_p2;
							}

							break;
						}

					case 22:
						{
							if ((p.apCsr[pOp->p1].nullRow) != 0)
							{
								sqlite3VdbeMemSetNull(aMem[pOp->p3]);
								goto jump_to_p2;
							}

							break;
						}

					case 93:
						{
							uint p2 = 0;
							VdbeCursor pC;
							BtCursor pCrsr;
							uint* aOffset;
							int len = 0;
							int i = 0;
							sqlite3_value pDest;
							sqlite3_value sMem = new sqlite3_value();
							byte* zData;
							byte* zHdr;
							byte* zEndHdr;
							ulong offset64 = 0;
							uint t = 0;
							sqlite3_value pReg;
							pC = p.apCsr[pOp->p1];
							p2 = ((uint)(pOp->p2));
							rc = (int)(sqlite3VdbeCursorMoveto(pC, &p2));
							if ((rc) != 0)
								goto abort_due_to_error;
							pDest = aMem[pOp->p3];
							aOffset = pC.aOffset;
							if (pC.cacheStatus != p.cacheCtr)
							{
								if ((pC.nullRow) != 0)
								{
									if ((pC.eCurType) == (3))
									{
										pReg = aMem[pC.seekResult];
										pC.payloadSize = (uint)(pC.szRow = (uint)(pReg.n));
										pC.aRow = (byte*)(pReg.z);
									}
									else
									{
										sqlite3VdbeMemSetNull(pDest);
										goto op_column_out;
									}
								}
								else
								{
									pCrsr = pC.uc.pCursor;
									pC.payloadSize = (uint)(sqlite3BtreePayloadSize(pCrsr));
									pC.aRow = sqlite3BtreePayloadFetch(pCrsr, &pC.szRow);
									if ((pC.payloadSize) > ((uint)(db.aLimit[0])))
									{
										goto too_big;
									}
								}

								pC.cacheStatus = (uint)(p.cacheCtr);
								pC.iHdrOffset = (uint)((byte)(((*(pC.aRow)) < ((byte)(0x80))) ? ((aOffset[0]) = ((uint)(*(pC.aRow)))), 1 : 
                    sqlite3GetVarint32((pC.aRow), &(aOffset[0])) ) ) ; pC.nHdrParsed = (ushort)(0); if ((pC.szRow) < (aOffset[0])) { pC.aRow = null; pC.szRow = (uint)(0); if (((aOffset[0]) > (98307)) || ((aOffset[0]) > (pC.payloadSize))) { goto op_column_corrupt; } } else { zData = pC.aRow; goto op_column_read_header; }
		} if  ((pC.nHdrParsed ) <= (p2 ) ) { if  ((pC.iHdrOffset ) < (aOffset[0] ) ) { if  ((pC.aRow ) == ( null ) ) { CRuntime.memset(sMem, (int ) ( 0 ) ,  (ulong ) ( sizeof (sqlite3_value ) ) ) ;  rc  =  (int ) (sqlite3VdbeMemFromBtreeZeroOffset (pC.uc.pCursor, (uint ) (aOffset[0] ) ,  sMem ) ) ;  if  (rc != 0 ) goto  abort_due_to_error ;  zData  =  (byte* ) (sMem.z ) ;  } else  { zData  =  pC.aRow ;  }
op_column_read_header:; i = (int)(pC.nHdrParsed); offset64 = (ulong)(aOffset[i]); zHdr = zData + pC.iHdrOffset; zEndHdr = zData + aOffset[0]; do { if ((pC.aType[i] = (uint)(t = (uint)(zHdr[0]))) < (0x80)) { zHdr++; offset64 += (ulong)(sqlite3VdbeOneByteSerialTypeLen((byte)(t))); } else { zHdr += sqlite3GetVarint32(zHdr, &t); pC.aType[i] = (uint)(t); offset64 += (ulong)(sqlite3VdbeSerialTypeLen((uint)(t))); } aOffset[++i] = ((uint)(offset64 & 0xffffffff)); } while ((((uint)(i)) <= (p2)) && ((zHdr) < (zEndHdr))); if ((((zHdr) >= (zEndHdr)) && (((zHdr) > (zEndHdr)) || (offset64 != pC.payloadSize))) || ((offset64) > (pC.payloadSize))) { if ((aOffset[0]) == (0)) { i = (int)(0); zHdr = zEndHdr; } else { if ((pC.aRow) == (null)) sqlite3VdbeMemRelease(sMem); goto op_column_corrupt; } }
pC.nHdrParsed = (ushort)(i); pC.iHdrOffset = ((uint)(zHdr - zData)); if ((pC.aRow) == (null)) sqlite3VdbeMemRelease(sMem);  } else { t = (uint)(0); }
if ((pC.nHdrParsed) <= (p2)) { if ((pOp->p4type) == (-11)) { sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, (int)(0x0800)); } else { sqlite3VdbeMemSetNull(pDest); } goto op_column_out; } } else { t = (uint)(pC.aType[p2]); }
if ((((pDest).flags & (0x2000 | 0x0400)) != 0)) { sqlite3VdbeMemSetNull(pDest); }
if ((pC.szRow) >= (aOffset[p2 + 1])) { zData = pC.aRow + aOffset[p2]; if ((t) < (12)) { sqlite3VdbeSerialGet(zData, (uint)(t), pDest); } else { pDest.n = (int)(len = (int)((t - 12) / 2)); pDest.enc = (byte)(encoding); if ((pDest.szMalloc) < (len + 2)) { pDest.flags = (ushort)(0x0001); if ((sqlite3VdbeMemGrow(pDest, (int)(len + 2), (int)(0))) != 0) goto no_mem; } else { pDest.z = pDest.zMalloc; } CRuntime.memcpy(pDest.z, zData, (ulong)(len)); pDest.z[len] = (sbyte)(0); pDest.z[len + 1] = (sbyte)(0); pDest.flags = (ushort)(sqlite3VdbeExec_aFlag[t & 1]); } } else { pDest.enc = (byte)(encoding); if ((((pOp->p5 & (0x40 | 0x80)) != 0) && ((((t) >= (12)) && ((t & 1) == (0))) || ((pOp->p5 & 0x80) != 0))) || ((len = (int)(sqlite3VdbeSerialTypeLen((uint)(t)))) == (0))) { sqlite3VdbeSerialGet(sqlite3CtypeMap, (uint)(t), pDest); } else { rc = (int)(sqlite3VdbeMemFromBtree(pC.uc.pCursor, (uint)(aOffset[p2]), (uint)(len), pDest)); if (rc != 0) goto abort_due_to_error; sqlite3VdbeSerialGet((byte*)(pDest.z), (uint)(t), pDest); pDest.flags &= (ushort)(~0x1000); } }
op_column_out:; break; op_column_corrupt:; if ((aOp[0].p3) > (0)) { pOp = &aOp[aOp[0].p3 - 1]; break; } else { rc = (int)(sqlite3CorruptError((int)(90330))); goto abort_due_to_error; } } case  94 :  { Table pTab; Column* aCol; int i = 0; pTab = pOp->p4.pTab; aCol = pTab.aCol; pIn1 = aMem[pOp->p1]; for (i = (int)(0); (i) < (pTab.nCol); i++) { if ((aCol[i].colFlags & 0x0060) != 0) { if ((aCol[i].colFlags & 0x0020) != 0) continue; if ((pOp->p3) != 0) { pIn1++; continue; } } applyAffinity(pIn1, (sbyte)(aCol[i].affinity), (byte)(encoding)); if ((pIn1.flags & 0x0001) == (0)) { switch (aCol[i].eCType) { case 2: { if ((pIn1.flags & 0x0010) == (0)) goto vdbe_type_error; break; } case 4: case 3: { if ((pIn1.flags & 0x0004) == (0)) goto vdbe_type_error; break; } case 6: { if ((pIn1.flags & 0x0002) == (0)) goto vdbe_type_error; break; } case 5: { if ((pIn1.flags & 0x0004) != 0) { if (((pIn1.u.i) <= (140737488355327L  L ) ) && ((pIn1.u.i) >= (-140737488355328L  L ) ) ) { pIn1.flags |= (ushort)(0x0020); pIn1.flags &= (ushort)(~0x0004); } else { pIn1.u.r = ((double)(pIn1.u.i)); pIn1.flags |= (ushort)(0x0008); pIn1.flags &= (ushort)(~0x0004); } } else if ((pIn1.flags & (0x0008 | 0x0020)) == (0)) { goto vdbe_type_error; }
break;  } default :  { break; } } } pIn1++;  } break; vdbe_type_error:; sqlite3VdbeError(p, "cannot store %s value in %s column %s.%s", vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType - 1], pTab.zName, aCol[i].zCnName); rc = (int)(19 | (12 << 8)); goto abort_due_to_error;  } case  95 :  { sbyte* zAffinity; zAffinity = pOp->p4.z; pIn1 = aMem[pOp->p1]; while ((1) != 0) { applyAffinity(pIn1, (sbyte)(zAffinity[0]), (byte)(encoding)); if (((zAffinity[0]) == (0x45)) && ((pIn1.flags & 0x0004) != 0)) { if (((pIn1.u.i) <= (140737488355327L  L ) ) && ((pIn1.u.i) >= (-140737488355328L  L ) ) ) { pIn1.flags |= (ushort)(0x0020); pIn1.flags &= (ushort)(~0x0004); } else { pIn1.u.r = ((double)(pIn1.u.i)); pIn1.flags |= (ushort)(0x0008); pIn1.flags &= (ushort)(~0x0004); } } zAffinity++; if ((zAffinity[0]) == (0)) break; pIn1++; } break; } case  96 :  { sqlite3_value pRec; ulong nData = 0; int nHdr = 0; long nByte = 0; long nZero = 0; int nVarint = 0; uint serial_type = 0; sqlite3_value pData0; sqlite3_value pLast; int nField = 0; sbyte* zAffinity; int file_format = 0; uint len = 0; byte* zHdr; byte* zPayload; nData = (ulong)(0); nHdr = (int)(0); nZero = (long)(0); nField = (int)(pOp->p1); zAffinity = pOp->p4.z; pData0 = aMem[nField]; nField = (int)(pOp->p2); pLast = pData0[nField - 1]; file_format = (int)(p.minWriteFileFormat); pOut = aMem[pOp->p3]; if ((zAffinity) != null) { pRec = pData0; do { applyAffinity(pRec, (sbyte)(zAffinity[0]), (byte)(encoding)); if (((zAffinity[0]) == (0x45)) && ((pRec.flags & 0x0004) != 0)) { pRec.flags |= (ushort)(0x0020); pRec.flags &= (ushort)(~(0x0004)); } zAffinity++; pRec++; } while ((zAffinity[0]) != 0); } pRec = pLast; do { if ((pRec.flags & 0x0001) != 0) { if ((pRec.flags & 0x4000) != 0) { pRec.uTemp = (uint)(10); } else { pRec.uTemp = (uint)(0); } nHdr++; } else if ((pRec.flags & (0x0004 | 0x0020)) != 0) { long i = (long)(pRec.u.i); ulong uu = 0; if ((i) < (0)) { uu = (ulong)(~i); } else { uu = (ulong)(i); } nHdr++; if ((uu) <= (127)) { if (((i & 1) == (i)) && ((file_format) >= (4))) { pRec.uTemp = (uint)(8 + (uint)(uu)); } else { nData++; pRec.uTemp = (uint)(1); } } else if ((uu) <= (32767)) { nData += (ulong)(2); pRec.uTemp = (uint)(2); } else if ((uu) <= (8388607)) { nData += (ulong)(3); pRec.uTemp = (uint)(3); } else if ((uu) <= (2147483647)) { nData += (ulong)(4); pRec.uTemp = (uint)(4); } else if ((uu) <= (140737488355327L  L ) ) { nData += (ulong)(6); pRec.uTemp = (uint)(5); } else { nData += (ulong)(8); if ((pRec.flags & 0x0020) != 0) { pRec.u.r = ((double)(pRec.u.i)); pRec.flags &= (ushort)(~0x0020); pRec.flags |= (ushort)(0x0008); pRec.uTemp = (uint)(7); } else { pRec.uTemp = (uint)(6); } } } else if ((pRec.flags & 0x0008) != 0) { nHdr++; nData += (ulong)(8); pRec.uTemp = (uint)(7); } else { len = ((uint)(pRec.n)); serial_type = (uint)((len * 2) + 12 + ((pRec.flags & 0x0002) != 0)); if ((pRec.flags & 0x4000) != 0) { serial_type += (uint)(pRec.u.nZero * 2); if ((nData) != 0) { if ((sqlite3VdbeMemExpandBlob(pRec)) != 0) goto no_mem; len += (uint)(pRec.u.nZero); } else { nZero += (long)(pRec.u.nZero); } } nData += (ulong)(len); nHdr += (int)(sqlite3VarintLen((ulong)(serial_type))); pRec.uTemp = (uint)(serial_type); } if ((pRec) == (pData0)) break; pRec--; } while ((1) != 0); if ((nHdr) <= (126)) { nHdr += (int)(1); } else { nVarint = (int)(sqlite3VarintLen((ulong)(nHdr))); nHdr += (int)(nVarint); if ((nVarint) < (sqlite3VarintLen((ulong)(nHdr)))) nHdr++; } nByte = (long)(nHdr + nData); if ((nByte + nZero) <= (pOut.szMalloc)) { pOut.z = pOut.zMalloc; } else { if ((nByte + nZero) > (db.aLimit[0])) { goto too_big; } if ((sqlite3VdbeMemClearAndResize(pOut, (int)(nByte))) != 0) { goto no_mem; } } pOut.n = ((int)(nByte)); pOut.flags = (ushort)(0x0010); if ((nZero) != 0) { pOut.u.nZero = (int)(nZero); pOut.flags |= (ushort)(0x4000); } zHdr = (byte*)(pOut.z); zPayload = zHdr + nHdr; zHdr += (byte)((((uint)(nHdr)) < ((uint)(0x80))) ? (*(zHdr) = ((byte)(nHdr))) , 1 :  sqlite3PutVarint((zHdr), (ulong)(nHdr)) ) ; pRec = pData0; do { serial_type = (uint)(pRec.uTemp); zHdr += (byte)(((serial_type) < ((uint)(0x80))) ? (*(zHdr) = ((byte)(serial_type))) , 1 :  sqlite3PutVarint((zHdr), (ulong)(serial_type)) ) ; zPayload += sqlite3VdbeSerialPut(zPayload, pRec, (uint)(serial_type)); } while ((++pRec) <= (pLast)); break; } case  97 :  { long nEntry = 0; BtCursor pCrsr; pCrsr = p.apCsr[pOp->p1].uc.pCursor; if ((pOp->p3) != 0) { nEntry = (long)(sqlite3BtreeRowCountEst(pCrsr)); } else { nEntry = (long)(0); rc = (int)(sqlite3BtreeCount(db, pCrsr, &nEntry)); if ((rc) != 0) goto abort_due_to_error; } pOut = out2Prerelease(p, pOp); pOut.u.i = (long)(nEntry); goto check_for_interrupt; } case  0 :  { int p1 = 0; sbyte* zName; int nName = 0; Savepoint* pNew; Savepoint* pSavepoint; Savepoint* pTmp; int iSavepoint = 0; int ii = 0; p1 = (int)(pOp->p1); zName = pOp->p4.z; if ((p1) == (0)) { if ((db.nVdbeWrite) > (0)) { sqlite3VdbeError(p, "cannot open savepoint - SQL statements in progress"); rc = (int)(5); } else { nName = (int)(sqlite3Strlen30(zName)); rc = (int)(sqlite3VtabSavepoint(db, (int)(0), (int)(db.nStatement + db.nSavepoint))); if (rc != 0) goto abort_due_to_error; pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Savepoint) + nName + 1)); if ((pNew) != null) { pNew->zName = (sbyte*)(&pNew[1]); CRuntime.memcpy(pNew->zName, zName, (ulong)(nName + 1)); if ((db.autoCommit) != 0) { db.autoCommit = (byte)(0); db.isTransactionSavepoint = (byte)(1); } else { db.nSavepoint++; } pNew->pNext = db.pSavepoint; db.pSavepoint = pNew; pNew->nDeferredCons = (long)(db.nDeferredCons); pNew->nDeferredImmCons = (long)(db.nDeferredImmCons); } } } else { iSavepoint = (int)(0); for (pSavepoint = db.pSavepoint; ((pSavepoint) != null) && ((sqlite3StrICmp(pSavepoint->zName, zName)) != 0); pSavepoint = pSavepoint->pNext) { iSavepoint++; } if (pSavepoint == null) { sqlite3VdbeError(p, "no such savepoint: %s", zName); rc = (int)(1); } else if (((db.nVdbeWrite) > (0)) && ((p1) == (1))) { sqlite3VdbeError(p, "cannot release savepoint - SQL statements in progress"); rc = (int)(5); } else { int isTransaction = (int)(((pSavepoint->pNext) == (null)) && ((db.isTransactionSavepoint) != 0) ? 1 : 0); if (((isTransaction) != 0) && ((p1) == (1))) { if ((rc = (int)(sqlite3VdbeCheckFk(p, (int)(1)))) != 0) { goto vdbe_return; } db.autoCommit = (byte)(1); if ((sqlite3VdbeHalt(p)) == (5)) { p.pc = ((int)(pOp - aOp)); db.autoCommit = (byte)(0); p.rc = (int)(rc = (int)(5)); goto vdbe_return; } rc = (int)(p.rc); if ((rc) != 0) { db.autoCommit = (byte)(0); } else { db.isTransactionSavepoint = (byte)(0); } } else { int isSchemaChange = 0; iSavepoint = (int)(db.nSavepoint - iSavepoint - 1); if ((p1) == (2)) { isSchemaChange = (int)((db.mDbFlags & 0x0001) != 0); for (ii = (int)(0); (ii) < (db.nDb); ii++) { rc = (int)(sqlite3BtreeTripAllCursors(db.aDb[ii].pBt, (int)(4 | (2 << 8)), ((isSchemaChange) == (0) ? 1 : 0))); if (rc != 0) goto abort_due_to_error; } } else { isSchemaChange = (int)(0); } for (ii = (int)(0); (ii) < (db.nDb); ii++) { rc = (int)(sqlite3BtreeSavepoint(db.aDb[ii].pBt, (int)(p1), (int)(iSavepoint))); if (rc != 0) { goto abort_due_to_error; } } if ((isSchemaChange) != 0) { sqlite3ExpirePreparedStatements(db, (int)(0)); sqlite3ResetAllSchemasOfConnection(db); db.mDbFlags |= (uint)(0x0001); } } if ((rc) != 0) goto abort_due_to_error; while (db.pSavepoint != pSavepoint) { pTmp = db.pSavepoint; db.pSavepoint = pTmp->pNext; sqlite3DbFree(db, pTmp); db.nSavepoint--; } if ((p1) == (1)) { db.pSavepoint = pSavepoint->pNext; sqlite3DbFree(db, pSavepoint); if (isTransaction == 0) { db.nSavepoint--; } } else { db.nDeferredCons = (long)(pSavepoint->nDeferredCons); db.nDeferredImmCons = (long)(pSavepoint->nDeferredImmCons); } if ((isTransaction == 0) || ((p1) == (2))) { rc = (int)(sqlite3VtabSavepoint(db, (int)(p1), (int)(iSavepoint))); if (rc != 0) goto abort_due_to_error; } } } if ((rc) != 0) goto abort_due_to_error; break; } case  1 :  { int desiredAutoCommit = 0; int iRollback = 0; desiredAutoCommit = (int)(pOp->p1); iRollback = (int)(pOp->p2); if (desiredAutoCommit != db.autoCommit) { if ((iRollback) != 0) { sqlite3RollbackAll(db, (int)(4 | (2 << 8))); db.autoCommit = (byte)(1); } else if (((desiredAutoCommit) != 0) && ((db.nVdbeWrite) > (0))) { sqlite3VdbeError(p, "cannot commit transaction - SQL statements in progress"); rc = (int)(5); goto abort_due_to_error; } else if ((rc = (int)(sqlite3VdbeCheckFk(p, (int)(1)))) != 0) { goto vdbe_return; } else { db.autoCommit = ((byte)(desiredAutoCommit)); } if ((sqlite3VdbeHalt(p)) == (5)) { p.pc = ((int)(pOp - aOp)); db.autoCommit = ((byte)(1 - desiredAutoCommit)); p.rc = (int)(rc = (int)(5)); goto vdbe_return; } sqlite3CloseSavepoints(db); if ((p.rc) == (0)) { rc = (int)(101); } else { rc = (int)(1); } goto vdbe_return; } else { sqlite3VdbeError(p, (!desiredAutoCommit) ? "cannot start a transaction within a transaction" : ((iRollback) != 0 ? "cannot rollback - no transaction is active" : "cannot commit - no transaction is active")); rc = (int)(1); goto abort_due_to_error; } } case  2 :  { Btree pBt; int iMeta = (int)(0); if (((pOp->p2) != 0) && ((db.flags & (0x00100000 | ((ulong)(0x00002) << 32))) != 0)) { if ((db.flags & 0x00100000) != 0) { rc = (int)(8); } else { rc = (int)(11); } goto abort_due_to_error; } pBt = db.aDb[pOp->p1].pBt; if ((pBt) != null) { rc = (int)(sqlite3BtreeBeginTrans(pBt, (int)(pOp->p2), &iMeta)); if (rc != 0) { if ((rc & 0xff) == (5)) { p.pc = ((int)(pOp - aOp)); p.rc = (int)(rc); goto vdbe_return; } goto abort_due_to_error; } if ((((p.usesStmtJournal) != 0) && ((pOp->p2) != 0)) && (((db.autoCommit) == (0)) || ((db.nVdbeRead) > (1)))) { if ((p.iStatement) == (0)) { db.nStatement++; p.iStatement = (int)(db.nSavepoint + db.nStatement); } rc = (int)(sqlite3VtabSavepoint(db, (int)(0), (int)(p.iStatement - 1))); if ((rc) == (0)) { rc = (int)(sqlite3BtreeBeginStmt(pBt, (int)(p.iStatement))); } p.nStmtDefCons = (long)(db.nDeferredCons); p.nStmtDefImmCons = (long)(db.nDeferredImmCons); } } if ((((rc) == (0)) && ((pOp->p5) != 0)) && ((iMeta != pOp->p3) || (db.aDb[pOp->p1].pSchema.iGeneration != pOp->p4.i))) { sqlite3DbFree(db, p.zErrMsg); p.zErrMsg = sqlite3DbStrDup(db, "database schema has changed"); if (db.aDb[pOp->p1].pSchema.schema_cookie != iMeta) { sqlite3ResetOneSchema(db, (int)(pOp->p1)); } p.expired = (uint)(1); rc = (int)(17); } if ((rc) != 0) goto abort_due_to_error; break; } case  98 :  { int iMeta = 0; int iDb = 0; int iCookie = 0; iDb = (int)(pOp->p1); iCookie = (int)(pOp->p3); sqlite3BtreeGetMeta(db.aDb[iDb].pBt, (int)(iCookie), (uint*)(&iMeta)); pOut = out2Prerelease(p, pOp); pOut.u.i = (long)(iMeta); break; } case  99 :  { Db pDb; pDb = db.aDb[pOp->p1]; rc = (int)(sqlite3BtreeUpdateMeta(pDb.pBt, (int)(pOp->p2), (uint)(pOp->p3))); if ((pOp->p2) == (1)) { pDb.pSchema.schema_cookie = (int)(pOp->p3 - pOp->p5); db.mDbFlags |= (uint)(0x0001); sqlite3FkClearTriggerCache(db, (int)(pOp->p1)); } else if ((pOp->p2) == (2)) { pDb.pSchema.file_format = (byte)(pOp->p3); } if ((pOp->p1) == (1)) { sqlite3ExpirePreparedStatements(db, (int)(0)); p.expired = (uint)(0); } if ((rc) != 0) goto abort_due_to_error; break; } case  100 :  { int nField = 0; KeyInfo pKeyInfo; uint p2 = 0; int iDb = 0; int wrFlag = 0; Btree pX; VdbeCursor pCur; Db pDb; pCur = p.apCsr[pOp->p1]; if (((pCur) != null) && ((pCur.pgnoRoot) == ((uint)(pOp->p2)))) { sqlite3BtreeClearCursor(pCur.uc.pCursor); goto open_cursor_set_hints; } case  101 :  case  112 :  ; if ((p.expired) == (1)) { rc = (int)(4 | (2 << 8)); goto abort_due_to_error; } nField = (int)(0); pKeyInfo = null; p2 = ((uint)(pOp->p2)); iDb = (int)(pOp->p3); pDb = db.aDb[iDb]; pX = pDb.pBt; if ((pOp->opcode) == (112)) { wrFlag = (int)(0x00000004 | (pOp->p5 & 0x08)); if ((pDb.pSchema.file_format) < (p.minWriteFileFormat)) { p.minWriteFileFormat = (byte)(pDb.pSchema.file_format); } } else { wrFlag = (int)(0); } if ((pOp->p5 & 0x10) != 0) { pIn2 = aMem[p2]; sqlite3VdbeMemIntegerify(pIn2); p2 = (uint)((int)(pIn2.u.i)); } if ((pOp->p4type) == (-9)) { pKeyInfo = pOp->p4.pKeyInfo; nField = (int)(pKeyInfo.nAllField); } else if ((pOp->p4type) == (-3)) { nField = (int)(pOp->p4.i); } pCur = allocateCursor(p, (int)(pOp->p1), (int)(nField), (byte)(0)); if ((pCur) == (null)) goto no_mem; pCur.iDb = (sbyte)(iDb); pCur.nullRow = (byte)(1); pCur.isOrdered = (uint)(1); pCur.pgnoRoot = (uint)(p2); rc = (int)(sqlite3BtreeCursor(pX, (uint)(p2), (int)(wrFlag), pKeyInfo, pCur.uc.pCursor)); pCur.pKeyInfo = pKeyInfo; pCur.isTable = (byte)(pOp->p4type != (-9)); open_cursor_set_hints:; sqlite3BtreeCursorHintFlags(pCur.uc.pCursor, (uint)(pOp->p5 & (0x01 | 0x02))); if ((rc) != 0) goto abort_due_to_error; break; } case  113 :  { VdbeCursor pOrig; VdbeCursor pCx; pOrig = p.apCsr[pOp->p2]; pCx = allocateCursor(p, (int)(pOp->p1), (int)(pOrig.nField), (byte)(0)); if ((pCx) == (null)) goto no_mem; pCx.nullRow = (byte)(1); pCx.isEphemeral = (uint)(1); pCx.pKeyInfo = pOrig.pKeyInfo; pCx.isTable = (byte)(pOrig.isTable); pCx.pgnoRoot = (uint)(pOrig.pgnoRoot); pCx.isOrdered = (uint)(pOrig.isOrdered); pCx.ub.pBtx = pOrig.ub.pBtx; pCx.hasBeenDuped = (uint)(1); pOrig.hasBeenDuped = (uint)(1); rc = (int)(sqlite3BtreeCursor(pCx.ub.pBtx, (uint)(pCx.pgnoRoot), (int)(0x00000004), pCx.pKeyInfo, pCx.uc.pCursor)); break; } case  115 :  case  116 :  { VdbeCursor pCx; KeyInfo pKeyInfo; if ((pOp->p3) > (0)) { aMem[pOp->p3].n = (int)(0); aMem[pOp->p3].z = ""; } pCx = p.apCsr[pOp->p1]; if ((((pCx) != null) && (pCx.hasBeenDuped == 0)) && ((pOp->p2) <= (pCx.nField))) { pCx.seqCount = (long)(0); pCx.cacheStatus = (uint)(0); rc = (int)(sqlite3BtreeClearTable(pCx.ub.pBtx, (int)(pCx.pgnoRoot), null)); } else { pCx = allocateCursor(p, (int)(pOp->p1), (int)(pOp->p2), (byte)(0)); if ((pCx) == (null)) goto no_mem; pCx.isEphemeral = (uint)(1); rc = (int)(sqlite3BtreeOpen(db.pVfs, null, db, pCx.ub.pBtx, (int)(1 | 4 | pOp->p5), (int)(sqlite3VdbeExec_vfsFlags))); if ((rc) == (0)) { rc = (int)(sqlite3BtreeBeginTrans(pCx.ub.pBtx, (int)(1), null)); if ((rc) == (0)) { if ((pCx.pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo) != null) { rc = (int)(sqlite3BtreeCreateTable(pCx.ub.pBtx, &pCx.pgnoRoot, (int)(2 | pOp->p5))); if ((rc) == (0)) { rc = (int)(sqlite3BtreeCursor(pCx.ub.pBtx, (uint)(pCx.pgnoRoot), (int)(0x00000004), pKeyInfo, pCx.uc.pCursor)); } pCx.isTable = (byte)(0); } else { pCx.pgnoRoot = (uint)(1); rc = (int)(sqlite3BtreeCursor(pCx.ub.pBtx, (uint)(1), (int)(0x00000004), null, pCx.uc.pCursor)); pCx.isTable = (byte)(1); } } pCx.isOrdered = (uint)(pOp->p5 != 8); if ((rc) != 0) { sqlite3BtreeClose(pCx.ub.pBtx); } } } if ((rc) != 0) goto abort_due_to_error; pCx.nullRow = (byte)(1); break; } case  118 :  { VdbeCursor pCx; pCx = allocateCursor(p, (int)(pOp->p1), (int)(pOp->p2), (byte)(1)); if ((pCx) == (null)) goto no_mem; pCx.pKeyInfo = pOp->p4.pKeyInfo; rc = (int)(sqlite3VdbeSorterInit(db, (int)(pOp->p3), pCx)); if ((rc) != 0) goto abort_due_to_error; break; } case  119 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; if ((pC.seqCount++) == (0)) { goto jump_to_p2; } break; } case  120 :  { VdbeCursor pCx; pCx = allocateCursor(p, (int)(pOp->p1), (int)(pOp->p3), (byte)(3)); if ((pCx) == (null)) goto no_mem; pCx.nullRow = (byte)(1); pCx.seekResult = (int)(pOp->p2); pCx.isTable = (byte)(1); pCx.uc.pCursor = sqlite3BtreeFakeValidCursor(); break; } case  121 :  { sqlite3VdbeFreeCursor(p, p.apCsr[pOp->p1]); p.apCsr[pOp->p1] = null; break; } case  23 :  case  24 :  case  25 :  case  26 :  { int res = 0; int oc = 0; VdbeCursor pC; UnpackedRecord r = new UnpackedRecord(); int nField = 0; long iKey = 0; int eqOnly = 0; pC = p.apCsr[pOp->p1]; oc = (int)(pOp->opcode); eqOnly = (int)(0); pC.nullRow = (byte)(0); pC.deferredMoveto = (byte)(0); pC.cacheStatus = (uint)(0); if ((pC.isTable) != 0) { ushort flags3 = 0; ushort newType = 0; pIn3 = aMem[pOp->p3]; flags3 = (ushort)(pIn3.flags); if ((flags3 & (0x0004 | 0x0008 | 0x0020 | 0x0002)) == (0x0002)) { applyNumericAffinity(pIn3, (int)(0)); } iKey = (long)(sqlite3VdbeIntValue(pIn3)); newType = (ushort)(pIn3.flags); pIn3.flags = (ushort)(flags3); if ((newType & (0x0004 | 0x0020)) == (0)) { int c = 0; if ((newType & 0x0008) == (0)) { if (((newType & 0x0001) != 0) || ((oc) >= (25))) { goto jump_to_p2; } else { rc = (int)(sqlite3BtreeLast(pC.uc.pCursor, &res)); if (rc != 0) goto abort_due_to_error; goto seek_not_found; } } c = (int)(sqlite3IntFloatCompare((long)(iKey), (double)(pIn3.u.r))); if ((c) > (0)) { if ((oc & 0x0001) == (26 & 0x0001)) oc--; } else if ((c) < (0)) { if ((oc & 0x0001) == (23 & 0x0001)) oc++; } } rc = (int)(sqlite3BtreeTableMoveto(pC.uc.pCursor, (long)((ulong)(iKey)), (int)(0), &res)); pC.movetoTarget = (long)(iKey); if (rc != 0) { goto abort_due_to_error; } } else { if ((sqlite3BtreeCursorHasHint(pC.uc.pCursor, (uint)(0x00000002))) != 0) { eqOnly = (int)(1); } nField = (int)(pOp->p4.i); r.pKeyInfo = pC.pKeyInfo; r.nField = ((ushort)(nField)); r.default_rc = (sbyte)((1 & (oc - 23)) ? -1 : +1); r.aMem = aMem[pOp->p3]; r.eqSeen = (byte)(0); rc = (int)(sqlite3BtreeIndexMoveto(pC.uc.pCursor, r, &res)); if (rc != 0) { goto abort_due_to_error; } if (((eqOnly) != 0) && ((r.eqSeen) == (0))) { goto seek_not_found; } } if ((oc) >= (25)) { if (((res) < (0)) || (((res) == (0)) && ((oc) == (26)))) { res = (int)(0); rc = (int)(sqlite3BtreeNext(pC.uc.pCursor, (int)(0))); if (rc != 0) { if ((rc) == (101)) { rc = (int)(0); res = (int)(1); } else { goto abort_due_to_error; } } } else { res = (int)(0); } } else { if (((res) > (0)) || (((res) == (0)) && ((oc) == (23)))) { res = (int)(0); rc = (int)(sqlite3BtreePrevious(pC.uc.pCursor, (int)(0))); if (rc != 0) { if ((rc) == (101)) { rc = (int)(0); res = (int)(1); } else { goto abort_due_to_error; } } } else { res = (int)(sqlite3BtreeEof(pC.uc.pCursor)); } } seek_not_found:; if ((res) != 0) { goto jump_to_p2; } else if ((eqOnly) != 0) { pOp++; } break; } case  123 :  { VdbeCursor pC; int res = 0; int nStep = 0; UnpackedRecord r = new UnpackedRecord(); pC = p.apCsr[pOp[1].p1]; if (sqlite3BtreeCursorIsValidNN(pC.uc.pCursor) == 0) { break; } nStep = (int)(pOp->p1); r.pKeyInfo = pC.pKeyInfo; r.nField = ((ushort)(pOp[1].p4.i)); r.default_rc = (sbyte)(0); r.aMem = aMem[pOp[1].p3]; res = (int)(0); while ((1) != 0) { rc = (int)(sqlite3VdbeIdxKeyCompare(db, pC, r, &res)); if ((rc) != 0) goto abort_due_to_error; if ((res) > (0)) { seekscan_search_fail:; pOp++; goto jump_to_p2; } if ((res) == (0)) { goto jump_to_p2; break; } if ((nStep) <= (0)) { break; } nStep--; rc = (int)(sqlite3BtreeNext(pC.uc.pCursor, (int)(0))); if ((rc) != 0) { if ((rc) == (101)) { rc = (int)(0); goto seekscan_search_fail; } else { goto abort_due_to_error; } } } break; } case  124 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; if ((pC.seekHit) < (pOp->p2)) { pC.seekHit = (ushort)(pOp->p2); } else if ((pC.seekHit) > (pOp->p3)) { pC.seekHit = (ushort)(pOp->p3); } break; } case  27 :  { if (p.apCsr[pOp->p1] == null) { goto jump_to_p2_and_check_for_interrupt; } break; } case  28 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; if ((pC.seekHit) >= (pOp->p4.i)) break; } case  29 :  case  30 :  case  31 :  { int alreadyExists = 0; int takeJump = 0; int ii = 0; VdbeCursor pC; int res = 0; UnpackedRecord pFree; UnpackedRecord pIdxKey; UnpackedRecord r = new UnpackedRecord(); pC = p.apCsr[pOp->p1]; pIn3 = aMem[pOp->p3]; if ((pOp->p4.i) > (0)) { r.pKeyInfo = pC.pKeyInfo; r.nField = ((ushort)(pOp->p4.i)); r.aMem = pIn3; pIdxKey = r; pFree = null; } else { rc = (int)(((pIn3).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn3) : 0); if ((rc) != 0) goto no_mem; pFree = pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC.pKeyInfo); if ((pIdxKey) == (null)) goto no_mem; sqlite3VdbeRecordUnpack(pC.pKeyInfo, (int)(pIn3.n), pIn3.z, pIdxKey); } pIdxKey.default_rc = (sbyte)(0); takeJump = (int)(0); if ((pOp->opcode) == (29)) { for (ii = (int)(0); (ii) < (pIdxKey.nField); ii++) { if ((pIdxKey.aMem[ii].flags & 0x0001) != 0) { takeJump = (int)(1); break; } } } rc = (int)(sqlite3BtreeIndexMoveto(pC.uc.pCursor, pIdxKey, &res)); if ((pFree) != null) sqlite3DbFreeNN(db, pFree); if (rc != 0) { goto abort_due_to_error; } pC.seekResult = (int)(res); alreadyExists = (int)((res) == (0) ? 1 : 0); pC.nullRow = (byte)(1 - alreadyExists); pC.deferredMoveto = (byte)(0); pC.cacheStatus = (uint)(0); if ((pOp->opcode) == (31)) { if ((alreadyExists) != 0) goto jump_to_p2; } else { if (((takeJump) != 0) || (alreadyExists == 0)) goto jump_to_p2; if ((pOp->opcode) == (28)) pC.seekHit = (ushort)(pOp->p4.i); } break; } case  32 :  { VdbeCursor pC; BtCursor pCrsr; int res = 0; ulong iKey = 0; pIn3 = aMem[pOp->p3]; if ((pIn3.flags & (0x0004 | 0x0020)) == (0)) { sqlite3_value x = (sqlite3_value)(pIn3[0]); applyAffinity(x, (sbyte)(0x43), (byte)(encoding)); if ((x.flags & 0x0004) == (0)) goto jump_to_p2; iKey = (ulong)(x.u.i); goto notExistsWithKey; } case  33 :  pIn3 = aMem[pOp->p3]; iKey = (ulong)(pIn3.u.i); notExistsWithKey:; pC = p.apCsr[pOp->p1]; pCrsr = pC.uc.pCursor; res = (int)(0); rc = (int)(sqlite3BtreeTableMoveto(pCrsr, (long)(iKey), (int)(0), &res)); pC.movetoTarget = (long)(iKey); pC.nullRow = (byte)(0); pC.cacheStatus = (uint)(0); pC.deferredMoveto = (byte)(0); pC.seekResult = (int)(res); if (res != 0) { if ((pOp->p2) == (0)) { rc = (int)(sqlite3CorruptError((int)(92477))); } else { goto jump_to_p2; } } if ((rc) != 0) goto abort_due_to_error; break; } case  125 :  { pOut = out2Prerelease(p, pOp); pOut.u.i = (long)(p.apCsr[pOp->p1].seqCount++); break; } case  126 :  { long v = 0; VdbeCursor pC; int res = 0; int cnt = 0; sqlite3_value pMem; VdbeFrame pFrame; v = (long)(0); res = (int)(0); pOut = out2Prerelease(p, pOp); pC = p.apCsr[pOp->p1]; { if (pC.useRandomRowid == 0) { rc = (int)(sqlite3BtreeLast(pC.uc.pCursor, &res)); if (rc != 0) { goto abort_due_to_error; } if ((res) != 0) { v = (long)(1); } else { v = (long)(sqlite3BtreeIntegerKey(pC.uc.pCursor)); if ((v) >= ((long)((((ulong)(0x7fffffff)) << 32) | (ulong)(0xffffffff)))) { pC.useRandomRowid = (uint)(1); } else { v++; } } } if ((pOp->p3) != 0) { if ((p.pFrame) != null) { for (pFrame = p.pFrame; pFrame.pParent; pFrame = pFrame.pParent) { } pMem = pFrame.aMem[pOp->p3]; } else { pMem = aMem[pOp->p3]; } sqlite3VdbeMemIntegerify(pMem); if (((pMem.u.i) == ((long)((((ulong)(0x7fffffff)) << 32) | (ulong)(0xffffffff)))) || ((pC.useRandomRowid) != 0)) { rc = (int)(13); goto abort_due_to_error; } if ((v) < (pMem.u.i + 1)) { v = (long)(pMem.u.i + 1); } pMem.u.i = (long)(v); } if ((pC.useRandomRowid) != 0) { cnt = (int)(0); do { sqlite3_randomness((int)(sizeof(long)), &v); v &= (long)((long)((((ulong)(0x7fffffff)) << 32) | (ulong)(0xffffffff)) > > 1); v++; } while ((((rc = (int)(sqlite3BtreeTableMoveto(pC.uc.pCursor, (long)((ulong)(v)), (int)(0), &res))) == (0)) && ((res) == (0))) && ((++cnt) < (100))); if ((rc) != 0) goto abort_due_to_error; if ((res) == (0)) { rc = (int)(13); goto abort_due_to_error; } } pC.deferredMoveto = (byte)(0); pC.cacheStatus = (uint)(0); } pOut.u.i = (long)(v); break; } case  127 :  { sqlite3_value pData; sqlite3_value pKey; VdbeCursor pC; int seekResult = 0; sbyte* zDb; Table pTab; BtreePayload x = new BtreePayload(); pData = aMem[pOp->p2]; pC = p.apCsr[pOp->p1]; pKey = aMem[pOp->p3]; x.nKey = (long)(pKey.u.i); if (((pOp->p4type) == (-6)) && (((db).xUpdateCallback) != null)) { zDb = db.aDb[pC.iDb].zDbSName; pTab = pOp->p4.pTab; } else { pTab = null; zDb = null; } if ((pOp->p5 & 0x01) != 0) p.nChange++; if ((pOp->p5 & 0x20) != 0) db.lastRowid = (long)(x.nKey); x.pData = pData.z; x.nData = (int)(pData.n); seekResult = (int)((pOp->p5 & 0x10) ? pC.seekResult : 0); if ((pData.flags & 0x4000) != 0) { x.nZero = (int)(pData.u.nZero); } else { x.nZero = (int)(0); } x.pKey = null; rc = (int)(sqlite3BtreeInsert(pC.uc.pCursor, x, (int)(pOp->p5 & (0x08 | 0x02 | 0x80)), (int)(seekResult))); pC.deferredMoveto = (byte)(0); pC.cacheStatus = (uint)(0); if ((rc) != 0) goto abort_due_to_error; if ((pTab) != null) { db.xUpdateCallback(db.pUpdateArg, (int)((pOp->p5 & 0x04) ? 23 : 18), zDb, pTab.zName, (long)(x.nKey)); } break; } case  128 :  { VdbeCursor pDest; VdbeCursor pSrc; long iKey = 0; pDest = p.apCsr[pOp->p1]; pSrc = p.apCsr[pOp->p2]; iKey = (long)((pOp->p3) != 0 ? aMem[pOp->p3].u.i : 0); rc = (int)(sqlite3BtreeTransferRow(pDest.uc.pCursor, pSrc.uc.pCursor, (long)(iKey))); if (rc != 0) goto abort_due_to_error; break; } case  129 :  { VdbeCursor pC; sbyte* zDb; Table pTab; int opflags = 0; opflags = (int)(pOp->p2); pC = p.apCsr[pOp->p1]; if (((pOp->p4type) == (-6)) && (((db).xUpdateCallback) != null)) { zDb = db.aDb[pC.iDb].zDbSName; pTab = pOp->p4.pTab; if (((pOp->p5 & 0x02) != 0) && ((pC.isTable) != 0)) { pC.movetoTarget = (long)(sqlite3BtreeIntegerKey(pC.uc.pCursor)); } } else { zDb = null; pTab = null; } rc = (int)(sqlite3BtreeDelete(pC.uc.pCursor, (byte)(pOp->p5))); pC.cacheStatus = (uint)(0); pC.seekResult = (int)(0); if ((rc) != 0) goto abort_due_to_error; if ((opflags & 0x01) != 0) { p.nChange++; if ((((db.xUpdateCallback) != null) && (pTab != null)) && (((pTab).tabFlags & 0x00000080) == (0))) { db.xUpdateCallback(db.pUpdateArg, (int)(9), zDb, pTab.zName, (long)(pC.movetoTarget)); } } break; } case  130 :  { sqlite3VdbeSetChanges(db, (long)(p.nChange)); p.nChange = (long)(0); break; } case  131 :  { VdbeCursor pC; int res = 0; int nKeyCol = 0; pC = p.apCsr[pOp->p1]; pIn3 = aMem[pOp->p3]; nKeyCol = (int)(pOp->p4.i); res = (int)(0); rc = (int)(sqlite3VdbeSorterCompare(pC, pIn3, (int)(nKeyCol), &res)); if ((rc) != 0) goto abort_due_to_error; if ((res) != 0) goto jump_to_p2; break; } case  132 :  { VdbeCursor pC; pOut = aMem[pOp->p2]; pC = p.apCsr[pOp->p1]; rc = (int)(sqlite3VdbeSorterRowkey(pC, pOut)); if ((rc) != 0) goto abort_due_to_error; p.apCsr[pOp->p3].cacheStatus = (uint)(0); break; } case  133 :  { VdbeCursor pC; BtCursor pCrsr; uint n = 0; pOut = out2Prerelease(p, pOp); pC = p.apCsr[pOp->p1]; pCrsr = pC.uc.pCursor; n = (uint)(sqlite3BtreePayloadSize(pCrsr)); if ((n) > ((uint)(db.aLimit[0]))) { goto too_big; } rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, (uint)(n), pOut)); if ((rc) != 0) goto abort_due_to_error; if (pOp->p3 == 0) if ((((pOut).flags & 0x1000) != 0) && ((sqlite3VdbeMemMakeWriteable(pOut)) != 0)) { goto no_mem; } break; } case  134 :  { VdbeCursor pC; long v = 0; sqlite3_vtab pVtab; sqlite3_module pModule; pOut = out2Prerelease(p, pOp); pC = p.apCsr[pOp->p1]; if ((pC.nullRow) != 0) { pOut.flags = (ushort)(0x0001); break; } else if ((pC.deferredMoveto) != 0) { v = (long)(pC.movetoTarget); } else if ((pC.eCurType) == (2)) { pVtab = pC.uc.pVCur.pVtab; pModule = pVtab.pModule; rc = (int)(pModule.xRowid(pC.uc.pVCur, &v)); sqlite3VtabImportErrmsg(p, pVtab); if ((rc) != 0) goto abort_due_to_error; } else { rc = (int)(sqlite3VdbeCursorRestore(pC)); if ((rc) != 0) goto abort_due_to_error; if ((pC.nullRow) != 0) { pOut.flags = (ushort)(0x0001); break; } v = (long)(sqlite3BtreeIntegerKey(pC.uc.pCursor)); } pOut.u.i = (long)(v); break; } case  135 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; pC.nullRow = (byte)(1); pC.cacheStatus = (uint)(0); if ((pC.eCurType) == (0)) { sqlite3BtreeClearCursor(pC.uc.pCursor); } break; } case  136 :  case  34 :  { VdbeCursor pC; BtCursor pCrsr; int res = 0; pC = p.apCsr[pOp->p1]; pCrsr = pC.uc.pCursor; res = (int)(0); if ((pOp->opcode) == (136)) { pC.seekResult = (int)(-1); if ((sqlite3BtreeCursorIsValidNN(pCrsr)) != 0) { break; } } rc = (int)(sqlite3BtreeLast(pCrsr, &res)); pC.nullRow = ((byte)(res)); pC.deferredMoveto = (byte)(0); pC.cacheStatus = (uint)(0); if ((rc) != 0) goto abort_due_to_error; if ((pOp->p2) > (0)) { if ((res) != 0) goto jump_to_p2; } break; } case  35 :  { VdbeCursor pC; BtCursor pCrsr; int res = 0; long sz = 0; pC = p.apCsr[pOp->p1]; pCrsr = pC.uc.pCursor; rc = (int)(sqlite3BtreeFirst(pCrsr, &res)); if ((rc) != 0) goto abort_due_to_error; if ((res) == (0)) { sz = (long)(sqlite3BtreeRowCountEst(pCrsr)); if (((sz) >= (0)) && ((sqlite3LogEst((ulong)(sz))) < (pOp->p3))) res = (int)(1); } if ((res) != 0) goto jump_to_p2; break; } case  36 :  case  37 :  { p.aCounter[2]++; } case  38 :  { VdbeCursor pC; BtCursor pCrsr; int res = 0; pC = p.apCsr[pOp->p1]; res = (int)(1); if ((((pC).eCurType) == (1))) { rc = (int)(sqlite3VdbeSorterRewind(pC, &res)); } else { pCrsr = pC.uc.pCursor; rc = (int)(sqlite3BtreeFirst(pCrsr, &res)); pC.deferredMoveto = (byte)(0); pC.cacheStatus = (uint)(0); } if ((rc) != 0) goto abort_due_to_error; pC.nullRow = ((byte)(res)); if ((res) != 0) goto jump_to_p2; break; } case  3 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; rc = (int)(sqlite3VdbeSorterNext(db, pC)); goto next_tail;  case  4 :  case  5 :  ; pC = p.apCsr[pOp->p1]; rc = (int)(pOp->p4.xAdvance(pC.uc.pCursor, (int)(pOp->p3))); next_tail:; pC.cacheStatus = (uint)(0); if ((rc) == (0)) { pC.nullRow = (byte)(0); p.aCounter[pOp->p5]++; goto jump_to_p2_and_check_for_interrupt; } if (rc != 101) goto abort_due_to_error; rc = (int)(0); pC.nullRow = (byte)(1); goto check_for_interrupt; } case  137 :  { VdbeCursor pC; BtreePayload x = new BtreePayload(); pC = p.apCsr[pOp->p1]; pIn2 = aMem[pOp->p2]; if ((pOp->p5 & 0x01) != 0) p.nChange++; rc = (int)(((pIn2).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0); if ((rc) != 0) goto abort_due_to_error; x.nKey = (long)(pIn2.n); x.pKey = pIn2.z; x.aMem = aMem[pOp->p3]; x.nMem = ((ushort)(pOp->p4.i)); rc = (int)(sqlite3BtreeInsert(pC.uc.pCursor, x, (int)(pOp->p5 & (0x08 | 0x02 | 0x80)), (int)((pOp->p5 & 0x10) ? pC.seekResult : 0))); pC.cacheStatus = (uint)(0); if ((rc) != 0) goto abort_due_to_error; break; } case  138 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; pIn2 = aMem[pOp->p2]; rc = (int)(((pIn2).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pIn2) : 0); if ((rc) != 0) goto abort_due_to_error; rc = (int)(sqlite3VdbeSorterWrite(pC, pIn2)); if ((rc) != 0) goto abort_due_to_error; break; } case  139 :  { VdbeCursor pC; BtCursor pCrsr; int res = 0; UnpackedRecord r = new UnpackedRecord(); pC = p.apCsr[pOp->p1]; pCrsr = pC.uc.pCursor; r.pKeyInfo = pC.pKeyInfo; r.nField = ((ushort)(pOp->p3)); r.default_rc = (sbyte)(0); r.aMem = aMem[pOp->p2]; rc = (int)(sqlite3BtreeIndexMoveto(pCrsr, r, &res)); if ((rc) != 0) goto abort_due_to_error; if ((res) == (0)) { rc = (int)(sqlite3BtreeDelete(pCrsr, (byte)(0x04))); if ((rc) != 0) goto abort_due_to_error; } else if (((pOp->p5) != 0) && (sqlite3WritableSchema(db) == 0)) { rc = (int)(sqlite3ReportError((int)(11 | (3 << 8)), (int)(93533), "index corruption")); goto abort_due_to_error; } pC.cacheStatus = (uint)(0); pC.seekResult = (int)(0); break; } case  140 :  case  141 :  { VdbeCursor pC; VdbeCursor pTabCur; long rowid = 0; pC = p.apCsr[pOp->p1]; rc = (int)(sqlite3VdbeCursorRestore(pC)); if ((rc != 0)) goto abort_due_to_error; if (pC.nullRow == 0) { rowid = (long)(0); rc = (int)(sqlite3VdbeIdxRowid(db, pC.uc.pCursor, &rowid)); if (rc != 0) { goto abort_due_to_error; } if ((pOp->opcode) == (140)) { pTabCur = p.apCsr[pOp->p3]; pTabCur.nullRow = (byte)(0); pTabCur.movetoTarget = (long)(rowid); pTabCur.deferredMoveto = (byte)(1); pTabCur.ub.aAltMap = pOp->p4.ai; pTabCur.pAltCursor = pC; } else { pOut = out2Prerelease(p, pOp); pOut.u.i = (long)(rowid); } } else { sqlite3VdbeMemSetNull(aMem[pOp->p2]); } break; } case  142 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; if ((pC.deferredMoveto) != 0) { rc = (int)(sqlite3VdbeFinishMoveto(pC)); if ((rc) != 0) goto abort_due_to_error; } break; } case  39 :  case  40 :  case  41 :  case  42 :  { VdbeCursor pC; int res = 0; UnpackedRecord r = new UnpackedRecord(); pC = p.apCsr[pOp->p1]; r.pKeyInfo = pC.pKeyInfo; r.nField = ((ushort)(pOp->p4.i)); if ((pOp->opcode) < (41)) { r.default_rc = (sbyte)(-1); } else { r.default_rc = (sbyte)(0); } r.aMem = aMem[pOp->p3]; { long nCellKey = (long)(0); BtCursor pCur; sqlite3_value m = new sqlite3_value(); pCur = pC.uc.pCursor; nCellKey = (long)(sqlite3BtreePayloadSize(pCur)); if (((nCellKey) <= (0)) || ((nCellKey) > (0x7fffffff))) { rc = (int)(sqlite3CorruptError((int)(93737))); goto abort_due_to_error; } sqlite3VdbeMemInit(m, db, (ushort)(0)); rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m)); if ((rc) != 0) goto abort_due_to_error; res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(m.n), m.z, r, (int)(0))); sqlite3VdbeMemRelease(m); } if ((pOp->opcode & 1) == (41 & 1)) { res = (int)(-res); } else { res++; } if ((res) > (0)) goto jump_to_p2; break; } case  143 :  { int iMoved = 0; int iDb = 0; pOut = out2Prerelease(p, pOp); pOut.flags = (ushort)(0x0001); if ((db.nVdbeRead) > (db.nVDestroy + 1)) { rc = (int)(6); p.errorAction = (byte)(2); goto abort_due_to_error; } else { iDb = (int)(pOp->p3); iMoved = (int)(0); rc = (int)(sqlite3BtreeDropTable(db.aDb[iDb].pBt, (int)(pOp->p1), &iMoved)); pOut.flags = (ushort)(0x0004); pOut.u.i = (long)(iMoved); if ((rc) != 0) goto abort_due_to_error; if (iMoved != 0) { sqlite3RootPageMoved(db, (int)(iDb), (uint)(iMoved), (uint)(pOp->p1)); resetSchemaOnFault = (byte)(iDb + 1); } } break; } case  144 :  { long nChange = 0; nChange = (long)(0); rc = (int)(sqlite3BtreeClearTable(db.aDb[pOp->p2].pBt, (int)((uint)(pOp->p1)), &nChange)); if ((pOp->p3) != 0) { p.nChange += (long)(nChange); if ((pOp->p3) > (0)) { aMem[pOp->p3].u.i += (long)(nChange); } } if ((rc) != 0) goto abort_due_to_error; break; } case  145 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; if ((((pC).eCurType) == (1))) { sqlite3VdbeSorterReset(db, pC.uc.pSorter); } else { rc = (int)(sqlite3BtreeClearTableOfCursor(pC.uc.pCursor)); if ((rc) != 0) goto abort_due_to_error; } break; } case  146 :  { uint pgno = 0; Db pDb; pOut = out2Prerelease(p, pOp); pgno = (uint)(0); pDb = db.aDb[pOp->p1]; rc = (int)(sqlite3BtreeCreateTable(pDb.pBt, &pgno, (int)(pOp->p3))); if ((rc) != 0) goto abort_due_to_error; pOut.u.i = (long)(pgno); break; } case  147 :  { db.nSqlExec++; rc = (int)(sqlite3_exec(db, pOp->p4.z, null, null, null)); db.nSqlExec--; if ((rc) != 0) goto abort_due_to_error; break; } case  148 :  { int iDb = 0; sbyte* zSchema; sbyte* zSql; InitData initData = new InitData(); iDb = (int)(pOp->p1); if ((pOp->p4.z) == (null)) { sqlite3SchemaClear(db.aDb[iDb].pSchema); db.mDbFlags &= (uint)(~0x0010); rc = (int)(sqlite3InitOne(db, (int)(iDb), &p.zErrMsg, (uint)(pOp->p5))); db.mDbFlags |= (uint)(0x0001); p.expired = (uint)(0); } else { zSchema = "sqlite_master"; initData.db = db; initData.iDb = (int)(iDb); initData.pzErrMsg = &p.zErrMsg; initData.mInitFlags = (uint)(0); initData.mxPage = (uint)(sqlite3BtreeLastPage(db.aDb[iDb].pBt)); zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid", db.aDb[iDb].zDbSName, zSchema, pOp->p4.z); if ((zSql) == (null)) { rc = (int)(7); } else { db.init.busy = (byte)(1); initData.rc = (int)(0); initData.nInitRow = (uint)(0); rc = (int)(sqlite3_exec(db, zSql, sqlite3InitCallback, initData, null)); if ((rc) == (0)) rc = (int)(initData.rc); if (((rc) == (0)) && ((initData.nInitRow) == (0))) { rc = (int)(sqlite3CorruptError((int)(93989))); } sqlite3DbFreeNN(db, zSql); db.init.busy = (byte)(0); } } if ((rc) != 0) { sqlite3ResetAllSchemasOfConnection(db); if ((rc) == (7)) { goto no_mem; } goto abort_due_to_error; } break; } case  149 :  { rc = (int)(sqlite3AnalysisLoad(db, (int)(pOp->p1))); if ((rc) != 0) goto abort_due_to_error; break; } case  150 :  { sqlite3UnlinkAndDeleteTable(db, (int)(pOp->p1), pOp->p4.z); break; } case  151 :  { sqlite3UnlinkAndDeleteIndex(db, (int)(pOp->p1), pOp->p4.z); break; } case  152 :  { sqlite3UnlinkAndDeleteTrigger(db, (int)(pOp->p1), pOp->p4.z); break; } case  154 :  { int nRoot = 0; uint* aRoot; int nErr = 0; sbyte* z; sqlite3_value pnErr; nRoot = (int)(pOp->p2); aRoot = pOp->p4.ai; pnErr = aMem[pOp->p3]; pIn1 = aMem[pOp->p1]; z = sqlite3BtreeIntegrityCheck(db, db.aDb[pOp->p5].pBt, &aRoot[1], (int)(nRoot), (int)((int)(pnErr.u.i) + 1), &nErr); sqlite3VdbeMemSetNull(pIn1); if ((nErr) == (0)) { } else if ((z) == (null)) { goto no_mem; } else { pnErr.u.i -= (long)(nErr - 1); sqlite3VdbeMemSetStr(pIn1, z, (long)(-1), (byte)(1), sqlite3_free); } sqlite3VdbeChangeEncoding(pIn1, (int)(encoding)); goto check_for_interrupt; } case  155 :  { pIn1 = aMem[pOp->p1]; pIn2 = aMem[pOp->p2]; if ((pIn1.flags & 0x0010) == (0)) { if ((sqlite3VdbeMemSetRowSet(pIn1)) != 0) goto no_mem; } sqlite3RowSetInsert((RowSet)(pIn1.z), (long)(pIn2.u.i)); break; } case  45 :  { long val = 0; pIn1 = aMem[pOp->p1]; if (((pIn1.flags & 0x0010) == (0)) || ((sqlite3RowSetNext((RowSet)(pIn1.z), &val)) == (0))) { sqlite3VdbeMemSetNull(pIn1); goto jump_to_p2_and_check_for_interrupt; } else { sqlite3VdbeMemSetInt64(aMem[pOp->p3], (long)(val)); } goto check_for_interrupt; } case  46 :  { int iSet = 0; int exists = 0; pIn1 = aMem[pOp->p1]; pIn3 = aMem[pOp->p3]; iSet = (int)(pOp->p4.i); if ((pIn1.flags & 0x0010) == (0)) { if ((sqlite3VdbeMemSetRowSet(pIn1)) != 0) goto no_mem; } if ((iSet) != 0) { exists = (int)(sqlite3RowSetTest((RowSet)(pIn1.z), (int)(iSet), (long)(pIn3.u.i))); if ((exists) != 0) goto jump_to_p2; } if ((iSet) >= (0)) { sqlite3RowSetInsert((RowSet)(pIn1.z), (long)(pIn3.u.i)); } break; } case  47 :  { int nMem = 0; int nByte = 0; sqlite3_value pRt; sqlite3_value pMem; sqlite3_value pEnd; VdbeFrame pFrame; SubProgram* pProgram; void* t; pProgram = pOp->p4.pProgram; pRt = aMem[pOp->p3]; if ((pOp->p5) != 0) { t = pProgram->token; for (pFrame = p.pFrame; ((pFrame) != null) && (pFrame.token != t); pFrame = pFrame.pParent) { } if ((pFrame) != null) break; } if ((p.nFrame) >= (db.aLimit[10])) { rc = (int)(1); sqlite3VdbeError(p, "too many levels of trigger recursion"); goto abort_due_to_error; } if ((pRt.flags & 0x0010) == (0)) { nMem = (int)(pProgram->nMem + pProgram->nCsr); if ((pProgram->nCsr) == (0)) nMem++; nByte = (int)((((sizeof(VdbeFrame)) + 7) & ~7) + nMem * sizeof(sqlite3_value) + pProgram->nCsr * sizeof(VdbeCursor) + (pProgram->nOp + 7) / 8); pFrame = sqlite3DbMallocZero(db, (ulong)(nByte)); if (pFrame == null) { goto no_mem; } sqlite3VdbeMemRelease(pRt); pRt.flags = (ushort)(0x0010 | 0x0400); pRt.z = (sbyte*)(pFrame); pRt.n = (int)(nByte); pRt.xDel = sqlite3VdbeFrameMemDel; pFrame.v = p; pFrame.nChildMem = (int)(nMem); pFrame.nChildCsr = (int)(pProgram->nCsr); pFrame.pc = ((int)(pOp - aOp)); pFrame.aMem = p.aMem; pFrame.nMem = (int)(p.nMem); pFrame.apCsr = p.apCsr; pFrame.nCursor = (int)(p.nCursor); pFrame.aOp = p.aOp; pFrame.nOp = (int)(p.nOp); pFrame.token = pProgram->token; pEnd = ((sqlite3_value)(&((byte*)(pFrame))[(((sizeof(VdbeFrame)) + 7) & ~7)]))[pFrame.nChildMem]; for (pMem = ((sqlite3_value)(&((byte*)(pFrame))[(((sizeof(VdbeFrame)) + 7) & ~7)])); pMem != pEnd; pMem++) { pMem.flags = (ushort)(0x0080); pMem.db = db; } } else { pFrame = (VdbeFrame)(pRt.z); } p.nFrame++; pFrame.pParent = p.pFrame; pFrame.lastRowid = (long)(db.lastRowid); pFrame.nChange = (long)(p.nChange); pFrame.nDbChange = (long)(p.db.nChange); pFrame.pAuxData = p.pAuxData; p.pAuxData = null; p.nChange = (long)(0); p.pFrame = pFrame; p.aMem = aMem = ((sqlite3_value)(&((byte*)(pFrame))[(((sizeof(VdbeFrame)) + 7) & ~7)])); p.nMem = (int)(pFrame.nChildMem); p.nCursor = (int)((ushort)(pFrame.nChildCsr)); p.apCsr = (VdbeCursor)(aMem[p.nMem]); pFrame.aOnce = (byte*)(p.apCsr[pProgram->nCsr]); CRuntime.memset(pFrame.aOnce, (int)(0), (ulong)((pProgram->nOp + 7) / 8)); p.aOp = aOp = pProgram->aOp; p.nOp = (int)(pProgram->nOp); pOp = &aOp[-1]; goto check_for_interrupt; } case  156 :  { VdbeFrame pFrame; sqlite3_value pIn; pOut = out2Prerelease(p, pOp); pFrame = p.pFrame; pIn = pFrame.aMem[pOp->p1 + pFrame.aOp[pFrame.pc].p1]; sqlite3VdbeMemShallowCopy(pOut, pIn, (int)(0x1000)); break; } case  157 :  { if ((db.flags & 0x00080000) != 0) { db.nDeferredImmCons += (long)(pOp->p2); } else if ((pOp->p1) != 0) { db.nDeferredCons += (long)(pOp->p2); } else { p.nFkConstraint += (long)(pOp->p2); } break; } case  48 :  { if ((pOp->p1) != 0) { if (((db.nDeferredCons) == (0)) && ((db.nDeferredImmCons) == (0))) goto jump_to_p2; } else { if (((p.nFkConstraint) == (0)) && ((db.nDeferredImmCons) == (0))) goto jump_to_p2; } break; } case  158 :  { VdbeFrame pFrame; if ((p.pFrame) != null) { for (pFrame = p.pFrame; pFrame.pParent; pFrame = pFrame.pParent) { } pIn1 = pFrame.aMem[pOp->p1]; } else { pIn1 = aMem[pOp->p1]; } sqlite3VdbeMemIntegerify(pIn1); pIn2 = aMem[pOp->p2]; sqlite3VdbeMemIntegerify(pIn2); if ((pIn1.u.i) < (pIn2.u.i)) { pIn1.u.i = (long)(pIn2.u.i); } break; } case  49 :  { pIn1 = aMem[pOp->p1]; if ((pIn1.u.i) > (0)) { pIn1.u.i -= (long)(pOp->p3); goto jump_to_p2; } break; } case  159 :  { long x = 0; pIn1 = aMem[pOp->p1]; pIn3 = aMem[pOp->p3]; pOut = out2Prerelease(p, pOp); x = (long)(pIn1.u.i); if (((x) <= (0)) || ((sqlite3AddInt64(&x, (long)((pIn3.u.i) > (0) ? pIn3.u.i : 0))) != 0)) { pOut.u.i = (long)(-1); } else { pOut.u.i = (long)(x); } break; } case  59 :  { pIn1 = aMem[pOp->p1]; if ((pIn1.u.i) != 0) { if ((pIn1.u.i) > (0)) pIn1.u.i--; goto jump_to_p2; } break; } case  60 :  { pIn1 = aMem[pOp->p1]; if ((pIn1.u.i) > (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32)))) pIn1.u.i--; if ((pIn1.u.i) == (0)) goto jump_to_p2; break; } case  160 :  case  161 :  { int n = 0; sqlite3_context pCtx; n = (int)(pOp->p5); pCtx = sqlite3DbMallocRawNN(db, (ulong)(n * sizeof(sqlite3_value) + (sizeof(sqlite3_context) + sizeof(sqlite3_value) - sizeof(sqlite3_value)))); if ((pCtx) == (null)) goto no_mem; pCtx.pMem = null; pCtx.pOut = (pCtx.argv[n]); sqlite3VdbeMemInit(pCtx.pOut, db, (ushort)(0x0001)); pCtx.pFunc = pOp->p4.pFunc; pCtx.iOp = ((int)(pOp - aOp)); pCtx.pVdbe = p; pCtx.skipFlag = (byte)(0); pCtx.isError = (int)(0); pCtx.argc = (byte)(n); pOp->p4type = (sbyte)(-16); pOp->p4.pCtx = pCtx; pOp->opcode = (byte)(162); } case  162 :  { int i = 0; sqlite3_context pCtx; sqlite3_value pMem; pCtx = pOp->p4.pCtx; pMem = aMem[pOp->p3]; if (pCtx.pMem != pMem) { pCtx.pMem = pMem; for (i = (int)(pCtx.argc - 1); (i) >= (0); i--) { pCtx.argv[i] = aMem[pOp->p2 + i]; } } pMem.n++; if ((pOp->p1) != 0) { pCtx.pFunc.xInverse(pCtx, (int)(pCtx.argc), pCtx.argv); } else pCtx.pFunc.xSFunc(pCtx, (int)(pCtx.argc), pCtx.argv); if ((pCtx.isError) != 0) { if ((pCtx.isError) > (0)) { sqlite3VdbeError(p, "%s", sqlite3_value_text(pCtx.pOut)); rc = (int)(pCtx.isError); } if ((pCtx.skipFlag) != 0) { i = (int)(pOp[-1].p1); if ((i) != 0) sqlite3VdbeMemSetInt64(aMem[i], (long)(1)); pCtx.skipFlag = (byte)(0); } sqlite3VdbeMemRelease(pCtx.pOut); pCtx.pOut.flags = (ushort)(0x0001); pCtx.isError = (int)(0); if ((rc) != 0) goto abort_due_to_error; } break; } case  163 :  case  164 :  { sqlite3_value pMem; pMem = aMem[pOp->p1]; if ((pOp->p3) != 0) { rc = (int)(sqlite3VdbeMemAggValue(pMem, aMem[pOp->p3], pOp->p4.pFunc)); pMem = aMem[pOp->p3]; } else { rc = (int)(sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc)); } if ((rc) != 0) { sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem)); goto abort_due_to_error; } sqlite3VdbeChangeEncoding(pMem, (int)(encoding)); if ((sqlite3VdbeMemTooBig(pMem)) != 0) { goto too_big; } break; } case  6 :  { int i = 0; int* aRes = stackalloc int[3]; sqlite3_value pMem; aRes[0] = (int)(0); aRes[1] = (int)(aRes[2] = (int)(-1)); rc = (int)(sqlite3Checkpoint(db, (int)(pOp->p1), (int)(pOp->p2), &aRes[1], &aRes[2])); if ((rc) != 0) { if (rc != 5) goto abort_due_to_error; rc = (int)(0); aRes[0] = (int)(1); } for (i = (int)(0), pMem = aMem[pOp->p3]; (i) < (3); i++, pMem++) { sqlite3VdbeMemSetInt64(pMem, (long)(aRes[i])); } break; } case  7 :  { Btree pBt; Pager pPager; int eNew = 0; int eOld = 0; sbyte* zFilename; pOut = out2Prerelease(p, pOp); eNew = (int)(pOp->p3); pBt = db.aDb[pOp->p1].pBt; pPager = sqlite3BtreePager(pBt); eOld = (int)(sqlite3PagerGetJournalMode(pPager)); if ((eNew) == (-1)) eNew = (int)(eOld); if (sqlite3PagerOkToChangeJournalMode(pPager) == 0) eNew = (int)(eOld); zFilename = sqlite3PagerFilename(pPager, (int)(1)); if (((eNew) == (5)) && (((sqlite3Strlen30(zFilename)) == (0)) || (sqlite3PagerWalSupported(pPager) == 0))) { eNew = (int)(eOld); } if ((eNew != eOld) && (((eOld) == (5)) || ((eNew) == (5)))) { if ((db.autoCommit == 0) || ((db.nVdbeRead) > (1))) { rc = (int)(1); sqlite3VdbeError(p, "cannot change %s wal mode from within a transaction", ((eNew) == (5) ? "into" : "out of")); goto abort_due_to_error; } else { if ((eOld) == (5)) { rc = (int)(sqlite3PagerCloseWal(pPager, db)); if ((rc) == (0)) { sqlite3PagerSetJournalMode(pPager, (int)(eNew)); } } else if ((eOld) == (4)) { sqlite3PagerSetJournalMode(pPager, (int)(2)); } if ((rc) == (0)) { rc = (int)(sqlite3BtreeSetVersion(pBt, (int)((eNew) == (5) ? 2 : 1))); } } } if ((rc) != 0) eNew = (int)(eOld); eNew = (int)(sqlite3PagerSetJournalMode(pPager, (int)(eNew))); pOut.flags = (ushort)(0x0002 | 0x0800 | 0x0200); pOut.z = sqlite3JournalModename((int)(eNew)); pOut.n = (int)(sqlite3Strlen30(pOut.z)); pOut.enc = (byte)(1); sqlite3VdbeChangeEncoding(pOut, (int)(encoding)); if ((rc) != 0) goto abort_due_to_error; break; } case  8 :  { rc = (int)(sqlite3RunVacuum(&p.zErrMsg, db, (int)(pOp->p1), (pOp->p2) != 0 ? aMem[pOp->p2] : null)); if ((rc) != 0) goto abort_due_to_error; break; } case  61 :  { Btree pBt; pBt = db.aDb[pOp->p1].pBt; rc = (int)(sqlite3BtreeIncrVacuum(pBt)); if ((rc) != 0) { if (rc != 101) goto abort_due_to_error; rc = (int)(0); goto jump_to_p2; } break; } case  165 :  { if (pOp->p1 == 0) { sqlite3ExpirePreparedStatements(db, (int)(pOp->p2)); } else { p.expired = (uint)(pOp->p2 + 1); } break; } case  166 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; sqlite3BtreeCursorPin(pC.uc.pCursor); break; } case  167 :  { VdbeCursor pC; pC = p.apCsr[pOp->p1]; sqlite3BtreeCursorUnpin(pC.uc.pCursor); break; } case  168 :  { byte isWriteLock = (byte)(pOp->p3); if (((isWriteLock) != 0) || ((0) == (db.flags & 0x00000400))) { int p1 = (int)(pOp->p1); rc = (int)(sqlite3BtreeLockTable(db.aDb[p1].pBt, (int)(pOp->p2), (byte)(isWriteLock))); if ((rc) != 0) { if ((rc & 0xFF) == (6)) { sbyte* z = pOp->p4.z; sqlite3VdbeError(p, "database table is locked: %s", z); } goto abort_due_to_error; } } break; } case  169 :  { VTable pVTab; pVTab = pOp->p4.pVtab; rc = (int)(sqlite3VtabBegin(db, pVTab)); if ((pVTab) != null) sqlite3VtabImportErrmsg(p, pVTab.pVtab); if ((rc) != 0) goto abort_due_to_error; break; } case  170 :  { sqlite3_value sMem = new sqlite3_value(); sbyte* zTab; CRuntime.memset(sMem, (int)(0), (ulong)(sizeof(sqlite3_value))); sMem.db = db; rc = (int)(sqlite3VdbeMemCopy(sMem, aMem[pOp->p2])); zTab = (sbyte*)(sqlite3_value_text(sMem)); if ((zTab) != null) { rc = (int)(sqlite3VtabCallCreate(db, (int)(pOp->p1), zTab, &p.zErrMsg)); } sqlite3VdbeMemRelease(sMem); if ((rc) != 0) goto abort_due_to_error; break; } case  171 :  { db.nVDestroy++; rc = (int)(sqlite3VtabCallDestroy(db, (int)(pOp->p1), pOp->p4.z)); db.nVDestroy--; if ((rc) != 0) goto abort_due_to_error; break; } case  172 :  { VdbeCursor pCur; sqlite3_vtab_cursor pVCur; sqlite3_vtab pVtab; sqlite3_module pModule; pCur = null; pVCur = null; pVtab = pOp->p4.pVtab.pVtab; if (((pVtab) == (null)) || ((pVtab.pModule) == (null))) { rc = (int)(6); goto abort_due_to_error; } pModule = pVtab.pModule; rc = (int)(pModule.xOpen(pVtab, pVCur)); sqlite3VtabImportErrmsg(p, pVtab); if ((rc) != 0) goto abort_due_to_error; pVCur.pVtab = pVtab; pCur = allocateCursor(p, (int)(pOp->p1), (int)(0), (byte)(2)); if ((pCur) != null) { pCur.uc.pVCur = pVCur; pVtab.nRef++; } else { pModule.xClose(pVCur); goto no_mem; } break; } case  173 :  { VdbeCursor pC; ValueList pRhs; pC = p.apCsr[pOp->p1]; pRhs = sqlite3_malloc64((ulong)(sizeof(ValueList))); if ((pRhs) == (null)) goto no_mem; pRhs.pCsr = pC.uc.pCursor; pRhs.pOut = aMem[pOp->p3]; pOut = out2Prerelease(p, pOp); pOut.flags = (ushort)(0x0001); sqlite3VdbeMemSetPointer(pOut, pRhs, "ValueList", sqlite3_free); break; } case  9 :  { int nArg = 0; int iQuery = 0; sqlite3_module pModule; sqlite3_value pQuery; sqlite3_value pArgc; sqlite3_vtab_cursor pVCur; sqlite3_vtab pVtab; VdbeCursor pCur; int res = 0; int i = 0; sqlite3_value apArg; pQuery = aMem[pOp->p3]; pArgc = pQuery[1]; pCur = p.apCsr[pOp->p1]; pVCur = pCur.uc.pVCur; pVtab = pVCur.pVtab; pModule = pVtab.pModule; nArg = ((int)(pArgc.u.i)); iQuery = ((int)(pQuery.u.i)); apArg = p.apArg; for (i = (int)(0); (i) < (nArg); i++) { apArg[i] = pArgc[i + 1]; } rc = (int)(pModule.xFilter(pVCur, (int)(iQuery), pOp->p4.z, (int)(nArg), apArg)); sqlite3VtabImportErrmsg(p, pVtab); if ((rc) != 0) goto abort_due_to_error; res = (int)(pModule.xEof(pVCur)); pCur.nullRow = (byte)(0); if ((res) != 0) goto jump_to_p2; break; } case  174 :  { sqlite3_vtab pVtab; sqlite3_module pModule; sqlite3_value pDest; sqlite3_context sContext = new sqlite3_context(); VdbeCursor pCur = p.apCsr[pOp->p1]; pDest = aMem[pOp->p3]; if ((pCur.nullRow) != 0) { sqlite3VdbeMemSetNull(pDest); break; } pVtab = pCur.uc.pVCur.pVtab; pModule = pVtab.pModule; CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(sqlite3_context))); sContext.pOut = pDest; if ((pOp->p5 & 0x01) != 0) { sqlite3VdbeMemSetNull(pDest); pDest.flags = (ushort)(0x0001 | 0x4000); pDest.u.nZero = (int)(0); } else { ((pDest).flags = (ushort)(((pDest).flags & ~(0xc1bf | 0x4000)) | 0x0001)); } rc = (int)(pModule.xColumn(pCur.uc.pVCur, sContext, (int)(pOp->p2))); sqlite3VtabImportErrmsg(p, pVtab); if ((sContext.isError) > (0)) { sqlite3VdbeError(p, "%s", sqlite3_value_text(pDest)); rc = (int)(sContext.isError); } sqlite3VdbeChangeEncoding(pDest, (int)(encoding)); if ((sqlite3VdbeMemTooBig(pDest)) != 0) { goto too_big; } if ((rc) != 0) goto abort_due_to_error; break; } case  62 :  { sqlite3_vtab pVtab; sqlite3_module pModule; int res = 0; VdbeCursor pCur; pCur = p.apCsr[pOp->p1]; if ((pCur.nullRow) != 0) { break; } pVtab = pCur.uc.pVCur.pVtab; pModule = pVtab.pModule; rc = (int)(pModule.xNext(pCur.uc.pVCur)); sqlite3VtabImportErrmsg(p, pVtab); if ((rc) != 0) goto abort_due_to_error; res = (int)(pModule.xEof(pCur.uc.pVCur)); if (res == 0) { goto jump_to_p2_and_check_for_interrupt; } goto check_for_interrupt; } case  175 :  { sqlite3_vtab pVtab; sqlite3_value pName; int isLegacy = 0; isLegacy = (int)(db.flags & 0x04000000); db.flags |= (ulong)(0x04000000); pVtab = pOp->p4.pVtab.pVtab; pName = aMem[pOp->p1]; rc = (int)(sqlite3VdbeChangeEncoding(pName, (int)(1))); if ((rc) != 0) goto abort_due_to_error; rc = (int)(pVtab.pModule.xRename(pVtab, pName.z)); if ((isLegacy) == (0)) db.flags &= (ulong)(~(ulong)(0x04000000)); sqlite3VtabImportErrmsg(p, pVtab); p.expired = (uint)(0); if ((rc) != 0) goto abort_due_to_error; break; } case  10 :  { sqlite3_vtab pVtab; sqlite3_module pModule; int nArg = 0; int i = 0; long rowid = (long)(0); sqlite3_value apArg; sqlite3_value pX; if ((db.mallocFailed) != 0) goto no_mem; pVtab = pOp->p4.pVtab.pVtab; if (((pVtab) == (null)) || ((pVtab.pModule) == (null))) { rc = (int)(6); goto abort_due_to_error; } pModule = pVtab.pModule; nArg = (int)(pOp->p2); if ((pModule.xUpdate) != null) { byte vtabOnConflict = (byte)(db.vtabOnConflict); apArg = p.apArg; pX = aMem[pOp->p3]; for (i = (int)(0); (i) < (nArg); i++) { apArg[i] = pX; pX++; } db.vtabOnConflict = (byte)(pOp->p5); rc = (int)(pModule.xUpdate(pVtab, (int)(nArg), apArg, &rowid)); db.vtabOnConflict = (byte)(vtabOnConflict); sqlite3VtabImportErrmsg(p, pVtab); if (((rc) == (0)) && ((pOp->p1) != 0)) { db.lastRowid = (long)(rowid); } if (((rc & 0xff) == (19)) && ((pOp->p4.pVtab.bConstraint) != 0)) { if ((pOp->p5) == (4)) { rc = (int)(0); } else { p.errorAction = (byte)(((pOp->p5) == (5)) ? 2 : pOp->p5); } } else { p.nChange++; } if ((rc) != 0) goto abort_due_to_error; } break; } case  176 :  { pOut = out2Prerelease(p, pOp); pOut.u.i = (long)(sqlite3BtreeLastPage(db.aDb[pOp->p1].pBt)); break; } case  177 :  { uint newMax = 0; Btree pBt; pOut = out2Prerelease(p, pOp); pBt = db.aDb[pOp->p1].pBt; newMax = (uint)(0); if ((pOp->p3) != 0) { newMax = (uint)(sqlite3BtreeLastPage(pBt)); if ((newMax) < ((uint)(pOp->p3))) newMax = ((uint)(pOp->p3)); } pOut.u.i = (long)(sqlite3BtreeMaxPageCount(pBt, (uint)(newMax))); break; } case  65 :  case  66 :  { int i = 0; sqlite3_context pCtx; pCtx = pOp->p4.pCtx; pOut = aMem[pOp->p3]; if (pCtx.pOut != pOut) { pCtx.pVdbe = p; pCtx.pOut = pOut; for (i = (int)(pCtx.argc - 1); (i) >= (0); i--) { pCtx.argv[i] = aMem[pOp->p2 + i]; } } ((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0001)); *pCtx.pFunc.xSFunc(pCtx, (int)(pCtx.argc), pCtx.argv); if ((pCtx.isError) != 0) { if ((pCtx.isError) > (0)) { sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut)); rc = (int)(pCtx.isError); } sqlite3VdbeDeleteAuxData(db, p.pAuxData, (int)(pCtx.iOp), (int)(pOp->p1)); pCtx.isError = (int)(0); if ((rc) != 0) goto abort_due_to_error; } if ((pOut.flags & (0x0002 | 0x0010)) != 0) { sqlite3VdbeChangeEncoding(pOut, (int)(encoding)); if ((sqlite3VdbeMemTooBig(pOut)) != 0) goto too_big; } break; } case  178 :  { ulong h = 0; pIn1 = aMem[pOp->p1]; h = (ulong)(filterHash(aMem, pOp)); h %= (ulong)(pIn1.n); pIn1.z[h / 8] |= (sbyte)(1 << (h & 7)); break; } case  63 :  { ulong h = 0; pIn1 = aMem[pOp->p1]; h = (ulong)(filterHash(aMem, pOp)); h %= (ulong)(pIn1.n); if ((pIn1.z[h / 8] & (1 << (h & 7))) == (0)) { p.aCounter[8]++; goto jump_to_p2; } else { p.aCounter[7]++; } break; } case  179 :  case  64 :  { int i = 0; sbyte* zTrace; if ((((db.mTrace & (0x01 | 0x40)) != 0) && (p.doingRerun == 0)) && ((zTrace = ((pOp->p4.z) != 0 ? pOp->p4.z : p.zSql)) != null)) { if ((db.mTrace & 0x40) != 0) { sbyte* z = sqlite3VdbeExpandSql(p, zTrace); db.trace.xLegacy(db.pTraceArg, z); sqlite3_free(z); } else if ((db.nVdbeExec) > (1)) { sbyte* z = sqlite3MPrintf(db, "-- %s", zTrace); (void)(db.trace.xV2((uint)(0x01), db.pTraceArg, p, z)); sqlite3DbFree(db, z); } else { (void)(db.trace.xV2((uint)(0x01), db.pTraceArg, p, zTrace)); } } if ((pOp->p1) >= (sqlite3Config.iOnceResetThreshold)) { if ((pOp->opcode) == (179)) break; for (i = (int)(1); (i) < (p.nOp); i++) { if ((p.aOp[i].opcode) == (17)) p.aOp[i].p1 = (int)(0); } pOp->p1 = (int)(0); } pOp->p1++; p.aCounter[6]++; goto jump_to_p2; }
default :  { break; } } }

    abort_due_to_error:
; if ((db.mallocFailed) != 0) { rc = (int)(7); } else if ((rc) == (10 | (33 << 8))) { rc = (int)(sqlite3CorruptError((int)(95926))); }
if (((p.zErrMsg) == (null)) && (rc != (10 | (12 << 8))))
{
	sqlite3VdbeError(p, "%s", sqlite3ErrStr((int)(rc)));
}

p.rc = (int)(rc);
sqlite3SystemError(db, (int)(rc));
sqlite3_log((int)(rc), "statement aborts at %d: [%s] %s", (int)(pOp - aOp), p.zSql, p.zErrMsg);
sqlite3VdbeHalt(p);
if ((rc) == (10 | (12 << 8)))
	sqlite3OomFault(db);
if (((rc) == (11)) && ((db.autoCommit) == (0)))
{
	db.flags |= (ulong)((ulong)(0x00002) << 32);
}

rc = (int)(1);
if ((resetSchemaOnFault) > (0))
{
	sqlite3ResetOneSchema(db, (int)(resetSchemaOnFault - 1));
}

vdbe_return:
; while (((nVmStep) >= (nProgressLimit)) && (db.xProgress != null)) { nProgressLimit += (ulong)(db.nProgressOps); if ((db.xProgress(db.pProgressArg)) != 0) { nProgressLimit = (ulong)(0xffffffff | (((ulong)(0xffffffff)) << 32)); rc = (int)(9); goto abort_due_to_error; } }
p.aCounter[4] += (uint)((int)(nVmStep));
sqlite3VdbeLeave(p);
return (int)(rc);
too_big:
; sqlite3VdbeError(p, "string or blob too big");
rc = (int)(18);
goto abort_due_to_error;
no_mem:
; sqlite3OomFault(db);
sqlite3VdbeError(p, "out of memory");
rc = (int)(7);
goto abort_due_to_error;
abort_due_to_interrupt:
;
rc = (int)(9);
goto abort_due_to_error;
}
public static int sqlite3VdbeFinalize(Vdbe p)
{
	int rc = (int)(0);
	if (((p.iVdbeMagic) == (0x2df20da3)) || ((p.iVdbeMagic) == (0x319c2973)))
	{
		rc = (int)(sqlite3VdbeReset(p));
	}

	sqlite3VdbeDelete(p);
	return (int)(rc);
}
public static void sqlite3VdbeFreeCursor(Vdbe p, VdbeCursor pCx)
{
	if ((pCx) == (null))
	{
		return;
	}

	switch (pCx.eCurType)
	{
		case 1:
			{
				sqlite3VdbeSorterClose(p.db, pCx);
				break;
			}

		case 0:
			{
				sqlite3BtreeCloseCursor(pCx.uc.pCursor);
				break;
			}

		case 2:
			{
				sqlite3_vtab_cursor pVCur = pCx.uc.pVCur;
				sqlite3_module pModule = pVCur.pVtab.pModule;
				pVCur.pVtab.nRef--;
				pModule.xClose(pVCur);
				break;
			}
	}
}
public static sqlite3_value sqlite3VdbeGetBoundValue(Vdbe v, int iVar, byte aff)
{
	if ((v) != null)
	{
		sqlite3_value pMem = v.aVar[iVar - 1];
		if ((0) == (pMem.flags & 0x0001))
		{
			sqlite3_value pRet = sqlite3ValueNew(v.db);
			if ((pRet) != null)
			{
				sqlite3VdbeMemCopy(pRet, pMem);
				sqlite3ValueApplyAffinity(pRet, (byte)(aff), (byte)(1));
			}

			return pRet;
		}
	}

	return null;
}
public static int sqlite3VdbeGoto(Vdbe p, int iDest)
{
	return (int)(sqlite3VdbeAddOp3(p, (int)(11), (int)(0), (int)(iDest), (int)(0)));
}
public static int sqlite3VdbeHalt(Vdbe p)
{
	int rc = 0;
	sqlite3 db = p.db;
	if (p.iVdbeMagic != 0x2df20da3)
	{
		return (int)(0);
	}

	if ((db.mallocFailed) != 0)
	{
		p.rc = (int)(7);
	}

	closeAllCursors(p);
	if (((p.pc) >= (0)) && ((p.bIsReader) != 0))
	{
		int mrc = 0;
		int eStatementOp = (int)(0);
		int isSpecialError = 0;
		sqlite3VdbeEnter(p);
		if ((p.rc) != 0)
		{
			mrc = (int)(p.rc & 0xff);
			isSpecialError = (int)(((((mrc) == (7)) || ((mrc) == (10))) || ((mrc) == (9))) || ((mrc) == (13)) ? 1 : 0);
		}
		else
		{
			mrc = (int)(isSpecialError = (int)(0));
		}

		if ((isSpecialError) != 0)
		{
			if ((p.readOnly == 0) || (mrc != 9))
			{
				if ((((mrc) == (7)) || ((mrc) == (13))) && ((p.usesStmtJournal) != 0))
				{
					eStatementOp = (int)(2);
				}
				else
				{
					sqlite3RollbackAll(db, (int)(4 | (2 << 8)));
					sqlite3CloseSavepoints(db);
					db.autoCommit = (byte)(1);
					p.nChange = (long)(0);
				}
			}
		}

		if (((p.rc) == (0)) || (((p.errorAction) == (3)) && (isSpecialError == 0)))
		{
			sqlite3VdbeCheckFk(p, (int)(0));
		}

		if (((!((((db).nVTrans) > (0)) && (((db).aVTrans) == (null)))) && ((db.autoCommit) != 0)) && ((db.nVdbeWrite) == ((p.readOnly) == (0))))
		{
			if (((p.rc) == (0)) || (((p.errorAction) == (3)) && (isSpecialError == 0)))
			{
				rc = (int)(sqlite3VdbeCheckFk(p, (int)(1)));
				if (rc != 0)
				{
					if ((p.readOnly) != 0)
					{
						sqlite3VdbeLeave(p);
						return (int)(1);
					}

					rc = (int)(19 | (3 << 8));
				}
				else if ((db.flags & ((ulong)(0x00002) << 32)) != 0)
				{
					rc = (int)(11);
					db.flags &= (ulong)(~((ulong)(0x00002) << 32));
				}
				else
				{
					rc = (int)(vdbeCommit(db, p));
				}

				if (((rc) == (5)) && ((p.readOnly) != 0))
				{
					sqlite3VdbeLeave(p);
					return (int)(5);
				}
				else if (rc != 0)
				{
					p.rc = (int)(rc);
					sqlite3RollbackAll(db, (int)(0));
					p.nChange = (long)(0);
				}
				else
				{
					db.nDeferredCons = (long)(0);
					db.nDeferredImmCons = (long)(0);
					db.flags &= (ulong)(~(ulong)(0x00080000));
					sqlite3CommitInternalChanges(db);
				}
			}
			else
			{
				sqlite3RollbackAll(db, (int)(0));
				p.nChange = (long)(0);
			}

			db.nStatement = (int)(0);
		}
		else if ((eStatementOp) == (0))
		{
			if (((p.rc) == (0)) || ((p.errorAction) == (3)))
			{
				eStatementOp = (int)(1);
			}
			else if ((p.errorAction) == (2))
			{
				eStatementOp = (int)(2);
			}
			else
			{
				sqlite3RollbackAll(db, (int)(4 | (2 << 8)));
				sqlite3CloseSavepoints(db);
				db.autoCommit = (byte)(1);
				p.nChange = (long)(0);
			}
		}

		if ((eStatementOp) != 0)
		{
			rc = (int)(sqlite3VdbeCloseStatement(p, (int)(eStatementOp)));
			if ((rc) != 0)
			{
				if (((p.rc) == (0)) || ((p.rc & 0xff) == (19)))
				{
					p.rc = (int)(rc);
					sqlite3DbFree(db, p.zErrMsg);
					p.zErrMsg = null;
				}

				sqlite3RollbackAll(db, (int)(4 | (2 << 8)));
				sqlite3CloseSavepoints(db);
				db.autoCommit = (byte)(1);
				p.nChange = (long)(0);
			}
		}

		if ((p.changeCntOn) != 0)
		{
			if (eStatementOp != 2)
			{
				sqlite3VdbeSetChanges(db, (long)(p.nChange));
			}
			else
			{
				sqlite3VdbeSetChanges(db, (long)(0));
			}

			p.nChange = (long)(0);
		}

		sqlite3VdbeLeave(p);
	}

	if ((p.pc) >= (0))
	{
		db.nVdbeActive--;
		if (p.readOnly == 0)
			db.nVdbeWrite--;
		if ((p.bIsReader) != 0)
			db.nVdbeRead--;
	}

	p.iVdbeMagic = (uint)(0x319c2973);
	if ((db.mallocFailed) != 0)
	{
		p.rc = (int)(7);
	}

	if ((db.autoCommit) != 0)
	{
	}

	return (int)((p.rc) == (5) ? 5 : 0);
}
public static int sqlite3VdbeHasSubProgram(Vdbe pVdbe)
{
	return (int)(pVdbe.pProgram != null);
}
public static void sqlite3VdbeJumpHere(Vdbe p, int addr)
{
	sqlite3VdbeChangeP2(p, (int)(addr), (int)(p.nOp));
}
public static void sqlite3VdbeJumpHereOrPopInst(Vdbe p, int addr)
{
	if ((addr) == (p.nOp - 1))
	{
		p.nOp--;
	}
	else
	{
		sqlite3VdbeChangeP2(p, (int)(addr), (int)(p.nOp));
	}
}
public static void sqlite3VdbeLeave(Vdbe p)
{
	if ((p.lockMask) == (0))
		return;
	vdbeLeave(p);
}
public static void sqlite3VdbeLinkSubProgram(Vdbe pVdbe, SubProgram* p)
{
	p->pNext = pVdbe.pProgram;
	pVdbe.pProgram = p;
}
public static int sqlite3VdbeList(Vdbe p)
{
	sqlite3_value pSub = null;
	sqlite3 db = p.db;
	int i = 0;
	int rc = (int)(0);
	sqlite3_value pMem = p.aMem[1];
	int bListSubprogs = (int)((((p.explain) == (1)) || ((db.flags & 0x01000000) != 0)) ? 1 : 0);
	VdbeOp* aOp;
	VdbeOp* pOp;
	releaseMemArray(pMem, (int)(8));
	p.pResultSet = null;
	if ((p.rc) == (7))
	{
		sqlite3OomFault(db);
		return (int)(1);
	}

	if ((bListSubprogs) != 0)
	{
		pSub = p.aMem[9];
	}
	else
	{
		pSub = null;
	}

	rc = (int)(sqlite3VdbeNextOpcode(p, pSub, ((p.explain) == (2) ? 1 : 0), &p.pc, &i, &aOp));
	if ((rc) == (0))
	{
		pOp = aOp + i;
		if ((0) != 0)
		{
			p.rc = (int)(9);
			rc = (int)(1);
			sqlite3VdbeError(p, sqlite3ErrStr((int)(p.rc)));
		}
		else
		{
			sbyte* zP4 = sqlite3VdbeDisplayP4(db, pOp);
			if ((p.explain) == (2))
			{
				sqlite3VdbeMemSetInt64(pMem, (long)(pOp->p1));
				sqlite3VdbeMemSetInt64(pMem[1], (long)(pOp->p2));
				sqlite3VdbeMemSetInt64(pMem[2], (long)(pOp->p3));
				sqlite3VdbeMemSetStr(pMem[3], zP4, (long)(-1), (byte)(1), sqlite3_free);
				p.nResColumn = (ushort)(4);
			}
			else
			{
				sqlite3VdbeMemSetInt64(pMem[0], (long)(i));
				sqlite3VdbeMemSetStr(pMem[1], sqlite3OpcodeName((int)(pOp->opcode)), (long)(-1), (byte)(1), null);
				sqlite3VdbeMemSetInt64(pMem[2], (long)(pOp->p1));
				sqlite3VdbeMemSetInt64(pMem[3], (long)(pOp->p2));
				sqlite3VdbeMemSetInt64(pMem[4], (long)(pOp->p3));
				sqlite3VdbeMemSetInt64(pMem[6], (long)(pOp->p5));
				sqlite3VdbeMemSetNull(pMem[7]);
				sqlite3VdbeMemSetStr(pMem[5], zP4, (long)(-1), (byte)(1), sqlite3_free);
				p.nResColumn = (ushort)(8);
			}

			p.pResultSet = pMem;
			if ((db.mallocFailed) != 0)
			{
				p.rc = (int)(7);
				rc = (int)(1);
			}
			else
			{
				p.rc = (int)(0);
				rc = (int)(100);
			}
		}
	}

	return (int)(rc);
}
public static int sqlite3VdbeLoadString(Vdbe p, int iDest, sbyte* zStr)
{
	return (int)(sqlite3VdbeAddOp4(p, (int)(117), (int)(0), (int)(iDest), (int)(0), zStr, (int)(0)));
}
public static void sqlite3VdbeMakeReady(Vdbe p, Parse pParse)
{
	sqlite3 db;
	int nVar = 0;
	int nMem = 0;
	int nCursor = 0;
	int nArg = 0;
	int n = 0;
	ReusableSpace x = new ReusableSpace();
	p.pVList = pParse.pVList;
	pParse.pVList = null;
	db = p.db;
	nVar = (int)(pParse.nVar);
	nMem = (int)(pParse.nMem);
	nCursor = (int)(pParse.nTab);
	nArg = (int)(pParse.nMaxArg);
	nMem += (int)(nCursor);
	if (((nCursor) == (0)) && ((nMem) > (0)))
		nMem++;
	n = (int)(((sizeof(VdbeOp) * p.nOp) + 7) & ~7);
	x.pSpace = &((byte*)(p.aOp))[n];
	x.nFree = (long)((pParse.szOpAlloc - n) & ~7);
	resolveP2Values(p, &nArg);
	p.usesStmtJournal = (uint)((byte)(((pParse.isMultiWrite) != 0) && ((pParse.mayAbort) != 0)));
	if ((pParse.explain) != 0)
	{
		int iFirst = 0;
		int mx = 0;
		int i = 0;
		if ((nMem) < (10))
			nMem = (int)(10);
		p.explain = (uint)(pParse.explain);
		if ((pParse.explain) == (2))
		{
			sqlite3VdbeSetNumCols(p, (int)(4));
			iFirst = (int)(8);
			mx = (int)(12);
		}
		else
		{
			sqlite3VdbeSetNumCols(p, (int)(8));
			iFirst = (int)(0);
			mx = (int)(8);
		}

		for (i = (int)(iFirst); (i) < (mx); i++)
		{
			sqlite3VdbeSetColName(p, (int)(i - iFirst), (int)(0), sqlite3VdbeMakeReady_azColName[i], null);
		}
	}

	p.expired = (uint)(0);
	x.nNeeded = (long)(0);
	p.aMem = allocSpace(&x, null, (long)(nMem * sizeof(sqlite3_value)));
	p.aVar = allocSpace(&x, null, (long)(nVar * sizeof(sqlite3_value)));
	p.apArg = allocSpace(&x, null, (long)(nArg * sizeof(sqlite3_value)));
	p.apCsr = allocSpace(&x, null, (long)(nCursor * sizeof(VdbeCursor)));
	if ((x.nNeeded) != 0)
	{
		x.pSpace = p.pFree = sqlite3DbMallocRawNN(db, (ulong)(x.nNeeded));
		x.nFree = (long)(x.nNeeded);
		if (db.mallocFailed == 0)
		{
			p.aMem = allocSpace(&x, p.aMem, (long)(nMem * sizeof(sqlite3_value)));
			p.aVar = allocSpace(&x, p.aVar, (long)(nVar * sizeof(sqlite3_value)));
			p.apArg = allocSpace(&x, p.apArg, (long)(nArg * sizeof(sqlite3_value)));
			p.apCsr = allocSpace(&x, p.apCsr, (long)(nCursor * sizeof(VdbeCursor)));
		}
	}

	if ((db.mallocFailed) != 0)
	{
		p.nVar = (short)(0);
		p.nCursor = (int)(0);
		p.nMem = (int)(0);
	}
	else
	{
		p.nCursor = (int)(nCursor);
		p.nVar = ((short)(nVar));
		initMemArray(p.aVar, (int)(nVar), db, (ushort)(0x0001));
		p.nMem = (int)(nMem);
		initMemArray(p.aMem, (int)(nMem), db, (ushort)(0x0080));
		CRuntime.memset(p.apCsr, (int)(0), (ulong)(nCursor * sizeof(VdbeCursor)));
	}

	sqlite3VdbeRewind(p);
}
public static void sqlite3VdbeMultiLoad(Vdbe p, int iDest, sbyte* zTypes)
{
	sbyte* ap;
	int i = 0;
	sbyte c = 0;
	(__va_start(&ap, zTypes));
	for (i = (int)(0); (c = (sbyte)(zTypes[i])) != 0; i++)
	{
		if ((c) == (115))
		{
			sbyte* z = (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
			sqlite3VdbeAddOp4(p, (int)((z) == (null) ? 74 : 117), (int)(0), (int)(iDest + i), (int)(0), z, (int)(0));
		}
		else if ((c) == (105))
		{
			sqlite3VdbeAddOp2(p, (int)(71), (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )), (int)(iDest + i));
		}
		else
		{
			goto skip_op_resultrow;
		}
	}

	sqlite3VdbeAddOp2(p, (int)(83), (int)(iDest), (int)(i));
skip_op_resultrow:
	; ((void)(ap = null));
}
public static int sqlite3VdbeNextOpcode(Vdbe p, sqlite3_value pSub, int eMode, int* piPc, int* piAddr, VdbeOp** paOp)
{
	int nRow = 0;
	int nSub = (int)(0);
	SubProgram** apSub = null;
	int i = 0;
	int rc = (int)(0);
	VdbeOp* aOp = null;
	int iPc = 0;
	nRow = (int)(p.nOp);
	if (pSub != null)
	{
		if ((pSub.flags & 0x0010) != 0)
		{
			nSub = (int)(pSub.n / sizeof(Vdbe));
			apSub = (SubProgram**)(pSub.z);
		}

		for (i = (int)(0); (i) < (nSub); i++)
		{
			nRow += (int)(apSub[i]->nOp);
		}
	}

	iPc = (int)(*piPc);
	while ((1) != 0)
	{
		i = (int)(iPc++);
		if ((i) >= (nRow))
		{
			p.rc = (int)(0);
			rc = (int)(101);
			break;
		}

		if ((i) < (p.nOp))
		{
			aOp = p.aOp;
		}
		else
		{
			int j = 0;
			i -= (int)(p.nOp);
			for (j = (int)(0); (i) >= (apSub[j]->nOp); j++)
			{
				i -= (int)(apSub[j]->nOp);
			}

			aOp = apSub[j]->aOp;
		}

		if ((pSub != null) && ((aOp[i].p4type) == (-4)))
		{
			int nByte = (int)((nSub + 1) * sizeof(SubProgram));
			int j = 0;
			for (j = (int)(0); (j) < (nSub); j++)
			{
				if ((apSub[j]) == (aOp[i].p4.pProgram))
					break;
			}

			if ((j) == (nSub))
			{
				p.rc = (int)(sqlite3VdbeMemGrow(pSub, (int)(nByte), (int)(nSub != 0)));
				if (p.rc != 0)
				{
					rc = (int)(1);
					break;
				}

				apSub = (SubProgram**)(pSub.z);
				apSub[nSub++] = aOp[i].p4.pProgram;
				((pSub).flags = (ushort)(((pSub).flags & ~(0xc1bf | 0x4000)) | 0x0010));
				pSub.n = (int)(nSub * sizeof(SubProgram));
				nRow += (int)(aOp[i].p4.pProgram->nOp);
			}
		}

		if ((eMode) == (0))
			break;
		{
			if ((aOp[i].opcode) == (183))
				break;
			if (((aOp[i].opcode) == (64)) && ((iPc) > (1)))
				break;
		}
	}

	*piPc = (int)(iPc);
	*piAddr = (int)(i);
	*paOp = aOp;
	return (int)(rc);
}
public static int sqlite3VdbeParameterIndex(Vdbe p, sbyte* zName, int nName)
{
	if (((p) == (null)) || ((zName) == (null)))
		return (int)(0);
	return (int)(sqlite3VListNameToNum(p.pVList, zName, (int)(nName)));
}
public static Parse sqlite3VdbeParser(Vdbe p)
{
	return p.pParse;
}
public static byte sqlite3VdbePrepareFlags(Vdbe v)
{
	return (byte)(v.prepFlags);
}
public static int sqlite3VdbeReset(Vdbe p)
{
	sqlite3 db;
	db = p.db;
	sqlite3VdbeHalt(p);
	if ((p.pc) >= (0))
	{
		if (((db.pErr) != null) || ((p.zErrMsg) != null))
		{
			sqlite3VdbeTransferError(p);
		}
		else
		{
			db.errCode = (int)(p.rc);
		}

		if ((p.runOnlyOnce) != 0)
			p.expired = (uint)(1);
	}
	else if (((p.rc) != 0) && ((p.expired) != 0))
	{
		sqlite3ErrorWithMsg(db, (int)(p.rc), (p.zErrMsg) != 0 ? "%s" : null, p.zErrMsg);
	}

	if ((p.zErrMsg) != null)
	{
		sqlite3DbFree(db, p.zErrMsg);
		p.zErrMsg = null;
	}

	p.pResultSet = null;
	p.iVdbeMagic = (uint)(0x48fa9f76);
	return (int)(p.rc & db.errMask);
}
public static void sqlite3VdbeResetStepResult(Vdbe p)
{
	p.rc = (int)(0);
}
public static void sqlite3VdbeResolveLabel(Vdbe v, int x)
{
	Parse p = v.pParse;
	int j = (int)(~(x));
	if ((p.nLabelAlloc + p.nLabel) < (0))
	{
		resizeResolveLabel(p, v, (int)(j));
	}
	else
	{
		p.aLabel[j] = (int)(v.nOp);
	}
}
public static void sqlite3VdbeReusable(Vdbe p)
{
	p.runOnlyOnce = (uint)(0);
}
public static void sqlite3VdbeRewind(Vdbe p)
{
	p.iVdbeMagic = (uint)(0x2df20da3);
	p.pc = (int)(-1);
	p.rc = (int)(0);
	p.errorAction = (byte)(2);
	p.nChange = (long)(0);
	p.cacheCtr = (uint)(1);
	p.minWriteFileFormat = (byte)(255);
	p.iStatement = (int)(0);
	p.nFkConstraint = (long)(0);
}
public static void sqlite3VdbeRunOnlyOnce(Vdbe p)
{
	p.runOnlyOnce = (uint)(1);
}
public static int sqlite3VdbeSetColName(Vdbe p, int idx, int var, sbyte* zName, delegate17 xDel)
{
	int rc = 0;
	sqlite3_value pColName;
	if ((p.db.mallocFailed) != 0)
	{
		return (int)(7);
	}

	pColName = (p.aColName[idx + var * p.nResColumn]);
	rc = (int)(sqlite3VdbeMemSetStr(pColName, zName, (long)(-1), (byte)(1), xDel));
	return (int)(rc);
}
public static void sqlite3VdbeSetNumCols(Vdbe p, int nResColumn)
{
	int n = 0;
	sqlite3 db = p.db;
	if ((p.nResColumn) != 0)
	{
		releaseMemArray(p.aColName, (int)(p.nResColumn * 2));
		sqlite3DbFree(db, p.aColName);
	}

	n = (int)(nResColumn * 2);
	p.nResColumn = ((ushort)(nResColumn));
	p.aColName = (sqlite3_value)(sqlite3DbMallocRawNN(db, (ulong)(sizeof(sqlite3_value) * n)));
	if ((p.aColName) == (null))
		return;
	initMemArray(p.aColName, (int)(n), db, (ushort)(0x0001));
}
public static void sqlite3VdbeSetSql(Vdbe p, sbyte* z, int n, byte prepFlags)
{
	if ((p) == (null))
		return;
	p.prepFlags = (byte)(prepFlags);
	if ((prepFlags & 0x80) == (0))
	{
		p.expmask = (uint)(0);
	}

	p.zSql = sqlite3DbStrNDup(p.db, z, (ulong)(n));
}
public static void sqlite3VdbeSetVarmask(Vdbe v, int iVar)
{
	if ((iVar) >= (32))
	{
		v.expmask |= (uint)(0x80000000);
	}
	else
	{
		v.expmask |= (uint)((uint)(1) << (iVar - 1));
	}
}
public static void sqlite3VdbeSwap(Vdbe pA, Vdbe pB)
{
	Vdbe tmp = new Vdbe(); Vdbe pTmp;
	sbyte* zTmp;
	tmp = (Vdbe)(pA);
	pA = (Vdbe)(pB);
	pB = (Vdbe)(tmp);
	pTmp = pA.pNext;
	pA.pNext = pB.pNext;
	pB.pNext = pTmp;
	pTmp = pA.pPrev;
	pA.pPrev = pB.pPrev;
	pB.pPrev = pTmp;
	zTmp = pA.zSql;
	pA.zSql = pB.zSql;
	pB.zSql = zTmp;
	pB.expmask = (uint)(pA.expmask);
	pB.prepFlags = (byte)(pA.prepFlags);
	CRuntime.memcpy(pB.aCounter, pA.aCounter, (ulong)(9 * sizeof(uint)));
	pB.aCounter[5]++;
}
public static int sqlite3VdbeTransferError(Vdbe p)
{
	sqlite3 db = p.db;
	int rc = (int)(p.rc);
	if ((p.zErrMsg) != null)
	{
		db.bBenignMalloc++;
		sqlite3BeginBenignMalloc();
		if ((db.pErr) == (null))
			db.pErr = sqlite3ValueNew(db);
		sqlite3ValueSetStr(db.pErr, (int)(-1), p.zErrMsg, (byte)(1), ((Void(Void * ))(-1)));
		sqlite3EndBenignMalloc();
		db.bBenignMalloc--;
	}
	else if ((db.pErr) != null)
	{
		sqlite3ValueSetNull(db.pErr);
	}

	db.errCode = (int)(rc);
	db.errByteOffset = (int)(-1);
	return (int)(rc);
}
public static void sqlite3VdbeUsesBtree(Vdbe p, int i)
{
	(p.btreeMask) |= (uint)(((uint)(1)) << (i));
	if ((i != 1) && ((sqlite3BtreeSharable(p.db.aDb[i].pBt)) != 0))
	{
		(p.lockMask) |= (uint)(((uint)(1)) << (i));
	}
}
public static void sqlite3VtabImportErrmsg(Vdbe p, sqlite3_vtab pVtab)
{
	if ((pVtab.zErrMsg) != null)
	{
		sqlite3 db = p.db;
		sqlite3DbFree(db, p.zErrMsg);
		p.zErrMsg = sqlite3DbStrDup(db, pVtab.zErrMsg);
		sqlite3_free(pVtab.zErrMsg);
		pVtab.zErrMsg = null;
	}
}
public static void sqlite3WhereMinMaxOptEarlyOut(Vdbe v, WhereInfo pWInfo)
{
	WhereLevel pInner;
	int i = 0;
	if (pWInfo.bOrderedInnerLoop == 0)
		return;
	if ((pWInfo.nOBSat) == (0))
		return;
	for (i = (int)(pWInfo.nLevel - 1); (i) >= (0); i--)
	{
		pInner = pWInfo.a[i];
		if ((pInner.pWLoop.wsFlags & 0x00000004) != 0)
		{
			sqlite3VdbeGoto(v, (int)(pInner.addrNxt));
			return;
		}
	}

	sqlite3VdbeGoto(v, (int)(pWInfo.iBreak));
}
public static void vdbeChangeP4Full(Vdbe p, VdbeOp* pOp, sbyte* zP4, int n)
{
	if ((pOp->p4type) != 0)
	{
		freeP4(p.db, (int)(pOp->p4type), pOp->p4.p);
		pOp->p4type = (sbyte)(0);
		pOp->p4.p = null;
	}

	if ((n) < (0))
	{
		sqlite3VdbeChangeP4(p, (int)(pOp - p.aOp), zP4, (int)(n));
	}
	else
	{
		if ((n) == (0))
			n = (int)(sqlite3Strlen30(zP4));
		pOp->p4.z = sqlite3DbStrNDup(p.db, zP4, (ulong)(n));
		pOp->p4type = (sbyte)(-7);
	}
}
public static int vdbeCloseStatement(Vdbe p, int eOp)
{
	sqlite3 db = p.db;
	int rc = (int)(0);
	int i = 0;
	int iSavepoint = (int)(p.iStatement - 1);
	for (i = (int)(0); (i) < (db.nDb); i++)
	{
		int rc2 = (int)(0);
		Btree pBt = db.aDb[i].pBt;
		if ((pBt) != null)
		{
			if ((eOp) == (2))
			{
				rc2 = (int)(sqlite3BtreeSavepoint(pBt, (int)(2), (int)(iSavepoint)));
			}

			if ((rc2) == (0))
			{
				rc2 = (int)(sqlite3BtreeSavepoint(pBt, (int)(1), (int)(iSavepoint)));
			}

			if ((rc) == (0))
			{
				rc = (int)(rc2);
			}
		}
	}

	db.nStatement--;
	p.iStatement = (int)(0);
	if ((rc) == (0))
	{
		if ((eOp) == (2))
		{
			rc = (int)(sqlite3VtabSavepoint(db, (int)(2), (int)(iSavepoint)));
		}

		if ((rc) == (0))
		{
			rc = (int)(sqlite3VtabSavepoint(db, (int)(1), (int)(iSavepoint)));
		}
	}

	if ((eOp) == (2))
	{
		db.nDeferredCons = (long)(p.nStmtDefCons);
		db.nDeferredImmCons = (long)(p.nStmtDefImmCons);
	}

	return (int)(rc);
}
public static void vdbeLeave(Vdbe p)
{
	int i = 0;
	sqlite3 db;
	Db aDb;
	int nDb = 0;
	db = p.db;
	aDb = db.aDb;
	nDb = (int)(db.nDb);
	for (i = (int)(0); (i) < (nDb); i++)
	{
		if (((i != 1) && (((p.lockMask) & (((uint)(1)) << (i))) != 0)) && (aDb[i].pBt != null))
		{
			sqlite3BtreeLeave(aDb[i].pBt);
		}
	}
}
public static int vdbeSafety(Vdbe p)
{
	if ((p.db) == (null))
	{
		sqlite3_log((int)(21), "API called with finalized prepared statement");
		return (int)(1);
	}
	else
	{
		return (int)(0);
	}
}
public static int vdbeSafetyNotNull(Vdbe p)
{
	if ((p) == (null))
	{
		sqlite3_log((int)(21), "API called with NULL prepared statement");
		return (int)(1);
	}
	else
	{
		return (int)(vdbeSafety(p));
	}
}
public static int vdbeUnbind(Vdbe p, int i)
{
	sqlite3_value pVar;
	if ((vdbeSafetyNotNull(p)) != 0)
	{
		return (int)(sqlite3MisuseError((int)(86472)));
	}

	sqlite3_mutex_enter(p.db.mutex);
	if ((p.iVdbeMagic != 0x2df20da3) || ((p.pc) >= (0)))
	{
		sqlite3Error(p.db, (int)(21));
		sqlite3_mutex_leave(p.db.mutex);
		sqlite3_log((int)(21), "bind on a busy prepared statement: [%s]", p.zSql);
		return (int)(sqlite3MisuseError((int)(86480)));
	}

	if (((i) < (1)) || ((i) > (p.nVar)))
	{
		sqlite3Error(p.db, (int)(25));
		sqlite3_mutex_leave(p.db.mutex);
		return (int)(25);
	}

	i--;
	pVar = p.aVar[i];
	sqlite3VdbeMemRelease(pVar);
	pVar.flags = (ushort)(0x0001);
	p.db.errCode = (int)(0);
	if ((p.expmask != 0) && ((p.expmask & ((i) >= (31) ? 0x80000000 : (uint)(1) << i)) != 0))
	{
		p.expired = (uint)(1);
	}

	return (int)(0);
}
public static void whereLikeOptimizationStringFixup(Vdbe v, WhereLevel pLevel, WhereTerm pTerm)
{
	if ((pTerm.wtFlags & 0x0100) != 0)
	{
		VdbeOp* pOp;
		pOp = sqlite3VdbeGetOp(v, (int)(-1));
		pOp->p3 = ((int)(pLevel.iLikeRepCntr >> 1));
		pOp->p5 = (ushort)((byte)(pLevel.iLikeRepCntr & 1));
	}
}}
}