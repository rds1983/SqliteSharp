<?xml version="1.0" encoding="utf-8"?>
<functions>
  <function>public static void absFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    switch (sqlite3_value_type(argv[0]))
    {
        case 1:
        {
            long iVal = (long)(sqlite3_value_int64(argv[0]));
            if ((iVal) &lt; (0))
            {
                if ((iVal) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))
                {
                    sqlite3_result_error(context, "integer overflow", (int)(-1));
                    return;
                }

                iVal = (long)(-iVal);
            }

            sqlite3_result_int64(context, (long)(iVal));
            break;
        }

        case 5:
        {
            sqlite3_result_null(context);
            break;
        }

        default:
        {
            double rVal = (double)(sqlite3_value_double(argv[0]));
            if ((rVal) &lt; (0))
                rVal = (double)(-rVal);
            sqlite3_result_double(context, (double)(rVal));
            break;
        }
    }
}</function>
  <function>public static int accessPayload(BtCursor pCur, uint offset, uint amt, byte* pBuf, int eOp)
{
    byte* aPayload;
    int rc = (int)(0);
    int iIdx = (int)(0);
    MemPage pPage = pCur.pPage;
    BtShared pBt = pCur.pBt;
    if ((pCur.ix) &gt;= (pPage.nCell))
    {
        return (int)(sqlite3CorruptError((int)(71057)));
    }

    getCellInfo(pCur);
    aPayload = pCur.info.pPayload;
    if (((ulong)(aPayload - pPage.aData)) &gt; (pBt.usableSize - pCur.info.nLocal))
    {
        return (int)(sqlite3CorruptError((int)(71072)));
    }

    if ((offset) &lt; (pCur.info.nLocal))
    {
        int a = (int)(amt);
        if ((a + offset) &gt; (pCur.info.nLocal))
        {
            a = (int)(pCur.info.nLocal - offset);
        }

        rc = (int)(copyPayload(&amp;aPayload[offset], pBuf, (int)(a), (int)(eOp), pPage.pDbPage));
        offset = (uint)(0);
        pBuf += a;
        amt -= (uint)(a);
    }
    else
    {
        offset -= (uint)(pCur.info.nLocal);
    }

    if (((rc) == (0)) &amp;&amp; ((amt) &gt; (0)))
    {
        uint ovflSize = (uint)(pBt.usableSize - 4);
        uint nextPage = 0;
        nextPage = (uint)(sqlite3Get4byte(&amp;aPayload[pCur.info.nLocal]));
        if ((pCur.curFlags &amp; 0x04) == (0))
        {
            int nOvfl = (int)((pCur.info.nPayload - pCur.info.nLocal + ovflSize - 1) / ovflSize);
            if (((pCur.aOverflow) == (null)) || ((nOvfl * (int)(sizeof(uint))) &gt; (sqlite3MallocSize(pCur.aOverflow))))
            {
                uint* aNew = (uint*)(sqlite3Realloc(pCur.aOverflow, (ulong)(nOvfl * 2 * sizeof(uint))));
                if ((aNew) == (null))
                {
                    return (int)(7);
                }
                else
                {
                    pCur.aOverflow = aNew;
                }
            }

            CRuntime.memset(pCur.aOverflow, (int)(0), (ulong)(nOvfl * sizeof(uint)));
            pCur.curFlags |= (byte)(0x04);
        }
        else
        {
            if ((pCur.aOverflow[offset / ovflSize]) != 0)
            {
                iIdx = (int)(offset / ovflSize);
                nextPage = (uint)(pCur.aOverflow[iIdx]);
                offset = (uint)(offset % ovflSize);
            }
        }

        while ((nextPage) != 0)
        {
            if ((nextPage) &gt; (pBt.nPage))
                return (int)(sqlite3CorruptError((int)(71134)));
            pCur.aOverflow[iIdx] = (uint)(nextPage);
            if ((offset) &gt;= (ovflSize))
            {
                if ((pCur.aOverflow[iIdx + 1]) != 0)
                {
                    nextPage = (uint)(pCur.aOverflow[iIdx + 1]);
                }
                else
                {
                    rc = (int)(getOverflowPage(pBt, (uint)(nextPage), null, &amp;nextPage));
                }

                offset -= (uint)(ovflSize);
            }
            else
            {
                int a = (int)(amt);
                if ((a + offset) &gt; (ovflSize))
                {
                    a = (int)(ovflSize - offset);
                }

                {
                    PgHdr pDbPage;
                    rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(nextPage), pDbPage, (int)((eOp) == (0) ? 0x02 : 0)));
                    if ((rc) == (0))
                    {
                        aPayload = sqlite3PagerGetData(pDbPage);
                        nextPage = (uint)(sqlite3Get4byte(aPayload));
                        rc = (int)(copyPayload(&amp;aPayload[offset + 4], pBuf, (int)(a), (int)(eOp), pDbPage));
                        sqlite3PagerUnref(pDbPage);
                        offset = (uint)(0);
                    }
                }

                amt -= (uint)(a);
                if ((amt) == (0))
                    return (int)(rc);
                pBuf += a;
            }

            if ((rc) != 0)
                break;
            iIdx++;
        }
    }

    if (((rc) == (0)) &amp;&amp; ((amt) &gt; (0)))
    {
        return (int)(sqlite3CorruptError((int)(71219)));
    }

    return (int)(rc);
}</function>
  <function>public static int accessPayloadChecked(BtCursor pCur, uint offset, uint amt, void* pBuf)
{
    int rc = 0;
    if ((pCur.eState) == (1))
    {
        return (int)(4);
    }

    rc = (int)(btreeRestoreCursorPosition(pCur));
    return (int)((rc) != 0 ? rc : accessPayload(pCur, (uint)(offset), (uint)(amt), pBuf, (int)(0)));
}</function>
  <function>public static sbyte* actionName(byte action)
{
    sbyte* zName;
    switch (action)
    {
        case 8:
            zName = "SET NULL";
            break;
        case 9:
            zName = "SET DEFAULT";
            break;
        case 10:
            zName = "CASCADE";
            break;
        case 7:
            zName = "RESTRICT";
            break;
        default:
            zName = "NO ACTION";
            break;
    }

    return zName;
}</function>
  <function>public static int addAggInfoColumn(sqlite3 db, AggInfo pInfo)
{
    int i = 0;
    pInfo.aCol = sqlite3ArrayAllocate(db, pInfo.aCol, (int)(sizeof(AggInfo_col)), &amp;pInfo.nColumn, &amp;i);
    return (int)(i);
}</function>
  <function>public static int addAggInfoFunc(sqlite3 db, AggInfo pInfo)
{
    int i = 0;
    pInfo.aFunc = sqlite3ArrayAllocate(db, pInfo.aFunc, (int)(sizeof(AggInfo_func)), &amp;pInfo.nFunc, &amp;i);
    return (int)(i);
}</function>
  <function>public static void addArgumentToVtab(Parse pParse)
{
    if (((pParse.sArg.z) != null) &amp;&amp; ((pParse.pNewTable) != null))
    {
        sbyte* z = pParse.sArg.z;
        int n = (int)(pParse.sArg.n);
        sqlite3 db = pParse.db;
        addModuleArgument(pParse, pParse.pNewTable, sqlite3DbStrNDup(db, z, (ulong)(n)));
    }
}</function>
  <function>public static void addModuleArgument(Parse pParse, Table pTable, sbyte* zArg)
{
    long nBytes = 0;
    sbyte** azModuleArg;
    sqlite3 db = pParse.db;
    nBytes = (long)(sizeof(char*) * (2 + pTable.u.vtab.nArg));
    if ((pTable.u.vtab.nArg + 3) &gt;= (db.aLimit[2]))
    {
        sqlite3ErrorMsg(pParse, "too many columns on %s", pTable.zName);
    }

    azModuleArg = sqlite3DbRealloc(db, pTable.u.vtab.azArg, (ulong)(nBytes));
    if ((azModuleArg) == (null))
    {
        sqlite3DbFree(db, zArg);
    }
    else
    {
        int i = (int)(pTable.u.vtab.nArg++);
        azModuleArg[i] = zArg;
        azModuleArg[i + 1] = null;
        pTable.u.vtab.azArg = azModuleArg;
    }
}</function>
  <function>public static int addToSavepointBitvecs(Pager pPager, uint pgno)
{
    int ii = 0;
    int rc = (int)(0);
    for (ii = (int)(0); (ii) &lt; (pPager.nSavepoint); ii++)
    {
        PagerSavepoint* p = &amp;pPager.aSavepoint[ii];
        if ((pgno) &lt;= (p-&gt;nOrig))
        {
            rc |= (int)(sqlite3BitvecSet(p-&gt;pInSavepoint, (uint)(pgno)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static void addToVTrans(sqlite3 db, VTable pVTab)
{
    db.aVTrans[db.nVTrans++] = pVTab;
    sqlite3VtabLock(pVTab);
}</function>
  <function>public static void addWhereTerm(Parse pParse, SrcList pSrc, int iLeft, int iColLeft, int iRight, int iColRight, int isOuterJoin, Expr ppWhere)
{
    sqlite3 db = pParse.db;
    Expr pE1;
    Expr pE2;
    Expr pEq;
    pE1 = sqlite3CreateColumnExpr(db, pSrc, (int)(iLeft), (int)(iColLeft));
    pE2 = sqlite3CreateColumnExpr(db, pSrc, (int)(iRight), (int)(iColRight));
    pEq = sqlite3PExpr(pParse, (int)(53), pE1, pE2);
    if (((pEq) != null) &amp;&amp; ((isOuterJoin) != 0))
    {
        (pEq).flags |= (uint)(0x000001);
        pEq.w.iRightJoinTable = (int)(pE2.iTable);
    }

    ppWhere = sqlite3ExprAnd(pParse, ppWhere, pEq);
}</function>
  <function>public static void agginfoFree(sqlite3 db, AggInfo p)
{
    sqlite3DbFree(db, p.aCol);
    sqlite3DbFree(db, p.aFunc);
    sqlite3DbFreeNN(db, p);
}</function>
  <function>public static int agginfoPersistExprCb(Walker pWalker, Expr pExpr)
{
    if (((!(((pExpr).flags &amp; (0x004000 | 0x002000)) != 0)) != 0) &amp;&amp; (pExpr.pAggInfo != null))
    {
        AggInfo pAggInfo = pExpr.pAggInfo;
        int iAgg = (int)(pExpr.iAgg);
        Parse pParse = pWalker.pParse;
        sqlite3 db = pParse.db;
        if ((pExpr.op) == (169))
        {
            if ((pAggInfo.aCol[iAgg].pCExpr) == (pExpr))
            {
                pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
                if ((pExpr) != null)
                {
                    pAggInfo.aCol[iAgg].pCExpr = pExpr;
                    sqlite3ExprDeferredDelete(pParse, pExpr);
                }
            }
        }
        else
        {
            if ((pAggInfo.aFunc[iAgg].pFExpr) == (pExpr))
            {
                pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
                if ((pExpr) != null)
                {
                    pAggInfo.aFunc[iAgg].pFExpr = pExpr;
                    sqlite3ExprDeferredDelete(pParse, pExpr);
                }
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int allocateBtreePage(BtShared pBt, MemPage ppPage, uint* pPgno, uint nearby, byte eMode)
{
    MemPage pPage1;
    int rc = 0;
    uint n = 0;
    uint k = 0;
    MemPage pTrunk = null;
    MemPage pPrevTrunk = null;
    uint mxPage = 0;
    pPage1 = pBt.pPage1;
    mxPage = (uint)(btreePagecount(pBt));
    n = (uint)(sqlite3Get4byte(&amp;pPage1.aData[36]));
    if ((n) &gt;= (mxPage))
    {
        return (int)(sqlite3CorruptError((int)(72266)));
    }

    if ((n) &gt; (0))
    {
        uint iTrunk = 0;
        byte searchList = (byte)(0);
        uint nSearch = (uint)(0);
        if ((eMode) == (1))
        {
            if ((nearby) &lt;= (mxPage))
            {
                byte eType = 0;
                rc = (int)(ptrmapGet(pBt, (uint)(nearby), &amp;eType, null));
                if ((rc) != 0)
                    return (int)(rc);
                if ((eType) == (2))
                {
                    searchList = (byte)(1);
                }
            }
        }
        else if ((eMode) == (2))
        {
            searchList = (byte)(1);
        }

        rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
        if ((rc) != 0)
            return (int)(rc);
        sqlite3Put4byte(&amp;pPage1.aData[36], (uint)(n - 1));
        do
        {
            pPrevTrunk = pTrunk;
            if ((pPrevTrunk) != null)
            {
                iTrunk = (uint)(sqlite3Get4byte(&amp;pPrevTrunk.aData[0]));
            }
            else
            {
                iTrunk = (uint)(sqlite3Get4byte(&amp;pPage1.aData[32]));
            }

            if (((iTrunk) &gt; (mxPage)) || ((nSearch++) &gt; (n)))
            {
                rc = (int)(sqlite3CorruptError((int)(72322)));
            }
            else
            {
                rc = (int)(btreeGetUnusedPage(pBt, (uint)(iTrunk), pTrunk, (int)(0)));
            }

            if ((rc) != 0)
            {
                pTrunk = null;
                goto end_allocate_page;
            }

            k = (uint)(sqlite3Get4byte(&amp;pTrunk.aData[4]));
            if (((k) == (0)) &amp;&amp; (searchList == 0))
            {
                rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
                if ((rc) != 0)
                {
                    goto end_allocate_page;
                }

                *pPgno = (uint)(iTrunk);
                CRuntime.memcpy(&amp;pPage1.aData[32], &amp;pTrunk.aData[0], (ulong)(4));
                ppPage = pTrunk;
                pTrunk = null;
            }
            else if ((k) &gt; (pBt.usableSize / 4 - 2))
            {
                rc = (int)(sqlite3CorruptError((int)(72351)));
                goto end_allocate_page;
            }
            else if (((searchList) != 0) &amp;&amp; (((nearby) == (iTrunk)) || (((iTrunk) &lt; (nearby)) &amp;&amp; ((eMode) == (2)))))
            {
                *pPgno = (uint)(iTrunk);
                ppPage = pTrunk;
                searchList = (byte)(0);
                rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
                if ((rc) != 0)
                {
                    goto end_allocate_page;
                }

                if ((k) == (0))
                {
                    if (pPrevTrunk == null)
                    {
                        CRuntime.memcpy(&amp;pPage1.aData[32], &amp;pTrunk.aData[0], (ulong)(4));
                    }
                    else
                    {
                        rc = (int)(sqlite3PagerWrite(pPrevTrunk.pDbPage));
                        if (rc != 0)
                        {
                            goto end_allocate_page;
                        }

                        CRuntime.memcpy(&amp;pPrevTrunk.aData[0], &amp;pTrunk.aData[0], (ulong)(4));
                    }
                }
                else
                {
                    MemPage pNewTrunk;
                    uint iNewTrunk = (uint)(sqlite3Get4byte(&amp;pTrunk.aData[8]));
                    if ((iNewTrunk) &gt; (mxPage))
                    {
                        rc = (int)(sqlite3CorruptError((int)(72385)));
                        goto end_allocate_page;
                    }

                    rc = (int)(btreeGetUnusedPage(pBt, (uint)(iNewTrunk), pNewTrunk, (int)(0)));
                    if (rc != 0)
                    {
                        goto end_allocate_page;
                    }

                    rc = (int)(sqlite3PagerWrite(pNewTrunk.pDbPage));
                    if (rc != 0)
                    {
                        releasePage(pNewTrunk);
                        goto end_allocate_page;
                    }

                    CRuntime.memcpy(&amp;pNewTrunk.aData[0], &amp;pTrunk.aData[0], (ulong)(4));
                    sqlite3Put4byte(&amp;pNewTrunk.aData[4], (uint)(k - 1));
                    CRuntime.memcpy(&amp;pNewTrunk.aData[8], &amp;pTrunk.aData[12], (ulong)((k - 1) * 4));
                    releasePage(pNewTrunk);
                    if (pPrevTrunk == null)
                    {
                        sqlite3Put4byte(&amp;pPage1.aData[32], (uint)(iNewTrunk));
                    }
                    else
                    {
                        rc = (int)(sqlite3PagerWrite(pPrevTrunk.pDbPage));
                        if ((rc) != 0)
                        {
                            goto end_allocate_page;
                        }

                        sqlite3Put4byte(&amp;pPrevTrunk.aData[0], (uint)(iNewTrunk));
                    }
                }

                pTrunk = null;
            }
            else if ((k) &gt; (0))
            {
                uint closest = 0;
                uint iPage = 0;
                byte* aData = pTrunk.aData;
                if ((nearby) &gt; (0))
                {
                    uint i = 0;
                    closest = (uint)(0);
                    if ((eMode) == (2))
                    {
                        for (i = (uint)(0); (i) &lt; (k); i++)
                        {
                            iPage = (uint)(sqlite3Get4byte(&amp;aData[8 + i * 4]));
                            if ((iPage) &lt;= (nearby))
                            {
                                closest = (uint)(i);
                                break;
                            }
                        }
                    }
                    else
                    {
                        int dist = 0;
                        dist = (int)(sqlite3AbsInt32((int)(sqlite3Get4byte(&amp;aData[8]) - nearby)));
                        for (i = (uint)(1); (i) &lt; (k); i++)
                        {
                            int d2 = (int)(sqlite3AbsInt32((int)(sqlite3Get4byte(&amp;aData[8 + i * 4]) - nearby)));
                            if ((d2) &lt; (dist))
                            {
                                closest = (uint)(i);
                                dist = (int)(d2);
                            }
                        }
                    }
                }
                else
                {
                    closest = (uint)(0);
                }

                iPage = (uint)(sqlite3Get4byte(&amp;aData[8 + closest * 4]));
                if (((iPage) &gt; (mxPage)) || ((iPage) &lt; (2)))
                {
                    rc = (int)(sqlite3CorruptError((int)(72450)));
                    goto end_allocate_page;
                }

                if ((searchList == 0) || (((iPage) == (nearby)) || (((iPage) &lt; (nearby)) &amp;&amp; ((eMode) == (2)))))
                {
                    int noContent = 0;
                    *pPgno = (uint)(iPage);
                    rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
                    if ((rc) != 0)
                        goto end_allocate_page;
                    if ((closest) &lt; (k - 1))
                    {
                        CRuntime.memcpy(&amp;aData[8 + closest * 4], &amp;aData[4 + k * 4], (ulong)(4));
                    }

                    sqlite3Put4byte(&amp;aData[4], (uint)(k - 1));
                    noContent = (int)((!btreeGetHasContent(pBt, (uint)(*pPgno))) != 0 ? 0x01 : 0);
                    rc = (int)(btreeGetUnusedPage(pBt, (uint)(*pPgno), ppPage, (int)(noContent)));
                    if ((rc) == (0))
                    {
                        rc = (int)(sqlite3PagerWrite((ppPage).pDbPage));
                        if (rc != 0)
                        {
                            releasePage(ppPage);
                            ppPage = null;
                        }
                    }

                    searchList = (byte)(0);
                }
            }

            releasePage(pPrevTrunk);
            pPrevTrunk = null;
        }
        while ((searchList) != 0);
    }
    else
    {
        int bNoContent = (int)(((0) == (pBt.bDoTruncate)) ? 0x01 : 0);
        rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
        if ((rc) != 0)
            return (int)(rc);
        pBt.nPage++;
        if ((pBt.nPage) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
            pBt.nPage++;
        if (((pBt.autoVacuum) != 0) &amp;&amp; ((ptrmapPageno((pBt), (uint)(pBt.nPage))) == (pBt.nPage)))
        {
            MemPage pPg = null;
            rc = (int)(btreeGetUnusedPage(pBt, (uint)(pBt.nPage), pPg, (int)(bNoContent)));
            if ((rc) == (0))
            {
                rc = (int)(sqlite3PagerWrite(pPg.pDbPage));
                releasePage(pPg);
            }

            if ((rc) != 0)
                return (int)(rc);
            pBt.nPage++;
            if ((pBt.nPage) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
            {
                pBt.nPage++;
            }
        }

        sqlite3Put4byte(28 + pBt.pPage1.aData, (uint)(pBt.nPage));
        *pPgno = (uint)(pBt.nPage);
        rc = (int)(btreeGetUnusedPage(pBt, (uint)(*pPgno), ppPage, (int)(bNoContent)));
        if ((rc) != 0)
            return (int)(rc);
        rc = (int)(sqlite3PagerWrite((ppPage).pDbPage));
        if (rc != 0)
        {
            releasePage(ppPage);
            ppPage = null;
        }
    }

    end_allocate_page:
        ; releasePage ( pTrunk ) ; 
    releasePage(pPrevTrunk);
    return (int)(rc);
}</function>
  <function>public static VdbeCursor allocateCursor(Vdbe p, int iCur, int nField, byte eCurType)
{
    sqlite3_value pMem = (iCur) &gt; (0) ? p.aMem[p.nMem - iCur] : p.aMem;
    int nByte = 0;
    VdbeCursor pCx = null;
    nByte = (int)((((sizeof(VdbeCursor)) + 7) &amp; ~7) + 2 * sizeof(uint) * nField + ((eCurType) == (0) ? sqlite3BtreeCursorSize() : 0));
    if ((p.apCsr[iCur]) != null)
    {
        sqlite3VdbeFreeCursor(p, p.apCsr[iCur]);
        p.apCsr[iCur] = null;
    }

    if ((pMem.szMalloc) &lt; (nByte))
    {
        if ((pMem.szMalloc) &gt; (0))
        {
            sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
        }

        pMem.z = pMem.zMalloc = sqlite3DbMallocRaw(pMem.db, (ulong)(nByte));
        if ((pMem.zMalloc) == (null))
        {
            pMem.szMalloc = (int)(0);
            return null;
        }

        pMem.szMalloc = (int)(nByte);
    }

    p.apCsr[iCur] = pCx = (VdbeCursor)(pMem.zMalloc);
    CRuntime.memset(pCx, (int)(0), ((ulong)((0).pAltCursor)));
    pCx.eCurType = (byte)(eCurType);
    pCx.nField = (short)(nField);
    pCx.aOffset = &amp;pCx.aType[nField];
    if ((eCurType) == (0))
    {
        pCx.uc.pCursor = (BtCursor)(&amp;pMem.z[(((sizeof(VdbeCursor)) + 7) &amp; ~7) + 2 * sizeof(uint) * nField]);
        sqlite3BtreeCursorZero(pCx.uc.pCursor);
    }

    return pCx;
}</function>
  <function>public static sqlite3_index_info* allocateIndexInfo(WhereInfo pWInfo, WhereClause pWC, ulong mUnusable, SrcItem pSrc, ushort* pmNoOmit)
{
    int i = 0; int  j  =  0 ; 
    int nTerm = 0;
    Parse pParse = pWInfo.pParse;
    sqlite3_index_constraint* pIdxCons;
    sqlite3_index_orderby* pIdxOrderBy;
    sqlite3_index_constraint_usage* pUsage;
    HiddenIndexInfo pHidden;
    WhereTerm pTerm;
    int nOrderBy = 0;
    sqlite3_index_info* pIdxInfo;
    ushort mNoOmit = (ushort)(0);
    Table pTab;
    int eDistinct = (int)(0);
    ExprList pOrderBy = pWInfo.pOrderBy;
    pTab = pSrc.pTab;
    for (i = (int)(nTerm = (int)(0)), pTerm = pWC.a; (i) &lt; (pWC.nTerm); i++, pTerm++)
    {
        pTerm.wtFlags &amp;= (ushort)(~0x0040);
        if (pTerm.leftCursor != pSrc.iCursor)
            continue;
        if ((pTerm.prereqRight &amp; mUnusable) != 0)
            continue;
        if ((pTerm.eOperator &amp; ~(0x0800)) == (0))
            continue;
        if ((pTerm.wtFlags &amp; 0x0080) != 0)
            continue;
        if (((pSrc.fg.jointype &amp; 0x0008) != 0) &amp;&amp; (!(((pTerm.pExpr).flags &amp; (0x000001)) != 0)))
        {
            continue;
        }

        nTerm++;
        pTerm.wtFlags |= (ushort)(0x0040);
    }

    nOrderBy = (int)(0);
    if ((pOrderBy) != null)
    {
        int n = (int)(pOrderBy.nExpr);
        for (i = (int)(0); (i) &lt; (n); i++)
        {
            Expr pExpr = pOrderBy.a[i].pExpr;
            Expr pE2;
            if ((sqlite3ExprIsConstant(pExpr)) != 0)
            {
                continue;
            }

            if ((pOrderBy.a[i].sortFlags &amp; 0x02) != 0)
                break;
            if (((pExpr.op) == (167)) &amp;&amp; ((pExpr.iTable) == (pSrc.iCursor)))
            {
                continue;
            }

            if ((((pExpr.op) == (113)) &amp;&amp; (((pE2 = pExpr.pLeft).op) == (167))) &amp;&amp; ((pE2.iTable) == (pSrc.iCursor)))
            {
                sbyte* zColl;
                pExpr.iColumn = (short)(pE2.iColumn);
                if ((pE2.iColumn) &lt; (0))
                    continue;
                zColl = sqlite3ColumnColl(&amp;pTab.aCol[pE2.iColumn]);
                if ((zColl) == (null))
                    zColl = sqlite3StrBINARY;
                if ((sqlite3_stricmp(pExpr.u.zToken, zColl)) == (0))
                    continue;
            }

            break;
        }

        if ((i) == (n))
        {
            nOrderBy = (int)(n);
            if ((pWInfo.wctrlFlags &amp; (0x0040 | 0x0080)) != 0)
            {
                eDistinct = (int)(1 + ((pWInfo.wctrlFlags &amp; 0x0080) != 0));
            }
        }
    }

    pIdxInfo = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(sqlite3_index_info) + (sizeof(sqlite3_index_constraint) + sizeof(sqlite3_index_constraint_usage)) * nTerm + sizeof(sqlite3_index_orderby) * nOrderBy + sizeof(HiddenIndexInfo) + sizeof(sqlite3_value) * nTerm));
    if ((pIdxInfo) == (null))
    {
        sqlite3ErrorMsg(pParse, "out of memory");
        return null;
    }

    pHidden = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    pIdxCons = (sqlite3_index_constraint*)(pHidden.aRhs[nTerm]);
    pIdxOrderBy = (sqlite3_index_orderby*)(&amp;pIdxCons[nTerm]);
    pUsage = (sqlite3_index_constraint_usage*)(&amp;pIdxOrderBy[nOrderBy]);
    pIdxInfo-&gt;aConstraint = pIdxCons;
    pIdxInfo-&gt;aOrderBy = pIdxOrderBy;
    pIdxInfo-&gt;aConstraintUsage = pUsage;
    pHidden.pWC = pWC;
    pHidden.pParse = pParse;
    pHidden.eDistinct = (int)(eDistinct);
    pHidden.mIn = (uint)(0);
    for (i = (int)(j = (int)(0)), pTerm = pWC.a; (i) &lt; (pWC.nTerm); i++, pTerm++)
    {
        ushort op = 0;
        if ((pTerm.wtFlags &amp; 0x0040) == (0))
            continue;
        pIdxCons[j].iColumn = (int)(pTerm.u.x.leftColumn);
        pIdxCons[j].iTermOffset = (int)(i);
        op = (ushort)(pTerm.eOperator &amp; 0x1fff);
        if ((op) == (0x0001))
        {
            if ((pTerm.wtFlags &amp; 0x8000) == (0))
            {
                pHidden.mIn |= (uint)((j) &lt;= (31) ? ((uint)(1)) &lt;&lt; (j) : 0);
            }

            op = (ushort)(0x0002);
        }

        if ((op) == (0x0040))
        {
            pIdxCons[j].op = (byte)(pTerm.eMatchOp);
        }
        else if ((op &amp; (0x0100 | 0x0080)) != 0)
        {
            if ((op) == (0x0100))
            {
                pIdxCons[j].op = (byte)(71);
            }
            else
            {
                pIdxCons[j].op = (byte)(72);
            }
        }
        else
        {
            pIdxCons[j].op = ((byte)(op));
            if (((op &amp; ((0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)) | (0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) != 0) &amp;&amp; ((sqlite3ExprIsVector(pTerm.pExpr.pRight)) != 0))
            {
                if ((j) &lt; (16))
                    mNoOmit |= (ushort)(1 &lt;&lt; j);
                if ((op) == (0x0002 &lt;&lt; (56 - 53)))
                    pIdxCons[j].op = (byte)(0x0002 &lt;&lt; (55 - 53));
                if ((op) == (0x0002 &lt;&lt; (54 - 53)))
                    pIdxCons[j].op = (byte)(0x0002 &lt;&lt; (57 - 53));
            }
        }

        j++;
    }

    pIdxInfo-&gt;nConstraint = (int)(j);
    for (i = (int)(j = (int)(0)); (i) &lt; (nOrderBy); i++)
    {
        Expr pExpr = pOrderBy.a[i].pExpr;
        if ((sqlite3ExprIsConstant(pExpr)) != 0)
            continue;
        pIdxOrderBy[j].iColumn = (int)(pExpr.iColumn);
        pIdxOrderBy[j].desc = (byte)(pOrderBy.a[i].sortFlags &amp; 0x01);
        j++;
    }

    pIdxInfo-&gt;nOrderBy = (int)(j);
    *pmNoOmit = (ushort)(mNoOmit);
    return pIdxInfo;
}</function>
  <function>public static int allocateSpace(MemPage pPage, int nByte, int* pIdx)
{
    int hdr = (int)(pPage.hdrOffset);
    byte* data = pPage.aData;
    int top = 0;
    int rc = (int)(0);
    int gap = 0;
    gap = (int)(pPage.cellOffset + 2 * pPage.nCell);
    top = (int)((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]);
    if ((gap) &gt; (top))
    {
        if (((top) == (0)) &amp;&amp; ((pPage.pBt.usableSize) == (65536)))
        {
            top = (int)(65536);
        }
        else
        {
            return (int)(sqlite3CorruptError((int)(67844)));
        }
    }

    if ((((data[hdr + 2]) != 0) || ((data[hdr + 1]) != 0)) &amp;&amp; ((gap + 2) &lt;= (top)))
    {
        byte* pSpace = pageFindSlot(pPage, (int)(nByte), &amp;rc);
        if ((pSpace) != null)
        {
            int g2 = 0;
            *pIdx = (int)(g2 = ((int)(pSpace - data)));
            if ((g2) &lt;= (gap))
            {
                return (int)(sqlite3CorruptError((int)(67862)));
            }
            else
            {
                return (int)(0);
            }
        }
        else if ((rc) != 0)
        {
            return (int)(rc);
        }
    }

    if ((gap + 2 + nByte) &gt; (top))
    {
        rc = (int)(defragmentPage(pPage, (int)((4) &lt; (pPage.nFree - (2 + nByte)) ? (4) : (pPage.nFree - (2 + nByte)))));
        if ((rc) != 0)
            return (int)(rc);
        top = (int)(((((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]) - 1) &amp; 0xffff) + 1);
    }

    top -= (int)(nByte);
    ((&amp;data[hdr + 5])[0] = ((byte)((top) &gt;&gt; 8)), (&amp;data[hdr + 5])[1] = ((byte)(top)));
    *pIdx = (int)(top);
    return (int)(0);
}</function>
  <function>public static int allocateTempSpace(BtShared pBt)
{
    pBt.pTmpSpace = sqlite3PageMalloc((int)(pBt.pageSize));
    if ((pBt.pTmpSpace) == (null))
    {
        BtCursor pCur = pBt.pCursor;
        pBt.pCursor = pCur.pNext;
        CRuntime.memset(pCur, (int)(0), (ulong)(sizeof(BtCursor)));
        return (int)(7);
    }

    CRuntime.memset(pBt.pTmpSpace, (int)(0), (ulong)(8));
    pBt.pTmpSpace += 4;
    return (int)(0);
}</function>
  <function>public static void* allocSpace(ReusableSpace* p, void* pBuf, long nByte)
{
    if ((pBuf) == (null))
    {
        nByte = (long)(((nByte) + 7) &amp; ~7);
        if ((nByte) &lt;= (p-&gt;nFree))
        {
            p-&gt;nFree -= (long)(nByte);
            pBuf = &amp;p-&gt;pSpace[p-&gt;nFree];
        }
        else
        {
            p-&gt;nNeeded += (long)(nByte);
        }
    }

    return pBuf;
}</function>
  <function>public static int allowedOp(int op)
{
    return (((((op) == (49)) || (((op) &gt;= (53)) &amp;&amp; ((op) &lt;= (57)))) || ((op) == (50))) || ((op) == (45)) ? 1 : 0);
}</function>
  <function>public static int alsoAnInt(sqlite3_value pRec, double rValue, long* piValue)
{
    long iValue = (long)(rValue);
    if ((sqlite3RealSameAsInt((double)(rValue), (long)(iValue))) != 0)
    {
        *piValue = (long)(iValue);
        return (int)(1);
    }

    return ((0) == (sqlite3Atoi64(pRec.z, piValue, (int)(pRec.n), (byte)(pRec.enc))) ? 1 : 0);
}</function>
  <function>public static int analysisLoader(void* pData, int argc, sbyte** argv, sbyte** NotUsed)
{
    analysisInfo pInfo = (analysisInfo)(pData);
    Index pIndex;
    Table pTable;
    sbyte* z;
    if ((((argv) == (null)) || ((argv[0]) == (null))) || ((argv[2]) == (null)))
    {
        return (int)(0);
    }

    pTable = sqlite3FindTable(pInfo.db, argv[0], pInfo.zDatabase);
    if ((pTable) == (null))
    {
        return (int)(0);
    }

    if ((argv[1]) == (null))
    {
        pIndex = null;
    }
    else if ((sqlite3_stricmp(argv[0], argv[1])) == (0))
    {
        pIndex = sqlite3PrimaryKeyIndex(pTable);
    }
    else
    {
        pIndex = sqlite3FindIndex(pInfo.db, argv[1], pInfo.zDatabase);
    }

    z = argv[2];
    if ((pIndex) != null)
    {
        uint* aiRowEst = null;
        int nCol = (int)(pIndex.nKeyCol + 1);
        pIndex.bUnordered = (uint)(0);
        decodeIntArray(z, (int)(nCol), aiRowEst, pIndex.aiRowLogEst, pIndex);
        pIndex.hasStat1 = (uint)(1);
        if ((pIndex.pPartIdxWhere) == (null))
        {
            pTable.nRowLogEst = (short)(pIndex.aiRowLogEst[0]);
            pTable.tabFlags |= (uint)(0x00000010);
        }
    }
    else
    {
        Index fakeIdx = new Index();
        fakeIdx.szIdxRow = (short)(pTable.szTabRow);
        decodeIntArray(z, (int)(1), null, &amp;pTable.nRowLogEst, fakeIdx);
        pTable.szTabRow = (short)(fakeIdx.szIdxRow);
        pTable.tabFlags |= (uint)(0x00000010);
    }

    return (int)(0);
}</function>
  <function>public static int analyzeAggregate(Walker pWalker, Expr pExpr)
{
    int i = 0;
    NameContext pNC = pWalker.u.pNC;
    Parse pParse = pNC.pParse;
    SrcList pSrcList = pNC.pSrcList;
    AggInfo pAggInfo = pNC.uNC.pAggInfo;
    switch (pExpr.op)
    {
        case 169:
        case 167:
        {
            if ((pSrcList != null))
            {
                SrcItem pItem = pSrcList.a;
                for (i = (int)(0); (i) &lt; (pSrcList.nSrc); i++, pItem++)
                {
                    AggInfo_col pCol;
                    if ((pExpr.iTable) == (pItem.iCursor))
                    {
                        int k = 0;
                        pCol = pAggInfo.aCol;
                        for (k = (int)(0); (k) &lt; (pAggInfo.nColumn); k++, pCol++)
                        {
                            if (((pCol.iTable) == (pExpr.iTable)) &amp;&amp; ((pCol.iColumn) == (pExpr.iColumn)))
                            {
                                break;
                            }
                        }

                        if (((k) &gt;= (pAggInfo.nColumn)) &amp;&amp; ((k = (int)(addAggInfoColumn(pParse.db, pAggInfo))) &gt;= (0)))
                        {
                            pCol = pAggInfo.aCol[k];
                            pCol.pTab = pExpr.y.pTab;
                            pCol.iTable = (int)(pExpr.iTable);
                            pCol.iColumn = (short)(pExpr.iColumn);
                            pCol.iMem = (int)(++pParse.nMem);
                            pCol.iSorterColumn = (short)(-1);
                            pCol.pCExpr = pExpr;
                            if ((pAggInfo.pGroupBy) != null)
                            {
                                int j = 0;
                                int n = 0;
                                ExprList pGB = pAggInfo.pGroupBy;
                                ExprList_item* pTerm = pGB.a;
                                n = (int)(pGB.nExpr);
                                for (j = (int)(0); (j) &lt; (n); j++, pTerm++)
                                {
                                    Expr pE = pTerm-&gt;pExpr;
                                    if ((((pE.op) == (167)) &amp;&amp; ((pE.iTable) == (pExpr.iTable))) &amp;&amp; ((pE.iColumn) == (pExpr.iColumn)))
                                    {
                                        pCol.iSorterColumn = (short)(j);
                                        break;
                                    }
                                }
                            }

                            if ((pCol.iSorterColumn) &lt; (0))
                            {
                                pCol.iSorterColumn = (short)(pAggInfo.nSortingColumn++);
                            }
                        }

                        pExpr.pAggInfo = pAggInfo;
                        pExpr.op = (byte)(169);
                        pExpr.iAgg = ((short)(k));
                        break;
                    }
                }
            }

            return (int)(1);
        }

        case 168:
        {
            if (((pNC.ncFlags &amp; 0x020000) == (0)) &amp;&amp; ((pWalker.walkerDepth) == (pExpr.op2)))
            {
                AggInfo_func pItem = pAggInfo.aFunc;
                for (i = (int)(0); (i) &lt; (pAggInfo.nFunc); i++, pItem++)
                {
                    if ((pItem.pFExpr) == (pExpr))
                        break;
                    if ((sqlite3ExprCompare(null, pItem.pFExpr, pExpr, (int)(-1))) == (0))
                    {
                        break;
                    }
                }

                if ((i) &gt;= (pAggInfo.nFunc))
                {
                    byte enc = (byte)((pParse.db).enc);
                    i = (int)(addAggInfoFunc(pParse.db, pAggInfo));
                    if ((i) &gt;= (0))
                    {
                        pItem = pAggInfo.aFunc[i];
                        pItem.pFExpr = pExpr;
                        pItem.iMem = (int)(++pParse.nMem);
                        pItem.pFunc = sqlite3FindFunction(pParse.db, pExpr.u.zToken, (int)(pExpr.x.pList ? pExpr.x.pList.nExpr : 0), (byte)(enc), (byte)(0));
                        if ((pExpr.flags &amp; 0x000002) != 0)
                        {
                            pItem.iDistinct = (int)(pParse.nTab++);
                        }
                        else
                        {
                            pItem.iDistinct = (int)(-1);
                        }
                    }
                }

                pExpr.iAgg = ((short)(i));
                pExpr.pAggInfo = pAggInfo;
                return (int)(1);
            }
            else
            {
                return (int)(0);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static void analyzeDatabase(Parse pParse, int iDb)
{
    sqlite3 db = pParse.db;
    Schema pSchema = db.aDb[iDb].pSchema;
    HashElem* k;
    int iStatCur = 0;
    int iMem = 0;
    int iTab = 0;
    sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
    iStatCur = (int)(pParse.nTab);
    pParse.nTab += (int)(3);
    openStatTable(pParse, (int)(iDb), (int)(iStatCur), null, null);
    iMem = (int)(pParse.nMem + 1);
    iTab = (int)(pParse.nTab);
    for (k = ((&amp;pSchema.tblHash)-&gt;first); k; k = ((k)-&gt;next))
    {
        Table pTab = (Table)((k)-&gt;data);
        analyzeOneTable(pParse, pTab, null, (int)(iStatCur), (int)(iMem), (int)(iTab));
    }

    loadAnalysis(pParse, (int)(iDb));
}</function>
  <function>public static int analyzeFilterKeyword(byte* z, int lastToken)
{
    if (((lastToken) == (23)) &amp;&amp; ((getToken(&amp;z)) == (22)))
    {
        return (int)(166);
    }

    return (int)(59);
}</function>
  <function>public static void analyzeOneTable(Parse pParse, Table pTab, Index pOnlyIdx, int iStatCur, int iMem, int iTab)
{
    sqlite3 db = pParse.db;
    Index pIdx;
    int iIdxCur = 0;
    int iTabCur = 0;
    Vdbe v;
    int i = 0;
    int jZeroRows = (int)(-1);
    int iDb = 0;
    byte needTableCnt = (byte)(1);
    int regNewRowid = (int)(iMem++);
    int regStat = (int)(iMem++);
    int regChng = (int)(iMem++);
    int regRowid = (int)(iMem++);
    int regTemp = (int)(iMem++);
    int regTemp2 = (int)(iMem++);
    int regTabname = (int)(iMem++);
    int regIdxname = (int)(iMem++);
    int regStat1 = (int)(iMem++);
    int regPrev = (int)(iMem);
    pParse.nMem = (int)((pParse.nMem) &gt; (iMem) ? (pParse.nMem) : (iMem));
    v = sqlite3GetVdbe(pParse);
    if (((v) == (null)) || ((pTab) == (null)))
    {
        return;
    }

    if (!(((pTab).eTabType) == (0)))
    {
        return;
    }

    if ((sqlite3_strlike("sqlite\\_%", pTab.zName, (uint)(92))) == (0))
    {
        return;
    }

    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    if ((sqlite3AuthCheck(pParse, (int)(28), pTab.zName, null, db.aDb[iDb].zDbSName)) != 0)
    {
        return;
    }

    sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
    iTabCur = (int)(iTab++);
    iIdxCur = (int)(iTab++);
    pParse.nTab = (int)((pParse.nTab) &gt; (iTab) ? (pParse.nTab) : (iTab));
    sqlite3OpenTable(pParse, (int)(iTabCur), (int)(iDb), pTab, (int)(101));
    sqlite3VdbeLoadString(v, (int)(regTabname), pTab.zName);
    for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
    {
        int nCol = 0;
        int addrRewind = 0;
        int addrNextRow = 0;
        sbyte* zIdxName;
        int nColTest = 0;
        if (((pOnlyIdx) != null) &amp;&amp; (pOnlyIdx != pIdx))
            continue;
        if ((pIdx.pPartIdxWhere) == (null))
            needTableCnt = (byte)(0);
        if ((!(((pTab).tabFlags &amp; 0x00000080) == (0))) &amp;&amp; (((pIdx).idxType) == (2)))
        {
            nCol = (int)(pIdx.nKeyCol);
            zIdxName = pTab.zName;
            nColTest = (int)(nCol - 1);
        }
        else
        {
            nCol = (int)(pIdx.nColumn);
            zIdxName = pIdx.zName;
            nColTest = (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol - 1 : nCol - 1);
        }

        sqlite3VdbeLoadString(v, (int)(regIdxname), zIdxName);
        pParse.nMem = (int)((pParse.nMem) &gt; (regPrev + nColTest) ? (pParse.nMem) : (regPrev + nColTest));
        sqlite3VdbeAddOp3(v, (int)(101), (int)(iIdxCur), (int)(pIdx.tnum), (int)(iDb));
        sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(nCol), (int)(regStat + 1));
        sqlite3VdbeAddOp2(v, (int)(71), (int)(pIdx.nKeyCol), (int)(regRowid));
        {
            addrRewind = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iIdxCur)));
            sqlite3VdbeAddOp3(v, (int)(97), (int)(iIdxCur), (int)(regTemp), (int)(1));
        }

        sqlite3VdbeAddOp2(v, (int)(71), (int)(db.nAnalysisLimit), (int)(regTemp2));
        sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regStat + 1), (int)(regStat), (int)(4), statInitFuncdef, (int)(0));
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regChng));
        addrNextRow = (int)(sqlite3VdbeCurrentAddr(v));
        if ((nColTest) &gt; (0))
        {
            int endDistinctTest = (int)(sqlite3VdbeMakeLabel(pParse));
            int* aGotoChng;
            aGotoChng = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * nColTest));
            if ((aGotoChng) == (null))
                continue;
            sqlite3VdbeAddOp0(v, (int)(11));
            addrNextRow = (int)(sqlite3VdbeCurrentAddr(v));
            if ((((nColTest) == (1)) &amp;&amp; ((pIdx.nKeyCol) == (1))) &amp;&amp; ((pIdx).onError != 0))
            {
                sqlite3VdbeAddOp2(v, (int)(51), (int)(regPrev), (int)(endDistinctTest));
            }

            for (i = (int)(0); (i) &lt; (nColTest); i++)
            {
                sbyte* pColl = (sbyte*)(sqlite3LocateCollSeq(pParse, pIdx.azColl[i]));
                sqlite3VdbeAddOp2(v, (int)(71), (int)(i), (int)(regChng));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(i), (int)(regTemp));
                aGotoChng[i] = (int)(sqlite3VdbeAddOp4(v, (int)(52), (int)(regTemp), (int)(0), (int)(regPrev + i), pColl, (int)(-2)));
                sqlite3VdbeChangeP5(v, (ushort)(0x80));
            }

            sqlite3VdbeAddOp2(v, (int)(71), (int)(nColTest), (int)(regChng));
            sqlite3VdbeGoto(v, (int)(endDistinctTest));
            sqlite3VdbeJumpHere(v, (int)(addrNextRow - 1));
            for (i = (int)(0); (i) &lt; (nColTest); i++)
            {
                sqlite3VdbeJumpHere(v, (int)(aGotoChng[i]));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(i), (int)(regPrev + i));
            }

            sqlite3VdbeResolveLabel(v, (int)(endDistinctTest));
            sqlite3DbFree(db, aGotoChng);
        }

        {
            sqlite3VdbeAddFunctionCall(pParse, (int)(1), (int)(regStat), (int)(regTemp), (int)(2 + 0), statPushFuncdef, (int)(0));
            if ((db.nAnalysisLimit) != 0)
            {
                int j1 = 0;
                int j2 = 0;
                int j3 = 0;
                j1 = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(regTemp)));
                j2 = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(regTemp)));
                j3 = (int)(sqlite3VdbeAddOp4Int(v, (int)(26), (int)(iIdxCur), (int)(0), (int)(regPrev), (int)(1)));
                sqlite3VdbeJumpHere(v, (int)(j1));
                sqlite3VdbeAddOp2(v, (int)(5), (int)(iIdxCur), (int)(addrNextRow));
                sqlite3VdbeJumpHere(v, (int)(j2));
                sqlite3VdbeJumpHere(v, (int)(j3));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(5), (int)(iIdxCur), (int)(addrNextRow));
            }
        }

        callStatGet(pParse, (int)(regStat), (int)(0), (int)(regStat1));
        sqlite3VdbeAddOp4(v, (int)(96), (int)(regTabname), (int)(3), (int)(regTemp), "BBB", (int)(0));
        sqlite3VdbeAddOp2(v, (int)(126), (int)(iStatCur), (int)(regNewRowid));
        sqlite3VdbeAddOp3(v, (int)(127), (int)(iStatCur), (int)(regTemp), (int)(regNewRowid));
        sqlite3VdbeChangeP5(v, (ushort)(0x08));
        sqlite3VdbeJumpHere(v, (int)(addrRewind));
    }

    if (((pOnlyIdx) == (null)) &amp;&amp; ((needTableCnt) != 0))
    {
        sqlite3VdbeAddOp2(v, (int)(97), (int)(iTabCur), (int)(regStat1));
        jZeroRows = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regStat1)));
        sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regIdxname));
        sqlite3VdbeAddOp4(v, (int)(96), (int)(regTabname), (int)(3), (int)(regTemp), "BBB", (int)(0));
        sqlite3VdbeAddOp2(v, (int)(126), (int)(iStatCur), (int)(regNewRowid));
        sqlite3VdbeAddOp3(v, (int)(127), (int)(iStatCur), (int)(regTemp), (int)(regNewRowid));
        sqlite3VdbeChangeP5(v, (ushort)(0x08));
        sqlite3VdbeJumpHere(v, (int)(jZeroRows));
    }
}</function>
  <function>public static int analyzeOverKeyword(byte* z, int lastToken)
{
    if ((lastToken) == (23))
    {
        int t = (int)(getToken(&amp;z));
        if (((t) == (22)) || ((t) == (59)))
            return (int)(165);
    }

    return (int)(59);
}</function>
  <function>public static void analyzeTable(Parse pParse, Table pTab, Index pOnlyIdx)
{
    int iDb = 0;
    int iStatCur = 0;
    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
    sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
    iStatCur = (int)(pParse.nTab);
    pParse.nTab += (int)(3);
    if ((pOnlyIdx) != null)
    {
        openStatTable(pParse, (int)(iDb), (int)(iStatCur), pOnlyIdx.zName, "idx");
    }
    else
    {
        openStatTable(pParse, (int)(iDb), (int)(iStatCur), pTab.zName, "tbl");
    }

    analyzeOneTable(pParse, pTab, pOnlyIdx, (int)(iStatCur), (int)(pParse.nMem + 1), (int)(pParse.nTab));
    loadAnalysis(pParse, (int)(iDb));
}</function>
  <function>public static int analyzeWindowKeyword(byte* z)
{
    int t = 0;
    t = (int)(getToken(&amp;z));
    if (t != 59)
        return (int)(59);
    t = (int)(getToken(&amp;z));
    if (t != 24)
        return (int)(59);
    return (int)(164);
}</function>
  <function>public static int anotherValidCursor(BtCursor pCur)
{
    BtCursor pOther;
    for (pOther = pCur.pBt.pCursor; pOther; pOther = pOther.pNext)
    {
        if (((pOther != pCur) &amp;&amp; ((pOther.eState) == (0))) &amp;&amp; ((pOther.pPage) == (pCur.pPage)))
        {
            return (int)(sqlite3CorruptError((int)(74730)));
        }
    }

    return (int)(0);
}</function>
  <function>public static int apiHandleError(sqlite3 db, int rc)
{
    if (((db.mallocFailed) != 0) || ((rc) == (10 | (12 &lt;&lt; 8))))
    {
        sqlite3OomClear(db);
        sqlite3Error(db, (int)(7));
        return (int)(7);
    }

    return (int)(rc &amp; db.errMask);
}</function>
  <function>public static sbyte* appendText(sbyte* p, sbyte* z)
{
    ulong n = (ulong)(CRuntime.strlen(z));
    CRuntime.memcpy(p, z, (ulong)(n + 1));
    return p + n + 1;
}</function>
  <function>public static void applyAffinity(sqlite3_value pRec, sbyte affinity, byte enc)
{
    if ((affinity) &gt;= (0x43))
    {
        if ((pRec.flags &amp; 0x0004) == (0))
        {
            if ((pRec.flags &amp; 0x0008) == (0))
            {
                if ((pRec.flags &amp; 0x0002) != 0)
                    applyNumericAffinity(pRec, (int)(1));
            }
            else
            {
                sqlite3VdbeIntegerAffinity(pRec);
            }
        }
    }
    else if ((affinity) == (0x42))
    {
        if ((0) == (pRec.flags &amp; 0x0002))
        {
            if ((pRec.flags &amp; (0x0008 | 0x0004 | 0x0020)) != 0)
            {
                sqlite3VdbeMemStringify(pRec, (byte)(enc), (byte)(1));
            }
        }

        pRec.flags &amp;= (ushort)(~(0x0008 | 0x0004 | 0x0020));
    }
}</function>
  <function>public static void applyNumericAffinity(sqlite3_value pRec, int bTryForInt)
{
    double rValue = 0;
    byte enc = (byte)(pRec.enc);
    int rc = 0;
    rc = (int)(sqlite3AtoF(pRec.z, &amp;rValue, (int)(pRec.n), (byte)(enc)));
    if ((rc) &lt;= (0))
        return;
    if (((rc) == (1)) &amp;&amp; ((alsoAnInt(pRec, (double)(rValue), &amp;pRec.u.i)) != 0))
    {
        pRec.flags |= (ushort)(0x0004);
    }
    else
    {
        pRec.u.r = (double)(rValue);
        pRec.flags |= (ushort)(0x0008);
        if ((bTryForInt) != 0)
            sqlite3VdbeIntegerAffinity(pRec);
    }

    pRec.flags &amp;= (ushort)(~0x0002);
}</function>
  <function>public static int areDoubleQuotedStringsEnabled(sqlite3 db, NameContext pTopNC)
{
    if ((db.init.busy) != 0)
        return (int)(1);
    if ((pTopNC.ncFlags &amp; 0x010000) != 0)
    {
        if (((sqlite3WritableSchema(db)) != 0) &amp;&amp; ((db.flags &amp; 0x40000000) != 0))
        {
            return (int)(1);
        }

        return (int)((db.flags &amp; 0x20000000) != 0);
    }
    else
    {
        return (int)((db.flags &amp; 0x40000000) != 0);
    }
}</function>
  <function>public static void attachBackupObject(sqlite3_backup p)
{
    sqlite3_backup pp;
    pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p.pSrc));
    p.pNext = pp;
    pp = p;
    p.isAttached = (int)(1);
}</function>
  <function>public static void attachFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    int i = 0;
    int rc = (int)(0);
    sqlite3 db = sqlite3_context_db_handle(context);
    sbyte* zName;
    sbyte* zFile;
    sbyte* zPath = null;
    sbyte* zErr = null;
    uint flags = 0;
    Db aNew;
    Db pNew;
    sbyte* zErrDyn = null;
    sqlite3_vfs pVfs;
    zFile = (sbyte*)(sqlite3_value_text(argv[0]));
    zName = (sbyte*)(sqlite3_value_text(argv[1]));
    if ((zFile) == (null))
        zFile = "";
    if ((zName) == (null))
        zName = "";
    if ((db.init.reopenMemdb) != 0)
    {
        pVfs = sqlite3_vfs_find("memdb");
        if ((pVfs) == (null))
            return;
        pNew = db.aDb[db.init.iDb];
        if ((pNew.pBt) != null)
            sqlite3BtreeClose(pNew.pBt);
        pNew.pBt = null;
        pNew.pSchema = null;
        rc = (int)(sqlite3BtreeOpen(pVfs, "x\000", db, pNew.pBt, (int)(0), (int)(0x00000100)));
    }
    else
    {
        if ((db.nDb) &gt;= (db.aLimit[7] + 2))
        {
            zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", (int)(db.aLimit[7]));
            goto attach_error;
        }

        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            if ((sqlite3DbIsNamed(db, (int)(i), zName)) != 0)
            {
                zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
                goto attach_error;
            }
        }

        if ((db.aDb) == (db.aDbStatic))
        {
            aNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Db) * 3));
            if ((aNew) == (null))
                return;
            CRuntime.memcpy(aNew, db.aDb, (ulong)(sizeof(Db) * 2));
        }
        else
        {
            aNew = sqlite3DbRealloc(db, db.aDb, (ulong)(sizeof(Db) * (db.nDb + 1)));
            if ((aNew) == (null))
                return;
        }

        db.aDb = aNew;
        pNew = db.aDb[db.nDb];
        CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(Db)));
        flags = (uint)(db.openFlags);
        rc = (int)(sqlite3ParseUri(db.pVfs.zName, zFile, &amp;flags, pVfs, &amp;zPath, &amp;zErr));
        if (rc != 0)
        {
            if ((rc) == (7))
                sqlite3OomFault(db);
            sqlite3_result_error(context, zErr, (int)(-1));
            sqlite3_free(zErr);
            return;
        }

        flags |= (uint)(0x00000100);
        rc = (int)(sqlite3BtreeOpen(pVfs, zPath, db, pNew.pBt, (int)(0), (int)(flags)));
        db.nDb++;
        pNew.zDbSName = sqlite3DbStrDup(db, zName);
    }

    db.noSharedCache = (byte)(0);
    if ((rc) == (19))
    {
        rc = (int)(1);
        zErrDyn = sqlite3MPrintf(db, "database is already attached");
    }
    else if ((rc) == (0))
    {
        Pager pPager;
        pNew.pSchema = sqlite3SchemaGet(db, pNew.pBt);
        if (pNew.pSchema == null)
        {
            rc = (int)(7);
        }
        else if (((pNew.pSchema.file_format) != 0) &amp;&amp; (pNew.pSchema.enc != ((db).enc)))
        {
            zErrDyn = sqlite3MPrintf(db, "attached databases must use the same text encoding as main database");
            rc = (int)(1);
        }

        sqlite3BtreeEnter(pNew.pBt);
        pPager = sqlite3BtreePager(pNew.pBt);
        sqlite3PagerLockingMode(pPager, (int)(db.dfltLockMode));
        sqlite3BtreeSecureDelete(pNew.pBt, (int)(sqlite3BtreeSecureDelete(db.aDb[0].pBt, (int)(-1))));
        sqlite3BtreeSetPagerFlags(pNew.pBt, (uint)(0x03 | (db.flags &amp; 0x38)));
        sqlite3BtreeLeave(pNew.pBt);
    }

    pNew.safety_level = (byte)(2 + 1);
    if (((rc) == (0)) &amp;&amp; ((pNew.zDbSName) == (null)))
    {
        rc = (int)(7);
    }

    sqlite3_free_filename(zPath);
    if ((rc) == (0))
    {
        sqlite3BtreeEnterAll(db);
        db.init.iDb = (byte)(0);
        db.mDbFlags &amp;= (uint)(~(0x0010));
        if ((db.init.reopenMemdb) == 0)
        {
            rc = (int)(sqlite3Init(db, &amp;zErrDyn));
        }

        sqlite3BtreeLeaveAll(db);
    }

    if ((rc) != 0)
    {
        if ((db.init.reopenMemdb) == 0)
        {
            int iDb = (int)(db.nDb - 1);
            if ((db.aDb[iDb].pBt) != null)
            {
                sqlite3BtreeClose(db.aDb[iDb].pBt);
                db.aDb[iDb].pBt = null;
                db.aDb[iDb].pSchema = null;
            }

            sqlite3ResetAllSchemasOfConnection(db);
            db.nDb = (int)(iDb);
            if (((rc) == (7)) || ((rc) == (10 | (12 &lt;&lt; 8))))
            {
                sqlite3OomFault(db);
                sqlite3DbFree(db, zErrDyn);
                zErrDyn = sqlite3MPrintf(db, "out of memory");
            }
            else if ((zErrDyn) == (null))
            {
                zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
            }
        }

        goto attach_error;
    }

    return;
    attach_error:
        ; if  ( ( zErrDyn ) != null ) { sqlite3_result_error ( context ,  zErrDyn ,  ( int ) ( - 1 ) ) ;  sqlite3DbFree ( db ,  zErrDyn ) ;  }
    if ((rc) != 0)
        sqlite3_result_error_code(context, (int)(rc));
}</function>
  <function>public static Select attachWithToSelect(Parse pParse, Select pSelect, With pWith)
{
    if ((pSelect) != null)
    {
        pSelect.pWith = pWith;
        parserDoubleLinkSelect(pParse, pSelect);
    }
    else
    {
        sqlite3WithDelete(pParse.db, pWith);
    }

    return pSelect;
}</function>
  <function>public static int autoIncBegin(Parse pParse, int iDb, Table pTab)
{
    int memId = (int)(0);
    if (((pTab.tabFlags &amp; 0x00000008) != 0) &amp;&amp; ((pParse.db.mDbFlags &amp; 0x0004) == (0)))
    {
        Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
        AutoincInfo pInfo;
        Table pSeqTab = pParse.db.aDb[iDb].pSchema.pSeqTab;
        if (((((pSeqTab) == (null)) || (!(((pSeqTab).tabFlags &amp; 0x00000080) == (0)))) || ((((pSeqTab).eTabType) == (1)) != 0)) || (pSeqTab.nCol != 2))
        {
            pParse.nErr++;
            pParse.rc = (int)(11 | (2 &lt;&lt; 8));
            return (int)(0);
        }

        pInfo = pToplevel.pAinc;
        while (((pInfo) != null) &amp;&amp; (pInfo.pTab != pTab))
        {
            pInfo = pInfo.pNext;
        }

        if ((pInfo) == (null))
        {
            pInfo = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(AutoincInfo)));
            sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);
            if ((pParse.db.mallocFailed) != 0)
                return (int)(0);
            pInfo.pNext = pToplevel.pAinc;
            pToplevel.pAinc = pInfo;
            pInfo.pTab = pTab;
            pInfo.iDb = (int)(iDb);
            pToplevel.nMem++;
            pInfo.regCtr = (int)(++pToplevel.nMem);
            pToplevel.nMem += (int)(2);
        }

        memId = (int)(pInfo.regCtr);
    }

    return (int)(memId);
}</function>
  <function>public static void autoIncrementEnd(Parse pParse)
{
    AutoincInfo p;
    Vdbe v = pParse.pVdbe;
    sqlite3 db = pParse.db;
    for (p = pParse.pAinc; p; p = p.pNext)
    {
        VdbeOp* aOp;
        Db pDb = db.aDb[p.iDb];
        int iRec = 0;
        int memId = (int)(p.regCtr);
        iRec = (int)(sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp3(v, (int)(55), (int)(memId + 2), (int)(sqlite3VdbeCurrentAddr(v) + 7), (int)(memId));
        sqlite3OpenTable(pParse, (int)(0), (int)(p.iDb), pDb.pSchema.pSeqTab, (int)(112));
        aOp = sqlite3VdbeAddOpList(v, ((int)(5 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), autoIncrementEnd_autoIncEnd, (int)(autoIncrementEnd_iLn));
        if ((aOp) == (null))
            break;
        aOp[0].p1 = (int)(memId + 1);
        aOp[1].p2 = (int)(memId + 1);
        aOp[2].p1 = (int)(memId - 1);
        aOp[2].p3 = (int)(iRec);
        aOp[3].p2 = (int)(iRec);
        aOp[3].p3 = (int)(memId + 1);
        aOp[3].p5 = (ushort)(0x08);
        sqlite3ReleaseTempReg(pParse, (int)(iRec));
    }
}</function>
  <function>public static void autoIncStep(Parse pParse, int memId, int regRowid)
{
    if ((memId) &gt; (0))
    {
        sqlite3VdbeAddOp2(pParse.pVdbe, (int)(158), (int)(memId), (int)(regRowid));
    }
}</function>
  <function>public static int autoVacuumCommit(Btree p)
{
    int rc = (int)(0);
    Pager pPager;
    BtShared pBt;
    sqlite3 db;
    pBt = p.pBt;
    pPager = pBt.pPager;
    invalidateAllOverflowCache(pBt);
    if (pBt.incrVacuum == 0)
    {
        uint nFin = 0;
        uint nFree = 0;
        uint nVac = 0;
        uint iFree = 0;
        uint nOrig = 0;
        nOrig = (uint)(btreePagecount(pBt));
        if (((ptrmapPageno((pBt), (uint)(nOrig))) == (nOrig)) || ((nOrig) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
        {
            return (int)(sqlite3CorruptError((int)(70159)));
        }

        nFree = (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[36]));
        db = p.db;
        if ((db.xAutovacPages) != null)
        {
            int iDb = 0;
            for (iDb = (int)(0); ((iDb) &lt; (db.nDb)); iDb++)
            {
                if ((db.aDb[iDb].pBt) == (p))
                    break;
            }

            nVac = (uint)(db.xAutovacPages(db.pAutovacPagesArg, db.aDb[iDb].zDbSName, (uint)(nOrig), (uint)(nFree), (uint)(pBt.pageSize)));
            if ((nVac) &gt; (nFree))
            {
                nVac = (uint)(nFree);
            }

            if ((nVac) == (0))
            {
                return (int)(0);
            }
        }
        else
        {
            nVac = (uint)(nFree);
        }

        nFin = (uint)(finalDbSize(pBt, (uint)(nOrig), (uint)(nVac)));
        if ((nFin) &gt; (nOrig))
            return (int)(sqlite3CorruptError((int)(70186)));
        if ((nFin) &lt; (nOrig))
        {
            rc = (int)(saveAllCursors(pBt, (uint)(0), null));
        }

        for (iFree = (uint)(nOrig); ((iFree) &gt; (nFin)) &amp;&amp; ((rc) == (0)); iFree--)
        {
            rc = (int)(incrVacuumStep(pBt, (uint)(nFin), (uint)(iFree), ((nVac) == (nFree) ? 1 : 0)));
        }

        if ((((rc) == (101)) || ((rc) == (0))) &amp;&amp; ((nFree) &gt; (0)))
        {
            rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
            if ((nVac) == (nFree))
            {
                sqlite3Put4byte(&amp;pBt.pPage1.aData[32], (uint)(0));
                sqlite3Put4byte(&amp;pBt.pPage1.aData[36], (uint)(0));
            }

            sqlite3Put4byte(&amp;pBt.pPage1.aData[28], (uint)(nFin));
            pBt.bDoTruncate = (byte)(1);
            pBt.nPage = (uint)(nFin);
        }

        if (rc != 0)
        {
            sqlite3PagerRollback(pPager);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void avgFinalize(sqlite3_context context)
{
    SumCtx* p;
    p = sqlite3_aggregate_context(context, (int)(0));
    if (((p) != null) &amp;&amp; ((p-&gt;cnt) &gt; (0)))
    {
        sqlite3_result_double(context, (double)(p-&gt;rSum / (double)(p-&gt;cnt)));
    }
}</function>
  <function>public static int backupOnePage(sqlite3_backup p, uint iSrcPg, byte* zSrcData, int bUpdate)
{
    Pager pDestPager = sqlite3BtreePager(p.pDest);
    int nSrcPgsz = (int)(sqlite3BtreeGetPageSize(p.pSrc));
    int nDestPgsz = (int)(sqlite3BtreeGetPageSize(p.pDest));
    int nCopy = (int)((nSrcPgsz) &lt; (nDestPgsz) ? (nSrcPgsz) : (nDestPgsz));
    long iEnd = (long)((long)(iSrcPg) * (long)(nSrcPgsz));
    int rc = (int)(0);
    long iOff = 0;
    if ((nSrcPgsz != nDestPgsz) &amp;&amp; ((sqlite3PagerIsMemdb(pDestPager)) != 0))
    {
        rc = (int)(8);
    }

    for (iOff = (long)(iEnd - (long)(nSrcPgsz)); ((rc) == (0)) &amp;&amp; ((iOff) &lt; (iEnd)); iOff += (long)(nDestPgsz))
    {
        PgHdr pDestPg = null;
        uint iDest = (uint)((uint)(iOff / nDestPgsz) + 1);
        if ((iDest) == ((sqlite3PendingByte / ((p.pDest.pBt).pageSize)) + 1))
            continue;
        if (((0) == (rc = (int)(sqlite3PagerGet(pDestPager, (uint)(iDest), pDestPg, (int)(0))))) &amp;&amp; ((0) == (rc = (int)(sqlite3PagerWrite(pDestPg)))))
        {
            byte* zIn = &amp;zSrcData[iOff % nSrcPgsz];
            byte* zDestData = sqlite3PagerGetData(pDestPg);
            byte* zOut = &amp;zDestData[iOff % nDestPgsz];
            CRuntime.memcpy(zOut, zIn, (ulong)(nCopy));
            ((byte*)(sqlite3PagerGetExtra(pDestPg)))[0] = (byte)(0);
            if (((iOff) == (0)) &amp;&amp; ((bUpdate) == (0)))
            {
                sqlite3Put4byte(&amp;zOut[28], (uint)(sqlite3BtreeLastPage(p.pSrc)));
            }
        }

        sqlite3PagerUnref(pDestPg);
    }

    return (int)(rc);
}</function>
  <function>public static int backupTruncateFile(sqlite3_file pFile, long iSize)
{
    long iCurrent = 0;
    int rc = (int)(sqlite3OsFileSize(pFile, &amp;iCurrent));
    if (((rc) == (0)) &amp;&amp; ((iCurrent) &gt; (iSize)))
    {
        rc = (int)(sqlite3OsTruncate(pFile, (long)(iSize)));
    }

    return (int)(rc);
}</function>
  <function>public static void backupUpdate(sqlite3_backup p, uint iPage, byte* aData)
{
    do
    {
        if ((isFatalError((int)(p.rc)) == 0) &amp;&amp; ((iPage) &lt; (p.iNext)))
        {
            int rc = 0;
            sqlite3_mutex_enter(p.pDestDb.mutex);
            rc = (int)(backupOnePage(p, (uint)(iPage), aData, (int)(1)));
            sqlite3_mutex_leave(p.pDestDb.mutex);
            if (rc != 0)
            {
                p.rc = (int)(rc);
            }
        }
    }
    while ((p = p.pNext) != null);
}</function>
  <function>public static int balance(BtCursor pCur)
{
    int rc = (int)(0);
    int nMin = (int)(pCur.pBt.usableSize * 2 / 3);
    byte* aBalanceQuickSpace = stackalloc byte[13];
    byte* pFree = null;
    do
    {
        int iPage = 0;
        MemPage pPage = pCur.pPage;
        if (((pPage.nFree) &lt; (0)) &amp;&amp; ((btreeComputeFreeSpace(pPage)) != 0))
            break;
        if (((pPage.nOverflow) == (0)) &amp;&amp; ((pPage.nFree) &lt;= (nMin)))
        {
            break;
        }
        else if ((iPage = (int)(pCur.iPage)) == (0))
        {
            if (((pPage.nOverflow) != 0) &amp;&amp; ((rc = (int)(anotherValidCursor(pCur))) == (0)))
            {
                rc = (int)(balance_deeper(pPage, pCur.apPage[1]));
                if ((rc) == (0))
                {
                    pCur.iPage = (sbyte)(1);
                    pCur.ix = (ushort)(0);
                    pCur.aiIdx[0] = (ushort)(0);
                    pCur.apPage[0] = pPage;
                    pCur.pPage = pCur.apPage[1];
                }
            }
            else
            {
                break;
            }
        }
        else
        {
            MemPage pParent = pCur.apPage[iPage - 1];
            int iIdx = (int)(pCur.aiIdx[iPage - 1]);
            rc = (int)(sqlite3PagerWrite(pParent.pDbPage));
            if (((rc) == (0)) &amp;&amp; ((pParent.nFree) &lt; (0)))
            {
                rc = (int)(btreeComputeFreeSpace(pParent));
            }

            if ((rc) == (0))
            {
                if ((((((pPage.intKeyLeaf) != 0) &amp;&amp; ((pPage.nOverflow) == (1))) &amp;&amp; ((pPage.aiOvfl[0]) == (pPage.nCell))) &amp;&amp; (pParent.pgno != 1)) &amp;&amp; ((pParent.nCell) == (iIdx)))
                {
                    rc = (int)(balance_quick(pParent, pPage, aBalanceQuickSpace));
                }
                else
                {
                    byte* pSpace = sqlite3PageMalloc((int)(pCur.pBt.pageSize));
                    rc = (int)(balance_nonroot(pParent, (int)(iIdx), pSpace, ((iPage) == (1) ? 1 : 0), (int)(pCur.hints &amp; 0x00000001)));
                    if ((pFree) != null)
                    {
                        sqlite3PageFree(pFree);
                    }

                    pFree = pSpace;
                }
            }

            pPage.nOverflow = (byte)(0);
            releasePage(pPage);
            pCur.iPage--;
            pCur.pPage = pCur.apPage[pCur.iPage];
        }
    }
    while ((rc) == (0));
    if ((pFree) != null)
    {
        sqlite3PageFree(pFree);
    }

    return (int)(rc);
}</function>
  <function>public static int balance_deeper(MemPage pRoot, MemPage ppChild)
{
    int rc = 0;
    MemPage pChild = null;
    uint pgnoChild = (uint)(0);
    BtShared pBt = pRoot.pBt;
    rc = (int)(sqlite3PagerWrite(pRoot.pDbPage));
    if ((rc) == (0))
    {
        rc = (int)(allocateBtreePage(pBt, pChild, &amp;pgnoChild, (uint)(pRoot.pgno), (byte)(0)));
        copyNodeContent(pRoot, pChild, &amp;rc);
        if ((pBt.autoVacuum) != 0)
        {
            ptrmapPut(pBt, (uint)(pgnoChild), (byte)(5), (uint)(pRoot.pgno), &amp;rc);
        }
    }

    if ((rc) != 0)
    {
        ppChild = null;
        releasePage(pChild);
        return (int)(rc);
    }

    CRuntime.memcpy(pChild.aiOvfl, pRoot.aiOvfl, (ulong)(pRoot.nOverflow * sizeof(ushort)));
    CRuntime.memcpy(pChild.apOvfl, pRoot.apOvfl, (ulong)(pRoot.nOverflow * sizeof(byte*)));
    pChild.nOverflow = (byte)(pRoot.nOverflow);
    zeroPage(pRoot, (int)(pChild.aData[0] &amp; ~0x08));
    sqlite3Put4byte(&amp;pRoot.aData[pRoot.hdrOffset + 8], (uint)(pgnoChild));
    ppChild = pChild;
    return (int)(0);
}</function>
  <function>public static int balance_nonroot(MemPage pParent, int iParentIdx, byte* aOvflSpace, int isRoot, int bBulk)
{
    BtShared pBt;
    int nMaxCells = (int)(0);
    int nNew = (int)(0);
    int nOld = 0;
    int i = 0; int  j  =  0 ;  int  k  =  0 ; 
    int nxDiv = 0;
    int rc = (int)(0);
    ushort leafCorrection = 0;
    int leafData = 0;
    int usableSpace = 0;
    int pageFlags = 0;
    int iSpace1 = (int)(0);
    int iOvflSpace = (int)(0);
    int szScratch = 0;
    var apOld = new MemPage[3]; apOld [ 0 ]  =  new  MemPage ( ) ;  apOld [ 1 ]  =  new  MemPage ( ) ;  apOld [ 2 ]  =  new  MemPage ( ) ; 
    var apNew = new MemPage[5]; apNew [ 0 ]  =  new  MemPage ( ) ;  apNew [ 1 ]  =  new  MemPage ( ) ;  apNew [ 2 ]  =  new  MemPage ( ) ;  apNew [ 3 ]  =  new  MemPage ( ) ;  apNew [ 4 ]  =  new  MemPage ( ) ; 
    byte* pRight;
    byte** apDiv = stackalloc byte[2];
    int* cntNew = stackalloc int[5];
    int* cntOld = stackalloc int[5];
    int* szNew = stackalloc int[5];
    byte* aSpace1;
    uint pgno = 0;
    byte* abDone = stackalloc byte[5];
    uint* aPgno = stackalloc uint[5];
    uint* aPgOrder = stackalloc uint[5];
    ushort* aPgFlags = stackalloc ushort[5];
    CellArray b = new CellArray();
    CRuntime.memset(abDone, (int)(0), (ulong)(5 * sizeof(byte)));
    CRuntime.memset(b, (int)(0), (ulong)(sizeof(CellArray)));
    pBt = pParent.pBt;
    if (aOvflSpace == null)
    {
        return (int)(7);
    }

    i = (int)(pParent.nOverflow + pParent.nCell);
    if ((i) &lt; (2))
    {
        nxDiv = (int)(0);
    }
    else
    {
        if ((iParentIdx) == (0))
        {
            nxDiv = (int)(0);
        }
        else if ((iParentIdx) == (i))
        {
            nxDiv = (int)(i - 2 + bBulk);
        }
        else
        {
            nxDiv = (int)(iParentIdx - 1);
        }

        i = (int)(2 - bBulk);
    }

    nOld = (int)(i + 1);
    if ((i + nxDiv - pParent.nOverflow) == (pParent.nCell))
    {
        pRight = &amp;pParent.aData[pParent.hdrOffset + 8];
    }
    else
    {
        pRight = ((pParent).aData + ((pParent).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pParent).aCellIdx[2 * (i + nxDiv - pParent.nOverflow)])))));
    }

    pgno = (uint)(sqlite3Get4byte(pRight));
    while ((1) != 0)
    {
        if ((rc) == (0))
        {
            rc = (int)(getAndInitPage(pBt, (uint)(pgno), apOld[i], null, (int)(0)));
        }

        if ((rc) != 0)
        {
            CRuntime.memset(apOld, (int)(0), (ulong)((i + 1) * sizeof(MemPage)));
            goto balance_cleanup;
        }

        if ((apOld[i].nFree) &lt; (0))
        {
            rc = (int)(btreeComputeFreeSpace(apOld[i]));
            if ((rc) != 0)
            {
                CRuntime.memset(apOld, (int)(0), (ulong)((i) * sizeof(MemPage)));
                goto balance_cleanup;
            }
        }

        nMaxCells += (int)(apOld[i].nCell + ((int)(4 * sizeof(byte) / sizeof(byte*))));
        if ((i--) == (0))
            break;
        if (((pParent.nOverflow) != 0) &amp;&amp; ((i + nxDiv) == (pParent.aiOvfl[0])))
        {
            apDiv[i] = pParent.apOvfl[0];
            pgno = (uint)(sqlite3Get4byte(apDiv[i]));
            szNew[i] = (int)(pParent.xCellSize(pParent, apDiv[i]));
            pParent.nOverflow = (byte)(0);
        }
        else
        {
            apDiv[i] = ((pParent).aData + ((pParent).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pParent).aCellIdx[2 * (i + nxDiv - pParent.nOverflow)])))));
            pgno = (uint)(sqlite3Get4byte(apDiv[i]));
            szNew[i] = (int)(pParent.xCellSize(pParent, apDiv[i]));
            if ((pBt.btsFlags &amp; 0x000c) != 0)
            {
                int iOff = 0;
                iOff = (int)(((int)((long)(apDiv[i]))) - ((int)((long)(pParent.aData))));
                if ((iOff + szNew[i]) &lt;= ((int)(pBt.usableSize)))
                {
                    CRuntime.memcpy(&amp;aOvflSpace[iOff], apDiv[i], (ulong)(szNew[i]));
                    apDiv[i] = &amp;aOvflSpace[apDiv[i] - pParent.aData];
                }
            }

            dropCell(pParent, (int)(i + nxDiv - pParent.nOverflow), (int)(szNew[i]), &amp;rc);
        }
    }

    nMaxCells = (int)((nMaxCells + 3) &amp; ~3);
    szScratch = (int)(nMaxCells * sizeof(byte) + nMaxCells * sizeof(ushort) + pBt.pageSize);
    b.apCell = sqlite3DbMallocRaw(null, (ulong)(szScratch));
    if ((b.apCell) == (null))
    {
        rc = (int)(7);
        goto balance_cleanup;
    }

    b.szCell = (ushort*)(&amp;b.apCell[nMaxCells]);
    aSpace1 = (byte*)(&amp;b.szCell[nMaxCells]);
    b.pRef = apOld[0];
    leafCorrection = (ushort)(b.pRef.leaf * 4);
    leafData = (int)(b.pRef.intKeyLeaf);
    for (i = (int)(0); (i) &lt; (nOld); i++)
    {
        MemPage pOld = apOld[i];
        int limit = (int)(pOld.nCell);
        byte* aData = pOld.aData;
        ushort maskPage = (ushort)(pOld.maskPage);
        byte* piCell = aData + pOld.cellOffset;
        byte* piEnd;
        if (pOld.aData[0] != apOld[0].aData[0])
        {
            rc = (int)(sqlite3CorruptError((int)(74064)));
            goto balance_cleanup;
        }

        CRuntime.memset(&amp;b.szCell[b.nCell], (int)(0), (ulong)(sizeof(ushort) * (limit + pOld.nOverflow)));
        if ((pOld.nOverflow) &gt; (0))
        {
            if (((limit) &lt; (pOld.aiOvfl[0])))
            {
                rc = (int)(sqlite3CorruptError((int)(74088)));
                goto balance_cleanup;
            }

            limit = (int)(pOld.aiOvfl[0]);
            for (j = (int)(0); (j) &lt; (limit); j++)
            {
                b.apCell[b.nCell] = aData + (maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(piCell))));
                piCell += 2;
                b.nCell++;
            }

            for (k = (int)(0); (k) &lt; (pOld.nOverflow); k++)
            {
                b.apCell[b.nCell] = pOld.apOvfl[k];
                b.nCell++;
            }
        }

        piEnd = aData + pOld.cellOffset + 2 * pOld.nCell;
        while ((piCell) &lt; (piEnd))
        {
            b.apCell[b.nCell] = aData + (maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(piCell))));
            piCell += 2;
            b.nCell++;
        }

        cntOld[i] = (int)(b.nCell);
        if (((i) &lt; (nOld - 1)) &amp;&amp; (leafData == 0))
        {
            ushort sz = (ushort)(szNew[i]);
            byte* pTemp;
            b.szCell[b.nCell] = (ushort)(sz);
            pTemp = &amp;aSpace1[iSpace1];
            iSpace1 += (int)(sz);
            CRuntime.memcpy(pTemp, apDiv[i], (ulong)(sz));
            b.apCell[b.nCell] = pTemp + leafCorrection;
            b.szCell[b.nCell] = (ushort)(b.szCell[b.nCell] - leafCorrection);
            if (pOld.leaf == 0)
            {
                CRuntime.memcpy(b.apCell[b.nCell], &amp;pOld.aData[8], (ulong)(4));
            }
            else
            {
                while ((b.szCell[b.nCell]) &lt; (4))
                {
                    aSpace1[iSpace1++] = (byte)(0x00);
                    b.szCell[b.nCell]++;
                }
            }

            b.nCell++;
        }
    }

    usableSpace = (int)(pBt.usableSize - 12 + leafCorrection);
    for (i = (int)(k = (int)(0)); (i) &lt; (nOld); i++, k++)
    {
        MemPage p = apOld[i];
        b.apEnd[k] = p.aDataEnd;
        b.ixNx[k] = (int)(cntOld[i]);
        if (((k) != 0) &amp;&amp; ((b.ixNx[k]) == (b.ixNx[k - 1])))
        {
            k--;
        }

        if (leafData == 0)
        {
            k++;
            b.apEnd[k] = pParent.aDataEnd;
            b.ixNx[k] = (int)(cntOld[i] + 1);
        }

        szNew[i] = (int)(usableSpace - p.nFree);
        for (j = (int)(0); (j) &lt; (p.nOverflow); j++)
        {
            szNew[i] += (int)(2 + p.xCellSize(p, p.apOvfl[j]));
        }

        cntNew[i] = (int)(cntOld[i]);
    }

    k = (int)(nOld);
    for (i = (int)(0); (i) &lt; (k); i++)
    {
        int sz = 0;
        while ((szNew[i]) &gt; (usableSpace))
        {
            if ((i + 1) &gt;= (k))
            {
                k = (int)(i + 2);
                if ((k) &gt; (3 + 2))
                {
                    rc = (int)(sqlite3CorruptError((int)(74189)));
                    goto balance_cleanup;
                }

                szNew[k - 1] = (int)(0);
                cntNew[k - 1] = (int)(b.nCell);
            }

            sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i] - 1)));
            szNew[i] -= (int)(sz);
            if (leafData == 0)
            {
                if ((cntNew[i]) &lt; (b.nCell))
                {
                    sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
                }
                else
                {
                    sz = (int)(0);
                }
            }

            szNew[i + 1] += (int)(sz);
            cntNew[i]--;
        }

        while ((cntNew[i]) &lt; (b.nCell))
        {
            sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
            if ((szNew[i] + sz) &gt; (usableSpace))
                break;
            szNew[i] += (int)(sz);
            cntNew[i]++;
            if (leafData == 0)
            {
                if ((cntNew[i]) &lt; (b.nCell))
                {
                    sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
                }
                else
                {
                    sz = (int)(0);
                }
            }

            szNew[i + 1] -= (int)(sz);
        }

        if ((cntNew[i]) &gt;= (b.nCell))
        {
            k = (int)(i + 1);
        }
        else if ((cntNew[i]) &lt;= ((i) &gt; (0) ? cntNew[i - 1] : 0))
        {
            rc = (int)(sqlite3CorruptError((int)(74222)));
            goto balance_cleanup;
        }
    }

    for (i = (int)(k - 1); (i) &gt; (0); i--)
    {
        int szRight = (int)(szNew[i]);
        int szLeft = (int)(szNew[i - 1]);
        int r = 0;
        int d = 0;
        r = (int)(cntNew[i - 1] - 1);
        d = (int)(r + 1 - leafData);
        (void)(cachedCellSize(b, (int)(d)));
        do
        {
            (void)(cachedCellSize(b, (int)(r)));
            if ((szRight != 0) &amp;&amp; (((bBulk) != 0) || ((szRight + b.szCell[d] + 2) &gt; (szLeft - (b.szCell[r] + ((i) == (k - 1) ? 0 : 2))))))
            {
                break;
            }

            szRight += (int)(b.szCell[d] + 2);
            szLeft -= (int)(b.szCell[r] + 2);
            cntNew[i - 1] = (int)(r);
            r--;
            d--;
        }
        while ((r) &gt;= (0));
        szNew[i] = (int)(szRight);
        szNew[i - 1] = (int)(szLeft);
        if ((cntNew[i - 1]) &lt;= ((i) &gt; (1) ? cntNew[i - 2] : 0))
        {
            rc = (int)(sqlite3CorruptError((int)(74264)));
            goto balance_cleanup;
        }
    }

    pageFlags = (int)(apOld[0].aData[0]);
    for (i = (int)(0); (i) &lt; (k); i++)
    {
        MemPage pNew;
        if ((i) &lt; (nOld))
        {
            pNew = apNew[i] = apOld[i];
            apOld[i] = null;
            rc = (int)(sqlite3PagerWrite(pNew.pDbPage));
            nNew++;
            if ((sqlite3PagerPageRefcount(pNew.pDbPage) != 1 + ((i) == (iParentIdx - nxDiv))) &amp;&amp; ((rc) == (0)))
            {
                rc = (int)(sqlite3CorruptError((int)(74297)));
            }

            if ((rc) != 0)
                goto balance_cleanup;
        }
        else
        {
            rc = (int)(allocateBtreePage(pBt, pNew, &amp;pgno, (uint)((bBulk) != 0 ? 1 : pgno), (byte)(0)));
            if ((rc) != 0)
                goto balance_cleanup;
            zeroPage(pNew, (int)(pageFlags));
            apNew[i] = pNew;
            nNew++;
            cntOld[i] = (int)(b.nCell);
            if ((pBt.autoVacuum) != 0)
            {
                ptrmapPut(pBt, (uint)(pNew.pgno), (byte)(5), (uint)(pParent.pgno), &amp;rc);
                if (rc != 0)
                {
                    goto balance_cleanup;
                }
            }
        }
    }

    for (i = (int)(0); (i) &lt; (nNew); i++)
    {
        aPgOrder[i] = (uint)(aPgno[i] = (uint)(apNew[i].pgno));
        aPgFlags[i] = (ushort)(apNew[i].pDbPage.flags);
        for (j = (int)(0); (j) &lt; (i); j++)
        {
            if (((aPgno[j]) == (aPgno[i])))
            {
                rc = (int)(sqlite3CorruptError((int)(74343)));
                goto balance_cleanup;
            }
        }
    }

    for (i = (int)(0); (i) &lt; (nNew); i++)
    {
        int iBest = (int)(0);
        for (j = (int)(1); (j) &lt; (nNew); j++)
        {
            if ((aPgOrder[j]) &lt; (aPgOrder[iBest]))
                iBest = (int)(j);
        }

        pgno = (uint)(aPgOrder[iBest]);
        aPgOrder[iBest] = (uint)(0xffffffff);
        if (iBest != i)
        {
            if ((iBest) &gt; (i))
            {
                sqlite3PagerRekey(apNew[iBest].pDbPage, (uint)(pBt.nPage + iBest + 1), (ushort)(0));
            }

            sqlite3PagerRekey(apNew[i].pDbPage, (uint)(pgno), (ushort)(aPgFlags[iBest]));
            apNew[i].pgno = (uint)(pgno);
        }
    }

    sqlite3Put4byte(pRight, (uint)(apNew[nNew - 1].pgno));
    if (((pageFlags &amp; 0x08) == (0)) &amp;&amp; (nOld != nNew))
    {
        MemPage pOld = ((nNew) &gt; (nOld) ? apNew : apOld)[nOld - 1];
        CRuntime.memcpy(&amp;apNew[nNew - 1].aData[8], &amp;pOld.aData[8], (ulong)(4));
    }

    if ((pBt.autoVacuum) != 0)
    {
        MemPage pOld;
        MemPage pNew = pOld = apNew[0];
        int cntOldNext = (int)(pNew.nCell + pNew.nOverflow);
        int iNew = (int)(0);
        int iOld = (int)(0);
        for (i = (int)(0); (i) &lt; (b.nCell); i++)
        {
            byte* pCell = b.apCell[i];
            while ((i) == (cntOldNext))
            {
                iOld++;
                pOld = (iOld) &lt; (nNew) ? apNew[iOld] : apOld[iOld];
                cntOldNext += (int)(pOld.nCell + pOld.nOverflow + !leafData);
            }

            if ((i) == (cntNew[iNew]))
            {
                pNew = apNew[++iNew];
                if (leafData == 0)
                    continue;
            }

            if ((((iOld) &gt;= (nNew)) || (pNew.pgno != aPgno[iOld])) || (!((((ulong)(pCell)) &gt;= ((ulong)(pOld.aData))) &amp;&amp; (((ulong)(pCell)) &lt; ((ulong)(pOld.aDataEnd))))))
            {
                if (leafCorrection == 0)
                {
                    ptrmapPut(pBt, (uint)(sqlite3Get4byte(pCell)), (byte)(5), (uint)(pNew.pgno), &amp;rc);
                }

                if ((cachedCellSize(b, (int)(i))) &gt; (pNew.minLocal))
                {
                    ptrmapPutOvflPtr(pNew, pOld, pCell, &amp;rc);
                }

                if ((rc) != 0)
                    goto balance_cleanup;
            }
        }
    }

    for (i = (int)(0); (i) &lt; (nNew - 1); i++)
    {
        byte* pCell;
        byte* pTemp;
        int sz = 0;
        byte* pSrcEnd;
        MemPage pNew = apNew[i];
        j = (int)(cntNew[i]);
        pCell = b.apCell[j];
        sz = (int)(b.szCell[j] + leafCorrection);
        pTemp = &amp;aOvflSpace[iOvflSpace];
        if (pNew.leaf == 0)
        {
            CRuntime.memcpy(&amp;pNew.aData[8], pCell, (ulong)(4));
        }
        else if ((leafData) != 0)
        {
            CellInfo info = new CellInfo();
            j--;
            pNew.xParseCell(pNew, b.apCell[j], &amp;info);
            pCell = pTemp;
            sz = (int)(4 + sqlite3PutVarint(&amp;pCell[4], (ulong)(info.nKey)));
            pTemp = null;
        }
        else
        {
            pCell -= 4;
            if ((b.szCell[j]) == (4))
            {
                sz = (int)(pParent.xCellSize(pParent, pCell));
            }
        }

        iOvflSpace += (int)(sz);
        for (k = (int)(0); ((b.ixNx[k]) &lt;= (i)) &amp;&amp; ((k) &lt; (3 * 2)); k++)
        {
        }

        pSrcEnd = b.apEnd[k];
        if (((((ulong)(pSrcEnd)) &gt;= ((ulong)(pCell))) &amp;&amp; (((ulong)(pSrcEnd)) &lt; ((ulong)(pCell + sz)))))
        {
            rc = (int)(sqlite3CorruptError((int)(74500)));
            goto balance_cleanup;
        }

        insertCell(pParent, (int)(nxDiv + i), pCell, (int)(sz), pTemp, (uint)(pNew.pgno), &amp;rc);
        if (rc != 0)
            goto balance_cleanup;
    }

    for (i = (int)(1 - nNew); (i) &lt; (nNew); i++)
    {
        int iPg = (int)((i) &lt; (0) ? -i : i);
        if ((abDone[iPg]) != 0)
            continue;
        if (((i) &gt;= (0)) || ((cntOld[iPg - 1]) &gt;= (cntNew[iPg - 1])))
        {
            int iNew = 0;
            int iOld = 0;
            int nNewCell = 0;
            if ((iPg) == (0))
            {
                iNew = (int)(iOld = (int)(0));
                nNewCell = (int)(cntNew[0]);
            }
            else
            {
                iOld = (int)((iPg) &lt; (nOld) ? (cntOld[iPg - 1] + !leafData) : b.nCell);
                iNew = (int)(cntNew[iPg - 1] + !leafData);
                nNewCell = (int)(cntNew[iPg] - iNew);
            }

            rc = (int)(editPage(apNew[iPg], (int)(iOld), (int)(iNew), (int)(nNewCell), b));
            if ((rc) != 0)
                goto balance_cleanup;
            abDone[iPg]++;
            apNew[iPg].nFree = (int)(usableSpace - szNew[iPg]);
        }
    }

    if ((((isRoot) != 0) &amp;&amp; ((pParent.nCell) == (0))) &amp;&amp; ((pParent.hdrOffset) &lt;= (apNew[0].nFree)))
    {
        rc = (int)(defragmentPage(apNew[0], (int)(-1)));
        copyNodeContent(apNew[0], pParent, &amp;rc);
        freePage(apNew[0], &amp;rc);
    }
    else if (((pBt.autoVacuum) != 0) &amp;&amp; (leafCorrection == 0))
    {
        for (i = (int)(0); (i) &lt; (nNew); i++)
        {
            uint key = (uint)(sqlite3Get4byte(&amp;apNew[i].aData[8]));
            ptrmapPut(pBt, (uint)(key), (byte)(5), (uint)(apNew[i].pgno), &amp;rc);
        }
    }

    for (i = (int)(nNew); (i) &lt; (nOld); i++)
    {
        freePage(apOld[i], &amp;rc);
    }

    balance_cleanup:
        ; sqlite3DbFree ( null ,  b . apCell ) ; 
    for (i = (int)(0); (i) &lt; (nOld); i++)
    {
        releasePage(apOld[i]);
    }

    for (i = (int)(0); (i) &lt; (nNew); i++)
    {
        releasePage(apNew[i]);
    }

    return (int)(rc);
}</function>
  <function>public static int balance_quick(MemPage pParent, MemPage pPage, byte* pSpace)
{
    BtShared pBt = pPage.pBt;
    MemPage pNew;
    int rc = 0;
    uint pgnoNew = 0;
    if ((pPage.nCell) == (0))
        return (int)(sqlite3CorruptError((int)(73641)));
    rc = (int)(allocateBtreePage(pBt, pNew, &amp;pgnoNew, (uint)(0), (byte)(0)));
    if ((rc) == (0))
    {
        byte* pOut = &amp;pSpace[4];
        byte* pCell = pPage.apOvfl[0];
        ushort szCell = (ushort)(pPage.xCellSize(pPage, pCell));
        byte* pStop;
        CellArray b = new CellArray();
        zeroPage(pNew, (int)(0x01 | 0x04 | 0x08));
        b.nCell = (int)(1);
        b.pRef = pPage;
        b.apCell = &amp;pCell;
        b.szCell = &amp;szCell;
        b.apEnd[0] = pPage.aDataEnd;
        b.ixNx[0] = (int)(2);
        rc = (int)(rebuildPage(b, (int)(0), (int)(1), pNew));
        if ((rc) != 0)
        {
            releasePage(pNew);
            return (int)(rc);
        }

        pNew.nFree = (int)(pBt.usableSize - pNew.cellOffset - 2 - szCell);
        if ((pBt.autoVacuum) != 0)
        {
            ptrmapPut(pBt, (uint)(pgnoNew), (byte)(5), (uint)(pParent.pgno), &amp;rc);
            if ((szCell) &gt; (pNew.minLocal))
            {
                ptrmapPutOvflPtr(pNew, pNew, pCell, &amp;rc);
            }
        }

        pCell = ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (pPage.nCell - 1)])))));
        pStop = &amp;pCell[9];
        while (((*(pCell++) &amp; 0x80) != 0) &amp;&amp; ((pCell) &lt; (pStop)))
        {
        }

        pStop = &amp;pCell[9];
        while ((((*(pOut++) = (byte)(*(pCell++))) &amp; 0x80) != 0) &amp;&amp; ((pCell) &lt; (pStop)))
        {
        }

        if ((rc) == (0))
        {
            insertCell(pParent, (int)(pParent.nCell), pSpace, (int)(pOut - pSpace), null, (uint)(pPage.pgno), &amp;rc);
        }

        sqlite3Put4byte(&amp;pParent.aData[pParent.hdrOffset + 8], (uint)(pgnoNew));
        releasePage(pNew);
    }

    return (int)(rc);
}</function>
  <function>public static byte binaryCompareP5(Expr pExpr1, Expr pExpr2, int jumpIfNull)
{
    byte aff = (byte)(sqlite3ExprAffinity(pExpr2));
    aff = (byte)((byte)(sqlite3CompareAffinity(pExpr1, (sbyte)(aff))) | (byte)(jumpIfNull));
    return (byte)(aff);
}</function>
  <function>public static void binaryToUnaryIfNull(Parse pParse, Expr pY, Expr pA, int op)
{
    sqlite3 db = pParse.db;
    if (((((pA) != null) &amp;&amp; ((pY) != null)) &amp;&amp; ((pY.op) == (121))) &amp;&amp; (!((pParse.eParseMode) &gt;= (2))))
    {
        pA.op = ((byte)(op));
        sqlite3ExprDelete(db, pA.pRight);
        pA.pRight = null;
    }
}</function>
  <function>public static int binCollFunc(void* NotUsed, int nKey1, void* pKey1, int nKey2, void* pKey2)
{
    int rc = 0; int  n  =  0 ; 
    n = (int)((nKey1) &lt; (nKey2) ? nKey1 : nKey2);
    rc = (int)(memcmp(pKey1, pKey2, (ulong)(n)));
    if ((rc) == (0))
    {
        rc = (int)(nKey1 - nKey2);
    }

    return (int)(rc);
}</function>
  <function>public static int bindText(sqlite3_stmt* pStmt, int i, void* zData, long nData, delegate17 xDel, byte encoding)
{
    Vdbe p = (Vdbe)(pStmt);
    sqlite3_value pVar;
    int rc = 0;
    rc = (int)(vdbeUnbind(p, (int)(i)));
    if ((rc) == (0))
    {
        if (zData != null)
        {
            pVar = p.aVar[i - 1];
            rc = (int)(sqlite3VdbeMemSetStr(pVar, zData, (long)(nData), (byte)(encoding), xDel));
            if (((rc) == (0)) &amp;&amp; (encoding != 0))
            {
                rc = (int)(sqlite3VdbeChangeEncoding(pVar, (int)((p.db).enc)));
            }

            if ((rc) != 0)
            {
                sqlite3Error(p.db, (int)(rc));
                rc = (int)(sqlite3ApiExit(p.db, (int)(rc)));
            }
        }

        sqlite3_mutex_leave(p.db.mutex);
    }
    else if ((xDel != null) &amp;&amp; (xDel != ((Void(Void * ))(-1))))
    {
        xDel(zData);
    }

    return (int)(rc);
}</function>
  <function>public static int blobReadWrite(sqlite3_blob* pBlob, void* z, int n, int iOffset, delegate174 xCall)
{
    int rc = 0;
    Incrblob p = (Incrblob)(pBlob);
    Vdbe v;
    sqlite3 db;
    if ((p) == (null))
        return (int)(sqlite3MisuseError((int)(96397)));
    db = p.db;
    sqlite3_mutex_enter(db.mutex);
    v = (Vdbe)(p.pStmt);
    if ((((n) &lt; (0)) || ((iOffset) &lt; (0))) || (((long)(iOffset) + n) &gt; (p.nByte)))
    {
        rc = (int)(1);
    }
    else if ((v) == (null))
    {
        rc = (int)(4);
    }
    else
    {
        sqlite3BtreeEnterCursor(p.pCsr);
        rc = (int)(xCall(p.pCsr, (uint)(iOffset + p.iOffset), (uint)(n), z));
        sqlite3BtreeLeaveCursor(p.pCsr);
        if ((rc) == (4))
        {
            sqlite3VdbeFinalize(v);
            p.pStmt = null;
        }
        else
        {
            v.rc = (int)(rc);
        }
    }

    sqlite3Error(db, (int)(rc));
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int blobSeekToRow(Incrblob p, long iRow, sbyte** pzErr)
{
    int rc = 0;
    sbyte* zErr = null;
    Vdbe v = (Vdbe)(p.pStmt);
    v.aMem[1].flags = (ushort)(0x0004);
    v.aMem[1].u.i = (long)(iRow);
    if ((v.pc) &gt; (4))
    {
        v.pc = (int)(4);
        rc = (int)(sqlite3VdbeExec(v));
    }
    else
    {
        rc = (int)(sqlite3_step(p.pStmt));
    }

    if ((rc) == (100))
    {
        VdbeCursor pC = v.apCsr[0];
        uint type = 0;
        type = (uint)((pC.nHdrParsed) &gt; (p.iCol) ? pC.aType[p.iCol] : 0);
        if ((type) &lt; (12))
        {
            zErr = sqlite3MPrintf(p.db, "cannot open value of type %s", (type) == (0) ? "null" : (type) == (7) ? "real" : "integer");
            rc = (int)(1);
            sqlite3_finalize(p.pStmt);
            p.pStmt = null;
        }
        else
        {
            p.iOffset = (int)(pC.aType[p.iCol + pC.nField]);
            p.nByte = (int)(sqlite3VdbeSerialTypeLen((uint)(type)));
            p.pCsr = pC.uc.pCursor;
            sqlite3BtreeIncrblobCursor(p.pCsr);
        }
    }

    if ((rc) == (100))
    {
        rc = (int)(0);
    }
    else if ((p.pStmt) != null)
    {
        rc = (int)(sqlite3_finalize(p.pStmt));
        p.pStmt = null;
        if ((rc) == (0))
        {
            zErr = sqlite3MPrintf(p.db, "no such rowid: %lld", (long)(iRow));
            rc = (int)(1);
        }
        else
        {
            zErr = sqlite3MPrintf(p.db, "%s", sqlite3_errmsg(p.db));
        }
    }

    *pzErr = zErr;
    return (int)(rc);
}</function>
  <function>public static int btreeCellSizeCheck(MemPage pPage)
{
    int iCellFirst = 0;
    int iCellLast = 0;
    int i = 0;
    int sz = 0;
    int pc = 0;
    byte* data;
    int usableSize = 0;
    int cellOffset = 0;
    iCellFirst = (int)(pPage.cellOffset + 2 * pPage.nCell);
    usableSize = (int)(pPage.pBt.usableSize);
    iCellLast = (int)(usableSize - 4);
    data = pPage.aData;
    cellOffset = (int)(pPage.cellOffset);
    if (pPage.leaf == 0)
        iCellLast--;
    for (i = (int)(0); (i) &lt; (pPage.nCell); i++)
    {
        pc = (int)(_byteswap_ushort((ushort)(*(ushort*)(&amp;data[cellOffset + i * 2]))));
        if (((pc) &lt; (iCellFirst)) || ((pc) &gt; (iCellLast)))
        {
            return (int)(sqlite3CorruptError((int)(68174)));
        }

        sz = (int)(pPage.xCellSize(pPage, &amp;data[pc]));
        if ((pc + sz) &gt; (usableSize))
        {
            return (int)(sqlite3CorruptError((int)(68179)));
        }
    }

    return (int)(0);
}</function>
  <function>public static void btreeClearHasContent(BtShared pBt)
{
    sqlite3BitvecDestroy(pBt.pHasContent);
    pBt.pHasContent = null;
}</function>
  <function>public static int btreeComputeFreeSpace(MemPage pPage)
{
    int pc = 0;
    byte hdr = 0;
    byte* data;
    int usableSize = 0;
    int nFree = 0;
    int top = 0;
    int iCellFirst = 0;
    int iCellLast = 0;
    usableSize = (int)(pPage.pBt.usableSize);
    hdr = (byte)(pPage.hdrOffset);
    data = pPage.aData;
    top = (int)(((((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]) - 1) &amp; 0xffff) + 1);
    iCellFirst = (int)(hdr + 8 + pPage.childPtrSize + 2 * pPage.nCell);
    iCellLast = (int)(usableSize - 4);
    pc = (int)((&amp;data[hdr + 1])[0] &lt;&lt; 8 | (&amp;data[hdr + 1])[1]);
    nFree = (int)(data[hdr + 7] + top);
    if ((pc) &gt; (0))
    {
        uint next = 0;
        uint size = 0;
        if ((pc) &lt; (top))
        {
            return (int)(sqlite3CorruptError((int)(68112)));
        }

        while ((1) != 0)
        {
            if ((pc) &gt; (iCellLast))
            {
                return (int)(sqlite3CorruptError((int)(68117)));
            }

            next = (uint)((&amp;data[pc])[0] &lt;&lt; 8 | (&amp;data[pc])[1]);
            size = (uint)((&amp;data[pc + 2])[0] &lt;&lt; 8 | (&amp;data[pc + 2])[1]);
            nFree = (int)(nFree + size);
            if ((next) &lt;= (pc + size + 3))
                break;
            pc = (int)(next);
        }

        if ((next) &gt; (0))
        {
            return (int)(sqlite3CorruptError((int)(68127)));
        }

        if ((pc + size) &gt; ((uint)(usableSize)))
        {
            return (int)(sqlite3CorruptError((int)(68131)));
        }
    }

    if (((nFree) &gt; (usableSize)) || ((nFree) &lt; (iCellFirst)))
    {
        return (int)(sqlite3CorruptError((int)(68143)));
    }

    pPage.nFree = (int)((ushort)(nFree - iCellFirst));
    return (int)(0);
}</function>
  <function>public static int btreeCreateTable(Btree p, uint* piTable, int createTabFlags)
{
    BtShared pBt = p.pBt;
    MemPage pRoot;
    uint pgnoRoot = 0;
    int rc = 0;
    int ptfFlags = 0;
    if ((pBt.autoVacuum) != 0)
    {
        uint pgnoMove = 0;
        MemPage pPageMove;
        invalidateAllOverflowCache(pBt);
        sqlite3BtreeGetMeta(p, (int)(4), &amp;pgnoRoot);
        if ((pgnoRoot) &gt; (btreePagecount(pBt)))
        {
            return (int)(sqlite3CorruptError((int)(75647)));
        }

        pgnoRoot++;
        while (((pgnoRoot) == (ptrmapPageno(pBt, (uint)(pgnoRoot)))) || ((pgnoRoot) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
        {
            pgnoRoot++;
        }

        rc = (int)(allocateBtreePage(pBt, pPageMove, &amp;pgnoMove, (uint)(pgnoRoot), (byte)(1)));
        if (rc != 0)
        {
            return (int)(rc);
        }

        if (pgnoMove != pgnoRoot)
        {
            byte eType = (byte)(0);
            uint iPtrPage = (uint)(0);
            rc = (int)(saveAllCursors(pBt, (uint)(0), null));
            releasePage(pPageMove);
            if (rc != 0)
            {
                return (int)(rc);
            }

            rc = (int)(btreeGetPage(pBt, (uint)(pgnoRoot), pRoot, (int)(0)));
            if (rc != 0)
            {
                return (int)(rc);
            }

            rc = (int)(ptrmapGet(pBt, (uint)(pgnoRoot), &amp;eType, &amp;iPtrPage));
            if (((eType) == (1)) || ((eType) == (2)))
            {
                rc = (int)(sqlite3CorruptError((int)(75695)));
            }

            if (rc != 0)
            {
                releasePage(pRoot);
                return (int)(rc);
            }

            rc = (int)(relocatePage(pBt, pRoot, (byte)(eType), (uint)(iPtrPage), (uint)(pgnoMove), (int)(0)));
            releasePage(pRoot);
            if (rc != 0)
            {
                return (int)(rc);
            }

            rc = (int)(btreeGetPage(pBt, (uint)(pgnoRoot), pRoot, (int)(0)));
            if (rc != 0)
            {
                return (int)(rc);
            }

            rc = (int)(sqlite3PagerWrite(pRoot.pDbPage));
            if (rc != 0)
            {
                releasePage(pRoot);
                return (int)(rc);
            }
        }
        else
        {
            pRoot = pPageMove;
        }

        ptrmapPut(pBt, (uint)(pgnoRoot), (byte)(1), (uint)(0), &amp;rc);
        if ((rc) != 0)
        {
            releasePage(pRoot);
            return (int)(rc);
        }

        rc = (int)(sqlite3BtreeUpdateMeta(p, (int)(4), (uint)(pgnoRoot)));
        if ((rc) != 0)
        {
            releasePage(pRoot);
            return (int)(rc);
        }
    }
    else
    {
        rc = (int)(allocateBtreePage(pBt, pRoot, &amp;pgnoRoot, (uint)(1), (byte)(0)));
        if ((rc) != 0)
            return (int)(rc);
    }

    if ((createTabFlags &amp; 1) != 0)
    {
        ptfFlags = (int)(0x01 | 0x04 | 0x08);
    }
    else
    {
        ptfFlags = (int)(0x02 | 0x08);
    }

    zeroPage(pRoot, (int)(ptfFlags));
    sqlite3PagerUnref(pRoot.pDbPage);
    *piTable = (uint)(pgnoRoot);
    return (int)(0);
}</function>
  <function>public static int btreeCursor(Btree p, uint iTable, int wrFlag, KeyInfo pKeyInfo, BtCursor pCur)
{
    BtShared pBt = p.pBt;
    BtCursor pX;
    if ((iTable) &lt;= (1))
    {
        if ((iTable) &lt; (1))
        {
            return (int)(sqlite3CorruptError((int)(70650)));
        }
        else if ((btreePagecount(pBt)) == (0))
        {
            iTable = (uint)(0);
        }
    }

    pCur.pgnoRoot = (uint)(iTable);
    pCur.iPage = (sbyte)(-1);
    pCur.pKeyInfo = pKeyInfo;
    pCur.pBtree = p;
    pCur.pBt = pBt;
    pCur.curFlags = (byte)(0);
    for (pX = pBt.pCursor; pX; pX = pX.pNext)
    {
        if ((pX.pgnoRoot) == (iTable))
        {
            pX.curFlags |= (byte)(0x20);
            pCur.curFlags = (byte)(0x20);
        }
    }

    pCur.eState = (byte)(1);
    pCur.pNext = pBt.pCursor;
    pBt.pCursor = pCur;
    if ((wrFlag) != 0)
    {
        pCur.curFlags |= (byte)(0x01);
        pCur.curPagerFlags = (byte)(0);
        if ((pBt.pTmpSpace) == (null))
            return (int)(allocateTempSpace(pBt));
    }
    else
    {
        pCur.curPagerFlags = (byte)(0x02);
    }

    return (int)(0);
}</function>
  <function>public static int btreeCursorWithLock(Btree p, uint iTable, int wrFlag, KeyInfo pKeyInfo, BtCursor pCur)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    rc = (int)(btreeCursor(p, (uint)(iTable), (int)(wrFlag), pKeyInfo, pCur));
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int btreeDropTable(Btree p, uint iTable, int* piMoved)
{
    int rc = 0;
    MemPage pPage = null;
    BtShared pBt = p.pBt;
    if ((iTable) &gt; (btreePagecount(pBt)))
    {
        return (int)(sqlite3CorruptError((int)(75896)));
    }

    rc = (int)(sqlite3BtreeClearTable(p, (int)(iTable), null));
    if ((rc) != 0)
        return (int)(rc);
    rc = (int)(btreeGetPage(pBt, (uint)(iTable), pPage, (int)(0)));
    if ((rc) != 0)
    {
        releasePage(pPage);
        return (int)(rc);
    }

    *piMoved = (int)(0);
    if ((pBt.autoVacuum) != 0)
    {
        uint maxRootPgno = 0;
        sqlite3BtreeGetMeta(p, (int)(4), &amp;maxRootPgno);
        if ((iTable) == (maxRootPgno))
        {
            freePage(pPage, &amp;rc);
            releasePage(pPage);
            if (rc != 0)
            {
                return (int)(rc);
            }
        }
        else
        {
            MemPage pMove;
            releasePage(pPage);
            rc = (int)(btreeGetPage(pBt, (uint)(maxRootPgno), pMove, (int)(0)));
            if (rc != 0)
            {
                return (int)(rc);
            }

            rc = (int)(relocatePage(pBt, pMove, (byte)(1), (uint)(0), (uint)(iTable), (int)(0)));
            releasePage(pMove);
            if (rc != 0)
            {
                return (int)(rc);
            }

            pMove = null;
            rc = (int)(btreeGetPage(pBt, (uint)(maxRootPgno), pMove, (int)(0)));
            freePage(pMove, &amp;rc);
            releasePage(pMove);
            if (rc != 0)
            {
                return (int)(rc);
            }

            *piMoved = (int)(maxRootPgno);
        }

        maxRootPgno--;
        while (((maxRootPgno) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) || ((ptrmapPageno((pBt), (uint)(maxRootPgno))) == (maxRootPgno)))
        {
            maxRootPgno--;
        }

        rc = (int)(sqlite3BtreeUpdateMeta(p, (int)(4), (uint)(maxRootPgno)));
    }
    else
    {
        freePage(pPage, &amp;rc);
        releasePage(pPage);
    }

    return (int)(rc);
}</function>
  <function>public static void btreeEndTransaction(Btree p)
{
    BtShared pBt = p.pBt;
    sqlite3 db = p.db;
    pBt.bDoTruncate = (byte)(0);
    if (((p.inTrans) &gt; (0)) &amp;&amp; ((db.nVdbeRead) &gt; (1)))
    {
        downgradeAllSharedCacheTableLocks(p);
        p.inTrans = (byte)(1);
    }
    else
    {
        if (p.inTrans != 0)
        {
            clearAllSharedCacheTableLocks(p);
            pBt.nTransaction--;
            if ((0) == (pBt.nTransaction))
            {
                pBt.inTransaction = (byte)(0);
            }
        }

        p.inTrans = (byte)(0);
        unlockBtreeIfUnused(pBt);
    }
}</function>
  <function>public static void btreeEnterAll(sqlite3 db)
{
    int i = 0;
    int skipOk = (int)(1);
    Btree p;
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        p = db.aDb[i].pBt;
        if (((p) != null) &amp;&amp; ((p.sharable) != 0))
        {
            sqlite3BtreeEnter(p);
            skipOk = (int)(0);
        }
    }

    db.noSharedCache = (byte)(skipOk);
}</function>
  <function>public static int btreeGetHasContent(BtShared pBt, uint pgno)
{
    Bitvec* p = pBt.pHasContent;
    return (((p) != null) &amp;&amp; (((pgno) &gt; (sqlite3BitvecSize(p))) || ((sqlite3BitvecTestNotNull(p, (uint)(pgno))) != 0)) ? 1 : 0);
}</function>
  <function>public static int btreeGetPage(BtShared pBt, uint pgno, MemPage ppPage, int flags)
{
    int rc = 0;
    PgHdr pDbPage;
    rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(pgno), pDbPage, (int)(flags)));
    if ((rc) != 0)
        return (int)(rc);
    ppPage = btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
    return (int)(0);
}</function>
  <function>public static int btreeGetUnusedPage(BtShared pBt, uint pgno, MemPage ppPage, int flags)
{
    int rc = (int)(btreeGetPage(pBt, (uint)(pgno), ppPage, (int)(flags)));
    if ((rc) == (0))
    {
        if ((sqlite3PagerPageRefcount((ppPage).pDbPage)) &gt; (1))
        {
            releasePage(ppPage);
            ppPage = null;
            return (int)(sqlite3CorruptError((int)(68467)));
        }

        (ppPage).isInit = (byte)(0);
    }
    else
    {
        ppPage = null;
    }

    return (int)(rc);
}</function>
  <function>public static void btreeHeapInsert(uint* aHeap, uint x)
{
    uint j = 0; uint  i  =  ( uint ) ( ++ aHeap [ 0 ] ) ; 
    aHeap[i] = (uint)(x);
    while (((j = (uint)(i / 2)) &gt; (0)) &amp;&amp; ((aHeap[j]) &gt; (aHeap[i])))
    {
        x = (uint)(aHeap[j]);
        aHeap[j] = (uint)(aHeap[i]);
        aHeap[i] = (uint)(x);
        i = (uint)(j);
    }
}</function>
  <function>public static int btreeHeapPull(uint* aHeap, uint* pOut)
{
    uint j = 0; uint  i  =  0 ;  uint  x  =  0 ; 
    if ((x = (uint)(aHeap[0])) == (0))
        return (int)(0);
    *pOut = (uint)(aHeap[1]);
    aHeap[1] = (uint)(aHeap[x]);
    aHeap[x] = (uint)(0xffffffff);
    aHeap[0]--;
    i = (uint)(1);
    while ((j = (uint)(i * 2)) &lt;= (aHeap[0]))
    {
        if ((aHeap[j]) &gt; (aHeap[j + 1]))
            j++;
        if ((aHeap[i]) &lt; (aHeap[j]))
            break;
        x = (uint)(aHeap[i]);
        aHeap[i] = (uint)(aHeap[j]);
        aHeap[j] = (uint)(x);
        i = (uint)(j);
    }

    return (int)(1);
}</function>
  <function>public static int btreeInitPage(MemPage pPage)
{
    byte* data;
    BtShared pBt;
    pBt = pPage.pBt;
    data = pPage.aData + pPage.hdrOffset;
    if ((decodeFlags(pPage, (int)(data[0]))) != 0)
    {
        return (int)(sqlite3CorruptError((int)(68211)));
    }

    pPage.maskPage = ((ushort)(pBt.pageSize - 1));
    pPage.nOverflow = (byte)(0);
    pPage.cellOffset = (ushort)(pPage.hdrOffset + 8 + pPage.childPtrSize);
    pPage.aCellIdx = data + pPage.childPtrSize + 8;
    pPage.aDataEnd = pPage.aData + pBt.pageSize;
    pPage.aDataOfst = pPage.aData + pPage.childPtrSize;
    pPage.nCell = (ushort)((&amp;data[3])[0] &lt;&lt; 8 | (&amp;data[3])[1]);
    if ((pPage.nCell) &gt; ((pBt.pageSize - 8) / 6))
    {
        return (int)(sqlite3CorruptError((int)(68225)));
    }

    pPage.nFree = (int)(-1);
    pPage.isInit = (byte)(1);
    if ((pBt.db.flags &amp; 0x00200000) != 0)
    {
        return (int)(btreeCellSizeCheck(pPage));
    }

    return (int)(0);
}</function>
  <function>public static int btreeInvokeBusyHandler(void* pArg)
{
    BtShared pBt = (BtShared)(pArg);
    return (int)(sqlite3InvokeBusyHandler(pBt.db.busyHandler));
}</function>
  <function>public static void btreeLeaveAll(sqlite3 db)
{
    int i = 0;
    Btree p;
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        p = db.aDb[i].pBt;
        if ((p) != null)
            sqlite3BtreeLeave(p);
    }
}</function>
  <function>public static void btreeLockCarefully(Btree p)
{
    Btree pLater;
    if ((sqlite3_mutex_try(p.pBt.mutex)) == (0))
    {
        p.pBt.db = p.db;
        p.locked = (byte)(1);
        return;
    }

    for (pLater = p.pNext; pLater; pLater = pLater.pNext)
    {
        if ((pLater.locked) != 0)
        {
            unlockBtreeMutex(pLater);
        }
    }

    lockBtreeMutex(p);
    for (pLater = p.pNext; pLater; pLater = pLater.pNext)
    {
        if ((pLater.wantToLock) != 0)
        {
            lockBtreeMutex(pLater);
        }
    }
}</function>
  <function>public static int btreeMoveto(BtCursor pCur, void* pKey, long nKey, int bias, int* pRes)
{
    int rc = 0;
    UnpackedRecord pIdxKey;
    if ((pKey) != null)
    {
        KeyInfo pKeyInfo = pCur.pKeyInfo;
        pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
        if ((pIdxKey) == (null))
            return (int)(7);
        sqlite3VdbeRecordUnpack(pKeyInfo, (int)(nKey), pKey, pIdxKey);
        if (((pIdxKey.nField) == (0)) || ((pIdxKey.nField) &gt; (pKeyInfo.nAllField)))
        {
            rc = (int)(sqlite3CorruptError((int)(66991)));
        }
        else
        {
            rc = (int)(sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes));
        }

        sqlite3DbFree(pCur.pKeyInfo.db, pIdxKey);
    }
    else
    {
        pIdxKey = null;
        rc = (int)(sqlite3BtreeTableMoveto(pCur, (long)(nKey), (int)(bias), pRes));
    }

    return (int)(rc);
}</function>
  <function>public static int btreeNext(BtCursor pCur)
{
    int rc = 0;
    int idx = 0;
    MemPage pPage;
    if (pCur.eState != 0)
    {
        rc = (int)((pCur.eState) &gt;= (3) ? btreeRestoreCursorPosition(pCur) : 0);
        if (rc != 0)
        {
            return (int)(rc);
        }

        if ((1) == (pCur.eState))
        {
            return (int)(101);
        }

        if ((pCur.eState) == (2))
        {
            pCur.eState = (byte)(0);
            if ((pCur.skipNext) &gt; (0))
                return (int)(0);
        }
    }

    pPage = pCur.pPage;
    idx = (int)(++pCur.ix);
    if ((pPage.isInit == 0) || ((sqlite3FaultSim((int)(412))) != 0))
    {
        return (int)(sqlite3CorruptError((int)(72086)));
    }

    if ((idx) &gt;= (pPage.nCell))
    {
        if (pPage.leaf == 0)
        {
            rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]))));
            if ((rc) != 0)
                return (int)(rc);
            return (int)(moveToLeftmost(pCur));
        }

        do
        {
            if ((pCur.iPage) == (0))
            {
                pCur.eState = (byte)(1);
                return (int)(101);
            }

            moveToParent(pCur);
            pPage = pCur.pPage;
        }
        while ((pCur.ix) &gt;= (pPage.nCell));
        if ((pPage.intKey) != 0)
        {
            return (int)(sqlite3BtreeNext(pCur, (int)(0)));
        }
        else
        {
            return (int)(0);
        }
    }

    if ((pPage.leaf) != 0)
    {
        return (int)(0);
    }
    else
    {
        return (int)(moveToLeftmost(pCur));
    }
}</function>
  <function>public static int btreeOverwriteCell(BtCursor pCur, BtreePayload pX)
{
    int iOffset = 0;
    int nTotal = (int)(pX.nData + pX.nZero);
    int rc = 0;
    MemPage pPage = pCur.pPage;
    BtShared pBt;
    uint ovflPgno = 0;
    uint ovflPageSize = 0;
    if (((pCur.info.pPayload + pCur.info.nLocal) &gt; (pPage.aDataEnd)) || ((pCur.info.pPayload) &lt; (pPage.aData + pPage.cellOffset)))
    {
        return (int)(sqlite3CorruptError((int)(74927)));
    }

    rc = (int)(btreeOverwriteContent(pPage, pCur.info.pPayload, pX, (int)(0), (int)(pCur.info.nLocal)));
    if ((rc) != 0)
        return (int)(rc);
    if ((pCur.info.nLocal) == (nTotal))
        return (int)(0);
    iOffset = (int)(pCur.info.nLocal);
    ovflPgno = (uint)(sqlite3Get4byte(pCur.info.pPayload + iOffset));
    pBt = pPage.pBt;
    ovflPageSize = (uint)(pBt.usableSize - 4);
    do
    {
        rc = (int)(btreeGetPage(pBt, (uint)(ovflPgno), pPage, (int)(0)));
        if ((rc) != 0)
            return (int)(rc);
        if ((sqlite3PagerPageRefcount(pPage.pDbPage) != 1) || ((pPage.isInit) != 0))
        {
            rc = (int)(sqlite3CorruptError((int)(74946)));
        }
        else
        {
            if ((iOffset + ovflPageSize) &lt; ((uint)(nTotal)))
            {
                ovflPgno = (uint)(sqlite3Get4byte(pPage.aData));
            }
            else
            {
                ovflPageSize = (uint)(nTotal - iOffset);
            }

            rc = (int)(btreeOverwriteContent(pPage, pPage.aData + 4, pX, (int)(iOffset), (int)(ovflPageSize)));
        }

        sqlite3PagerUnref(pPage.pDbPage);
        if ((rc) != 0)
            return (int)(rc);
        iOffset += (int)(ovflPageSize);
    }
    while ((iOffset) &lt; (nTotal));
    return (int)(0);
}</function>
  <function>public static int btreeOverwriteContent(MemPage pPage, byte* pDest, BtreePayload pX, int iOffset, int iAmt)
{
    int nData = (int)(pX.nData - iOffset);
    if ((nData) &lt;= (0))
    {
        int i = 0;
        for (i = (int)(0); ((i) &lt; (iAmt)) &amp;&amp; ((pDest[i]) == (0)); i++)
        {
        }

        if ((i) &lt; (iAmt))
        {
            int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
            if ((rc) != 0)
                return (int)(rc);
            CRuntime.memset(pDest + i, (int)(0), (ulong)(iAmt - i));
        }
    }
    else
    {
        if ((nData) &lt; (iAmt))
        {
            int rc = (int)(btreeOverwriteContent(pPage, pDest + nData, pX, (int)(iOffset + nData), (int)(iAmt - nData)));
            if ((rc) != 0)
                return (int)(rc);
            iAmt = (int)(nData);
        }

        if (memcmp(pDest, ((byte*)(pX.pData)) + iOffset, (ulong)(iAmt)) != 0)
        {
            int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
            if ((rc) != 0)
                return (int)(rc);
            CRuntime.memmove(pDest, ((byte*)(pX.pData)) + iOffset, (ulong)(iAmt));
        }
    }

    return (int)(0);
}</function>
  <function>public static uint btreePagecount(BtShared pBt)
{
    return (uint)(pBt.nPage);
}</function>
  <function>public static MemPage btreePageFromDbPage(PgHdr pDbPage, uint pgno, BtShared pBt)
{
    MemPage pPage = (MemPage)(sqlite3PagerGetExtra(pDbPage));
    if (pgno != pPage.pgno)
    {
        pPage.aData = sqlite3PagerGetData(pDbPage);
        pPage.pDbPage = pDbPage;
        pPage.pBt = pBt;
        pPage.pgno = (uint)(pgno);
        pPage.hdrOffset = (byte)((pgno) == (1) ? 100 : 0);
    }

    return pPage;
}</function>
  <function>public static MemPage btreePageLookup(BtShared pBt, uint pgno)
{
    PgHdr pDbPage;
    pDbPage = sqlite3PagerLookup(pBt.pPager, (uint)(pgno));
    if ((pDbPage) != null)
    {
        return btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
    }

    return null;
}</function>
  <function>public static void btreeParseCell(MemPage pPage, int iCell, CellInfo* pInfo)
{
    pPage.xParseCell(pPage, ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (iCell)]))))), pInfo);
}</function>
  <function>public static void btreeParseCellAdjustSizeForOverflow(MemPage pPage, byte* pCell, CellInfo* pInfo)
{
    int minLocal = 0;
    int maxLocal = 0;
    int surplus = 0;
    minLocal = (int)(pPage.minLocal);
    maxLocal = (int)(pPage.maxLocal);
    surplus = (int)(minLocal + (pInfo-&gt;nPayload - minLocal) % (pPage.pBt.usableSize - 4));
    if ((surplus) &lt;= (maxLocal))
    {
        pInfo-&gt;nLocal = ((ushort)(surplus));
    }
    else
    {
        pInfo-&gt;nLocal = ((ushort)(minLocal));
    }

    pInfo-&gt;nSize = (ushort)((ushort)(&amp;pInfo-&gt;pPayload[pInfo-&gt;nLocal] - pCell) + 4);
}</function>
  <function>public static void btreeParseCellPtr(MemPage pPage, byte* pCell, CellInfo* pInfo)
{
    byte* pIter;
    uint nPayload = 0;
    ulong iKey = 0;
    pIter = pCell;
    nPayload = (uint)(*pIter);
    if ((nPayload) &gt;= (0x80))
    {
        byte* pEnd = &amp;pIter[8];
        nPayload &amp;= (uint)(0x7f);
        do
        {
            nPayload = (uint)((nPayload &lt;&lt; 7) | (*++pIter &amp; 0x7f));
        }
        while (((*pIter) &gt;= (0x80)) &amp;&amp; ((pIter) &lt; (pEnd)));
    }

    pIter++;
    iKey = (ulong)(*pIter);
    if ((iKey) &gt;= (0x80))
    {
        byte x = 0;
        iKey = (ulong)(((iKey &amp; 0x7f) &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
        if ((x) &gt;= (0x80))
        {
            iKey = (ulong)((iKey &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
            if ((x) &gt;= (0x80))
            {
                iKey = (ulong)((iKey &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
                if ((x) &gt;= (0x80))
                {
                    iKey = (ulong)((iKey &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
                    if ((x) &gt;= (0x80))
                    {
                        iKey = (ulong)((iKey &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
                        if ((x) &gt;= (0x80))
                        {
                            iKey = (ulong)((iKey &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
                            if ((x) &gt;= (0x80))
                            {
                                iKey = (ulong)((iKey &lt;&lt; 7) | ((x = (byte)(*++pIter)) &amp; 0x7f));
                                if ((x) &gt;= (0x80))
                                {
                                    iKey = (ulong)((iKey &lt;&lt; 8) | (*++pIter));
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    pIter++;
    pInfo-&gt;nKey = (long)(*(long*)(&amp;iKey));
    pInfo-&gt;nPayload = (uint)(nPayload);
    pInfo-&gt;pPayload = pIter;
    if ((nPayload) &lt;= (pPage.maxLocal))
    {
        pInfo-&gt;nSize = (ushort)(nPayload + (ushort)(pIter - pCell));
        if ((pInfo-&gt;nSize) &lt; (4))
            pInfo-&gt;nSize = (ushort)(4);
        pInfo-&gt;nLocal = ((ushort)(nPayload));
    }
    else
    {
        btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
    }
}</function>
  <function>public static void btreeParseCellPtrIndex(MemPage pPage, byte* pCell, CellInfo* pInfo)
{
    byte* pIter;
    uint nPayload = 0;
    pIter = pCell + pPage.childPtrSize;
    nPayload = (uint)(*pIter);
    if ((nPayload) &gt;= (0x80))
    {
        byte* pEnd = &amp;pIter[8];
        nPayload &amp;= (uint)(0x7f);
        do
        {
            nPayload = (uint)((nPayload &lt;&lt; 7) | (*++pIter &amp; 0x7f));
        }
        while (((*(pIter)) &gt;= (0x80)) &amp;&amp; ((pIter) &lt; (pEnd)));
    }

    pIter++;
    pInfo-&gt;nKey = (long)(nPayload);
    pInfo-&gt;nPayload = (uint)(nPayload);
    pInfo-&gt;pPayload = pIter;
    if ((nPayload) &lt;= (pPage.maxLocal))
    {
        pInfo-&gt;nSize = (ushort)(nPayload + (ushort)(pIter - pCell));
        if ((pInfo-&gt;nSize) &lt; (4))
            pInfo-&gt;nSize = (ushort)(4);
        pInfo-&gt;nLocal = ((ushort)(nPayload));
    }
    else
    {
        btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
    }
}</function>
  <function>public static void btreeParseCellPtrNoPayload(MemPage pPage, byte* pCell, CellInfo* pInfo)
{
    pInfo-&gt;nSize = (ushort)(4 + sqlite3GetVarint(&amp;pCell[4], (ulong*)(&amp;pInfo-&gt;nKey)));
    pInfo-&gt;nPayload = (uint)(0);
    pInfo-&gt;nLocal = (ushort)(0);
    pInfo-&gt;pPayload = null;
    return;
}</function>
  <function>public static int btreePayloadToLocal(MemPage pPage, long nPayload)
{
    int maxLocal = 0;
    maxLocal = (int)(pPage.maxLocal);
    if ((nPayload) &lt;= (maxLocal))
    {
        return (int)(nPayload);
    }
    else
    {
        int minLocal = 0;
        int surplus = 0;
        minLocal = (int)(pPage.minLocal);
        surplus = (int)(minLocal + (nPayload - minLocal) % (pPage.pBt.usableSize - 4));
        return (int)(((surplus) &lt;= (maxLocal)) ? surplus : minLocal);
    }
}</function>
  <function>public static int btreePrevious(BtCursor pCur)
{
    int rc = 0;
    MemPage pPage;
    if (pCur.eState != 0)
    {
        rc = (int)((pCur.eState) &gt;= (3) ? btreeRestoreCursorPosition(pCur) : 0);
        if (rc != 0)
        {
            return (int)(rc);
        }

        if ((1) == (pCur.eState))
        {
            return (int)(101);
        }

        if ((2) == (pCur.eState))
        {
            pCur.eState = (byte)(0);
            if ((pCur.skipNext) &lt; (0))
                return (int)(0);
        }
    }

    pPage = pCur.pPage;
    if (pPage.leaf == 0)
    {
        int idx = (int)(pCur.ix);
        rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (idx)])))))))));
        if ((rc) != 0)
            return (int)(rc);
        rc = (int)(moveToRightmost(pCur));
    }
    else
    {
        while ((pCur.ix) == (0))
        {
            if ((pCur.iPage) == (0))
            {
                pCur.eState = (byte)(1);
                return (int)(101);
            }

            moveToParent(pCur);
        }

        pCur.ix--;
        pPage = pCur.pPage;
        if (((pPage.intKey) != 0) &amp;&amp; (pPage.leaf == 0))
        {
            rc = (int)(sqlite3BtreePrevious(pCur, (int)(0)));
        }
        else
        {
            rc = (int)(0);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void btreeReleaseAllCursorPages(BtCursor pCur)
{
    int i = 0;
    if ((pCur.iPage) &gt;= (0))
    {
        for (i = (int)(0); (i) &lt; (pCur.iPage); i++)
        {
            releasePageNotNull(pCur.apPage[i]);
        }

        releasePageNotNull(pCur.pPage);
        pCur.iPage = (sbyte)(-1);
    }
}</function>
  <function>public static int btreeRestoreCursorPosition(BtCursor pCur)
{
    int rc = 0;
    int skipNext = (int)(0);
    if ((pCur.eState) == (4))
    {
        return (int)(pCur.skipNext);
    }

    pCur.eState = (byte)(1);
    if ((sqlite3FaultSim((int)(410))) != 0)
    {
        rc = (int)(10);
    }
    else
    {
        rc = (int)(btreeMoveto(pCur, pCur.pKey, (long)(pCur.nKey), (int)(0), &amp;skipNext));
    }

    if ((rc) == (0))
    {
        sqlite3_free(pCur.pKey);
        pCur.pKey = null;
        if ((skipNext) != 0)
            pCur.skipNext = (int)(skipNext);
        if (((pCur.skipNext) != 0) &amp;&amp; ((pCur.eState) == (0)))
        {
            pCur.eState = (byte)(2);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int btreeSetHasContent(BtShared pBt, uint pgno)
{
    int rc = (int)(0);
    if (pBt.pHasContent == null)
    {
        pBt.pHasContent = sqlite3BitvecCreate((uint)(pBt.nPage));
        if (pBt.pHasContent == null)
        {
            rc = (int)(7);
        }
    }

    if (((rc) == (0)) &amp;&amp; ((pgno) &lt;= (sqlite3BitvecSize(pBt.pHasContent))))
    {
        rc = (int)(sqlite3BitvecSet(pBt.pHasContent, (uint)(pgno)));
    }

    return (int)(rc);
}</function>
  <function>public static void btreeSetNPage(BtShared pBt, MemPage pPage1)
{
    int nPage = (int)(sqlite3Get4byte(&amp;pPage1.aData[28]));
    if ((nPage) == (0))
        sqlite3PagerPagecount(pBt.pPager, &amp;nPage);
    pBt.nPage = (uint)(nPage);
}</function>
  <function>public static ushort cachedCellSize(CellArray p, int N)
{
    if ((p.szCell[N]) != 0)
        return (ushort)(p.szCell[N]);
    return (ushort)(computeCellSize(p, (int)(N)));
}</function>
  <function>public static void callCollNeeded(sqlite3 db, int enc, sbyte* zName)
{
    if ((db.xCollNeeded) != null)
    {
        sbyte* zExternal = sqlite3DbStrDup(db, zName);
        if (zExternal == null)
            return;
        db.xCollNeeded(db.pCollNeededArg, db, (int)(enc), zExternal);
        sqlite3DbFree(db, zExternal);
    }

    if ((db.xCollNeeded16) != null)
    {
        sbyte* zExternal;
        sqlite3_value pTmp = sqlite3ValueNew(db);
        sqlite3ValueSetStr(pTmp, (int)(-1), zName, (byte)(1), null);
        zExternal = sqlite3ValueText(pTmp, (byte)(2));
        if ((zExternal) != null)
        {
            db.xCollNeeded16(db.pCollNeededArg, db, (int)((db).enc), zExternal);
        }

        sqlite3ValueFree(pTmp);
    }
}</function>
  <function>public static void callFinaliser(sqlite3 db, int offset)
{
    int i = 0;
    if ((db.aVTrans) != null)
    {
        VTable aVTrans = db.aVTrans;
        db.aVTrans = null;
        for (i = (int)(0); (i) &lt; (db.nVTrans); i++)
        {
            VTable pVTab = aVTrans[i];
            sqlite3_vtab p = pVTab.pVtab;
            if ((p) != null)
            {
                delegate23 x;
                x = *(Int(sqlite3_vtab * ))((sbyte*)(p.pModule) + offset);
                if ((x) != null)
                    x(p);
            }

            pVTab.iSavepoint = (int)(0);
            sqlite3VtabUnlock(pVTab);
        }

        sqlite3DbFree(db, aVTrans);
        db.nVTrans = (int)(0);
    }
}</function>
  <function>public static void callStatGet(Parse pParse, int regStat, int iParam, int regOut)
{
    sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regStat), (int)(regOut), (int)(1 + 0), statGetFuncdef, (int)(0));
}</function>
  <function>public static int cannotBeFunction(Parse pParse, SrcItem pFrom)
{
    if ((pFrom.fg.isTabFunc) != 0)
    {
        sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom.zName);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void cdateFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    dateFunc(context, (int)(0), null);
}</function>
  <function>public static ushort cellSizePtr(MemPage pPage, byte* pCell)
{
    byte* pIter = pCell + pPage.childPtrSize;
    byte* pEnd;
    uint nSize = 0;
    nSize = (uint)(*pIter);
    if ((nSize) &gt;= (0x80))
    {
        pEnd = &amp;pIter[8];
        nSize &amp;= (uint)(0x7f);
        do
        {
            nSize = (uint)((nSize &lt;&lt; 7) | (*++pIter &amp; 0x7f));
        }
        while (((*(pIter)) &gt;= (0x80)) &amp;&amp; ((pIter) &lt; (pEnd)));
    }

    pIter++;
    if ((pPage.intKey) != 0)
    {
        pEnd = &amp;pIter[9];
        while ((((*pIter++) &amp; 0x80) != 0) &amp;&amp; ((pIter) &lt; (pEnd)))
        {
        }
    }

    if ((nSize) &lt;= (pPage.maxLocal))
    {
        nSize += ((uint)(pIter - pCell));
        if ((nSize) &lt; (4))
            nSize = (uint)(4);
    }
    else
    {
        int minLocal = (int)(pPage.minLocal);
        nSize = (uint)(minLocal + (nSize - minLocal) % (pPage.pBt.usableSize - 4));
        if ((nSize) &gt; (pPage.maxLocal))
        {
            nSize = (uint)(minLocal);
        }

        nSize += (uint)(4 + (ushort)(pIter - pCell));
    }

    return (ushort)(nSize);
}</function>
  <function>public static ushort cellSizePtrNoPayload(MemPage pPage, byte* pCell)
{
    byte* pIter = pCell + 4;
    byte* pEnd;
    pEnd = pIter + 9;
    while ((((*pIter++) &amp; 0x80) != 0) &amp;&amp; ((pIter) &lt; (pEnd)))
    {
    }

    return (ushort)(pIter - pCell);
}</function>
  <function>public static void changes(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    sqlite3_result_int64(context, (long)(sqlite3_changes64(db)));
}</function>
  <function>public static int changeTempStorage(Parse pParse, sbyte* zStorageType)
{
    int ts = (int)(getTempStore(zStorageType));
    sqlite3 db = pParse.db;
    if ((db.temp_store) == (ts))
        return (int)(0);
    if (invalidateTempStorage(pParse) != 0)
    {
        return (int)(1);
    }

    db.temp_store = ((byte)(ts));
    return (int)(0);
}</function>
  <function>public static void charFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* z; byte  * zOut ; 
    int i = 0;
    zOut = z = sqlite3_malloc64((ulong)(argc * 4 + 1));
    if ((z) == (null))
    {
        sqlite3_result_error_nomem(context);
        return;
    }

    for (i = (int)(0); (i) &lt; (argc); i++)
    {
        long x = 0;
        uint c = 0;
        x = (long)(sqlite3_value_int64(argv[i]));
        if (((x) &lt; (0)) || ((x) &gt; (0x10ffff)))
            x = (long)(0xfffd);
        c = ((uint)(x &amp; 0x1fffff));
        if ((c) &lt; (0x00080))
        {
            *zOut++ = ((byte)(c &amp; 0xFF));
        }
        else if ((c) &lt; (0x00800))
        {
            *zOut++ = (byte)(0xC0 + (byte)((c &gt;&gt; 6) &amp; 0x1F));
            *zOut++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
        }
        else if ((c) &lt; (0x10000))
        {
            *zOut++ = (byte)(0xE0 + (byte)((c &gt;&gt; 12) &amp; 0x0F));
            *zOut++ = (byte)(0x80 + (byte)((c &gt;&gt; 6) &amp; 0x3F));
            *zOut++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
        }
        else
        {
            *zOut++ = (byte)(0xF0 + (byte)((c &gt;&gt; 18) &amp; 0x07));
            *zOut++ = (byte)(0x80 + (byte)((c &gt;&gt; 12) &amp; 0x3F));
            *zOut++ = (byte)(0x80 + (byte)((c &gt;&gt; 6) &amp; 0x3F));
            *zOut++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
        }
    }

    sqlite3_result_text64(context, (sbyte*)(z), (ulong)(zOut - z), sqlite3_free, (byte)(1));
}</function>
  <function>public static void checkAppendMsg(IntegrityCk pCheck, sbyte* zFormat)
{
    sbyte* ap;
    if (pCheck.mxErr == 0)
        return;
    pCheck.mxErr--;
    pCheck.nErr++;
    (__va_start(&amp;ap, zFormat));
    if ((pCheck.errMsg.nChar) != 0)
    {
        sqlite3_str_append(pCheck.errMsg, "\n", (int)(1));
    }

    if ((pCheck.zPfx) != null)
    {
        sqlite3_str_appendf(pCheck.errMsg, pCheck.zPfx, (uint)(pCheck.v1), (int)(pCheck.v2));
    }

    sqlite3_str_vappendf(pCheck.errMsg, zFormat, ap);
    ((void)(ap = null));
    if ((pCheck.errMsg.accError) == (7))
    {
        pCheck.bOomFault = (int)(1);
    }
}</function>
  <function>public static int checkColumnOverlap(IdList* pIdList, ExprList pEList)
{
    int e = 0;
    if (((pIdList) == (null)) || ((pEList) == (null)))
        return (int)(1);
    for (e = (int)(0); (e) &lt; (pEList.nExpr); e++)
    {
        if ((sqlite3IdListIndex(pIdList, pEList.a[e].zEName)) &gt;= (0))
            return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int checkConstraintExprNode(Walker pWalker, Expr pExpr)
{
    if ((pExpr.op) == (167))
    {
        if ((pExpr.iColumn) &gt;= (0))
        {
            if ((pWalker.u.aiCol[pExpr.iColumn]) &gt;= (0))
            {
                pWalker.eCode |= (ushort)(0x01);
            }
        }
        else
        {
            pWalker.eCode |= (ushort)(0x02);
        }
    }

    return (int)(0);
}</function>
  <function>public static void checkList(IntegrityCk pCheck, int isFreeList, uint iPage, uint N)
{
    int i = 0;
    uint expected = (uint)(N);
    int nErrAtStart = (int)(pCheck.nErr);
    while ((iPage != 0) &amp;&amp; ((pCheck.mxErr) != 0))
    {
        PgHdr pOvflPage;
        byte* pOvflData;
        if ((checkRef(pCheck, (uint)(iPage))) != 0)
            break;
        N--;
        if ((sqlite3PagerGet(pCheck.pPager, (uint)(iPage), pOvflPage, (int)(0))) != 0)
        {
            checkAppendMsg(pCheck, "failed to get page %d", (uint)(iPage));
            break;
        }

        pOvflData = (byte*)(sqlite3PagerGetData(pOvflPage));
        if ((isFreeList) != 0)
        {
            uint n = (uint)(sqlite3Get4byte(&amp;pOvflData[4]));
            if ((pCheck.pBt.autoVacuum) != 0)
            {
                checkPtrmap(pCheck, (uint)(iPage), (byte)(2), (uint)(0));
            }

            if ((n) &gt; (pCheck.pBt.usableSize / 4 - 2))
            {
                checkAppendMsg(pCheck, "freelist leaf count too big on page %d", (uint)(iPage));
                N--;
            }
            else
            {
                for (i = (int)(0); (i) &lt; ((int)(n)); i++)
                {
                    uint iFreePage = (uint)(sqlite3Get4byte(&amp;pOvflData[8 + i * 4]));
                    if ((pCheck.pBt.autoVacuum) != 0)
                    {
                        checkPtrmap(pCheck, (uint)(iFreePage), (byte)(2), (uint)(0));
                    }

                    checkRef(pCheck, (uint)(iFreePage));
                }

                N -= (uint)(n);
            }
        }
        else
        {
            if (((pCheck.pBt.autoVacuum) != 0) &amp;&amp; ((N) &gt; (0)))
            {
                i = (int)(sqlite3Get4byte(pOvflData));
                checkPtrmap(pCheck, (uint)(i), (byte)(4), (uint)(iPage));
            }
        }

        iPage = (uint)(sqlite3Get4byte(pOvflData));
        sqlite3PagerUnref(pOvflPage);
    }

    if (((N) != 0) &amp;&amp; ((nErrAtStart) == (pCheck.nErr)))
    {
        checkAppendMsg(pCheck, "%s is %d but should be %d", (isFreeList) != 0 ? "size" : "overflow list length", (uint)(expected - N), (uint)(expected));
    }
}</function>
  <function>public static void checkPtrmap(IntegrityCk pCheck, uint iChild, byte eType, uint iParent)
{
    int rc = 0;
    byte ePtrmapType = 0;
    uint iPtrmapParent = 0;
    rc = (int)(ptrmapGet(pCheck.pBt, (uint)(iChild), &amp;ePtrmapType, &amp;iPtrmapParent));
    if (rc != 0)
    {
        if (((rc) == (7)) || ((rc) == (10 | (12 &lt;&lt; 8))))
            pCheck.bOomFault = (int)(1);
        checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", (uint)(iChild));
        return;
    }

    if ((ePtrmapType != eType) || (iPtrmapParent != iParent))
    {
        checkAppendMsg(pCheck, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", (uint)(iChild), (int)(eType), (uint)(iParent), (int)(ePtrmapType), (uint)(iPtrmapParent));
    }
}</function>
  <function>public static int checkReadTransaction(sqlite3 db, Btree p)
{
    if (sqlite3BtreeTxnState(p) != 0)
    {
        sqlite3ErrorWithMsg(db, (int)(1), "destination database is in use");
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int checkRef(IntegrityCk pCheck, uint iPage)
{
    if (((iPage) &gt; (pCheck.nPage)) || ((iPage) == (0)))
    {
        checkAppendMsg(pCheck, "invalid page number %d", (uint)(iPage));
        return (int)(1);
    }

    if ((getPageReferenced(pCheck, (uint)(iPage))) != 0)
    {
        checkAppendMsg(pCheck, "2nd reference to page %d", (uint)(iPage));
        return (int)(1);
    }

    if ((0) != 0)
        return (int)(1);
    setPageReferenced(pCheck, (uint)(iPage));
    return (int)(0);
}</function>
  <function>public static int checkTreePage(IntegrityCk pCheck, uint iPage, long* piMinKey, long maxKey)
{
    MemPage pPage = null;
    int i = 0;
    int rc = 0;
    int depth = (int)(-1); int  d2  =  0 ; 
    int pgno = 0;
    int nFrag = 0;
    int hdr = 0;
    int cellStart = 0;
    int nCell = 0;
    int doCoverageCheck = (int)(1);
    int keyCanBeEqual = (int)(1);
    byte* data;
    byte* pCell;
    byte* pCellIdx;
    BtShared pBt;
    uint pc = 0;
    uint usableSize = 0;
    uint contentOffset = 0;
    uint* heap = null;
    uint x = 0; uint  prev  =  ( uint ) ( 0 ) ; 
    sbyte* saved_zPfx = pCheck.zPfx;
    int saved_v1 = (int)(pCheck.v1);
    int saved_v2 = (int)(pCheck.v2);
    byte savedIsInit = (byte)(0);
    pBt = pCheck.pBt;
    usableSize = (uint)(pBt.usableSize);
    if ((iPage) == (0))
        return (int)(0);
    if ((checkRef(pCheck, (uint)(iPage))) != 0)
        return (int)(0);
    pCheck.zPfx = "Page %u: ";
    pCheck.v1 = (uint)(iPage);
    if ((rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0)))) != 0)
    {
        checkAppendMsg(pCheck, "unable to get the page. error code=%d", (int)(rc));
        goto end_of_check;
    }

    savedIsInit = (byte)(pPage.isInit);
    pPage.isInit = (byte)(0);
    if ((rc = (int)(btreeInitPage(pPage))) != 0)
    {
        checkAppendMsg(pCheck, "btreeInitPage() returns error code %d", (int)(rc));
        goto end_of_check;
    }

    if ((rc = (int)(btreeComputeFreeSpace(pPage))) != 0)
    {
        checkAppendMsg(pCheck, "free space corruption", (int)(rc));
        goto end_of_check;
    }

    data = pPage.aData;
    hdr = (int)(pPage.hdrOffset);
    pCheck.zPfx = "On tree page %u cell %d: ";
    contentOffset = (uint)(((((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]) - 1) &amp; 0xffff) + 1);
    nCell = (int)((&amp;data[hdr + 3])[0] &lt;&lt; 8 | (&amp;data[hdr + 3])[1]);
    cellStart = (int)(hdr + 12 - 4 * pPage.leaf);
    pCellIdx = &amp;data[cellStart + 2 * (nCell - 1)];
    if (pPage.leaf == 0)
    {
        pgno = (int)(sqlite3Get4byte(&amp;data[hdr + 8]));
        if ((pBt.autoVacuum) != 0)
        {
            pCheck.zPfx = "On page %u at right child: ";
            checkPtrmap(pCheck, (uint)(pgno), (byte)(5), (uint)(iPage));
        }

        depth = (int)(checkTreePage(pCheck, (uint)(pgno), &amp;maxKey, (long)(maxKey)));
        keyCanBeEqual = (int)(0);
    }
    else
    {
        heap = pCheck.heap;
        heap[0] = (uint)(0);
    }

    for (i = (int)(nCell - 1); ((i) &gt;= (0)) &amp;&amp; ((pCheck.mxErr) != 0); i--)
    {
        CellInfo info = new CellInfo();
        pCheck.v2 = (int)(i);
        pc = (uint)(_byteswap_ushort((ushort)(*(ushort*)(pCellIdx))));
        pCellIdx -= 2;
        if (((pc) &lt; (contentOffset)) || ((pc) &gt; (usableSize - 4)))
        {
            checkAppendMsg(pCheck, "Offset %d out of range %d..%d", (uint)(pc), (uint)(contentOffset), (uint)(usableSize - 4));
            doCoverageCheck = (int)(0);
            continue;
        }

        pCell = &amp;data[pc];
        pPage.xParseCell(pPage, pCell, &amp;info);
        if ((pc + info.nSize) &gt; (usableSize))
        {
            checkAppendMsg(pCheck, "Extends off end of page");
            doCoverageCheck = (int)(0);
            continue;
        }

        if ((pPage.intKey) != 0)
        {
            if (((keyCanBeEqual) != 0 ? ((info.nKey) &gt; (maxKey)) : ((info.nKey) &gt;= (maxKey))) != 0)
            {
                checkAppendMsg(pCheck, "Rowid %lld out of order", (long)(info.nKey));
            }

            maxKey = (long)(info.nKey);
            keyCanBeEqual = (int)(0);
        }

        if ((info.nPayload) &gt; (info.nLocal))
        {
            uint nPage = 0;
            uint pgnoOvfl = 0;
            nPage = (uint)((info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4));
            pgnoOvfl = (uint)(sqlite3Get4byte(&amp;pCell[info.nSize - 4]));
            if ((pBt.autoVacuum) != 0)
            {
                checkPtrmap(pCheck, (uint)(pgnoOvfl), (byte)(3), (uint)(iPage));
            }

            checkList(pCheck, (int)(0), (uint)(pgnoOvfl), (uint)(nPage));
        }

        if (pPage.leaf == 0)
        {
            pgno = (int)(sqlite3Get4byte(pCell));
            if ((pBt.autoVacuum) != 0)
            {
                checkPtrmap(pCheck, (uint)(pgno), (byte)(5), (uint)(iPage));
            }

            d2 = (int)(checkTreePage(pCheck, (uint)(pgno), &amp;maxKey, (long)(maxKey)));
            keyCanBeEqual = (int)(0);
            if (d2 != depth)
            {
                checkAppendMsg(pCheck, "Child page depth differs");
                depth = (int)(d2);
            }
        }
        else
        {
            btreeHeapInsert(heap, (uint)((pc &lt;&lt; 16) | (pc + info.nSize - 1)));
        }
    }

    *piMinKey = (long)(maxKey);
    pCheck.zPfx = null;
    if (((doCoverageCheck) != 0) &amp;&amp; ((pCheck.mxErr) &gt; (0)))
    {
        if (pPage.leaf == 0)
        {
            heap = pCheck.heap;
            heap[0] = (uint)(0);
            for (i = (int)(nCell - 1); (i) &gt;= (0); i--)
            {
                uint size = 0;
                pc = (uint)(_byteswap_ushort((ushort)(*(ushort*)(&amp;data[cellStart + i * 2]))));
                size = (uint)(pPage.xCellSize(pPage, &amp;data[pc]));
                btreeHeapInsert(heap, (uint)((pc &lt;&lt; 16) | (pc + size - 1)));
            }
        }

        i = (int)((&amp;data[hdr + 1])[0] &lt;&lt; 8 | (&amp;data[hdr + 1])[1]);
        while ((i) &gt; (0))
        {
            int size = 0;
            int j = 0;
            size = (int)((&amp;data[i + 2])[0] &lt;&lt; 8 | (&amp;data[i + 2])[1]);
            btreeHeapInsert(heap, (uint)((((uint)(i)) &lt;&lt; 16) | (i + size - 1)));
            j = (int)((&amp;data[i])[0] &lt;&lt; 8 | (&amp;data[i])[1]);
            i = (int)(j);
        }

        nFrag = (int)(0);
        prev = (uint)(contentOffset - 1);
        while ((btreeHeapPull(heap, &amp;x)) != 0)
        {
            if ((prev &amp; 0xffff) &gt;= (x &gt;&gt; 16))
            {
                checkAppendMsg(pCheck, "Multiple uses for byte %u of page %u", (uint)(x &gt;&gt; 16), (uint)(iPage));
                break;
            }
            else
            {
                nFrag += (int)((x &gt;&gt; 16) - (prev &amp; 0xffff) - 1);
                prev = (uint)(x);
            }
        }

        nFrag += (int)(usableSize - (prev &amp; 0xffff) - 1);
        if (((heap[0]) == (0)) &amp;&amp; (nFrag != data[hdr + 7]))
        {
            checkAppendMsg(pCheck, "Fragmentation of %d bytes reported as %d on page %u", (int)(nFrag), (int)(data[hdr + 7]), (uint)(iPage));
        }
    }

    end_of_check:
        ; if  ( doCoverageCheck == 0 ) pPage . isInit  =  ( byte ) ( savedIsInit ) ; 
    releasePage(pPage);
    pCheck.zPfx = saved_zPfx;
    pCheck.v1 = (uint)(saved_v1);
    pCheck.v2 = (int)(saved_v2);
    return (int)(depth + 1);
}</function>
  <function>public static void clearAllSharedCacheTableLocks(Btree p)
{
    BtShared pBt = p.pBt;
    BtLock ppIter = pBt.pLock;
    while ((ppIter) != null)
    {
        BtLock pLock = ppIter;
        if ((pLock.pBtree) == (p))
        {
            ppIter = pLock.pNext;
            if (pLock.iTable != 1)
            {
                sqlite3_free(pLock);
            }
        }
        else
        {
            ppIter = pLock.pNext;
        }
    }

    if ((pBt.pWriter) == (p))
    {
        pBt.pWriter = null;
        pBt.btsFlags &amp;= (ushort)(~(0x0040 | 0x0080));
    }
    else if ((pBt.nTransaction) == (2))
    {
        pBt.btsFlags &amp;= (ushort)(~0x0080);
    }
}</function>
  <function>public static int clearCellOverflow(MemPage pPage, byte* pCell, CellInfo* pInfo)
{
    BtShared pBt;
    uint ovflPgno = 0;
    int rc = 0;
    int nOvfl = 0;
    uint ovflPageSize = 0;
    if ((pCell + pInfo-&gt;nSize) &gt; (pPage.aDataEnd))
    {
        return (int)(sqlite3CorruptError((int)(72724)));
    }

    ovflPgno = (uint)(sqlite3Get4byte(pCell + pInfo-&gt;nSize - 4));
    pBt = pPage.pBt;
    ovflPageSize = (uint)(pBt.usableSize - 4);
    nOvfl = (int)((pInfo-&gt;nPayload - pInfo-&gt;nLocal + ovflPageSize - 1) / ovflPageSize);
    while ((nOvfl--) != 0)
    {
        uint iNext = (uint)(0);
        MemPage pOvfl = null;
        if (((ovflPgno) &lt; (2)) || ((ovflPgno) &gt; (btreePagecount(pBt))))
        {
            return (int)(sqlite3CorruptError((int)(72741)));
        }

        if ((nOvfl) != 0)
        {
            rc = (int)(getOverflowPage(pBt, (uint)(ovflPgno), pOvfl, &amp;iNext));
            if ((rc) != 0)
                return (int)(rc);
        }

        if ((((pOvfl) != null) || ((pOvfl = btreePageLookup(pBt, (uint)(ovflPgno))) != null)) &amp;&amp; (sqlite3PagerPageRefcount(pOvfl.pDbPage) != 1))
        {
            rc = (int)(sqlite3CorruptError((int)(72761)));
        }
        else
        {
            rc = (int)(freePage2(pBt, pOvfl, (uint)(ovflPgno)));
        }

        if ((pOvfl) != null)
        {
            sqlite3PagerUnref(pOvfl.pDbPage);
        }

        if ((rc) != 0)
            return (int)(rc);
        ovflPgno = (uint)(iNext);
    }

    return (int)(0);
}</function>
  <function>public static int clearDatabasePage(BtShared pBt, uint pgno, int freePageFlag, long* pnChange)
{
    MemPage pPage;
    int rc = 0;
    byte* pCell;
    int i = 0;
    int hdr = 0;
    CellInfo info = new CellInfo();
    if ((pgno) &gt; (btreePagecount(pBt)))
    {
        return (int)(sqlite3CorruptError((int)(75785)));
    }

    rc = (int)(getAndInitPage(pBt, (uint)(pgno), pPage, null, (int)(0)));
    if ((rc) != 0)
        return (int)(rc);
    if (((pBt.openFlags &amp; 4) == (0)) &amp;&amp; (sqlite3PagerPageRefcount(pPage.pDbPage) != (1 + ((pgno) == (1)))))
    {
        rc = (int)(sqlite3CorruptError((int)(75792)));
        goto cleardatabasepage_out;
    }

    hdr = (int)(pPage.hdrOffset);
    for (i = (int)(0); (i) &lt; (pPage.nCell); i++)
    {
        pCell = ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (i)])))));
        if (pPage.leaf == 0)
        {
            rc = (int)(clearDatabasePage(pBt, (uint)(sqlite3Get4byte(pCell)), (int)(1), pnChange));
            if ((rc) != 0)
                goto cleardatabasepage_out;
        }

        pPage.xParseCell(pPage, pCell, &amp;info);
        if (info.nLocal != info.nPayload)
        {
            rc = (int)(clearCellOverflow(pPage, pCell, &amp;info));
        }
        else
        {
            rc = (int)(0);
        }

        if ((rc) != 0)
            goto cleardatabasepage_out;
    }

    if (pPage.leaf == 0)
    {
        rc = (int)(clearDatabasePage(pBt, (uint)(sqlite3Get4byte(&amp;pPage.aData[hdr + 8])), (int)(1), pnChange));
        if ((rc) != 0)
            goto cleardatabasepage_out;
        if ((pPage.intKey) != 0)
            pnChange = null;
    }

    if ((pnChange) != null)
    {
        *pnChange += (long)(pPage.nCell);
    }

    if ((freePageFlag) != 0)
    {
        freePage(pPage, &amp;rc);
    }
    else if ((rc = (int)(sqlite3PagerWrite(pPage.pDbPage))) == (0))
    {
        zeroPage(pPage, (int)(pPage.aData[hdr] | 0x08));
    }

    cleardatabasepage_out:
        ; releasePage ( pPage ) ; 
    return (int)(rc);
}</function>
  <function>public static void clearSelect(sqlite3 db, Select p, int bFree)
{
    while ((p) != null)
    {
        Select pPrior = p.pPrior;
        sqlite3ExprListDelete(db, p.pEList);
        sqlite3SrcListDelete(db, p.pSrc);
        sqlite3ExprDelete(db, p.pWhere);
        sqlite3ExprListDelete(db, p.pGroupBy);
        sqlite3ExprDelete(db, p.pHaving);
        sqlite3ExprListDelete(db, p.pOrderBy);
        sqlite3ExprDelete(db, p.pLimit);
        if ((p.pWith) != null)
            sqlite3WithDelete(db, p.pWith);
        if ((p.pWinDefn) != null)
        {
            sqlite3WindowListDelete(db, p.pWinDefn);
        }

        while ((p.pWin) != null)
        {
            sqlite3WindowUnlinkFromSelect(p.pWin);
        }

        if ((bFree) != 0)
            sqlite3DbFreeNN(db, p);
        p = pPrior;
        bFree = (int)(1);
    }
}</function>
  <function>public static void clearYMD_HMS_TZ(DateTime* p)
{
    p-&gt;validYMD = (sbyte)(0);
    p-&gt;validHMS = (sbyte)(0);
    p-&gt;validTZ = (sbyte)(0);
}</function>
  <function>public static void closeAllCursors(Vdbe p)
{
    if ((p.pFrame) != null)
    {
        VdbeFrame pFrame;
        for (pFrame = p.pFrame; pFrame.pParent; pFrame = pFrame.pParent)
        {
        }

        sqlite3VdbeFrameRestore(pFrame);
        p.pFrame = null;
        p.nFrame = (int)(0);
    }

    closeCursorsInFrame(p);
    if ((p.aMem) != null)
    {
        releaseMemArray(p.aMem, (int)(p.nMem));
    }

    while ((p.pDelFrame) != null)
    {
        VdbeFrame pDel = p.pDelFrame;
        p.pDelFrame = pDel.pParent;
        sqlite3VdbeFrameDelete(pDel);
    }

    if ((p.pAuxData) != null)
        sqlite3VdbeDeleteAuxData(p.db, p.pAuxData, (int)(-1), (int)(0));
}</function>
  <function>public static void closeCursorsInFrame(Vdbe p)
{
    if ((p.apCsr) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (p.nCursor); i++)
        {
            VdbeCursor pC = p.apCsr[i];
            if ((pC) != null)
            {
                sqlite3VdbeFreeCursor(p, pC);
                p.apCsr[i] = null;
            }
        }
    }
}</function>
  <function>public static int codeAllEqualityTerms(Parse pParse, WhereLevel pLevel, int bRev, int nExtraReg, sbyte** pzAff)
{
    ushort nEq = 0;
    ushort nSkip = 0;
    Vdbe v = pParse.pVdbe;
    Index pIdx;
    WhereTerm pTerm;
    WhereLoop pLoop;
    int j = 0;
    int regBase = 0;
    int nReg = 0;
    sbyte* zAff;
    pLoop = pLevel.pWLoop;
    nEq = (ushort)(pLoop.u.btree.nEq);
    nSkip = (ushort)(pLoop.nSkip);
    pIdx = pLoop.u.btree.pIndex;
    regBase = (int)(pParse.nMem + 1);
    nReg = (int)(pLoop.u.btree.nEq + nExtraReg);
    pParse.nMem += (int)(nReg);
    zAff = sqlite3DbStrDup(pParse.db, sqlite3IndexAffinityStr(pParse.db, pIdx));
    if ((nSkip) != 0)
    {
        int iIdxCur = (int)(pLevel.iIdxCur);
        sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(regBase), (int)(regBase + nSkip - 1));
        sqlite3VdbeAddOp1(v, (int)((bRev) != 0 ? 34 : 38), (int)(iIdxCur));
        j = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
        pLevel.addrSkip = (int)(sqlite3VdbeAddOp4Int(v, (int)((bRev) != 0 ? 23 : 26), (int)(iIdxCur), (int)(0), (int)(regBase), (int)(nSkip)));
        sqlite3VdbeJumpHere(v, (int)(j));
        for (j = (int)(0); (j) &lt; (nSkip); j++)
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(j), (int)(regBase + j));
        }
    }

    for (j = (int)(nSkip); (j) &lt; (nEq); j++)
    {
        int r1 = 0;
        pTerm = pLoop.aLTerm[j];
        r1 = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(j), (int)(bRev), (int)(regBase + j)));
        if (r1 != regBase + j)
        {
            if ((nReg) == (1))
            {
                sqlite3ReleaseTempReg(pParse, (int)(regBase));
                regBase = (int)(r1);
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(79), (int)(r1), (int)(regBase + j));
            }
        }
    }

    for (j = (int)(nSkip); (j) &lt; (nEq); j++)
    {
        pTerm = pLoop.aLTerm[j];
        if ((pTerm.eOperator &amp; 0x0001) != 0)
        {
            if ((pTerm.pExpr.flags &amp; 0x000800) != 0)
            {
                if ((zAff) != null)
                    zAff[j] = (sbyte)(0x41);
            }
        }
        else if ((pTerm.eOperator &amp; 0x0100) == (0))
        {
            Expr pRight = pTerm.pExpr.pRight;
            if (((pTerm.wtFlags &amp; 0x0800) == (0)) &amp;&amp; ((sqlite3ExprCanBeNull(pRight)) != 0))
            {
                sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + j), (int)(pLevel.addrBrk));
            }

            if ((pParse.nErr) == (0))
            {
                if ((sqlite3CompareAffinity(pRight, (sbyte)(zAff[j]))) == (0x41))
                {
                    zAff[j] = (sbyte)(0x41);
                }

                if ((sqlite3ExprNeedsNoAffinityChange(pRight, (sbyte)(zAff[j]))) != 0)
                {
                    zAff[j] = (sbyte)(0x41);
                }
            }
        }
    }

    *pzAff = zAff;
    return (int)(regBase);
}</function>
  <function>public static void codeApplyAffinity(Parse pParse, int _base_, int n, sbyte* zAff)
{
    Vdbe v = pParse.pVdbe;
    if ((zAff) == (null))
    {
        return;
    }

    while (((n) &gt; (0)) &amp;&amp; ((zAff[0]) &lt;= (0x41)))
    {
        n--;
        _base_++;
        zAff++;
    }

    while (((n) &gt; (1)) &amp;&amp; ((zAff[n - 1]) &lt;= (0x41)))
    {
        n--;
    }

    if ((n) &gt; (0))
    {
        sqlite3VdbeAddOp4(v, (int)(95), (int)(_base_), (int)(n), (int)(0), zAff, (int)(n));
    }
}</function>
  <function>public static void codeAttach(Parse pParse, int type, FuncDef pFunc, Expr pAuthArg, Expr pFilename, Expr pDbname, Expr pKey)
{
    int rc = 0;
    NameContext sName = new NameContext();
    Vdbe v;
    sqlite3 db = pParse.db;
    int regArgs = 0;
    if ((pParse.nErr) != 0)
        goto attach_end;
    CRuntime.memset(sName, (int)(0), (ulong)(sizeof(NameContext)));
    sName.pParse = pParse;
    if (((0 != resolveAttachExpr(sName, pFilename)) || (0 != resolveAttachExpr(sName, pDbname))) || (0 != resolveAttachExpr(sName, pKey)))
    {
        goto attach_end;
    }

    if ((pAuthArg) != null)
    {
        sbyte* zAuthArg;
        if ((pAuthArg.op) == (117))
        {
            zAuthArg = pAuthArg.u.zToken;
        }
        else
        {
            zAuthArg = null;
        }

        rc = (int)(sqlite3AuthCheck(pParse, (int)(type), zAuthArg, null, null));
        if (rc != 0)
        {
            goto attach_end;
        }
    }

    v = sqlite3GetVdbe(pParse);
    regArgs = (int)(sqlite3GetTempRange(pParse, (int)(4)));
    sqlite3ExprCode(pParse, pFilename, (int)(regArgs));
    sqlite3ExprCode(pParse, pDbname, (int)(regArgs + 1));
    sqlite3ExprCode(pParse, pKey, (int)(regArgs + 2));
    if ((v) != null)
    {
        sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regArgs + 3 - pFunc.nArg), (int)(regArgs + 3), (int)(pFunc.nArg), pFunc, (int)(0));
        sqlite3VdbeAddOp1(v, (int)(165), (((type) == (24)) ? 1 : 0));
    }

    attach_end:
        ; sqlite3ExprDelete ( db ,  pFilename ) ; 
    sqlite3ExprDelete(db, pDbname);
    sqlite3ExprDelete(db, pKey);
}</function>
  <function>public static int codeCompare(Parse pParse, Expr pLeft, Expr pRight, int opcode, int in1, int in2, int dest, int jumpIfNull, int isCommuted)
{
    int p5 = 0;
    int addr = 0;
    CollSeq p4;
    if ((pParse.nErr) != 0)
        return (int)(0);
    if ((isCommuted) != 0)
    {
        p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
    }
    else
    {
        p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
    }

    p5 = (int)(binaryCompareP5(pLeft, pRight, (int)(jumpIfNull)));
    addr = (int)(sqlite3VdbeAddOp4(pParse.pVdbe, (int)(opcode), (int)(in2), (int)(dest), (int)(in1), (void*)(p4), (int)(-2)));
    sqlite3VdbeChangeP5(pParse.pVdbe, (ushort)((byte)(p5)));
    return (int)(addr);
}</function>
  <function>public static void codeDeferredSeek(WhereInfo pWInfo, Index pIdx, int iCur, int iIdxCur)
{
    Parse pParse = pWInfo.pParse;
    Vdbe v = pParse.pVdbe;
    pWInfo.bDeferredSeek = (uint)(1);
    sqlite3VdbeAddOp3(v, (int)(140), (int)(iIdxCur), (int)(0), (int)(iCur));
    if (((pWInfo.wctrlFlags &amp; 0x0020) != 0) &amp;&amp; ((((pParse).pToplevel ? (pParse).pToplevel : (pParse)).writeMask) == (0)))
    {
        int i = 0;
        Table pTab = pIdx.pTable;
        uint* ai = (uint*)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(uint) * (pTab.nCol + 1))));
        if ((ai) != null)
        {
            ai[0] = (uint)(pTab.nCol);
            for (i = (int)(0); (i) &lt; (pIdx.nColumn - 1); i++)
            {
                int x1 = 0;
                int x2 = 0;
                x1 = (int)(pIdx.aiColumn[i]);
                x2 = (int)(sqlite3TableColumnToStorage(pTab, (short)(x1)));
                if ((x1) &gt;= (0))
                    ai[x2 + 1] = (uint)(i + 1);
            }

            sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(ai), (int)(-15));
        }
    }
}</function>
  <function>public static int codeDistinct(Parse pParse, int eTnctType, int iTab, int addrRepeat, ExprList pEList, int regElem)
{
    int iRet = (int)(0);
    int nResultCol = (int)(pEList.nExpr);
    Vdbe v = pParse.pVdbe;
    switch (eTnctType)
    {
        case 2:
        {
            int i = 0;
            int iJump = 0;
            int regPrev = 0;
            iRet = (int)(regPrev = (int)(pParse.nMem + 1));
            pParse.nMem += (int)(nResultCol);
            iJump = (int)(sqlite3VdbeCurrentAddr(v) + nResultCol);
            for (i = (int)(0); (i) &lt; (nResultCol); i++)
            {
                CollSeq pColl = sqlite3ExprCollSeq(pParse, pEList.a[i].pExpr);
                if ((i) &lt; (nResultCol - 1))
                {
                    sqlite3VdbeAddOp3(v, (int)(52), (int)(regElem + i), (int)(iJump), (int)(regPrev + i));
                }
                else
                {
                    sqlite3VdbeAddOp3(v, (int)(53), (int)(regElem + i), (int)(addrRepeat), (int)(regPrev + i));
                }

                sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pColl), (int)(-2));
                sqlite3VdbeChangeP5(v, (ushort)(0x80));
            }

            sqlite3VdbeAddOp3(v, (int)(79), (int)(regElem), (int)(regPrev), (int)(nResultCol - 1));
            break;
        }

        case 1:
        {
            break;
        }

        default:
        {
            int r1 = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iTab), (int)(addrRepeat), (int)(regElem), (int)(nResultCol));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(regElem), (int)(nResultCol), (int)(r1));
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iTab), (int)(r1), (int)(regElem), (int)(nResultCol));
            sqlite3VdbeChangeP5(v, (ushort)(0x10));
            sqlite3ReleaseTempReg(pParse, (int)(r1));
            iRet = (int)(iTab);
            break;
        }
    }

    return (int)(iRet);
}</function>
  <function>public static int codeEqualityTerm(Parse pParse, WhereTerm pTerm, WhereLevel pLevel, int iEq, int bRev, int iTarget)
{
    Expr pX = pTerm.pExpr;
    Vdbe v = pParse.pVdbe;
    int iReg = 0;
    if (((pX.op) == (53)) || ((pX.op) == (45)))
    {
        iReg = (int)(sqlite3ExprCodeTarget(pParse, pX.pRight, (int)(iTarget)));
    }
    else if ((pX.op) == (50))
    {
        iReg = (int)(iTarget);
        sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(iReg));
    }
    else
    {
        int eType = (int)(5);
        int iTab = 0;
        InLoop* pIn;
        WhereLoop pLoop = pLevel.pWLoop;
        int i = 0;
        int nEq = (int)(0);
        int* aiMap = null;
        if ((((pLoop.wsFlags &amp; 0x00000400) == (0)) &amp;&amp; (pLoop.u.btree.pIndex != null)) &amp;&amp; ((pLoop.u.btree.pIndex.aSortOrder[iEq]) != 0))
        {
            bRev = (int)(!bRev);
        }

        iReg = (int)(iTarget);
        for (i = (int)(0); (i) &lt; (iEq); i++)
        {
            if (((pLoop.aLTerm[i]) != null) &amp;&amp; ((pLoop.aLTerm[i].pExpr) == (pX)))
            {
                disableTerm(pLevel, pTerm);
                return (int)(iTarget);
            }
        }

        for (i = (int)(iEq); (i) &lt; (pLoop.nLTerm); i++)
        {
            if ((pLoop.aLTerm[i].pExpr) == (pX))
                nEq++;
        }

        iTab = (int)(0);
        if ((!(((pX).flags &amp; 0x000800) != 0)) || ((pX.x.pSelect.pEList.nExpr) == (1)))
        {
            eType = (int)(sqlite3FindInIndex(pParse, pX, (uint)(0x0004), null, null, &amp;iTab));
        }
        else
        {
            sqlite3 db = pParse.db;
            pX = removeUnindexableInClauseTerms(pParse, (int)(iEq), pLoop, pX);
            if (db.mallocFailed == 0)
            {
                aiMap = (int*)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(int) * nEq)));
                eType = (int)(sqlite3FindInIndex(pParse, pX, (uint)(0x0004), null, aiMap, &amp;iTab));
                pTerm.pExpr.iTable = (int)(iTab);
            }

            sqlite3ExprDelete(db, pX);
            pX = pTerm.pExpr;
        }

        if ((eType) == (4))
        {
            bRev = (int)(!bRev);
        }

        sqlite3VdbeAddOp2(v, (int)((bRev) != 0 ? 34 : 38), (int)(iTab), (int)(0));
        pLoop.wsFlags |= (uint)(0x00000800);
        if ((pLevel.u._in_.nIn) == (0))
        {
            pLevel.addrNxt = (int)(sqlite3VdbeMakeLabel(pParse));
        }

        if (((iEq) &gt; (0)) &amp;&amp; ((pLoop.wsFlags &amp; 0x00100000) == (0)))
        {
            pLoop.wsFlags |= (uint)(0x00040000);
        }

        i = (int)(pLevel.u._in_.nIn);
        pLevel.u._in_.nIn += (int)(nEq);
        pLevel.u._in_.aInLoop = sqlite3DbReallocOrFree(pParse.db, pLevel.u._in_.aInLoop, (ulong)(sizeof(InLoop) * pLevel.u._in_.nIn));
        pIn = pLevel.u._in_.aInLoop;
        if ((pIn) != null)
        {
            int iMap = (int)(0);
            pIn += i;
            for (i = (int)(iEq); (i) &lt; (pLoop.nLTerm); i++)
            {
                if ((pLoop.aLTerm[i].pExpr) == (pX))
                {
                    int iOut = (int)(iReg + i - iEq);
                    if ((eType) == (1))
                    {
                        pIn-&gt;addrInTop = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iTab), (int)(iOut)));
                    }
                    else
                    {
                        int iCol = (int)((aiMap) != 0 ? aiMap[iMap++] : 0);
                        pIn-&gt;addrInTop = (int)(sqlite3VdbeAddOp3(v, (int)(93), (int)(iTab), (int)(iCol), (int)(iOut)));
                    }

                    sqlite3VdbeAddOp1(v, (int)(50), (int)(iOut));
                    if ((i) == (iEq))
                    {
                        pIn-&gt;iCur = (int)(iTab);
                        pIn-&gt;eEndLoopOp = (byte)((bRev) != 0 ? 4 : 5);
                        if ((iEq) &gt; (0))
                        {
                            pIn-&gt;iBase = (int)(iReg - i);
                            pIn-&gt;nPrefix = (int)(i);
                        }
                        else
                        {
                            pIn-&gt;nPrefix = (int)(0);
                        }
                    }
                    else
                    {
                        pIn-&gt;eEndLoopOp = (byte)(182);
                    }

                    pIn++;
                }
            }

            if (((iEq) &gt; (0)) &amp;&amp; ((pLoop.wsFlags &amp; (0x00100000 | 0x00000400)) == (0)))
            {
                sqlite3VdbeAddOp3(v, (int)(124), (int)(pLevel.iIdxCur), (int)(0), (int)(iEq));
            }
        }
        else
        {
            pLevel.u._in_.nIn = (int)(0);
        }

        sqlite3DbFree(pParse.db, aiMap);
    }

    if (((pLevel.pWLoop.wsFlags &amp; 0x00200000) == (0)) || ((pTerm.eOperator &amp; 0x0800) == (0)))
    {
        disableTerm(pLevel, pTerm);
    }

    return (int)(iReg);
}</function>
  <function>public static void codeExprOrVector(Parse pParse, Expr p, int iReg, int nReg)
{
    if (((p) != null) &amp;&amp; ((sqlite3ExprIsVector(p)) != 0))
    {
        if ((((p).flags &amp; 0x000800) != 0))
        {
            Vdbe v = pParse.pVdbe;
            int iSelect = 0;
            iSelect = (int)(sqlite3CodeSubselect(pParse, p));
            sqlite3VdbeAddOp3(v, (int)(79), (int)(iSelect), (int)(iReg), (int)(nReg - 1));
        }
        else
        {
            int i = 0;
            ExprList pList;
            pList = p.x.pList;
            for (i = (int)(0); (i) &lt; (nReg); i++)
            {
                sqlite3ExprCode(pParse, pList.a[i].pExpr, (int)(iReg + i));
            }
        }
    }
    else
    {
        sqlite3ExprCode(pParse, p, (int)(iReg));
    }
}</function>
  <function>public static void codeInteger(Parse pParse, Expr pExpr, int negFlag, int iMem)
{
    Vdbe v = pParse.pVdbe;
    if ((pExpr.flags &amp; 0x000400) != 0)
    {
        int i = (int)(pExpr.u.iValue);
        if ((negFlag) != 0)
            i = (int)(-i);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(i), (int)(iMem));
    }
    else
    {
        int c = 0;
        long value = 0;
        sbyte* z = pExpr.u.zToken;
        c = (int)(sqlite3DecOrHexToI64(z, &amp;value));
        if (((((c) == (3)) &amp;&amp; (negFlag == 0)) || ((c) == (2))) || (((negFlag) != 0) &amp;&amp; ((value) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))))
        {
            if ((sqlite3_strnicmp(z, "0x", (int)(2))) == (0))
            {
                sqlite3ErrorMsg(pParse, "hex literal too big: %s%#T", (negFlag) != 0 ? "-" : "", pExpr);
            }
            else
            {
                codeReal(v, z, (int)(negFlag), (int)(iMem));
            }
        }
        else
        {
            if ((negFlag) != 0)
            {
                value = (long)((c) == (3) ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))) : -value);
            }

            sqlite3VdbeAddOp4Dup8(v, (int)(72), (int)(0), (int)(iMem), (int)(0), (byte*)(&amp;value), (int)(-14));
        }
    }
}</function>
  <function>public static void codeOffset(Vdbe v, int iOffset, int iContinue)
{
    if ((iOffset) &gt; (0))
    {
        sqlite3VdbeAddOp3(v, (int)(49), (int)(iOffset), (int)(iContinue), (int)(1));
    }
}</function>
  <function>public static void codeReal(Vdbe v, sbyte* z, int negateFlag, int iMem)
{
    if ((z != null))
    {
        double value = 0;
        sqlite3AtoF(z, &amp;value, (int)(sqlite3Strlen30(z)), (byte)(1));
        if ((negateFlag) != 0)
            value = (double)(-value);
        sqlite3VdbeAddOp4Dup8(v, (int)(153), (int)(0), (int)(iMem), (int)(0), (byte*)(&amp;value), (int)(-13));
    }
}</function>
  <function>public static void codeReturningTrigger(Parse pParse, Trigger pTrigger, Table pTab, int regIn)
{
    Vdbe v = pParse.pVdbe;
    sqlite3 db = pParse.db;
    ExprList pNew;
    Returning pReturning;
    Select sSelect = new Select();
    SrcList sFrom = new SrcList();
    pReturning = pParse.u1.pReturning;
    CRuntime.memset(sSelect, (int)(0), (ulong)(sizeof(Select)));
    CRuntime.memset(sFrom, (int)(0), (ulong)(sizeof(SrcList)));
    sSelect.pEList = sqlite3ExprListDup(db, pReturning.pReturnEL, (int)(0));
    sSelect.pSrc = sFrom;
    sFrom.nSrc = (int)(1);
    sFrom.a[0].pTab = pTab;
    sFrom.a[0].iCursor = (int)(-1);
    sqlite3SelectPrep(pParse, sSelect, null);
    if ((pParse.nErr) == (0))
    {
        sqlite3GenerateColumnNames(pParse, sSelect);
    }

    sqlite3ExprListDelete(db, sSelect.pEList);
    pNew = sqlite3ExpandReturning(pParse, pReturning.pReturnEL, pTab);
    if (db.mallocFailed == 0)
    {
        NameContext sNC = new NameContext();
        CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
        if ((pReturning.nRetCol) == (0))
        {
            pReturning.nRetCol = (int)(pNew.nExpr);
            pReturning.iRetCur = (int)(pParse.nTab++);
        }

        sNC.pParse = pParse;
        sNC.uNC.iBaseReg = (int)(regIn);
        sNC.ncFlags = (int)(0x000400);
        pParse.eTriggerOp = (byte)(pTrigger.op);
        pParse.pTriggerTab = pTab;
        if (((sqlite3ResolveExprListNames(sNC, pNew)) == (0)) &amp;&amp; ((!db.mallocFailed) != 0))
        {
            int i = 0;
            int nCol = (int)(pNew.nExpr);
            int reg = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(nCol + 2);
            pReturning.iRetReg = (int)(reg);
            for (i = (int)(0); (i) &lt; (nCol); i++)
            {
                Expr pCol = pNew.a[i].pExpr;
                sqlite3ExprCodeFactorable(pParse, pCol, (int)(reg + i));
                if ((sqlite3ExprAffinity(pCol)) == (0x45))
                {
                    sqlite3VdbeAddOp1(v, (int)(86), (int)(reg + i));
                }
            }

            sqlite3VdbeAddOp3(v, (int)(96), (int)(reg), (int)(i), (int)(reg + i));
            sqlite3VdbeAddOp2(v, (int)(126), (int)(pReturning.iRetCur), (int)(reg + i + 1));
            sqlite3VdbeAddOp3(v, (int)(127), (int)(pReturning.iRetCur), (int)(reg + i), (int)(reg + i + 1));
        }
    }

    sqlite3ExprListDelete(db, pNew);
    pParse.eTriggerOp = (byte)(0);
    pParse.pTriggerTab = null;
}</function>
  <function>public static TriggerPrg codeRowTrigger(Parse pParse, Trigger pTrigger, Table pTab, int orconf)
{
    Parse pTop = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    sqlite3 db = pParse.db;
    TriggerPrg pPrg;
    Expr pWhen = null;
    Vdbe v;
    NameContext sNC = new NameContext();
    SubProgram* pProgram = null;
    int iEndTrigger = (int)(0);
    Parse sSubParse = new Parse();
    pPrg = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerPrg)));
    if (pPrg == null)
        return null;
    pPrg.pNext = pTop.pTriggerPrg;
    pTop.pTriggerPrg = pPrg;
    pPrg.pProgram = pProgram = sqlite3DbMallocZero(db, (ulong)(sizeof(SubProgram)));
    if (pProgram == null)
        return null;
    sqlite3VdbeLinkSubProgram(pTop.pVdbe, pProgram);
    pPrg.pTrigger = pTrigger;
    pPrg.orconf = (int)(orconf);
    pPrg.aColmask[0] = (uint)(0xffffffff);
    pPrg.aColmask[1] = (uint)(0xffffffff);
    sqlite3ParseObjectInit(sSubParse, db);
    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    sNC.pParse = sSubParse;
    sSubParse.pTriggerTab = pTab;
    sSubParse.pToplevel = pTop;
    sSubParse.zAuthContext = pTrigger.zName;
    sSubParse.eTriggerOp = (byte)(pTrigger.op);
    sSubParse.nQueryLoop = (uint)(pParse.nQueryLoop);
    sSubParse.disableVtab = (byte)(pParse.disableVtab);
    v = sqlite3GetVdbe(sSubParse);
    if ((v) != null)
    {
        if ((pTrigger.zName) != null)
        {
            sqlite3VdbeChangeP4(v, (int)(-1), sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger.zName), (int)(-7));
        }

        if ((pTrigger.pWhen) != null)
        {
            pWhen = sqlite3ExprDup(db, pTrigger.pWhen, (int)(0));
            if (((db.mallocFailed) == (0)) &amp;&amp; ((0) == (sqlite3ResolveExprNames(sNC, pWhen))))
            {
                iEndTrigger = (int)(sqlite3VdbeMakeLabel(sSubParse));
                sqlite3ExprIfFalse(sSubParse, pWhen, (int)(iEndTrigger), (int)(0x10));
            }

            sqlite3ExprDelete(db, pWhen);
        }

        codeTriggerProgram(sSubParse, pTrigger.step_list, (int)(orconf));
        if ((iEndTrigger) != 0)
        {
            sqlite3VdbeResolveLabel(v, (int)(iEndTrigger));
        }

        sqlite3VdbeAddOp0(v, (int)(70));
        transferParseError(pParse, sSubParse);
        if ((pParse.nErr) == (0))
        {
            pProgram-&gt;aOp = sqlite3VdbeTakeOpArray(v, &amp;pProgram-&gt;nOp, &amp;pTop.nMaxArg);
        }

        pProgram-&gt;nMem = (int)(sSubParse.nMem);
        pProgram-&gt;nCsr = (int)(sSubParse.nTab);
        pProgram-&gt;token = (void*)(pTrigger);
        pPrg.aColmask[0] = (uint)(sSubParse.oldmask);
        pPrg.aColmask[1] = (uint)(sSubParse.newmask);
        sqlite3VdbeDelete(v);
    }
    else
    {
        transferParseError(pParse, sSubParse);
    }

    sqlite3ParseObjectReset(sSubParse);
    return pPrg;
}</function>
  <function>public static void codeTableLocks(Parse pParse)
{
    int i = 0;
    Vdbe pVdbe = pParse.pVdbe;
    for (i = (int)(0); (i) &lt; (pParse.nTableLock); i++)
    {
        TableLock* p = &amp;pParse.aTableLock[i];
        int p1 = (int)(p-&gt;iDb);
        sqlite3VdbeAddOp4(pVdbe, (int)(168), (int)(p1), (int)(p-&gt;iTab), (int)(p-&gt;isWriteLock), p-&gt;zLockName, (int)(-1));
    }
}</function>
  <function>public static int codeTriggerProgram(Parse pParse, TriggerStep pStepList, int orconf)
{
    TriggerStep pStep;
    Vdbe v = pParse.pVdbe;
    sqlite3 db = pParse.db;
    for (pStep = pStepList; pStep; pStep = pStep.pNext)
    {
        pParse.eOrconf = (byte)(((orconf) == (11)) ? pStep.orconf : (byte)(orconf));
        if ((pStep.zSpan) != null)
        {
            sqlite3VdbeAddOp4(v, (int)(179), (int)(0x7fffffff), (int)(1), (int)(0), sqlite3MPrintf(db, "-- %s", pStep.zSpan), (int)(-7));
        }

        switch (pStep.op)
        {
            case 129:
            {
                sqlite3Update(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprListDup(db, pStep.pExprList, (int)(0)), sqlite3ExprDup(db, pStep.pWhere, (int)(0)), (int)(pParse.eOrconf), null, null, null);
                sqlite3VdbeAddOp0(v, (int)(130));
                break;
            }

            case 127:
            {
                sqlite3Insert(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3SelectDup(db, pStep.pSelect, (int)(0)), sqlite3IdListDup(db, pStep.pIdList), (int)(pParse.eOrconf), sqlite3UpsertDup(db, pStep.pUpsert));
                sqlite3VdbeAddOp0(v, (int)(130));
                break;
            }

            case 128:
            {
                sqlite3DeleteFrom(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprDup(db, pStep.pWhere, (int)(0)), null, null);
                sqlite3VdbeAddOp0(v, (int)(130));
                break;
            }

            default:
                ;
            {
                SelectDest sDest = new SelectDest();
                Select pSelect = sqlite3SelectDup(db, pStep.pSelect, (int)(0));
                sqlite3SelectDestInit(sDest, (int)(4), (int)(0));
                sqlite3Select(pParse, pSelect, sDest);
                sqlite3SelectDelete(db, pSelect);
                break;
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static void codeVectorCompare(Parse pParse, Expr pExpr, int dest, byte op, byte p5)
{
    Vdbe v = pParse.pVdbe;
    Expr pLeft = pExpr.pLeft;
    Expr pRight = pExpr.pRight;
    int nLeft = (int)(sqlite3ExprVectorSize(pLeft));
    int i = 0;
    int regLeft = (int)(0);
    int regRight = (int)(0);
    byte opx = (byte)(op);
    int addrCmp = (int)(0);
    int addrDone = (int)(sqlite3VdbeMakeLabel(pParse));
    int isCommuted = (int)(((pExpr).flags &amp; (0x000200)) != 0);
    if ((pParse.nErr) != 0)
        return;
    if (nLeft != sqlite3ExprVectorSize(pRight))
    {
        sqlite3ErrorMsg(pParse, "row value misused");
        return;
    }

    if ((op) == (55))
        opx = (byte)(56);
    if ((op) == (57))
        opx = (byte)(54);
    if ((op) == (52))
        opx = (byte)(53);
    regLeft = (int)(exprCodeSubselect(pParse, pLeft));
    regRight = (int)(exprCodeSubselect(pParse, pRight));
    sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(dest));
    for (i = (int)(0); 1; i++)
    {
        int regFree1 = (int)(0);
        int regFree2 = (int)(0);
        Expr pL = null;
        Expr pR = null;
        int r1 = 0;
        int r2 = 0;
        if ((addrCmp) != 0)
            sqlite3VdbeJumpHere(v, (int)(addrCmp));
        r1 = (int)(exprVectorRegister(pParse, pLeft, (int)(i), (int)(regLeft), pL, &amp;regFree1));
        r2 = (int)(exprVectorRegister(pParse, pRight, (int)(i), (int)(regRight), pR, &amp;regFree2));
        addrCmp = (int)(sqlite3VdbeCurrentAddr(v));
        codeCompare(pParse, pL, pR, (int)(opx), (int)(r1), (int)(r2), (int)(addrDone), (int)(p5), (int)(isCommuted));
        sqlite3ReleaseTempReg(pParse, (int)(regFree1));
        sqlite3ReleaseTempReg(pParse, (int)(regFree2));
        if ((((opx) == (56)) || ((opx) == (54))) &amp;&amp; ((i) &lt; (nLeft - 1)))
        {
            addrCmp = (int)(sqlite3VdbeAddOp0(v, (int)(58)));
        }

        if ((p5) == (0x80))
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(dest));
        }
        else
        {
            sqlite3VdbeAddOp3(v, (int)(91), (int)(r1), (int)(dest), (int)(r2));
        }

        if ((i) == (nLeft - 1))
        {
            break;
        }

        if ((opx) == (53))
        {
            sqlite3VdbeAddOp2(v, (int)(51), (int)(dest), (int)(addrDone));
        }
        else
        {
            sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrDone));
            if ((i) == (nLeft - 2))
                opx = (byte)(op);
        }
    }

    sqlite3VdbeJumpHere(v, (int)(addrCmp));
    sqlite3VdbeResolveLabel(v, (int)(addrDone));
    if ((op) == (52))
    {
        sqlite3VdbeAddOp2(v, (int)(19), (int)(dest), (int)(dest));
    }
}</function>
  <function>public static int collationMatch(sbyte* zColl, Index pIndex)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (pIndex.nColumn); i++)
    {
        sbyte* z = pIndex.azColl[i];
        if (((pIndex.aiColumn[i]) &gt;= (0)) &amp;&amp; ((0) == (sqlite3StrICmp(z, zColl))))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static void columnMallocFailure(sqlite3_stmt* pStmt)
{
    Vdbe p = (Vdbe)(pStmt);
    if ((p) != null)
    {
        p.rc = (int)(sqlite3ApiExit(p.db, (int)(p.rc)));
        sqlite3_mutex_leave(p.db.mutex);
    }
}</function>
  <function>public static sqlite3_value columnMem(sqlite3_stmt* pStmt, int i)
{
    Vdbe pVm;
    sqlite3_value pOut;
    pVm = (Vdbe)(pStmt);
    if ((pVm) == (null))
        return columnNullValue();
    sqlite3_mutex_enter(pVm.db.mutex);
    if (((pVm.pResultSet != null) &amp;&amp; ((i) &lt; (pVm.nResColumn))) &amp;&amp; ((i) &gt;= (0)))
    {
        pOut = pVm.pResultSet[i];
    }
    else
    {
        sqlite3Error(pVm.db, (int)(25));
        pOut = columnNullValue();
    }

    return pOut;
}</function>
  <function>public static void* columnName(sqlite3_stmt* pStmt, int N, int useUtf16, int useType)
{
    void* ret;
    Vdbe p;
    int n = 0;
    sqlite3 db;
    ret = null;
    p = (Vdbe)(pStmt);
    db = p.db;
    n = (int)(sqlite3_column_count(pStmt));
    if (((N) &lt; (n)) &amp;&amp; ((N) &gt;= (0)))
    {
        N += (int)(useType * n);
        sqlite3_mutex_enter(db.mutex);
        if ((useUtf16) != 0)
        {
            ret = sqlite3_value_text16(p.aColName[N]);
        }
        else
        {
            ret = sqlite3_value_text(p.aColName[N]);
        }

        if ((db.mallocFailed) != 0)
        {
            sqlite3OomClear(db);
            ret = null;
        }

        sqlite3_mutex_leave(db.mutex);
    }

    return ret;
}</function>
  <function>public static sqlite3_value columnNullValue()
{
    return columnNullValue_nullMem;
}</function>
  <function>public static sbyte* columnTypeImpl(NameContext pNC, Expr pExpr)
{
    sbyte* zType = null;
    int j = 0;
    switch (pExpr.op)
    {
        case 167:
        {
            Table pTab = null;
            Select pS = null;
            int iCol = (int)(pExpr.iColumn);
            while (((pNC) != null) &amp;&amp; (pTab == null))
            {
                SrcList pTabList = pNC.pSrcList;
                for (j = (int)(0); ((j) &lt; (pTabList.nSrc)) &amp;&amp; (pTabList.a[j].iCursor != pExpr.iTable); j++)
                {
                }

                if ((j) &lt; (pTabList.nSrc))
                {
                    pTab = pTabList.a[j].pTab;
                    pS = pTabList.a[j].pSelect;
                }
                else
                {
                    pNC = pNC.pNext;
                }
            }

            if ((pTab) == (null))
            {
                break;
            }

            if ((pS) != null)
            {
                if (((iCol) &lt; (pS.pEList.nExpr)) &amp;&amp; ((iCol) &gt;= (0)))
                {
                    NameContext sNC = new NameContext();
                    Expr p = pS.pEList.a[iCol].pExpr;
                    sNC.pSrcList = pS.pSrc;
                    sNC.pNext = pNC;
                    sNC.pParse = pNC.pParse;
                    zType = columnTypeImpl(sNC, p);
                }
            }
            else
            {
                if ((iCol) &lt; (0))
                {
                    zType = "INTEGER";
                }
                else
                {
                    zType = sqlite3ColumnType(&amp;pTab.aCol[iCol], null);
                }
            }

            break;
        }

        case 138:
        {
            NameContext sNC = new NameContext();
            Select pS;
            Expr p;
            pS = pExpr.x.pSelect;
            p = pS.pEList.a[0].pExpr;
            sNC.pSrcList = pS.pSrc;
            sNC.pNext = pNC;
            sNC.pParse = pNC.pParse;
            zType = columnTypeImpl(sNC, p);
            break;
        }
    }

    return zType;
}</function>
  <function>public static int compare2pow63(sbyte* zNum, int incr)
{
    int c = (int)(0);
    int i = 0;
    sbyte* pow63 = "922337203685477580";
    for (i = (int)(0); ((c) == (0)) &amp;&amp; ((i) &lt; (18)); i++)
    {
        c = (int)((zNum[i * incr] - pow63[i]) * 10);
    }

    if ((c) == (0))
    {
        c = (int)(zNum[18 * incr] - 56);
    }

    return (int)(c);
}</function>
  <function>public static sbyte comparisonAffinity(Expr pExpr)
{
    sbyte aff = 0;
    aff = (sbyte)(sqlite3ExprAffinity(pExpr.pLeft));
    if ((pExpr.pRight) != null)
    {
        aff = (sbyte)(sqlite3CompareAffinity(pExpr.pRight, (sbyte)(aff)));
    }
    else if ((((pExpr).flags &amp; 0x000800) != 0))
    {
        aff = (sbyte)(sqlite3CompareAffinity(pExpr.x.pSelect.pEList.a[0].pExpr, (sbyte)(aff)));
    }
    else if ((aff) == (0))
    {
        aff = (sbyte)(0x41);
    }

    return (sbyte)(aff);
}</function>
  <function>public static void compileoptiongetFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    int n = 0;
    n = (int)(sqlite3_value_int(argv[0]));
    sqlite3_result_text(context, sqlite3_compileoption_get((int)(n)), (int)(-1), null);
}</function>
  <function>public static void compileoptionusedFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    sbyte* zOptName;
    if ((zOptName = (sbyte*)(sqlite3_value_text(argv[0]))) != null)
    {
        sqlite3_result_int(context, (int)(sqlite3_compileoption_used(zOptName)));
    }
}</function>
  <function>public static ushort computeCellSize(CellArray p, int N)
{
    p.szCell[N] = (ushort)(p.pRef.xCellSize(p.pRef, p.apCell[N]));
    return (ushort)(p.szCell[N]);
}</function>
  <function>public static void computeHMS(DateTime* p)
{
    int s = 0;
    if ((p-&gt;validHMS) != 0)
        return;
    computeJD(p);
    s = ((int)((p-&gt;iJD + 43200000) % 86400000));
    p-&gt;s = (double)(s / 1000.0);
    s = ((int)(p-&gt;s));
    p-&gt;s -= (double)(s);
    p-&gt;h = (int)(s / 3600);
    s -= (int)(p-&gt;h * 3600);
    p-&gt;m = (int)(s / 60);
    p-&gt;s += (double)(s - p-&gt;m * 60);
    p-&gt;rawS = (sbyte)(0);
    p-&gt;validHMS = (sbyte)(1);
}</function>
  <function>public static void computeJD(DateTime* p)
{
    int Y = 0; int  M  =  0 ;  int  D  =  0 ;  int  A  =  0 ;  int  B  =  0 ;  int  X1  =  0 ;  int  X2  =  0 ; 
    if ((p-&gt;validJD) != 0)
        return;
    if ((p-&gt;validYMD) != 0)
    {
        Y = (int)(p-&gt;Y);
        M = (int)(p-&gt;M);
        D = (int)(p-&gt;D);
    }
    else
    {
        Y = (int)(2000);
        M = (int)(1);
        D = (int)(1);
    }

    if ((((Y) &lt; (-4713)) || ((Y) &gt; (9999))) || ((p-&gt;rawS) != 0))
    {
        datetimeError(p);
        return;
    }

    if ((M) &lt;= (2))
    {
        Y--;
        M += (int)(12);
    }

    A = (int)(Y / 100);
    B = (int)(2 - A + (A / 4));
    X1 = (int)(36525 * (Y + 4716) / 100);
    X2 = (int)(306001 * (M + 1) / 10000);
    p-&gt;iJD = ((long)((X1 + X2 + D + B - 1524.5) * 86400000));
    p-&gt;validJD = (sbyte)(1);
    if ((p-&gt;validHMS) != 0)
    {
        p-&gt;iJD += (long)(p-&gt;h * 3600000 + p-&gt;m * 60000 + (long)(p-&gt;s * 1000));
        if ((p-&gt;validTZ) != 0)
        {
            p-&gt;iJD -= (long)(p-&gt;tz * 60000);
            p-&gt;validYMD = (sbyte)(0);
            p-&gt;validHMS = (sbyte)(0);
            p-&gt;validTZ = (sbyte)(0);
        }
    }
}</function>
  <function>public static void computeLimitRegisters(Parse pParse, Select p, int iBreak)
{
    Vdbe v = null;
    int iLimit = (int)(0);
    int iOffset = 0;
    int n = 0;
    Expr pLimit = p.pLimit;
    if ((p.iLimit) != 0)
        return;
    if ((pLimit) != null)
    {
        p.iLimit = (int)(iLimit = (int)(++pParse.nMem));
        v = sqlite3GetVdbe(pParse);
        if ((sqlite3ExprIsInteger(pLimit.pLeft, &amp;n)) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(n), (int)(iLimit));
            if ((n) == (0))
            {
                sqlite3VdbeGoto(v, (int)(iBreak));
            }
            else if (((n) &gt;= (0)) &amp;&amp; ((p.nSelectRow) &gt; (sqlite3LogEst((ulong)(n)))))
            {
                p.nSelectRow = (short)(sqlite3LogEst((ulong)(n)));
                p.selFlags |= (uint)(0x0004000);
            }
        }
        else
        {
            sqlite3ExprCode(pParse, pLimit.pLeft, (int)(iLimit));
            sqlite3VdbeAddOp1(v, (int)(15), (int)(iLimit));
            sqlite3VdbeAddOp2(v, (int)(20), (int)(iLimit), (int)(iBreak));
        }

        if ((pLimit.pRight) != null)
        {
            p.iOffset = (int)(iOffset = (int)(++pParse.nMem));
            pParse.nMem++;
            sqlite3ExprCode(pParse, pLimit.pRight, (int)(iOffset));
            sqlite3VdbeAddOp1(v, (int)(15), (int)(iOffset));
            sqlite3VdbeAddOp3(v, (int)(159), (int)(iLimit), (int)(iOffset + 1), (int)(iOffset));
        }
    }
}</function>
  <function>public static ushort computeNumericType(sqlite3_value pMem)
{
    int rc = 0;
    long ix = 0;
    if ((((pMem).flags &amp; 0x4000) ? sqlite3VdbeMemExpandBlob(pMem) : 0) != 0)
    {
        pMem.u.i = (long)(0);
        return (ushort)(0x0004);
    }

    rc = (int)(sqlite3AtoF(pMem.z, &amp;pMem.u.r, (int)(pMem.n), (byte)(pMem.enc)));
    if ((rc) &lt;= (0))
    {
        if (((rc) == (0)) &amp;&amp; ((sqlite3Atoi64(pMem.z, &amp;ix, (int)(pMem.n), (byte)(pMem.enc))) &lt;= (1)))
        {
            pMem.u.i = (long)(ix);
            return (ushort)(0x0004);
        }
        else
        {
            return (ushort)(0x0008);
        }
    }
    else if (((rc) == (1)) &amp;&amp; ((sqlite3Atoi64(pMem.z, &amp;ix, (int)(pMem.n), (byte)(pMem.enc))) == (0)))
    {
        pMem.u.i = (long)(ix);
        return (ushort)(0x0004);
    }

    return (ushort)(0x0008);
}</function>
  <function>public static void computeYMD(DateTime* p)
{
    int Z = 0; int  A  =  0 ;  int  B  =  0 ;  int  C  =  0 ;  int  D  =  0 ;  int  E  =  0 ;  int  X1  =  0 ; 
    if ((p-&gt;validYMD) != 0)
        return;
    if (p-&gt;validJD == 0)
    {
        p-&gt;Y = (int)(2000);
        p-&gt;M = (int)(1);
        p-&gt;D = (int)(1);
    }
    else if (validJulianDay((long)(p-&gt;iJD)) == 0)
    {
        datetimeError(p);
        return;
    }
    else
    {
        Z = ((int)((p-&gt;iJD + 43200000) / 86400000));
        A = ((int)((Z - 1867216.25) / 36524.25));
        A = (int)(Z + 1 + A - (A / 4));
        B = (int)(A + 1524);
        C = ((int)((B - 122.1) / 365.25));
        D = (int)((36525 * (C &amp; 32767)) / 100);
        E = ((int)((B - D) / 30.6001));
        X1 = ((int)(30.6001 * E));
        p-&gt;D = (int)(B - D - X1);
        p-&gt;M = (int)((E) &lt; (14) ? E - 1 : E - 13);
        p-&gt;Y = (int)((p-&gt;M) &gt; (2) ? C - 4716 : C - 4715);
    }

    p-&gt;validYMD = (sbyte)(1);
}</function>
  <function>public static void computeYMD_HMS(DateTime* p)
{
    computeYMD(p);
    computeHMS(p);
}</function>
  <function>public static int connectionIsBusy(sqlite3 db)
{
    int j = 0;
    if ((db.pVdbe) != null)
        return (int)(1);
    for (j = (int)(0); (j) &lt; (db.nDb); j++)
    {
        Btree pBt = db.aDb[j].pBt;
        if (((pBt) != null) &amp;&amp; ((sqlite3BtreeIsInBackup(pBt)) != 0))
            return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void constInsert(WhereConst pConst, Expr pColumn, Expr pValue, Expr pExpr)
{
    int i = 0;
    if ((((pColumn).flags &amp; (0x000008)) != 0))
        return;
    if (sqlite3ExprAffinity(pValue) != 0)
        return;
    if (sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst.pParse, pExpr)) == 0)
    {
        return;
    }

    for (i = (int)(0); (i) &lt; (pConst.nConst); i++)
    {
        Expr pE2 = pConst.apExpr[i * 2];
        if (((pE2.iTable) == (pColumn.iTable)) &amp;&amp; ((pE2.iColumn) == (pColumn.iColumn)))
        {
            return;
        }
    }

    if ((sqlite3ExprAffinity(pColumn)) == (0x41))
    {
        pConst.bHasAffBlob = (int)(1);
    }

    pConst.nConst++;
    pConst.apExpr = sqlite3DbReallocOrFree(pConst.pParse.db, pConst.apExpr, (ulong)(pConst.nConst * 2 * sizeof(Expr)));
    if ((pConst.apExpr) == (null))
    {
        pConst.nConst = (int)(0);
    }
    else
    {
        pConst.apExpr[pConst.nConst * 2 - 2] = pColumn;
        pConst.apExpr[pConst.nConst * 2 - 1] = pValue;
    }
}</function>
  <function>public static void constructAutomaticIndex(Parse pParse, WhereClause pWC, SrcItem pSrc, ulong notReady, WhereLevel pLevel)
{
    int nKeyCol = 0;
    WhereTerm pTerm;
    WhereTerm pWCEnd;
    Index pIdx;
    Vdbe v;
    int addrInit = 0;
    Table pTable;
    int addrTop = 0;
    int regRecord = 0;
    int n = 0;
    int i = 0;
    int mxBitCol = 0;
    CollSeq pColl;
    WhereLoop pLoop;
    sbyte* zNotUsed;
    ulong idxCols = 0;
    ulong extraCols = 0;
    byte sentWarning = (byte)(0);
    Expr pPartial = null;
    int iContinue = (int)(0);
    SrcItem pTabItem;
    int addrCounter = (int)(0);
    int regBase = 0;
    v = pParse.pVdbe;
    addrInit = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
    nKeyCol = (int)(0);
    pTable = pSrc.pTab;
    pWCEnd = pWC.a[pWC.nTerm];
    pLoop = pLevel.pWLoop;
    idxCols = (ulong)(0);
    for (pTerm = pWC.a; (pTerm) &lt; (pWCEnd); pTerm++)
    {
        Expr pExpr = pTerm.pExpr;
        if ((((pTerm.wtFlags &amp; 0x0002) == (0)) &amp;&amp; (((pSrc.fg.jointype &amp; 0x0008) == (0)) || (((pExpr).flags &amp; (0x000001)) != 0))) &amp;&amp; ((sqlite3ExprIsTableConstant(pExpr, (int)(pSrc.iCursor))) != 0))
        {
            pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse.db, pExpr, (int)(0)));
        }

        if ((termCanDriveIndex(pTerm, pSrc, (ulong)(notReady))) != 0)
        {
            int iCol = 0;
            ulong cMask = 0;
            iCol = (int)(pTerm.u.x.leftColumn);
            cMask = (ulong)((iCol) &gt;= ((int)(sizeof(ulong) * 8)) ? (((ulong)(1)) &lt;&lt; (((int)(sizeof(ulong) * 8)) - 1)) : (((ulong)(1)) &lt;&lt; (iCol)));
            if (sentWarning == 0)
            {
                sqlite3_log((int)(28 | (1 &lt;&lt; 8)), "automatic index on %s(%s)", pTable.zName, pTable.aCol[iCol].zCnName);
                sentWarning = (byte)(1);
            }

            if ((idxCols &amp; cMask) == (0))
            {
                if ((whereLoopResize(pParse.db, pLoop, (int)(nKeyCol + 1))) != 0)
                {
                    goto end_auto_index_create;
                }

                pLoop.aLTerm[nKeyCol++] = pTerm;
                idxCols |= (ulong)(cMask);
            }
        }
    }

    pLoop.u.btree.nEq = (ushort)(pLoop.nLTerm = (ushort)(nKeyCol));
    pLoop.wsFlags = (uint)(0x00000001 | 0x00000040 | 0x00000200 | 0x00004000);
    extraCols = (ulong)(pSrc.colUsed &amp; (~idxCols | (((ulong)(1)) &lt;&lt; (((int)(sizeof(ulong) * 8)) - 1))));
    mxBitCol = (int)((((int)(sizeof(ulong) * 8)) - 1) &lt; (pTable.nCol) ? (((int)(sizeof(ulong) * 8)) - 1) : (pTable.nCol));
    for (i = (int)(0); (i) &lt; (mxBitCol); i++)
    {
        if ((extraCols &amp; (((ulong)(1)) &lt;&lt; (i))) != 0)
            nKeyCol++;
    }

    if ((pSrc.colUsed &amp; (((ulong)(1)) &lt;&lt; (((int)(sizeof(ulong) * 8)) - 1))) != 0)
    {
        nKeyCol += (int)(pTable.nCol - ((int)(sizeof(ulong) * 8)) + 1);
    }

    pIdx = sqlite3AllocateIndexObject(pParse.db, (short)(nKeyCol + 1), (int)(0), &amp;zNotUsed);
    if ((pIdx) == (null))
        goto end_auto_index_create;
    pLoop.u.btree.pIndex = pIdx;
    pIdx.zName = "auto-index";
    pIdx.pTable = pTable;
    n = (int)(0);
    idxCols = (ulong)(0);
    for (pTerm = pWC.a; (pTerm) &lt; (pWCEnd); pTerm++)
    {
        if ((termCanDriveIndex(pTerm, pSrc, (ulong)(notReady))) != 0)
        {
            int iCol = 0;
            ulong cMask = 0;
            iCol = (int)(pTerm.u.x.leftColumn);
            cMask = (ulong)((iCol) &gt;= ((int)(sizeof(ulong) * 8)) ? (((ulong)(1)) &lt;&lt; (((int)(sizeof(ulong) * 8)) - 1)) : (((ulong)(1)) &lt;&lt; (iCol)));
            if ((idxCols &amp; cMask) == (0))
            {
                Expr pX = pTerm.pExpr;
                idxCols |= (ulong)(cMask);
                pIdx.aiColumn[n] = (short)(pTerm.u.x.leftColumn);
                pColl = sqlite3ExprCompareCollSeq(pParse, pX);
                pIdx.azColl[n] = pColl ? pColl.zName : sqlite3StrBINARY;
                n++;
            }
        }
    }

    for (i = (int)(0); (i) &lt; (mxBitCol); i++)
    {
        if ((extraCols &amp; (((ulong)(1)) &lt;&lt; (i))) != 0)
        {
            pIdx.aiColumn[n] = (short)(i);
            pIdx.azColl[n] = sqlite3StrBINARY;
            n++;
        }
    }

    if ((pSrc.colUsed &amp; (((ulong)(1)) &lt;&lt; (((int)(sizeof(ulong) * 8)) - 1))) != 0)
    {
        for (i = (int)(((int)(sizeof(ulong) * 8)) - 1); (i) &lt; (pTable.nCol); i++)
        {
            pIdx.aiColumn[n] = (short)(i);
            pIdx.azColl[n] = sqlite3StrBINARY;
            n++;
        }
    }

    pIdx.aiColumn[n] = (short)(-1);
    pIdx.azColl[n] = sqlite3StrBINARY;
    pLevel.iIdxCur = (int)(pParse.nTab++);
    sqlite3VdbeAddOp2(v, (int)(115), (int)(pLevel.iIdxCur), (int)(nKeyCol + 1));
    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
    if ((((pParse.db).dbOptFlags &amp; (0x00080000)) == (0)))
    {
        pLevel.regFilter = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(76), (int)(10000), (int)(pLevel.regFilter));
    }

    pTabItem = pWC.pWInfo.pTabList.a[pLevel.iFrom];
    if ((pTabItem.fg.viaCoroutine) != 0)
    {
        int regYield = (int)(pTabItem.regReturn);
        addrCounter = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(0)));
        sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(pTabItem.addrFillSub));
        addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(regYield)));
    }
    else
    {
        addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(pLevel.iTabCur)));
    }

    if ((pPartial) != null)
    {
        iContinue = (int)(sqlite3VdbeMakeLabel(pParse));
        sqlite3ExprIfFalse(pParse, pPartial, (int)(iContinue), (int)(0x10));
        pLoop.wsFlags |= (uint)(0x00020000);
    }

    regRecord = (int)(sqlite3GetTempReg(pParse));
    regBase = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(pLevel.iTabCur), (int)(regRecord), (int)(0), null, null, (int)(0)));
    if ((pLevel.regFilter) != 0)
    {
        sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(regBase), (int)(pLoop.u.btree.nEq));
    }

    sqlite3VdbeAddOp2(v, (int)(137), (int)(pLevel.iIdxCur), (int)(regRecord));
    sqlite3VdbeChangeP5(v, (ushort)(0x10));
    if ((pPartial) != null)
        sqlite3VdbeResolveLabel(v, (int)(iContinue));
    if ((pTabItem.fg.viaCoroutine) != 0)
    {
        sqlite3VdbeChangeP2(v, (int)(addrCounter), (int)(regBase + n));
        translateColumnToCopy(pParse, (int)(addrTop), (int)(pLevel.iTabCur), (int)(pTabItem.regResult), (int)(pLevel.iIdxCur));
        sqlite3VdbeGoto(v, (int)(addrTop));
        pTabItem.fg.viaCoroutine = (uint)(0);
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(5), (int)(pLevel.iTabCur), (int)(addrTop + 1));
        sqlite3VdbeChangeP5(v, (ushort)(3));
    }

    sqlite3VdbeJumpHere(v, (int)(addrTop));
    sqlite3ReleaseTempReg(pParse, (int)(regRecord));
    sqlite3VdbeJumpHere(v, (int)(addrInit));
    end_auto_index_create:
        ; sqlite3ExprDelete ( pParse . db ,  pPartial ) ; 
}</function>
  <function>public static void* contextMalloc(sqlite3_context context, long nByte)
{
    sbyte* z;
    sqlite3 db = sqlite3_context_db_handle(context);
    if ((nByte) &gt; (db.aLimit[0]))
    {
        sqlite3_result_error_toobig(context);
        z = null;
    }
    else
    {
        z = sqlite3Malloc((ulong)(nByte));
        if (z == null)
        {
            sqlite3_result_error_nomem(context);
        }
    }

    return z;
}</function>
  <function>public static int convertCompoundSelectToSubquery(Walker pWalker, Select p)
{
    int i = 0;
    Select pNew;
    Select pX;
    sqlite3 db;
    ExprList_item* a;
    SrcList pNewSrc;
    Parse pParse;
    Token dummy = new Token();
    if ((p.pPrior) == (null))
        return (int)(0);
    if ((p.pOrderBy) == (null))
        return (int)(0);
    for (pX = p; ((pX) != null) &amp;&amp; (((pX.op) == (135)) || ((pX.op) == (138))); pX = pX.pPrior)
    {
    }

    if ((pX) == (null))
        return (int)(0);
    a = p.pOrderBy.a;
    if ((a[0].u.x.iOrderByCol) != 0)
        return (int)(0);
    for (i = (int)(p.pOrderBy.nExpr - 1); (i) &gt;= (0); i--)
    {
        if ((a[i].pExpr.flags &amp; 0x000100) != 0)
            break;
    }

    if ((i) &lt; (0))
        return (int)(0);
    pParse = pWalker.pParse;
    db = pParse.db;
    pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Select)));
    if ((pNew) == (null))
        return (int)(2);
    CRuntime.memset(&amp;dummy, (int)(0), (ulong)(sizeof(Token)));
    pNewSrc = sqlite3SrcListAppendFromTerm(pParse, null, null, null, &amp;dummy, pNew, null, null);
    if ((pNewSrc) == (null))
        return (int)(2);
    pNew = (Select)(p);
    p.pSrc = pNewSrc;
    p.pEList = sqlite3ExprListAppend(pParse, null, sqlite3Expr(db, (int)(180), null));
    p.op = (byte)(138);
    p.pWhere = null;
    pNew.pGroupBy = null;
    pNew.pHaving = null;
    pNew.pOrderBy = null;
    p.pPrior = null;
    p.pNext = null;
    p.pWith = null;
    p.pWinDefn = null;
    p.selFlags &amp;= (uint)(~0x0000100);
    p.selFlags |= (uint)(0x0010000);
    pNew.pPrior.pNext = pNew;
    pNew.pLimit = null;
    return (int)(0);
}</function>
  <function>public static void convertToWithoutRowidTable(Parse pParse, Table pTab)
{
    Index pIdx;
    Index pPk;
    int nPk = 0;
    int nExtra = 0;
    int i = 0; int  j  =  0 ; 
    sqlite3 db = pParse.db;
    Vdbe v = pParse.pVdbe;
    if (db.init.imposterTable == 0)
    {
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            if (((pTab.aCol[i].colFlags &amp; 0x0001) != 0) &amp;&amp; ((pTab.aCol[i].notNull) == (0)))
            {
                pTab.aCol[i].notNull = (uint)(2);
            }
        }

        pTab.tabFlags |= (uint)(0x00000800);
    }

    if ((pParse.u1.addrCrTab) != 0)
    {
        sqlite3VdbeChangeP3(v, (int)(pParse.u1.addrCrTab), (int)(2));
    }

    if ((pTab.iPKey) &gt;= (0))
    {
        ExprList pList;
        Token ipkToken = new Token();
        sqlite3TokenInit(&amp;ipkToken, pTab.aCol[pTab.iPKey].zCnName);
        pList = sqlite3ExprListAppend(pParse, null, sqlite3ExprAlloc(db, (int)(59), &amp;ipkToken, (int)(0)));
        if ((pList) == (null))
        {
            pTab.tabFlags &amp;= (uint)(~0x00000080);
            return;
        }

        if (((pParse.eParseMode) &gt;= (2)))
        {
            sqlite3RenameTokenRemap(pParse, pList.a[0].pExpr, &amp;pTab.iPKey);
        }

        pList.a[0].sortFlags = (byte)(pParse.iPkSortOrder);
        pTab.iPKey = (short)(-1);
        sqlite3CreateIndex(pParse, null, null, null, pList, (int)(pTab.keyConf), null, null, (int)(0), (int)(0), (byte)(2));
        if ((pParse.nErr) != 0)
        {
            pTab.tabFlags &amp;= (uint)(~0x00000080);
            return;
        }

        pPk = sqlite3PrimaryKeyIndex(pTab);
    }
    else
    {
        pPk = sqlite3PrimaryKeyIndex(pTab);
        for (i = (int)(j = (int)(1)); (i) &lt; (pPk.nKeyCol); i++)
        {
            if ((isDupColumn(pPk, (int)(j), pPk, (int)(i))) != 0)
            {
                pPk.nColumn--;
            }
            else
            {
                pPk.azColl[j] = pPk.azColl[i];
                pPk.aSortOrder[j] = (byte)(pPk.aSortOrder[i]);
                pPk.aiColumn[j++] = (short)(pPk.aiColumn[i]);
            }
        }

        pPk.nKeyCol = (ushort)(j);
    }

    pPk.isCovering = (uint)(1);
    if (db.init.imposterTable == 0)
        pPk.uniqNotNull = (uint)(1);
    nPk = (int)(pPk.nColumn = (ushort)(pPk.nKeyCol));
    if (((v) != null) &amp;&amp; ((pPk.tnum) &gt; (0)))
    {
        sqlite3VdbeChangeOpcode(v, (int)(pPk.tnum), (byte)(11));
    }

    pPk.tnum = (uint)(pTab.tnum);
    for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
    {
        int n = 0;
        if ((((pIdx).idxType) == (2)))
            continue;
        for (i = (int)(n = (int)(0)); (i) &lt; (nPk); i++)
        {
            if (isDupColumn(pIdx, (int)(pIdx.nKeyCol), pPk, (int)(i)) == 0)
            {
                n++;
            }
        }

        if ((n) == (0))
        {
            pIdx.nColumn = (ushort)(pIdx.nKeyCol);
            continue;
        }

        if ((resizeIndexObject(db, pIdx, (int)(pIdx.nKeyCol + n))) != 0)
            return;
        for (i = (int)(0), j = (int)(pIdx.nKeyCol); (i) &lt; (nPk); i++)
        {
            if (isDupColumn(pIdx, (int)(pIdx.nKeyCol), pPk, (int)(i)) == 0)
            {
                pIdx.aiColumn[j] = (short)(pPk.aiColumn[i]);
                pIdx.azColl[j] = pPk.azColl[i];
                if ((pPk.aSortOrder[i]) != 0)
                {
                    pIdx.bAscKeyBug = (uint)(1);
                }

                j++;
            }
        }
    }

    nExtra = (int)(0);
    for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
    {
        if ((hasColumn(pPk.aiColumn, (int)(nPk), (int)(i)) == 0) &amp;&amp; ((pTab.aCol[i].colFlags &amp; 0x0020) == (0)))
            nExtra++;
    }

    if ((resizeIndexObject(db, pPk, (int)(nPk + nExtra))) != 0)
        return;
    for (i = (int)(0), j = (int)(nPk); (i) &lt; (pTab.nCol); i++)
    {
        if ((hasColumn(pPk.aiColumn, (int)(j), (int)(i)) == 0) &amp;&amp; ((pTab.aCol[i].colFlags &amp; 0x0020) == (0)))
        {
            pPk.aiColumn[j] = (short)(i);
            pPk.azColl[j] = sqlite3StrBINARY;
            j++;
        }
    }

    recomputeColumnsNotIndexed(pPk);
}</function>
  <function>public static void copyNodeContent(MemPage pFrom, MemPage pTo, int* pRC)
{
    if ((*pRC) == (0))
    {
        BtShared pBt = pFrom.pBt;
        byte* aFrom = pFrom.aData;
        byte* aTo = pTo.aData;
        int iFromHdr = (int)(pFrom.hdrOffset);
        int iToHdr = (int)(((pTo.pgno) == (1)) ? 100 : 0);
        int rc = 0;
        int iData = 0;
        iData = (int)((&amp;aFrom[iFromHdr + 5])[0] &lt;&lt; 8 | (&amp;aFrom[iFromHdr + 5])[1]);
        CRuntime.memcpy(&amp;aTo[iData], &amp;aFrom[iData], (ulong)(pBt.usableSize - iData));
        CRuntime.memcpy(&amp;aTo[iToHdr], &amp;aFrom[iFromHdr], (ulong)(pFrom.cellOffset + 2 * pFrom.nCell));
        pTo.isInit = (byte)(0);
        rc = (int)(btreeInitPage(pTo));
        if ((rc) == (0))
            rc = (int)(btreeComputeFreeSpace(pTo));
        if (rc != 0)
        {
            *pRC = (int)(rc);
            return;
        }

        if ((pBt.autoVacuum) != 0)
        {
            *pRC = (int)(setChildPtrmaps(pTo));
        }
    }
}</function>
  <function>public static int copyPayload(void* pPayload, void* pBuf, int nByte, int eOp, PgHdr pDbPage)
{
    if ((eOp) != 0)
    {
        int rc = (int)(sqlite3PagerWrite(pDbPage));
        if (rc != 0)
        {
            return (int)(rc);
        }

        CRuntime.memcpy(pPayload, pBuf, (ulong)(nByte));
    }
    else
    {
        CRuntime.memcpy(pBuf, pPayload, (ulong)(nByte));
    }

    return (int)(0);
}</function>
  <function>public static void corruptSchema(InitData pData, sbyte** azObj, sbyte* zExtra)
{
    sqlite3 db = pData.db;
    if ((db.mallocFailed) != 0)
    {
        pData.rc = (int)(7);
    }
    else if (pData.pzErrMsg[0] != null)
    {
    }
    else if ((pData.mInitFlags &amp; (0x0003)) != 0)
    {
        *pData.pzErrMsg = sqlite3MPrintf(db, "error in %s %s after %s: %s", azObj[0], azObj[1], corruptSchema_azAlterType[(pData.mInitFlags &amp; 0x0003) - 1], zExtra);
        pData.rc = (int)(1);
    }
    else if ((db.flags &amp; 0x00000001) != 0)
    {
        pData.rc = (int)(sqlite3CorruptError((int)(133217)));
    }
    else
    {
        sbyte* z;
        sbyte* zObj = (azObj[1]) != 0 ? azObj[1] : "?";
        z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
        if (((zExtra) != null) &amp;&amp; ((zExtra[0]) != 0))
            z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
        *pData.pzErrMsg = z;
        pData.rc = (int)(sqlite3CorruptError((int)(133224)));
    }
}</function>
  <function>public static void countFinalize(sqlite3_context context)
{
    CountCtx* p;
    p = sqlite3_aggregate_context(context, (int)(0));
    sqlite3_result_int64(context, (long)(p ? p-&gt;n : 0));
}</function>
  <function>public static void countInverse(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    CountCtx* p;
    p = sqlite3_aggregate_context(ctx, (int)(sizeof(CountCtx)));
    if ((((argc) == (0)) || (5 != sqlite3_value_type(argv[0]))) &amp;&amp; ((p) != null))
    {
        p-&gt;n--;
    }
}</function>
  <function>public static uint countLookasideSlots(LookasideSlot* p)
{
    uint cnt = (uint)(0);
    while ((p) != null)
    {
        p = p-&gt;pNext;
        cnt++;
    }

    return (uint)(cnt);
}</function>
  <function>public static void countStep(sqlite3_context context, int argc, sqlite3_value argv)
{
    CountCtx* p;
    p = sqlite3_aggregate_context(context, (int)(sizeof(CountCtx)));
    if ((((argc) == (0)) || (5 != sqlite3_value_type(argv[0]))) &amp;&amp; ((p) != null))
    {
        p-&gt;n++;
    }
}</function>
  <function>public static void* createAggContext(sqlite3_context p, int nByte)
{
    sqlite3_value pMem = p.pMem;
    if ((nByte) &lt;= (0))
    {
        sqlite3VdbeMemSetNull(pMem);
        pMem.z = null;
    }
    else
    {
        sqlite3VdbeMemClearAndResize(pMem, (int)(nByte));
        pMem.flags = (ushort)(0x2000);
        pMem.u.pDef = p.pFunc;
        if ((pMem.z) != null)
        {
            CRuntime.memset(pMem.z, (int)(0), (ulong)(nByte));
        }
    }

    return (void*)(pMem.z);
}</function>
  <function>public static int createCollation(sqlite3 db, sbyte* zName, byte enc, void* pCtx, delegate70 xCompare, delegate17 xDel)
{
    CollSeq pColl;
    int enc2 = 0;
    enc2 = (int)(enc);
    if (((enc2) == (4)) || ((enc2) == (8)))
    {
        enc2 = (int)(2);
    }

    if (((enc2) &lt; (1)) || ((enc2) &gt; (3)))
    {
        return (int)(sqlite3MisuseError((int)(171202)));
    }

    pColl = sqlite3FindCollSeq(db, (byte)(enc2), zName, (int)(0));
    if (((pColl) != null) &amp;&amp; ((pColl.xCmp) != null))
    {
        if ((db.nVdbeActive) != 0)
        {
            sqlite3ErrorWithMsg(db, (int)(5), "unable to delete/modify collation sequence due to active statements");
            return (int)(5);
        }

        sqlite3ExpirePreparedStatements(db, (int)(0));
        if ((pColl.enc &amp; ~8) == (enc2))
        {
            CollSeq aColl = sqlite3HashFind(&amp;db.aCollSeq, zName);
            int j = 0;
            for (j = (int)(0); (j) &lt; (3); j++)
            {
                CollSeq p = aColl[j];
                if ((p.enc) == (pColl.enc))
                {
                    if ((p.xDel) != null)
                    {
                        p.xDel(p.pUser);
                    }

                    p.xCmp = null;
                }
            }
        }
    }

    pColl = sqlite3FindCollSeq(db, (byte)(enc2), zName, (int)(1));
    if ((pColl) == (null))
        return (int)(7);
    pColl.xCmp = xCompare;
    pColl.pUser = pCtx;
    pColl.xDel = xDel;
    pColl.enc = ((byte)(enc2 | (enc &amp; 8)));
    sqlite3Error(db, (int)(0));
    return (int)(0);
}</function>
  <function>public static int createFunctionApi(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal, delegate69 xValue, delegate68 xInverse, delegate17 xDestroy)
{
    int rc = (int)(1);
    FuncDestructor pArg = null;
    sqlite3_mutex_enter(db.mutex);
    if ((xDestroy) != null)
    {
        pArg = (FuncDestructor)(sqlite3Malloc((ulong)(sizeof(FuncDestructor))));
        if (pArg == null)
        {
            sqlite3OomFault(db);
            xDestroy(p);
            goto  out
            ;
        }

        pArg.nRef = (int)(0);
        pArg.xDestroy = xDestroy;
        pArg.pUserData = p;
    }

    rc = (int)(sqlite3CreateFunc(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, xValue, xInverse, pArg));
    if (((pArg) != null) &amp;&amp; ((pArg.nRef) == (0)))
    {
        xDestroy(p);
        sqlite3_free(pArg);
    }

     out :  ;  rc  =  ( int ) ( sqlite3ApiExit ( db ,  ( int ) ( rc ) ) ) ; 
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static void createMask(WhereMaskSet* pMaskSet, int iCursor)
{
    pMaskSet-&gt;ix[pMaskSet-&gt;n++] = (int)(iCursor);
}</function>
  <function>public static int createModule(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
{
    int rc = (int)(0);
    sqlite3_mutex_enter(db.mutex);
    (void)(sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy));
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    if ((rc != 0) &amp;&amp; ((xDestroy) != null))
        xDestroy(pAux);
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static sbyte* createTableStmt(sqlite3 db, Table p)
{
    int i = 0; int  k  =  0 ;  int  n  =  0 ; 
    sbyte* zStmt;
    sbyte* zSep; sbyte  * zSep2 ;  sbyte  * zEnd ; 
    Column* pCol;
    n = (int)(0);
    for (pCol = p.aCol, i = (int)(0); (i) &lt; (p.nCol); i++, pCol++)
    {
        n += (int)(identLength(pCol-&gt;zCnName) + 5);
    }

    n += (int)(identLength(p.zName));
    if ((n) &lt; (50))
    {
        zSep = "";
        zSep2 = ",";
        zEnd = ")";
    }
    else
    {
        zSep = "\n  ";
        zSep2 = ",\n  ";
        zEnd = "\n)";
    }

    n += (int)(35 + 6 * p.nCol);
    zStmt = sqlite3DbMallocRaw(null, (ulong)(n));
    if ((zStmt) == (null))
    {
        sqlite3OomFault(db);
        return null;
    }

    sqlite3_snprintf((int)(n), zStmt, "CREATE TABLE ");
    k = (int)(sqlite3Strlen30(zStmt));
    identPut(zStmt, &amp;k, p.zName);
    zStmt[k++] = (sbyte)(40);
    for (pCol = p.aCol, i = (int)(0); (i) &lt; (p.nCol); i++, pCol++)
    {
        int len = 0;
        sbyte* zType;
        sqlite3_snprintf((int)(n - k), &amp;zStmt[k], zSep);
        k += (int)(sqlite3Strlen30(&amp;zStmt[k]));
        zSep = zSep2;
        identPut(zStmt, &amp;k, pCol-&gt;zCnName);
        zType = createTableStmt_azType[pCol-&gt;affinity - 0x41];
        len = (int)(sqlite3Strlen30(zType));
        CRuntime.memcpy(&amp;zStmt[k], zType, (ulong)(len));
        k += (int)(len);
    }

    sqlite3_snprintf((int)(n - k), &amp;zStmt[k], "%s", zEnd);
    return zStmt;
}</function>
  <function>public static void cteClear(sqlite3 db, Cte pCte)
{
    sqlite3ExprListDelete(db, pCte.pCols);
    sqlite3SelectDelete(db, pCte.pSelect);
    sqlite3DbFree(db, pCte.zName);
}</function>
  <function>public static void ctimeFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    timeFunc(context, (int)(0), null);
}</function>
  <function>public static void ctimestampFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    datetimeFunc(context, (int)(0), null);
}</function>
  <function>public static void cume_distInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    p-&gt;nStep++;
}</function>
  <function>public static void cume_distStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
    {
        p-&gt;nTotal++;
    }
}</function>
  <function>public static void cume_distValueFunc(sqlite3_context pCtx)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(0)));
    if ((p) != null)
    {
        double r = (double)((double)(p-&gt;nStep) / (double)(p-&gt;nTotal));
        sqlite3_result_double(pCtx, (double)(r));
    }
}</function>
  <function>public static int databaseIsUnmoved(Pager pPager)
{
    int bHasMoved = (int)(0);
    int rc = 0;
    if ((pPager.tempFile) != 0)
        return (int)(0);
    if ((pPager.dbSize) == (0))
        return (int)(0);
    rc = (int)(sqlite3OsFileControl(pPager.fd, (int)(20), &amp;bHasMoved));
    if ((rc) == (12))
    {
        rc = (int)(0);
    }
    else if (((rc) == (0)) &amp;&amp; ((bHasMoved) != 0))
    {
        rc = (int)(8 | (4 &lt;&lt; 8));
    }

    return (int)(rc);
}</function>
  <function>public static sbyte* databaseName(sbyte* zName)
{
    while ((((zName[-1] != 0) || (zName[-2] != 0)) || (zName[-3] != 0)) || (zName[-4] != 0))
    {
        zName--;
    }

    return zName;
}</function>
  <function>public static void dateFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    DateTime x = new DateTime();
    if ((isDate(context, (int)(argc), argv, &amp;x)) == (0))
    {
        int Y = 0;
        sbyte* zBuf = stackalloc sbyte[16];
        computeYMD(&amp;x);
        Y = (int)(x.Y);
        if ((Y) &lt; (0))
            Y = (int)(-Y);
        zBuf[1] = (sbyte)(48 + (Y / 1000) % 10);
        zBuf[2] = (sbyte)(48 + (Y / 100) % 10);
        zBuf[3] = (sbyte)(48 + (Y / 10) % 10);
        zBuf[4] = (sbyte)(48 + (Y) % 10);
        zBuf[5] = (sbyte)(45);
        zBuf[6] = (sbyte)(48 + (x.M / 10) % 10);
        zBuf[7] = (sbyte)(48 + (x.M) % 10);
        zBuf[8] = (sbyte)(45);
        zBuf[9] = (sbyte)(48 + (x.D / 10) % 10);
        zBuf[10] = (sbyte)(48 + (x.D) % 10);
        zBuf[11] = (sbyte)(0);
        if ((x.Y) &lt; (0))
        {
            zBuf[0] = (sbyte)(45);
            sqlite3_result_text(context, zBuf, (int)(11), ((Void(Void * ))(-1)));
        }
        else
        {
            sqlite3_result_text(context, &amp;zBuf[1], (int)(10), ((Void(Void * ))(-1)));
        }
    }
}</function>
  <function>public static void datetimeError(DateTime* p)
{
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
    p-&gt;isError = (sbyte)(1);
}</function>
  <function>public static void datetimeFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    DateTime x = new DateTime();
    if ((isDate(context, (int)(argc), argv, &amp;x)) == (0))
    {
        int Y = 0;
        int s = 0;
        sbyte* zBuf = stackalloc sbyte[24];
        computeYMD_HMS(&amp;x);
        Y = (int)(x.Y);
        if ((Y) &lt; (0))
            Y = (int)(-Y);
        zBuf[1] = (sbyte)(48 + (Y / 1000) % 10);
        zBuf[2] = (sbyte)(48 + (Y / 100) % 10);
        zBuf[3] = (sbyte)(48 + (Y / 10) % 10);
        zBuf[4] = (sbyte)(48 + (Y) % 10);
        zBuf[5] = (sbyte)(45);
        zBuf[6] = (sbyte)(48 + (x.M / 10) % 10);
        zBuf[7] = (sbyte)(48 + (x.M) % 10);
        zBuf[8] = (sbyte)(45);
        zBuf[9] = (sbyte)(48 + (x.D / 10) % 10);
        zBuf[10] = (sbyte)(48 + (x.D) % 10);
        zBuf[11] = (sbyte)(32);
        zBuf[12] = (sbyte)(48 + (x.h / 10) % 10);
        zBuf[13] = (sbyte)(48 + (x.h) % 10);
        zBuf[14] = (sbyte)(58);
        zBuf[15] = (sbyte)(48 + (x.m / 10) % 10);
        zBuf[16] = (sbyte)(48 + (x.m) % 10);
        zBuf[17] = (sbyte)(58);
        s = ((int)(x.s));
        zBuf[18] = (sbyte)(48 + (s / 10) % 10);
        zBuf[19] = (sbyte)(48 + (s) % 10);
        zBuf[20] = (sbyte)(0);
        if ((x.Y) &lt; (0))
        {
            zBuf[0] = (sbyte)(45);
            sqlite3_result_text(context, zBuf, (int)(20), ((Void(Void * ))(-1)));
        }
        else
        {
            sqlite3_result_text(context, &amp;zBuf[1], (int)(19), ((Void(Void * ))(-1)));
        }
    }
}</function>
  <function>public static void* dbMallocRawFinish(sqlite3 db, ulong n)
{
    void* p;
    p = sqlite3Malloc((ulong)(n));
    if (p == null)
        sqlite3OomFault(db);
    return p;
}</function>
  <function>public static void* dbReallocFinish(sqlite3 db, void* p, ulong n)
{
    void* pNew = null;
    if ((db.mallocFailed) == (0))
    {
        if ((isLookaside(db, p)) != 0)
        {
            pNew = sqlite3DbMallocRawNN(db, (ulong)(n));
            if ((pNew) != null)
            {
                CRuntime.memcpy(pNew, p, (ulong)(lookasideMallocSize(db, p)));
                sqlite3DbFree(db, p);
            }
        }
        else
        {
            pNew = sqlite3Realloc(p, (ulong)(n));
            if (pNew == null)
            {
                sqlite3OomFault(db);
            }
        }
    }

    return pNew;
}</function>
  <function>public static int decodeFlags(MemPage pPage, int flagByte)
{
    BtShared pBt;
    pPage.leaf = ((byte)(flagByte &gt;&gt; 3));
    flagByte &amp;= (int)(~0x08);
    pPage.childPtrSize = (byte)(4 - 4 * pPage.leaf);
    pPage.xCellSize = cellSizePtr;
    pBt = pPage.pBt;
    if ((flagByte) == (0x04 | 0x01))
    {
        pPage.intKey = (byte)(1);
        if ((pPage.leaf) != 0)
        {
            pPage.intKeyLeaf = (byte)(1);
            pPage.xParseCell = btreeParseCellPtr;
        }
        else
        {
            pPage.intKeyLeaf = (byte)(0);
            pPage.xCellSize = cellSizePtrNoPayload;
            pPage.xParseCell = btreeParseCellPtrNoPayload;
        }

        pPage.maxLocal = (ushort)(pBt.maxLeaf);
        pPage.minLocal = (ushort)(pBt.minLeaf);
    }
    else if ((flagByte) == (0x02))
    {
        pPage.intKey = (byte)(0);
        pPage.intKeyLeaf = (byte)(0);
        pPage.xParseCell = btreeParseCellPtrIndex;
        pPage.maxLocal = (ushort)(pBt.maxLocal);
        pPage.minLocal = (ushort)(pBt.minLocal);
    }
    else
    {
        return (int)(sqlite3CorruptError((int)(68061)));
    }

    pPage.max1bytePayload = (byte)(pBt.max1bytePayload);
    return (int)(0);
}</function>
  <function>public static void decodeIntArray(sbyte* zIntArray, int nOut, uint* aOut, short* aLog, Index pIndex)
{
    sbyte* z = zIntArray;
    int c = 0;
    int i = 0;
    uint v = 0;
    for (i = (int)(0); ((*z) != 0) &amp;&amp; ((i) &lt; (nOut)); i++)
    {
        v = (uint)(0);
        while (((c = (int)(z[0])) &gt;= (48)) &amp;&amp; ((c) &lt;= (57)))
        {
            v = (uint)(v * 10 + c - 48);
            z++;
        }

        aLog[i] = (short)(sqlite3LogEst((ulong)(v)));
        if ((*z) == (32))
            z++;
    }

    {
        pIndex.bUnordered = (uint)(0);
        pIndex.noSkipScan = (uint)(0);
        while ((z[0]) != 0)
        {
            if ((sqlite3_strglob("unordered*", z)) == (0))
            {
                pIndex.bUnordered = (uint)(1);
            }
            else if ((sqlite3_strglob("sz=[0-9]*", z)) == (0))
            {
                int sz = (int)(sqlite3Atoi(z + 3));
                if ((sz) &lt; (2))
                    sz = (int)(2);
                pIndex.szIdxRow = (short)(sqlite3LogEst((ulong)(sz)));
            }
            else if ((sqlite3_strglob("noskipscan*", z)) == (0))
            {
                pIndex.noSkipScan = (uint)(1);
            }

            while ((z[0] != 0) &amp;&amp; (z[0] != 32))
            {
                z++;
            }

            while ((z[0]) == (32))
            {
                z++;
            }
        }
    }
}</function>
  <function>public static int defragmentPage(MemPage pPage, int nMaxFrag)
{
    int i = 0;
    int pc = 0;
    int hdr = 0;
    int size = 0;
    int usableSize = 0;
    int cellOffset = 0;
    int cbrk = 0;
    int nCell = 0;
    byte* data;
    byte* temp;
    byte* src;
    int iCellFirst = 0;
    int iCellLast = 0;
    int iCellStart = 0;
    temp = null;
    src = data = pPage.aData;
    hdr = (int)(pPage.hdrOffset);
    cellOffset = (int)(pPage.cellOffset);
    nCell = (int)(pPage.nCell);
    iCellFirst = (int)(cellOffset + 2 * nCell);
    usableSize = (int)(pPage.pBt.usableSize);
    if (((int)(data[hdr + 7])) &lt;= (nMaxFrag))
    {
        int iFree = (int)((&amp;data[hdr + 1])[0] &lt;&lt; 8 | (&amp;data[hdr + 1])[1]);
        if ((iFree) &gt; (usableSize - 4))
            return (int)(sqlite3CorruptError((int)(67648)));
        if ((iFree) != 0)
        {
            int iFree2 = (int)((&amp;data[iFree])[0] &lt;&lt; 8 | (&amp;data[iFree])[1]);
            if ((iFree2) &gt; (usableSize - 4))
                return (int)(sqlite3CorruptError((int)(67651)));
            if (((0) == (iFree2)) || (((data[iFree2]) == (0)) &amp;&amp; ((data[iFree2 + 1]) == (0))))
            {
                byte* pEnd = &amp;data[cellOffset + nCell * 2];
                byte* pAddr;
                int sz2 = (int)(0);
                int sz = (int)((&amp;data[iFree + 2])[0] &lt;&lt; 8 | (&amp;data[iFree + 2])[1]);
                int top = (int)((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]);
                if ((top) &gt;= (iFree))
                {
                    return (int)(sqlite3CorruptError((int)(67659)));
                }

                if ((iFree2) != 0)
                {
                    if ((iFree + sz) &gt; (iFree2))
                        return (int)(sqlite3CorruptError((int)(67662)));
                    sz2 = (int)((&amp;data[iFree2 + 2])[0] &lt;&lt; 8 | (&amp;data[iFree2 + 2])[1]);
                    if ((iFree2 + sz2) &gt; (usableSize))
                        return (int)(sqlite3CorruptError((int)(67664)));
                    CRuntime.memmove(&amp;data[iFree + sz + sz2], &amp;data[iFree + sz], (ulong)(iFree2 - (iFree + sz)));
                    sz += (int)(sz2);
                }
                else if (((iFree + sz) &gt; (usableSize)))
                {
                    return (int)(sqlite3CorruptError((int)(67668)));
                }

                cbrk = (int)(top + sz);
                CRuntime.memmove(&amp;data[cbrk], &amp;data[top], (ulong)(iFree - top));
                for (pAddr = &amp;data[cellOffset]; (pAddr) &lt; (pEnd); pAddr += 2)
                {
                    pc = (int)((pAddr)[0] &lt;&lt; 8 | (pAddr)[1]);
                    if ((pc) &lt; (iFree))
                    {
                        ((pAddr)[0] = ((byte)((pc + sz) &gt;&gt; 8)), (pAddr)[1] = ((byte)(pc + sz)));
                    }
                    else if ((pc) &lt; (iFree2))
                    {
                        ((pAddr)[0] = ((byte)((pc + sz2) &gt;&gt; 8)), (pAddr)[1] = ((byte)(pc + sz2)));
                    }
                }

                goto defragment_out;
            }
        }
    }

    cbrk = (int)(usableSize);
    iCellLast = (int)(usableSize - 4);
    iCellStart = (int)((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]);
    for (i = (int)(0); (i) &lt; (nCell); i++)
    {
        byte* pAddr;
        pAddr = &amp;data[cellOffset + i * 2];
        pc = (int)((pAddr)[0] &lt;&lt; 8 | (pAddr)[1]);
        if (((pc) &lt; (iCellStart)) || ((pc) &gt; (iCellLast)))
        {
            return (int)(sqlite3CorruptError((int)(67697)));
        }

        size = (int)(pPage.xCellSize(pPage, &amp;src[pc]));
        cbrk -= (int)(size);
        if (((cbrk) &lt; (iCellStart)) || ((pc + size) &gt; (usableSize)))
        {
            return (int)(sqlite3CorruptError((int)(67703)));
        }

        ((pAddr)[0] = ((byte)((cbrk) &gt;&gt; 8)), (pAddr)[1] = ((byte)(cbrk)));
        if ((temp) == (null))
        {
            if ((cbrk) == (pc))
                continue;
            temp = sqlite3PagerTempSpace(pPage.pBt.pPager);
            CRuntime.memcpy(&amp;temp[iCellStart], &amp;data[iCellStart], (ulong)(usableSize - iCellStart));
            src = temp;
        }

        CRuntime.memcpy(&amp;data[cbrk], &amp;src[pc], (ulong)(size));
    }

    data[hdr + 7] = (byte)(0);
    defragment_out:
        ;
    if (data[hdr + 7] + cbrk - iCellFirst != pPage.nFree)
    {
        return (int)(sqlite3CorruptError((int)(67722)));
    }

    ((&amp;data[hdr + 5])[0] = ((byte)((cbrk) &gt;&gt; 8)), (&amp;data[hdr + 5])[1] = ((byte)(cbrk)));
    data[hdr + 1] = (byte)(0);
    data[hdr + 2] = (byte)(0);
    CRuntime.memset(&amp;data[iCellFirst], (int)(0), (ulong)(cbrk - iCellFirst));
    return (int)(0);
}</function>
  <function>public static void deleteTable(sqlite3 db, Table pTable)
{
    Index pIndex; Index  pNext ; 
    for (pIndex = pTable.pIndex; pIndex; pIndex = pNext)
    {
        pNext = pIndex.pNext;
        if ((((db) == (null)) || ((db.pnBytesFreed) == (null))) &amp;&amp; (!(((pTable).eTabType) == (1))))
        {
            sbyte* zName = pIndex.zName;
            sqlite3HashInsert(&amp;pIndex.pSchema.idxHash, zName, null);
        }

        sqlite3FreeIndex(db, pIndex);
    }

    if ((((pTable).eTabType) == (0)))
    {
        sqlite3FkDelete(db, pTable);
    }
    else if ((((pTable).eTabType) == (1)))
    {
        sqlite3VtabClear(db, pTable);
    }
    else
    {
        sqlite3SelectDelete(db, pTable.u.view.pSelect);
    }

    sqlite3DeleteColumnNames(db, pTable);
    sqlite3DbFree(db, pTable.zName);
    sqlite3DbFree(db, pTable.zColAff);
    sqlite3ExprListDelete(db, pTable.pCheck);
    sqlite3DbFree(db, pTable);
}</function>
  <function>public static void dense_rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
        p-&gt;nStep = (long)(1);
}</function>
  <function>public static void dense_rankValueFunc(sqlite3_context pCtx)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
    {
        if ((p-&gt;nStep) != 0)
        {
            p-&gt;nValue++;
            p-&gt;nStep = (long)(0);
        }

        sqlite3_result_int64(pCtx, (long)(p-&gt;nValue));
    }
}</function>
  <function>public static void destroyRootPage(Parse pParse, int iTable, int iDb)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    int r1 = (int)(sqlite3GetTempReg(pParse));
    if ((iTable) &lt; (2))
        sqlite3ErrorMsg(pParse, "corrupt schema");
    sqlite3VdbeAddOp3(v, (int)(143), (int)(iTable), (int)(r1), (int)(iDb));
    sqlite3MayAbort(pParse);
    sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET rootpage=%d WHERE #%d AND rootpage=#%d", pParse.db.aDb[iDb].zDbSName, (int)(iTable), (int)(r1), (int)(r1));
    sqlite3ReleaseTempReg(pParse, (int)(r1));
}</function>
  <function>public static void destroyTable(Parse pParse, Table pTab)
{
    uint iTab = (uint)(pTab.tnum);
    uint iDestroyed = (uint)(0);
    while ((1) != 0)
    {
        Index pIdx;
        uint iLargest = (uint)(0);
        if (((iDestroyed) == (0)) || ((iTab) &lt; (iDestroyed)))
        {
            iLargest = (uint)(iTab);
        }

        for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            uint iIdx = (uint)(pIdx.tnum);
            if ((((iDestroyed) == (0)) || ((iIdx) &lt; (iDestroyed))) &amp;&amp; ((iIdx) &gt; (iLargest)))
            {
                iLargest = (uint)(iIdx);
            }
        }

        if ((iLargest) == (0))
        {
            return;
        }
        else
        {
            int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
            destroyRootPage(pParse, (int)(iLargest), (int)(iDb));
            iDestroyed = (uint)(iLargest);
        }
    }
}</function>
  <function>public static void detachFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sbyte* zName = (sbyte*)(sqlite3_value_text(argv[0]));
    sqlite3 db = sqlite3_context_db_handle(context);
    int i = 0;
    Db pDb = null;
    HashElem* pEntry;
    sbyte* zErr = stackalloc sbyte[128];
    if ((zName) == (null))
        zName = "";
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        pDb = db.aDb[i];
        if ((pDb.pBt) == (null))
            continue;
        if ((sqlite3DbIsNamed(db, (int)(i), zName)) != 0)
            break;
    }

    if ((i) &gt;= (db.nDb))
    {
        sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "no such database: %s", zName);
        goto detach_error;
    }

    if ((i) &lt; (2))
    {
        sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "cannot detach database %s", zName);
        goto detach_error;
    }

    if ((sqlite3BtreeTxnState(pDb.pBt) != 0) || ((sqlite3BtreeIsInBackup(pDb.pBt)) != 0))
    {
        sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "database %s is locked", zName);
        goto detach_error;
    }

    pEntry = ((&amp;db.aDb[1].pSchema.trigHash)-&gt;first);
    while ((pEntry) != null)
    {
        Trigger pTrig = (Trigger)((pEntry)-&gt;data);
        if ((pTrig.pTabSchema) == (pDb.pSchema))
        {
            pTrig.pTabSchema = pTrig.pSchema;
        }

        pEntry = ((pEntry)-&gt;next);
    }

    sqlite3BtreeClose(pDb.pBt);
    pDb.pBt = null;
    pDb.pSchema = null;
    sqlite3CollapseDatabaseArray(db);
    return;
    detach_error:
        ; sqlite3_result_error ( context ,  zErr ,  ( int ) ( - 1 ) ) ; 
}</function>
  <function>public static void disableLookaside(Parse pParse)
{
    sqlite3 db = pParse.db;
    pParse.disableLookaside++;
    db.lookaside.bDisable++;
    db.lookaside.sz = (ushort)(0);
}</function>
  <function>public static void disableTerm(WhereLevel pLevel, WhereTerm pTerm)
{
    int nLoop = (int)(0);
    while ((((pTerm.wtFlags &amp; 0x0004) == (0)) &amp;&amp; (((pLevel.iLeftJoin) == (0)) || (((pTerm.pExpr).flags &amp; (0x000001)) != 0))) &amp;&amp; ((pLevel.notReady &amp; pTerm.prereqAll) == (0)))
    {
        if (((nLoop) != 0) &amp;&amp; ((pTerm.wtFlags &amp; 0x0400) != 0))
        {
            pTerm.wtFlags |= (ushort)(0x0200);
        }
        else
        {
            pTerm.wtFlags |= (ushort)(0x0004);
        }

        if ((pTerm.iParent) &lt; (0))
            break;
        pTerm = pTerm.pWC.a[pTerm.iParent];
        pTerm.nChild--;
        if (pTerm.nChild != 0)
            break;
        nLoop++;
    }
}</function>
  <function>public static int disallowAggregatesInOrderByCb(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (168)) &amp;&amp; ((pExpr.pAggInfo) == (null)))
    {
        sqlite3ErrorMsg(pWalker.pParse, "misuse of aggregate: %s()", pExpr.u.zToken);
    }

    return (int)(0);
}</function>
  <function>public static void disconnectAllVtab(sqlite3 db)
{
    int i = 0;
    HashElem* p;
    sqlite3BtreeEnterAll(db);
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        Schema pSchema = db.aDb[i].pSchema;
        if ((pSchema) != null)
        {
            for (p = ((&amp;pSchema.tblHash)-&gt;first); p; p = ((p)-&gt;next))
            {
                Table pTab = (Table)((p)-&gt;data);
                if ((((pTab).eTabType) == (1)))
                    sqlite3VtabDisconnect(db, pTab);
            }
        }
    }

    for (p = ((&amp;db.aModule)-&gt;first); p; p = ((p)-&gt;next))
    {
        Module pMod = (Module)((p)-&gt;data);
        if ((pMod.pEpoTab) != null)
        {
            sqlite3VtabDisconnect(db, pMod.pEpoTab);
        }
    }

    sqlite3VtabUnlockList(db);
    sqlite3BtreeLeaveAll(db);
}</function>
  <function>public static long doubleToInt64(double r)
{
    if ((r) &lt;= ((double)(doubleToInt64_minInt)))
    {
        return (long)(doubleToInt64_minInt);
    }
    else if ((r) &gt;= ((double)(doubleToInt64_maxInt)))
    {
        return (long)(doubleToInt64_maxInt);
    }
    else
    {
        return (long)(r);
    }
}</function>
  <function>public static int doWalCallbacks(sqlite3 db)
{
    int rc = (int)(0);
    int i = 0;
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        Btree pBt = db.aDb[i].pBt;
        if ((pBt) != null)
        {
            int nEntry = 0;
            sqlite3BtreeEnter(pBt);
            nEntry = (int)(sqlite3PagerWalCallback(sqlite3BtreePager(pBt)));
            sqlite3BtreeLeave(pBt);
            if ((((nEntry) &gt; (0)) &amp;&amp; ((db.xWalCallback) != null)) &amp;&amp; ((rc) == (0)))
            {
                rc = (int)(db.xWalCallback(db.pWalArg, db, db.aDb[i].zDbSName, (int)(nEntry)));
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static void downgradeAllSharedCacheTableLocks(Btree p)
{
    BtShared pBt = p.pBt;
    if ((pBt.pWriter) == (p))
    {
        BtLock pLock;
        pBt.pWriter = null;
        pBt.btsFlags &amp;= (ushort)(~(0x0040 | 0x0080));
        for (pLock = pBt.pLock; pLock; pLock = pLock.pNext)
        {
            pLock.eLock = (byte)(1);
        }
    }
}</function>
  <function>public static void dropCell(MemPage pPage, int idx, int sz, int* pRC)
{
    uint pc = 0;
    byte* data;
    byte* ptr;
    int rc = 0;
    int hdr = 0;
    if ((*pRC) != 0)
        return;
    data = pPage.aData;
    ptr = &amp;pPage.aCellIdx[2 * idx];
    pc = (uint)((ptr)[0] &lt;&lt; 8 | (ptr)[1]);
    hdr = (int)(pPage.hdrOffset);
    if ((pc + sz) &gt; (pPage.pBt.usableSize))
    {
        *pRC = (int)(sqlite3CorruptError((int)(73020)));
        return;
    }

    rc = (int)(freeSpace(pPage, (ushort)(pc), (ushort)(sz)));
    if ((rc) != 0)
    {
        *pRC = (int)(rc);
        return;
    }

    pPage.nCell--;
    if ((pPage.nCell) == (0))
    {
        CRuntime.memset(&amp;data[hdr + 1], (int)(0), (ulong)(4));
        data[hdr + 7] = (byte)(0);
        ((&amp;data[hdr + 5])[0] = ((byte)((pPage.pBt.usableSize) &gt;&gt; 8)), (&amp;data[hdr + 5])[1] = ((byte)(pPage.pBt.usableSize)));
        pPage.nFree = (int)(pPage.pBt.usableSize - pPage.hdrOffset - pPage.childPtrSize - 8);
    }
    else
    {
        CRuntime.memmove(ptr, ptr + 2, (ulong)(2 * (pPage.nCell - idx)));
        ((&amp;data[hdr + 3])[0] = ((byte)((pPage.nCell) &gt;&gt; 8)), (&amp;data[hdr + 3])[1] = ((byte)(pPage.nCell)));
        pPage.nFree += (int)(2);
    }
}</function>
  <function>public static void dropColumnFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    int iSchema = (int)(sqlite3_value_int(argv[0]));
    sbyte* zSql = (sbyte*)(sqlite3_value_text(argv[1]));
    int iCol = (int)(sqlite3_value_int(argv[2]));
    sbyte* zDb = db.aDb[iSchema].zDbSName;
    int rc = 0;
    Parse sParse = new Parse();
    RenameToken* pCol;
    Table pTab;
    sbyte* zEnd;
    sbyte* zNew = null;
    delegate67 xAuth = db.xAuth;
    db.xAuth = null;
    rc = (int)(renameParseSql(sParse, zDb, db, zSql, ((iSchema) == (1) ? 1 : 0)));
    if (rc != 0)
        goto drop_column_done;
    pTab = sParse.pNewTable;
    if ((((pTab) == (null)) || ((pTab.nCol) == (1))) || ((iCol) &gt;= (pTab.nCol)))
    {
        rc = (int)(sqlite3CorruptError((int)(110906)));
        goto drop_column_done;
    }

    pCol = renameTokenFind(sParse, null, (void*)(pTab.aCol[iCol].zCnName));
    if ((iCol) &lt; (pTab.nCol - 1))
    {
        RenameToken* pEnd;
        pEnd = renameTokenFind(sParse, null, (void*)(pTab.aCol[iCol + 1].zCnName));
        zEnd = pEnd-&gt;t.z;
    }
    else
    {
        zEnd = &amp;zSql[pTab.u.tab.addColOffset];
        while ((pCol-&gt;t.z[0] != 0) &amp;&amp; (pCol-&gt;t.z[0] != 44))
        {
            pCol-&gt;t.z--;
        }
    }

    zNew = sqlite3MPrintf(db, "%.*s%s", (long)(pCol-&gt;t.z - zSql), zSql, zEnd);
    sqlite3_result_text(context, zNew, (int)(-1), ((Void(Void * ))(-1)));
    sqlite3_free(zNew);
    drop_column_done:
        ; renameParseCleanup ( sParse ) ; 
    db.xAuth = xAuth;
    if (rc != 0)
    {
        sqlite3_result_error_code(context, (int)(rc));
    }
}</function>
  <function>public static int dupedExprNodeSize(Expr p, int flags)
{
    int nByte = (int)(dupedExprStructSize(p, (int)(flags)) &amp; 0xfff);
    if ((!(((p).flags &amp; (0x000400)) != 0)) &amp;&amp; ((p.u.zToken) != null))
    {
        nByte += (int)((CRuntime.strlen(p.u.zToken) &amp; 0x3fffffff) + 1);
    }

    return (int)(((nByte) + 7) &amp; ~7);
}</function>
  <function>public static int dupedExprSize(Expr p, int flags)
{
    int nByte = (int)(0);
    if ((p) != null)
    {
        nByte = (int)(dupedExprNodeSize(p, (int)(flags)));
        if ((flags &amp; 0x0001) != 0)
        {
            nByte += (int)(dupedExprSize(p.pLeft, (int)(flags)) + dupedExprSize(p.pRight, (int)(flags)));
        }
    }

    return (int)(nByte);
}</function>
  <function>public static int dupedExprStructSize(Expr p, int flags)
{
    int nSize = 0;
    if ((((0) == (flags)) || ((p.op) == (178))) || (((p).flags &amp; (0x1000000)) != 0))
    {
        nSize = (int)(sizeof(Expr));
    }
    else
    {
        if (((p.pLeft) != null) || ((p.x.pList) != null))
        {
            nSize = (int)(((ulong)(&amp;((0).iTable))) | 0x002000);
        }
        else
        {
            nSize = (int)(((ulong)((0).pLeft)) | 0x004000);
        }
    }

    return (int)(nSize);
}</function>
  <function>public static int editPage(MemPage pPg, int iOld, int iNew, int nNew, CellArray pCArray)
{
    byte* aData = pPg.aData;
    int hdr = (int)(pPg.hdrOffset);
    byte* pBegin = &amp;pPg.aCellIdx[nNew * 2];
    int nCell = (int)(pPg.nCell);
    byte* pData;
    byte* pCellptr;
    int i = 0;
    int iOldEnd = (int)(iOld + pPg.nCell + pPg.nOverflow);
    int iNewEnd = (int)(iNew + nNew);
    if ((iOld) &lt; (iNew))
    {
        int nShift = (int)(pageFreeArray(pPg, (int)(iOld), (int)(iNew - iOld), pCArray));
        if (((nShift) &gt; (nCell)))
            return (int)(sqlite3CorruptError((int)(73528)));
        CRuntime.memmove(pPg.aCellIdx, &amp;pPg.aCellIdx[nShift * 2], (ulong)(nCell * 2));
        nCell -= (int)(nShift);
    }

    if ((iNewEnd) &lt; (iOldEnd))
    {
        int nTail = (int)(pageFreeArray(pPg, (int)(iNewEnd), (int)(iOldEnd - iNewEnd), pCArray));
        nCell -= (int)(nTail);
    }

    pData = &amp;aData[(((((&amp;aData[hdr + 5])[0] &lt;&lt; 8 | (&amp;aData[hdr + 5])[1]) - 1) &amp; 0xffff) + 1)];
    if ((pData) &lt; (pBegin))
        goto editpage_fail;
    if ((pData) &gt; (pPg.aDataEnd))
        goto editpage_fail;
    if ((iNew) &lt; (iOld))
    {
        int nAdd = (int)((nNew) &lt; (iOld - iNew) ? (nNew) : (iOld - iNew));
        pCellptr = pPg.aCellIdx;
        CRuntime.memmove(&amp;pCellptr[nAdd * 2], pCellptr, (ulong)(nCell * 2));
        if ((pageInsertArray(pPg, pBegin, &amp;pData, pCellptr, (int)(iNew), (int)(nAdd), pCArray)) != 0)
            goto editpage_fail;
        nCell += (int)(nAdd);
    }

    for (i = (int)(0); (i) &lt; (pPg.nOverflow); i++)
    {
        int iCell = (int)((iOld + pPg.aiOvfl[i]) - iNew);
        if (((iCell) &gt;= (0)) &amp;&amp; ((iCell) &lt; (nNew)))
        {
            pCellptr = &amp;pPg.aCellIdx[iCell * 2];
            if ((nCell) &gt; (iCell))
            {
                CRuntime.memmove(&amp;pCellptr[2], pCellptr, (ulong)((nCell - iCell) * 2));
            }

            nCell++;
            cachedCellSize(pCArray, (int)(iCell + iNew));
            if ((pageInsertArray(pPg, pBegin, &amp;pData, pCellptr, (int)(iCell + iNew), (int)(1), pCArray)) != 0)
                goto editpage_fail;
        }
    }

    pCellptr = &amp;pPg.aCellIdx[nCell * 2];
    if ((pageInsertArray(pPg, pBegin, &amp;pData, pCellptr, (int)(iNew + nCell), (int)(nNew - nCell), pCArray)) != 0)
        goto editpage_fail;
    pPg.nCell = (ushort)(nNew);
    pPg.nOverflow = (byte)(0);
    ((&amp;aData[hdr + 3])[0] = ((byte)((pPg.nCell) &gt;&gt; 8)), (&amp;aData[hdr + 3])[1] = ((byte)(pPg.nCell)));
    ((&amp;aData[hdr + 5])[0] = ((byte)((pData - aData) &gt;&gt; 8)), (&amp;aData[hdr + 5])[1] = ((byte)(pData - aData)));
    return (int)(0);
    editpage_fail:
        ; populateCellCache ( pCArray ,  ( int ) ( iNew ) ,  ( int ) ( nNew ) ) ; 
    return (int)(rebuildPage(pCArray, (int)(iNew), (int)(nNew), pPg));
}</function>
  <function>public static void enlargeAndAppend(sqlite3_str p, sbyte* z, int N)
{
    N = (int)(sqlite3StrAccumEnlarge(p, (int)(N)));
    if ((N) &gt; (0))
    {
        CRuntime.memcpy(&amp;p.zText[p.nChar], z, (ulong)(N));
        p.nChar += (uint)(N);
    }
}</function>
  <function>public static void errlogFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    sqlite3_log((int)(sqlite3_value_int(argv[0])), "%s", sqlite3_value_text(argv[1]));
}</function>
  <function>public static void estimateIndexWidth(Index pIdx)
{
    uint wIndex = (uint)(0);
    int i = 0;
    Column* aCol = pIdx.pTable.aCol;
    for (i = (int)(0); (i) &lt; (pIdx.nColumn); i++)
    {
        short x = (short)(pIdx.aiColumn[i]);
        wIndex += (uint)((x) &lt; (0) ? 1 : aCol[pIdx.aiColumn[i]].szEst);
    }

    pIdx.szIdxRow = (short)(sqlite3LogEst((ulong)(wIndex * 4)));
}</function>
  <function>public static void estimateTableWidth(Table pTab)
{
    uint wTable = (uint)(0);
    Column* pTabCol;
    int i = 0;
    for (i = (int)(pTab.nCol), pTabCol = pTab.aCol; (i) &gt; (0); i--, pTabCol++)
    {
        wTable += (uint)(pTabCol-&gt;szEst);
    }

    if ((pTab.iPKey) &lt; (0))
        wTable++;
    pTab.szTabRow = (short)(sqlite3LogEst((ulong)(wTable * 4)));
}</function>
  <function>public static short estLog(short N)
{
    return (short)((N) &lt;= (10) ? 0 : sqlite3LogEst((ulong)(N)) - 33);
}</function>
  <function>public static sbyte et_getdigit(double* val, int* cnt)
{
    int digit = 0;
    double d = 0;
    if ((*cnt) &lt;= (0))
        return (sbyte)(48);
    (*cnt)--;
    digit = ((int)(*val));
    d = (double)(digit);
    digit += (int)(48);
    *val = (double)((*val - d) * 10.0);
    return (sbyte)(digit);
}</function>
  <function>public static int execSql(sqlite3 db, sbyte** pzErrMsg, sbyte* zSql)
{
    sqlite3_stmt* pStmt;
    int rc = 0;
    rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &amp;pStmt, null));
    if (rc != 0)
        return (int)(rc);
    while ((100) == (rc = (int)(sqlite3_step(pStmt))))
    {
        sbyte* zSubSql = (sbyte*)(sqlite3_column_text(pStmt, (int)(0)));
        if (((zSubSql) != null) &amp;&amp; (((CRuntime.strncmp(zSubSql, "CRE", (ulong)(3))) == (0)) || ((CRuntime.strncmp(zSubSql, "INS", (ulong)(3))) == (0))))
        {
            rc = (int)(execSql(db, pzErrMsg, zSubSql));
            if (rc != 0)
                break;
        }
    }

    if ((rc) == (101))
        rc = (int)(0);
    if ((rc) != 0)
    {
        sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
    }

    (void)(sqlite3_finalize(pStmt));
    return (int)(rc);
}</function>
  <function>public static int execSqlF(sqlite3 db, sbyte** pzErrMsg, sbyte* zSql)
{
    sbyte* z;
    sbyte* ap;
    int rc = 0;
    (__va_start(&amp;ap, zSql));
    z = sqlite3VMPrintf(db, zSql, ap);
    ((void)(ap = null));
    if ((z) == (null))
        return (int)(7);
    rc = (int)(execSql(db, pzErrMsg, z));
    sqlite3DbFree(db, z);
    return (int)(rc);
}</function>
  <function>public static void explainAppendTerm(sqlite3_str pStr, Index pIdx, int nTerm, int iTerm, int bAnd, sbyte* zOp)
{
    int i = 0;
    if ((bAnd) != 0)
        sqlite3_str_append(pStr, " AND ", (int)(5));
    if ((nTerm) &gt; (1))
        sqlite3_str_append(pStr, "(", (int)(1));
    for (i = (int)(0); (i) &lt; (nTerm); i++)
    {
        if ((i) != 0)
            sqlite3_str_append(pStr, ",", (int)(1));
        sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, (int)(iTerm + i)));
    }

    if ((nTerm) &gt; (1))
        sqlite3_str_append(pStr, ")", (int)(1));
    sqlite3_str_append(pStr, zOp, (int)(1));
    if ((nTerm) &gt; (1))
        sqlite3_str_append(pStr, "(", (int)(1));
    for (i = (int)(0); (i) &lt; (nTerm); i++)
    {
        if ((i) != 0)
            sqlite3_str_append(pStr, ",", (int)(1));
        sqlite3_str_append(pStr, "?", (int)(1));
    }

    if ((nTerm) &gt; (1))
        sqlite3_str_append(pStr, ")", (int)(1));
}</function>
  <function>public static sbyte* explainIndexColumnName(Index pIdx, int i)
{
    i = (int)(pIdx.aiColumn[i]);
    if ((i) == (-2))
        return "&lt;expr&gt;";
    if ((i) == (-1))
        return "rowid";
    return pIdx.pTable.aCol[i].zCnName;
}</function>
  <function>public static void explainIndexRange(sqlite3_str pStr, WhereLoop pLoop)
{
    Index pIndex = pLoop.u.btree.pIndex;
    ushort nEq = (ushort)(pLoop.u.btree.nEq);
    ushort nSkip = (ushort)(pLoop.nSkip);
    int i = 0; int  j  =  0 ; 
    if (((nEq) == (0)) &amp;&amp; ((pLoop.wsFlags &amp; (0x00000020 | 0x00000010)) == (0)))
        return;
    sqlite3_str_append(pStr, " (", (int)(2));
    for (i = (int)(0); (i) &lt; (nEq); i++)
    {
        sbyte* z = explainIndexColumnName(pIndex, (int)(i));
        if ((i) != 0)
            sqlite3_str_append(pStr, " AND ", (int)(5));
        sqlite3_str_appendf(pStr, (i) &gt;= (nSkip) ? "%s=?" : "ANY(%s)", z);
    }

    j = (int)(i);
    if ((pLoop.wsFlags &amp; 0x00000020) != 0)
    {
        explainAppendTerm(pStr, pIndex, (int)(pLoop.u.btree.nBtm), (int)(j), (int)(i), "&gt;");
        i = (int)(1);
    }

    if ((pLoop.wsFlags &amp; 0x00000010) != 0)
    {
        explainAppendTerm(pStr, pIndex, (int)(pLoop.u.btree.nTop), (int)(j), (int)(i), "&lt;");
    }

    sqlite3_str_append(pStr, ")", (int)(1));
}</function>
  <function>public static void explainSimpleCount(Parse pParse, Table pTab, Index pIdx)
{
    if ((pParse.explain) == (2))
    {
        int bCover = (int)(((pIdx != null) &amp;&amp; ((((pTab).tabFlags &amp; 0x00000080) == (0)) || (!(((pIdx).idxType) == (2))))) ? 1 : 0);
        sqlite3VdbeExplain(pParse, (byte)(0), "SCAN %s%s%s", pTab.zName, (bCover) != 0 ? " USING COVERING INDEX " : "", (bCover) != 0 ? pIdx.zName : "");
    }
}</function>
  <function>public static void explainTempTable(Parse pParse, sbyte* zUsage)
{
    sqlite3VdbeExplain(pParse, (byte)(0), "USE TEMP B-TREE FOR %s", zUsage);
}</function>
  <function>public static void exprAnalyze(SrcList pSrc, WhereClause pWC, int idxTerm)
{
    WhereInfo pWInfo = pWC.pWInfo;
    WhereTerm pTerm;
    WhereMaskSet* pMaskSet;
    Expr pExpr;
    ulong prereqLeft = 0;
    ulong prereqAll = 0;
    ulong extraRight = (ulong)(0);
    Expr pStr1 = null;
    int isComplete = (int)(0);
    int noCase = (int)(0);
    int op = 0;
    Parse pParse = pWInfo.pParse;
    sqlite3 db = pParse.db;
    byte eOp2 = (byte)(0);
    int nLeft = 0;
    if ((db.mallocFailed) != 0)
    {
        return;
    }

    pTerm = pWC.a[idxTerm];
    pMaskSet = &amp;pWInfo.sMaskSet;
    pExpr = pTerm.pExpr;
    pMaskSet-&gt;bVarSelect = (int)(0);
    prereqLeft = (ulong)(sqlite3WhereExprUsage(pMaskSet, pExpr.pLeft));
    op = (int)(pExpr.op);
    if ((op) == (49))
    {
        if ((sqlite3ExprCheckIN(pParse, pExpr)) != 0)
            return;
        if ((((pExpr).flags &amp; 0x000800) != 0))
        {
            pTerm.prereqRight = (ulong)(exprSelectUsage(pMaskSet, pExpr.x.pSelect));
        }
        else
        {
            pTerm.prereqRight = (ulong)(sqlite3WhereExprListUsage(pMaskSet, pExpr.x.pList));
        }

        prereqAll = (ulong)(prereqLeft | pTerm.prereqRight);
    }
    else
    {
        pTerm.prereqRight = (ulong)(sqlite3WhereExprUsage(pMaskSet, pExpr.pRight));
        if ((((pExpr.pLeft) == (null)) || (((pExpr).flags &amp; (0x000800 | 0x020000)) != 0)) || (pExpr.x.pList != null))
        {
            prereqAll = (ulong)(sqlite3WhereExprUsageNN(pMaskSet, pExpr));
        }
        else
        {
            prereqAll = (ulong)(prereqLeft | pTerm.prereqRight);
        }
    }

    if ((pMaskSet-&gt;bVarSelect) != 0)
        pTerm.wtFlags |= (ushort)(0x1000);
    if ((((pExpr).flags &amp; (0x000001)) != 0))
    {
        ulong x = (ulong)(sqlite3WhereGetMask(pMaskSet, (int)(pExpr.w.iRightJoinTable)));
        prereqAll |= (ulong)(x);
        extraRight = (ulong)(x - 1);
        if ((prereqAll &gt;&gt; 1) &gt;= (x))
        {
            sqlite3ErrorMsg(pParse, "ON clause references tables to its right");
            return;
        }
    }

    pTerm.prereqAll = (ulong)(prereqAll);
    pTerm.leftCursor = (int)(-1);
    pTerm.iParent = (int)(-1);
    pTerm.eOperator = (ushort)(0);
    if ((allowedOp((int)(op))) != 0)
    {
        int* aiCurCol = stackalloc int[2];
        Expr pLeft = sqlite3ExprSkipCollate(pExpr.pLeft);
        Expr pRight = sqlite3ExprSkipCollate(pExpr.pRight);
        ushort opMask = (ushort)((pTerm.prereqRight &amp; prereqLeft) == (0) ? 0x1fff : 0x0800);
        if ((pTerm.u.x.iField) &gt; (0))
        {
            pLeft = pLeft.x.pList.a[pTerm.u.x.iField - 1].pExpr;
        }

        if ((exprMightBeIndexed(pSrc, (ulong)(prereqLeft), aiCurCol, pLeft, (int)(op))) != 0)
        {
            pTerm.leftCursor = (int)(aiCurCol[0]);
            pTerm.u.x.leftColumn = (int)(aiCurCol[1]);
            pTerm.eOperator = (ushort)(operatorMask((int)(op)) &amp; opMask);
        }

        if ((op) == (45))
            pTerm.wtFlags |= (ushort)(0x0800);
        if ((((pRight) != null) &amp;&amp; ((exprMightBeIndexed(pSrc, (ulong)(pTerm.prereqRight), aiCurCol, pRight, (int)(op))) != 0)) &amp;&amp; (!(((pRight).flags &amp; (0x000008)) != 0)))
        {
            WhereTerm pNew;
            Expr pDup;
            ushort eExtraOp = (ushort)(0);
            if ((pTerm.leftCursor) &gt;= (0))
            {
                int idxNew = 0;
                pDup = sqlite3ExprDup(db, pExpr, (int)(0));
                if ((db.mallocFailed) != 0)
                {
                    sqlite3ExprDelete(db, pDup);
                    return;
                }

                idxNew = (int)(whereClauseInsert(pWC, pDup, (ushort)(0x0002 | 0x0001)));
                if ((idxNew) == (0))
                    return;
                pNew = pWC.a[idxNew];
                markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
                if ((op) == (45))
                    pNew.wtFlags |= (ushort)(0x0800);
                pTerm = pWC.a[idxTerm];
                pTerm.wtFlags |= (ushort)(0x0008);
                if ((termIsEquivalence(pParse, pDup)) != 0)
                {
                    pTerm.eOperator |= (ushort)(0x0800);
                    eExtraOp = (ushort)(0x0800);
                }
            }
            else
            {
                pDup = pExpr;
                pNew = pTerm;
            }

            pNew.wtFlags |= (ushort)(exprCommute(pParse, pDup));
            pNew.leftCursor = (int)(aiCurCol[0]);
            pNew.u.x.leftColumn = (int)(aiCurCol[1]);
            pNew.prereqRight = (ulong)(prereqLeft | extraRight);
            pNew.prereqAll = (ulong)(prereqAll);
            pNew.eOperator = (ushort)((operatorMask((int)(pDup.op)) + eExtraOp) &amp; opMask);
        }
        else if ((((op) == (50)) &amp;&amp; (!(((pExpr).flags &amp; (0x000001)) != 0))) &amp;&amp; ((0) == (sqlite3ExprCanBeNull(pLeft))))
        {
            pExpr.op = (byte)(170);
            pExpr.u.zToken = "false";
            (pExpr).flags |= (uint)(0x20000000);
            pTerm.prereqAll = (ulong)(0);
            pTerm.eOperator = (ushort)(0);
        }
    }
    else if (((pExpr.op) == (48)) &amp;&amp; ((pWC.op) == (44)))
    {
        ExprList pList;
        int i = 0;
        pList = pExpr.x.pList;
        for (i = (int)(0); (i) &lt; (2); i++)
        {
            Expr pNewExpr;
            int idxNew = 0;
            pNewExpr = sqlite3PExpr(pParse, (int)(exprAnalyze_ops[i]), sqlite3ExprDup(db, pExpr.pLeft, (int)(0)), sqlite3ExprDup(db, pList.a[i].pExpr, (int)(0)));
            transferJoinMarkings(pNewExpr, pExpr);
            idxNew = (int)(whereClauseInsert(pWC, pNewExpr, (ushort)(0x0002 | 0x0001)));
            exprAnalyze(pSrc, pWC, (int)(idxNew));
            pTerm = pWC.a[idxTerm];
            markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
        }
    }
    else if ((pExpr.op) == (43))
    {
        exprAnalyzeOrTerm(pSrc, pWC, (int)(idxTerm));
        pTerm = pWC.a[idxTerm];
    }
    else if ((pExpr.op) == (51))
    {
        if ((((pExpr.pLeft.op) == (167)) &amp;&amp; ((pExpr.pLeft.iColumn) &gt;= (0))) &amp;&amp; (!(((pExpr).flags &amp; (0x000001)) != 0)))
        {
            Expr pNewExpr;
            Expr pLeft = pExpr.pLeft;
            int idxNew = 0;
            WhereTerm pNewTerm;
            pNewExpr = sqlite3PExpr(pParse, (int)(54), sqlite3ExprDup(db, pLeft, (int)(0)), sqlite3ExprAlloc(db, (int)(121), null, (int)(0)));
            idxNew = (int)(whereClauseInsert(pWC, pNewExpr, (ushort)(0x0002 | 0x0001 | 0x0080)));
            if ((idxNew) != 0)
            {
                pNewTerm = pWC.a[idxNew];
                pNewTerm.prereqRight = (ulong)(0);
                pNewTerm.leftCursor = (int)(pLeft.iTable);
                pNewTerm.u.x.leftColumn = (int)(pLeft.iColumn);
                pNewTerm.eOperator = (ushort)(0x0002 &lt;&lt; (54 - 53));
                markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
                pTerm = pWC.a[idxTerm];
                pTerm.wtFlags |= (ushort)(0x0008);
                pNewTerm.prereqAll = (ulong)(pTerm.prereqAll);
            }
        }
    }
    else if ((((pExpr.op) == (172)) &amp;&amp; ((pWC.op) == (44))) &amp;&amp; ((isLikeOrGlob(pParse, pExpr, pStr1, &amp;isComplete, &amp;noCase)) != 0))
    {
        Expr pLeft;
        Expr pStr2;
        Expr pNewExpr1;
        Expr pNewExpr2;
        int idxNew1 = 0;
        int idxNew2 = 0;
        sbyte* zCollSeqName;
        ushort wtFlags = (ushort)(0x0100 | 0x0002 | 0x0001);
        pLeft = pExpr.x.pList.a[1].pExpr;
        pStr2 = sqlite3ExprDup(db, pStr1, (int)(0));
        if (((noCase) != 0) &amp;&amp; (pParse.db.mallocFailed == 0))
        {
            int i = 0;
            sbyte c = 0;
            pTerm.wtFlags |= (ushort)(0x0400);
            for (i = (int)(0); (c = (sbyte)(pStr1.u.zToken[i])) != 0; i++)
            {
                pStr1.u.zToken[i] = (sbyte)((c) &amp; ~(sqlite3CtypeMap[(byte)(c)] &amp; 0x20));
                pStr2.u.zToken[i] = (sbyte)(sqlite3UpperToLower[(byte)(c)]);
            }
        }

        if (db.mallocFailed == 0)
        {
            byte c = 0;
            byte* pC;
            pC = (byte*)(&amp;pStr2.u.zToken[sqlite3Strlen30(pStr2.u.zToken) - 1]);
            c = (byte)(*pC);
            if ((noCase) != 0)
            {
                if ((c) == (65 - 1))
                    isComplete = (int)(0);
                c = (byte)(sqlite3UpperToLower[c]);
            }

            *pC = (byte)(c + 1);
        }

        zCollSeqName = (noCase) != 0 ? "NOCASE" : sqlite3StrBINARY;
        pNewExpr1 = sqlite3ExprDup(db, pLeft, (int)(0));
        pNewExpr1 = sqlite3PExpr(pParse, (int)(57), sqlite3ExprAddCollateString(pParse, pNewExpr1, zCollSeqName), pStr1);
        transferJoinMarkings(pNewExpr1, pExpr);
        idxNew1 = (int)(whereClauseInsert(pWC, pNewExpr1, (ushort)(wtFlags)));
        exprAnalyze(pSrc, pWC, (int)(idxNew1));
        pNewExpr2 = sqlite3ExprDup(db, pLeft, (int)(0));
        pNewExpr2 = sqlite3PExpr(pParse, (int)(56), sqlite3ExprAddCollateString(pParse, pNewExpr2, zCollSeqName), pStr2);
        transferJoinMarkings(pNewExpr2, pExpr);
        idxNew2 = (int)(whereClauseInsert(pWC, pNewExpr2, (ushort)(wtFlags)));
        exprAnalyze(pSrc, pWC, (int)(idxNew2));
        pTerm = pWC.a[idxTerm];
        if ((isComplete) != 0)
        {
            markTermAsChild(pWC, (int)(idxNew1), (int)(idxTerm));
            markTermAsChild(pWC, (int)(idxNew2), (int)(idxTerm));
        }
    }

    if (((((((pExpr.op) == (53)) || ((pExpr.op) == (45))) &amp;&amp; ((nLeft = (int)(sqlite3ExprVectorSize(pExpr.pLeft))) &gt; (1))) &amp;&amp; ((sqlite3ExprVectorSize(pExpr.pRight)) == (nLeft))) &amp;&amp; (((pExpr.pLeft.flags &amp; 0x000800) == (0)) || ((pExpr.pRight.flags &amp; 0x000800) == (0)))) &amp;&amp; ((pWC.op) == (44)))
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (nLeft); i++)
        {
            int idxNew = 0;
            Expr pNew;
            Expr pLeft = sqlite3ExprForVectorField(pParse, pExpr.pLeft, (int)(i), (int)(nLeft));
            Expr pRight = sqlite3ExprForVectorField(pParse, pExpr.pRight, (int)(i), (int)(nLeft));
            pNew = sqlite3PExpr(pParse, (int)(pExpr.op), pLeft, pRight);
            transferJoinMarkings(pNew, pExpr);
            idxNew = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0001 | 0x8000)));
            exprAnalyze(pSrc, pWC, (int)(idxNew));
        }

        pTerm = pWC.a[idxTerm];
        pTerm.wtFlags |= (ushort)(0x0004 | 0x0002);
        pTerm.eOperator = (ushort)(0);
    }
    else if ((((((((pExpr.op) == (49)) &amp;&amp; ((pTerm.u.x.iField) == (0))) &amp;&amp; ((pExpr.pLeft.op) == (177))) &amp;&amp; ((((pExpr).flags &amp; 0x000800) != 0) != 0)) &amp;&amp; ((pExpr.x.pSelect.pPrior) == (null))) &amp;&amp; ((pExpr.x.pSelect.pWin) == (null))) &amp;&amp; ((pWC.op) == (44)))
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (sqlite3ExprVectorSize(pExpr.pLeft)); i++)
        {
            int idxNew = 0;
            idxNew = (int)(whereClauseInsert(pWC, pExpr, (ushort)(0x0002 | 0x8000)));
            pWC.a[idxNew].u.x.iField = (int)(i + 1);
            exprAnalyze(pSrc, pWC, (int)(idxNew));
            markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
        }
    }
    else if ((pWC.op) == (44))
    {
        Expr pRight = null;
        Expr pLeft = null;
        int res = (int)(isAuxiliaryVtabOperator(db, pExpr, &amp;eOp2, pLeft, pRight));
        while ((res--) &gt; (0))
        {
            int idxNew = 0;
            WhereTerm pNewTerm;
            ulong prereqColumn = 0;
            ulong prereqExpr = 0;
            prereqExpr = (ulong)(sqlite3WhereExprUsage(pMaskSet, pRight));
            prereqColumn = (ulong)(sqlite3WhereExprUsage(pMaskSet, pLeft));
            if ((prereqExpr &amp; prereqColumn) == (0))
            {
                Expr pNewExpr;
                pNewExpr = sqlite3PExpr(pParse, (int)(46), null, sqlite3ExprDup(db, pRight, (int)(0)));
                if ((((pExpr).flags &amp; (0x000001)) != 0) &amp;&amp; ((pNewExpr) != null))
                {
                    (pNewExpr).flags |= (uint)(0x000001);
                    pNewExpr.w.iRightJoinTable = (int)(pExpr.w.iRightJoinTable);
                }

                idxNew = (int)(whereClauseInsert(pWC, pNewExpr, (ushort)(0x0002 | 0x0001)));
                pNewTerm = pWC.a[idxNew];
                pNewTerm.prereqRight = (ulong)(prereqExpr);
                pNewTerm.leftCursor = (int)(pLeft.iTable);
                pNewTerm.u.x.leftColumn = (int)(pLeft.iColumn);
                pNewTerm.eOperator = (ushort)(0x0040);
                pNewTerm.eMatchOp = (byte)(eOp2);
                markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
                pTerm = pWC.a[idxTerm];
                pTerm.wtFlags |= (ushort)(0x0008);
                pNewTerm.prereqAll = (ulong)(pTerm.prereqAll);
            }

            {
                Expr t = pLeft;
                pLeft = pRight;
                pRight = t;
            }
        }
    }

    pTerm = pWC.a[idxTerm];
    pTerm.prereqRight |= (ulong)(extraRight);
}</function>
  <function>public static void exprAnalyzeOrTerm(SrcList pSrc, WhereClause pWC, int idxTerm)
{
    WhereInfo pWInfo = pWC.pWInfo;
    Parse pParse = pWInfo.pParse;
    sqlite3 db = pParse.db;
    WhereTerm pTerm = pWC.a[idxTerm];
    Expr pExpr = pTerm.pExpr;
    int i = 0;
    WhereClause pOrWc;
    WhereTerm pOrTerm;
    WhereOrInfo pOrInfo;
    ulong chngToIN = 0;
    ulong indexable = 0;
    pTerm.u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, (ulong)(sizeof(WhereOrInfo)));
    if ((pOrInfo) == (null))
        return;
    pTerm.wtFlags |= (ushort)(0x0010);
    pOrWc = pOrInfo.wc;
    CRuntime.memset(pOrWc.aStatic, (int)(0), (ulong)(8 * sizeof(WhereTerm)));
    sqlite3WhereClauseInit(pOrWc, pWInfo);
    sqlite3WhereSplit(pOrWc, pExpr, (byte)(43));
    sqlite3WhereExprAnalyze(pSrc, pOrWc);
    if ((db.mallocFailed) != 0)
        return;
    indexable = (ulong)(~(ulong)(0));
    chngToIN = (ulong)(~(ulong)(0));
    for (i = (int)(pOrWc.nTerm - 1), pOrTerm = pOrWc.a; ((i) &gt;= (0)) &amp;&amp; ((indexable) != 0); i--, pOrTerm++)
    {
        if ((pOrTerm.eOperator &amp; 0x01ff) == (0))
        {
            WhereAndInfo pAndInfo;
            chngToIN = (ulong)(0);
            pAndInfo = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereAndInfo)));
            if ((pAndInfo) != null)
            {
                WhereClause pAndWC;
                WhereTerm pAndTerm;
                int j = 0;
                ulong b = (ulong)(0);
                pOrTerm.u.pAndInfo = pAndInfo;
                pOrTerm.wtFlags |= (ushort)(0x0020);
                pOrTerm.eOperator = (ushort)(0x0400);
                pOrTerm.leftCursor = (int)(-1);
                pAndWC = pAndInfo.wc;
                CRuntime.memset(pAndWC.aStatic, (int)(0), (ulong)(8 * sizeof(WhereTerm)));
                sqlite3WhereClauseInit(pAndWC, pWC.pWInfo);
                sqlite3WhereSplit(pAndWC, pOrTerm.pExpr, (byte)(44));
                sqlite3WhereExprAnalyze(pSrc, pAndWC);
                pAndWC.pOuter = pWC;
                if (db.mallocFailed == 0)
                {
                    for (j = (int)(0), pAndTerm = pAndWC.a; (j) &lt; (pAndWC.nTerm); j++, pAndTerm++)
                    {
                        if (((allowedOp((int)(pAndTerm.pExpr.op))) != 0) || ((pAndTerm.eOperator) == (0x0040)))
                        {
                            b |= (ulong)(sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(pAndTerm.leftCursor)));
                        }
                    }
                }

                indexable &amp;= (ulong)(b);
            }
        }
        else if ((pOrTerm.wtFlags &amp; 0x0008) != 0)
        {
        }
        else
        {
            ulong b = 0;
            b = (ulong)(sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(pOrTerm.leftCursor)));
            if ((pOrTerm.wtFlags &amp; 0x0002) != 0)
            {
                WhereTerm pOther = pOrWc.a[pOrTerm.iParent];
                b |= (ulong)(sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(pOther.leftCursor)));
            }

            indexable &amp;= (ulong)(b);
            if ((pOrTerm.eOperator &amp; 0x0002) == (0))
            {
                chngToIN = (ulong)(0);
            }
            else
            {
                chngToIN &amp;= (ulong)(b);
            }
        }
    }

    pOrInfo.indexable = (ulong)(indexable);
    pTerm.eOperator = (ushort)(0x0200);
    pTerm.leftCursor = (int)(-1);
    if ((indexable) != 0)
    {
        pWC.hasOr = (byte)(1);
    }

    if (((indexable) != 0) &amp;&amp; ((pOrWc.nTerm) == (2)))
    {
        int iOne = (int)(0);
        WhereTerm pOne;
        while ((pOne = whereNthSubterm(pOrWc.a[0], (int)(iOne++))) != null)
        {
            int iTwo = (int)(0);
            WhereTerm pTwo;
            while ((pTwo = whereNthSubterm(pOrWc.a[1], (int)(iTwo++))) != null)
            {
                whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
            }
        }
    }

    if ((chngToIN) != 0)
    {
        int okToChngToIN = (int)(0);
        int iColumn = (int)(-1);
        int iCursor = (int)(-1);
        int j = (int)(0);
        for (j = (int)(0); ((j) &lt; (2)) &amp;&amp; (okToChngToIN == 0); j++)
        {
            Expr pLeft = null;
            pOrTerm = pOrWc.a;
            for (i = (int)(pOrWc.nTerm - 1); (i) &gt;= (0); i--, pOrTerm++)
            {
                pOrTerm.wtFlags &amp;= (ushort)(~0x0040);
                if ((pOrTerm.leftCursor) == (iCursor))
                {
                    continue;
                }

                if ((chngToIN &amp; sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(pOrTerm.leftCursor))) == (0))
                {
                    continue;
                }

                iColumn = (int)(pOrTerm.u.x.leftColumn);
                iCursor = (int)(pOrTerm.leftCursor);
                pLeft = pOrTerm.pExpr.pLeft;
                break;
            }

            if ((i) &lt; (0))
            {
                break;
            }

            okToChngToIN = (int)(1);
            for (; ((i) &gt;= (0)) &amp;&amp; ((okToChngToIN) != 0); i--, pOrTerm++)
            {
                if (pOrTerm.leftCursor != iCursor)
                {
                    pOrTerm.wtFlags &amp;= (ushort)(~0x0040);
                }
                else if ((pOrTerm.u.x.leftColumn != iColumn) || (((iColumn) == (-2)) &amp;&amp; ((sqlite3ExprCompare(pParse, pOrTerm.pExpr.pLeft, pLeft, (int)(-1))) != 0)))
                {
                    okToChngToIN = (int)(0);
                }
                else
                {
                    int affLeft = 0;
                    int affRight = 0;
                    affRight = (int)(sqlite3ExprAffinity(pOrTerm.pExpr.pRight));
                    affLeft = (int)(sqlite3ExprAffinity(pOrTerm.pExpr.pLeft));
                    if ((affRight != 0) &amp;&amp; (affRight != affLeft))
                    {
                        okToChngToIN = (int)(0);
                    }
                    else
                    {
                        pOrTerm.wtFlags |= (ushort)(0x0040);
                    }
                }
            }
        }

        if ((okToChngToIN) != 0)
        {
            Expr pDup;
            ExprList pList = null;
            Expr pLeft = null;
            Expr pNew;
            for (i = (int)(pOrWc.nTerm - 1), pOrTerm = pOrWc.a; (i) &gt;= (0); i--, pOrTerm++)
            {
                if ((pOrTerm.wtFlags &amp; 0x0040) == (0))
                    continue;
                pDup = sqlite3ExprDup(db, pOrTerm.pExpr.pRight, (int)(0));
                pList = sqlite3ExprListAppend(pWInfo.pParse, pList, pDup);
                pLeft = pOrTerm.pExpr.pLeft;
            }

            pDup = sqlite3ExprDup(db, pLeft, (int)(0));
            pNew = sqlite3PExpr(pParse, (int)(49), pDup, null);
            if ((pNew) != null)
            {
                int idxNew = 0;
                transferJoinMarkings(pNew, pExpr);
                pNew.x.pList = pList;
                idxNew = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0002 | 0x0001)));
                exprAnalyze(pSrc, pWC, (int)(idxNew));
                markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
            }
            else
            {
                sqlite3ExprListDelete(db, pList);
            }
        }
    }
}</function>
  <function>public static void exprCodeBetween(Parse pParse, Expr pExpr, int dest, delegate175 xJump, int jumpIfNull)
{
    Expr exprAnd = new Expr();
    Expr compLeft = new Expr();
    Expr compRight = new Expr();
    int regFree1 = (int)(0);
    Expr pDel = null;
    sqlite3 db = pParse.db;
    CRuntime.memset(compLeft, (int)(0), (ulong)(sizeof(Expr)));
    CRuntime.memset(compRight, (int)(0), (ulong)(sizeof(Expr)));
    CRuntime.memset(exprAnd, (int)(0), (ulong)(sizeof(Expr)));
    pDel = sqlite3ExprDup(db, pExpr.pLeft, (int)(0));
    if ((db.mallocFailed) == (0))
    {
        exprAnd.op = (byte)(44);
        exprAnd.pLeft = compLeft;
        exprAnd.pRight = compRight;
        compLeft.op = (byte)(57);
        compLeft.pLeft = pDel;
        compLeft.pRight = pExpr.x.pList.a[0].pExpr;
        compRight.op = (byte)(55);
        compRight.pLeft = pDel;
        compRight.pRight = pExpr.x.pList.a[1].pExpr;
        exprToRegister(pDel, (int)(exprCodeVector(pParse, pDel, &amp;regFree1)));
        if ((xJump) != null)
        {
            xJump(pParse, exprAnd, (int)(dest), (int)(jumpIfNull));
        }
        else
        {
            pDel.flags |= (uint)(0x000001);
            sqlite3ExprCodeTarget(pParse, exprAnd, (int)(dest));
        }

        sqlite3ReleaseTempReg(pParse, (int)(regFree1));
    }

    sqlite3ExprDelete(db, pDel);
}</function>
  <function>public static int exprCodeInlineFunction(Parse pParse, ExprList pFarg, int iFuncId, int target)
{
    int nFarg = 0;
    Vdbe v = pParse.pVdbe;
    nFarg = (int)(pFarg.nExpr);
    switch (iFuncId)
    {
        case 0:
        {
            int endCoalesce = (int)(sqlite3VdbeMakeLabel(pParse));
            int i = 0;
            sqlite3ExprCode(pParse, pFarg.a[0].pExpr, (int)(target));
            for (i = (int)(1); (i) &lt; (nFarg); i++)
            {
                sqlite3VdbeAddOp2(v, (int)(51), (int)(target), (int)(endCoalesce));
                sqlite3ExprCode(pParse, pFarg.a[i].pExpr, (int)(target));
            }

            setDoNotMergeFlagOnCopy(v);
            sqlite3VdbeResolveLabel(v, (int)(endCoalesce));
            break;
        }

        case 5:
        {
            Expr caseExpr = new Expr();
            CRuntime.memset(caseExpr, (int)(0), (ulong)(sizeof(Expr)));
            caseExpr.op = (byte)(157);
            caseExpr.x.pList = pFarg;
            return (int)(sqlite3ExprCodeTarget(pParse, caseExpr, (int)(target)));
        }

        default:
        {
            target = (int)(sqlite3ExprCodeTarget(pParse, pFarg.a[0].pExpr, (int)(target)));
            break;
        }

        case 3:
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprCompare(null, pFarg.a[0].pExpr, pFarg.a[1].pExpr, (int)(-1))), (int)(target));
            break;
        }

        case 2:
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprImpliesExpr(pParse, pFarg.a[0].pExpr, pFarg.a[1].pExpr, (int)(-1))), (int)(target));
            break;
        }

        case 1:
        {
            Expr pA1;
            pA1 = pFarg.a[1].pExpr;
            if ((pA1.op) == (167))
            {
                sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprImpliesNonNullRow(pFarg.a[0].pExpr, (int)(pA1.iTable))), (int)(target));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
            }

            break;
        }

        case 4:
        {
            sbyte** azAff = stackalloc sbyte*[]{"blob", "text", "numeric", "integer", "real"};
            sbyte aff = 0;
            aff = (sbyte)(sqlite3ExprAffinity(pFarg.a[0].pExpr));
            sqlite3VdbeLoadString(v, (int)(target), ((aff) &lt;= (0x40)) ? "none" : azAff[aff - 0x41]);
            break;
        }
    }

    return (int)(target);
}</function>
  <function>public static int exprCodeSubselect(Parse pParse, Expr pExpr)
{
    int reg = (int)(0);
    if ((pExpr.op) == (138))
    {
        reg = (int)(sqlite3CodeSubselect(pParse, pExpr));
    }

    return (int)(reg);
}</function>
  <function>public static int exprCodeVector(Parse pParse, Expr p, int* piFreeable)
{
    int iResult = 0;
    int nResult = (int)(sqlite3ExprVectorSize(p));
    if ((nResult) == (1))
    {
        iResult = (int)(sqlite3ExprCodeTemp(pParse, p, piFreeable));
    }
    else
    {
        *piFreeable = (int)(0);
        if ((p.op) == (138))
        {
            iResult = (int)(sqlite3CodeSubselect(pParse, p));
        }
        else
        {
            int i = 0;
            iResult = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(nResult);
            for (i = (int)(0); (i) &lt; (nResult); i++)
            {
                sqlite3ExprCodeFactorable(pParse, p.x.pList.a[i].pExpr, (int)(i + iResult));
            }
        }
    }

    return (int)(iResult);
}</function>
  <function>public static int exprColumnFlagUnion(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (167)) &amp;&amp; ((pExpr.iColumn) &gt;= (0)))
    {
        pWalker.eCode |= (ushort)(pWalker.u.pTab.aCol[pExpr.iColumn].colFlags);
    }

    return (int)(0);
}</function>
  <function>public static ushort exprCommute(Parse pParse, Expr pExpr)
{
    if ((((pExpr.pLeft.op) == (177)) || ((pExpr.pRight.op) == (177))) || (sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pExpr.pRight) != sqlite3BinaryCompareCollSeq(pParse, pExpr.pRight, pExpr.pLeft)))
    {
        pExpr.flags ^= (uint)(0x000200);
    }

    {
        Expr t = pExpr.pRight;
        pExpr.pRight = pExpr.pLeft;
        pExpr.pLeft = t;
    }

    if ((pExpr.op) &gt;= (54))
    {
        pExpr.op = (byte)(((pExpr.op - 54) ^ 2) + 54);
    }

    return (ushort)(0);
}</function>
  <function>public static int exprCompareVariable(Parse pParse, Expr pVar, Expr pExpr)
{
    int res = (int)(0);
    int iVar = 0;
    sqlite3_value pL; sqlite3_value  pR  =  null ; 
    sqlite3ValueFromExpr(pParse.db, pExpr, (byte)(1), (byte)(0x41), pR);
    if ((pR) != null)
    {
        iVar = (int)(pVar.iColumn);
        sqlite3VdbeSetVarmask(pParse.pVdbe, (int)(iVar));
        pL = sqlite3VdbeGetBoundValue(pParse.pReprepare, (int)(iVar), (byte)(0x41));
        if ((pL) != null)
        {
            if ((sqlite3_value_type(pL)) == (3))
            {
                sqlite3_value_text(pL);
            }

            res = (int)((0) == (sqlite3MemCompare(pL, pR, null)) ? 1 : 0);
        }

        sqlite3ValueFree(pR);
        sqlite3ValueFree(pL);
    }

    return (int)(res);
}</function>
  <function>public static Expr exprDup(sqlite3 db, Expr p, int dupFlags, byte** pzBuffer)
{
    Expr pNew;
    byte* zAlloc;
    uint staticFlag = 0;
    if ((pzBuffer) != null)
    {
        zAlloc = *pzBuffer;
        staticFlag = (uint)(0x8000000);
    }
    else
    {
        zAlloc = sqlite3DbMallocRawNN(db, (ulong)(dupedExprSize(p, (int)(dupFlags))));
        staticFlag = (uint)(0);
    }

    pNew = (Expr)(zAlloc);
    if ((pNew) != null)
    {
        uint nStructSize = (uint)(dupedExprStructSize(p, (int)(dupFlags)));
        int nNewSize = (int)(nStructSize &amp; 0xfff);
        int nToken = 0;
        if ((!(((p).flags &amp; (0x000400)) != 0)) &amp;&amp; ((p.u.zToken) != null))
        {
            nToken = (int)(sqlite3Strlen30(p.u.zToken) + 1);
        }
        else
        {
            nToken = (int)(0);
        }

        if ((dupFlags) != 0)
        {
            CRuntime.memcpy(zAlloc, p, (ulong)(nNewSize));
        }
        else
        {
            uint nSize = (uint)(exprStructSize(p));
            CRuntime.memcpy(zAlloc, p, (ulong)(nSize));
            if ((nSize) &lt; (sizeof(Expr)))
            {
                CRuntime.memset(&amp;zAlloc[nSize], (int)(0), (ulong)(sizeof(Expr) - nSize));
            }
        }

        pNew.flags &amp;= (uint)(~(0x002000 | 0x004000 | 0x8000000 | 0x010000));
        pNew.flags |= (uint)(nStructSize &amp; (0x002000 | 0x004000));
        pNew.flags |= (uint)(staticFlag);
        if ((dupFlags) != 0)
        {
        }

        if ((nToken) != 0)
        {
            sbyte* zToken = pNew.u.zToken = (sbyte*)(&amp;zAlloc[nNewSize]);
            CRuntime.memcpy(zToken, p.u.zToken, (ulong)(nToken));
        }

        if ((0) == ((p.flags | pNew.flags) &amp; (0x004000 | 0x800000)))
        {
            if ((((p).flags &amp; 0x000800) != 0))
            {
                pNew.x.pSelect = sqlite3SelectDup(db, p.x.pSelect, (int)(dupFlags));
            }
            else
            {
                pNew.x.pList = sqlite3ExprListDup(db, p.x.pList, (int)(dupFlags));
            }
        }

        if ((((pNew).flags &amp; (0x002000 | 0x004000 | 0x1000000)) != 0))
        {
            zAlloc += dupedExprNodeSize(p, (int)(dupFlags));
            if (!(((pNew).flags &amp; (0x004000 | 0x800000)) != 0))
            {
                pNew.pLeft = p.pLeft ? exprDup(db, p.pLeft, (int)(0x0001), &amp;zAlloc) : null;
                pNew.pRight = p.pRight ? exprDup(db, p.pRight, (int)(0x0001), &amp;zAlloc) : null;
            }

            if ((((p).flags &amp; (0x1000000)) != 0))
            {
                pNew.y.pWin = sqlite3WindowDup(db, pNew, p.y.pWin);
            }

            if ((pzBuffer) != null)
            {
                *pzBuffer = zAlloc;
            }
        }
        else
        {
            if (!(((p).flags &amp; (0x004000 | 0x800000)) != 0))
            {
                if ((pNew.op) == (178))
                {
                    pNew.pLeft = p.pLeft;
                }
                else
                {
                    pNew.pLeft = sqlite3ExprDup(db, p.pLeft, (int)(0));
                }

                pNew.pRight = sqlite3ExprDup(db, p.pRight, (int)(0));
            }
        }
    }

    return pNew;
}</function>
  <function>public static int exprIdxCover(Walker pWalker, Expr pExpr)
{
    if ((((pExpr.op) == (167)) &amp;&amp; ((pExpr.iTable) == (pWalker.u.pIdxCover.iCur))) &amp;&amp; ((sqlite3TableColumnToIndex(pWalker.u.pIdxCover.pIdx, (short)(pExpr.iColumn))) &lt; (0)))
    {
        pWalker.eCode = (ushort)(1);
        return (int)(2);
    }

    return (int)(0);
}</function>
  <function>public static int exprImpliesNotNull(Parse pParse, Expr p, Expr pNN, int iTab, int seenNot)
{
    if ((sqlite3ExprCompare(pParse, p, pNN, (int)(iTab))) == (0))
    {
        return (int)(pNN.op != 121);
    }

    switch (p.op)
    {
        case 49:
        {
            if (((seenNot) != 0) &amp;&amp; (((p).flags &amp; (0x000800)) != 0))
                return (int)(0);
            return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
        }

        case 48:
        {
            ExprList pList;
            pList = p.x.pList;
            if ((seenNot) != 0)
                return (int)(0);
            if (((exprImpliesNotNull(pParse, pList.a[0].pExpr, pNN, (int)(iTab), (int)(1))) != 0) || ((exprImpliesNotNull(pParse, pList.a[1].pExpr, pNN, (int)(iTab), (int)(1))) != 0))
            {
                return (int)(1);
            }

            return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
        }

        case 53:
        case 52:
        case 56:
        case 55:
        case 54:
        case 57:
        case 106:
        case 107:
        case 103:
        case 104:
        case 105:
        case 111:
            seenNot = (int)(1);
        case 108:
        case 110:
        case 102:
        case 109:
        {
            if ((exprImpliesNotNull(pParse, p.pRight, pNN, (int)(iTab), (int)(seenNot))) != 0)
                return (int)(1);
        }

        case 181:
        case 113:
        case 174:
        case 173:
        {
            return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(seenNot)));
        }

        case 175:
        {
            if ((seenNot) != 0)
                return (int)(0);
            if (p.op2 != 45)
                return (int)(0);
            return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
        }

        case 114:
        case 19:
        {
            return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
        }
    }

    return (int)(0);
}</function>
  <function>public static sbyte* exprINAffinity(Parse pParse, Expr pExpr)
{
    Expr pLeft = pExpr.pLeft;
    int nVal = (int)(sqlite3ExprVectorSize(pLeft));
    Select pSelect = (((pExpr).flags &amp; 0x000800) != 0) ? pExpr.x.pSelect : null;
    sbyte* zRet;
    zRet = sqlite3DbMallocRaw(pParse.db, (ulong)(nVal + 1));
    if ((zRet) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (nVal); i++)
        {
            Expr pA = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
            sbyte a = (sbyte)(sqlite3ExprAffinity(pA));
            if ((pSelect) != null)
            {
                zRet[i] = (sbyte)(sqlite3CompareAffinity(pSelect.pEList.a[i].pExpr, (sbyte)(a)));
            }
            else
            {
                zRet[i] = (sbyte)(a);
            }
        }

        zRet[nVal] = (sbyte)(0);
    }

    return zRet;
}</function>
  <function>public static int exprIsConst(Expr p, int initFlag, int iCur)
{
    Walker w = new Walker();
    w.eCode = (ushort)(initFlag);
    w.xExprCallback = exprNodeIsConstant;
    w.xSelectCallback = sqlite3SelectWalkFail;
    w.u.iCur = (int)(iCur);
    sqlite3WalkExpr(w, p);
    return (int)(w.eCode);
}</function>
  <function>public static int exprIsDeterministic(Expr p)
{
    Walker w = new Walker();
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    w.eCode = (ushort)(1);
    w.xExprCallback = exprNodeIsDeterministic;
    w.xSelectCallback = sqlite3SelectWalkFail;
    sqlite3WalkExpr(w, p);
    return (int)(w.eCode);
}</function>
  <function>public static ExprList exprListAppendList(Parse pParse, ExprList pList, ExprList pAppend, int bIntToNull)
{
    if ((pAppend) != null)
    {
        int i = 0;
        int nInit = (int)(pList ? pList.nExpr : 0);
        for (i = (int)(0); (i) &lt; (pAppend.nExpr); i++)
        {
            sqlite3 db = pParse.db;
            Expr pDup = sqlite3ExprDup(db, pAppend.a[i].pExpr, (int)(0));
            if ((db.mallocFailed) != 0)
            {
                sqlite3ExprDelete(db, pDup);
                break;
            }

            if ((bIntToNull) != 0)
            {
                int iDummy = 0;
                Expr pSub;
                pSub = sqlite3ExprSkipCollateAndLikely(pDup);
                if ((sqlite3ExprIsInteger(pSub, &amp;iDummy)) != 0)
                {
                    pSub.op = (byte)(121);
                    pSub.flags &amp;= (uint)(~(0x000400 | 0x10000000 | 0x20000000));
                    pSub.u.zToken = null;
                }
            }

            pList = sqlite3ExprListAppend(pParse, pList, pDup);
            if ((pList) != null)
                pList.a[nInit + i].sortFlags = (byte)(pAppend.a[i].sortFlags);
        }
    }

    return pList;
}</function>
  <function>public static void exprListDeleteNN(sqlite3 db, ExprList pList)
{
    int i = (int)(pList.nExpr);
    ExprList_item* pItem = pList.a;
    do
    {
        sqlite3ExprDelete(db, pItem-&gt;pExpr);
        sqlite3DbFree(db, pItem-&gt;zEName);
        pItem++;
    }
    while ((--i) &gt; (0));
    sqlite3DbFreeNN(db, pList);
}</function>
  <function>public static int exprMightBeIndexed(SrcList pFrom, ulong mPrereq, int* aiCurCol, Expr pExpr, int op)
{
    if (((pExpr.op) == (177)) &amp;&amp; (((op) &gt;= (54)) &amp;&amp; ((op) &lt;= (57))))
    {
        pExpr = pExpr.x.pList.a[0].pExpr;
    }

    if ((pExpr.op) == (167))
    {
        aiCurCol[0] = (int)(pExpr.iTable);
        aiCurCol[1] = (int)(pExpr.iColumn);
        return (int)(1);
    }

    if ((mPrereq) == (0))
        return (int)(0);
    if ((mPrereq &amp; (mPrereq - 1)) != 0)
        return (int)(0);
    return (int)(exprMightBeIndexed2(pFrom, (ulong)(mPrereq), aiCurCol, pExpr));
}</function>
  <function>public static int exprMightBeIndexed2(SrcList pFrom, ulong mPrereq, int* aiCurCol, Expr pExpr)
{
    Index pIdx;
    int i = 0;
    int iCur = 0;
    for (i = (int)(0); (mPrereq) &gt; (1); i++, mPrereq &gt;&gt;= 1)
    {
    }

    iCur = (int)(pFrom.a[i].iCursor);
    for (pIdx = pFrom.a[i].pTab.pIndex; pIdx; pIdx = pIdx.pNext)
    {
        if ((pIdx.aColExpr) == (null))
            continue;
        for (i = (int)(0); (i) &lt; (pIdx.nKeyCol); i++)
        {
            if (pIdx.aiColumn[i] != (-2))
                continue;
            if ((sqlite3ExprCompareSkip(pExpr, pIdx.aColExpr.a[i].pExpr, (int)(iCur))) == (0))
            {
                aiCurCol[0] = (int)(iCur);
                aiCurCol[1] = (int)(-2);
                return (int)(1);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int exprNodeIsConstant(Walker pWalker, Expr pExpr)
{
    if (((pWalker.eCode) == (2)) &amp;&amp; (((pExpr).flags &amp; (0x000001)) != 0))
    {
        pWalker.eCode = (ushort)(0);
        return (int)(2);
    }

    switch (pExpr.op)
    {
        case 172:
            if ((((pWalker.eCode) &gt;= (4)) || (((pExpr).flags &amp; (0x080000)) != 0)) &amp;&amp; (!(((pExpr).flags &amp; (0x1000000)) != 0)))
            {
                if ((pWalker.eCode) == (5))
                    (pExpr).flags |= (uint)(0x40000000);
                return (int)(0);
            }
            else
            {
                pWalker.eCode = (ushort)(0);
                return (int)(2);
            }

        case 59:
            if ((sqlite3ExprIdToTrueFalse(pExpr)) != 0)
            {
                return (int)(1);
            }

        case 167:
        case 168:
        case 169:
            ;
            if ((((pExpr).flags &amp; (0x000008)) != 0) &amp;&amp; (pWalker.eCode != 2))
            {
                return (int)(0);
            }

            if (((pWalker.eCode) == (3)) &amp;&amp; ((pExpr.iTable) == (pWalker.u.iCur)))
            {
                return (int)(0);
            }

        case 179:
        case 176:
        case 141:
            ;
            pWalker.eCode = (ushort)(0);
            return (int)(2);
        case 156:
            if ((pWalker.eCode) == (5))
            {
                pExpr.op = (byte)(121);
            }
            else if ((pWalker.eCode) == (4))
            {
                pWalker.eCode = (ushort)(0);
                return (int)(2);
            }

        default:
            ;
            return (int)(0);
    }
}</function>
  <function>public static int exprNodeIsConstantOrGroupBy(Walker pWalker, Expr pExpr)
{
    ExprList pGroupBy = pWalker.u.pGroupBy;
    int i = 0;
    for (i = (int)(0); (i) &lt; (pGroupBy.nExpr); i++)
    {
        Expr p = pGroupBy.a[i].pExpr;
        if ((sqlite3ExprCompare(null, pExpr, p, (int)(-1))) &lt; (2))
        {
            CollSeq pColl = sqlite3ExprNNCollSeq(pWalker.pParse, p);
            if ((sqlite3IsBinary(pColl)) != 0)
            {
                return (int)(1);
            }
        }
    }

    if ((((pExpr).flags &amp; 0x000800) != 0))
    {
        pWalker.eCode = (ushort)(0);
        return (int)(2);
    }

    return (int)(exprNodeIsConstant(pWalker, pExpr));
}</function>
  <function>public static int exprNodeIsDeterministic(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (172)) &amp;&amp; ((((pExpr).flags &amp; (0x080000)) != 0) == (0)))
    {
        pWalker.eCode = (ushort)(0);
        return (int)(2);
    }

    return (int)(0);
}</function>
  <function>public static int exprProbability(Expr p)
{
    double r = (double)(-1.0);
    if (p.op != 153)
        return (int)(-1);
    sqlite3AtoF(p.u.zToken, &amp;r, (int)(sqlite3Strlen30(p.u.zToken)), (byte)(1));
    if ((r) &gt; (1.0))
        return (int)(-1);
    return (int)(r * 134217728.0);
}</function>
  <function>public static int exprRefToSrcList(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (167)) || ((pExpr.op) == (169)))
    {
        int i = 0;
        RefSrcList p = pWalker.u.pRefSrcList;
        SrcList pSrc = p.pRef;
        int nSrc = (int)(pSrc ? pSrc.nSrc : 0);
        for (i = (int)(0); (i) &lt; (nSrc); i++)
        {
            if ((pExpr.iTable) == (pSrc.a[i].iCursor))
            {
                pWalker.eCode |= (ushort)(1);
                return (int)(0);
            }
        }

        for (i = (int)(0); ((i) &lt; (p.nExclude)) &amp;&amp; (p.aiExclude[i] != pExpr.iTable); i++)
        {
        }

        if ((i) &gt;= (p.nExclude))
        {
            pWalker.eCode |= (ushort)(2);
        }
    }

    return (int)(0);
}</function>
  <function>public static Expr exprRowColumn(Parse pParse, int iCol)
{
    Expr pRet = sqlite3PExpr(pParse, (int)(75), null, null);
    if ((pRet) != null)
        pRet.iColumn = (short)(iCol + 1);
    return pRet;
}</function>
  <function>public static ulong exprSelectUsage(WhereMaskSet* pMaskSet, Select pS)
{
    ulong mask = (ulong)(0);
    while ((pS) != null)
    {
        SrcList pSrc = pS.pSrc;
        mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pS.pEList));
        mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pS.pGroupBy));
        mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pS.pOrderBy));
        mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pS.pWhere));
        mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pS.pHaving));
        if ((pSrc != null))
        {
            int i = 0;
            for (i = (int)(0); (i) &lt; (pSrc.nSrc); i++)
            {
                mask |= (ulong)(exprSelectUsage(pMaskSet, pSrc.a[i].pSelect));
                mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pSrc.a[i].pOn));
                if ((pSrc.a[i].fg.isTabFunc) != 0)
                {
                    mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pSrc.a[i].u1.pFuncArg));
                }
            }
        }

        pS = pS.pPrior;
    }

    return (ulong)(mask);
}</function>
  <function>public static void exprSetHeight(Expr p)
{
    int nHeight = (int)(p.pLeft ? p.pLeft.nHeight : 0);
    if (((p.pRight) != null) &amp;&amp; ((p.pRight.nHeight) &gt; (nHeight)))
        nHeight = (int)(p.pRight.nHeight);
    if ((((p).flags &amp; 0x000800) != 0))
    {
        heightOfSelect(p.x.pSelect, &amp;nHeight);
    }
    else if ((p.x.pList) != null)
    {
        heightOfExprList(p.x.pList, &amp;nHeight);
        p.flags |= (uint)((0x000100 | 0x200000 | 0x000004) &amp; sqlite3ExprListFlags(p.x.pList));
    }

    p.nHeight = (int)(nHeight + 1);
}</function>
  <function>public static int exprStructSize(Expr p)
{
    if ((((p).flags &amp; (0x004000)) != 0))
        return (int)((ulong)((0).pLeft));
    if ((((p).flags &amp; (0x002000)) != 0))
        return (int)((ulong)(&amp;((0).iTable)));
    return (int)(sizeof(Expr));
}</function>
  <function>public static Expr exprTableColumn(sqlite3 db, Table pTab, int iCursor, short iCol)
{
    Expr pExpr = sqlite3Expr(db, (int)(167), null);
    if ((pExpr) != null)
    {
        pExpr.y.pTab = pTab;
        pExpr.iTable = (int)(iCursor);
        pExpr.iColumn = (short)(iCol);
    }

    return pExpr;
}</function>
  <function>public static Expr exprTableRegister(Parse pParse, Table pTab, int regBase, short iCol)
{
    Expr pExpr;
    Column* pCol;
    sbyte* zColl;
    sqlite3 db = pParse.db;
    pExpr = sqlite3Expr(db, (int)(176), null);
    if ((pExpr) != null)
    {
        if (((iCol) &gt;= (0)) &amp;&amp; (iCol != pTab.iPKey))
        {
            pCol = &amp;pTab.aCol[iCol];
            pExpr.iTable = (int)(regBase + sqlite3TableColumnToStorage(pTab, (short)(iCol)) + 1);
            pExpr.affExpr = (sbyte)(pCol-&gt;affinity);
            zColl = sqlite3ColumnColl(pCol);
            if ((zColl) == (null))
                zColl = db.pDfltColl.zName;
            pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
        }
        else
        {
            pExpr.iTable = (int)(regBase);
            pExpr.affExpr = (sbyte)(0x44);
        }
    }

    return pExpr;
}</function>
  <function>public static void exprToRegister(Expr pExpr, int iReg)
{
    Expr p = sqlite3ExprSkipCollateAndLikely(pExpr);
    if (((p) == (null)))
        return;
    p.op2 = (byte)(p.op);
    p.op = (byte)(176);
    p.iTable = (int)(iReg);
    (p).flags &amp;= (uint)(~(0x001000));
}</function>
  <function>public static int exprVectorRegister(Parse pParse, Expr pVector, int iField, int regSelect, Expr ppExpr, int* pRegFree)
{
    byte op = (byte)(pVector.op);
    if ((op) == (176))
    {
        ppExpr = sqlite3VectorFieldSubexpr(pVector, (int)(iField));
        return (int)(pVector.iTable + iField);
    }

    if ((op) == (138))
    {
        ppExpr = pVector.x.pSelect.pEList.a[iField].pExpr;
        return (int)(regSelect + iField);
    }

    if ((op) == (177))
    {
        ppExpr = pVector.x.pList.a[iField].pExpr;
        return (int)(sqlite3ExprCodeTemp(pParse, ppExpr, pRegFree));
    }

    return (int)(0);
}</function>
  <function>public static void* fetchPayload(BtCursor pCur, uint* pAmt)
{
    int amt = 0;
    amt = (int)(pCur.info.nLocal);
    if ((amt) &gt; ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)))
    {
        amt = (int)((0) &gt; ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)) ? (0) : ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)));
    }

    *pAmt = ((uint)(amt));
    return (void*)(pCur.info.pPayload);
}</function>
  <function>public static int fillInCell(MemPage pPage, byte* pCell, BtreePayload pX, int* pnSize)
{
    int nPayload = 0;
    byte* pSrc;
    int nSrc = 0; int  n  =  0 ;  int  rc  =  0 ;  int  mn  =  0 ; 
    int spaceLeft = 0;
    MemPage pToRelease;
    byte* pPrior;
    byte* pPayload;
    BtShared pBt;
    uint pgnoOvfl = 0;
    int nHeader = 0;
    nHeader = (int)(pPage.childPtrSize);
    if ((pPage.intKey) != 0)
    {
        nPayload = (int)(pX.nData + pX.nZero);
        pSrc = pX.pData;
        nSrc = (int)(pX.nData);
        nHeader += (int)((byte)((((uint)(nPayload)) &lt; ((uint)(0x80))) ? (*(&amp;pCell[nHeader]) = ((byte)(nPayload))), 1 : 
        sqlite3PutVarint((&amp;pCell[nHeader]), (ulong)(nPayload)) ) )
        ;
        nHeader += (int)(sqlite3PutVarint(&amp;pCell[nHeader], (ulong)(*(ulong*)(&amp;pX.nKey))));
    }
    else
    {
        nSrc = (int)(nPayload = ((int)(pX.nKey)));
        pSrc = pX.pKey;
        nHeader += (int)((byte)((((uint)(nPayload)) &lt; ((uint)(0x80))) ? (*(&amp;pCell[nHeader]) = ((byte)(nPayload))), 1 : 
        sqlite3PutVarint((&amp;pCell[nHeader]), (ulong)(nPayload)) ) )
        ;
    }

    pPayload = &amp;pCell[nHeader];
    if ((nPayload) &lt;= (pPage.maxLocal))
    {
        n = (int)(nHeader + nPayload);
        if ((n) &lt; (4))
            n = (int)(4);
        *pnSize = (int)(n);
        CRuntime.memcpy(pPayload, pSrc, (ulong)(nSrc));
        CRuntime.memset(pPayload + nSrc, (int)(0), (ulong)(nPayload - nSrc));
        return (int)(0);
    }

    mn = (int)(pPage.minLocal);
    n = (int)(mn + (nPayload - mn) % (pPage.pBt.usableSize - 4));
    if ((n) &gt; (pPage.maxLocal))
        n = (int)(mn);
    spaceLeft = (int)(n);
    *pnSize = (int)(n + nHeader + 4);
    pPrior = &amp;pCell[nHeader + n];
    pToRelease = null;
    pgnoOvfl = (uint)(0);
    pBt = pPage.pBt;
    while ((1) != 0)
    {
        n = (int)(nPayload);
        if ((n) &gt; (spaceLeft))
            n = (int)(spaceLeft);
        if ((nSrc) &gt;= (n))
        {
            CRuntime.memcpy(pPayload, pSrc, (ulong)(n));
        }
        else if ((nSrc) &gt; (0))
        {
            n = (int)(nSrc);
            CRuntime.memcpy(pPayload, pSrc, (ulong)(n));
        }
        else
        {
            CRuntime.memset(pPayload, (int)(0), (ulong)(n));
        }

        nPayload -= (int)(n);
        if ((nPayload) &lt;= (0))
            break;
        pPayload += n;
        pSrc += n;
        nSrc -= (int)(n);
        spaceLeft -= (int)(n);
        if ((spaceLeft) == (0))
        {
            MemPage pOvfl = null;
            uint pgnoPtrmap = (uint)(pgnoOvfl);
            if ((pBt.autoVacuum) != 0)
            {
                do
                {
                    pgnoOvfl++;
                }
                while (((ptrmapPageno((pBt), (uint)(pgnoOvfl))) == (pgnoOvfl)) || ((pgnoOvfl) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)));
            }

            rc = (int)(allocateBtreePage(pBt, pOvfl, &amp;pgnoOvfl, (uint)(pgnoOvfl), (byte)(0)));
            if (((pBt.autoVacuum) != 0) &amp;&amp; ((rc) == (0)))
            {
                byte eType = (byte)((pgnoPtrmap) != 0 ? 4 : 3);
                ptrmapPut(pBt, (uint)(pgnoOvfl), (byte)(eType), (uint)(pgnoPtrmap), &amp;rc);
                if ((rc) != 0)
                {
                    releasePage(pOvfl);
                }
            }

            if ((rc) != 0)
            {
                releasePage(pToRelease);
                return (int)(rc);
            }

            sqlite3Put4byte(pPrior, (uint)(pgnoOvfl));
            releasePage(pToRelease);
            pToRelease = pOvfl;
            pPrior = pOvfl.aData;
            sqlite3Put4byte(pPrior, (uint)(0));
            pPayload = &amp;pOvfl.aData[4];
            spaceLeft = (int)(pBt.usableSize - 4);
        }
    }

    releasePage(pToRelease);
    return (int)(0);
}</function>
  <function>public static ulong filterHash(sqlite3_value aMem, VdbeOp* pOp)
{
    int i = 0; int  mx  =  0 ; 
    ulong h = (ulong)(0);
    for (i = (int)(pOp-&gt;p3), mx = (int)(i + pOp-&gt;p4.i); (i) &lt; (mx); i++)
    {
        sqlite3_value p = aMem[i];
        if ((p.flags &amp; (0x0004 | 0x0020)) != 0)
        {
            h += (ulong)(p.u.i);
        }
        else if ((p.flags &amp; 0x0008) != 0)
        {
            h += (ulong)(sqlite3VdbeIntValue(p));
        }
        else if ((p.flags &amp; (0x0002 | 0x0010)) != 0)
        {
            h += (ulong)(p.n);
            if ((p.flags &amp; 0x4000) != 0)
                h += (ulong)(p.u.nZero);
        }
    }

    return (ulong)(h);
}</function>
  <function>public static void filterPullDown(Parse pParse, WhereInfo pWInfo, int iLevel, int addrNxt, ulong notReady)
{
    while ((++iLevel) &lt; (pWInfo.nLevel))
    {
        WhereLevel pLevel = pWInfo.a[iLevel];
        WhereLoop pLoop = pLevel.pWLoop;
        if ((pLevel.regFilter) == (0))
            continue;
        if ((pLevel.pWLoop.nSkip) != 0)
            continue;
        if ((pLoop.prereq &amp; notReady) != 0)
            continue;
        if ((pLoop.wsFlags &amp; 0x00000100) != 0)
        {
            WhereTerm pTerm = pLoop.aLTerm[0];
            int regRowid = 0;
            regRowid = (int)(sqlite3GetTempReg(pParse));
            regRowid = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(0), (int)(0), (int)(regRowid)));
            sqlite3VdbeAddOp4Int(pParse.pVdbe, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(regRowid), (int)(1));
        }
        else
        {
            ushort nEq = (ushort)(pLoop.u.btree.nEq);
            int r1 = 0;
            sbyte* zStartAff;
            r1 = (int)(codeAllEqualityTerms(pParse, pLevel, (int)(0), (int)(0), &amp;zStartAff));
            codeApplyAffinity(pParse, (int)(r1), (int)(nEq), zStartAff);
            sqlite3DbFree(pParse.db, zStartAff);
            sqlite3VdbeAddOp4Int(pParse.pVdbe, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(r1), (int)(nEq));
        }

        pLevel.regFilter = (int)(0);
    }
}</function>
  <function>public static uint finalDbSize(BtShared pBt, uint nOrig, uint nFree)
{
    int nEntry = 0;
    uint nPtrmap = 0;
    uint nFin = 0;
    nEntry = (int)(pBt.usableSize / 5);
    nPtrmap = (uint)((nFree - nOrig + ptrmapPageno(pBt, (uint)(nOrig)) + nEntry) / nEntry);
    nFin = (uint)(nOrig - nFree - nPtrmap);
    if (((nOrig) &gt; ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) &amp;&amp; ((nFin) &lt; ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
    {
        nFin--;
    }

    while (((ptrmapPageno((pBt), (uint)(nFin))) == (nFin)) || ((nFin) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
    {
        nFin--;
    }

    return (uint)(nFin);
}</function>
  <function>public static void finalizeAggFunctions(Parse pParse, AggInfo pAggInfo)
{
    Vdbe v = pParse.pVdbe;
    int i = 0;
    AggInfo_func pF;
    for (i = (int)(0), pF = pAggInfo.aFunc; (i) &lt; (pAggInfo.nFunc); i++, pF++)
    {
        ExprList pList;
        pList = pF.pFExpr.x.pList;
        sqlite3VdbeAddOp2(v, (int)(164), (int)(pF.iMem), (int)(pList ? pList.nExpr : 0));
        sqlite3VdbeAppendP4(v, pF.pFunc, (int)(-8));
    }
}</function>
  <function>public static Btree findBtree(sqlite3 pErrorDb, sqlite3 pDb, sbyte* zDb)
{
    int i = (int)(sqlite3FindDbName(pDb, zDb));
    if ((i) == (1))
    {
        Parse sParse = new Parse();
        int rc = (int)(0);
        sqlite3ParseObjectInit(sParse, pDb);
        if ((sqlite3OpenTempDatabase(sParse)) != 0)
        {
            sqlite3ErrorWithMsg(pErrorDb, (int)(sParse.rc), "%s", sParse.zErrMsg);
            rc = (int)(1);
        }

        sqlite3DbFree(pErrorDb, sParse.zErrMsg);
        sqlite3ParseObjectReset(sParse);
        if ((rc) != 0)
        {
            return null;
        }
    }

    if ((i) &lt; (0))
    {
        sqlite3ErrorWithMsg(pErrorDb, (int)(1), "unknown database %s", zDb);
        return null;
    }

    return pDb.aDb[i].pBt;
}</function>
  <function>public static CollSeq findCollSeqEntry(sqlite3 db, sbyte* zName, int create)
{
    CollSeq pColl;
    pColl = sqlite3HashFind(&amp;db.aCollSeq, zName);
    if (((null) == (pColl)) &amp;&amp; ((create) != 0))
    {
        int nName = (int)(sqlite3Strlen30(zName) + 1);
        pColl = sqlite3DbMallocZero(db, (ulong)(3 * sizeof(CollSeq) + nName));
        if ((pColl) != null)
        {
            CollSeq pDel = null;
            pColl[0].zName = (sbyte*)(pColl[3]);
            pColl[0].enc = (byte)(1);
            pColl[1].zName = (sbyte*)(pColl[3]);
            pColl[1].enc = (byte)(2);
            pColl[2].zName = (sbyte*)(pColl[3]);
            pColl[2].enc = (byte)(3);
            CRuntime.memcpy(pColl[0].zName, zName, (ulong)(nName));
            pDel = sqlite3HashInsert(&amp;db.aCollSeq, pColl[0].zName, pColl);
            if (pDel != null)
            {
                sqlite3OomFault(db);
                sqlite3DbFree(db, pDel);
                pColl = null;
            }
        }
    }

    return pColl;
}</function>
  <function>public static void findConstInWhere(WhereConst pConst, Expr pExpr)
{
    Expr pRight; Expr  pLeft ; 
    if (((pExpr) == (null)))
        return;
    if ((((pExpr).flags &amp; (0x000001)) != 0))
        return;
    if ((pExpr.op) == (44))
    {
        findConstInWhere(pConst, pExpr.pRight);
        findConstInWhere(pConst, pExpr.pLeft);
        return;
    }

    if (pExpr.op != 53)
        return;
    pRight = pExpr.pRight;
    pLeft = pExpr.pLeft;
    if (((pRight.op) == (167)) &amp;&amp; ((sqlite3ExprIsConstant(pLeft)) != 0))
    {
        constInsert(pConst, pRight, pLeft, pExpr);
    }

    if (((pLeft.op) == (167)) &amp;&amp; ((sqlite3ExprIsConstant(pRight)) != 0))
    {
        constInsert(pConst, pLeft, pRight, pExpr);
    }
}</function>
  <function>public static HashElem* findElementWithHash(Hash* pH, sbyte* pKey, uint* pHash)
{
    HashElem* elem;
    uint count = 0;
    uint h = 0;
    if ((pH-&gt;ht) != null)
    {
        _ht* pEntry;
        h = (uint)(strHash(pKey) % pH-&gt;htsize);
        pEntry = &amp;pH-&gt;ht[h];
        elem = pEntry-&gt;chain;
        count = (uint)(pEntry-&gt;count);
    }
    else
    {
        h = (uint)(0);
        elem = pH-&gt;first;
        count = (uint)(pH-&gt;count);
    }

    if ((pHash) != null)
        *pHash = (uint)(h);
    while ((count--) != 0)
    {
        if ((sqlite3StrICmp(elem-&gt;pKey, pKey)) == (0))
        {
            return elem;
        }

        elem = elem-&gt;next;
    }

    return &amp;findElementWithHash_nullElement;
}</function>
  <function>public static int findIndexCol(Parse pParse, ExprList pList, int iBase, Index pIdx, int iCol)
{
    int i = 0;
    sbyte* zColl = pIdx.azColl[iCol];
    for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
    {
        Expr p = sqlite3ExprSkipCollateAndLikely(pList.a[i].pExpr);
        if ((((p != null) &amp;&amp; (((p.op) == (167)) || ((p.op) == (169)))) &amp;&amp; ((p.iColumn) == (pIdx.aiColumn[iCol]))) &amp;&amp; ((p.iTable) == (iBase)))
        {
            CollSeq pColl = sqlite3ExprNNCollSeq(pParse, pList.a[i].pExpr);
            if ((0) == (sqlite3StrICmp(pColl.zName, zColl)))
            {
                return (int)(i);
            }
        }
    }

    return (int)(-1);
}</function>
  <function>public static int findNextHostParameter(sbyte* zSql, int* pnToken)
{
    int tokenType = 0;
    int nTotal = (int)(0);
    int n = 0;
    *pnToken = (int)(0);
    while ((zSql[0]) != 0)
    {
        n = (int)(sqlite3GetToken((byte*)(zSql), &amp;tokenType));
        if ((tokenType) == (156))
        {
            *pnToken = (int)(n);
            break;
        }

        nTotal += (int)(n);
        zSql += n;
    }

    return (int)(nTotal);
}</function>
  <function>public static Select findRightmost(Select p)
{
    while ((p.pNext) != null)
    {
        p = p.pNext;
    }

    return p;
}</function>
  <function>public static void first_valueFinalizeFunc(sqlite3_context pCtx)
{
    NthValueCtx p;
    p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
    if (((p) != null) &amp;&amp; ((p.pValue) != null))
    {
        sqlite3_result_value(pCtx, p.pValue);
        sqlite3_value_free(p.pValue);
        p.pValue = null;
    }
}</function>
  <function>public static void first_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    NthValueCtx p;
    p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
    if (((p) != null) &amp;&amp; ((p.pValue) == (null)))
    {
        p.pValue = sqlite3_value_dup(apArg[0]);
        if (p.pValue == null)
        {
            sqlite3_result_error_nomem(pCtx);
        }
    }
}</function>
  <function>public static void fixDistinctOpenEph(Parse pParse, int eTnctType, int iVal, int iOpenEphAddr)
{
    if (((pParse.nErr) == (0)) &amp;&amp; (((eTnctType) == (1)) || ((eTnctType) == (2))))
    {
        Vdbe v = pParse.pVdbe;
        sqlite3VdbeChangeToNoop(v, (int)(iOpenEphAddr));
        if ((sqlite3VdbeGetOp(v, (int)(iOpenEphAddr + 1))-&gt;opcode) == (183))
        {
            sqlite3VdbeChangeToNoop(v, (int)(iOpenEphAddr + 1));
        }

        if ((eTnctType) == (2))
        {
            VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iOpenEphAddr));
            pOp-&gt;opcode = (byte)(74);
            pOp-&gt;p1 = (int)(1);
            pOp-&gt;p2 = (int)(iVal);
        }
    }
}</function>
  <function>public static int fixExprCb(Walker p, Expr pExpr)
{
    DbFixer pFix = p.u.pFix;
    if (pFix.bTemp == 0)
        (pExpr).flags |= (uint)(0x40000000);
    if ((pExpr.op) == (156))
    {
        if ((pFix.pParse.db.init.busy) != 0)
        {
            pExpr.op = (byte)(121);
        }
        else
        {
            sqlite3ErrorMsg(pFix.pParse, "%s cannot use variables", pFix.zType);
            return (int)(2);
        }
    }

    return (int)(0);
}</function>
  <function>public static int fixSelectCb(Walker p, Select pSelect)
{
    DbFixer pFix = p.u.pFix;
    int i = 0;
    SrcItem pItem;
    sqlite3 db = pFix.pParse.db;
    int iDb = (int)(sqlite3FindDbName(db, pFix.zDb));
    SrcList pList = pSelect.pSrc;
    if (((pList) == (null)))
        return (int)(0);
    for (i = (int)(0), pItem = pList.a; (i) &lt; (pList.nSrc); i++, pItem++)
    {
        if ((pFix.bTemp) == (0))
        {
            if ((pItem.zDatabase) != null)
            {
                if (iDb != sqlite3FindDbName(db, pItem.zDatabase))
                {
                    sqlite3ErrorMsg(pFix.pParse, "%s %T cannot reference objects in database %s", pFix.zType, pFix.pName, pItem.zDatabase);
                    return (int)(2);
                }

                sqlite3DbFree(db, pItem.zDatabase);
                pItem.zDatabase = null;
                pItem.fg.notCte = (uint)(1);
            }

            pItem.pSchema = pFix.pSchema;
            pItem.fg.fromDDL = (uint)(1);
        }

        if ((sqlite3WalkExpr(pFix.w, pList.a[i].pOn)) != 0)
            return (int)(2);
    }

    if ((pSelect.pWith) != null)
    {
        for (i = (int)(0); (i) &lt; (pSelect.pWith.nCte); i++)
        {
            if ((sqlite3WalkSelect(p, pSelect.pWith.a[i].pSelect)) != 0)
            {
                return (int)(2);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static Trigger fkActionTrigger(Parse pParse, Table pTab, FKey pFKey, ExprList pChanges)
{
    sqlite3 db = pParse.db;
    int action = 0;
    Trigger pTrigger;
    int iAction = (int)(pChanges != null);
    action = (int)(pFKey.aAction[iAction]);
    if (((action) == (7)) &amp;&amp; ((db.flags &amp; 0x00080000) != 0))
    {
        return null;
    }

    pTrigger = pFKey.apTrigger[iAction];
    if ((action != 0) &amp;&amp; (pTrigger == null))
    {
        sbyte* zFrom;
        int nFrom = 0;
        Index pIdx = null;
        int* aiCol = null;
        TriggerStep pStep = null;
        Expr pWhere = null;
        ExprList pList = null;
        Select pSelect = null;
        int i = 0;
        Expr pWhen = null;
        if ((sqlite3FkLocateIndex(pParse, pTab, pFKey, pIdx, &amp;aiCol)) != 0)
            return null;
        for (i = (int)(0); (i) &lt; (pFKey.nCol); i++)
        {
            Token tOld = (Token)(stackalloc Token[]{"old", 3};
         )

        ;
        Token tNew = (Token)(stackalloc Token[]{"new", 3}; )
        ;
        Token tFromCol = new Token();
        Token tToCol = new Token();
        int iFromCol = 0;
        Expr pEq;
        iFromCol = (int)((aiCol) != 0 ? aiCol[i] : pFKey.aCol[0].iFrom);
        sqlite3TokenInit(&amp;tToCol, pTab.aCol[pIdx ? pIdx.aiColumn[i] : pTab.iPKey].zCnName);
        sqlite3TokenInit(&amp;tFromCol, pFKey.pFrom.aCol[iFromCol].zCnName);
        pEq = sqlite3PExpr(pParse, (int)(53), sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &amp;tOld, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &amp;tToCol, (int)(0))), sqlite3ExprAlloc(db, (int)(59), &amp;tFromCol, (int)(0)));
        pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
        if ((pChanges) != null)
        {
            pEq = sqlite3PExpr(pParse, (int)(45), sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &amp;tOld, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &amp;tToCol, (int)(0))), sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &amp;tNew, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &amp;tToCol, (int)(0))));
            pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
        }

        if ((action != 7) &amp;&amp; ((action != 10) || ((pChanges) != null)))
        {
            Expr pNew;
            if ((action) == (10))
            {
                pNew = sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &amp;tNew, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &amp;tToCol, (int)(0)));
            }
            else if ((action) == (9))
            {
                Column* pCol = pFKey.pFrom.aCol + iFromCol;
                Expr pDflt;
                if ((pCol-&gt;colFlags &amp; 0x0060) != 0)
                {
                    pDflt = null;
                }
                else
                {
                    pDflt = sqlite3ColumnExpr(pFKey.pFrom, pCol);
                }

                if ((pDflt) != null)
                {
                    pNew = sqlite3ExprDup(db, pDflt, (int)(0));
                }
                else
                {
                    pNew = sqlite3ExprAlloc(db, (int)(121), null, (int)(0));
                }
            }
            else
            {
                pNew = sqlite3ExprAlloc(db, (int)(121), null, (int)(0));
            }

            pList = sqlite3ExprListAppend(pParse, pList, pNew);
            sqlite3ExprListSetName(pParse, pList, &amp;tFromCol, (int)(0));
        }
    } sqlite3DbFree ( db ,  aiCol ) ;  zFrom  =  pFKey . pFrom . zName ;  nFrom  =  ( int ) ( sqlite3Strlen30 ( zFrom ) ) ;  if  ( ( action ) == ( 7 ) ) { Token  tFrom  =  new  Token ( ) ;  Expr  pRaise ;  tFrom . z  =  zFrom ;  tFrom . n  =  ( uint ) ( nFrom ) ;  pRaise  =  sqlite3Expr ( db ,  ( int ) ( 71 ) ,  "FOREIGN KEY constraint failed" ) ;  if  ( ( pRaise ) != null ) { pRaise . affExpr  =  ( sbyte ) ( 2 ) ;  } pSelect  =  sqlite3SelectNew ( pParse ,  sqlite3ExprListAppend ( pParse ,  null ,  pRaise ) ,  sqlite3SrcListAppend ( pParse ,  null ,  &amp; tFrom ,  null ) ,  pWhere ,  null ,  null ,  null ,  ( uint ) ( 0 ) ,  null ) ;  pWhere  =  null ;  } db . lookaside . bDisable ++ ;  db . lookaside . sz  =  ( ushort ) ( 0 ) ;  pTrigger  =  ( Trigger ) ( sqlite3DbMallocZero ( db ,  ( ulong ) ( sizeof ( Trigger ) + sizeof ( TriggerStep ) + nFrom + 1 ) ) ) ;  if  ( ( pTrigger ) != null ) { pStep  =  pTrigger . step_list  =  ( TriggerStep ) ( pTrigger [ 1 ] ) ;  pStep . zTarget  =  ( sbyte  * ) ( pStep [ 1 ] ) ;  CRuntime . memcpy ( pStep . zTarget ,  zFrom ,  ( ulong ) ( nFrom ) ) ;  pStep . pWhere  =  sqlite3ExprDup ( db ,  pWhere ,  ( int ) ( 0x0001 ) ) ;  pStep . pExprList  =  sqlite3ExprListDup ( db ,  pList ,  ( int ) ( 0x0001 ) ) ;  pStep . pSelect  =  sqlite3SelectDup ( db ,  pSelect ,  ( int ) ( 0x0001 ) ) ;  if  ( ( pWhen ) != null ) { pWhen  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  pWhen ,  null ) ;  pTrigger . pWhen  =  sqlite3ExprDup ( db ,  pWhen ,  ( int ) ( 0x0001 ) ) ;  } } db . lookaside . bDisable -- ;  db . lookaside . sz  =  ( ushort ) ( ( db . lookaside . bDisable ) != 0 ? 0 :  db . lookaside . szTrue ) ;  sqlite3ExprDelete ( db ,  pWhere ) ;  sqlite3ExprDelete ( db ,  pWhen ) ;  sqlite3ExprListDelete ( db ,  pList ) ;  sqlite3SelectDelete ( db ,  pSelect ) ;  if  ( ( db . mallocFailed ) == ( 1 ) ) { fkTriggerDelete ( db ,  pTrigger ) ;  return  null ;  } switch  ( action ) { case  7 :  pStep . op  =  ( byte ) ( 138 ) ;  break ;  case  10 :  if  ( pChanges == null ) { pStep . op  =  ( byte ) ( 128 ) ;  break ;  } default :  pStep . op  =  ( byte ) ( 129 ) ;  } pStep . pTrig  =  pTrigger ;  pTrigger . pSchema  =  pTab . pSchema ;  pTrigger . pTabSchema  =  pTab . pSchema ;  pFKey . apTrigger [ iAction ]  =  pTrigger ;  pTrigger . op  =  ( byte ) ( pChanges ? 129 :  128 ) ;  }

    return pTrigger;
}</function>
  <function>public static int fkChildIsModified(Table pTab, FKey p, int* aChange, int bChngRowid)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (p.nCol); i++)
    {
        int iChildKey = (int)(p.aCol[i].iFrom);
        if ((aChange[iChildKey]) &gt;= (0))
            return (int)(1);
        if (((iChildKey) == (pTab.iPKey)) &amp;&amp; ((bChngRowid) != 0))
            return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void fkLookupParent(Parse pParse, int iDb, Table pTab, Index pIdx, FKey pFKey, int* aiCol, int regData, int nIncr, int isIgnore)
{
    int i = 0;
    Vdbe v = sqlite3GetVdbe(pParse);
    int iCur = (int)(pParse.nTab - 1);
    int iOk = (int)(sqlite3VdbeMakeLabel(pParse));
    if ((nIncr) &lt; (0))
    {
        sqlite3VdbeAddOp2(v, (int)(48), (int)(pFKey.isDeferred), (int)(iOk));
    }

    for (i = (int)(0); (i) &lt; (pFKey.nCol); i++)
    {
        int iReg = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + regData + 1);
        sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(iOk));
    }

    if ((isIgnore) == (0))
    {
        if ((pIdx) == (null))
        {
            int iMustBeInt = 0;
            int regTemp = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp2(v, (int)(80), (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[0])) + 1 + regData), (int)(regTemp));
            iMustBeInt = (int)(sqlite3VdbeAddOp2(v, (int)(15), (int)(regTemp), (int)(0)));
            if (((pTab) == (pFKey.pFrom)) &amp;&amp; ((nIncr) == (1)))
            {
                sqlite3VdbeAddOp3(v, (int)(53), (int)(regData), (int)(iOk), (int)(regTemp));
                sqlite3VdbeChangeP5(v, (ushort)(0x90));
            }

            sqlite3OpenTable(pParse, (int)(iCur), (int)(iDb), pTab, (int)(101));
            sqlite3VdbeAddOp3(v, (int)(33), (int)(iCur), (int)(0), (int)(regTemp));
            sqlite3VdbeGoto(v, (int)(iOk));
            sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
            sqlite3VdbeJumpHere(v, (int)(iMustBeInt));
            sqlite3ReleaseTempReg(pParse, (int)(regTemp));
        }
        else
        {
            int nCol = (int)(pFKey.nCol);
            int regTemp = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
            int regRec = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp3(v, (int)(101), (int)(iCur), (int)(pIdx.tnum), (int)(iDb));
            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
            for (i = (int)(0); (i) &lt; (nCol); i++)
            {
                sqlite3VdbeAddOp2(v, (int)(79), (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + 1 + regData), (int)(regTemp + i));
            }

            if (((pTab) == (pFKey.pFrom)) &amp;&amp; ((nIncr) == (1)))
            {
                int iJump = (int)(sqlite3VdbeCurrentAddr(v) + nCol + 1);
                for (i = (int)(0); (i) &lt; (nCol); i++)
                {
                    int iChild = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + 1 + regData);
                    int iParent = (int)(1 + regData);
                    iParent += (int)(sqlite3TableColumnToStorage(pIdx.pTable, (short)(pIdx.aiColumn[i])));
                    if ((pIdx.aiColumn[i]) == (pTab.iPKey))
                    {
                        iParent = (int)(regData);
                    }

                    sqlite3VdbeAddOp3(v, (int)(52), (int)(iChild), (int)(iJump), (int)(iParent));
                    sqlite3VdbeChangeP5(v, (ushort)(0x10));
                }

                sqlite3VdbeGoto(v, (int)(iOk));
            }

            sqlite3VdbeAddOp4(v, (int)(96), (int)(regTemp), (int)(nCol), (int)(regRec), sqlite3IndexAffinityStr(pParse.db, pIdx), (int)(nCol));
            sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iCur), (int)(iOk), (int)(regRec), (int)(0));
            sqlite3ReleaseTempReg(pParse, (int)(regRec));
            sqlite3ReleaseTempRange(pParse, (int)(regTemp), (int)(nCol));
        }
    }

    if ((((pFKey.isDeferred == 0) &amp;&amp; ((pParse.db.flags &amp; 0x00080000) == 0)) &amp;&amp; (pParse.pToplevel == null)) &amp;&amp; (pParse.isMultiWrite == 0))
    {
        sqlite3HaltConstraint(pParse, (int)(19 | (3 &lt;&lt; 8)), (int)(2), null, (sbyte)(-1), (byte)(4));
    }
    else
    {
        if (((nIncr) &gt; (0)) &amp;&amp; ((pFKey.isDeferred) == (0)))
        {
            sqlite3MayAbort(pParse);
        }

        sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(nIncr));
    }

    sqlite3VdbeResolveLabel(v, (int)(iOk));
    sqlite3VdbeAddOp1(v, (int)(121), (int)(iCur));
}</function>
  <function>public static int fkParentIsModified(Table pTab, FKey p, int* aChange, int bChngRowid)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (p.nCol); i++)
    {
        sbyte* zKey = p.aCol[i].zCol;
        int iKey = 0;
        for (iKey = (int)(0); (iKey) &lt; (pTab.nCol); iKey++)
        {
            if (((aChange[iKey]) &gt;= (0)) || (((iKey) == (pTab.iPKey)) &amp;&amp; ((bChngRowid) != 0)))
            {
                Column* pCol = &amp;pTab.aCol[iKey];
                if ((zKey) != null)
                {
                    if ((0) == (sqlite3StrICmp(pCol-&gt;zCnName, zKey)))
                        return (int)(1);
                }
                else if ((pCol-&gt;colFlags &amp; 0x0001) != 0)
                {
                    return (int)(1);
                }
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static void fkScanChildren(Parse pParse, SrcList pSrc, Table pTab, Index pIdx, FKey pFKey, int* aiCol, int regData, int nIncr)
{
    sqlite3 db = pParse.db;
    int i = 0;
    Expr pWhere = null;
    NameContext sNameContext = new NameContext();
    WhereInfo pWInfo;
    int iFkIfZero = (int)(0);
    Vdbe v = sqlite3GetVdbe(pParse);
    if ((nIncr) &lt; (0))
    {
        iFkIfZero = (int)(sqlite3VdbeAddOp2(v, (int)(48), (int)(pFKey.isDeferred), (int)(0)));
    }

    for (i = (int)(0); (i) &lt; (pFKey.nCol); i++)
    {
        Expr pLeft;
        Expr pRight;
        Expr pEq;
        short iCol = 0;
        sbyte* zCol;
        iCol = (short)(pIdx ? pIdx.aiColumn[i] : -1);
        pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(iCol));
        iCol = (short)((aiCol) != 0 ? aiCol[i] : pFKey.aCol[0].iFrom);
        zCol = pFKey.pFrom.aCol[iCol].zCnName;
        pRight = sqlite3Expr(db, (int)(59), zCol);
        pEq = sqlite3PExpr(pParse, (int)(53), pLeft, pRight);
        pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
    }

    if (((pTab) == (pFKey.pFrom)) &amp;&amp; ((nIncr) &gt; (0)))
    {
        Expr pNe;
        Expr pLeft;
        Expr pRight;
        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(-1));
            pRight = exprTableColumn(db, pTab, (int)(pSrc.a[0].iCursor), (short)(-1));
            pNe = sqlite3PExpr(pParse, (int)(52), pLeft, pRight);
        }
        else
        {
            Expr pEq;
            Expr pAll = null;
            for (i = (int)(0); (i) &lt; (pIdx.nKeyCol); i++)
            {
                short iCol = (short)(pIdx.aiColumn[i]);
                pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(iCol));
                pRight = sqlite3Expr(db, (int)(59), pTab.aCol[iCol].zCnName);
                pEq = sqlite3PExpr(pParse, (int)(45), pLeft, pRight);
                pAll = sqlite3ExprAnd(pParse, pAll, pEq);
            }

            pNe = sqlite3PExpr(pParse, (int)(19), pAll, null);
        }

        pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
    }

    CRuntime.memset(sNameContext, (int)(0), (ulong)(sizeof(NameContext)));
    sNameContext.pSrcList = pSrc;
    sNameContext.pParse = pParse;
    sqlite3ResolveExprNames(sNameContext, pWhere);
    if ((pParse.nErr) == (0))
    {
        pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, null, null, null, (ushort)(0), (int)(0));
        sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(nIncr));
        if ((pWInfo) != null)
        {
            sqlite3WhereEnd(pWInfo);
        }
    }

    sqlite3ExprDelete(db, pWhere);
    if ((iFkIfZero) != 0)
    {
        sqlite3VdbeJumpHereOrPopInst(v, (int)(iFkIfZero));
    }
}</function>
  <function>public static void fkTriggerDelete(sqlite3 dbMem, Trigger p)
{
    if ((p) != null)
    {
        TriggerStep pStep = p.step_list;
        sqlite3ExprDelete(dbMem, pStep.pWhere);
        sqlite3ExprListDelete(dbMem, pStep.pExprList);
        sqlite3SelectDelete(dbMem, pStep.pSelect);
        sqlite3ExprDelete(dbMem, p.pWhen);
        sqlite3DbFree(dbMem, p);
    }
}</function>
  <function>public static int flattenSubquery(Parse pParse, Select p, int iFrom, int isAgg)
{
    sbyte* zSavedAuthContext = pParse.zAuthContext;
    Select pParent;
    Select pSub;
    Select pSub1;
    SrcList pSrc;
    SrcList pSubSrc;
    int iParent = 0;
    int iNewParent = (int)(-1);
    int isLeftJoin = (int)(0);
    int i = 0;
    Expr pWhere;
    SrcItem pSubitem;
    sqlite3 db = pParse.db;
    Walker w = new Walker();
    int* aCsrMap = null;
    if ((((db).dbOptFlags &amp; (0x00000001)) != 0))
        return (int)(0);
    pSrc = p.pSrc;
    pSubitem = pSrc.a[iFrom];
    iParent = (int)(pSubitem.iCursor);
    pSub = pSubitem.pSelect;
    if (((p.pWin) != null) || ((pSub.pWin) != null))
        return (int)(0);
    pSubSrc = pSub.pSrc;
    if (((pSub.pLimit) != null) &amp;&amp; ((p.pLimit) != null))
        return (int)(0);
    if (((pSub.pLimit) != null) &amp;&amp; ((pSub.pLimit.pRight) != null))
        return (int)(0);
    if (((p.selFlags &amp; 0x0000100) != 0) &amp;&amp; ((pSub.pLimit) != null))
    {
        return (int)(0);
    }

    if ((pSubSrc.nSrc) == (0))
        return (int)(0);
    if ((pSub.selFlags &amp; 0x0000001) != 0)
        return (int)(0);
    if (((pSub.pLimit) != null) &amp;&amp; (((pSrc.nSrc) &gt; (1)) || ((isAgg) != 0)))
    {
        return (int)(0);
    }

    if (((p.pOrderBy) != null) &amp;&amp; ((pSub.pOrderBy) != null))
    {
        return (int)(0);
    }

    if (((isAgg) != 0) &amp;&amp; ((pSub.pOrderBy) != null))
        return (int)(0);
    if (((pSub.pLimit) != null) &amp;&amp; ((p.pWhere) != null))
        return (int)(0);
    if (((pSub.pLimit) != null) &amp;&amp; ((p.selFlags &amp; 0x0000001) != 0))
    {
        return (int)(0);
    }

    if ((pSub.selFlags &amp; (0x0002000)) != 0)
    {
        return (int)(0);
    }

    if ((pSubitem.fg.jointype &amp; 0x0020) != 0)
    {
        isLeftJoin = (int)(1);
        if (((((pSubSrc.nSrc) &gt; (1)) || ((isAgg) != 0)) || (((pSubSrc.a[0].pTab).eTabType) == (1))) || ((p.selFlags &amp; 0x0000001) != 0))
        {
            return (int)(0);
        }
    }

    if ((pSub.pPrior) != null)
    {
        if ((pSub.pOrderBy) != null)
        {
            return (int)(0);
        }

        if ((((isAgg) != 0) || ((p.selFlags &amp; 0x0000001) != 0)) || ((isLeftJoin) &gt; (0)))
        {
            return (int)(0);
        }

        for (pSub1 = pSub; pSub1; pSub1 = pSub1.pPrior)
        {
            if (((((pSub1.selFlags &amp; (0x0000001 | 0x0000008)) != 0) || (((pSub1.pPrior) != null) &amp;&amp; (pSub1.op != 135))) || ((pSub1.pSrc.nSrc) &lt; (1))) || ((pSub1.pWin) != null))
            {
                return (int)(0);
            }
        }

        if ((p.pOrderBy) != null)
        {
            int ii = 0;
            for (ii = (int)(0); (ii) &lt; (p.pOrderBy.nExpr); ii++)
            {
                if ((p.pOrderBy.a[ii].u.x.iOrderByCol) == (0))
                    return (int)(0);
            }
        }

        if ((p.selFlags &amp; 0x0002000) != 0)
            return (int)(0);
        if ((pSrc.nSrc) &gt; (1))
        {
            if ((pParse.nSelect) &gt; (500))
                return (int)(0);
            aCsrMap = sqlite3DbMallocZero(db, (ulong)(((long)(pParse.nTab) + 1) * sizeof(int)));
            if ((aCsrMap) != null)
                aCsrMap[0] = (int)(pParse.nTab);
        }
    }

    pParse.zAuthContext = pSubitem.zName;
    sqlite3AuthCheck(pParse, (int)(21), null, null, null);
    pParse.zAuthContext = zSavedAuthContext;
    pSub1 = pSubitem.pSelect;
    sqlite3DbFree(db, pSubitem.zDatabase);
    sqlite3DbFree(db, pSubitem.zName);
    sqlite3DbFree(db, pSubitem.zAlias);
    pSubitem.zDatabase = null;
    pSubitem.zName = null;
    pSubitem.zAlias = null;
    pSubitem.pSelect = null;
    for (pSub = pSub.pPrior; pSub; pSub = pSub.pPrior)
    {
        Select pNew;
        ExprList pOrderBy = p.pOrderBy;
        Expr pLimit = p.pLimit;
        Select pPrior = p.pPrior;
        Table pItemTab = pSubitem.pTab;
        pSubitem.pTab = null;
        p.pOrderBy = null;
        p.pPrior = null;
        p.pLimit = null;
        pNew = sqlite3SelectDup(db, p, (int)(0));
        p.pLimit = pLimit;
        p.pOrderBy = pOrderBy;
        p.op = (byte)(135);
        pSubitem.pTab = pItemTab;
        if ((pNew) == (null))
        {
            p.pPrior = pPrior;
        }
        else
        {
            pNew.selId = (uint)(++pParse.nSelect);
            if (((aCsrMap) != null) &amp;&amp; ((db.mallocFailed) == (0)))
            {
                renumberCursors(pParse, pNew, (int)(iFrom), aCsrMap);
            }

            pNew.pPrior = pPrior;
            if ((pPrior) != null)
                pPrior.pNext = pNew;
            pNew.pNext = p;
            p.pPrior = pNew;
        }
    }

    sqlite3DbFree(db, aCsrMap);
    if ((db.mallocFailed) != 0)
    {
        pSubitem.pSelect = pSub1;
        return (int)(1);
    }

    if ((pSubitem.pTab != null))
    {
        Table pTabToDel = pSubitem.pTab;
        if ((pTabToDel.nTabRef) == (1))
        {
            Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
            sqlite3ParserAddCleanup(pToplevel, sqlite3DeleteTable, pTabToDel);
        }
        else
        {
            pTabToDel.nTabRef--;
        }

        pSubitem.pTab = null;
    }

    pSub = pSub1;
    for (pParent = p; pParent; pParent = pParent.pPrior, pSub = pSub.pPrior)
    {
        int nSubSrc = 0;
        byte jointype = (byte)(0);
        pSubSrc = pSub.pSrc;
        nSubSrc = (int)(pSubSrc.nSrc);
        pSrc = pParent.pSrc;
        if ((pParent) == (p))
        {
            jointype = (byte)(pSubitem.fg.jointype);
        }

        if ((nSubSrc) &gt; (1))
        {
            pSrc = sqlite3SrcListEnlarge(pParse, pSrc, (int)(nSubSrc - 1), (int)(iFrom + 1));
            if ((pSrc) == (null))
                break;
            pParent.pSrc = pSrc;
        }

        for (i = (int)(0); (i) &lt; (nSubSrc); i++)
        {
            sqlite3IdListDelete(db, pSrc.a[i + iFrom].pUsing);
            pSrc.a[i + iFrom] = (SrcItem)(pSubSrc.a[i]);
            iNewParent = (int)(pSubSrc.a[i].iCursor);
            CRuntime.memset(pSubSrc.a[i], (int)(0), (ulong)(sizeof(SrcItem)));
        }

        pSrc.a[iFrom].fg.jointype = (byte)(jointype);
        if (((pSub.pOrderBy) != null) &amp;&amp; ((pParent.selFlags &amp; 0x0400000) == (0)))
        {
            ExprList pOrderBy = pSub.pOrderBy;
            for (i = (int)(0); (i) &lt; (pOrderBy.nExpr); i++)
            {
                pOrderBy.a[i].u.x.iOrderByCol = (ushort)(0);
            }

            pParent.pOrderBy = pOrderBy;
            pSub.pOrderBy = null;
        }

        pWhere = pSub.pWhere;
        pSub.pWhere = null;
        if ((isLeftJoin) &gt; (0))
        {
            sqlite3SetJoinExpr(pWhere, (int)(iNewParent));
        }

        if ((pWhere) != null)
        {
            if ((pParent.pWhere) != null)
            {
                pParent.pWhere = sqlite3PExpr(pParse, (int)(44), pWhere, pParent.pWhere);
            }
            else
            {
                pParent.pWhere = pWhere;
            }
        }

        if ((db.mallocFailed) == (0))
        {
            SubstContext x = new SubstContext();
            x.pParse = pParse;
            x.iTable = (int)(iParent);
            x.iNewTable = (int)(iNewParent);
            x.isLeftJoin = (int)(isLeftJoin);
            x.pEList = pSub.pEList;
            substSelect(x, pParent, (int)(0));
        }

        pParent.selFlags |= (uint)(pSub.selFlags &amp; 0x0000100);
        if ((pSub.pLimit) != null)
        {
            pParent.pLimit = pSub.pLimit;
            pSub.pLimit = null;
        }

        for (i = (int)(0); (i) &lt; (nSubSrc); i++)
        {
            recomputeColumnsUsed(pParent, pSrc.a[i + iFrom]);
        }
    }

    sqlite3AggInfoPersistWalkerInit(w, pParse);
    sqlite3WalkSelect(w, pSub1);
    sqlite3SelectDelete(db, pSub1);
    return (int)(1);
}</function>
  <function>public static void freeEphemeralFunction(sqlite3 db, FuncDef pDef)
{
    if ((pDef.funcFlags &amp; 0x0010) != 0)
    {
        sqlite3DbFreeNN(db, pDef);
    }
}</function>
  <function>public static void freeIndexInfo(sqlite3 db, sqlite3_index_info* pIdxInfo)
{
    HiddenIndexInfo pHidden;
    int i = 0;
    pHidden = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    for (i = (int)(0); (i) &lt; (pIdxInfo-&gt;nConstraint); i++)
    {
        sqlite3ValueFree(pHidden.aRhs[i]);
        pHidden.aRhs[i] = null;
    }

    sqlite3DbFree(db, pIdxInfo);
}</function>
  <function>public static void freeP4(sqlite3 db, int p4type, void* p4)
{
    switch (p4type)
    {
        case (-16):
        {
            freeP4FuncCtx(db, (sqlite3_context)(p4));
            break;
        }

        case (-13):
        case (-14):
        case (-7):
        case (-17):
        case (-15):
        {
            sqlite3DbFree(db, p4);
            break;
        }

        case (-9):
        {
            if ((db.pnBytesFreed) == (null))
                sqlite3KeyInfoUnref((KeyInfo)(p4));
            break;
        }

        case (-8):
        {
            freeEphemeralFunction(db, (FuncDef)(p4));
            break;
        }

        case (-11):
        {
            if ((db.pnBytesFreed) == (null))
            {
                sqlite3ValueFree((sqlite3_value)(p4));
            }
            else
            {
                freeP4Mem(db, (sqlite3_value)(p4));
            }

            break;
        }

        case (-12):
        {
            if ((db.pnBytesFreed) == (null))
                sqlite3VtabUnlock((VTable)(p4));
            break;
        }
    }
}</function>
  <function>public static void freeP4FuncCtx(sqlite3 db, sqlite3_context p)
{
    freeEphemeralFunction(db, p.pFunc);
    sqlite3DbFreeNN(db, p);
}</function>
  <function>public static void freeP4Mem(sqlite3 db, sqlite3_value p)
{
    if ((p.szMalloc) != 0)
        sqlite3DbFree(db, p.zMalloc);
    sqlite3DbFreeNN(db, p);
}</function>
  <function>public static void freePage(MemPage pPage, int* pRC)
{
    if ((*pRC) == (0))
    {
        *pRC = (int)(freePage2(pPage.pBt, pPage, (uint)(pPage.pgno)));
    }
}</function>
  <function>public static int freePage2(BtShared pBt, MemPage pMemPage, uint iPage)
{
    MemPage pTrunk = null;
    uint iTrunk = (uint)(0);
    MemPage pPage1 = pBt.pPage1;
    MemPage pPage;
    int rc = 0;
    uint nFree = 0;
    if (((iPage) &lt; (2)) || ((iPage) &gt; (pBt.nPage)))
    {
        return (int)(sqlite3CorruptError((int)(72577)));
    }

    if ((pMemPage) != null)
    {
        pPage = pMemPage;
        sqlite3PagerRef(pPage.pDbPage);
    }
    else
    {
        pPage = btreePageLookup(pBt, (uint)(iPage));
    }

    rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
    if ((rc) != 0)
        goto freepage_out;
    nFree = (uint)(sqlite3Get4byte(&amp;pPage1.aData[36]));
    sqlite3Put4byte(&amp;pPage1.aData[36], (uint)(nFree + 1));
    if ((pBt.btsFlags &amp; 0x0004) != 0)
    {
        if (((pPage == null) &amp;&amp; ((rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0)))) != 0)) || ((rc = (int)(sqlite3PagerWrite(pPage.pDbPage))) != 0))
        {
            goto freepage_out;
        }

        CRuntime.memset(pPage.aData, (int)(0), (ulong)(pPage.pBt.pageSize));
    }

    if ((pBt.autoVacuum) != 0)
    {
        ptrmapPut(pBt, (uint)(iPage), (byte)(2), (uint)(0), &amp;rc);
        if ((rc) != 0)
            goto freepage_out;
    }

    if (nFree != 0)
    {
        uint nLeaf = 0;
        iTrunk = (uint)(sqlite3Get4byte(&amp;pPage1.aData[32]));
        if ((iTrunk) &gt; (btreePagecount(pBt)))
        {
            rc = (int)(sqlite3CorruptError((int)(72624)));
            goto freepage_out;
        }

        rc = (int)(btreeGetPage(pBt, (uint)(iTrunk), pTrunk, (int)(0)));
        if (rc != 0)
        {
            goto freepage_out;
        }

        nLeaf = (uint)(sqlite3Get4byte(&amp;pTrunk.aData[4]));
        if ((nLeaf) &gt; (pBt.usableSize / 4 - 2))
        {
            rc = (int)(sqlite3CorruptError((int)(72635)));
            goto freepage_out;
        }

        if ((nLeaf) &lt; (pBt.usableSize / 4 - 8))
        {
            rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
            if ((rc) == (0))
            {
                sqlite3Put4byte(&amp;pTrunk.aData[4], (uint)(nLeaf + 1));
                sqlite3Put4byte(&amp;pTrunk.aData[8 + nLeaf * 4], (uint)(iPage));
                if (((pPage) != null) &amp;&amp; ((pBt.btsFlags &amp; 0x0004) == (0)))
                {
                    sqlite3PagerDontWrite(pPage.pDbPage);
                }

                rc = (int)(btreeSetHasContent(pBt, (uint)(iPage)));
            }

            goto freepage_out;
        }
    }

    if (((pPage) == (null)) &amp;&amp; (0 != (rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0))))))
    {
        goto freepage_out;
    }

    rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
    if (rc != 0)
    {
        goto freepage_out;
    }

    sqlite3Put4byte(pPage.aData, (uint)(iTrunk));
    sqlite3Put4byte(&amp;pPage.aData[4], (uint)(0));
    sqlite3Put4byte(&amp;pPage1.aData[32], (uint)(iPage));
    freepage_out:
        ; if  ( ( pPage ) != null ) { pPage . isInit  =  ( byte ) ( 0 ) ;  }
    releasePage(pPage);
    releasePage(pTrunk);
    return (int)(rc);
}</function>
  <function>public static int freeSpace(MemPage pPage, ushort iStart, ushort iSize)
{
    ushort iPtr = 0;
    ushort iFreeBlk = 0;
    byte hdr = 0;
    byte nFrag = (byte)(0);
    ushort iOrigSize = (ushort)(iSize);
    ushort x = 0;
    uint iEnd = (uint)(iStart + iSize);
    byte* data = pPage.aData;
    hdr = (byte)(pPage.hdrOffset);
    iPtr = (ushort)(hdr + 1);
    if (((data[iPtr + 1]) == (0)) &amp;&amp; ((data[iPtr]) == (0)))
    {
        iFreeBlk = (ushort)(0);
    }
    else
    {
        while ((iFreeBlk = (ushort)((&amp;data[iPtr])[0] &lt;&lt; 8 | (&amp;data[iPtr])[1])) &lt; (iStart))
        {
            if ((iFreeBlk) &lt; (iPtr + 4))
            {
                if ((iFreeBlk) == (0))
                    break;
                return (int)(sqlite3CorruptError((int)(67940)));
            }

            iPtr = (ushort)(iFreeBlk);
        }

        if ((iFreeBlk) &gt; (pPage.pBt.usableSize - 4))
        {
            return (int)(sqlite3CorruptError((int)(67945)));
        }

        if (((iFreeBlk) != 0) &amp;&amp; ((iEnd + 3) &gt;= (iFreeBlk)))
        {
            nFrag = (byte)(iFreeBlk - iEnd);
            if ((iEnd) &gt; (iFreeBlk))
                return (int)(sqlite3CorruptError((int)(67957)));
            iEnd = (uint)(iFreeBlk + ((&amp;data[iFreeBlk + 2])[0] &lt;&lt; 8 | (&amp;data[iFreeBlk + 2])[1]));
            if ((iEnd) &gt; (pPage.pBt.usableSize))
            {
                return (int)(sqlite3CorruptError((int)(67960)));
            }

            iSize = (ushort)(iEnd - iStart);
            iFreeBlk = (ushort)((&amp;data[iFreeBlk])[0] &lt;&lt; 8 | (&amp;data[iFreeBlk])[1]);
        }

        if ((iPtr) &gt; (hdr + 1))
        {
            int iPtrEnd = (int)(iPtr + ((&amp;data[iPtr + 2])[0] &lt;&lt; 8 | (&amp;data[iPtr + 2])[1]));
            if ((iPtrEnd + 3) &gt;= (iStart))
            {
                if ((iPtrEnd) &gt; (iStart))
                    return (int)(sqlite3CorruptError((int)(67973)));
                nFrag += (byte)(iStart - iPtrEnd);
                iSize = (ushort)(iEnd - iPtr);
                iStart = (ushort)(iPtr);
            }
        }

        if ((nFrag) &gt; (data[hdr + 7]))
            return (int)(sqlite3CorruptError((int)(67979)));
        data[hdr + 7] -= (byte)(nFrag);
    }

    x = (ushort)((&amp;data[hdr + 5])[0] &lt;&lt; 8 | (&amp;data[hdr + 5])[1]);
    if ((iStart) &lt;= (x))
    {
        if ((iStart) &lt; (x))
            return (int)(sqlite3CorruptError((int)(67987)));
        if (iPtr != hdr + 1)
            return (int)(sqlite3CorruptError((int)(67988)));
        ((&amp;data[hdr + 1])[0] = ((byte)((iFreeBlk) &gt;&gt; 8)), (&amp;data[hdr + 1])[1] = ((byte)(iFreeBlk)));
        ((&amp;data[hdr + 5])[0] = ((byte)((iEnd) &gt;&gt; 8)), (&amp;data[hdr + 5])[1] = ((byte)(iEnd)));
    }
    else
    {
        ((&amp;data[iPtr])[0] = ((byte)((iStart) &gt;&gt; 8)), (&amp;data[iPtr])[1] = ((byte)(iStart)));
    }

    if ((pPage.pBt.btsFlags &amp; 0x000c) != 0)
    {
        CRuntime.memset(&amp;data[iStart], (int)(0), (ulong)(iSize));
    }

    ((&amp;data[iStart])[0] = ((byte)((iFreeBlk) &gt;&gt; 8)), (&amp;data[iStart])[1] = ((byte)(iFreeBlk)));
    ((&amp;data[iStart + 2])[0] = ((byte)((iSize) &gt;&gt; 8)), (&amp;data[iStart + 2])[1] = ((byte)(iSize)));
    pPage.nFree += (int)(iOrigSize);
    return (int)(0);
}</function>
  <function>public static void freeTempSpace(BtShared pBt)
{
    if ((pBt.pTmpSpace) != null)
    {
        pBt.pTmpSpace -= 4;
        sqlite3PageFree(pBt.pTmpSpace);
        pBt.pTmpSpace = null;
    }
}</function>
  <function>public static void functionDestroy(sqlite3 db, FuncDef p)
{
    FuncDestructor pDestructor;
    pDestructor = p.u.pDestructor;
    if ((pDestructor) != null)
    {
        pDestructor.nRef--;
        if ((pDestructor.nRef) == (0))
        {
            pDestructor.xDestroy(pDestructor.pUserData);
            sqlite3DbFree(db, pDestructor);
        }
    }
}</function>
  <function>public static void gatherSelectWindows(Select p)
{
    Walker w = new Walker();
    w.xExprCallback = gatherSelectWindowsCallback;
    w.xSelectCallback = gatherSelectWindowsSelectCallback;
    w.xSelectCallback2 = null;
    w.pParse = null;
    w.u.pSelect = p;
    sqlite3WalkSelect(w, p);
}</function>
  <function>public static int gatherSelectWindowsCallback(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (172)) &amp;&amp; (((pExpr).flags &amp; (0x1000000)) != 0))
    {
        Select pSelect = pWalker.u.pSelect;
        Window pWin = pExpr.y.pWin;
        sqlite3WindowLink(pSelect, pWin);
    }

    return (int)(0);
}</function>
  <function>public static int gatherSelectWindowsSelectCallback(Walker pWalker, Select p)
{
    return (int)((p) == (pWalker.u.pSelect) ? 0 : 1);
}</function>
  <function>public static void generateColumnTypes(Parse pParse, SrcList pTabList, ExprList pEList)
{
    Vdbe v = pParse.pVdbe;
    int i = 0;
    NameContext sNC = new NameContext();
    sNC.pSrcList = pTabList;
    sNC.pParse = pParse;
    sNC.pNext = null;
    for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
    {
        Expr p = pEList.a[i].pExpr;
        sbyte* zType;
        zType = columnTypeImpl(sNC, p);
        sqlite3VdbeSetColName(v, (int)(i), (int)(1), zType, ((Void(Void * ))(-1)));
    }
}</function>
  <function>public static int generateOutputSubroutine(Parse pParse, Select p, SelectDest pIn, SelectDest pDest, int regReturn, int regPrev, KeyInfo pKeyInfo, int iBreak)
{
    Vdbe v = pParse.pVdbe;
    int iContinue = 0;
    int addr = 0;
    addr = (int)(sqlite3VdbeCurrentAddr(v));
    iContinue = (int)(sqlite3VdbeMakeLabel(pParse));
    if ((regPrev) != 0)
    {
        int addr1 = 0;
        int addr2 = 0;
        addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regPrev)));
        addr2 = (int)(sqlite3VdbeAddOp4(v, (int)(89), (int)(pIn.iSdst), (int)(regPrev + 1), (int)(pIn.nSdst), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9)));
        sqlite3VdbeAddOp3(v, (int)(16), (int)(addr2 + 2), (int)(iContinue), (int)(addr2 + 2));
        sqlite3VdbeJumpHere(v, (int)(addr1));
        sqlite3VdbeAddOp3(v, (int)(79), (int)(pIn.iSdst), (int)(regPrev + 1), (int)(pIn.nSdst - 1));
        sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regPrev));
    }

    if ((pParse.db.mallocFailed) != 0)
        return (int)(0);
    codeOffset(v, (int)(p.iOffset), (int)(iContinue));
    switch (pDest.eDest)
    {
        case 12:
        {
            int r1 = (int)(sqlite3GetTempReg(pParse));
            int r2 = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(pIn.iSdst), (int)(pIn.nSdst), (int)(r1));
            sqlite3VdbeAddOp2(v, (int)(126), (int)(pDest.iSDParm), (int)(r2));
            sqlite3VdbeAddOp3(v, (int)(127), (int)(pDest.iSDParm), (int)(r1), (int)(r2));
            sqlite3VdbeChangeP5(v, (ushort)(0x08));
            sqlite3ReleaseTempReg(pParse, (int)(r2));
            sqlite3ReleaseTempReg(pParse, (int)(r1));
            break;
        }

        case 11:
        {
            int r1 = 0;
            r1 = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp4(v, (int)(96), (int)(pIn.iSdst), (int)(pIn.nSdst), (int)(r1), pDest.zAffSdst, (int)(pIn.nSdst));
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(pDest.iSDParm), (int)(r1), (int)(pIn.iSdst), (int)(pIn.nSdst));
            sqlite3ReleaseTempReg(pParse, (int)(r1));
            break;
        }

        case 10:
        {
            sqlite3ExprCodeMove(pParse, (int)(pIn.iSdst), (int)(pDest.iSDParm), (int)(pIn.nSdst));
            break;
        }

        case 13:
        {
            if ((pDest.iSdst) == (0))
            {
                pDest.iSdst = (int)(sqlite3GetTempRange(pParse, (int)(pIn.nSdst)));
                pDest.nSdst = (int)(pIn.nSdst);
            }

            sqlite3ExprCodeMove(pParse, (int)(pIn.iSdst), (int)(pDest.iSdst), (int)(pIn.nSdst));
            sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
            break;
        }

        default:
        {
            sqlite3VdbeAddOp2(v, (int)(83), (int)(pIn.iSdst), (int)(pIn.nSdst));
            break;
        }
    }

    if ((p.iLimit) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(60), (int)(p.iLimit), (int)(iBreak));
    }

    sqlite3VdbeResolveLabel(v, (int)(iContinue));
    sqlite3VdbeAddOp1(v, (int)(67), (int)(regReturn));
    return (int)(addr);
}</function>
  <function>public static void generateSortTail(Parse pParse, Select p, SortCtx pSort, int nColumn, SelectDest pDest)
{
    Vdbe v = pParse.pVdbe;
    int addrBreak = (int)(pSort.labelDone);
    int addrContinue = (int)(sqlite3VdbeMakeLabel(pParse));
    int addr = 0;
    int addrOnce = (int)(0);
    int iTab = 0;
    ExprList pOrderBy = pSort.pOrderBy;
    int eDest = (int)(pDest.eDest);
    int iParm = (int)(pDest.iSDParm);
    int regRow = 0;
    int regRowid = 0;
    int iCol = 0;
    int nKey = 0;
    int iSortTab = 0;
    int i = 0;
    int bSeq = 0;
    int nRefKey = (int)(0);
    ExprList_item* aOutEx = p.pEList.a;
    if ((pSort.labelBkOut) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(12), (int)(pSort.regReturn), (int)(pSort.labelBkOut));
        sqlite3VdbeGoto(v, (int)(addrBreak));
        sqlite3VdbeResolveLabel(v, (int)(pSort.labelBkOut));
    }

    iTab = (int)(pSort.iECursor);
    if ((((eDest) == (9)) || ((eDest) == (13))) || ((eDest) == (10)))
    {
        if (((eDest) == (10)) &amp;&amp; ((p.iOffset) != 0))
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pDest.iSdst));
        }

        regRowid = (int)(0);
        regRow = (int)(pDest.iSdst);
    }
    else
    {
        regRowid = (int)(sqlite3GetTempReg(pParse));
        if (((eDest) == (12)) || ((eDest) == (14)))
        {
            regRow = (int)(sqlite3GetTempReg(pParse));
            nColumn = (int)(0);
        }
        else
        {
            regRow = (int)(sqlite3GetTempRange(pParse, (int)(nColumn)));
        }
    }

    nKey = (int)(pOrderBy.nExpr - pSort.nOBSat);
    if ((pSort.sortFlags &amp; 0x01) != 0)
    {
        int regSortOut = (int)(++pParse.nMem);
        iSortTab = (int)(pParse.nTab++);
        if ((pSort.labelBkOut) != 0)
        {
            addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
        }

        sqlite3VdbeAddOp3(v, (int)(120), (int)(iSortTab), (int)(regSortOut), (int)(nKey + 1 + nColumn + nRefKey));
        if ((addrOnce) != 0)
            sqlite3VdbeJumpHere(v, (int)(addrOnce));
        addr = (int)(1 + sqlite3VdbeAddOp2(v, (int)(36), (int)(iTab), (int)(addrBreak)));
        codeOffset(v, (int)(p.iOffset), (int)(addrContinue));
        sqlite3VdbeAddOp3(v, (int)(132), (int)(iTab), (int)(regSortOut), (int)(iSortTab));
        bSeq = (int)(0);
    }
    else
    {
        addr = (int)(1 + sqlite3VdbeAddOp2(v, (int)(37), (int)(iTab), (int)(addrBreak)));
        codeOffset(v, (int)(p.iOffset), (int)(addrContinue));
        iSortTab = (int)(iTab);
        bSeq = (int)(1);
    }

    for (i = (int)(0), iCol = (int)(nKey + bSeq - 1); (i) &lt; (nColumn); i++)
    {
        if ((aOutEx[i].u.x.iOrderByCol) == (0))
            iCol++;
    }

    for (i = (int)(nColumn - 1); (i) &gt;= (0); i--)
    {
        {
            int iRead = 0;
            if ((aOutEx[i].u.x.iOrderByCol) != 0)
            {
                iRead = (int)(aOutEx[i].u.x.iOrderByCol - 1);
            }
            else
            {
                iRead = (int)(iCol--);
            }

            sqlite3VdbeAddOp3(v, (int)(93), (int)(iSortTab), (int)(iRead), (int)(regRow + i));
        }
    }

    switch (eDest)
    {
        case 14:
        case 12:
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(iSortTab), (int)(nKey + bSeq), (int)(regRow));
            sqlite3VdbeAddOp2(v, (int)(126), (int)(iParm), (int)(regRowid));
            sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(regRow), (int)(regRowid));
            sqlite3VdbeChangeP5(v, (ushort)(0x08));
            break;
        }

        case 11:
        {
            sqlite3VdbeAddOp4(v, (int)(96), (int)(regRow), (int)(nColumn), (int)(regRowid), pDest.zAffSdst, (int)(nColumn));
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(regRowid), (int)(regRow), (int)(nColumn));
            break;
        }

        case 10:
        {
            break;
        }

        case 15:
        {
            int i2 = (int)(pDest.iSDParm2);
            int r1 = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(regRow + ((i2) &lt; (0))), (int)(nColumn - ((i2) &lt; (0))), (int)(r1));
            if ((i2) &lt; (0))
            {
                sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(regRow));
            }
            else
            {
                sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regRow), (int)(i2));
            }

            break;
        }

        default:
        {
            if ((eDest) == (9))
            {
                sqlite3VdbeAddOp2(v, (int)(83), (int)(pDest.iSdst), (int)(nColumn));
            }
            else
            {
                sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
            }

            break;
        }
    }

    if ((regRowid) != 0)
    {
        if ((eDest) == (11))
        {
            sqlite3ReleaseTempRange(pParse, (int)(regRow), (int)(nColumn));
        }
        else
        {
            sqlite3ReleaseTempReg(pParse, (int)(regRow));
        }

        sqlite3ReleaseTempReg(pParse, (int)(regRowid));
    }

    sqlite3VdbeResolveLabel(v, (int)(addrContinue));
    if ((pSort.sortFlags &amp; 0x01) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(3), (int)(iTab), (int)(addr));
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addr));
    }

    if ((pSort.regReturn) != 0)
        sqlite3VdbeAddOp1(v, (int)(67), (int)(pSort.regReturn));
    sqlite3VdbeResolveLabel(v, (int)(addrBreak));
}</function>
  <function>public static void generateWithRecursiveQuery(Parse pParse, Select p, SelectDest pDest)
{
    SrcList pSrc = p.pSrc;
    int nCol = (int)(p.pEList.nExpr);
    Vdbe v = pParse.pVdbe;
    Select pSetup;
    Select pFirstRec;
    int addrTop = 0;
    int addrCont = 0; int  addrBreak  =  0 ; 
    int iCurrent = (int)(0);
    int regCurrent = 0;
    int iQueue = 0;
    int iDistinct = (int)(0);
    int eDest = (int)(8);
    SelectDest destQueue = new SelectDest();
    int i = 0;
    int rc = 0;
    ExprList pOrderBy;
    Expr pLimit;
    int regLimit = 0; int  regOffset  =  0 ; 
    if ((p.pWin) != null)
    {
        sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
        return;
    }

    if ((sqlite3AuthCheck(pParse, (int)(33), null, null, null)) != 0)
        return;
    addrBreak = (int)(sqlite3VdbeMakeLabel(pParse));
    p.nSelectRow = (short)(320);
    computeLimitRegisters(pParse, p, (int)(addrBreak));
    pLimit = p.pLimit;
    regLimit = (int)(p.iLimit);
    regOffset = (int)(p.iOffset);
    p.pLimit = null;
    p.iLimit = (int)(p.iOffset = (int)(0));
    pOrderBy = p.pOrderBy;
    for (i = (int)(0); ((i) &lt; (pSrc.nSrc)); i++)
    {
        if ((pSrc.a[i].fg.isRecursive) != 0)
        {
            iCurrent = (int)(pSrc.a[i].iCursor);
            break;
        }
    }

    iQueue = (int)(pParse.nTab++);
    if ((p.op) == (134))
    {
        eDest = (int)(pOrderBy ? 6 : 5);
        iDistinct = (int)(pParse.nTab++);
    }
    else
    {
        eDest = (int)(pOrderBy ? 7 : 8);
    }

    sqlite3SelectDestInit(destQueue, (int)(eDest), (int)(iQueue));
    regCurrent = (int)(++pParse.nMem);
    sqlite3VdbeAddOp3(v, (int)(120), (int)(iCurrent), (int)(regCurrent), (int)(nCol));
    if ((pOrderBy) != null)
    {
        KeyInfo pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, (int)(1));
        sqlite3VdbeAddOp4(v, (int)(116), (int)(iQueue), (int)(pOrderBy.nExpr + 2), (int)(0), (sbyte*)(pKeyInfo), (int)(-9));
        destQueue.pOrderBy = pOrderBy;
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(116), (int)(iQueue), (int)(nCol));
    }

    if ((iDistinct) != 0)
    {
        p.addrOpenEphm[0] = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iDistinct), (int)(0)));
        p.selFlags |= (uint)(0x0000020);
    }

    p.pOrderBy = null;
    for (pFirstRec = p; (pFirstRec != null); pFirstRec = pFirstRec.pPrior)
    {
        if ((pFirstRec.selFlags &amp; 0x0000008) != 0)
        {
            sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
            goto end_of_recursive_query;
        }

        pFirstRec.op = (byte)(135);
        if ((pFirstRec.pPrior.selFlags &amp; 0x0002000) == (0))
            break;
    }

    pSetup = pFirstRec.pPrior;
    pSetup.pNext = null;
    sqlite3VdbeExplain(pParse, (byte)(1), "SETUP");
    rc = (int)(sqlite3Select(pParse, pSetup, destQueue));
    pSetup.pNext = p;
    if ((rc) != 0)
        goto end_of_recursive_query;
    addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iQueue), (int)(addrBreak)));
    sqlite3VdbeAddOp1(v, (int)(135), (int)(iCurrent));
    if ((pOrderBy) != null)
    {
        sqlite3VdbeAddOp3(v, (int)(93), (int)(iQueue), (int)(pOrderBy.nExpr + 1), (int)(regCurrent));
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(133), (int)(iQueue), (int)(regCurrent));
    }

    sqlite3VdbeAddOp1(v, (int)(129), (int)(iQueue));
    addrCont = (int)(sqlite3VdbeMakeLabel(pParse));
    codeOffset(v, (int)(regOffset), (int)(addrCont));
    selectInnerLoop(pParse, p, (int)(iCurrent), null, null, pDest, (int)(addrCont), (int)(addrBreak));
    if ((regLimit) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(60), (int)(regLimit), (int)(addrBreak));
    }

    sqlite3VdbeResolveLabel(v, (int)(addrCont));
    pFirstRec.pPrior = null;
    sqlite3VdbeExplain(pParse, (byte)(1), "RECURSIVE STEP");
    sqlite3Select(pParse, p, destQueue);
    pFirstRec.pPrior = pSetup;
    sqlite3VdbeGoto(v, (int)(addrTop));
    sqlite3VdbeResolveLabel(v, (int)(addrBreak));
    end_of_recursive_query:
        ; sqlite3ExprListDelete ( pParse . db ,  p . pOrderBy ) ; 
    p.pOrderBy = pOrderBy;
    p.pLimit = pLimit;
    return;
}</function>
  <function>public static int getAndInitPage(BtShared pBt, uint pgno, MemPage ppPage, BtCursor pCur, int bReadOnly)
{
    int rc = 0;
    PgHdr pDbPage;
    if ((pgno) &gt; (btreePagecount(pBt)))
    {
        rc = (int)(sqlite3CorruptError((int)(68380)));
        goto getAndInitPage_error1;
    }

    rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(pgno), pDbPage, (int)(bReadOnly)));
    if ((rc) != 0)
    {
        goto getAndInitPage_error1;
    }

    ppPage = (MemPage)(sqlite3PagerGetExtra(pDbPage));
    if (((ppPage).isInit) == (0))
    {
        btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
        rc = (int)(btreeInitPage(ppPage));
        if (rc != 0)
        {
            goto getAndInitPage_error2;
        }
    }

    if (((pCur) != null) &amp;&amp; ((((ppPage).nCell) &lt; (1)) || ((ppPage).intKey != pCur.curIntKey)))
    {
        rc = (int)(sqlite3CorruptError((int)(68401)));
        goto getAndInitPage_error2;
    }

    return (int)(0);
    getAndInitPage_error2:
        ; releasePage ( ppPage ) ; 
    getAndInitPage_error1:
        ; if  ( ( pCur ) != null ) { pCur . iPage -- ;  pCur . pPage  =  pCur . apPage [ pCur . iPage ] ;  }
    return (int)(rc);
}</function>
  <function>public static int getAutoVacuum(sbyte* z)
{
    int i = 0;
    if ((0) == (sqlite3StrICmp(z, "none")))
        return (int)(0);
    if ((0) == (sqlite3StrICmp(z, "full")))
        return (int)(1);
    if ((0) == (sqlite3StrICmp(z, "incremental")))
        return (int)(2);
    i = (int)(sqlite3Atoi(z));
    return (int)((byte)((((i) &gt;= (0)) &amp;&amp; ((i) &lt;= (2))) ? i : 0));
}</function>
  <function>public static void getCellInfo(BtCursor pCur)
{
    if ((pCur.info.nSize) == (0))
    {
        pCur.curFlags |= (byte)(0x02);
        btreeParseCell(pCur.pPage, (int)(pCur.ix), &amp;pCur.info);
    }
    else
    {
    }
}</function>
  <function>public static int getDigits(sbyte* zDate, sbyte* zFormat)
{
    sbyte* ap;
    int cnt = (int)(0);
    sbyte nextC = 0;
    (__va_start(&amp;ap, zFormat));
    do
    {
        sbyte N = (sbyte)(zFormat[0] - 48);
        sbyte min = (sbyte)(zFormat[1] - 48);
        int val = (int)(0);
        ushort max = 0;
        max = (ushort)(getDigits_aMx[zFormat[2] - 97]);
        nextC = (sbyte)(zFormat[3]);
        val = (int)(0);
        while ((N--) != 0)
        {
            if ((sqlite3CtypeMap[(byte)(*zDate)] &amp; 0x04) == 0)
            {
                goto end_getDigits;
            }

            val = (int)(val * 10 + *zDate - 48);
            zDate++;
        }

        if ((((val) &lt; ((int)(min))) || ((val) &gt; ((int)(max)))) || ((nextC != 0) &amp;&amp; (nextC != *zDate)))
        {
            goto end_getDigits;
        }

        *(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(val);
        zDate++;
        cnt++;
        zFormat += 4;
    }
    while ((nextC) != 0);
    end_getDigits:
        ; ( ( void ) ( ap  =  null ) ) ; 
    return (int)(cnt);
}</function>
  <function>public static double getDoubleArg(PrintfArguments p)
{
    if ((p.nArg) &lt;= (p.nUsed))
        return (double)(0.0);
    return (double)(sqlite3_value_double(p.apArg[p.nUsed++]));
}</function>
  <function>public static long getIntArg(PrintfArguments p)
{
    if ((p.nArg) &lt;= (p.nUsed))
        return (long)(0);
    return (long)(sqlite3_value_int64(p.apArg[p.nUsed++]));
}</function>
  <function>public static int getLockingMode(sbyte* z)
{
    if ((z) != null)
    {
        if ((0) == (sqlite3StrICmp(z, "exclusive")))
            return (int)(1);
        if ((0) == (sqlite3StrICmp(z, "normal")))
            return (int)(0);
    }

    return (int)(-1);
}</function>
  <function>public static int getOverflowPage(BtShared pBt, uint ovfl, MemPage ppPage, uint* pPgnoNext)
{
    uint next = (uint)(0);
    MemPage pPage = null;
    int rc = (int)(0);
    if ((pBt.autoVacuum) != 0)
    {
        uint pgno = 0;
        uint iGuess = (uint)(ovfl + 1);
        byte eType = 0;
        while (((ptrmapPageno((pBt), (uint)(iGuess))) == (iGuess)) || ((iGuess) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
        {
            iGuess++;
        }

        if ((iGuess) &lt;= (btreePagecount(pBt)))
        {
            rc = (int)(ptrmapGet(pBt, (uint)(iGuess), &amp;eType, &amp;pgno));
            if ((((rc) == (0)) &amp;&amp; ((eType) == (4))) &amp;&amp; ((pgno) == (ovfl)))
            {
                next = (uint)(iGuess);
                rc = (int)(101);
            }
        }
    }

    if ((rc) == (0))
    {
        rc = (int)(btreeGetPage(pBt, (uint)(ovfl), pPage, (int)(((ppPage) == (null)) ? 0x02 : 0)));
        if ((rc) == (0))
        {
            next = (uint)(sqlite3Get4byte(pPage.aData));
        }
    }

    *pPgnoNext = (uint)(next);
    if ((ppPage) != null)
    {
        ppPage = pPage;
    }
    else
    {
        releasePage(pPage);
    }

    return (int)((rc) == (101) ? 0 : rc);
}</function>
  <function>public static int getPageError(Pager pPager, uint pgno, PgHdr ppPage, int flags)
{
    ppPage = null;
    return (int)(pPager.errCode);
}</function>
  <function>public static int getPageMMap(Pager pPager, uint pgno, PgHdr ppPage, int flags)
{
    int rc = (int)(0);
    PgHdr pPg = null;
    uint iFrame = (uint)(0);
    int bMmapOk = (int)((((pgno) &gt; (1)) &amp;&amp; (((pPager.eState) == (1)) || ((flags &amp; 0x02) != 0))) ? 1 : 0);
    if (((pgno) &lt;= (1)) &amp;&amp; ((pgno) == (0)))
    {
        return (int)(sqlite3CorruptError((int)(58828)));
    }

    if (((bMmapOk) != 0) &amp;&amp; ((pPager).pWal != null))
    {
        rc = (int)(sqlite3WalFindFrame(pPager.pWal, (uint)(pgno), &amp;iFrame));
        if (rc != 0)
        {
            ppPage = null;
            return (int)(rc);
        }
    }

    if (((bMmapOk) != 0) &amp;&amp; ((iFrame) == (0)))
    {
        void* pData = null;
        rc = (int)(sqlite3OsFetch(pPager.fd, (long)((long)(pgno - 1) * pPager.pageSize), (int)(pPager.pageSize), &amp;pData));
        if (((rc) == (0)) &amp;&amp; ((pData) != null))
        {
            if (((pPager.eState) &gt; (1)) || ((pPager.tempFile) != 0))
            {
                pPg = sqlite3PagerLookup(pPager, (uint)(pgno));
            }

            if ((pPg) == (null))
            {
                rc = (int)(pagerAcquireMapPage(pPager, (uint)(pgno), pData, pPg));
            }
            else
            {
                sqlite3OsUnfetch(pPager.fd, (long)((long)(pgno - 1) * pPager.pageSize), pData);
            }

            if ((pPg) != null)
            {
                ppPage = pPg;
                return (int)(0);
            }
        }

        if (rc != 0)
        {
            ppPage = null;
            return (int)(rc);
        }
    }

    return (int)(getPageNormal(pPager, (uint)(pgno), ppPage, (int)(flags)));
}</function>
  <function>public static int getPageNormal(Pager pPager, uint pgno, PgHdr ppPage, int flags)
{
    int rc = (int)(0);
    PgHdr pPg;
    byte noContent = 0;
    sqlite3_pcache_page* pBase;
    if ((pgno) == (0))
        return (int)(sqlite3CorruptError((int)(58717)));
    pBase = sqlite3PcacheFetch(pPager.pPCache, (uint)(pgno), (int)(3));
    if ((pBase) == (null))
    {
        pPg = null;
        rc = (int)(sqlite3PcacheFetchStress(pPager.pPCache, (uint)(pgno), &amp;pBase));
        if (rc != 0)
            goto pager_acquire_err;
        if ((pBase) == (null))
        {
            rc = (int)(7);
            goto pager_acquire_err;
        }
    }

    pPg = ppPage = sqlite3PcacheFetchFinish(pPager.pPCache, (uint)(pgno), pBase);
    noContent = (byte)((flags &amp; 0x01) != 0);
    if (((pPg.pPager) != null) &amp;&amp; (noContent == 0))
    {
        pPager.aStat[0]++;
        return (int)(0);
    }
    else
    {
        if ((pgno) == ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1)))
        {
            rc = (int)(sqlite3CorruptError((int)(58749)));
            goto pager_acquire_err;
        }

        pPg.pPager = pPager;
        if (((!((pPager.fd).pMethods != null)) || ((pPager.dbSize) &lt; (pgno))) || ((noContent) != 0))
        {
            if ((pgno) &gt; (pPager.mxPgno))
            {
                rc = (int)(13);
                goto pager_acquire_err;
            }

            if ((noContent) != 0)
            {
                sqlite3BeginBenignMalloc();
                if ((pgno) &lt;= (pPager.dbOrigSize))
                {
                    sqlite3BitvecSet(pPager.pInJournal, (uint)(pgno));
                }

                addToSavepointBitvecs(pPager, (uint)(pgno));
                sqlite3EndBenignMalloc();
            }

            CRuntime.memset(pPg.pData, (int)(0), (ulong)(pPager.pageSize));
        }
        else
        {
            pPager.aStat[1]++;
            rc = (int)(readDbPage(pPg));
            if (rc != 0)
            {
                goto pager_acquire_err;
            }
        }
    }

    return (int)(0);
    pager_acquire_err:
        ;
    if ((pPg) != null)
    {
        sqlite3PcacheDrop(pPg);
    }

    pagerUnlockIfUnused(pPager);
    ppPage = null;
    return (int)(rc);
}</function>
  <function>public static int getPageReferenced(IntegrityCk pCheck, uint iPg)
{
    return (int)(pCheck.aPgRef[iPg / 8] &amp; (1 &lt;&lt; (iPg &amp; 0x07)));
}</function>
  <function>public static TriggerPrg getRowTrigger(Parse pParse, Trigger pTrigger, Table pTab, int orconf)
{
    Parse pRoot = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    TriggerPrg pPrg;
    for (pPrg = pRoot.pTriggerPrg; ((pPrg) != null) &amp;&amp; ((pPrg.pTrigger != pTrigger) || (pPrg.orconf != orconf)); pPrg = pPrg.pNext)
    {
    }

    if (pPrg == null)
    {
        pPrg = codeRowTrigger(pParse, pTrigger, pTab, (int)(orconf));
        pParse.db.errByteOffset = (int)(-1);
    }

    return pPrg;
}</function>
  <function>public static byte getSafetyLevel(sbyte* z, int omitFull, byte dflt)
{
    int i = 0; int  n  =  0 ; 
    if ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x04) != 0)
    {
        return (byte)(sqlite3Atoi(z));
    }

    n = (int)(sqlite3Strlen30(z));
    for (i = (int)(0); (i) &lt; ((int)(8 * sizeof(byte) / sizeof(byte))); i++)
    {
        if ((((getSafetyLevel_iLength[i]) == (n)) &amp;&amp; ((sqlite3_strnicmp(&amp;getSafetyLevel_zText[getSafetyLevel_iOffset[i]], z, (int)(n))) == (0))) &amp;&amp; ((omitFull == 0) || ((getSafetyLevel_iValue[i]) &lt;= (1))))
        {
            return (byte)(getSafetyLevel_iValue[i]);
        }
    }

    return (byte)(dflt);
}</function>
  <function>public static int getTempStore(sbyte* z)
{
    if (((z[0]) &gt;= (48)) &amp;&amp; ((z[0]) &lt;= (50)))
    {
        return (int)(z[0] - 48);
    }
    else if ((sqlite3StrICmp(z, "file")) == (0))
    {
        return (int)(1);
    }
    else if ((sqlite3StrICmp(z, "memory")) == (0))
    {
        return (int)(2);
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static sbyte* getTextArg(PrintfArguments p)
{
    if ((p.nArg) &lt;= (p.nUsed))
        return null;
    return (sbyte*)(sqlite3_value_text(p.apArg[p.nUsed++]));
}</function>
  <function>public static int getToken(byte** pz)
{
    byte* z = *pz;
    int t = 0;
    do
    {
        z += sqlite3GetToken(z, &amp;t);
    }
    while ((t) == (183));
    if (((((((t) == (59)) || ((t) == (117))) || ((t) == (118))) || ((t) == (164))) || ((t) == (165))) || ((sqlite3ParserFallback((int)(t))) == (59)))
    {
        t = (int)(59);
    }

    *pz = z;
    return (int)(t);
}</function>
  <function>public static void groupConcatFinalize(sqlite3_context context)
{
    GroupConcatCtx pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(0)));
    if ((pGCC) != null)
    {
        sqlite3ResultStrAccum(context, pGCC.str);
        sqlite3_free(pGCC.pnSepLengths);
    }
}</function>
  <function>public static void groupConcatInverse(sqlite3_context context, int argc, sqlite3_value argv)
{
    GroupConcatCtx pGCC;
    (void)(argc);
    if ((sqlite3_value_type(argv[0])) == (5))
        return;
    pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(sizeof(GroupConcatCtx))));
    if ((pGCC) != null)
    {
        int nVS = 0;
        (void)(sqlite3_value_text(argv[0]));
        nVS = (int)(sqlite3_value_bytes(argv[0]));
        pGCC.nAccum -= (int)(1);
        if (pGCC.pnSepLengths != null)
        {
            if ((pGCC.nAccum) &gt; (0))
            {
                nVS += (int)(*pGCC.pnSepLengths);
                CRuntime.memmove(pGCC.pnSepLengths, pGCC.pnSepLengths + 1, (ulong)((pGCC.nAccum - 1) * sizeof(int)));
            }
        }
        else
        {
            nVS += (int)(pGCC.nFirstSepLength);
        }

        if ((nVS) &gt;= ((int)(pGCC.str.nChar)))
        {
            pGCC.str.nChar = (uint)(0);
        }
        else
        {
            pGCC.str.nChar -= (uint)(nVS);
            CRuntime.memmove(pGCC.str.zText, &amp;pGCC.str.zText[nVS], (ulong)(pGCC.str.nChar));
        }

        if ((pGCC.str.nChar) == (0))
        {
            pGCC.str.mxAlloc = (uint)(0);
            sqlite3_free(pGCC.pnSepLengths);
            pGCC.pnSepLengths = null;
        }
    }
}</function>
  <function>public static void groupConcatStep(sqlite3_context context, int argc, sqlite3_value argv)
{
    sbyte* zVal;
    GroupConcatCtx pGCC;
    sbyte* zSep;
    int nVal = 0; int  nSep  =  0 ; 
    if ((sqlite3_value_type(argv[0])) == (5))
        return;
    pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(sizeof(GroupConcatCtx))));
    if ((pGCC) != null)
    {
        sqlite3 db = sqlite3_context_db_handle(context);
        int firstTerm = (int)((pGCC.str.mxAlloc) == (0) ? 1 : 0);
        pGCC.str.mxAlloc = (uint)(db.aLimit[0]);
        if ((argc) == (1))
        {
            if (firstTerm == 0)
            {
                sqlite3_str_appendchar(pGCC.str, (int)(1), (sbyte)(44));
            }
            else
            {
                pGCC.nFirstSepLength = (int)(1);
            }
        }
        else if (firstTerm == 0)
        {
            zSep = (sbyte*)(sqlite3_value_text(argv[1]));
            nSep = (int)(sqlite3_value_bytes(argv[1]));
            if ((zSep) != null)
            {
                sqlite3_str_append(pGCC.str, zSep, (int)(nSep));
            }
            else
            {
                nSep = (int)(0);
            }

            if ((nSep != pGCC.nFirstSepLength) || (pGCC.pnSepLengths != null))
            {
                int* pnsl = pGCC.pnSepLengths;
                if ((pnsl) == (null))
                {
                    pnsl = (int*)(sqlite3_malloc64((ulong)((pGCC.nAccum + 1) * sizeof(int))));
                    if (pnsl != null)
                    {
                        int i = (int)(0);
                        int nA = (int)(pGCC.nAccum - 1);
                        while ((i) &lt; (nA))
                        {
                            pnsl[i++] = (int)(pGCC.nFirstSepLength);
                        }
                    }
                }
                else
                {
                    pnsl = (int*)(sqlite3_realloc64(pnsl, (ulong)(pGCC.nAccum * sizeof(int))));
                }

                if (pnsl != null)
                {
                    if (((pGCC.nAccum) &gt; (0)))
                    {
                        pnsl[pGCC.nAccum - 1] = (int)(nSep);
                    }

                    pGCC.pnSepLengths = pnsl;
                }
                else
                {
                    sqlite3StrAccumSetError(pGCC.str, (byte)(7));
                }
            }
        }
        else
        {
            pGCC.nFirstSepLength = (int)(sqlite3_value_bytes(argv[1]));
        }

        pGCC.nAccum += (int)(1);
        zVal = (sbyte*)(sqlite3_value_text(argv[0]));
        nVal = (int)(sqlite3_value_bytes(argv[0]));
        if ((zVal) != null)
            sqlite3_str_append(pGCC.str, zVal, (int)(nVal));
    }
}</function>
  <function>public static void groupConcatValue(sqlite3_context context)
{
    GroupConcatCtx pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(0)));
    if ((pGCC) != null)
    {
        sqlite3_str pAccum = pGCC.str;
        if ((pAccum.accError) == (18))
        {
            sqlite3_result_error_toobig(context);
        }
        else if ((pAccum.accError) == (7))
        {
            sqlite3_result_error_nomem(context);
        }
        else
        {
            sbyte* zText = sqlite3_str_value(pAccum);
            sqlite3_result_text(context, zText, (int)(pAccum.nChar), ((Void(Void * ))(-1)));
        }
    }
}</function>
  <function>public static int growOp3(Vdbe p, int op, int p1, int p2, int p3)
{
    if ((growOpArray(p, (int)(1))) != 0)
        return (int)(1);
    return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
}</function>
  <function>public static int growOpArray(Vdbe v, int nOp)
{
    VdbeOp* pNew;
    Parse p = v.pParse;
    long nNew = (long)((v.nOpAlloc) != 0 ? 2 * (long)(v.nOpAlloc) : (long)(1024 / sizeof(VdbeOp)));
    if ((nNew) &gt; (p.db.aLimit[5]))
    {
        sqlite3OomFault(p.db);
        return (int)(7);
    }

    pNew = sqlite3DbRealloc(p.db, v.aOp, (ulong)(nNew * sizeof(VdbeOp)));
    if ((pNew) != null)
    {
        p.szOpAlloc = (int)(sqlite3DbMallocSize(p.db, pNew));
        v.nOpAlloc = (int)(p.szOpAlloc / sizeof(VdbeOp));
        v.aOp = pNew;
    }

    return (int)(pNew ? 0 : 7);
}</function>
  <function>public static int growVTrans(sqlite3 db)
{
    int ARRAY_INCR = (int)(5);
    if ((db.nVTrans % ARRAY_INCR) == (0))
    {
        VTable aVTrans;
        long nBytes = (long)(sizeof(sqlite3_vtab) * ((long)(db.nVTrans) + ARRAY_INCR));
        aVTrans = sqlite3DbRealloc(db, (void*)(db.aVTrans), (ulong)(nBytes));
        if (aVTrans == null)
        {
            return (int)(7);
        }

        CRuntime.memset(aVTrans[db.nVTrans], (int)(0), (ulong)(sizeof(sqlite3_vtab) * ARRAY_INCR));
        db.aVTrans = aVTrans;
    }

    return (int)(0);
}</function>
  <function>public static int handleMovedCursor(VdbeCursor p)
{
    int isDifferentRow = 0; int  rc  =  0 ; 
    rc = (int)(sqlite3BtreeCursorRestore(p.uc.pCursor, &amp;isDifferentRow));
    p.cacheStatus = (uint)(0);
    if ((isDifferentRow) != 0)
        p.nullRow = (byte)(1);
    return (int)(rc);
}</function>
  <function>public static int hasAnchor(Select p)
{
    while (((p) != null) &amp;&amp; ((p.selFlags &amp; 0x0002000) != 0))
    {
        p = p.pPrior;
    }

    return (int)(p != null);
}</function>
  <function>public static int hasColumn(short* aiCol, int nCol, int x)
{
    while ((nCol--) &gt; (0))
    {
        if ((x) == (*(aiCol++)))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int hasHotJournal(Pager pPager, int* pExists)
{
    sqlite3_vfs pVfs = pPager.pVfs;
    int rc = (int)(0);
    int exists = (int)(1);
    int jrnlOpen = (int)(!!((pPager.jfd).pMethods != null));
    *pExists = (int)(0);
    if (jrnlOpen == 0)
    {
        rc = (int)(sqlite3OsAccess(pVfs, pPager.zJournal, (int)(0), &amp;exists));
    }

    if (((rc) == (0)) &amp;&amp; ((exists) != 0))
    {
        int locked = (int)(0);
        rc = (int)(sqlite3OsCheckReservedLock(pPager.fd, &amp;locked));
        if (((rc) == (0)) &amp;&amp; (locked == 0))
        {
            uint nPage = 0;
            rc = (int)(pagerPagecount(pPager, &amp;nPage));
            if ((rc) == (0))
            {
                if (((nPage) == (0)) &amp;&amp; (jrnlOpen == 0))
                {
                    sqlite3BeginBenignMalloc();
                    if ((pagerLockDb(pPager, (int)(2))) == (0))
                    {
                        sqlite3OsDelete(pVfs, pPager.zJournal, (int)(0));
                        if (pPager.exclusiveMode == 0)
                            pagerUnlockDb(pPager, (int)(1));
                    }

                    sqlite3EndBenignMalloc();
                }
                else
                {
                    if (jrnlOpen == 0)
                    {
                        int f = (int)(0x00000001 | 0x00000800);
                        rc = (int)(sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, (int)(f), &amp;f));
                    }

                    if ((rc) == (0))
                    {
                        byte first = (byte)(0);
                        rc = (int)(sqlite3OsRead(pPager.jfd, (void*)(&amp;first), (int)(1), (long)(0)));
                        if ((rc) == (10 | (2 &lt;&lt; 8)))
                        {
                            rc = (int)(0);
                        }

                        if (jrnlOpen == 0)
                        {
                            sqlite3OsClose(pPager.jfd);
                        }

                        *pExists = (int)(first != 0);
                    }
                    else if ((rc) == (14))
                    {
                        *pExists = (int)(1);
                        rc = (int)(0);
                    }
                }
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static void havingToWhere(Parse pParse, Select p)
{
    Walker sWalker = new Walker();
    CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
    sWalker.pParse = pParse;
    sWalker.xExprCallback = havingToWhereExprCb;
    sWalker.u.pSelect = p;
    sqlite3WalkExpr(sWalker, p.pHaving);
}</function>
  <function>public static int havingToWhereExprCb(Walker pWalker, Expr pExpr)
{
    if (pExpr.op != 44)
    {
        Select pS = pWalker.u.pSelect;
        if ((((sqlite3ExprIsConstantOrGroupBy(pWalker.pParse, pExpr, pS.pGroupBy)) != 0) &amp;&amp; ((((pExpr).flags &amp; (0x000001 | 0x20000000)) == (0x20000000)) == (0))) &amp;&amp; ((pExpr.pAggInfo) == (null)))
        {
            sqlite3 db = pWalker.pParse.db;
            Expr pNew = sqlite3Expr(db, (int)(155), "1");
            if ((pNew) != null)
            {
                Expr pWhere = pS.pWhere;
                {
                    Expr t = (Expr)(pNew);
                    pNew = (Expr)(pExpr);
                    pExpr = (Expr)(t);
                }

                pNew = sqlite3ExprAnd(pWalker.pParse, pWhere, pNew);
                pS.pWhere = pNew;
                pWalker.eCode = (ushort)(1);
            }
        }

        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void heightOfExpr(Expr p, int* pnHeight)
{
    if ((p) != null)
    {
        if ((p.nHeight) &gt; (*pnHeight))
        {
            *pnHeight = (int)(p.nHeight);
        }
    }
}</function>
  <function>public static void heightOfExprList(ExprList p, int* pnHeight)
{
    if ((p) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (p.nExpr); i++)
        {
            heightOfExpr(p.a[i].pExpr, pnHeight);
        }
    }
}</function>
  <function>public static void heightOfSelect(Select pSelect, int* pnHeight)
{
    Select p;
    for (p = pSelect; p; p = p.pPrior)
    {
        heightOfExpr(p.pWhere, pnHeight);
        heightOfExpr(p.pHaving, pnHeight);
        heightOfExpr(p.pLimit, pnHeight);
        heightOfExprList(p.pEList, pnHeight);
        heightOfExprList(p.pGroupBy, pnHeight);
        heightOfExprList(p.pOrderBy, pnHeight);
    }
}</function>
  <function>public static void hexFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    int i = 0; int  n  =  0 ; 
    byte* pBlob;
    sbyte* zHex; sbyte  * z ; 
    pBlob = sqlite3_value_blob(argv[0]);
    n = (int)(sqlite3_value_bytes(argv[0]));
    z = zHex = contextMalloc(context, (long)(((long)(n)) * 2 + 1));
    if ((zHex) != null)
    {
        for (i = (int)(0); (i) &lt; (n); i++, pBlob++)
        {
            byte c = (byte)(*pBlob);
            *(z++) = (sbyte)(hexdigits[(c &gt;&gt; 4) &amp; 0xf]);
            *(z++) = (sbyte)(hexdigits[c &amp; 0xf]);
        }

        *z = (sbyte)(0);
        sqlite3_result_text(context, zHex, (int)(n * 2), sqlite3_free);
    }
}</function>
  <function>public static int identLength(sbyte* z)
{
    int n = 0;
    for (n = (int)(0); *z; n++, z++)
    {
        if ((*z) == (34))
        {
            n++;
        }
    }

    return (int)(n + 2);
}</function>
  <function>public static void identPut(sbyte* z, int* pIdx, sbyte* zSignedIdent)
{
    byte* zIdent = (byte*)(zSignedIdent);
    int i = 0; int  j  =  0 ;  int  needQuote  =  0 ; 
    i = (int)(*pIdx);
    for (j = (int)(0); zIdent[j]; j++)
    {
        if (((sqlite3CtypeMap[(zIdent[j])] &amp; 0x06) == 0) &amp;&amp; (zIdent[j] != 95))
            break;
    }

    needQuote = (int)(((((sqlite3CtypeMap[(zIdent[0])] &amp; 0x04) != 0) || (sqlite3KeywordCode(zIdent, (int)(j)) != 59)) || (zIdent[j] != 0)) || ((j) == (0)) ? 1 : 0);
    if ((needQuote) != 0)
        z[i++] = (sbyte)(34);
    for (j = (int)(0); zIdent[j]; j++)
    {
        z[i++] = (sbyte)(zIdent[j]);
        if ((zIdent[j]) == (34))
            z[i++] = (sbyte)(34);
    }

    if ((needQuote) != 0)
        z[i++] = (sbyte)(34);
    z[i] = (sbyte)(0);
    *pIdx = (int)(i);
}</function>
  <function>public static int impliesNotNullRow(Walker pWalker, Expr pExpr)
{
    if ((((pExpr).flags &amp; (0x000001)) != 0))
        return (int)(1);
    switch (pExpr.op)
    {
        case 171:
        case 50:
        case 51:
        case 45:
        case 43:
        case 177:
        case 157:
        case 49:
        case 172:
        case 175:
            ;
            return (int)(1);
        case 167:
            if ((pWalker.u.iCur) == (pExpr.iTable))
            {
                pWalker.eCode = (ushort)(1);
                return (int)(2);
            }

            return (int)(1);
        case 44:
            if ((pWalker.eCode) == (0))
            {
                sqlite3WalkExpr(pWalker, pExpr.pLeft);
                if ((pWalker.eCode) != 0)
                {
                    pWalker.eCode = (ushort)(0);
                    sqlite3WalkExpr(pWalker, pExpr.pRight);
                }
            }

            return (int)(1);
        case 48:
            if ((sqlite3WalkExpr(pWalker, pExpr.pLeft)) == (2))
            {
                return (int)(2);
            }

            return (int)(1);
        case 53:
        case 52:
        case 56:
        case 55:
        case 54:
        case 57:
        {
            Expr pLeft = pExpr.pLeft;
            Expr pRight = pExpr.pRight;
            if (((((pLeft.op) == (167)) &amp;&amp; (pLeft.y.pTab != null)) &amp;&amp; (((pLeft.y.pTab).eTabType) == (1))) || ((((pRight.op) == (167)) &amp;&amp; (pRight.y.pTab != null)) &amp;&amp; (((pRight.y.pTab).eTabType) == (1))))
            {
                return (int)(1);
            }
        }

        default:
            return (int)(0);
    }
}</function>
  <function>public static int incrAggDepth(Walker pWalker, Expr pExpr)
{
    if ((pExpr.op) == (168))
        pExpr.op2 += (byte)(pWalker.u.n);
    return (int)(0);
}</function>
  <function>public static void incrAggFunctionDepth(Expr pExpr, int N)
{
    if ((N) &gt; (0))
    {
        Walker w = new Walker();
        CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
        w.xExprCallback = incrAggDepth;
        w.u.n = (int)(N);
        sqlite3WalkExpr(w, pExpr);
    }
}</function>
  <function>public static int incrVacuumStep(BtShared pBt, uint nFin, uint iLastPg, int bCommit)
{
    uint nFreeList = 0;
    int rc = 0;
    if ((!((ptrmapPageno((pBt), (uint)(iLastPg))) == (iLastPg))) &amp;&amp; (iLastPg != ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
    {
        byte eType = 0;
        uint iPtrPage = 0;
        nFreeList = (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[36]));
        if ((nFreeList) == (0))
        {
            return (int)(101);
        }

        rc = (int)(ptrmapGet(pBt, (uint)(iLastPg), &amp;eType, &amp;iPtrPage));
        if (rc != 0)
        {
            return (int)(rc);
        }

        if ((eType) == (1))
        {
            return (int)(sqlite3CorruptError((int)(69993)));
        }

        if ((eType) == (2))
        {
            if ((bCommit) == (0))
            {
                uint iFreePg = 0;
                MemPage pFreePg;
                rc = (int)(allocateBtreePage(pBt, pFreePg, &amp;iFreePg, (uint)(iLastPg), (byte)(1)));
                if (rc != 0)
                {
                    return (int)(rc);
                }

                releasePage(pFreePg);
            }
        }
        else
        {
            uint iFreePg = 0;
            MemPage pLastPg;
            byte eMode = (byte)(0);
            uint iNear = (uint)(0);
            rc = (int)(btreeGetPage(pBt, (uint)(iLastPg), pLastPg, (int)(0)));
            if (rc != 0)
            {
                return (int)(rc);
            }

            if ((bCommit) == (0))
            {
                eMode = (byte)(2);
                iNear = (uint)(nFin);
            }

            do
            {
                MemPage pFreePg;
                rc = (int)(allocateBtreePage(pBt, pFreePg, &amp;iFreePg, (uint)(iNear), (byte)(eMode)));
                if (rc != 0)
                {
                    releasePage(pLastPg);
                    return (int)(rc);
                }

                releasePage(pFreePg);
            }
            while (((bCommit) != 0) &amp;&amp; ((iFreePg) &gt; (nFin)));
            rc = (int)(relocatePage(pBt, pLastPg, (byte)(eType), (uint)(iPtrPage), (uint)(iFreePg), (int)(bCommit)));
            releasePage(pLastPg);
            if (rc != 0)
            {
                return (int)(rc);
            }
        }
    }

    if ((bCommit) == (0))
    {
        do
        {
            iLastPg--;
        }
        while (((iLastPg) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) || ((ptrmapPageno((pBt), (uint)(iLastPg))) == (iLastPg)));
        pBt.bDoTruncate = (byte)(1);
        pBt.nPage = (uint)(iLastPg);
    }

    return (int)(0);
}</function>
  <function>public static int indexColumnIsBeingUpdated(Index pIdx, int iCol, int* aXRef, int chngRowid)
{
    short iIdxCol = (short)(pIdx.aiColumn[iCol]);
    if ((iIdxCol) &gt;= (0))
    {
        return ((aXRef[iIdxCol]) &gt;= (0) ? 1 : 0);
    }

    return (int)(sqlite3ExprReferencesUpdatedColumn(pIdx.aColExpr.a[iCol].pExpr, aXRef, (int)(chngRowid)));
}</function>
  <function>public static int indexColumnNotNull(Index pIdx, int iCol)
{
    int j = 0;
    j = (int)(pIdx.aiColumn[iCol]);
    if ((j) &gt;= (0))
    {
        return (int)(pIdx.pTable.aCol[j].notNull);
    }
    else if ((j) == (-1))
    {
        return (int)(1);
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static Index indexIteratorFirst(IndexIterator* pIter, int* pIx)
{
    if ((pIter-&gt;eType) != 0)
    {
        *pIx = (int)(pIter-&gt;u.ax.aIdx[0].ix);
        return pIter-&gt;u.ax.aIdx[0].p;
    }
    else
    {
        *pIx = (int)(0);
        return pIter-&gt;u.lx.pIdx;
    }
}</function>
  <function>public static Index indexIteratorNext(IndexIterator* pIter, int* pIx)
{
    if ((pIter-&gt;eType) != 0)
    {
        int i = (int)(++pIter-&gt;i);
        if ((i) &gt;= (pIter-&gt;u.ax.nIdx))
        {
            *pIx = (int)(i);
            return null;
        }

        *pIx = (int)(pIter-&gt;u.ax.aIdx[i].ix);
        return pIter-&gt;u.ax.aIdx[i].p;
    }
    else
    {
        ++(*pIx);
        pIter-&gt;u.lx.pIdx = pIter-&gt;u.lx.pIdx.pNext;
        return pIter-&gt;u.lx.pIdx;
    }
}</function>
  <function>public static int indexMightHelpWithOrderBy(WhereLoopBuilder pBuilder, Index pIndex, int iCursor)
{
    ExprList pOB;
    ExprList aColExpr;
    int ii = 0; int  jj  =  0 ; 
    if ((pIndex.bUnordered) != 0)
        return (int)(0);
    if ((pOB = pBuilder.pWInfo.pOrderBy) == (null))
        return (int)(0);
    for (ii = (int)(0); (ii) &lt; (pOB.nExpr); ii++)
    {
        Expr pExpr = sqlite3ExprSkipCollateAndLikely(pOB.a[ii].pExpr);
        if (((pExpr) == (null)))
            continue;
        if (((pExpr.op) == (167)) &amp;&amp; ((pExpr.iTable) == (iCursor)))
        {
            if ((pExpr.iColumn) &lt; (0))
                return (int)(1);
            for (jj = (int)(0); (jj) &lt; (pIndex.nKeyCol); jj++)
            {
                if ((pExpr.iColumn) == (pIndex.aiColumn[jj]))
                    return (int)(1);
            }
        }
        else if ((aColExpr = pIndex.aColExpr) != null)
        {
            for (jj = (int)(0); (jj) &lt; (pIndex.nKeyCol); jj++)
            {
                if (pIndex.aiColumn[jj] != (-2))
                    continue;
                if ((sqlite3ExprCompareSkip(pExpr, aColExpr.a[jj].pExpr, (int)(iCursor))) == (0))
                {
                    return (int)(1);
                }
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int indexWhereClauseMightChange(Index pIdx, int* aXRef, int chngRowid)
{
    if ((pIdx.pPartIdxWhere) == (null))
        return (int)(0);
    return (int)(sqlite3ExprReferencesUpdatedColumn(pIdx.pPartIdxWhere, aXRef, (int)(chngRowid)));
}</function>
  <function>public static void initMemArray(sqlite3_value p, int N, sqlite3 db, ushort flags)
{
    while ((N--) &gt; (0))
    {
        p.db = db;
        p.flags = (ushort)(flags);
        p.szMalloc = (int)(0);
        p++;
    }
}</function>
  <function>public static void innerLoopLoadRow(Parse pParse, Select pSelect, RowLoadInfo* pInfo)
{
    sqlite3ExprCodeExprList(pParse, pSelect.pEList, (int)(pInfo-&gt;regResult), (int)(0), (byte)(pInfo-&gt;ecelFlags));
}</function>
  <function>public static void insertCell(MemPage pPage, int i, byte* pCell, int sz, byte* pTemp, uint iChild, int* pRC)
{
    int idx = (int)(0);
    int j = 0;
    byte* data;
    byte* pIns;
    if (((pPage.nOverflow) != 0) || ((sz + 2) &gt; (pPage.nFree)))
    {
        if ((pTemp) != null)
        {
            CRuntime.memcpy(pTemp, pCell, (ulong)(sz));
            pCell = pTemp;
        }

        if ((iChild) != 0)
        {
            sqlite3Put4byte(pCell, (uint)(iChild));
        }

        j = (int)(pPage.nOverflow++);
        pPage.apOvfl[j] = pCell;
        pPage.aiOvfl[j] = ((ushort)(i));
    }
    else
    {
        int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
        if (rc != 0)
        {
            *pRC = (int)(rc);
            return;
        }

        data = pPage.aData;
        rc = (int)(allocateSpace(pPage, (int)(sz), &amp;idx));
        if ((rc) != 0)
        {
            *pRC = (int)(rc);
            return;
        }

        pPage.nFree -= (int)((ushort)(2 + sz));
        if ((iChild) != 0)
        {
            CRuntime.memcpy(&amp;data[idx + 4], pCell + 4, (ulong)(sz - 4));
            sqlite3Put4byte(&amp;data[idx], (uint)(iChild));
        }
        else
        {
            CRuntime.memcpy(&amp;data[idx], pCell, (ulong)(sz));
        }

        pIns = pPage.aCellIdx + i * 2;
        CRuntime.memmove(pIns + 2, pIns, (ulong)(2 * (pPage.nCell - i)));
        ((pIns)[0] = ((byte)((idx) &gt;&gt; 8)), (pIns)[1] = ((byte)(idx)));
        pPage.nCell++;
        if ((++data[pPage.hdrOffset + 4]) == (0))
            data[pPage.hdrOffset + 3]++;
        if ((pPage.pBt.autoVacuum) != 0)
        {
            ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);
        }
    }
}</function>
  <function>public static void insertElement(Hash* pH, _ht* pEntry, HashElem* pNew)
{
    HashElem* pHead;
    if ((pEntry) != null)
    {
        pHead = (pEntry-&gt;count) != 0 ? pEntry-&gt;chain : null;
        pEntry-&gt;count++;
        pEntry-&gt;chain = pNew;
    }
    else
    {
        pHead = null;
    }

    if ((pHead) != null)
    {
        pNew-&gt;next = pHead;
        pNew-&gt;prev = pHead-&gt;prev;
        if ((pHead-&gt;prev) != null)
        {
            pHead-&gt;prev-&gt;next = pNew;
        }
        else
        {
            pH-&gt;first = pNew;
        }

        pHead-&gt;prev = pNew;
    }
    else
    {
        pNew-&gt;next = pH-&gt;first;
        if ((pH-&gt;first) != null)
        {
            pH-&gt;first-&gt;prev = pNew;
        }

        pNew-&gt;prev = null;
        pH-&gt;first = pNew;
    }
}</function>
  <function>public static void instrFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* zHaystack;
    byte* zNeedle;
    int nHaystack = 0;
    int nNeedle = 0;
    int typeHaystack = 0; int  typeNeedle  =  0 ; 
    int N = (int)(1);
    int isText = 0;
    byte firstChar = 0;
    sqlite3_value pC1 = null;
    sqlite3_value pC2 = null;
    typeHaystack = (int)(sqlite3_value_type(argv[0]));
    typeNeedle = (int)(sqlite3_value_type(argv[1]));
    if (((typeHaystack) == (5)) || ((typeNeedle) == (5)))
        return;
    nHaystack = (int)(sqlite3_value_bytes(argv[0]));
    nNeedle = (int)(sqlite3_value_bytes(argv[1]));
    if ((nNeedle) &gt; (0))
    {
        if (((typeHaystack) == (4)) &amp;&amp; ((typeNeedle) == (4)))
        {
            zHaystack = sqlite3_value_blob(argv[0]);
            zNeedle = sqlite3_value_blob(argv[1]);
            isText = (int)(0);
        }
        else if ((typeHaystack != 4) &amp;&amp; (typeNeedle != 4))
        {
            zHaystack = sqlite3_value_text(argv[0]);
            zNeedle = sqlite3_value_text(argv[1]);
            isText = (int)(1);
        }
        else
        {
            pC1 = sqlite3_value_dup(argv[0]);
            zHaystack = sqlite3_value_text(pC1);
            if ((zHaystack) == (null))
                goto endInstrOOM;
            nHaystack = (int)(sqlite3_value_bytes(pC1));
            pC2 = sqlite3_value_dup(argv[1]);
            zNeedle = sqlite3_value_text(pC2);
            if ((zNeedle) == (null))
                goto endInstrOOM;
            nNeedle = (int)(sqlite3_value_bytes(pC2));
            isText = (int)(1);
        }

        if (((zNeedle) == (null)) || (((nHaystack) != 0) &amp;&amp; ((zHaystack) == (null))))
            goto endInstrOOM;
        firstChar = (byte)(zNeedle[0]);
        while (((nNeedle) &lt;= (nHaystack)) &amp;&amp; ((zHaystack[0] != firstChar) || (memcmp(zHaystack, zNeedle, (ulong)(nNeedle)) != 0)))
        {
            N++;
            do
            {
                nHaystack--;
                zHaystack++;
            }
            while (((isText) != 0) &amp;&amp; ((zHaystack[0] &amp; 0xc0) == (0x80)));
        }

        if ((nNeedle) &gt; (nHaystack))
            N = (int)(0);
    }

    sqlite3_result_int(context, (int)(N));
    endInstr:
        ; sqlite3_value_free ( pC1 ) ; 
    sqlite3_value_free(pC2);
    return;
    endInstrOOM:
        ; sqlite3_result_error_nomem ( context ) ; 
    goto endInstr;
}</function>
  <function>public static int integrityCheckResultRow(Vdbe v)
{
    int addr = 0;
    sqlite3VdbeAddOp2(v, (int)(83), (int)(3), (int)(1));
    addr = (int)(sqlite3VdbeAddOp3(v, (int)(49), (int)(1), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(1)));
    sqlite3VdbeAddOp0(v, (int)(70));
    return (int)(addr);
}</function>
  <function>public static void invalidateAllOverflowCache(BtShared pBt)
{
    BtCursor p;
    for (p = pBt.pCursor; p; p = p.pNext)
    {
        (p.curFlags &amp;= (byte)(~0x04));
    }
}</function>
  <function>public static void invalidateIncrblobCursors(Btree pBtree, uint pgnoRoot, long iRow, int isClearTable)
{
    BtCursor p;
    pBtree.hasIncrblobCur = (byte)(0);
    for (p = pBtree.pBt.pCursor; p; p = p.pNext)
    {
        if ((p.curFlags &amp; 0x10) != 0)
        {
            pBtree.hasIncrblobCur = (byte)(1);
            if (((p.pgnoRoot) == (pgnoRoot)) &amp;&amp; (((isClearTable) != 0) || ((p.info.nKey) == (iRow))))
            {
                p.eState = (byte)(1);
            }
        }
    }
}</function>
  <function>public static int invalidateTempStorage(Parse pParse)
{
    sqlite3 db = pParse.db;
    if (db.aDb[1].pBt != null)
    {
        if ((db.autoCommit == 0) || (sqlite3BtreeTxnState(db.aDb[1].pBt) != 0))
        {
            sqlite3ErrorMsg(pParse, "temporary storage cannot be changed from within a transaction");
            return (int)(1);
        }

        sqlite3BtreeClose(db.aDb[1].pBt);
        db.aDb[1].pBt = null;
        sqlite3ResetAllSchemasOfConnection(db);
    }

    return (int)(0);
}</function>
  <function>public static void invokeProfileCallback(sqlite3 db, Vdbe p)
{
    long iNow = 0;
    long iElapse = 0;
    sqlite3OsCurrentTimeInt64(db.pVfs, &amp;iNow);
    iElapse = (long)((iNow - p.startTime) * 1000000);
    if ((db.xProfile) != null)
    {
        db.xProfile(db.pProfileArg, p.zSql, (ulong)(iElapse));
    }

    if ((db.mTrace &amp; 0x02) != 0)
    {
        db.trace.xV2((uint)(0x02), db.pTraceArg, p, (void*)(&amp;iElapse));
    }

    p.startTime = (long)(0);
}</function>
  <function>public static int invokeValueDestructor(void* p, delegate17 xDel, sqlite3_context pCtx)
{
    if ((xDel) == (null))
    {
    }
    else if ((xDel) == ((Void(Void * ))(-1)))
    {
    }
    else
    {
        xDel(p);
    }

    sqlite3_result_error_toobig(pCtx);
    return (int)(18);
}</function>
  <function>public static int isAllZero(sbyte* z, int n)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (n); i++)
    {
        if ((z[i]) != 0)
            return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static int isAlterableTable(Parse pParse, Table pTab)
{
    if ((((0) == (sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7)))) || ((pTab.tabFlags &amp; 0x00008000) != 0)) || (((pTab.tabFlags &amp; 0x00001000) != 0) &amp;&amp; ((sqlite3ReadOnlyShadowTables(pParse.db)) != 0)))
    {
        sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab.zName);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int isAsteriskTerm(Parse pParse, Expr pTerm)
{
    if ((pTerm.op) == (180))
        return (int)(1);
    if (pTerm.op != 141)
        return (int)(0);
    if (pTerm.pRight.op != 180)
        return (int)(0);
    sqlite3ErrorMsg(pParse, "RETURNING may not use \"TABLE.*\" wildcards");
    return (int)(1);
}</function>
  <function>public static int isAuxiliaryVtabOperator(sqlite3 db, Expr pExpr, byte* peOp2, Expr ppLeft, Expr ppRight)
{
    if ((pExpr.op) == (172))
    {
        ExprList pList;
        Expr pCol;
        int i = 0;
        pList = pExpr.x.pList;
        if (((pList) == (null)) || (pList.nExpr != 2))
        {
            return (int)(0);
        }

        pCol = pList.a[1].pExpr;
        if ((((((pCol).op) == (167)) &amp;&amp; ((pCol).y.pTab != null)) &amp;&amp; (((pCol).y.pTab.eTabType) == (1))))
        {
            for (i = (int)(0); (i) &lt; ((int)(4 * sizeof(Op2) / sizeof(Op2))); i++)
            {
                if ((sqlite3StrICmp(pExpr.u.zToken, isAuxiliaryVtabOperator_aOp[i].zOp)) == (0))
                {
                    *peOp2 = (byte)(isAuxiliaryVtabOperator_aOp[i].eOp2);
                    ppRight = pList.a[0].pExpr;
                    ppLeft = pCol;
                    return (int)(1);
                }
            }
        }

        pCol = pList.a[0].pExpr;
        if ((((((pCol).op) == (167)) &amp;&amp; ((pCol).y.pTab != null)) &amp;&amp; (((pCol).y.pTab.eTabType) == (1))))
        {
            sqlite3_vtab pVtab;
            sqlite3_module pMod;
            delegate68 xNotUsed;
            void* pNotUsed;
            pVtab = sqlite3GetVTable(db, pCol.y.pTab).pVtab;
            pMod = pVtab.pModule;
            if (pMod.xFindFunction != null)
            {
                i = (int)(pMod.xFindFunction(pVtab, (int)(2), pExpr.u.zToken, &amp;xNotUsed, &amp;pNotUsed));
                if ((i) &gt;= (150))
                {
                    *peOp2 = (byte)(i);
                    ppRight = pList.a[1].pExpr;
                    ppLeft = pCol;
                    return (int)(1);
                }
            }
        }
    }
    else if ((((pExpr.op) == (52)) || ((pExpr.op) == (171))) || ((pExpr.op) == (51)))
    {
        int res = (int)(0);
        Expr pLeft = pExpr.pLeft;
        Expr pRight = pExpr.pRight;
        if ((((((pLeft).op) == (167)) &amp;&amp; ((pLeft).y.pTab != null)) &amp;&amp; (((pLeft).y.pTab.eTabType) == (1))))
        {
            res++;
        }

        if (((pRight) != null) &amp;&amp; (((((pRight).op) == (167)) &amp;&amp; ((pRight).y.pTab != null)) &amp;&amp; (((pRight).y.pTab.eTabType) == (1))))
        {
            res++;
            {
                Expr t = pLeft;
                pLeft = pRight;
                pRight = t;
            }
        }

        ppLeft = pLeft;
        ppRight = pRight;
        if ((pExpr.op) == (52))
            *peOp2 = (byte)(68);
        if ((pExpr.op) == (171))
            *peOp2 = (byte)(69);
        if ((pExpr.op) == (51))
            *peOp2 = (byte)(70);
        return (int)(res);
    }

    return (int)(0);
}</function>
  <function>public static Select isCandidateForInOpt(Expr pX)
{
    Select p;
    SrcList pSrc;
    ExprList pEList;
    Table pTab;
    int i = 0;
    if (!(((pX).flags &amp; 0x000800) != 0))
        return null;
    if ((((pX).flags &amp; (0x000020)) != 0))
        return null;
    p = pX.x.pSelect;
    if ((p.pPrior) != null)
        return null;
    if ((p.selFlags &amp; (0x0000001 | 0x0000008)) != 0)
    {
        return null;
    }

    if ((p.pLimit) != null)
        return null;
    if ((p.pWhere) != null)
        return null;
    pSrc = p.pSrc;
    if (pSrc.nSrc != 1)
        return null;
    if ((pSrc.a[0].pSelect) != null)
        return null;
    pTab = pSrc.a[0].pTab;
    if ((((pTab).eTabType) == (1)))
        return null;
    pEList = p.pEList;
    for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
    {
        Expr pRes = pEList.a[i].pExpr;
        if (pRes.op != 167)
            return null;
    }

    return p;
}</function>
  <function>public static int isDate(sqlite3_context context, int argc, sqlite3_value argv, DateTime* p)
{
    int i = 0; int  n  =  0 ; 
    byte* z;
    int eType = 0;
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
    if ((argc) == (0))
    {
        if (sqlite3NotPureFunc(context) == 0)
            return (int)(1);
        return (int)(setDateTimeToCurrent(context, p));
    }

    if (((eType = (int)(sqlite3_value_type(argv[0]))) == (2)) || ((eType) == (1)))
    {
        setRawDateNumber(p, (double)(sqlite3_value_double(argv[0])));
    }
    else
    {
        z = sqlite3_value_text(argv[0]);
        if ((z == null) || ((parseDateOrTime(context, (sbyte*)(z), p)) != 0))
        {
            return (int)(1);
        }
    }

    for (i = (int)(1); (i) &lt; (argc); i++)
    {
        z = sqlite3_value_text(argv[i]);
        n = (int)(sqlite3_value_bytes(argv[i]));
        if (((z) == (null)) || ((parseModifier(context, (sbyte*)(z), (int)(n), p, (int)(i))) != 0))
            return (int)(1);
    }

    computeJD(p);
    if (((p-&gt;isError) != 0) || (validJulianDay((long)(p-&gt;iJD)) == 0))
        return (int)(1);
    return (int)(0);
}</function>
  <function>public static int isDistinctRedundant(Parse pParse, SrcList pTabList, WhereClause pWC, ExprList pDistinct)
{
    Table pTab;
    Index pIdx;
    int i = 0;
    int iBase = 0;
    if (pTabList.nSrc != 1)
        return (int)(0);
    iBase = (int)(pTabList.a[0].iCursor);
    pTab = pTabList.a[0].pTab;
    for (i = (int)(0); (i) &lt; (pDistinct.nExpr); i++)
    {
        Expr p = sqlite3ExprSkipCollateAndLikely(pDistinct.a[i].pExpr);
        if (((p) == (null)))
            continue;
        if ((p.op != 167) &amp;&amp; (p.op != 169))
            continue;
        if (((p.iTable) == (iBase)) &amp;&amp; ((p.iColumn) &lt; (0)))
            return (int)(1);
    }

    for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
    {
        if (!((pIdx).onError != 0))
            continue;
        if ((pIdx.pPartIdxWhere) != null)
            continue;
        for (i = (int)(0); (i) &lt; (pIdx.nKeyCol); i++)
        {
            if ((null) == (sqlite3WhereFindTerm(pWC, (int)(iBase), (int)(i), (ulong)(~(ulong)(0)), (uint)(0x0002), pIdx)))
            {
                if ((findIndexCol(pParse, pDistinct, (int)(iBase), pIdx, (int)(i))) &lt; (0))
                    break;
                if ((indexColumnNotNull(pIdx, (int)(i))) == (0))
                    break;
            }
        }

        if ((i) == (pIdx.nKeyCol))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int isDupColumn(Index pIdx, int nKey, Index pPk, int iCol)
{
    int i = 0; int  j  =  0 ; 
    j = (int)(pPk.aiColumn[iCol]);
    for (i = (int)(0); (i) &lt; (nKey); i++)
    {
        if (((pIdx.aiColumn[i]) == (j)) &amp;&amp; ((sqlite3StrICmp(pIdx.azColl[i], pPk.azColl[iCol])) == (0)))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int isFatalError(int rc)
{
    return ((((rc != 0) &amp;&amp; (rc != 5)) &amp;&amp; (rc != 6)) ? 1 : 0);
}</function>
  <function>public static int isLikeOrGlob(Parse pParse, Expr pExpr, Expr ppPrefix, int* pisComplete, int* pnoCase)
{
    byte* z = null;
    Expr pRight; Expr  pLeft ; 
    ExprList pList;
    byte c = 0;
    int cnt = 0;
    byte* wc = stackalloc byte[4];
    sqlite3 db = pParse.db;
    sqlite3_value pVal = null;
    int op = 0;
    int rc = 0;
    if (sqlite3IsLikeFunction(db, pExpr, pnoCase, (sbyte*)(wc)) == 0)
    {
        return (int)(0);
    }

    pList = pExpr.x.pList;
    pLeft = pList.a[1].pExpr;
    pRight = sqlite3ExprSkipCollate(pList.a[0].pExpr);
    op = (int)(pRight.op);
    if (((op) == (156)) &amp;&amp; ((db.flags &amp; 0x00800000) == (0)))
    {
        Vdbe pReprepare = pParse.pReprepare;
        int iCol = (int)(pRight.iColumn);
        pVal = sqlite3VdbeGetBoundValue(pReprepare, (int)(iCol), (byte)(0x41));
        if (((pVal) != null) &amp;&amp; ((sqlite3_value_type(pVal)) == (3)))
        {
            z = sqlite3_value_text(pVal);
        }

        sqlite3VdbeSetVarmask(pParse.pVdbe, (int)(iCol));
    }
    else if ((op) == (117))
    {
        z = (byte*)(pRight.u.zToken);
    }

    if ((z) != null)
    {
        cnt = (int)(0);
        while (((((c = (byte)(z[cnt])) != 0) &amp;&amp; (c != wc[0])) &amp;&amp; (c != wc[1])) &amp;&amp; (c != wc[2]))
        {
            cnt++;
            if (((c) == (wc[3])) &amp;&amp; (z[cnt] != 0))
                cnt++;
        }

        if (((cnt != 0) &amp;&amp; (255 != z[cnt - 1])) &amp;&amp; (((cnt) &gt; (1)) || (z[0] != wc[3])))
        {
            Expr pPrefix;
            *pisComplete = (int)(((c) == (wc[0])) &amp;&amp; ((z[cnt + 1]) == (0)) ? 1 : 0);
            pPrefix = sqlite3Expr(db, (int)(117), (sbyte*)(z));
            if ((pPrefix) != null)
            {
                int iFrom = 0;
                int iTo = 0;
                sbyte* zNew;
                zNew = pPrefix.u.zToken;
                zNew[cnt] = (sbyte)(0);
                for (iFrom = (int)(iTo = (int)(0)); (iFrom) &lt; (cnt); iFrom++)
                {
                    if ((zNew[iFrom]) == (wc[3]))
                        iFrom++;
                    zNew[iTo++] = (sbyte)(zNew[iFrom]);
                }

                zNew[iTo] = (sbyte)(0);
                if (((pLeft.op != 167) || (sqlite3ExprAffinity(pLeft) != 0x42)) || ((((((pLeft).flags &amp; (0x1000000 | 0x2000000)) == (0)) != 0) &amp;&amp; ((pLeft.y.pTab) != null)) &amp;&amp; (((pLeft.y.pTab).eTabType) == (1))))
                {
                    int isNum = 0;
                    double rDummy = 0;
                    isNum = (int)(sqlite3AtoF(zNew, &amp;rDummy, (int)(iTo), (byte)(1)));
                    if ((isNum) &lt;= (0))
                    {
                        if (((iTo) == (1)) &amp;&amp; ((zNew[0]) == (45)))
                        {
                            isNum = (int)(+1);
                        }
                        else
                        {
                            zNew[iTo - 1]++;
                            isNum = (int)(sqlite3AtoF(zNew, &amp;rDummy, (int)(iTo), (byte)(1)));
                            zNew[iTo - 1]--;
                        }
                    }

                    if ((isNum) &gt; (0))
                    {
                        sqlite3ExprDelete(db, pPrefix);
                        sqlite3ValueFree(pVal);
                        return (int)(0);
                    }
                }
            }

            ppPrefix = pPrefix;
            if ((op) == (156))
            {
                Vdbe v = pParse.pVdbe;
                sqlite3VdbeSetVarmask(v, (int)(pRight.iColumn));
                if (((*pisComplete) != 0) &amp;&amp; ((pRight.u.zToken[1]) != 0))
                {
                    int r1 = (int)(sqlite3GetTempReg(pParse));
                    sqlite3ExprCodeTarget(pParse, pRight, (int)(r1));
                    sqlite3VdbeChangeP3(v, (int)(sqlite3VdbeCurrentAddr(v) - 1), (int)(0));
                    sqlite3ReleaseTempReg(pParse, (int)(r1));
                }
            }
        }
        else
        {
            z = null;
        }
    }

    rc = (int)(z != null);
    sqlite3ValueFree(pVal);
    return (int)(rc);
}</function>
  <function>public static int isLimitTerm(WhereTerm pTerm)
{
    return (((pTerm.eMatchOp) &gt;= (73)) &amp;&amp; ((pTerm.eMatchOp) &lt;= (74)) ? 1 : 0);
}</function>
  <function>public static int isLookaside(sqlite3 db, void* p)
{
    return (((((ulong)(p)) &gt;= ((ulong)(db.lookaside.pStart))) &amp;&amp; (((ulong)(p)) &lt; ((ulong)(db.lookaside.pEnd)))) ? 1 : 0);
}</function>
  <function>public static int isRealTable(Parse pParse, Table pTab, int bDrop)
{
    sbyte* zType = null;
    if ((((pTab).eTabType) == (2)))
    {
        zType = "view";
    }

    if ((((pTab).eTabType) == (1)))
    {
        zType = "virtual table";
    }

    if ((zType) != null)
    {
        sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"", ((bDrop) != 0 ? "drop column from" : "rename columns of"), zType, pTab.zName);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static SrcItem isSelfJoinView(SrcList pTabList, SrcItem pThis)
{
    SrcItem pItem;
    if ((pThis.pSelect.selFlags &amp; 0x1000000) != 0)
        return null;
    for (pItem = pTabList.a; (pItem) &lt; (pThis); pItem++)
    {
        Select pS1;
        if ((pItem.pSelect) == (null))
            continue;
        if ((pItem.fg.viaCoroutine) != 0)
            continue;
        if ((pItem.zName) == (null))
            continue;
        if (pItem.pTab.pSchema != pThis.pTab.pSchema)
            continue;
        if (sqlite3_stricmp(pItem.zName, pThis.zName) != 0)
            continue;
        pS1 = pItem.pSelect;
        if (((pItem.pTab.pSchema) == (null)) &amp;&amp; (pThis.pSelect.selId != pS1.selId))
        {
            continue;
        }

        if ((pItem.pSelect.selFlags &amp; 0x1000000) != 0)
        {
            continue;
        }

        return pItem;
    }

    return null;
}</function>
  <function>public static int isSetNullAction(Parse pParse, FKey pFKey)
{
    Parse pTop = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    if ((pTop.pTriggerPrg) != null)
    {
        Trigger p = pTop.pTriggerPrg.pTrigger;
        if ((((p) == (pFKey.apTrigger[0])) &amp;&amp; ((pFKey.aAction[0]) == (8))) || (((p) == (pFKey.apTrigger[1])) &amp;&amp; ((pFKey.aAction[1]) == (8))))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static Table isSimpleCount(Select p, AggInfo pAggInfo)
{
    Table pTab;
    Expr pExpr;
    if ((((((p.pWhere) != null) || (p.pEList.nExpr != 1)) || (p.pSrc.nSrc != 1)) || ((p.pSrc.a[0].pSelect) != null)) || (pAggInfo.nFunc != 1))
    {
        return null;
    }

    pTab = p.pSrc.a[0].pTab;
    if (!(((pTab).eTabType) == (0)))
        return null;
    pExpr = p.pEList.a[0].pExpr;
    if (pExpr.op != 168)
        return null;
    if (pExpr.pAggInfo != pAggInfo)
        return null;
    if ((pAggInfo.aFunc[0].pFunc.funcFlags &amp; 0x0100) == (0))
        return null;
    if ((((pExpr).flags &amp; (0x000002 | 0x1000000)) != 0))
        return null;
    return pTab;
}</function>
  <function>public static long journalHdrOffset(Pager pPager)
{
    long offset = (long)(0);
    long c = (long)(pPager.journalOff);
    if ((c) != 0)
    {
        offset = (long)(((c - 1) / (pPager.sectorSize) + 1) * (pPager.sectorSize));
    }

    return (long)(offset);
}</function>
  <function>public static int jrnlBufferSize(Pager pPager)
{
    return (int)(0);
}</function>
  <function>public static void jsonAppendChar(JsonString p, sbyte c)
{
    if (((p.nUsed) &gt;= (p.nAlloc)) &amp;&amp; (jsonGrow(p, (uint)(1)) != 0))
        return;
    p.zBuf[p.nUsed++] = (sbyte)(c);
}</function>
  <function>public static void jsonAppendRaw(JsonString p, sbyte* zIn, uint N)
{
    if ((N) == (0))
        return;
    if (((N + p.nUsed) &gt;= (p.nAlloc)) &amp;&amp; (jsonGrow(p, (uint)(N)) != 0))
        return;
    CRuntime.memcpy(p.zBuf + p.nUsed, zIn, (ulong)(N));
    p.nUsed += (ulong)(N);
}</function>
  <function>public static void jsonAppendSeparator(JsonString p)
{
    sbyte c = 0;
    if ((p.nUsed) == (0))
        return;
    c = (sbyte)(p.zBuf[p.nUsed - 1]);
    if ((c != 91) &amp;&amp; (c != 123))
        jsonAppendChar(p, (sbyte)(44));
}</function>
  <function>public static void jsonAppendString(JsonString p, sbyte* zIn, uint N)
{
    uint i = 0;
    if (((zIn) == (null)) || (((N + p.nUsed + 2) &gt;= (p.nAlloc)) &amp;&amp; (jsonGrow(p, (uint)(N + 2)) != 0)))
        return;
    p.zBuf[p.nUsed++] = (sbyte)(34);
    for (i = (uint)(0); (i) &lt; (N); i++)
    {
        byte c = (byte)(((byte*)(zIn))[i]);
        if (((c) == (34)) || ((c) == (92)))
        {
            json_simple_escape:
                ;
            if (((p.nUsed + N + 3 - i) &gt; (p.nAlloc)) &amp;&amp; (jsonGrow(p, (uint)(N + 3 - i)) != 0))
                return;
            p.zBuf[p.nUsed++] = (sbyte)(92);
        }
        else if ((c) &lt;= (0x1f))
        {
            if ((jsonAppendString_aSpecial[c]) != 0)
            {
                c = (byte)(jsonAppendString_aSpecial[c]);
                goto json_simple_escape;
            }

            if (((p.nUsed + N + 7 + i) &gt; (p.nAlloc)) &amp;&amp; (jsonGrow(p, (uint)(N + 7 - i)) != 0))
                return;
            p.zBuf[p.nUsed++] = (sbyte)(92);
            p.zBuf[p.nUsed++] = (sbyte)(117);
            p.zBuf[p.nUsed++] = (sbyte)(48);
            p.zBuf[p.nUsed++] = (sbyte)(48);
            p.zBuf[p.nUsed++] = (sbyte)(48 + (c &gt;&gt; 4));
            c = (byte)("0123456789abcdef"[c &amp; 0xf]);
        }

        p.zBuf[p.nUsed++] = (sbyte)(c);
    }

    p.zBuf[p.nUsed++] = (sbyte)(34);
}</function>
  <function>public static void jsonAppendValue(JsonString p, sqlite3_value pValue)
{
    switch (sqlite3_value_type(pValue))
    {
        case 5:
        {
            jsonAppendRaw(p, "null", (uint)(4));
            break;
        }

        case 1:
        case 2:
        {
            sbyte* z = (sbyte*)(sqlite3_value_text(pValue));
            uint n = (uint)(sqlite3_value_bytes(pValue));
            jsonAppendRaw(p, z, (uint)(n));
            break;
        }

        case 3:
        {
            sbyte* z = (sbyte*)(sqlite3_value_text(pValue));
            uint n = (uint)(sqlite3_value_bytes(pValue));
            if ((sqlite3_value_subtype(pValue)) == (74))
            {
                jsonAppendRaw(p, z, (uint)(n));
            }
            else
            {
                jsonAppendString(p, z, (uint)(n));
            }

            break;
        }

        default:
        {
            if ((p.bErr) == (0))
            {
                sqlite3_result_error(p.pCtx, "JSON cannot hold BLOB values", (int)(-1));
                p.bErr = (byte)(2);
                jsonReset(p);
            }

            break;
        }
    }
}</function>
  <function>public static void jsonArrayCompute(sqlite3_context ctx, int isFinal)
{
    JsonString pStr;
    pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
    if ((pStr) != null)
    {
        pStr.pCtx = ctx;
        jsonAppendChar(pStr, (sbyte)(93));
        if ((pStr.bErr) != 0)
        {
            if ((pStr.bErr) == (1))
                sqlite3_result_error_nomem(ctx);
        }
        else if ((isFinal) != 0)
        {
            sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), (pStr.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free);
            pStr.bStatic = (byte)(1);
        }
        else
        {
            sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), ((Void(Void * ))(-1)));
            pStr.nUsed--;
        }
    }
    else
    {
        sqlite3_result_text(ctx, "[]", (int)(2), null);
    }

    sqlite3_result_subtype(ctx, (uint)(74));
}</function>
  <function>public static void jsonArrayFinal(sqlite3_context ctx)
{
    jsonArrayCompute(ctx, (int)(1));
}</function>
  <function>public static void jsonArrayFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    int i = 0;
    JsonString jx = new JsonString();
    jsonInit(jx, ctx);
    jsonAppendChar(jx, (sbyte)(91));
    for (i = (int)(0); (i) &lt; (argc); i++)
    {
        jsonAppendSeparator(jx);
        jsonAppendValue(jx, argv[i]);
    }

    jsonAppendChar(jx, (sbyte)(93));
    jsonResult(jx);
    sqlite3_result_subtype(ctx, (uint)(74));
}</function>
  <function>public static void jsonArrayLengthFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse* p;
    long n = (long)(0);
    uint i = 0;
    JsonNode* pNode;
    p = jsonParseCached(ctx, argv, ctx);
    if ((p) == (null))
        return;
    if ((argc) == (2))
    {
        sbyte* zPath = (sbyte*)(sqlite3_value_text(argv[1]));
        pNode = jsonLookup(p, zPath, null, ctx);
    }
    else
    {
        pNode = p-&gt;aNode;
    }

    if ((pNode) == (null))
    {
        return;
    }

    if ((pNode-&gt;eType) == (6))
    {
        for (i = (uint)(1); (i) &lt;= (pNode-&gt;n); n++)
        {
            i += (uint)(jsonNodeSize(&amp;pNode[i]));
        }
    }

    sqlite3_result_int64(ctx, (long)(n));
}</function>
  <function>public static void jsonArrayStep(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonString pStr;
    pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(sizeof(JsonString))));
    if ((pStr) != null)
    {
        if ((pStr.zBuf) == (null))
        {
            jsonInit(pStr, ctx);
            jsonAppendChar(pStr, (sbyte)(91));
        }
        else if ((pStr.nUsed) &gt; (1))
        {
            jsonAppendChar(pStr, (sbyte)(44));
        }

        pStr.pCtx = ctx;
        jsonAppendValue(pStr, argv[0]);
    }
}</function>
  <function>public static void jsonArrayValue(sqlite3_context ctx)
{
    jsonArrayCompute(ctx, (int)(0));
}</function>
  <function>public static int jsonEachBestIndex(sqlite3_vtab tab, sqlite3_index_info* pIdxInfo)
{
    int i = 0;
    int* aIdx = stackalloc int[2];
    int unusableMask = (int)(0);
    int idxMask = (int)(0);
    sqlite3_index_constraint* pConstraint;
    aIdx[0] = (int)(aIdx[1] = (int)(-1));
    pConstraint = pIdxInfo-&gt;aConstraint;
    for (i = (int)(0); (i) &lt; (pIdxInfo-&gt;nConstraint); i++, pConstraint++)
    {
        int iCol = 0;
        int iMask = 0;
        if ((pConstraint-&gt;iColumn) &lt; (8))
            continue;
        iCol = (int)(pConstraint-&gt;iColumn - 8);
        iMask = (int)(1 &lt;&lt; iCol);
        if ((pConstraint-&gt;usable) == (0))
        {
            unusableMask |= (int)(iMask);
        }
        else if ((pConstraint-&gt;op) == (2))
        {
            aIdx[iCol] = (int)(i);
            idxMask |= (int)(iMask);
        }
    }

    if ((unusableMask &amp; ~idxMask) != 0)
    {
        return (int)(19);
    }

    if ((aIdx[0]) &lt; (0))
    {
        pIdxInfo-&gt;idxNum = (int)(0);
    }
    else
    {
        pIdxInfo-&gt;estimatedCost = (double)(1.0);
        i = (int)(aIdx[0]);
        pIdxInfo-&gt;aConstraintUsage[i].argvIndex = (int)(1);
        pIdxInfo-&gt;aConstraintUsage[i].omit = (byte)(1);
        if ((aIdx[1]) &lt; (0))
        {
            pIdxInfo-&gt;idxNum = (int)(1);
        }
        else
        {
            i = (int)(aIdx[1]);
            pIdxInfo-&gt;aConstraintUsage[i].argvIndex = (int)(2);
            pIdxInfo-&gt;aConstraintUsage[i].omit = (byte)(1);
            pIdxInfo-&gt;idxNum = (int)(3);
        }
    }

    return (int)(0);
}</function>
  <function>public static int jsonEachClose(sqlite3_vtab_cursor cur)
{
    JsonEachCursor p = (JsonEachCursor)(cur);
    jsonEachCursorReset(p);
    sqlite3_free(cur);
    return (int)(0);
}</function>
  <function>public static int jsonEachColumn(sqlite3_vtab_cursor cur, sqlite3_context ctx, int i)
{
    JsonEachCursor p = (JsonEachCursor)(cur);
    JsonNode* pThis = &amp;p.sParse.aNode[p.i];
    switch (i)
    {
        case 0:
        {
            if ((p.i) == (0))
                break;
            if ((p.eType) == (7))
            {
                jsonReturn(pThis, ctx, null);
            }
            else if ((p.eType) == (6))
            {
                uint iKey = 0;
                if ((p.bRecursive) != 0)
                {
                    if ((p.iRowid) == (0))
                        break;
                    iKey = (uint)(p.sParse.aNode[p.sParse.aUp[p.i]].u.iKey);
                }
                else
                {
                    iKey = (uint)(p.iRowid);
                }

                sqlite3_result_int64(ctx, (long)(iKey));
            }

            break;
        }

        case 1:
        {
            if ((pThis-&gt;jnFlags &amp; 0x40) != 0)
                pThis++;
            jsonReturn(pThis, ctx, null);
            break;
        }

        case 2:
        {
            if ((pThis-&gt;jnFlags &amp; 0x40) != 0)
                pThis++;
            sqlite3_result_text(ctx, jsonType[pThis-&gt;eType], (int)(-1), null);
            break;
        }

        case 3:
        {
            if ((pThis-&gt;jnFlags &amp; 0x40) != 0)
                pThis++;
            if ((pThis-&gt;eType) &gt;= (6))
                break;
            jsonReturn(pThis, ctx, null);
            break;
        }

        case 4:
        {
            sqlite3_result_int64(ctx, (long)((long)(p.i) + ((pThis-&gt;jnFlags &amp; 0x40) != 0)));
            break;
        }

        case 5:
        {
            if (((p.i) &gt; (p.iBegin)) &amp;&amp; ((p.bRecursive) != 0))
            {
                sqlite3_result_int64(ctx, (long)(p.sParse.aUp[p.i]));
            }

            break;
        }

        case 6:
        {
            JsonString x = new JsonString();
            jsonInit(x, ctx);
            if ((p.bRecursive) != 0)
            {
                jsonEachComputePath(p, x, (uint)(p.i));
            }
            else
            {
                if ((p.zRoot) != null)
                {
                    jsonAppendRaw(x, p.zRoot, (uint)((int)(CRuntime.strlen(p.zRoot))));
                }
                else
                {
                    jsonAppendChar(x, (sbyte)(36));
                }

                if ((p.eType) == (6))
                {
                    jsonPrintf((int)(30), x, "[%d]", (uint)(p.iRowid));
                }
                else if ((p.eType) == (7))
                {
                    jsonPrintf((int)(pThis-&gt;n), x, ".%.*s", (uint)(pThis-&gt;n - 2), pThis-&gt;u.zJContent + 1);
                }
            }

            jsonResult(x);
            break;
        }

        case 7:
        {
            if ((p.bRecursive) != 0)
            {
                JsonString x = new JsonString();
                jsonInit(x, ctx);
                jsonEachComputePath(p, x, (uint)(p.sParse.aUp[p.i]));
                jsonResult(x);
                break;
            }
        }

        default:
        {
            sbyte* zRoot = p.zRoot;
            if ((zRoot) == (null))
                zRoot = "$";
            sqlite3_result_text(ctx, zRoot, (int)(-1), null);
            break;
        }

        case 8:
        {
            sqlite3_result_text(ctx, p.sParse.zJson, (int)(-1), null);
            break;
        }
    }

    return (int)(0);
}</function>
  <function>public static void jsonEachComputePath(JsonEachCursor p, JsonString pStr, uint i)
{
    JsonNode* pNode; JsonNode * pUp ; 
    uint iUp = 0;
    if ((i) == (0))
    {
        jsonAppendChar(pStr, (sbyte)(36));
        return;
    }

    iUp = (uint)(p.sParse.aUp[i]);
    jsonEachComputePath(p, pStr, (uint)(iUp));
    pNode = &amp;p.sParse.aNode[i];
    pUp = &amp;p.sParse.aNode[iUp];
    if ((pUp-&gt;eType) == (6))
    {
        jsonPrintf((int)(30), pStr, "[%d]", (uint)(pUp-&gt;u.iKey));
    }
    else
    {
        if ((pNode-&gt;jnFlags &amp; 0x40) == (0))
            pNode--;
        jsonPrintf((int)(pNode-&gt;n + 1), pStr, ".%.*s", (uint)(pNode-&gt;n - 2), pNode-&gt;u.zJContent + 1);
    }
}</function>
  <function>public static int jsonEachConnect(sqlite3 db, void* pAux, int argc, sbyte** argv, sqlite3_vtab ppVtab, sbyte** pzErr)
{
    sqlite3_vtab pNew;
    int rc = 0;
    rc = (int)(sqlite3_declare_vtab(db, "CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,json HIDDEN,root HIDDEN)"));
    if ((rc) == (0))
    {
        pNew = ppVtab = sqlite3_malloc((int)(sizeof(sqlite3_vtab)));
        if ((pNew) == (null))
            return (int)(7);
        CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(sqlite3_vtab)));
        sqlite3_vtab_config(db, (int)(2));
    }

    return (int)(rc);
}</function>
  <function>public static void jsonEachCursorReset(JsonEachCursor p)
{
    sqlite3_free(p.zJson);
    sqlite3_free(p.zRoot);
    jsonParseReset(&amp;p.sParse);
    p.iRowid = (uint)(0);
    p.i = (uint)(0);
    p.iEnd = (uint)(0);
    p.eType = (byte)(0);
    p.zJson = null;
    p.zRoot = null;
}</function>
  <function>public static int jsonEachDisconnect(sqlite3_vtab pVtab)
{
    sqlite3_free(pVtab);
    return (int)(0);
}</function>
  <function>public static int jsonEachEof(sqlite3_vtab_cursor cur)
{
    JsonEachCursor p = (JsonEachCursor)(cur);
    return ((p.i) &gt;= (p.iEnd) ? 1 : 0);
}</function>
  <function>public static int jsonEachFilter(sqlite3_vtab_cursor cur, int idxNum, sbyte* idxStr, int argc, sqlite3_value argv)
{
    JsonEachCursor p = (JsonEachCursor)(cur);
    sbyte* z;
    sbyte* zRoot = null;
    long n = 0;
    jsonEachCursorReset(p);
    if ((idxNum) == (0))
        return (int)(0);
    z = (sbyte*)(sqlite3_value_text(argv[0]));
    if ((z) == (null))
        return (int)(0);
    n = (long)(sqlite3_value_bytes(argv[0]));
    p.zJson = sqlite3_malloc64((ulong)(n + 1));
    if ((p.zJson) == (null))
        return (int)(7);
    CRuntime.memcpy(p.zJson, z, (ulong)((ulong)(n) + 1));
    if ((jsonParse(&amp;p.sParse, null, p.zJson)) != 0)
    {
        int rc = (int)(7);
        if ((p.sParse.oom) == (0))
        {
            sqlite3_free(cur.pVtab.zErrMsg);
            cur.pVtab.zErrMsg = sqlite3_mprintf("malformed JSON");
            if ((cur.pVtab.zErrMsg) != null)
                rc = (int)(1);
        }

        jsonEachCursorReset(p);
        return (int)(rc);
    }
    else if (((p.bRecursive) != 0) &amp;&amp; ((jsonParseFindParents(&amp;p.sParse)) != 0))
    {
        jsonEachCursorReset(p);
        return (int)(7);
    }
    else
    {
        JsonNode* pNode = null;
        if ((idxNum) == (3))
        {
            sbyte* zErr = null;
            zRoot = (sbyte*)(sqlite3_value_text(argv[1]));
            if ((zRoot) == (null))
                return (int)(0);
            n = (long)(sqlite3_value_bytes(argv[1]));
            p.zRoot = sqlite3_malloc64((ulong)(n + 1));
            if ((p.zRoot) == (null))
                return (int)(7);
            CRuntime.memcpy(p.zRoot, zRoot, (ulong)((ulong)(n) + 1));
            if (zRoot[0] != 36)
            {
                zErr = zRoot;
            }
            else
            {
                pNode = jsonLookupStep(&amp;p.sParse, (uint)(0), p.zRoot + 1, null, &amp;zErr);
            }

            if ((zErr) != null)
            {
                sqlite3_free(cur.pVtab.zErrMsg);
                cur.pVtab.zErrMsg = jsonPathSyntaxError(zErr);
                jsonEachCursorReset(p);
                return (int)((cur.pVtab.zErrMsg) != 0 ? 1 : 7);
            }
            else if ((pNode) == (null))
            {
                return (int)(0);
            }
        }
        else
        {
            pNode = p.sParse.aNode;
        }

        p.iBegin = (uint)(p.i = (uint)((int)(pNode - p.sParse.aNode)));
        p.eType = (byte)(pNode-&gt;eType);
        if ((p.eType) &gt;= (6))
        {
            pNode-&gt;u.iKey = (uint)(0);
            p.iEnd = (uint)(p.i + pNode-&gt;n + 1);
            if ((p.bRecursive) != 0)
            {
                p.eType = (byte)(p.sParse.aNode[p.sParse.aUp[p.i]].eType);
                if (((p.i) &gt; (0)) &amp;&amp; ((p.sParse.aNode[p.i - 1].jnFlags &amp; 0x40) != 0))
                {
                    p.i--;
                }
            }
            else
            {
                p.i++;
            }
        }
        else
        {
            p.iEnd = (uint)(p.i + 1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int jsonEachNext(sqlite3_vtab_cursor cur)
{
    JsonEachCursor p = (JsonEachCursor)(cur);
    if ((p.bRecursive) != 0)
    {
        if ((p.sParse.aNode[p.i].jnFlags &amp; 0x40) != 0)
            p.i++;
        p.i++;
        p.iRowid++;
        if ((p.i) &lt; (p.iEnd))
        {
            uint iUp = (uint)(p.sParse.aUp[p.i]);
            JsonNode* pUp = &amp;p.sParse.aNode[iUp];
            p.eType = (byte)(pUp-&gt;eType);
            if ((pUp-&gt;eType) == (6))
            {
                if ((iUp) == (p.i - 1))
                {
                    pUp-&gt;u.iKey = (uint)(0);
                }
                else
                {
                    pUp-&gt;u.iKey++;
                }
            }
        }
    }
    else
    {
        switch (p.eType)
        {
            case 6:
            {
                p.i += (uint)(jsonNodeSize(&amp;p.sParse.aNode[p.i]));
                p.iRowid++;
                break;
            }

            case 7:
            {
                p.i += (uint)(1 + jsonNodeSize(&amp;p.sParse.aNode[p.i + 1]));
                p.iRowid++;
                break;
            }

            default:
            {
                p.i = (uint)(p.iEnd);
                break;
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int jsonEachOpenEach(sqlite3_vtab p, sqlite3_vtab_cursor ppCursor)
{
    JsonEachCursor pCur;
    pCur = sqlite3_malloc((int)(sizeof(JsonEachCursor)));
    if ((pCur) == (null))
        return (int)(7);
    CRuntime.memset(pCur, (int)(0), (ulong)(sizeof(JsonEachCursor)));
    ppCursor = pCur._base_;
    return (int)(0);
}</function>
  <function>public static int jsonEachOpenTree(sqlite3_vtab p, sqlite3_vtab_cursor ppCursor)
{
    int rc = (int)(jsonEachOpenEach(p, ppCursor));
    if ((rc) == (0))
    {
        JsonEachCursor pCur = (JsonEachCursor)(ppCursor);
        pCur.bRecursive = (byte)(1);
    }

    return (int)(rc);
}</function>
  <function>public static int jsonEachRowid(sqlite3_vtab_cursor cur, long* pRowid)
{
    JsonEachCursor p = (JsonEachCursor)(cur);
    *pRowid = (long)(p.iRowid);
    return (int)(0);
}</function>
  <function>public static void jsonExtractFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse* p;
    JsonNode* pNode;
    sbyte* zPath;
    int flags = ((int)((long)(sqlite3_user_data(ctx))));
    JsonString jx = new JsonString();
    if ((argc) &lt; (2))
        return;
    p = jsonParseCached(ctx, argv, ctx);
    if ((p) == (null))
        return;
    if ((argc) == (2))
    {
        zPath = (sbyte*)(sqlite3_value_text(argv[1]));
        if ((zPath) == (null))
            return;
        if ((flags &amp; 0x03) != 0)
        {
            if (zPath[0] != 36)
            {
                jsonInit(jx, ctx);
                if ((sqlite3CtypeMap[(byte)(zPath[0])] &amp; 0x04) != 0)
                {
                    jsonAppendRaw(jx, "$[", (uint)(2));
                    jsonAppendRaw(jx, zPath, (uint)((int)(CRuntime.strlen(zPath))));
                    jsonAppendRaw(jx, "]", (uint)(2));
                }
                else
                {
                    jsonAppendRaw(jx, "$.", (uint)(1 + (zPath[0] != 91)));
                    jsonAppendRaw(jx, zPath, (uint)((int)(CRuntime.strlen(zPath))));
                    jsonAppendChar(jx, (sbyte)(0));
                }

                pNode = (jx.bErr) != 0 ? null : jsonLookup(p, jx.zBuf, null, ctx);
                jsonReset(jx);
            }
            else
            {
                pNode = jsonLookup(p, zPath, null, ctx);
            }

            if ((pNode) != null)
            {
                if ((flags &amp; 0x01) != 0)
                {
                    jsonReturnJson(pNode, ctx, null);
                }
                else
                {
                    jsonReturn(pNode, ctx, null);
                    sqlite3_result_subtype(ctx, (uint)(0));
                }
            }
        }
        else
        {
            pNode = jsonLookup(p, zPath, null, ctx);
            if (((p-&gt;nErr) == (0)) &amp;&amp; ((pNode) != null))
                jsonReturn(pNode, ctx, null);
        }
    }
    else
    {
        int i = 0;
        jsonInit(jx, ctx);
        jsonAppendChar(jx, (sbyte)(91));
        for (i = (int)(1); (i) &lt; (argc); i++)
        {
            zPath = (sbyte*)(sqlite3_value_text(argv[i]));
            pNode = jsonLookup(p, zPath, null, ctx);
            if ((p-&gt;nErr) != 0)
                break;
            jsonAppendSeparator(jx);
            if ((pNode) != null)
            {
                jsonRenderNode(pNode, jx, null);
            }
            else
            {
                jsonAppendRaw(jx, "null", (uint)(4));
            }
        }

        if ((i) == (argc))
        {
            jsonAppendChar(jx, (sbyte)(93));
            jsonResult(jx);
            sqlite3_result_subtype(ctx, (uint)(74));
        }

        jsonReset(jx);
    }
}</function>
  <function>public static void jsonGroupInverse(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    uint i = 0;
    int inStr = (int)(0);
    int nNest = (int)(0);
    sbyte* z;
    sbyte c = 0;
    JsonString pStr;
    pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
    if ((!pStr) != 0)
        return;
    z = pStr.zBuf;
    for (i = (uint)(1); ((i) &lt; (pStr.nUsed)) &amp;&amp; ((((c = (sbyte)(z[i])) != 44) || ((inStr) != 0)) || ((nNest) != 0)); i++)
    {
        if ((c) == (34))
        {
            inStr = (int)(!inStr);
        }
        else if ((c) == (92))
        {
            i++;
        }
        else if (inStr == 0)
        {
            if (((c) == (123)) || ((c) == (91)))
                nNest++;
            if (((c) == (125)) || ((c) == (93)))
                nNest--;
        }
    }

    if ((i) &lt; (pStr.nUsed))
    {
        pStr.nUsed -= (ulong)(i);
        CRuntime.memmove(&amp;z[1], &amp;z[i + 1], (ulong)(pStr.nUsed - 1));
        z[pStr.nUsed] = (sbyte)(0);
    }
    else
    {
        pStr.nUsed = (ulong)(1);
    }
}</function>
  <function>public static int jsonGrow(JsonString p, uint N)
{
    ulong nTotal = (ulong)((N) &lt; (p.nAlloc) ? p.nAlloc * 2 : p.nAlloc + N + 10);
    sbyte* zNew;
    if ((p.bStatic) != 0)
    {
        if ((p.bErr) != 0)
            return (int)(1);
        zNew = sqlite3_malloc64((ulong)(nTotal));
        if ((zNew) == (null))
        {
            jsonOom(p);
            return (int)(7);
        }

        CRuntime.memcpy(zNew, p.zBuf, (ulong)(p.nUsed));
        p.zBuf = zNew;
        p.bStatic = (byte)(0);
    }
    else
    {
        zNew = sqlite3_realloc64(p.zBuf, (ulong)(nTotal));
        if ((zNew) == (null))
        {
            jsonOom(p);
            return (int)(7);
        }

        p.zBuf = zNew;
    }

    p.nAlloc = (ulong)(nTotal);
    return (int)(0);
}</function>
  <function>public static byte jsonHexToInt(int h)
{
    h += (int)(9 * (1 &amp; (h &gt;&gt; 6)));
    return (byte)(h &amp; 0xf);
}</function>
  <function>public static uint jsonHexToInt4(sbyte* z)
{
    uint v = 0;
    v = (uint)((jsonHexToInt((int)(z[0])) &lt;&lt; 12) + (jsonHexToInt((int)(z[1])) &lt;&lt; 8) + (jsonHexToInt((int)(z[2])) &lt;&lt; 4) + jsonHexToInt((int)(z[3])));
    return (uint)(v);
}</function>
  <function>public static void jsonInit(JsonString p, sqlite3_context pCtx)
{
    p.pCtx = pCtx;
    p.bErr = (byte)(0);
    jsonZero(p);
}</function>
  <function>public static int jsonIs4Hex(sbyte* z)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (4); i++)
    {
        if ((sqlite3CtypeMap[(byte)(z[i])] &amp; 0x08) == 0)
            return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static int jsonLabelCompare(JsonNode* pNode, sbyte* zKey, uint nKey)
{
    if ((pNode-&gt;jnFlags &amp; 0x01) != 0)
    {
        if (pNode-&gt;n != nKey)
            return (int)(0);
        return ((CRuntime.strncmp(pNode-&gt;u.zJContent, zKey, (ulong)(nKey))) == (0) ? 1 : 0);
    }
    else
    {
        if (pNode-&gt;n != nKey + 2)
            return (int)(0);
        return ((CRuntime.strncmp(pNode-&gt;u.zJContent + 1, zKey, (ulong)(nKey))) == (0) ? 1 : 0);
    }
}</function>
  <function>public static JsonNode* jsonLookup(JsonParse* pParse, sbyte* zPath, int* pApnd, sqlite3_context pCtx)
{
    sbyte* zErr = null;
    JsonNode* pNode = null;
    sbyte* zMsg;
    if ((zPath) == (null))
        return null;
    if (zPath[0] != 36)
    {
        zErr = zPath;
        goto lookup_err;
    }

    zPath++;
    pNode = jsonLookupStep(pParse, (uint)(0), zPath, pApnd, &amp;zErr);
    if ((zErr) == (null))
        return pNode;
    lookup_err:
        ; pParse -&gt; nErr ++ ; 
    zMsg = jsonPathSyntaxError(zErr);
    if ((zMsg) != null)
    {
        sqlite3_result_error(pCtx, zMsg, (int)(-1));
        sqlite3_free(zMsg);
    }
    else
    {
        sqlite3_result_error_nomem(pCtx);
    }

    return null;
}</function>
  <function>public static JsonNode* jsonLookupAppend(JsonParse* pParse, sbyte* zPath, int* pApnd, sbyte** pzErr)
{
    *pApnd = (int)(1);
    if ((zPath[0]) == (0))
    {
        jsonParseAddNode(pParse, (uint)(0), (uint)(0), null);
        return (pParse-&gt;oom) != 0 ? null : &amp;pParse-&gt;aNode[pParse-&gt;nNode - 1];
    }

    if ((zPath[0]) == (46))
    {
        jsonParseAddNode(pParse, (uint)(7), (uint)(0), null);
    }
    else if ((CRuntime.strncmp(zPath, "[0]", (ulong)(3))) == (0))
    {
        jsonParseAddNode(pParse, (uint)(6), (uint)(0), null);
    }
    else
    {
        return null;
    }

    if ((pParse-&gt;oom) != 0)
        return null;
    return jsonLookupStep(pParse, (uint)(pParse-&gt;nNode - 1), zPath, pApnd, pzErr);
}</function>
  <function>public static JsonNode* jsonLookupStep(JsonParse* pParse, uint iRoot, sbyte* zPath, int* pApnd, sbyte** pzErr)
{
    uint i = 0; uint  j  =  0 ;  uint  nKey  =  0 ; 
    sbyte* zKey;
    JsonNode* pRoot = &amp;pParse-&gt;aNode[iRoot];
    if ((zPath[0]) == (0))
        return pRoot;
    if ((pRoot-&gt;jnFlags &amp; 0x08) != 0)
        return null;
    if ((zPath[0]) == (46))
    {
        if (pRoot-&gt;eType != 7)
            return null;
        zPath++;
        if ((zPath[0]) == (34))
        {
            zKey = zPath + 1;
            for (i = (uint)(1); ((zPath[i]) != 0) &amp;&amp; (zPath[i] != 34); i++)
            {
            }

            nKey = (uint)(i - 1);
            if ((zPath[i]) != 0)
            {
                i++;
            }
            else
            {
                *pzErr = zPath;
                return null;
            }
        }
        else
        {
            zKey = zPath;
            for (i = (uint)(0); (((zPath[i]) != 0) &amp;&amp; (zPath[i] != 46)) &amp;&amp; (zPath[i] != 91); i++)
            {
            }

            nKey = (uint)(i);
        }

        if ((nKey) == (0))
        {
            *pzErr = zPath;
            return null;
        }

        j = (uint)(1);
        for (;;)
        {
            while ((j) &lt;= (pRoot-&gt;n))
            {
                if ((jsonLabelCompare(pRoot + j, zKey, (uint)(nKey))) != 0)
                {
                    return jsonLookupStep(pParse, (uint)(iRoot + j + 1), &amp;zPath[i], pApnd, pzErr);
                }

                j++;
                j += (uint)(jsonNodeSize(&amp;pRoot[j]));
            }

            if ((pRoot-&gt;jnFlags &amp; 0x20) == (0))
                break;
            iRoot += (uint)(pRoot-&gt;u.iAppend);
            pRoot = &amp;pParse-&gt;aNode[iRoot];
            j = (uint)(1);
        }

        if ((pApnd) != null)
        {
            uint iStart = 0;
            uint iLabel = 0;
            JsonNode* pNode;
            iStart = (uint)(jsonParseAddNode(pParse, (uint)(7), (uint)(2), null));
            iLabel = (uint)(jsonParseAddNode(pParse, (uint)(5), (uint)(nKey), zKey));
            zPath += i;
            pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
            if ((pParse-&gt;oom) != 0)
                return null;
            if ((pNode) != null)
            {
                pRoot = &amp;pParse-&gt;aNode[iRoot];
                pRoot-&gt;u.iAppend = (uint)(iStart - iRoot);
                pRoot-&gt;jnFlags |= (byte)(0x20);
                pParse-&gt;aNode[iLabel].jnFlags |= (byte)(0x01);
            }

            return pNode;
        }
    }
    else if ((zPath[0]) == (91))
    {
        i = (uint)(0);
        j = (uint)(1);
        while ((sqlite3CtypeMap[(byte)(zPath[j])] &amp; 0x04) != 0)
        {
            i = (uint)(i * 10 + zPath[j] - 48);
            j++;
        }

        if (((j) &lt; (2)) || (zPath[j] != 93))
        {
            if ((zPath[1]) == (35))
            {
                JsonNode* pBase = pRoot;
                int iBase = (int)(iRoot);
                if (pRoot-&gt;eType != 6)
                    return null;
                for (;;)
                {
                    while ((j) &lt;= (pBase-&gt;n))
                    {
                        if ((pBase[j].jnFlags &amp; 0x04) == (0))
                            i++;
                        j += (uint)(jsonNodeSize(&amp;pBase[j]));
                    }

                    if ((pBase-&gt;jnFlags &amp; 0x20) == (0))
                        break;
                    iBase += (int)(pBase-&gt;u.iAppend);
                    pBase = &amp;pParse-&gt;aNode[iBase];
                    j = (uint)(1);
                }

                j = (uint)(2);
                if (((zPath[2]) == (45)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zPath[3])] &amp; 0x04) != 0))
                {
                    uint x = (uint)(0);
                    j = (uint)(3);
                    do
                    {
                        x = (uint)(x * 10 + zPath[j] - 48);
                        j++;
                    }
                    while ((sqlite3CtypeMap[(byte)(zPath[j])] &amp; 0x04) != 0);
                    if ((x) &gt; (i))
                        return null;
                    i -= (uint)(x);
                }

                if (zPath[j] != 93)
                {
                    *pzErr = zPath;
                    return null;
                }
            }
            else
            {
                *pzErr = zPath;
                return null;
            }
        }

        if (pRoot-&gt;eType != 6)
            return null;
        zPath += j + 1;
        j = (uint)(1);
        for (;;)
        {
            while (((j) &lt;= (pRoot-&gt;n)) &amp;&amp; (((i) &gt; (0)) || ((pRoot[j].jnFlags &amp; 0x04) != 0)))
            {
                if ((pRoot[j].jnFlags &amp; 0x04) == (0))
                    i--;
                j += (uint)(jsonNodeSize(&amp;pRoot[j]));
            }

            if ((pRoot-&gt;jnFlags &amp; 0x20) == (0))
                break;
            iRoot += (uint)(pRoot-&gt;u.iAppend);
            pRoot = &amp;pParse-&gt;aNode[iRoot];
            j = (uint)(1);
        }

        if ((j) &lt;= (pRoot-&gt;n))
        {
            return jsonLookupStep(pParse, (uint)(iRoot + j), zPath, pApnd, pzErr);
        }

        if (((i) == (0)) &amp;&amp; ((pApnd) != null))
        {
            uint iStart = 0;
            JsonNode* pNode;
            iStart = (uint)(jsonParseAddNode(pParse, (uint)(6), (uint)(1), null));
            pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
            if ((pParse-&gt;oom) != 0)
                return null;
            if ((pNode) != null)
            {
                pRoot = &amp;pParse-&gt;aNode[iRoot];
                pRoot-&gt;u.iAppend = (uint)(iStart - iRoot);
                pRoot-&gt;jnFlags |= (byte)(0x20);
            }

            return pNode;
        }
    }
    else
    {
        *pzErr = zPath;
    }

    return null;
}</function>
  <function>public static JsonNode* jsonMergePatch(JsonParse* pParse, uint iTarget, JsonNode* pPatch)
{
    uint i = 0; uint  j  =  0 ; 
    uint iRoot = 0;
    JsonNode* pTarget;
    if (pPatch-&gt;eType != 7)
    {
        return pPatch;
    }

    pTarget = &amp;pParse-&gt;aNode[iTarget];
    if (pTarget-&gt;eType != 7)
    {
        jsonRemoveAllNulls(pPatch);
        return pPatch;
    }

    iRoot = (uint)(iTarget);
    for (i = (uint)(1); (i) &lt; (pPatch-&gt;n); i += (uint)(jsonNodeSize(&amp;pPatch[i + 1]) + 1))
    {
        uint nKey = 0;
        sbyte* zKey;
        nKey = (uint)(pPatch[i].n);
        zKey = pPatch[i].u.zJContent;
        for (j = (uint)(1); (j) &lt; (pTarget-&gt;n); j += (uint)(jsonNodeSize(&amp;pTarget[j + 1]) + 1))
        {
            if (((pTarget[j].n) == (nKey)) &amp;&amp; ((CRuntime.strncmp(pTarget[j].u.zJContent, zKey, (ulong)(nKey))) == (0)))
            {
                if ((pTarget[j + 1].jnFlags &amp; (0x04 | 0x10)) != 0)
                    break;
                if ((pPatch[i + 1].eType) == (0))
                {
                    pTarget[j + 1].jnFlags |= (byte)(0x04);
                }
                else
                {
                    JsonNode* pNew = jsonMergePatch(pParse, (uint)(iTarget + j + 1), &amp;pPatch[i + 1]);
                    if ((pNew) == (null))
                        return null;
                    pTarget = &amp;pParse-&gt;aNode[iTarget];
                    if (pNew != &amp;pTarget[j + 1])
                    {
                        pTarget[j + 1].u.pPatch = pNew;
                        pTarget[j + 1].jnFlags |= (byte)(0x10);
                    }
                }

                break;
            }
        }

        if (((j) &gt;= (pTarget-&gt;n)) &amp;&amp; (pPatch[i + 1].eType != 0))
        {
            int iStart = 0;
            int iPatch = 0;
            iStart = (int)(jsonParseAddNode(pParse, (uint)(7), (uint)(2), null));
            jsonParseAddNode(pParse, (uint)(5), (uint)(nKey), zKey);
            iPatch = (int)(jsonParseAddNode(pParse, (uint)(1), (uint)(0), null));
            if ((pParse-&gt;oom) != 0)
                return null;
            jsonRemoveAllNulls(pPatch);
            pTarget = &amp;pParse-&gt;aNode[iTarget];
            pParse-&gt;aNode[iRoot].jnFlags |= (byte)(0x20);
            pParse-&gt;aNode[iRoot].u.iAppend = (uint)(iStart - iRoot);
            iRoot = (uint)(iStart);
            pParse-&gt;aNode[iPatch].jnFlags |= (byte)(0x10);
            pParse-&gt;aNode[iPatch].u.pPatch = &amp;pPatch[i + 1];
        }
    }

    return pTarget;
}</function>
  <function>public static uint jsonNodeSize(JsonNode* pNode)
{
    return (uint)((pNode-&gt;eType) &gt;= (6) ? pNode-&gt;n + 1 : 1);
}</function>
  <function>public static void jsonObjectCompute(sqlite3_context ctx, int isFinal)
{
    JsonString pStr;
    pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
    if ((pStr) != null)
    {
        jsonAppendChar(pStr, (sbyte)(125));
        if ((pStr.bErr) != 0)
        {
            if ((pStr.bErr) == (1))
                sqlite3_result_error_nomem(ctx);
        }
        else if ((isFinal) != 0)
        {
            sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), (pStr.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free);
            pStr.bStatic = (byte)(1);
        }
        else
        {
            sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), ((Void(Void * ))(-1)));
            pStr.nUsed--;
        }
    }
    else
    {
        sqlite3_result_text(ctx, "{}", (int)(2), null);
    }

    sqlite3_result_subtype(ctx, (uint)(74));
}</function>
  <function>public static void jsonObjectFinal(sqlite3_context ctx)
{
    jsonObjectCompute(ctx, (int)(1));
}</function>
  <function>public static void jsonObjectFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    int i = 0;
    JsonString jx = new JsonString();
    sbyte* z;
    uint n = 0;
    if ((argc &amp; 1) != 0)
    {
        sqlite3_result_error(ctx, "json_object() requires an even number of arguments", (int)(-1));
        return;
    }

    jsonInit(jx, ctx);
    jsonAppendChar(jx, (sbyte)(123));
    for (i = (int)(0); (i) &lt; (argc); i += (int)(2))
    {
        if (sqlite3_value_type(argv[i]) != 3)
        {
            sqlite3_result_error(ctx, "json_object() labels must be TEXT", (int)(-1));
            jsonReset(jx);
            return;
        }

        jsonAppendSeparator(jx);
        z = (sbyte*)(sqlite3_value_text(argv[i]));
        n = ((uint)(sqlite3_value_bytes(argv[i])));
        jsonAppendString(jx, z, (uint)(n));
        jsonAppendChar(jx, (sbyte)(58));
        jsonAppendValue(jx, argv[i + 1]);
    }

    jsonAppendChar(jx, (sbyte)(125));
    jsonResult(jx);
    sqlite3_result_subtype(ctx, (uint)(74));
}</function>
  <function>public static void jsonObjectStep(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonString pStr;
    sbyte* z;
    uint n = 0;
    pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(sizeof(JsonString))));
    if ((pStr) != null)
    {
        if ((pStr.zBuf) == (null))
        {
            jsonInit(pStr, ctx);
            jsonAppendChar(pStr, (sbyte)(123));
        }
        else if ((pStr.nUsed) &gt; (1))
        {
            jsonAppendChar(pStr, (sbyte)(44));
        }

        pStr.pCtx = ctx;
        z = (sbyte*)(sqlite3_value_text(argv[0]));
        n = ((uint)(sqlite3_value_bytes(argv[0])));
        jsonAppendString(pStr, z, (uint)(n));
        jsonAppendChar(pStr, (sbyte)(58));
        jsonAppendValue(pStr, argv[1]);
    }
}</function>
  <function>public static void jsonObjectValue(sqlite3_context ctx)
{
    jsonObjectCompute(ctx, (int)(0));
}</function>
  <function>public static void jsonOom(JsonString p)
{
    p.bErr = (byte)(1);
    sqlite3_result_error_nomem(p.pCtx);
    jsonReset(p);
}</function>
  <function>public static int jsonParse(JsonParse* pParse, sqlite3_context pCtx, sbyte* zJson)
{
    int i = 0;
    CRuntime.memset(pParse, (int)(0), (ulong)(sizeof(JsonParse)));
    if ((zJson) == (null))
        return (int)(1);
    pParse-&gt;zJson = zJson;
    i = (int)(jsonParseValue(pParse, (uint)(0)));
    if ((pParse-&gt;oom) != 0)
        i = (int)(-1);
    if ((i) &gt; (0))
    {
        while ((jsonIsSpace[(byte)(zJson[i])]) != 0)
        {
            i++;
        }

        if ((zJson[i]) != 0)
            i = (int)(-1);
    }

    if ((i) &lt;= (0))
    {
        if (pCtx != null)
        {
            if ((pParse-&gt;oom) != 0)
            {
                sqlite3_result_error_nomem(pCtx);
            }
            else
            {
                sqlite3_result_error(pCtx, "malformed JSON", (int)(-1));
            }
        }

        jsonParseReset(pParse);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int jsonParseAddNode(JsonParse* pParse, uint eType, uint n, sbyte* zContent)
{
    JsonNode* p;
    if (((pParse-&gt;aNode) == (null)) || ((pParse-&gt;nNode) &gt;= (pParse-&gt;nAlloc)))
    {
        return (int)(jsonParseAddNodeExpand(pParse, (uint)(eType), (uint)(n), zContent));
    }

    p = &amp;pParse-&gt;aNode[pParse-&gt;nNode];
    p-&gt;eType = ((byte)(eType));
    p-&gt;jnFlags = (byte)(0);
    p-&gt;n = (uint)(n);
    p-&gt;u.zJContent = zContent;
    return (int)(pParse-&gt;nNode++);
}</function>
  <function>public static int jsonParseAddNodeExpand(JsonParse* pParse, uint eType, uint n, sbyte* zContent)
{
    uint nNew = 0;
    JsonNode* pNew;
    if ((pParse-&gt;oom) != 0)
        return (int)(-1);
    nNew = (uint)(pParse-&gt;nAlloc * 2 + 10);
    pNew = sqlite3_realloc64(pParse-&gt;aNode, (ulong)(sizeof(JsonNode) * nNew));
    if ((pNew) == (null))
    {
        pParse-&gt;oom = (byte)(1);
        return (int)(-1);
    }

    pParse-&gt;nAlloc = (uint)(nNew);
    pParse-&gt;aNode = pNew;
    return (int)(jsonParseAddNode(pParse, (uint)(eType), (uint)(n), zContent));
}</function>
  <function>public static JsonParse* jsonParseCached(sqlite3_context pCtx, sqlite3_value argv, sqlite3_context pErrCtx)
{
    sbyte* zJson = (sbyte*)(sqlite3_value_text(argv[0]));
    int nJson = (int)(sqlite3_value_bytes(argv[0]));
    JsonParse* p;
    JsonParse* pMatch = null;
    int iKey = 0;
    int iMinKey = (int)(0);
    uint iMinHold = (uint)(0xffffffff);
    uint iMaxHold = (uint)(0);
    if ((zJson) == (null))
        return null;
    for (iKey = (int)(0); (iKey) &lt; (4); iKey++)
    {
        p = (JsonParse*)(sqlite3_get_auxdata(pCtx, (int)((-429938) + iKey)));
        if ((p) == (null))
        {
            iMinKey = (int)(iKey);
            break;
        }

        if ((((pMatch) == (null)) &amp;&amp; ((p-&gt;nJson) == (nJson))) &amp;&amp; ((memcmp(p-&gt;zJson, zJson, (ulong)(nJson))) == (0)))
        {
            p-&gt;nErr = (byte)(0);
            pMatch = p;
        }
        else if ((p-&gt;iHold) &lt; (iMinHold))
        {
            iMinHold = (uint)(p-&gt;iHold);
            iMinKey = (int)(iKey);
        }

        if ((p-&gt;iHold) &gt; (iMaxHold))
        {
            iMaxHold = (uint)(p-&gt;iHold);
        }
    }

    if ((pMatch) != null)
    {
        pMatch-&gt;nErr = (byte)(0);
        pMatch-&gt;iHold = (uint)(iMaxHold + 1);
        return pMatch;
    }

    p = sqlite3_malloc64((ulong)(sizeof(JsonParse) + nJson + 1));
    if ((p) == (null))
    {
        sqlite3_result_error_nomem(pCtx);
        return null;
    }

    CRuntime.memset(p, (int)(0), (ulong)(sizeof(JsonParse)));
    p-&gt;zJson = (sbyte*)(&amp;p[1]);
    CRuntime.memcpy(p-&gt;zJson, zJson, (ulong)(nJson + 1));
    if ((jsonParse(p, pErrCtx, p-&gt;zJson)) != 0)
    {
        sqlite3_free(p);
        return null;
    }

    p-&gt;nJson = (int)(nJson);
    p-&gt;iHold = (uint)(iMaxHold + 1);
    sqlite3_set_auxdata(pCtx, (int)((-429938) + iMinKey), p, (Void(Void * ))(jsonParseFree));
    return (JsonParse*)(sqlite3_get_auxdata(pCtx, (int)((-429938) + iMinKey)));
}</function>
  <function>public static void jsonParseFillInParentage(JsonParse* pParse, uint i, uint iParent)
{
    JsonNode* pNode = &amp;pParse-&gt;aNode[i];
    uint j = 0;
    pParse-&gt;aUp[i] = (uint)(iParent);
    switch (pNode-&gt;eType)
    {
        case 6:
        {
            for (j = (uint)(1); (j) &lt;= (pNode-&gt;n); j += (uint)(jsonNodeSize(pNode + j)))
            {
                jsonParseFillInParentage(pParse, (uint)(i + j), (uint)(i));
            }

            break;
        }

        case 7:
        {
            for (j = (uint)(1); (j) &lt;= (pNode-&gt;n); j += (uint)(jsonNodeSize(pNode + j + 1) + 1))
            {
                pParse-&gt;aUp[i + j] = (uint)(i);
                jsonParseFillInParentage(pParse, (uint)(i + j + 1), (uint)(i));
            }

            break;
        }

        default:
        {
            break;
        }
    }
}</function>
  <function>public static int jsonParseFindParents(JsonParse* pParse)
{
    uint* aUp;
    aUp = pParse-&gt;aUp = sqlite3_malloc64((ulong)(sizeof(uint) * pParse-&gt;nNode));
    if ((aUp) == (null))
    {
        pParse-&gt;oom = (byte)(1);
        return (int)(7);
    }

    jsonParseFillInParentage(pParse, (uint)(0), (uint)(0));
    return (int)(0);
}</function>
  <function>public static void jsonParseFree(JsonParse* pParse)
{
    jsonParseReset(pParse);
    sqlite3_free(pParse);
}</function>
  <function>public static void jsonParseReset(JsonParse* pParse)
{
    sqlite3_free(pParse-&gt;aNode);
    pParse-&gt;aNode = null;
    pParse-&gt;nNode = (uint)(0);
    pParse-&gt;nAlloc = (uint)(0);
    sqlite3_free(pParse-&gt;aUp);
    pParse-&gt;aUp = null;
}</function>
  <function>public static int jsonParseValue(JsonParse* pParse, uint i)
{
    sbyte c = 0;
    uint j = 0;
    int iThis = 0;
    int x = 0;
    JsonNode* pNode;
    sbyte* z = pParse-&gt;zJson;
    while ((jsonIsSpace[(byte)(z[i])]) != 0)
    {
        i++;
    }

    if ((c = (sbyte)(z[i])) == (123))
    {
        iThis = (int)(jsonParseAddNode(pParse, (uint)(7), (uint)(0), null));
        if ((iThis) &lt; (0))
            return (int)(-1);
        for (j = (uint)(i + 1);; j++)
        {
            while ((jsonIsSpace[(byte)(z[j])]) != 0)
            {
                j++;
            }

            if ((++pParse-&gt;iDepth) &gt; (2000))
                return (int)(-1);
            x = (int)(jsonParseValue(pParse, (uint)(j)));
            if ((x) &lt; (0))
            {
                pParse-&gt;iDepth--;
                if (((x) == (-2)) &amp;&amp; ((pParse-&gt;nNode) == ((uint)(iThis) + 1)))
                    return (int)(j + 1);
                return (int)(-1);
            }

            if ((pParse-&gt;oom) != 0)
                return (int)(-1);
            pNode = &amp;pParse-&gt;aNode[pParse-&gt;nNode - 1];
            if (pNode-&gt;eType != 5)
                return (int)(-1);
            pNode-&gt;jnFlags |= (byte)(0x40);
            j = (uint)(x);
            while ((jsonIsSpace[(byte)(z[j])]) != 0)
            {
                j++;
            }

            if (z[j] != 58)
                return (int)(-1);
            j++;
            x = (int)(jsonParseValue(pParse, (uint)(j)));
            pParse-&gt;iDepth--;
            if ((x) &lt; (0))
                return (int)(-1);
            j = (uint)(x);
            while ((jsonIsSpace[(byte)(z[j])]) != 0)
            {
                j++;
            }

            c = (sbyte)(z[j]);
            if ((c) == (44))
                continue;
            if (c != 125)
                return (int)(-1);
            break;
        }

        pParse-&gt;aNode[iThis].n = (uint)(pParse-&gt;nNode - (uint)(iThis) - 1);
        return (int)(j + 1);
    }
    else if ((c) == (91))
    {
        iThis = (int)(jsonParseAddNode(pParse, (uint)(6), (uint)(0), null));
        if ((iThis) &lt; (0))
            return (int)(-1);
        CRuntime.memset(&amp;pParse-&gt;aNode[iThis].u, (int)(0), (ulong)(sizeof(union JsonNode::(unnamed at sqlite3.c : 193298 : 3)) ) )
        ;
        for (j = (uint)(i + 1);; j++)
        {
            while ((jsonIsSpace[(byte)(z[j])]) != 0)
            {
                j++;
            }

            if ((++pParse-&gt;iDepth) &gt; (2000))
                return (int)(-1);
            x = (int)(jsonParseValue(pParse, (uint)(j)));
            pParse-&gt;iDepth--;
            if ((x) &lt; (0))
            {
                if (((x) == (-3)) &amp;&amp; ((pParse-&gt;nNode) == ((uint)(iThis) + 1)))
                    return (int)(j + 1);
                return (int)(-1);
            }

            j = (uint)(x);
            while ((jsonIsSpace[(byte)(z[j])]) != 0)
            {
                j++;
            }

            c = (sbyte)(z[j]);
            if ((c) == (44))
                continue;
            if (c != 93)
                return (int)(-1);
            break;
        }

        pParse-&gt;aNode[iThis].n = (uint)(pParse-&gt;nNode - (uint)(iThis) - 1);
        return (int)(j + 1);
    }
    else if ((c) == (34))
    {
        byte jnFlags = (byte)(0);
        j = (uint)(i + 1);
        for (;;)
        {
            c = (sbyte)(z[j]);
            if ((c &amp; ~0x1f) == (0))
            {
                return (int)(-1);
            }

            if ((c) == (92))
            {
                c = (sbyte)(z[++j]);
                if ((((((((((c) == (34)) || ((c) == (92))) || ((c) == (47))) || ((c) == (98))) || ((c) == (102))) || ((c) == (110))) || ((c) == (114))) || ((c) == (116))) || (((c) == (117)) &amp;&amp; ((jsonIs4Hex(z + j + 1)) != 0)))
                {
                    jnFlags = (byte)(0x02);
                }
                else
                {
                    return (int)(-1);
                }
            }
            else if ((c) == (34))
            {
                break;
            }

            j++;
        }

        jsonParseAddNode(pParse, (uint)(5), (uint)(j + 1 - i), &amp;z[i]);
        if (pParse-&gt;oom == 0)
            pParse-&gt;aNode[pParse-&gt;nNode - 1].jnFlags = (byte)(jnFlags);
        return (int)(j + 1);
    }
    else if ((((c) == (110)) &amp;&amp; ((CRuntime.strncmp(z + i, "null", (ulong)(4))) == (0))) &amp;&amp; ((sqlite3CtypeMap[(byte)(z[i + 4])] &amp; 0x06) == 0))
    {
        jsonParseAddNode(pParse, (uint)(0), (uint)(0), null);
        return (int)(i + 4);
    }
    else if ((((c) == (116)) &amp;&amp; ((CRuntime.strncmp(z + i, "true", (ulong)(4))) == (0))) &amp;&amp; ((sqlite3CtypeMap[(byte)(z[i + 4])] &amp; 0x06) == 0))
    {
        jsonParseAddNode(pParse, (uint)(1), (uint)(0), null);
        return (int)(i + 4);
    }
    else if ((((c) == (102)) &amp;&amp; ((CRuntime.strncmp(z + i, "false", (ulong)(5))) == (0))) &amp;&amp; ((sqlite3CtypeMap[(byte)(z[i + 5])] &amp; 0x06) == 0))
    {
        jsonParseAddNode(pParse, (uint)(2), (uint)(0), null);
        return (int)(i + 5);
    }
    else if (((c) == (45)) || (((c) &gt;= (48)) &amp;&amp; ((c) &lt;= (57))))
    {
        byte seenDP = (byte)(0);
        byte seenE = (byte)(0);
        if ((c) &lt;= (48))
        {
            j = (uint)((c) == (45) ? i + 1 : i);
            if ((((z[j]) == (48)) &amp;&amp; ((z[j + 1]) &gt;= (48))) &amp;&amp; ((z[j + 1]) &lt;= (57)))
                return (int)(-1);
        }

        j = (uint)(i + 1);
        for (;; j++)
        {
            c = (sbyte)(z[j]);
            if (((c) &gt;= (48)) &amp;&amp; ((c) &lt;= (57)))
                continue;
            if ((c) == (46))
            {
                if ((z[j - 1]) == (45))
                    return (int)(-1);
                if ((seenDP) != 0)
                    return (int)(-1);
                seenDP = (byte)(1);
                continue;
            }

            if (((c) == (101)) || ((c) == (69)))
            {
                if ((z[j - 1]) &lt; (48))
                    return (int)(-1);
                if ((seenE) != 0)
                    return (int)(-1);
                seenDP = (byte)(seenE = (byte)(1));
                c = (sbyte)(z[j + 1]);
                if (((c) == (43)) || ((c) == (45)))
                {
                    j++;
                    c = (sbyte)(z[j + 1]);
                }

                if (((c) &lt; (48)) || ((c) &gt; (57)))
                    return (int)(-1);
                continue;
            }

            break;
        }

        if ((z[j - 1]) &lt; (48))
            return (int)(-1);
        jsonParseAddNode(pParse, (uint)((seenDP) != 0 ? 4 : 3), (uint)(j - i), &amp;z[i]);
        return (int)(j);
    }
    else if ((c) == (125))
    {
        return (int)(-2);
    }
    else if ((c) == (93))
    {
        return (int)(-3);
    }
    else if ((c) == (0))
    {
        return (int)(0);
    }
    else
    {
        return (int)(-1);
    }
}</function>
  <function>public static void jsonPatchFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse x = new JsonParse();
    JsonParse y = new JsonParse();
    JsonNode* pResult;
    if ((jsonParse(&amp;x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
        return;
    if ((jsonParse(&amp;y, ctx, (sbyte*)(sqlite3_value_text(argv[1])))) != 0)
    {
        jsonParseReset(&amp;x);
        return;
    }

    pResult = jsonMergePatch(&amp;x, (uint)(0), y.aNode);
    if ((pResult) != null)
    {
        jsonReturnJson(pResult, ctx, null);
    }
    else
    {
        sqlite3_result_error_nomem(ctx);
    }

    jsonParseReset(&amp;x);
    jsonParseReset(&amp;y);
}</function>
  <function>public static sbyte* jsonPathSyntaxError(sbyte* zErr)
{
    return sqlite3_mprintf("JSON path error near '%q'", zErr);
}</function>
  <function>public static void jsonPrintf(int N, JsonString p, sbyte* zFormat)
{
    sbyte* ap;
    if (((p.nUsed + N) &gt;= (p.nAlloc)) &amp;&amp; ((jsonGrow(p, (uint)(N))) != 0))
        return;
    (__va_start(&amp;ap, zFormat));
    sqlite3_vsnprintf((int)(N), p.zBuf + p.nUsed, zFormat, ap);
    ((void)(ap = null));
    p.nUsed += (ulong)((int)(CRuntime.strlen(p.zBuf + p.nUsed)));
}</function>
  <function>public static void jsonQuoteFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonString jx = new JsonString();
    jsonInit(jx, ctx);
    jsonAppendValue(jx, argv[0]);
    jsonResult(jx);
    sqlite3_result_subtype(ctx, (uint)(74));
}</function>
  <function>public static void jsonRemoveAllNulls(JsonNode* pNode)
{
    int i = 0; int  n  =  0 ; 
    n = (int)(pNode-&gt;n);
    for (i = (int)(2); (i) &lt;= (n); i += (int)(jsonNodeSize(&amp;pNode[i]) + 1))
    {
        switch (pNode[i].eType)
        {
            case 0:
                pNode[i].jnFlags |= (byte)(0x04);
                break;
            case 7:
                jsonRemoveAllNulls(&amp;pNode[i]);
                break;
        }
    }
}</function>
  <function>public static void jsonRemoveFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse x = new JsonParse();
    JsonNode* pNode;
    sbyte* zPath;
    uint i = 0;
    if ((argc) &lt; (1))
        return;
    if ((jsonParse(&amp;x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
        return;
    for (i = (uint)(1); (i) &lt; ((uint)(argc)); i++)
    {
        zPath = (sbyte*)(sqlite3_value_text(argv[i]));
        if ((zPath) == (null))
            goto remove_done;
        pNode = jsonLookup(&amp;x, zPath, null, ctx);
        if ((x.nErr) != 0)
            goto remove_done;
        if ((pNode) != null)
            pNode-&gt;jnFlags |= (byte)(0x04);
    }

    if ((x.aNode[0].jnFlags &amp; 0x04) == (0))
    {
        jsonReturnJson(x.aNode, ctx, null);
    }

    remove_done:
        ; jsonParseReset ( &amp; x ) ; 
}</function>
  <function>public static void jsonRenderNode(JsonNode* pNode, JsonString pOut, sqlite3_value aReplace)
{
    if ((pNode-&gt;jnFlags &amp; (0x08 | 0x10)) != 0)
    {
        if (((pNode-&gt;jnFlags &amp; 0x08) != 0) &amp;&amp; (aReplace != null))
        {
            jsonAppendValue(pOut, aReplace[pNode-&gt;u.iReplace]);
            return;
        }

        pNode = pNode-&gt;u.pPatch;
    }

    switch (pNode-&gt;eType)
    {
        default:
        {
            jsonAppendRaw(pOut, "null", (uint)(4));
            break;
        }

        case 1:
        {
            jsonAppendRaw(pOut, "true", (uint)(4));
            break;
        }

        case 2:
        {
            jsonAppendRaw(pOut, "false", (uint)(5));
            break;
        }

        case 5:
        {
            if ((pNode-&gt;jnFlags &amp; 0x01) != 0)
            {
                jsonAppendString(pOut, pNode-&gt;u.zJContent, (uint)(pNode-&gt;n));
                break;
            }
        }

        case 4:
        case 3:
        {
            jsonAppendRaw(pOut, pNode-&gt;u.zJContent, (uint)(pNode-&gt;n));
            break;
        }

        case 6:
        {
            uint j = (uint)(1);
            jsonAppendChar(pOut, (sbyte)(91));
            for (;;)
            {
                while ((j) &lt;= (pNode-&gt;n))
                {
                    if ((pNode[j].jnFlags &amp; 0x04) == (0))
                    {
                        jsonAppendSeparator(pOut);
                        jsonRenderNode(&amp;pNode[j], pOut, aReplace);
                    }

                    j += (uint)(jsonNodeSize(&amp;pNode[j]));
                }

                if ((pNode-&gt;jnFlags &amp; 0x20) == (0))
                    break;
                pNode = &amp;pNode[pNode-&gt;u.iAppend];
                j = (uint)(1);
            }

            jsonAppendChar(pOut, (sbyte)(93));
            break;
        }

        case 7:
        {
            uint j = (uint)(1);
            jsonAppendChar(pOut, (sbyte)(123));
            for (;;)
            {
                while ((j) &lt;= (pNode-&gt;n))
                {
                    if ((pNode[j + 1].jnFlags &amp; 0x04) == (0))
                    {
                        jsonAppendSeparator(pOut);
                        jsonRenderNode(&amp;pNode[j], pOut, aReplace);
                        jsonAppendChar(pOut, (sbyte)(58));
                        jsonRenderNode(&amp;pNode[j + 1], pOut, aReplace);
                    }

                    j += (uint)(1 + jsonNodeSize(&amp;pNode[j + 1]));
                }

                if ((pNode-&gt;jnFlags &amp; 0x20) == (0))
                    break;
                pNode = &amp;pNode[pNode-&gt;u.iAppend];
                j = (uint)(1);
            }

            jsonAppendChar(pOut, (sbyte)(125));
            break;
        }
    }
}</function>
  <function>public static void jsonReplaceFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse x = new JsonParse();
    JsonNode* pNode;
    sbyte* zPath;
    uint i = 0;
    if ((argc) &lt; (1))
        return;
    if ((argc &amp; 1) == (0))
    {
        jsonWrongNumArgs(ctx, "replace");
        return;
    }

    if ((jsonParse(&amp;x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
        return;
    for (i = (uint)(1); (i) &lt; ((uint)(argc)); i += (uint)(2))
    {
        zPath = (sbyte*)(sqlite3_value_text(argv[i]));
        pNode = jsonLookup(&amp;x, zPath, null, ctx);
        if ((x.nErr) != 0)
            goto replace_err;
        if ((pNode) != null)
        {
            pNode-&gt;jnFlags |= ((byte)(0x08));
            pNode-&gt;u.iReplace = (uint)(i + 1);
        }
    }

    if ((x.aNode[0].jnFlags &amp; 0x08) != 0)
    {
        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);
    }
    else
    {
        jsonReturnJson(x.aNode, ctx, argv);
    }

    replace_err:
        ; jsonParseReset ( &amp; x ) ; 
}</function>
  <function>public static void jsonReset(JsonString p)
{
    if (p.bStatic == 0)
        sqlite3_free(p.zBuf);
    jsonZero(p);
}</function>
  <function>public static void jsonResult(JsonString p)
{
    if ((p.bErr) == (0))
    {
        sqlite3_result_text64(p.pCtx, p.zBuf, (ulong)(p.nUsed), (p.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free, (byte)(1));
        jsonZero(p);
    }
}</function>
  <function>public static void jsonReturn(JsonNode* pNode, sqlite3_context pCtx, sqlite3_value aReplace)
{
    switch (pNode-&gt;eType)
    {
        default:
        {
            sqlite3_result_null(pCtx);
            break;
        }

        case 1:
        {
            sqlite3_result_int(pCtx, (int)(1));
            break;
        }

        case 2:
        {
            sqlite3_result_int(pCtx, (int)(0));
            break;
        }

        case 3:
        {
            long i = (long)(0);
            sbyte* z;
            z = pNode-&gt;u.zJContent;
            if ((z[0]) == (45))
            {
                z++;
            }

            while (((z[0]) &gt;= (48)) &amp;&amp; ((z[0]) &lt;= (57)))
            {
                uint v = (uint)(*(z++) - 48);
                if ((i) &gt;= ((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) / 10))
                {
                    if ((i) &gt; ((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) / 10))
                        goto int_as_real;
                    if (((z[0]) &gt;= (48)) &amp;&amp; ((z[0]) &lt;= (57)))
                        goto int_as_real;
                    if ((v) == (9))
                        goto int_as_real;
                    if ((v) == (8))
                    {
                        if ((pNode-&gt;u.zJContent[0]) == (45))
                        {
                            sqlite3_result_int64(pCtx, (long)(((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))));
                            goto int_done;
                        }
                        else
                        {
                            goto int_as_real;
                        }
                    }
                }

                i = (long)(i * 10 + v);
            }

            if ((pNode-&gt;u.zJContent[0]) == (45))
            {
                i = (long)(-i);
            }

            sqlite3_result_int64(pCtx, (long)(i));
            int_done:
                ;
            break;
            int_as_real:
                ;
        }

        case 4:
        {
            double r = 0;
            sbyte* z;
            z = pNode-&gt;u.zJContent;
            sqlite3AtoF(z, &amp;r, (int)(sqlite3Strlen30(z)), (byte)(1));
            sqlite3_result_double(pCtx, (double)(r));
            break;
        }

        case 5:
        {
            if ((pNode-&gt;jnFlags &amp; 0x02) == (0))
            {
                sqlite3_result_text(pCtx, pNode-&gt;u.zJContent + 1, (int)(pNode-&gt;n - 2), ((Void(Void * ))(-1)));
            }
            else
            {
                uint i = 0;
                uint n = (uint)(pNode-&gt;n);
                sbyte* z;
                sbyte* zOut;
                uint j = 0;
                z = pNode-&gt;u.zJContent;
                zOut = sqlite3_malloc((int)(n + 1));
                if ((zOut) == (null))
                {
                    sqlite3_result_error_nomem(pCtx);
                    break;
                }

                for (i = (uint)(1), j = (uint)(0); (i) &lt; (n - 1); i++)
                {
                    sbyte c = (sbyte)(z[i]);
                    if (c != 92)
                    {
                        zOut[j++] = (sbyte)(c);
                    }
                    else
                    {
                        c = (sbyte)(z[++i]);
                        if ((c) == (117))
                        {
                            uint v = (uint)(jsonHexToInt4(z + i + 1));
                            i += (uint)(4);
                            if ((v) == (0))
                                break;
                            if ((v) &lt;= (0x7f))
                            {
                                zOut[j++] = ((sbyte)(v));
                            }
                            else if ((v) &lt;= (0x7ff))
                            {
                                zOut[j++] = ((sbyte)(0xc0 | (v &gt;&gt; 6)));
                                zOut[j++] = (sbyte)(0x80 | (v &amp; 0x3f));
                            }
                            else
                            {
                                uint vlo = 0;
                                if ((((((v &amp; 0xfc00) == (0xd800)) &amp;&amp; ((i) &lt; (n - 6))) &amp;&amp; ((z[i + 1]) == (92))) &amp;&amp; ((z[i + 2]) == (117))) &amp;&amp; (((vlo = (uint)(jsonHexToInt4(z + i + 3))) &amp; 0xfc00) == (0xdc00)))
                                {
                                    v = (uint)(((v &amp; 0x3ff) &lt;&lt; 10) + (vlo &amp; 0x3ff) + 0x10000);
                                    i += (uint)(6);
                                    zOut[j++] = (sbyte)(0xf0 | (v &gt;&gt; 18));
                                    zOut[j++] = (sbyte)(0x80 | ((v &gt;&gt; 12) &amp; 0x3f));
                                    zOut[j++] = (sbyte)(0x80 | ((v &gt;&gt; 6) &amp; 0x3f));
                                    zOut[j++] = (sbyte)(0x80 | (v &amp; 0x3f));
                                }
                                else
                                {
                                    zOut[j++] = (sbyte)(0xe0 | (v &gt;&gt; 12));
                                    zOut[j++] = (sbyte)(0x80 | ((v &gt;&gt; 6) &amp; 0x3f));
                                    zOut[j++] = (sbyte)(0x80 | (v &amp; 0x3f));
                                }
                            }
                        }
                        else
                        {
                            if ((c) == (98))
                            {
                                c = (sbyte)(8);
                            }
                            else if ((c) == (102))
                            {
                                c = (sbyte)(12);
                            }
                            else if ((c) == (110))
                            {
                                c = (sbyte)(10);
                            }
                            else if ((c) == (114))
                            {
                                c = (sbyte)(13);
                            }
                            else if ((c) == (116))
                            {
                                c = (sbyte)(9);
                            }

                            zOut[j++] = (sbyte)(c);
                        }
                    }
                }

                zOut[j] = (sbyte)(0);
                sqlite3_result_text(pCtx, zOut, (int)(j), sqlite3_free);
            }

            break;
        }

        case 6:
        case 7:
        {
            jsonReturnJson(pNode, pCtx, aReplace);
            break;
        }
    }
}</function>
  <function>public static void jsonReturnJson(JsonNode* pNode, sqlite3_context pCtx, sqlite3_value aReplace)
{
    JsonString s = new JsonString();
    jsonInit(s, pCtx);
    jsonRenderNode(pNode, s, aReplace);
    jsonResult(s);
    sqlite3_result_subtype(pCtx, (uint)(74));
}</function>
  <function>public static void jsonSetFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse x = new JsonParse();
    JsonNode* pNode;
    sbyte* zPath;
    uint i = 0;
    int bApnd = 0;
    int bIsSet = (int)(sqlite3_user_data(ctx) != null);
    if ((argc) &lt; (1))
        return;
    if ((argc &amp; 1) == (0))
    {
        jsonWrongNumArgs(ctx, (bIsSet) != 0 ? "set" : "insert");
        return;
    }

    if ((jsonParse(&amp;x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
        return;
    for (i = (uint)(1); (i) &lt; ((uint)(argc)); i += (uint)(2))
    {
        zPath = (sbyte*)(sqlite3_value_text(argv[i]));
        bApnd = (int)(0);
        pNode = jsonLookup(&amp;x, zPath, &amp;bApnd, ctx);
        if ((x.oom) != 0)
        {
            sqlite3_result_error_nomem(ctx);
            goto jsonSetDone;
        }
        else if ((x.nErr) != 0)
        {
            goto jsonSetDone;
        }
        else if (((pNode) != null) &amp;&amp; (((bApnd) != 0) || ((bIsSet) != 0)))
        {
            pNode-&gt;jnFlags |= ((byte)(0x08));
            pNode-&gt;u.iReplace = (uint)(i + 1);
        }
    }

    if ((x.aNode[0].jnFlags &amp; 0x08) != 0)
    {
        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);
    }
    else
    {
        jsonReturnJson(x.aNode, ctx, argv);
    }

    jsonSetDone:
        ; jsonParseReset ( &amp; x ) ; 
}</function>
  <function>public static void jsonTypeFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse* p;
    sbyte* zPath;
    JsonNode* pNode;
    p = jsonParseCached(ctx, argv, ctx);
    if ((p) == (null))
        return;
    if ((argc) == (2))
    {
        zPath = (sbyte*)(sqlite3_value_text(argv[1]));
        pNode = jsonLookup(p, zPath, null, ctx);
    }
    else
    {
        pNode = p-&gt;aNode;
    }

    if ((pNode) != null)
    {
        sqlite3_result_text(ctx, jsonType[pNode-&gt;eType], (int)(-1), null);
    }
}</function>
  <function>public static void jsonValidFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
{
    JsonParse* p;
    p = jsonParseCached(ctx, argv, null);
    sqlite3_result_int(ctx, (int)(p != null));
}</function>
  <function>public static void jsonWrongNumArgs(sqlite3_context pCtx, sbyte* zFuncName)
{
    sbyte* zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments", zFuncName);
    sqlite3_result_error(pCtx, zMsg, (int)(-1));
    sqlite3_free(zMsg);
}</function>
  <function>public static void jsonZero(JsonString p)
{
    p.zBuf = p.zSpace;
    p.nAlloc = (ulong)(100 * sizeof(sbyte));
    p.nUsed = (ulong)(0);
    p.bStatic = (byte)(1);
}</function>
  <function>public static void juliandayFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    DateTime x = new DateTime();
    if ((isDate(context, (int)(argc), argv, &amp;x)) == (0))
    {
        computeJD(&amp;x);
        sqlite3_result_double(context, (double)(x.iJD / 86400000.0));
    }
}</function>
  <function>public static int keywordCode(sbyte* z, int n, int* pType)
{
    int i = 0; int  j  =  0 ; 
    sbyte* zKW;
    if ((n) &gt;= (2))
    {
        i = (int)(((sqlite3UpperToLower[(byte)(z[0])] * 4) ^ (sqlite3UpperToLower[(byte)(z[n - 1])] * 3) ^ n * 1) % 127);
        for (i = (int)(((int)(aKWHash[i])) - 1); (i) &gt;= (0); i = (int)(((int)(aKWNext[i])) - 1))
        {
            if (aKWLen[i] != n)
                continue;
            zKW = &amp;zKWText[aKWOffset[i]];
            if ((z[0] &amp; ~0x20) != zKW[0])
                continue;
            if ((z[1] &amp; ~0x20) != zKW[1])
                continue;
            j = (int)(2);
            while (((j) &lt; (n)) &amp;&amp; ((z[j] &amp; ~0x20) == (zKW[j])))
            {
                j++;
            }

            if ((j) &lt; (n))
                continue;
            *pType = (int)(aKWCode[i]);
            break;
        }
    }

    return (int)(n);
}</function>
  <function>public static void last_insert_rowid(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    sqlite3_result_int64(context, (long)(sqlite3_last_insert_rowid(db)));
}</function>
  <function>public static void last_valueFinalizeFunc(sqlite3_context pCtx)
{
    LastValueCtx p;
    p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
    if (((p) != null) &amp;&amp; ((p.pVal) != null))
    {
        sqlite3_result_value(pCtx, p.pVal);
        sqlite3_value_free(p.pVal);
        p.pVal = null;
    }
}</function>
  <function>public static void last_valueInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    LastValueCtx p;
    p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
    if ((p) != null)
    {
        p.nVal--;
        if ((p.nVal) == (0))
        {
            sqlite3_value_free(p.pVal);
            p.pVal = null;
        }
    }
}</function>
  <function>public static void last_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    LastValueCtx p;
    p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
    if ((p) != null)
    {
        sqlite3_value_free(p.pVal);
        p.pVal = sqlite3_value_dup(apArg[0]);
        if ((p.pVal) == (null))
        {
            sqlite3_result_error_nomem(pCtx);
        }
        else
        {
            p.nVal++;
        }
    }
}</function>
  <function>public static void last_valueValueFunc(sqlite3_context pCtx)
{
    LastValueCtx p;
    p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(0)));
    if (((p) != null) &amp;&amp; ((p.pVal) != null))
    {
        sqlite3_result_value(pCtx, p.pVal);
    }
}</function>
  <function>public static void lengthFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    switch (sqlite3_value_type(argv[0]))
    {
        case 4:
        case 1:
        case 2:
        {
            sqlite3_result_int(context, (int)(sqlite3_value_bytes(argv[0])));
            break;
        }

        case 3:
        {
            byte* z = sqlite3_value_text(argv[0]);
            byte* z0;
            byte c = 0;
            if ((z) == (null))
                return;
            z0 = z;
            while ((c = (byte)(*z)) != 0)
            {
                z++;
                if ((c) &gt;= (0xc0))
                {
                    while ((*z &amp; 0xc0) == (0x80))
                    {
                        z++;
                        z0++;
                    }
                }
            }

            sqlite3_result_int(context, (int)(z - z0));
            break;
        }

        default:
        {
            sqlite3_result_null(context);
            break;
        }
    }
}</function>
  <function>public static void likeFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* zA; byte  * zB ; 
    uint escape = 0;
    int nPat = 0;
    sqlite3 db = sqlite3_context_db_handle(context);
    compareInfo* pInfo = sqlite3_user_data(context);
    compareInfo backupInfo = new compareInfo();
    nPat = (int)(sqlite3_value_bytes(argv[0]));
    if ((nPat) &gt; (db.aLimit[8]))
    {
        sqlite3_result_error(context, "LIKE or GLOB pattern too complex", (int)(-1));
        return;
    }

    if ((argc) == (3))
    {
        byte* zEsc = sqlite3_value_text(argv[2]);
        if ((zEsc) == (null))
            return;
        if (sqlite3Utf8CharLen((sbyte*)(zEsc), (int)(-1)) != 1)
        {
            sqlite3_result_error(context, "ESCAPE expression must be a single character", (int)(-1));
            return;
        }

        escape = (uint)(sqlite3Utf8Read(&amp;zEsc));
        if (((escape) == (pInfo-&gt;matchAll)) || ((escape) == (pInfo-&gt;matchOne)))
        {
            CRuntime.memcpy(&amp;backupInfo, pInfo, (ulong)(sizeof(compareInfo)));
            pInfo = &amp;backupInfo;
            if ((escape) == (pInfo-&gt;matchAll))
                pInfo-&gt;matchAll = (byte)(0);
            if ((escape) == (pInfo-&gt;matchOne))
                pInfo-&gt;matchOne = (byte)(0);
        }
    }
    else
    {
        escape = (uint)(pInfo-&gt;matchSet);
    }

    zB = sqlite3_value_text(argv[0]);
    zA = sqlite3_value_text(argv[1]);
    if (((zA) != null) &amp;&amp; ((zB) != null))
    {
        sqlite3_result_int(context, ((patternCompare(zB, zA, pInfo, (uint)(escape))) == (0) ? 1 : 0));
    }
}</function>
  <function>public static void loadAnalysis(Parse pParse, int iDb)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    if ((v) != null)
    {
        sqlite3VdbeAddOp1(v, (int)(149), (int)(iDb));
    }
}</function>
  <function>public static void loadExt(sqlite3_context context, int argc, sqlite3_value argv)
{
    sbyte* zFile = (sbyte*)(sqlite3_value_text(argv[0]));
    sbyte* zProc;
    sqlite3 db = sqlite3_context_db_handle(context);
    sbyte* zErrMsg = null;
    if ((db.flags &amp; 0x00020000) == (0))
    {
        sqlite3_result_error(context, "not authorized", (int)(-1));
        return;
    }

    if ((argc) == (2))
    {
        zProc = (sbyte*)(sqlite3_value_text(argv[1]));
    }
    else
    {
        zProc = null;
    }

    if (((zFile) != null) &amp;&amp; ((sqlite3_load_extension(db, zFile, zProc, &amp;zErrMsg)) != 0))
    {
        sqlite3_result_error(context, zErrMsg, (int)(-1));
        sqlite3_free(zErrMsg);
    }
}</function>
  <function>public static int lockBtree(BtShared pBt)
{
    int rc = 0;
    MemPage pPage1;
    uint nPage = 0;
    uint nPageFile = (uint)(0);
    rc = (int)(sqlite3PagerSharedLock(pBt.pPager));
    if (rc != 0)
        return (int)(rc);
    rc = (int)(btreeGetPage(pBt, (uint)(1), pPage1, (int)(0)));
    if (rc != 0)
        return (int)(rc);
    nPage = (uint)(sqlite3Get4byte(28 + pPage1.aData));
    sqlite3PagerPagecount(pBt.pPager, (int*)(&amp;nPageFile));
    if (((nPage) == (0)) || (memcmp(24 + pPage1.aData, 92 + pPage1.aData, (ulong)(4)) != 0))
    {
        nPage = (uint)(nPageFile);
    }

    if ((pBt.db.flags &amp; 0x02000000) != 0)
    {
        nPage = (uint)(0);
    }

    if ((nPage) &gt; (0))
    {
        uint pageSize = 0;
        uint usableSize = 0;
        byte* page1 = pPage1.aData;
        rc = (int)(26);
        if (memcmp(page1, zMagicHeader, (ulong)(16)) != 0)
        {
            goto page1_init_failed;
        }

        if ((page1[18]) &gt; (2))
        {
            pBt.btsFlags |= (ushort)(0x0001);
        }

        if ((page1[19]) &gt; (2))
        {
            goto page1_init_failed;
        }

        if (((page1[19]) == (2)) &amp;&amp; ((pBt.btsFlags &amp; 0x0020) == (0)))
        {
            int isOpen = (int)(0);
            rc = (int)(sqlite3PagerOpenWal(pBt.pPager, &amp;isOpen));
            if (rc != 0)
            {
                goto page1_init_failed;
            }
            else
            {
                if ((isOpen) == (0))
                {
                    releasePageOne(pPage1);
                    return (int)(0);
                }
            }

            rc = (int)(26);
        }
        else
        {
        }

        if (memcmp(&amp;page1[21], "@  ", (ulong)(3)) != 0)
        {
            goto page1_init_failed;
        }

        pageSize = (uint)((page1[16] &lt;&lt; 8) | (page1[17] &lt;&lt; 16));
        if (((((pageSize - 1) &amp; pageSize) != 0) || ((pageSize) &gt; (65536))) || ((pageSize) &lt;= (256)))
        {
            goto page1_init_failed;
        }

        pBt.btsFlags |= (ushort)(0x0002);
        usableSize = (uint)(pageSize - page1[20]);
        if (pageSize != pBt.pageSize)
        {
            releasePageOne(pPage1);
            pBt.usableSize = (uint)(usableSize);
            pBt.pageSize = (uint)(pageSize);
            freeTempSpace(pBt);
            rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &amp;pBt.pageSize, (int)(pageSize - usableSize)));
            return (int)(rc);
        }

        if ((nPage) &gt; (nPageFile))
        {
            if ((sqlite3WritableSchema(pBt.db)) == (0))
            {
                rc = (int)(sqlite3CorruptError((int)(69402)));
                goto page1_init_failed;
            }
            else
            {
                nPage = (uint)(nPageFile);
            }
        }

        if ((usableSize) &lt; (480))
        {
            goto page1_init_failed;
        }

        pBt.pageSize = (uint)(pageSize);
        pBt.usableSize = (uint)(usableSize);
        pBt.autoVacuum = (byte)((sqlite3Get4byte(&amp;page1[36 + 4 * 4])) != 0 ? 1 : 0);
        pBt.incrVacuum = (byte)((sqlite3Get4byte(&amp;page1[36 + 7 * 4])) != 0 ? 1 : 0);
    }

    pBt.maxLocal = ((ushort)((pBt.usableSize - 12) * 64 / 255 - 23));
    pBt.minLocal = ((ushort)((pBt.usableSize - 12) * 32 / 255 - 23));
    pBt.maxLeaf = ((ushort)(pBt.usableSize - 35));
    pBt.minLeaf = ((ushort)((pBt.usableSize - 12) * 32 / 255 - 23));
    if ((pBt.maxLocal) &gt; (127))
    {
        pBt.max1bytePayload = (byte)(127);
    }
    else
    {
        pBt.max1bytePayload = ((byte)(pBt.maxLocal));
    }

    pBt.pPage1 = pPage1;
    pBt.nPage = (uint)(nPage);
    return (int)(0);
    page1_init_failed:
        ; releasePageOne ( pPage1 ) ; 
    pBt.pPage1 = null;
    return (int)(rc);
}</function>
  <function>public static void lockBtreeMutex(Btree p)
{
    sqlite3_mutex_enter(p.pBt.mutex);
    p.pBt.db = p.db;
    p.locked = (byte)(1);
}</function>
  <function>public static void lockTable(Parse pParse, int iDb, uint iTab, byte isWriteLock, sbyte* zName)
{
    Parse pToplevel;
    int i = 0;
    int nBytes = 0;
    TableLock* p;
    pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    for (i = (int)(0); (i) &lt; (pToplevel.nTableLock); i++)
    {
        p = &amp;pToplevel.aTableLock[i];
        if (((p-&gt;iDb) == (iDb)) &amp;&amp; ((p-&gt;iTab) == (iTab)))
        {
            p-&gt;isWriteLock = (byte)(((p-&gt;isWriteLock) != 0) || ((isWriteLock) != 0));
            return;
        }
    }

    nBytes = (int)(sizeof(TableLock) * (pToplevel.nTableLock + 1));
    pToplevel.aTableLock = sqlite3DbReallocOrFree(pToplevel.db, pToplevel.aTableLock, (ulong)(nBytes));
    if ((pToplevel.aTableLock) != null)
    {
        p = &amp;pToplevel.aTableLock[pToplevel.nTableLock++];
        p-&gt;iDb = (int)(iDb);
        p-&gt;iTab = (uint)(iTab);
        p-&gt;isWriteLock = (byte)(isWriteLock);
        p-&gt;zLockName = zName;
    }
    else
    {
        pToplevel.nTableLock = (int)(0);
        sqlite3OomFault(pToplevel.db);
    }
}</function>
  <function>public static void logBadConnection(sbyte* zType)
{
    sqlite3_log((int)(21), "API call with %s database connection pointer", zType);
}</function>
  <function>public static int lookasideMallocSize(sqlite3 db, void* p)
{
    return (int)((p) &lt; (db.lookaside.pMiddle) ? db.lookaside.szTrue : 128);
}</function>
  <function>public static int lookupName(Parse pParse, sbyte* zDb, sbyte* zTab, sbyte* zCol, NameContext pNC, Expr pExpr)
{
    int i = 0; int  j  =  0 ; 
    int cnt = (int)(0);
    int cntTab = (int)(0);
    int nSubquery = (int)(0);
    sqlite3 db = pParse.db;
    SrcItem pItem;
    SrcItem pMatch = null;
    NameContext pTopNC = pNC;
    Schema pSchema = null;
    int eNewExprOp = (int)(167);
    Table pTab = null;
    Column* pCol;
    pExpr.iTable = (int)(-1);
    if ((zDb) != null)
    {
        if ((pNC.ncFlags &amp; (0x000002 | 0x000004)) != 0)
        {
            zDb = null;
        }
        else
        {
            for (i = (int)(0); (i) &lt; (db.nDb); i++)
            {
                if ((sqlite3StrICmp(db.aDb[i].zDbSName, zDb)) == (0))
                {
                    pSchema = db.aDb[i].pSchema;
                    break;
                }
            }

            if (((i) == (db.nDb)) &amp;&amp; ((sqlite3StrICmp("main", zDb)) == (0)))
            {
                pSchema = db.aDb[0].pSchema;
                zDb = db.aDb[0].zDbSName;
            }
        }
    }

    do
    {
        ExprList pEList;
        SrcList pSrcList = pNC.pSrcList;
        if ((pSrcList) != null)
        {
            for (i = (int)(0), pItem = pSrcList.a; (i) &lt; (pSrcList.nSrc); i++, pItem++)
            {
                byte hCol = 0;
                pTab = pItem.pTab;
                if (((pItem.pSelect) != null) &amp;&amp; ((pItem.pSelect.selFlags &amp; 0x0000800) != 0))
                {
                    int hit = (int)(0);
                    pEList = pItem.pSelect.pEList;
                    for (j = (int)(0); (j) &lt; (pEList.nExpr); j++)
                    {
                        if ((sqlite3MatchEName(&amp;pEList.a[j], zCol, zTab, zDb)) != 0)
                        {
                            cnt++;
                            cntTab = (int)(2);
                            pMatch = pItem;
                            pExpr.iColumn = (short)(j);
                            hit = (int)(1);
                        }
                    }

                    if (((hit) != 0) || ((zTab) == (null)))
                        continue;
                }

                if ((zDb) != null)
                {
                    if (pTab.pSchema != pSchema)
                        continue;
                    if (((pSchema) == (null)) &amp;&amp; (CRuntime.strcmp(zDb, "*") != 0))
                        continue;
                }

                if ((zTab) != null)
                {
                    sbyte* zTabName = (pItem.zAlias) != 0 ? pItem.zAlias : pTab.zName;
                    if (sqlite3StrICmp(zTabName, zTab) != 0)
                    {
                        continue;
                    }

                    if (((pParse.eParseMode) &gt;= (2)) &amp;&amp; ((pItem.zAlias) != null))
                    {
                        sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr.y.pTab));
                    }
                }

                hCol = (byte)(sqlite3StrIHash(zCol));
                for (j = (int)(0), pCol = pTab.aCol; (j) &lt; (pTab.nCol); j++, pCol++)
                {
                    if (((pCol-&gt;hName) == (hCol)) &amp;&amp; ((sqlite3StrICmp(pCol-&gt;zCnName, zCol)) == (0)))
                    {
                        if ((cnt) == (1))
                        {
                            if ((pItem.fg.jointype &amp; 0x0004) != 0)
                                continue;
                            if ((nameInUsingClause(pItem.pUsing, zCol)) != 0)
                                continue;
                        }

                        cnt++;
                        pMatch = pItem;
                        pExpr.iColumn = (short)((j) == (pTab.iPKey) ? -1 : (short)(j));
                        break;
                    }
                }

                if (((0) == (cnt)) &amp;&amp; (((pTab).tabFlags &amp; 0x00000200) == (0)))
                {
                    cntTab++;
                    pMatch = pItem;
                }
            }

            if ((pMatch) != null)
            {
                pExpr.iTable = (int)(pMatch.iCursor);
                pExpr.y.pTab = pMatch.pTab;
                if ((pMatch.fg.jointype &amp; 0x0008) != 0)
                {
                    (pExpr).flags |= (uint)(0x100000);
                }

                pSchema = pExpr.y.pTab.pSchema;
            }
        }

        if (((cnt) == (0)) &amp;&amp; ((zDb) == (null)))
        {
            pTab = null;
            if (pParse.pTriggerTab != null)
            {
                int op = (int)(pParse.eTriggerOp);
                if ((pParse.bReturning) != 0)
                {
                    if (((pNC.ncFlags &amp; 0x000400) != 0) &amp;&amp; (((zTab) == (null)) || ((sqlite3StrICmp(zTab, pParse.pTriggerTab.zName)) == (0))))
                    {
                        pExpr.iTable = (int)(op != 128);
                        pTab = pParse.pTriggerTab;
                    }
                }
                else if (((op != 128) &amp;&amp; ((zTab) != null)) &amp;&amp; ((sqlite3StrICmp("new", zTab)) == (0)))
                {
                    pExpr.iTable = (int)(1);
                    pTab = pParse.pTriggerTab;
                }
                else if (((op != 127) &amp;&amp; ((zTab) != null)) &amp;&amp; ((sqlite3StrICmp("old", zTab)) == (0)))
                {
                    pExpr.iTable = (int)(0);
                    pTab = pParse.pTriggerTab;
                }
            }

            if (((pNC.ncFlags &amp; 0x000200) != 0) &amp;&amp; (zTab != null))
            {
                Upsert pUpsert = pNC.uNC.pUpsert;
                if (((pUpsert) != null) &amp;&amp; ((sqlite3StrICmp("excluded", zTab)) == (0)))
                {
                    pTab = pUpsert.pUpsertSrc.a[0].pTab;
                    pExpr.iTable = (int)(2);
                }
            }

            if ((pTab) != null)
            {
                int iCol = 0;
                byte hCol = (byte)(sqlite3StrIHash(zCol));
                pSchema = pTab.pSchema;
                cntTab++;
                for (iCol = (int)(0), pCol = pTab.aCol; (iCol) &lt; (pTab.nCol); iCol++, pCol++)
                {
                    if (((pCol-&gt;hName) == (hCol)) &amp;&amp; ((sqlite3StrICmp(pCol-&gt;zCnName, zCol)) == (0)))
                    {
                        if ((iCol) == (pTab.iPKey))
                        {
                            iCol = (int)(-1);
                        }

                        break;
                    }
                }

                if ((((iCol) &gt;= (pTab.nCol)) &amp;&amp; ((sqlite3IsRowid(zCol)) != 0)) &amp;&amp; (((pTab).tabFlags &amp; 0x00000200) == (0)))
                {
                    iCol = (int)(-1);
                }

                if ((iCol) &lt; (pTab.nCol))
                {
                    cnt++;
                    pMatch = null;
                    if ((pExpr.iTable) == (2))
                    {
                        if (((pParse.eParseMode) &gt;= (2)))
                        {
                            pExpr.iColumn = (short)(iCol);
                            pExpr.y.pTab = pTab;
                            eNewExprOp = (int)(167);
                        }
                        else
                        {
                            pExpr.iTable = (int)(pNC.uNC.pUpsert.regData + sqlite3TableColumnToStorage(pTab, (short)(iCol)));
                            eNewExprOp = (int)(176);
                        }
                    }
                    else
                    {
                        pExpr.y.pTab = pTab;
                        if ((pParse.bReturning) != 0)
                        {
                            eNewExprOp = (int)(176);
                            pExpr.op2 = (byte)(167);
                            pExpr.iTable = (int)(pNC.uNC.iBaseReg + (pTab.nCol + 1) * pExpr.iTable + sqlite3TableColumnToStorage(pTab, (short)(iCol)) + 1);
                        }
                        else
                        {
                            pExpr.iColumn = ((short)(iCol));
                            eNewExprOp = (int)(77);
                            if ((iCol) &lt; (0))
                            {
                                pExpr.affExpr = (sbyte)(0x44);
                            }
                            else if ((pExpr.iTable) == (0))
                            {
                                pParse.oldmask |= (uint)((iCol) &gt;= (32) ? 0xffffffff : (((uint)(1)) &lt;&lt; iCol));
                            }
                            else
                            {
                                pParse.newmask |= (uint)((iCol) &gt;= (32) ? 0xffffffff : (((uint)(1)) &lt;&lt; iCol));
                            }
                        }
                    }
                }
            }
        }

        if (((((((cnt) == (0)) &amp;&amp; ((cntTab) == (1))) &amp;&amp; ((pMatch) != null)) &amp;&amp; ((pNC.ncFlags &amp; (0x000020 | 0x000008)) == (0))) &amp;&amp; ((sqlite3IsRowid(zCol)) != 0)) &amp;&amp; ((((pMatch.pTab).tabFlags &amp; 0x00000200) == (0)) != 0))
        {
            cnt = (int)(1);
            pExpr.iColumn = (short)(-1);
            pExpr.affExpr = (sbyte)(0x44);
        }

        if ((((cnt) == (0)) &amp;&amp; ((pNC.ncFlags &amp; 0x000080) != 0)) &amp;&amp; ((zTab) == (null)))
        {
            pEList = pNC.uNC.pEList;
            for (j = (int)(0); (j) &lt; (pEList.nExpr); j++)
            {
                sbyte* zAs = pEList.a[j].zEName;
                if (((pEList.a[j].eEName) == (0)) &amp;&amp; ((sqlite3_stricmp(zAs, zCol)) == (0)))
                {
                    Expr pOrig;
                    pOrig = pEList.a[j].pExpr;
                    if (((pNC.ncFlags &amp; 0x000001) == (0)) &amp;&amp; (((pOrig).flags &amp; (0x000010)) != 0))
                    {
                        sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
                        return (int)(2);
                    }

                    if ((((pOrig).flags &amp; (0x008000)) != 0) &amp;&amp; (((pNC.ncFlags &amp; 0x004000) == (0)) || (pNC != pTopNC)))
                    {
                        sqlite3ErrorMsg(pParse, "misuse of aliased window function %s", zAs);
                        return (int)(2);
                    }

                    if (sqlite3ExprVectorSize(pOrig) != 1)
                    {
                        sqlite3ErrorMsg(pParse, "row value misused");
                        return (int)(2);
                    }

                    resolveAlias(pParse, pEList, (int)(j), pExpr, (int)(nSubquery));
                    cnt = (int)(1);
                    pMatch = null;
                    if (((pParse.eParseMode) &gt;= (2)))
                    {
                        sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr));
                    }

                    goto lookupname_end;
                }
            }
        }

        if ((cnt) != 0)
            break;
        pNC = pNC.pNext;
        nSubquery++;
    }
    while ((pNC) != null);
    if (((cnt) == (0)) &amp;&amp; ((zTab) == (null)))
    {
        if ((((pExpr).flags &amp; (0x000040)) != 0) &amp;&amp; ((areDoubleQuotedStringsEnabled(db, pTopNC)) != 0))
        {
            sqlite3_log((int)(28), "double-quoted string literal: \"%w\"", zCol);
            pExpr.op = (byte)(117);
            CRuntime.memset(&amp;pExpr.y, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18103 : 3)) ) )
            ;
            return (int)(1);
        }

        if ((sqlite3ExprIdToTrueFalse(pExpr)) != 0)
        {
            return (int)(1);
        }
    }

    if (cnt != 1)
    {
        sbyte* zErr;
        zErr = (cnt) == (0) ? "no such column" : "ambiguous column name";
        if ((zDb) != null)
        {
            sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
        }
        else if ((zTab) != null)
        {
            sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
        }
        else
        {
            sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
        }

        sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
        pParse.checkSchema = (byte)(1);
        pTopNC.nNcErr++;
    }

    if (((pExpr.iColumn) &gt;= (0)) &amp;&amp; (pMatch != null))
    {
        pMatch.colUsed |= (ulong)(sqlite3ExprColUsed(pExpr));
    }

    if (!(((pExpr).flags &amp; (0x004000 | 0x800000)) != 0))
    {
        sqlite3ExprDelete(db, pExpr.pLeft);
        pExpr.pLeft = null;
        sqlite3ExprDelete(db, pExpr.pRight);
        pExpr.pRight = null;
    }

    pExpr.op = (byte)(eNewExprOp);
    (pExpr).flags |= (uint)(0x800000);
    lookupname_end:
        ; if  ( ( cnt ) == ( 1 ) ) { if  ( ( ( pParse . db . xAuth ) != null ) &amp;&amp; ( ( ( pExpr . op ) == ( 167 ) ) || ( ( pExpr . op ) == ( 77 ) ) ) ) { sqlite3AuthRead ( pParse ,  pExpr ,  pSchema ,  pNC . pSrcList ) ;  } for  ( ; ; ) { pTopNC . nRef ++ ;  if  ( ( pTopNC ) == ( pNC ) ) break ;  pTopNC  =  pTopNC . pNext ;  } return  ( int ) ( 1 ) ;  } else  { return  ( int ) ( 2 ) ;  }
}</function>
  <function>public static void lowerFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    sbyte* z1;
    sbyte* z2;
    int i = 0; int  n  =  0 ; 
    z2 = (sbyte*)(sqlite3_value_text(argv[0]));
    n = (int)(sqlite3_value_bytes(argv[0]));
    if ((z2) != null)
    {
        z1 = contextMalloc(context, (long)(((long)(n)) + 1));
        if ((z1) != null)
        {
            for (i = (int)(0); (i) &lt; (n); i++)
            {
                z1[i] = (sbyte)(sqlite3UpperToLower[(byte)(z2[i])]);
            }

            sqlite3_result_text(context, z1, (int)(n), sqlite3_free);
        }
    }
}</function>
  <function>public static void makeColumnPartOfPrimaryKey(Parse pParse, Column* pCol)
{
    pCol-&gt;colFlags |= (ushort)(0x0001);
    if ((pCol-&gt;colFlags &amp; 0x0060) != 0)
    {
        sqlite3ErrorMsg(pParse, "generated columns cannot be part of the PRIMARY KEY");
    }
}</function>
  <function>public static int makeSorterRecord(Parse pParse, SortCtx pSort, Select pSelect, int regBase, int nBase)
{
    int nOBSat = (int)(pSort.nOBSat);
    Vdbe v = pParse.pVdbe;
    int regOut = (int)(++pParse.nMem);
    if ((pSort.pDeferredRowLoad) != null)
    {
        innerLoopLoadRow(pParse, pSelect, pSort.pDeferredRowLoad);
    }

    sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase + nOBSat), (int)(nBase - nOBSat), (int)(regOut));
    return (int)(regOut);
}</function>
  <function>public static void mallocWithAlarm(int n, void** pp)
{
    void* p;
    int nFull = 0;
    nFull = (int)(sqlite3Config.m.xRoundup((int)(n)));
    sqlite3StatusHighwater((int)(5), (int)(n));
    if ((mem0.alarmThreshold) &gt; (0))
    {
        long nUsed = (long)(sqlite3StatusValue((int)(0)));
        if ((nUsed) &gt;= (mem0.alarmThreshold - nFull))
        {
            (1);
            sqlite3MallocAlarm((int)(nFull));
            if ((mem0.hardLimit) != 0)
            {
                nUsed = (long)(sqlite3StatusValue((int)(0)));
                if ((nUsed) &gt;= (mem0.hardLimit - nFull))
                {
                    *pp = null;
                    return;
                }
            }
        }
        else
        {
            (0);
        }
    }

    p = sqlite3Config.m.xMalloc((int)(nFull));
    if ((p) != null)
    {
        nFull = (int)(sqlite3MallocSize(p));
        sqlite3StatusUp((int)(0), (int)(nFull));
        sqlite3StatusUp((int)(9), (int)(1));
    }

    *pp = p;
}</function>
  <function>public static void markTermAsChild(WhereClause pWC, int iChild, int iParent)
{
    pWC.a[iChild].iParent = (int)(iParent);
    pWC.a[iChild].truthProb = (short)(pWC.a[iParent].truthProb);
    pWC.a[iParent].nChild++;
}</function>
  <function>public static int matchQuality(FuncDef p, int nArg, byte enc)
{
    int match = 0;
    if (p.nArg != nArg)
    {
        if ((nArg) == (-2))
            return (int)(((p.xSFunc) == (null)) ? 0 : 6);
        if ((p.nArg) &gt;= (0))
            return (int)(0);
    }

    if ((p.nArg) == (nArg))
    {
        match = (int)(4);
    }
    else
    {
        match = (int)(1);
    }

    if ((enc) == (p.funcFlags &amp; 0x0003))
    {
        match += (int)(2);
    }
    else if ((enc &amp; p.funcFlags &amp; 2) != 0)
    {
        match += (int)(1);
    }

    return (int)(match);
}</function>
  <function>public static void measureAllocationSize(sqlite3 db, void* p)
{
    *db.pnBytesFreed += (int)(sqlite3DbMallocSize(db, p));
}</function>
  <function>public static int memdbAccess(sqlite3_vfs pVfs, sbyte* zPath, int flags, int* pResOut)
{
    *pResOut = (int)(0);
    return (int)(0);
}</function>
  <function>public static int memdbClose(sqlite3_file pFile)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    if ((p-&gt;zFName) != null)
    {
        int i = 0;
        sqlite3_mutex* pVfsMutex = sqlite3MutexAlloc((int)(11));
        sqlite3_mutex_enter(pVfsMutex);
        for (i = (int)(0); ((i) &lt; (memdb_g.nMemStore)); i++)
        {
            if ((memdb_g.apMemStore[i]) == (p))
            {
                memdbEnter(p);
                if ((p-&gt;nRef) == (1))
                {
                    memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];
                    if ((memdb_g.nMemStore) == (0))
                    {
                        sqlite3_free(memdb_g.apMemStore);
                        memdb_g.apMemStore = null;
                    }
                }

                break;
            }
        }

        sqlite3_mutex_leave(pVfsMutex);
    }
    else
    {
        memdbEnter(p);
    }

    p-&gt;nRef--;
    if ((p-&gt;nRef) &lt;= (0))
    {
        if ((p-&gt;mFlags &amp; 1) != 0)
        {
            sqlite3_free(p-&gt;aData);
        }

        memdbLeave(p);
        sqlite3_mutex_free(p-&gt;pMutex);
        sqlite3_free(p);
    }
    else
    {
        memdbLeave(p);
    }

    return (int)(0);
}</function>
  <function>public static int memdbCurrentTimeInt64(sqlite3_vfs pVfs, long* p)
{
    return (int)(((sqlite3_vfs)((pVfs).pAppData)).xCurrentTimeInt64(((sqlite3_vfs)((pVfs).pAppData)), p));
}</function>
  <function>public static int memdbDeviceCharacteristics(sqlite3_file pFile)
{
    return (int)(0x00000001 | 0x00001000 | 0x00000200 | 0x00000400);
}</function>
  <function>public static void memdbDlClose(sqlite3_vfs pVfs, void* pHandle)
{
    ((sqlite3_vfs)((pVfs).pAppData)).xDlClose(((sqlite3_vfs)((pVfs).pAppData)), pHandle);
}</function>
  <function>public static void memdbDlError(sqlite3_vfs pVfs, int nByte, sbyte* zErrMsg)
{
    ((sqlite3_vfs)((pVfs).pAppData)).xDlError(((sqlite3_vfs)((pVfs).pAppData)), (int)(nByte), zErrMsg);
}</function>
  <function>public static void* memdbDlOpen(sqlite3_vfs pVfs, sbyte* zPath)
{
    return ((sqlite3_vfs)((pVfs).pAppData)).xDlOpen(((sqlite3_vfs)((pVfs).pAppData)), zPath);
}</function>
  <function>public static Void ( )memdbDlSym(sqlite3_vfs pVfs, void* p, sbyte* zSym)
{
    return ((sqlite3_vfs)((pVfs).pAppData)).xDlSym(((sqlite3_vfs)((pVfs).pAppData)), p, zSym);
}</function>
  <function>public static int memdbEnlarge(MemStore* p, long newSz)
{
    byte* pNew;
    if (((p-&gt;mFlags &amp; 2) == (0)) || ((p-&gt;nMmap) &gt; (0)))
    {
        return (int)(13);
    }

    if ((newSz) &gt; (p-&gt;szMax))
    {
        return (int)(13);
    }

    newSz *= (long)(2);
    if ((newSz) &gt; (p-&gt;szMax))
        newSz = (long)(p-&gt;szMax);
    pNew = sqlite3Realloc(p-&gt;aData, (ulong)(newSz));
    if ((pNew) == (null))
        return (int)(10 | (12 &lt;&lt; 8));
    p-&gt;aData = pNew;
    p-&gt;szAlloc = (long)(newSz);
    return (int)(0);
}</function>
  <function>public static void memdbEnter(MemStore* p)
{
    sqlite3_mutex_enter(p-&gt;pMutex);
}</function>
  <function>public static int memdbFetch(sqlite3_file pFile, long iOfst, int iAmt, void** pp)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    memdbEnter(p);
    if (((iOfst + iAmt) &gt; (p-&gt;sz)) || ((p-&gt;mFlags &amp; 2) != 0))
    {
        *pp = null;
    }
    else
    {
        p-&gt;nMmap++;
        *pp = (void*)(p-&gt;aData + iOfst);
    }

    memdbLeave(p);
    return (int)(0);
}</function>
  <function>public static int memdbFileControl(sqlite3_file pFile, int op, void* pArg)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    int rc = (int)(12);
    memdbEnter(p);
    if ((op) == (12))
    {
        *(sbyte**)(pArg) = sqlite3_mprintf("memdb(%p,%lld)", p-&gt;aData, (long)(p-&gt;sz));
        rc = (int)(0);
    }

    if ((op) == (36))
    {
        long iLimit = (long)(*(long*)(pArg));
        if ((iLimit) &lt; (p-&gt;sz))
        {
            if ((iLimit) &lt; (0))
            {
                iLimit = (long)(p-&gt;szMax);
            }
            else
            {
                iLimit = (long)(p-&gt;sz);
            }
        }

        p-&gt;szMax = (long)(iLimit);
        *(long*)(pArg) = (long)(iLimit);
        rc = (int)(0);
    }

    memdbLeave(p);
    return (int)(rc);
}</function>
  <function>public static int memdbFileSize(sqlite3_file pFile, long* pSize)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    memdbEnter(p);
    *pSize = (long)(p-&gt;sz);
    memdbLeave(p);
    return (int)(0);
}</function>
  <function>public static MemFile memdbFromDbSchema(sqlite3 db, sbyte* zSchema)
{
    MemFile p = null;
    MemStore* pStore;
    int rc = (int)(sqlite3_file_control(db, zSchema, (int)(7), p));
    if ((rc) != 0)
        return null;
    if (p._base_.pMethods != memdb_io_methods)
        return null;
    pStore = p.pStore;
    memdbEnter(pStore);
    if (pStore-&gt;zFName != null)
        p = null;
    memdbLeave(pStore);
    return p;
}</function>
  <function>public static int memdbFullPathname(sqlite3_vfs pVfs, sbyte* zPath, int nOut, sbyte* zOut)
{
    sqlite3_snprintf((int)(nOut), zOut, "%s", zPath);
    return (int)(0);
}</function>
  <function>public static int memdbGetLastError(sqlite3_vfs pVfs, int a, sbyte* b)
{
    return (int)(((sqlite3_vfs)((pVfs).pAppData)).xGetLastError(((sqlite3_vfs)((pVfs).pAppData)), (int)(a), b));
}</function>
  <function>public static void memdbLeave(MemStore* p)
{
    sqlite3_mutex_leave(p-&gt;pMutex);
}</function>
  <function>public static int memdbLock(sqlite3_file pFile, int eLock)
{
    MemFile pThis = (MemFile)(pFile);
    MemStore* p = pThis.pStore;
    int rc = (int)(0);
    if ((eLock) == (pThis.eLock))
        return (int)(0);
    memdbEnter(p);
    if ((eLock) &gt; (1))
    {
        if ((p-&gt;mFlags &amp; 4) != 0)
        {
            rc = (int)(8);
        }
        else if ((pThis.eLock) &lt;= (1))
        {
            if ((p-&gt;nWrLock) != 0)
            {
                rc = (int)(5);
            }
            else
            {
                p-&gt;nWrLock = (int)(1);
            }
        }
    }
    else if ((eLock) == (1))
    {
        if ((pThis.eLock) &gt; (1))
        {
            p-&gt;nWrLock = (int)(0);
        }
        else if ((p-&gt;nWrLock) != 0)
        {
            rc = (int)(5);
        }
        else
        {
            p-&gt;nRdLock++;
        }
    }
    else
    {
        if ((pThis.eLock) &gt; (1))
        {
            p-&gt;nWrLock = (int)(0);
        }

        p-&gt;nRdLock--;
    }

    if ((rc) == (0))
        pThis.eLock = (int)(eLock);
    memdbLeave(p);
    return (int)(rc);
}</function>
  <function>public static int memdbOpen(sqlite3_vfs pVfs, sbyte* zName, sqlite3_file pFd, int flags, int* pOutFlags)
{
    MemFile pFile = (MemFile)(pFd);
    MemStore* p = null;
    int szName = 0;
    CRuntime.memset(pFile, (int)(0), (ulong)(sizeof(MemFile)));
    szName = (int)(sqlite3Strlen30(zName));
    if (((szName) &gt; (1)) &amp;&amp; ((zName[0]) == (47)))
    {
        int i = 0;
        sqlite3_mutex* pVfsMutex = sqlite3MutexAlloc((int)(11));
        sqlite3_mutex_enter(pVfsMutex);
        for (i = (int)(0); (i) &lt; (memdb_g.nMemStore); i++)
        {
            if ((CRuntime.strcmp(memdb_g.apMemStore[i]-&gt;zFName, zName)) == (0))
            {
                p = memdb_g.apMemStore[i];
                break;
            }
        }

        if ((p) == (null))
        {
            MemStore** apNew;
            p = sqlite3Malloc((ulong)(sizeof(MemStore) + szName + 3));
            if ((p) == (null))
            {
                sqlite3_mutex_leave(pVfsMutex);
                return (int)(7);
            }

            apNew = sqlite3Realloc(memdb_g.apMemStore, (ulong)(sizeof(MemStore*) * (memdb_g.nMemStore + 1)));
            if ((apNew) == (null))
            {
                sqlite3_free(p);
                sqlite3_mutex_leave(pVfsMutex);
                return (int)(7);
            }

            apNew[memdb_g.nMemStore++] = p;
            memdb_g.apMemStore = apNew;
            CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemStore)));
            p-&gt;mFlags = (uint)(2 | 1);
            p-&gt;szMax = (long)(sqlite3Config.mxMemdbSize);
            p-&gt;zFName = (sbyte*)(&amp;p[1]);
            CRuntime.memcpy(p-&gt;zFName, zName, (ulong)(szName + 1));
            p-&gt;pMutex = sqlite3_mutex_alloc((int)(0));
            if ((p-&gt;pMutex) == (null))
            {
                memdb_g.nMemStore--;
                sqlite3_free(p);
                sqlite3_mutex_leave(pVfsMutex);
                return (int)(7);
            }

            p-&gt;nRef = (int)(1);
            memdbEnter(p);
        }
        else
        {
            memdbEnter(p);
            p-&gt;nRef++;
        }

        sqlite3_mutex_leave(pVfsMutex);
    }
    else
    {
        p = sqlite3Malloc((ulong)(sizeof(MemStore)));
        if ((p) == (null))
        {
            return (int)(7);
        }

        CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemStore)));
        p-&gt;mFlags = (uint)(2 | 1);
        p-&gt;szMax = (long)(sqlite3Config.mxMemdbSize);
    }

    pFile.pStore = p;
    if (pOutFlags != null)
    {
        *pOutFlags = (int)(flags | 0x00000080);
    }

    pFd.pMethods = memdb_io_methods;
    memdbLeave(p);
    return (int)(0);
}</function>
  <function>public static int memdbRandomness(sqlite3_vfs pVfs, int nByte, sbyte* zBufOut)
{
    return (int)(((sqlite3_vfs)((pVfs).pAppData)).xRandomness(((sqlite3_vfs)((pVfs).pAppData)), (int)(nByte), zBufOut));
}</function>
  <function>public static int memdbRead(sqlite3_file pFile, void* zBuf, int iAmt, long iOfst)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    memdbEnter(p);
    if ((iOfst + iAmt) &gt; (p-&gt;sz))
    {
        CRuntime.memset(zBuf, (int)(0), (ulong)(iAmt));
        if ((iOfst) &lt; (p-&gt;sz))
            CRuntime.memcpy(zBuf, p-&gt;aData + iOfst, (ulong)(p-&gt;sz - iOfst));
        memdbLeave(p);
        return (int)(10 | (2 &lt;&lt; 8));
    }

    CRuntime.memcpy(zBuf, p-&gt;aData + iOfst, (ulong)(iAmt));
    memdbLeave(p);
    return (int)(0);
}</function>
  <function>public static int memdbSleep(sqlite3_vfs pVfs, int nMicro)
{
    return (int)(((sqlite3_vfs)((pVfs).pAppData)).xSleep(((sqlite3_vfs)((pVfs).pAppData)), (int)(nMicro)));
}</function>
  <function>public static int memdbSync(sqlite3_file pFile, int flags)
{
    return (int)(0);
}</function>
  <function>public static int memdbTruncate(sqlite3_file pFile, long size)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    int rc = (int)(0);
    memdbEnter(p);
    if ((size) &gt; (p-&gt;sz))
    {
        rc = (int)(11);
    }
    else
    {
        p-&gt;sz = (long)(size);
    }

    memdbLeave(p);
    return (int)(rc);
}</function>
  <function>public static int memdbUnfetch(sqlite3_file pFile, long iOfst, void* pPage)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    memdbEnter(p);
    p-&gt;nMmap--;
    memdbLeave(p);
    return (int)(0);
}</function>
  <function>public static int memdbWrite(sqlite3_file pFile, void* z, int iAmt, long iOfst)
{
    MemStore* p = ((MemFile)(pFile)).pStore;
    memdbEnter(p);
    if ((p-&gt;mFlags &amp; 4) != 0)
    {
        memdbLeave(p);
        return (int)(10 | (3 &lt;&lt; 8));
    }

    if ((iOfst + iAmt) &gt; (p-&gt;sz))
    {
        int rc = 0;
        if (((iOfst + iAmt) &gt; (p-&gt;szAlloc)) &amp;&amp; ((rc = (int)(memdbEnlarge(p, (long)(iOfst + iAmt)))) != 0))
        {
            memdbLeave(p);
            return (int)(rc);
        }

        if ((iOfst) &gt; (p-&gt;sz))
            CRuntime.memset(p-&gt;aData + p-&gt;sz, (int)(0), (ulong)(iOfst - p-&gt;sz));
        p-&gt;sz = (long)(iOfst + iAmt);
    }

    CRuntime.memcpy(p-&gt;aData + iOfst, z, (ulong)(iAmt));
    memdbLeave(p);
    return (int)(0);
}</function>
  <function>public static long memIntValue(sqlite3_value pMem)
{
    long value = (long)(0);
    sqlite3Atoi64(pMem.z, &amp;value, (int)(pMem.n), (byte)(pMem.enc));
    return (long)(value);
}</function>
  <function>public static int memjrnlClose(sqlite3_file pJfd)
{
    MemJournal p = (MemJournal)(pJfd);
    memjrnlFreeChunks(p.pFirst);
    return (int)(0);
}</function>
  <function>public static int memjrnlCreateFile(MemJournal p)
{
    int rc = 0;
    sqlite3_file pReal = (sqlite3_file)(p);
    MemJournal copy = (MemJournal)(p);
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemJournal)));
    rc = (int)(sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, (int)(copy.flags), null));
    if ((rc) == (0))
    {
        int nChunk = (int)(copy.nChunkSize);
        long iOff = (long)(0);
        FileChunk* pIter;
        for (pIter = copy.pFirst; pIter; pIter = pIter-&gt;pNext)
        {
            if ((iOff + nChunk) &gt; (copy.endpoint.iOffset))
            {
                nChunk = (int)(copy.endpoint.iOffset - iOff);
            }

            rc = (int)(sqlite3OsWrite(pReal, pIter-&gt;zChunk, (int)(nChunk), (long)(iOff)));
            if ((rc) != 0)
                break;
            iOff += (long)(nChunk);
        }

        if ((rc) == (0))
        {
            memjrnlFreeChunks(copy.pFirst);
        }
    }

    if (rc != 0)
    {
        sqlite3OsClose(pReal);
        p = (MemJournal)(copy);
    }

    return (int)(rc);
}</function>
  <function>public static int memjrnlFileSize(sqlite3_file pJfd, long* pSize)
{
    MemJournal p = (MemJournal)(pJfd);
    *pSize = (long)(p.endpoint.iOffset);
    return (int)(0);
}</function>
  <function>public static void memjrnlFreeChunks(FileChunk* pFirst)
{
    FileChunk* pIter;
    FileChunk* pNext;
    for (pIter = pFirst; pIter; pIter = pNext)
    {
        pNext = pIter-&gt;pNext;
        sqlite3_free(pIter);
    }
}</function>
  <function>public static int memjrnlRead(sqlite3_file pJfd, void* zBuf, int iAmt, long iOfst)
{
    MemJournal p = (MemJournal)(pJfd);
    byte* zOut = zBuf;
    int nRead = (int)(iAmt);
    int iChunkOffset = 0;
    FileChunk* pChunk;
    if ((iAmt + iOfst) &gt; (p.endpoint.iOffset))
    {
        return (int)(10 | (2 &lt;&lt; 8));
    }

    if ((p.readpoint.iOffset != iOfst) || ((iOfst) == (0)))
    {
        long iOff = (long)(0);
        for (pChunk = p.pFirst; ((pChunk) != null) &amp;&amp; ((iOff + p.nChunkSize) &lt;= (iOfst)); pChunk = pChunk-&gt;pNext)
        {
            iOff += (long)(p.nChunkSize);
        }
    }
    else
    {
        pChunk = p.readpoint.pChunk;
    }

    iChunkOffset = ((int)(iOfst % p.nChunkSize));
    do
    {
        int iSpace = (int)(p.nChunkSize - iChunkOffset);
        int nCopy = (int)((nRead) &lt; (p.nChunkSize - iChunkOffset) ? (nRead) : (p.nChunkSize - iChunkOffset));
        CRuntime.memcpy(zOut, pChunk-&gt;zChunk + iChunkOffset, (ulong)(nCopy));
        zOut += nCopy;
        nRead -= (int)(iSpace);
        iChunkOffset = (int)(0);
    }
    while ((((nRead) &gt;= (0)) &amp;&amp; ((pChunk = pChunk-&gt;pNext) != null)) &amp;&amp; ((nRead) &gt; (0)));
    p.readpoint.iOffset = (long)(pChunk ? iOfst + iAmt : 0);
    p.readpoint.pChunk = pChunk;
    return (int)(0);
}</function>
  <function>public static int memjrnlSync(sqlite3_file pJfd, int flags)
{
    return (int)(0);
}</function>
  <function>public static int memjrnlTruncate(sqlite3_file pJfd, long size)
{
    MemJournal p = (MemJournal)(pJfd);
    if ((size) &lt; (p.endpoint.iOffset))
    {
        FileChunk* pIter = null;
        if ((size) == (0))
        {
            memjrnlFreeChunks(p.pFirst);
            p.pFirst = null;
        }
        else
        {
            long iOff = (long)(p.nChunkSize);
            for (pIter = p.pFirst; ((pIter) != null) &amp;&amp; ((iOff) &lt; (size)); pIter = pIter-&gt;pNext)
            {
                iOff += (long)(p.nChunkSize);
            }

            if ((pIter) != null)
            {
                memjrnlFreeChunks(pIter-&gt;pNext);
                pIter-&gt;pNext = null;
            }
        }

        p.endpoint.pChunk = pIter;
        p.endpoint.iOffset = (long)(size);
        p.readpoint.pChunk = null;
        p.readpoint.iOffset = (long)(0);
    }

    return (int)(0);
}</function>
  <function>public static int memjrnlWrite(sqlite3_file pJfd, void* zBuf, int iAmt, long iOfst)
{
    MemJournal p = (MemJournal)(pJfd);
    int nWrite = (int)(iAmt);
    byte* zWrite = (byte*)(zBuf);
    if (((p.nSpill) &gt; (0)) &amp;&amp; ((iAmt + iOfst) &gt; (p.nSpill)))
    {
        int rc = (int)(memjrnlCreateFile(p));
        if ((rc) == (0))
        {
            rc = (int)(sqlite3OsWrite(pJfd, zBuf, (int)(iAmt), (long)(iOfst)));
        }

        return (int)(rc);
    }
    else
    {
        if (((iOfst) &gt; (0)) &amp;&amp; (iOfst != p.endpoint.iOffset))
        {
            memjrnlTruncate(pJfd, (long)(iOfst));
        }

        if (((iOfst) == (0)) &amp;&amp; ((p.pFirst) != null))
        {
            CRuntime.memcpy(p.pFirst-&gt;zChunk, zBuf, (ulong)(iAmt));
        }
        else
        {
            while ((nWrite) &gt; (0))
            {
                FileChunk* pChunk = p.endpoint.pChunk;
                int iChunkOffset = (int)(p.endpoint.iOffset % p.nChunkSize);
                int iSpace = (int)((nWrite) &lt; (p.nChunkSize - iChunkOffset) ? (nWrite) : (p.nChunkSize - iChunkOffset));
                if ((iChunkOffset) == (0))
                {
                    FileChunk* pNew = sqlite3_malloc((int)(sizeof(FileChunk) + ((p.nChunkSize) - 8)));
                    if (pNew == null)
                    {
                        return (int)(10 | (12 &lt;&lt; 8));
                    }

                    pNew-&gt;pNext = null;
                    if ((pChunk) != null)
                    {
                        pChunk-&gt;pNext = pNew;
                    }
                    else
                    {
                        p.pFirst = pNew;
                    }

                    pChunk = p.endpoint.pChunk = pNew;
                }

                CRuntime.memcpy(pChunk-&gt;zChunk + iChunkOffset, zWrite, (ulong)(iSpace));
                zWrite += iSpace;
                nWrite -= (int)(iSpace);
                p.endpoint.iOffset += (long)(iSpace);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static double memRealValue(sqlite3_value pMem)
{
    double val = (double)(0);
    sqlite3AtoF(pMem.z, &amp;val, (int)(pMem.n), (byte)(pMem.enc));
    return (double)(val);
}</function>
  <function>public static void minMaxFinalize(sqlite3_context context)
{
    minMaxValueFinalize(context, (int)(0));
}</function>
  <function>public static void minmaxFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    int i = 0;
    int mask = 0;
    int iBest = 0;
    CollSeq pColl;
    mask = (int)((sqlite3_user_data(context)) == (null) ? 0 : -1);
    pColl = sqlite3GetFuncCollSeq(context);
    iBest = (int)(0);
    if ((sqlite3_value_type(argv[0])) == (5))
        return;
    for (i = (int)(1); (i) &lt; (argc); i++)
    {
        if ((sqlite3_value_type(argv[i])) == (5))
            return;
        if ((sqlite3MemCompare(argv[iBest], argv[i], pColl) ^ mask) &gt;= (0))
        {
            iBest = (int)(i);
        }
    }

    sqlite3_result_value(context, argv[iBest]);
}</function>
  <function>public static byte minMaxQuery(sqlite3 db, Expr pFunc, ExprList ppMinMax)
{
    int eRet = (int)(0x0000);
    ExprList pEList;
    sbyte* zFunc;
    ExprList pOrderBy;
    byte sortFlags = (byte)(0);
    pEList = pFunc.x.pList;
    if (((((pEList) == (null)) || (pEList.nExpr != 1)) || (((pFunc).flags &amp; (0x1000000)) != 0)) || (((db).dbOptFlags &amp; (0x00010000)) != 0))
    {
        return (byte)(eRet);
    }

    zFunc = pFunc.u.zToken;
    if ((sqlite3StrICmp(zFunc, "min")) == (0))
    {
        eRet = (int)(0x0001);
        if ((sqlite3ExprCanBeNull(pEList.a[0].pExpr)) != 0)
        {
            sortFlags = (byte)(0x02);
        }
    }
    else if ((sqlite3StrICmp(zFunc, "max")) == (0))
    {
        eRet = (int)(0x0002);
        sortFlags = (byte)(0x01);
    }
    else
    {
        return (byte)(eRet);
    }

    ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, (int)(0));
    if ((pOrderBy) != null)
        pOrderBy.a[0].sortFlags = (byte)(sortFlags);
    return (byte)(eRet);
}</function>
  <function>public static void minmaxStep(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sqlite3_value pArg = argv[0];
    sqlite3_value pBest;
    pBest = (sqlite3_value)(sqlite3_aggregate_context(context, (int)(sizeof(sqlite3_value))));
    if (pBest == null)
        return;
    if ((sqlite3_value_type(pArg)) == (5))
    {
        if ((pBest.flags) != 0)
            sqlite3SkipAccumulatorLoad(context);
    }
    else if ((pBest.flags) != 0)
    {
        int max = 0;
        int cmp = 0;
        CollSeq pColl = sqlite3GetFuncCollSeq(context);
        max = (int)(sqlite3_user_data(context) != null);
        cmp = (int)(sqlite3MemCompare(pBest, pArg, pColl));
        if ((((max) != 0) &amp;&amp; ((cmp) &lt; (0))) || ((max == 0) &amp;&amp; ((cmp) &gt; (0))))
        {
            sqlite3VdbeMemCopy(pBest, pArg);
        }
        else
        {
            sqlite3SkipAccumulatorLoad(context);
        }
    }
    else
    {
        pBest.db = sqlite3_context_db_handle(context);
        sqlite3VdbeMemCopy(pBest, pArg);
    }
}</function>
  <function>public static void minMaxValue(sqlite3_context context)
{
    minMaxValueFinalize(context, (int)(1));
}</function>
  <function>public static void minMaxValueFinalize(sqlite3_context context, int bValue)
{
    sqlite3_value pRes;
    pRes = (sqlite3_value)(sqlite3_aggregate_context(context, (int)(0)));
    if ((pRes) != null)
    {
        if ((pRes.flags) != 0)
        {
            sqlite3_result_value(context, pRes);
        }

        if ((bValue) == (0))
            sqlite3VdbeMemRelease(pRes);
    }
}</function>
  <function>public static int modifyPagePointer(MemPage pPage, uint iFrom, uint iTo, byte eType)
{
    if ((eType) == (4))
    {
        if (sqlite3Get4byte(pPage.aData) != iFrom)
        {
            return (int)(sqlite3CorruptError((int)(69823)));
        }

        sqlite3Put4byte(pPage.aData, (uint)(iTo));
    }
    else
    {
        int i = 0;
        int nCell = 0;
        int rc = 0;
        rc = (int)((pPage.isInit) != 0 ? 0 : btreeInitPage(pPage));
        if ((rc) != 0)
            return (int)(rc);
        nCell = (int)(pPage.nCell);
        for (i = (int)(0); (i) &lt; (nCell); i++)
        {
            byte* pCell = ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (i)])))));
            if ((eType) == (3))
            {
                CellInfo info = new CellInfo();
                pPage.xParseCell(pPage, pCell, &amp;info);
                if ((info.nLocal) &lt; (info.nPayload))
                {
                    if ((pCell + info.nSize) &gt; (pPage.aData + pPage.pBt.usableSize))
                    {
                        return (int)(sqlite3CorruptError((int)(69842)));
                    }

                    if ((iFrom) == (sqlite3Get4byte(pCell + info.nSize - 4)))
                    {
                        sqlite3Put4byte(pCell + info.nSize - 4, (uint)(iTo));
                        break;
                    }
                }
            }
            else
            {
                if ((sqlite3Get4byte(pCell)) == (iFrom))
                {
                    sqlite3Put4byte(pCell, (uint)(iTo));
                    break;
                }
            }
        }

        if ((i) == (nCell))
        {
            if ((eType != 5) || (sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]) != iFrom))
            {
                return (int)(sqlite3CorruptError((int)(69860)));
            }

            sqlite3Put4byte(&amp;pPage.aData[pPage.hdrOffset + 8], (uint)(iTo));
        }
    }

    return (int)(0);
}</function>
  <function>public static int moveToChild(BtCursor pCur, uint newPgno)
{
    BtShared pBt = pCur.pBt;
    if ((pCur.iPage) &gt;= (20 - 1))
    {
        return (int)(sqlite3CorruptError((int)(71358)));
    }

    pCur.info.nSize = (ushort)(0);
    pCur.curFlags &amp;= (byte)(~(0x02 | 0x04));
    pCur.aiIdx[pCur.iPage] = (ushort)(pCur.ix);
    pCur.apPage[pCur.iPage] = pCur.pPage;
    pCur.ix = (ushort)(0);
    pCur.iPage++;
    return (int)(getAndInitPage(pBt, (uint)(newPgno), pCur.pPage, pCur, (int)(pCur.curPagerFlags)));
}</function>
  <function>public static int moveToLeftmost(BtCursor pCur)
{
    uint pgno = 0;
    int rc = (int)(0);
    MemPage pPage;
    while (((rc) == (0)) &amp;&amp; ((pPage = pCur.pPage).leaf == 0))
    {
        pgno = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (pCur.ix)])))))));
        rc = (int)(moveToChild(pCur, (uint)(pgno)));
    }

    return (int)(rc);
}</function>
  <function>public static void moveToParent(BtCursor pCur)
{
    MemPage pLeaf;
    pCur.info.nSize = (ushort)(0);
    pCur.curFlags &amp;= (byte)(~(0x02 | 0x04));
    pCur.ix = (ushort)(pCur.aiIdx[pCur.iPage - 1]);
    pLeaf = pCur.pPage;
    pCur.pPage = pCur.apPage[--pCur.iPage];
    releasePageNotNull(pLeaf);
}</function>
  <function>public static int moveToRightmost(BtCursor pCur)
{
    uint pgno = 0;
    int rc = (int)(0);
    MemPage pPage = null;
    while ((pPage = pCur.pPage).leaf == 0)
    {
        pgno = (uint)(sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]));
        pCur.ix = (ushort)(pPage.nCell);
        rc = (int)(moveToChild(pCur, (uint)(pgno)));
        if ((rc) != 0)
            return (int)(rc);
    }

    pCur.ix = (ushort)(pPage.nCell - 1);
    return (int)(0);
}</function>
  <function>public static int moveToRoot(BtCursor pCur)
{
    MemPage pRoot;
    int rc = (int)(0);
    if ((pCur.iPage) &gt;= (0))
    {
        if ((pCur.iPage) != 0)
        {
            releasePageNotNull(pCur.pPage);
            while ((--pCur.iPage) != 0)
            {
                releasePageNotNull(pCur.apPage[pCur.iPage]);
            }

            pRoot = pCur.pPage = pCur.apPage[0];
            goto skip_init;
        }
    }
    else if ((pCur.pgnoRoot) == (0))
    {
        pCur.eState = (byte)(1);
        return (int)(16);
    }
    else
    {
        if ((pCur.eState) &gt;= (3))
        {
            if ((pCur.eState) == (4))
            {
                return (int)(pCur.skipNext);
            }

            sqlite3BtreeClearCursor(pCur);
        }

        rc = (int)(getAndInitPage(pCur.pBtree.pBt, (uint)(pCur.pgnoRoot), pCur.pPage, null, (int)(pCur.curPagerFlags)));
        if (rc != 0)
        {
            pCur.eState = (byte)(1);
            return (int)(rc);
        }

        pCur.iPage = (sbyte)(0);
        pCur.curIntKey = (byte)(pCur.pPage.intKey);
    }

    pRoot = pCur.pPage;
    if (((pRoot.isInit) == (0)) || (((pCur.pKeyInfo) == (null)) != pRoot.intKey))
    {
        return (int)(sqlite3CorruptError((int)(71496)));
    }

    skip_init:
        ; pCur . ix  =  ( ushort ) ( 0 ) ; 
    pCur.info.nSize = (ushort)(0);
    pCur.curFlags &amp;= (byte)(~(0x08 | 0x02 | 0x04));
    if ((pRoot.nCell) &gt; (0))
    {
        pCur.eState = (byte)(0);
    }
    else if (pRoot.leaf == 0)
    {
        uint subpage = 0;
        if (pRoot.pgno != 1)
            return (int)(sqlite3CorruptError((int)(71508)));
        subpage = (uint)(sqlite3Get4byte(&amp;pRoot.aData[pRoot.hdrOffset + 8]));
        pCur.eState = (byte)(0);
        rc = (int)(moveToChild(pCur, (uint)(subpage)));
    }
    else
    {
        pCur.eState = (byte)(1);
        rc = (int)(16);
    }

    return (int)(rc);
}</function>
  <function>public static int multiSelect(Parse pParse, Select p, SelectDest pDest)
{
    int rc = (int)(0);
    Select pPrior;
    Vdbe v;
    SelectDest dest = new SelectDest();
    Select pDelete = null;
    sqlite3 db;
    db = pParse.db;
    pPrior = p.pPrior;
    dest = (SelectDest)(pDest);
    v = sqlite3GetVdbe(pParse);
    if ((dest.eDest) == (12))
    {
        sqlite3VdbeAddOp2(v, (int)(116), (int)(dest.iSDParm), (int)(p.pEList.nExpr));
        dest.eDest = (byte)(14);
    }

    if ((p.selFlags &amp; 0x0000400) != 0)
    {
        rc = (int)(multiSelectValues(pParse, p, dest));
        if ((rc) &gt;= (0))
            goto multi_select_end;
        rc = (int)(0);
    }

    if (((p.selFlags &amp; 0x0002000) != 0) &amp;&amp; ((hasAnchor(p)) != 0))
    {
        generateWithRecursiveQuery(pParse, p, dest);
    }
    else if ((p.pOrderBy) != null)
    {
        return (int)(multiSelectOrderBy(pParse, p, pDest));
    }
    else
    {
        if ((pPrior.pPrior) == (null))
        {
            sqlite3VdbeExplain(pParse, (byte)(1), "COMPOUND QUERY");
            sqlite3VdbeExplain(pParse, (byte)(1), "LEFT-MOST SUBQUERY");
        }

        switch (p.op)
        {
            case 135:
            {
                int addr = (int)(0);
                int nLimit = (int)(0);
                pPrior.iLimit = (int)(p.iLimit);
                pPrior.iOffset = (int)(p.iOffset);
                pPrior.pLimit = p.pLimit;
                rc = (int)(sqlite3Select(pParse, pPrior, dest));
                pPrior.pLimit = null;
                if ((rc) != 0)
                {
                    goto multi_select_end;
                }

                p.pPrior = null;
                p.iLimit = (int)(pPrior.iLimit);
                p.iOffset = (int)(pPrior.iOffset);
                if ((p.iLimit) != 0)
                {
                    addr = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(p.iLimit)));
                    if ((p.iOffset) != 0)
                    {
                        sqlite3VdbeAddOp3(v, (int)(159), (int)(p.iLimit), (int)(p.iOffset + 1), (int)(p.iOffset));
                    }
                }

                sqlite3VdbeExplain(pParse, (byte)(1), "UNION ALL");
                rc = (int)(sqlite3Select(pParse, p, dest));
                pDelete = p.pPrior;
                p.pPrior = pPrior;
                p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
                if (((((p.pLimit) != null) &amp;&amp; ((sqlite3ExprIsInteger(p.pLimit.pLeft, &amp;nLimit)) != 0)) &amp;&amp; ((nLimit) &gt; (0))) &amp;&amp; ((p.nSelectRow) &gt; (sqlite3LogEst((ulong)(nLimit)))))
                {
                    p.nSelectRow = (short)(sqlite3LogEst((ulong)(nLimit)));
                }

                if ((addr) != 0)
                {
                    sqlite3VdbeJumpHere(v, (int)(addr));
                }

                break;
            }

            case 136:
            case 134:
            {
                int unionTab = 0;
                byte op = (byte)(0);
                int priorOp = 0;
                Expr pLimit;
                int addr = 0;
                SelectDest uniondest = new SelectDest();
                priorOp = (int)(1);
                if ((dest.eDest) == (priorOp))
                {
                    unionTab = (int)(dest.iSDParm);
                }
                else
                {
                    unionTab = (int)(pParse.nTab++);
                    addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(unionTab), (int)(0)));
                    p.addrOpenEphm[0] = (int)(addr);
                    findRightmost(p).selFlags |= (uint)(0x0000020);
                }

                sqlite3SelectDestInit(uniondest, (int)(priorOp), (int)(unionTab));
                rc = (int)(sqlite3Select(pParse, pPrior, uniondest));
                if ((rc) != 0)
                {
                    goto multi_select_end;
                }

                if ((p.op) == (136))
                {
                    op = (byte)(2);
                }
                else
                {
                    op = (byte)(1);
                }

                p.pPrior = null;
                pLimit = p.pLimit;
                p.pLimit = null;
                uniondest.eDest = (byte)(op);
                sqlite3VdbeExplain(pParse, (byte)(1), "%s USING TEMP B-TREE", sqlite3SelectOpName((int)(p.op)));
                rc = (int)(sqlite3Select(pParse, p, uniondest));
                pDelete = p.pPrior;
                p.pPrior = pPrior;
                p.pOrderBy = null;
                if ((p.op) == (134))
                {
                    p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
                }

                sqlite3ExprDelete(db, p.pLimit);
                p.pLimit = pLimit;
                p.iLimit = (int)(0);
                p.iOffset = (int)(0);
                if ((dest.eDest != priorOp) &amp;&amp; ((db.mallocFailed) == (0)))
                {
                    int iCont = 0;
                    int iBreak = 0;
                    int iStart = 0;
                    iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
                    iCont = (int)(sqlite3VdbeMakeLabel(pParse));
                    computeLimitRegisters(pParse, p, (int)(iBreak));
                    sqlite3VdbeAddOp2(v, (int)(38), (int)(unionTab), (int)(iBreak));
                    iStart = (int)(sqlite3VdbeCurrentAddr(v));
                    selectInnerLoop(pParse, p, (int)(unionTab), null, null, dest, (int)(iCont), (int)(iBreak));
                    sqlite3VdbeResolveLabel(v, (int)(iCont));
                    sqlite3VdbeAddOp2(v, (int)(5), (int)(unionTab), (int)(iStart));
                    sqlite3VdbeResolveLabel(v, (int)(iBreak));
                    sqlite3VdbeAddOp2(v, (int)(121), (int)(unionTab), (int)(0));
                }

                break;
            }

            default:
                ;
            {
                int tab1 = 0;
                int tab2 = 0;
                int iCont = 0;
                int iBreak = 0;
                int iStart = 0;
                Expr pLimit;
                int addr = 0;
                SelectDest intersectdest = new SelectDest();
                int r1 = 0;
                tab1 = (int)(pParse.nTab++);
                tab2 = (int)(pParse.nTab++);
                addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(tab1), (int)(0)));
                p.addrOpenEphm[0] = (int)(addr);
                findRightmost(p).selFlags |= (uint)(0x0000020);
                sqlite3SelectDestInit(intersectdest, (int)(1), (int)(tab1));
                rc = (int)(sqlite3Select(pParse, pPrior, intersectdest));
                if ((rc) != 0)
                {
                    goto multi_select_end;
                }

                addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(tab2), (int)(0)));
                p.addrOpenEphm[1] = (int)(addr);
                p.pPrior = null;
                pLimit = p.pLimit;
                p.pLimit = null;
                intersectdest.iSDParm = (int)(tab2);
                sqlite3VdbeExplain(pParse, (byte)(1), "%s USING TEMP B-TREE", sqlite3SelectOpName((int)(p.op)));
                rc = (int)(sqlite3Select(pParse, p, intersectdest));
                pDelete = p.pPrior;
                p.pPrior = pPrior;
                if ((p.nSelectRow) &gt; (pPrior.nSelectRow))
                {
                    p.nSelectRow = (short)(pPrior.nSelectRow);
                }

                sqlite3ExprDelete(db, p.pLimit);
                p.pLimit = pLimit;
                if ((rc) != 0)
                    break;
                iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
                iCont = (int)(sqlite3VdbeMakeLabel(pParse));
                computeLimitRegisters(pParse, p, (int)(iBreak));
                sqlite3VdbeAddOp2(v, (int)(38), (int)(tab1), (int)(iBreak));
                r1 = (int)(sqlite3GetTempReg(pParse));
                iStart = (int)(sqlite3VdbeAddOp2(v, (int)(133), (int)(tab1), (int)(r1)));
                sqlite3VdbeAddOp4Int(v, (int)(30), (int)(tab2), (int)(iCont), (int)(r1), (int)(0));
                sqlite3ReleaseTempReg(pParse, (int)(r1));
                selectInnerLoop(pParse, p, (int)(tab1), null, null, dest, (int)(iCont), (int)(iBreak));
                sqlite3VdbeResolveLabel(v, (int)(iCont));
                sqlite3VdbeAddOp2(v, (int)(5), (int)(tab1), (int)(iStart));
                sqlite3VdbeResolveLabel(v, (int)(iBreak));
                sqlite3VdbeAddOp2(v, (int)(121), (int)(tab2), (int)(0));
                sqlite3VdbeAddOp2(v, (int)(121), (int)(tab1), (int)(0));
                break;
            }
        }

        if ((p.pNext) == (null))
        {
            sqlite3VdbeExplainPop(pParse);
        }
    }

    if ((pParse.nErr) != 0)
        goto multi_select_end;
    if ((p.selFlags &amp; 0x0000020) != 0)
    {
        int i = 0;
        KeyInfo pKeyInfo;
        Select pLoop;
        CollSeq apColl;
        int nCol = 0;
        nCol = (int)(p.pEList.nExpr);
        pKeyInfo = sqlite3KeyInfoAlloc(db, (int)(nCol), (int)(1));
        if (pKeyInfo == null)
        {
            rc = (int)(7);
            goto multi_select_end;
        }

        for (i = (int)(0), apColl = pKeyInfo.aColl; (i) &lt; (nCol); i++, apColl++)
        {
            apColl = multiSelectCollSeq(pParse, p, (int)(i));
            if ((null) == (apColl))
            {
                apColl = db.pDfltColl;
            }
        }

        for (pLoop = p; pLoop; pLoop = pLoop.pPrior)
        {
            for (i = (int)(0); (i) &lt; (2); i++)
            {
                int addr = (int)(pLoop.addrOpenEphm[i]);
                if ((addr) &lt; (0))
                {
                    break;
                }

                sqlite3VdbeChangeP2(v, (int)(addr), (int)(nCol));
                sqlite3VdbeChangeP4(v, (int)(addr), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9));
                pLoop.addrOpenEphm[i] = (int)(-1);
            }
        }

        sqlite3KeyInfoUnref(pKeyInfo);
    }

    multi_select_end:
        ; pDest . iSdst  =  ( int ) ( dest . iSdst ) ; 
    pDest.nSdst = (int)(dest.nSdst);
    if ((pDelete) != null)
    {
        sqlite3ParserAddCleanup(pParse, sqlite3SelectDelete, pDelete);
    }

    return (int)(rc);
}</function>
  <function>public static CollSeq multiSelectCollSeq(Parse pParse, Select p, int iCol)
{
    CollSeq pRet;
    if ((p.pPrior) != null)
    {
        pRet = multiSelectCollSeq(pParse, p.pPrior, (int)(iCol));
    }
    else
    {
        pRet = null;
    }

    if (((pRet) == (null)) &amp;&amp; ((iCol) &lt; (p.pEList.nExpr)))
    {
        pRet = sqlite3ExprCollSeq(pParse, p.pEList.a[iCol].pExpr);
    }

    return pRet;
}</function>
  <function>public static int multiSelectOrderBy(Parse pParse, Select p, SelectDest pDest)
{
    int i = 0; int  j  =  0 ; 
    Select pPrior;
    Select pSplit;
    int nSelect = 0;
    Vdbe v;
    SelectDest destA = new SelectDest();
    SelectDest destB = new SelectDest();
    int regAddrA = 0;
    int regAddrB = 0;
    int addrSelectA = 0;
    int addrSelectB = 0;
    int regOutA = 0;
    int regOutB = 0;
    int addrOutA = 0;
    int addrOutB = (int)(0);
    int addrEofA = 0;
    int addrEofA_noB = 0;
    int addrEofB = 0;
    int addrAltB = 0;
    int addrAeqB = 0;
    int addrAgtB = 0;
    int regLimitA = 0;
    int regLimitB = 0;
    int regPrev = 0;
    int savedLimit = 0;
    int savedOffset = 0;
    int labelCmpr = 0;
    int labelEnd = 0;
    int addr1 = 0;
    int op = 0;
    KeyInfo pKeyDup = null;
    KeyInfo pKeyMerge;
    sqlite3 db;
    ExprList pOrderBy;
    int nOrderBy = 0;
    uint* aPermute;
    db = pParse.db;
    v = pParse.pVdbe;
    labelEnd = (int)(sqlite3VdbeMakeLabel(pParse));
    labelCmpr = (int)(sqlite3VdbeMakeLabel(pParse));
    op = (int)(p.op);
    pOrderBy = p.pOrderBy;
    nOrderBy = (int)(pOrderBy.nExpr);
    if (op != 135)
    {
        for (i = (int)(1); ((db.mallocFailed) == (0)) &amp;&amp; ((i) &lt;= (p.pEList.nExpr)); i++)
        {
            ExprList_item* pItem;
            for (j = (int)(0), pItem = pOrderBy.a; (j) &lt; (nOrderBy); j++, pItem++)
            {
                if ((pItem-&gt;u.x.iOrderByCol) == (i))
                    break;
            }

            if ((j) == (nOrderBy))
            {
                Expr pNew = sqlite3Expr(db, (int)(155), null);
                if ((pNew) == (null))
                    return (int)(7);
                pNew.flags |= (uint)(0x000400);
                pNew.u.iValue = (int)(i);
                p.pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
                if ((pOrderBy) != null)
                    pOrderBy.a[nOrderBy++].u.x.iOrderByCol = ((ushort)(i));
            }
        }
    }

    aPermute = sqlite3DbMallocRawNN(db, (ulong)(sizeof(uint) * (nOrderBy + 1)));
    if ((aPermute) != null)
    {
        ExprList_item* pItem;
        aPermute[0] = (uint)(nOrderBy);
        for (i = (int)(1), pItem = pOrderBy.a; (i) &lt;= (nOrderBy); i++, pItem++)
        {
            aPermute[i] = (uint)(pItem-&gt;u.x.iOrderByCol - 1);
        }

        pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, (int)(1));
    }
    else
    {
        pKeyMerge = null;
    }

    if ((op) == (135))
    {
        regPrev = (int)(0);
    }
    else
    {
        int nExpr = (int)(p.pEList.nExpr);
        regPrev = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nExpr + 1);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regPrev));
        pKeyDup = sqlite3KeyInfoAlloc(db, (int)(nExpr), (int)(1));
        if ((pKeyDup) != null)
        {
            for (i = (int)(0); (i) &lt; (nExpr); i++)
            {
                pKeyDup.aColl[i] = multiSelectCollSeq(pParse, p, (int)(i));
                pKeyDup.aSortFlags[i] = (byte)(0);
            }
        }
    }

    nSelect = (int)(1);
    if ((((op) == (135)) || ((op) == (134))) &amp;&amp; (((db).dbOptFlags &amp; (0x00200000)) == (0)))
    {
        for (pSplit = p; (pSplit.pPrior != null) &amp;&amp; ((pSplit.op) == (op)); pSplit = pSplit.pPrior)
        {
            nSelect++;
        }
    }

    if ((nSelect) &lt;= (3))
    {
        pSplit = p;
    }
    else
    {
        pSplit = p;
        for (i = (int)(2); (i) &lt; (nSelect); i += (int)(2))
        {
            pSplit = pSplit.pPrior;
        }
    }

    pPrior = pSplit.pPrior;
    pSplit.pPrior = null;
    pPrior.pNext = null;
    pPrior.pOrderBy = sqlite3ExprListDup(pParse.db, pOrderBy, (int)(0));
    sqlite3ResolveOrderGroupBy(pParse, p, p.pOrderBy, "ORDER");
    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior.pOrderBy, "ORDER");
    computeLimitRegisters(pParse, p, (int)(labelEnd));
    if (((p.iLimit) != 0) &amp;&amp; ((op) == (135)))
    {
        regLimitA = (int)(++pParse.nMem);
        regLimitB = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(79), (int)((p.iOffset) != 0 ? p.iOffset + 1 : p.iLimit), (int)(regLimitA));
        sqlite3VdbeAddOp2(v, (int)(79), (int)(regLimitA), (int)(regLimitB));
    }
    else
    {
        regLimitA = (int)(regLimitB = (int)(0));
    }

    sqlite3ExprDelete(db, p.pLimit);
    p.pLimit = null;
    regAddrA = (int)(++pParse.nMem);
    regAddrB = (int)(++pParse.nMem);
    regOutA = (int)(++pParse.nMem);
    regOutB = (int)(++pParse.nMem);
    sqlite3SelectDestInit(destA, (int)(13), (int)(regAddrA));
    sqlite3SelectDestInit(destB, (int)(13), (int)(regAddrB));
    sqlite3VdbeExplain(pParse, (byte)(1), "MERGE (%s)", sqlite3SelectOpName((int)(p.op)));
    addrSelectA = (int)(sqlite3VdbeCurrentAddr(v) + 1);
    addr1 = (int)(sqlite3VdbeAddOp3(v, (int)(13), (int)(regAddrA), (int)(0), (int)(addrSelectA)));
    pPrior.iLimit = (int)(regLimitA);
    sqlite3VdbeExplain(pParse, (byte)(1), "LEFT");
    sqlite3Select(pParse, pPrior, destA);
    sqlite3VdbeEndCoroutine(v, (int)(regAddrA));
    sqlite3VdbeJumpHere(v, (int)(addr1));
    addrSelectB = (int)(sqlite3VdbeCurrentAddr(v) + 1);
    addr1 = (int)(sqlite3VdbeAddOp3(v, (int)(13), (int)(regAddrB), (int)(0), (int)(addrSelectB)));
    savedLimit = (int)(p.iLimit);
    savedOffset = (int)(p.iOffset);
    p.iLimit = (int)(regLimitB);
    p.iOffset = (int)(0);
    sqlite3VdbeExplain(pParse, (byte)(1), "RIGHT");
    sqlite3Select(pParse, p, destB);
    p.iLimit = (int)(savedLimit);
    p.iOffset = (int)(savedOffset);
    sqlite3VdbeEndCoroutine(v, (int)(regAddrB));
    addrOutA = (int)(generateOutputSubroutine(pParse, p, destA, pDest, (int)(regOutA), (int)(regPrev), pKeyDup, (int)(labelEnd)));
    if (((op) == (135)) || ((op) == (134)))
    {
        addrOutB = (int)(generateOutputSubroutine(pParse, p, destB, pDest, (int)(regOutB), (int)(regPrev), pKeyDup, (int)(labelEnd)));
    }

    sqlite3KeyInfoUnref(pKeyDup);
    if (((op) == (136)) || ((op) == (137)))
    {
        addrEofA_noB = (int)(addrEofA = (int)(labelEnd));
    }
    else
    {
        addrEofA = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutB), (int)(addrOutB)));
        addrEofA_noB = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(labelEnd)));
        sqlite3VdbeGoto(v, (int)(addrEofA));
        p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
    }

    if ((op) == (137))
    {
        addrEofB = (int)(addrEofA);
        if ((p.nSelectRow) &gt; (pPrior.nSelectRow))
            p.nSelectRow = (short)(pPrior.nSelectRow);
    }
    else
    {
        addrEofB = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutA), (int)(addrOutA)));
        sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(labelEnd));
        sqlite3VdbeGoto(v, (int)(addrEofB));
    }

    addrAltB = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutA), (int)(addrOutA)));
    sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA));
    sqlite3VdbeGoto(v, (int)(labelCmpr));
    if ((op) == (135))
    {
        addrAeqB = (int)(addrAltB);
    }
    else if ((op) == (137))
    {
        addrAeqB = (int)(addrAltB);
        addrAltB++;
    }
    else
    {
        addrAeqB = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA)));
        sqlite3VdbeGoto(v, (int)(labelCmpr));
    }

    addrAgtB = (int)(sqlite3VdbeCurrentAddr(v));
    if (((op) == (135)) || ((op) == (134)))
    {
        sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutB), (int)(addrOutB));
    }

    sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(addrEofB));
    sqlite3VdbeGoto(v, (int)(labelCmpr));
    sqlite3VdbeJumpHere(v, (int)(addr1));
    sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA_noB));
    sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(addrEofB));
    sqlite3VdbeResolveLabel(v, (int)(labelCmpr));
    sqlite3VdbeAddOp4(v, (int)(88), (int)(0), (int)(0), (int)(0), (sbyte*)(aPermute), (int)(-15));
    sqlite3VdbeAddOp4(v, (int)(89), (int)(destA.iSdst), (int)(destB.iSdst), (int)(nOrderBy), (sbyte*)(pKeyMerge), (int)(-9));
    sqlite3VdbeChangeP5(v, (ushort)(0x01));
    sqlite3VdbeAddOp3(v, (int)(16), (int)(addrAltB), (int)(addrAeqB), (int)(addrAgtB));
    sqlite3VdbeResolveLabel(v, (int)(labelEnd));
    if ((pSplit.pPrior) != null)
    {
        sqlite3SelectDelete(db, pSplit.pPrior);
    }

    pSplit.pPrior = pPrior;
    pPrior.pNext = pSplit;
    sqlite3ExprListDelete(db, pPrior.pOrderBy);
    pPrior.pOrderBy = null;
    sqlite3VdbeExplainPop(pParse);
    return (int)(pParse.nErr != 0);
}</function>
  <function>public static KeyInfo multiSelectOrderByKeyInfo(Parse pParse, Select p, int nExtra)
{
    ExprList pOrderBy = p.pOrderBy;
    int nOrderBy = (int)((pOrderBy != null) ? pOrderBy.nExpr : 0);
    sqlite3 db = pParse.db;
    KeyInfo pRet = sqlite3KeyInfoAlloc(db, (int)(nOrderBy + nExtra), (int)(1));
    if ((pRet) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (nOrderBy); i++)
        {
            ExprList_item* pItem = &amp;pOrderBy.a[i];
            Expr pTerm = pItem-&gt;pExpr;
            CollSeq pColl;
            if ((pTerm.flags &amp; 0x000100) != 0)
            {
                pColl = sqlite3ExprCollSeq(pParse, pTerm);
            }
            else
            {
                pColl = multiSelectCollSeq(pParse, p, (int)(pItem-&gt;u.x.iOrderByCol - 1));
                if ((pColl) == (null))
                    pColl = db.pDfltColl;
                pOrderBy.a[i].pExpr = sqlite3ExprAddCollateString(pParse, pTerm, pColl.zName);
            }

            pRet.aColl[i] = pColl;
            pRet.aSortFlags[i] = (byte)(pOrderBy.a[i].sortFlags);
        }
    }

    return pRet;
}</function>
  <function>public static int multiSelectValues(Parse pParse, Select p, SelectDest pDest)
{
    int nRow = (int)(1);
    int rc = (int)(0);
    int bShowAll = (int)((p.pLimit) == (null) ? 1 : 0);
    do
    {
        if ((p.pWin) != null)
            return (int)(-1);
        if ((p.pPrior) == (null))
            break;
        p = p.pPrior;
        nRow += (int)(bShowAll);
    }
    while ((1) != 0);
    sqlite3VdbeExplain(pParse, (byte)(0), "SCAN %d CONSTANT ROW%s", (int)(nRow), (nRow) == (1) ? "" : "S");
    while ((p) != null)
    {
        selectInnerLoop(pParse, p, (int)(-1), null, null, pDest, (int)(1), (int)(1));
        if (bShowAll == 0)
            break;
        p.nSelectRow = (short)(nRow);
        p = p.pNext;
    }

    return (int)(rc);
}</function>
  <function>public static int nameInUsingClause(IdList* pUsing, sbyte* zCol)
{
    if ((pUsing) != null)
    {
        int k = 0;
        for (k = (int)(0); (k) &lt; (pUsing-&gt;nId); k++)
        {
            if ((sqlite3StrICmp(pUsing-&gt;a[k].zName, zCol)) == (0))
                return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int newDatabase(BtShared pBt)
{
    MemPage pP1;
    byte* data;
    int rc = 0;
    if ((pBt.nPage) &gt; (0))
    {
        return (int)(0);
    }

    pP1 = pBt.pPage1;
    data = pP1.aData;
    rc = (int)(sqlite3PagerWrite(pP1.pDbPage));
    if ((rc) != 0)
        return (int)(rc);
    CRuntime.memcpy(data, zMagicHeader, (ulong)(16 * sizeof(sbyte)));
    data[16] = ((byte)((pBt.pageSize &gt;&gt; 8) &amp; 0xff));
    data[17] = ((byte)((pBt.pageSize &gt;&gt; 16) &amp; 0xff));
    data[18] = (byte)(1);
    data[19] = (byte)(1);
    data[20] = ((byte)(pBt.pageSize - pBt.usableSize));
    data[21] = (byte)(64);
    data[22] = (byte)(32);
    data[23] = (byte)(32);
    CRuntime.memset(&amp;data[24], (int)(0), (ulong)(100 - 24));
    zeroPage(pP1, (int)(0x01 | 0x08 | 0x04));
    pBt.btsFlags |= (ushort)(0x0002);
    sqlite3Put4byte(&amp;data[36 + 4 * 4], (uint)(pBt.autoVacuum));
    sqlite3Put4byte(&amp;data[36 + 7 * 4], (uint)(pBt.incrVacuum));
    pBt.nPage = (uint)(1);
    data[31] = (byte)(1);
    return (int)(0);
}</function>
  <function>public static int nocaseCollatingFunc(void* NotUsed, int nKey1, void* pKey1, int nKey2, void* pKey2)
{
    int r = (int)(sqlite3_strnicmp((sbyte*)(pKey1), (sbyte*)(pKey2), (int)(((nKey1) &lt; (nKey2)) ? nKey1 : nKey2)));
    if ((0) == (r))
    {
        r = (int)(nKey1 - nKey2);
    }

    return (int)(r);
}</function>
  <function>public static sqlite3_mutex* noopMutexAlloc(int id)
{
    return (sqlite3_mutex*)(8);
}</function>
  <function>public static int noopMutexEnd()
{
    return (int)(0);
}</function>
  <function>public static void noopMutexEnter(sqlite3_mutex* p)
{
    return;
}</function>
  <function>public static void noopMutexFree(sqlite3_mutex* p)
{
    return;
}</function>
  <function>public static int noopMutexInit()
{
    return (int)(0);
}</function>
  <function>public static void noopMutexLeave(sqlite3_mutex* p)
{
    return;
}</function>
  <function>public static int noopMutexTry(sqlite3_mutex* p)
{
    return (int)(0);
}</function>
  <function>public static void noopStepFunc(sqlite3_context p, int n, sqlite3_value a)
{
}</function>
  <function>public static void noopValueFunc(sqlite3_context p)
{
}</function>
  <function>public static void notValidImpl(Parse pParse, NameContext pNC, sbyte* zMsg, Expr pExpr, Expr pError)
{
    sbyte* zIn = "partial index WHERE clauses";
    if ((pNC.ncFlags &amp; 0x000020) != 0)
        zIn = "index expressions";
    else if ((pNC.ncFlags &amp; 0x000004) != 0)
        zIn = "CHECK constraints";
    else if ((pNC.ncFlags &amp; 0x000008) != 0)
        zIn = "generated columns";
    sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
    if ((pExpr) != null)
        pExpr.op = (byte)(121);
    sqlite3RecordErrorOffsetOfExpr(pParse.db, pError);
}</function>
  <function>public static void nth_valueFinalizeFunc(sqlite3_context pCtx)
{
    NthValueCtx p;
    p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(0)));
    if (((p) != null) &amp;&amp; ((p.pValue) != null))
    {
        sqlite3_result_value(pCtx, p.pValue);
        sqlite3_value_free(p.pValue);
        p.pValue = null;
    }
}</function>
  <function>public static void nth_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    NthValueCtx p;
    p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
    if ((p) != null)
    {
        long iVal = 0;
        switch (sqlite3_value_numeric_type(apArg[1]))
        {
            case 1:
                iVal = (long)(sqlite3_value_int64(apArg[1]));
                break;
            case 2:
            {
                double fVal = (double)(sqlite3_value_double(apArg[1]));
                if (((long)(fVal)) != fVal)
                    goto error_out;
                iVal = ((long)(fVal));
                break;
            }

            default:
                goto error_out;
        }

        if ((iVal) &lt;= (0))
            goto error_out;
        p.nStep++;
        if ((iVal) == (p.nStep))
        {
            p.pValue = sqlite3_value_dup(apArg[0]);
            if (p.pValue == null)
            {
                sqlite3_result_error_nomem(pCtx);
            }
        }
    }

    return;
    error_out:
        ; sqlite3_result_error ( pCtx ,  "second argument to nth_value must be a positive integer" ,  ( int ) ( - 1 ) ) ; 
}</function>
  <function>public static void ntileInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    NtileCtx* p;
    p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
    p-&gt;iRow++;
}</function>
  <function>public static void ntileStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    NtileCtx* p;
    p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
    if ((p) != null)
    {
        if ((p-&gt;nTotal) == (0))
        {
            p-&gt;nParam = (long)(sqlite3_value_int64(apArg[0]));
            if ((p-&gt;nParam) &lt;= (0))
            {
                sqlite3_result_error(pCtx, "argument of ntile must be a positive integer", (int)(-1));
            }
        }

        p-&gt;nTotal++;
    }
}</function>
  <function>public static void ntileValueFunc(sqlite3_context pCtx)
{
    NtileCtx* p;
    p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
    if (((p) != null) &amp;&amp; ((p-&gt;nParam) &gt; (0)))
    {
        int nSize = (int)(p-&gt;nTotal / p-&gt;nParam);
        if ((nSize) == (0))
        {
            sqlite3_result_int64(pCtx, (long)(p-&gt;iRow + 1));
        }
        else
        {
            long nLarge = (long)(p-&gt;nTotal - p-&gt;nParam * nSize);
            long iSmall = (long)(nLarge * (nSize + 1));
            long iRow = (long)(p-&gt;iRow);
            if ((iRow) &lt; (iSmall))
            {
                sqlite3_result_int64(pCtx, (long)(1 + iRow / (nSize + 1)));
            }
            else
            {
                sqlite3_result_int64(pCtx, (long)(1 + nLarge + (iRow - iSmall) / nSize));
            }
        }
    }
}</function>
  <function>public static void nullifFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    CollSeq pColl = sqlite3GetFuncCollSeq(context);
    if (sqlite3MemCompare(argv[0], argv[1], pColl) != 0)
    {
        sqlite3_result_value(context, argv[0]);
    }
}</function>
  <function>public static int numberOfCachePages(PCache p)
{
    if ((p.szCache) &gt;= (0))
    {
        return (int)(p.szCache);
    }
    else
    {
        long n = 0;
        n = (long)((-1024 * (long)(p.szCache)) / (p.szPage + p.szExtra));
        if ((n) &gt; (1000000000))
            n = (long)(1000000000);
        return (int)(n);
    }
}</function>
  <function>public static ushort numericType(sqlite3_value pMem)
{
    if ((pMem.flags &amp; (0x0004 | 0x0008 | 0x0020)) != 0)
    {
        return (ushort)(pMem.flags &amp; (0x0004 | 0x0008 | 0x0020));
    }

    if ((pMem.flags &amp; (0x0002 | 0x0010)) != 0)
    {
        return (ushort)(computeNumericType(pMem));
    }

    return (ushort)(0);
}</function>
  <function>public static int openDatabase(sbyte* zFilename, sqlite3 ppDb, uint flags, sbyte* zVfs)
{
    sqlite3 db;
    int rc = 0;
    int isThreadsafe = 0;
    sbyte* zOpen = null;
    sbyte* zErrMsg = null;
    int i = 0;
    ppDb = null;
    rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (int)(rc);
    if ((sqlite3Config.bCoreMutex) == (0))
    {
        isThreadsafe = (int)(0);
    }
    else if ((flags &amp; 0x00008000) != 0)
    {
        isThreadsafe = (int)(0);
    }
    else if ((flags &amp; 0x00010000) != 0)
    {
        isThreadsafe = (int)(1);
    }
    else
    {
        isThreadsafe = (int)(sqlite3Config.bFullMutex);
    }

    if ((flags &amp; 0x00040000) != 0)
    {
        flags &amp;= (uint)(~0x00020000);
    }
    else if ((sqlite3Config.sharedCacheEnabled) != 0)
    {
        flags |= (uint)(0x00020000);
    }

    flags &amp;= (uint)(~(0x00000008 | 0x00000010 | 0x00000100 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00001000 | 0x00002000 | 0x00004000 | 0x00008000 | 0x00010000 | 0x00080000));
    db = sqlite3MallocZero((ulong)(sizeof(sqlite3)));
    if ((db) == (null))
        goto opendb_out;
    if ((isThreadsafe) != 0)
    {
        db.mutex = sqlite3MutexAlloc((int)(1));
        if ((db.mutex) == (null))
        {
            sqlite3_free(db);
            db = null;
            goto opendb_out;
        }

        if ((isThreadsafe) == (0))
        {
        }
    }

    sqlite3_mutex_enter(db.mutex);
    db.errMask = (int)((flags &amp; 0x02000000) != 0 ? 0xffffffff : 0xff);
    db.nDb = (int)(2);
    db.eOpenState = (byte)(0x6d);
    db.aDb = db.aDbStatic;
    db.lookaside.bDisable = (uint)(1);
    db.lookaside.sz = (ushort)(0);
    CRuntime.memcpy(db.aLimit, aHardLimit, (ulong)(12 * sizeof(int)));
    db.aLimit[11] = (int)(0);
    db.autoCommit = (byte)(1);
    db.nextAutovac = (sbyte)(-1);
    db.szMmap = (long)(sqlite3Config.szMmap);
    db.nextPagesize = (int)(0);
    db.init.azInit = sqlite3StdType;
    db.flags |= (ulong)(0x00000040 | 0x00040000 | 0x80000000 | 0x00000020 | 0x00000080 | 0x40000000 | 0x20000000 | 0x00008000);
    sqlite3HashInit(&amp;db.aCollSeq);
    sqlite3HashInit(&amp;db.aModule);
    createCollation(db, sqlite3StrBINARY, (byte)(1), null, binCollFunc, null);
    createCollation(db, sqlite3StrBINARY, (byte)(3), null, binCollFunc, null);
    createCollation(db, sqlite3StrBINARY, (byte)(2), null, binCollFunc, null);
    createCollation(db, "NOCASE", (byte)(1), null, nocaseCollatingFunc, null);
    createCollation(db, "RTRIM", (byte)(1), null, rtrimCollFunc, null);
    if ((db.mallocFailed) != 0)
    {
        goto opendb_out;
    }

    db.openFlags = (uint)(flags);
    if (((1 &lt;&lt; (flags &amp; 7)) &amp; 0x46) == (0))
    {
        rc = (int)(sqlite3MisuseError((int)(171858)));
    }
    else
    {
        rc = (int)(sqlite3ParseUri(zVfs, zFilename, &amp;flags, db.pVfs, &amp;zOpen, &amp;zErrMsg));
    }

    if (rc != 0)
    {
        if ((rc) == (7))
            sqlite3OomFault(db);
        sqlite3ErrorWithMsg(db, (int)(rc), (zErrMsg) != 0 ? "%s" : null, zErrMsg);
        sqlite3_free(zErrMsg);
        goto opendb_out;
    }

    rc = (int)(sqlite3BtreeOpen(db.pVfs, zOpen, db, db.aDb[0].pBt, (int)(0), (int)(flags | 0x00000100)));
    if (rc != 0)
    {
        if ((rc) == (10 | (12 &lt;&lt; 8)))
        {
            rc = (int)(7);
        }

        sqlite3Error(db, (int)(rc));
        goto opendb_out;
    }

    sqlite3BtreeEnter(db.aDb[0].pBt);
    db.aDb[0].pSchema = sqlite3SchemaGet(db, db.aDb[0].pBt);
    if (db.mallocFailed == 0)
    {
        sqlite3SetTextEncoding(db, (byte)((db).aDb[0].pSchema.enc));
    }

    sqlite3BtreeLeave(db.aDb[0].pBt);
    db.aDb[1].pSchema = sqlite3SchemaGet(db, null);
    db.aDb[0].zDbSName = "main";
    db.aDb[0].safety_level = (byte)(2 + 1);
    db.aDb[1].zDbSName = "temp";
    db.aDb[1].safety_level = (byte)(0x01);
    db.eOpenState = (byte)(0x76);
    if ((db.mallocFailed) != 0)
    {
        goto opendb_out;
    }

    sqlite3Error(db, (int)(0));
    sqlite3RegisterPerConnectionBuiltinFunctions(db);
    rc = (int)(sqlite3_errcode(db));
    for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; ((int)(2 * sizeof(Int(sqlite3 * )) / sizeof(Int(sqlite3 * ))))
         ) ;  i ++ ) { rc  =  ( int ) ( sqlite3BuiltinExtensions [ i ] ( db ) ) ;  }
    if ((rc) == (0))
    {
        sqlite3AutoLoadExtensions(db);
        rc = (int)(sqlite3_errcode(db));
        if (rc != 0)
        {
            goto opendb_out;
        }
    }

    if ((rc) != 0)
        sqlite3Error(db, (int)(rc));
    setupLookaside(db, null, (int)(sqlite3Config.szLookaside), (int)(sqlite3Config.nLookaside));
    sqlite3_wal_autocheckpoint(db, (int)(1000));
    opendb_out:
        ; if  ( ( db ) != null ) { sqlite3_mutex_leave ( db . mutex ) ;  }
    rc = (int)(sqlite3_errcode(db));
    if ((rc &amp; 0xff) == (7))
    {
        sqlite3_close(db);
        db = null;
    }
    else if (rc != 0)
    {
        db.eOpenState = (byte)(0xba);
    }

    ppDb = db;
    sqlite3_free_filename(zOpen);
    return (int)(rc);
}</function>
  <function>public static void openStatTable(Parse pParse, int iDb, int iStatCur, sbyte* zWhere, sbyte* zWhereType)
{
    int i = 0;
    sqlite3 db = pParse.db;
    Db pDb;
    Vdbe v = sqlite3GetVdbe(pParse);
    uint* aRoot = stackalloc uint[3];
    byte* aCreateTbl = stackalloc byte[3];
    int nToOpen = (int)(1);
    if ((v) == (null))
        return;
    pDb = db.aDb[iDb];
    for (i = (int)(0); (i) &lt; ((int)(3 * sizeof(aTableType) / sizeof(aTableType))); i++)
    {
        sbyte* zTab = openStatTable_aTable[i].zName;
        Table pStat;
        aCreateTbl[i] = (byte)(0);
        if ((pStat = sqlite3FindTable(db, zTab, pDb.zDbSName)) == (null))
        {
            if ((i) &lt; (nToOpen))
            {
                sqlite3NestedParse(pParse, "CREATE TABLE %Q.%s(%s)", pDb.zDbSName, zTab, openStatTable_aTable[i].zCols);
                aRoot[i] = ((uint)(pParse.regRoot));
                aCreateTbl[i] = (byte)(0x10);
            }
        }
        else
        {
            aRoot[i] = (uint)(pStat.tnum);
            sqlite3TableLock(pParse, (int)(iDb), (uint)(aRoot[i]), (byte)(1), zTab);
            if ((zWhere) != null)
            {
                sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", pDb.zDbSName, zTab, zWhereType, zWhere);
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(144), (int)(aRoot[i]), (int)(iDb));
            }
        }
    }

    for (i = (int)(0); (i) &lt; (nToOpen); i++)
    {
        sqlite3VdbeAddOp4Int(v, (int)(112), (int)(iStatCur + i), (int)(aRoot[i]), (int)(iDb), (int)(3));
        sqlite3VdbeChangeP5(v, (ushort)(aCreateTbl[i]));
    }
}</function>
  <function>public static int openSubJournal(Pager pPager)
{
    int rc = (int)(0);
    if (!((pPager.sjfd).pMethods != null))
    {
        int flags = (int)(0x00002000 | 0x00000002 | 0x00000004 | 0x00000010 | 0x00000008);
        int nStmtSpill = (int)(sqlite3Config.nStmtSpill);
        if (((pPager.journalMode) == (4)) || ((pPager.subjInMemory) != 0))
        {
            nStmtSpill = (int)(-1);
        }

        rc = (int)(sqlite3JournalOpen(pPager.pVfs, null, pPager.sjfd, (int)(flags), (int)(nStmtSpill)));
    }

    return (int)(rc);
}</function>
  <function>public static ushort operatorMask(int op)
{
    ushort c = 0;
    if ((op) == (49))
    {
        c = (ushort)(0x0001);
    }
    else if ((op) == (50))
    {
        c = (ushort)(0x0100);
    }
    else if ((op) == (45))
    {
        c = (ushort)(0x0080);
    }
    else
    {
        c = ((ushort)(0x0002 &lt;&lt; (op - 53)));
    }

    return (ushort)(c);
}</function>
  <function>public static int osLocaltime(long* t, tm* pTm)
{
    int rc = 0;
    if ((sqlite3Config.bLocaltimeFault) != 0)
    {
        if (sqlite3Config.xAltLocaltime != null)
        {
            return (int)(sqlite3Config.xAltLocaltime((void*)(t), (void*)(pTm)));
        }
        else
        {
            return (int)(1);
        }
    }

    rc = (int)(localtime_s(pTm, t));
    return (int)(rc);
}</function>
  <function>public static sqlite3_value out2Prerelease(Vdbe p, VdbeOp* pOp)
{
    sqlite3_value pOut;
    pOut = p.aMem[pOp-&gt;p2];
    if ((((pOut).flags &amp; (0x2000 | 0x0400)) != 0))
    {
        return out2PrereleaseWithClear(pOut);
    }
    else
    {
        pOut.flags = (ushort)(0x0004);
        return pOut;
    }
}</function>
  <function>public static sqlite3_value out2PrereleaseWithClear(sqlite3_value pOut)
{
    sqlite3VdbeMemSetNull(pOut);
    pOut.flags = (ushort)(0x0004);
    return pOut;
}</function>
  <function>public static byte* pageFindSlot(MemPage pPg, int nByte, int* pRc)
{
    int hdr = (int)(pPg.hdrOffset);
    byte* aData = pPg.aData;
    int iAddr = (int)(hdr + 1);
    int pc = (int)((&amp;aData[iAddr])[0] &lt;&lt; 8 | (&amp;aData[iAddr])[1]);
    int x = 0;
    int maxPC = (int)(pPg.pBt.usableSize - nByte);
    int size = 0;
    while ((pc) &lt;= (maxPC))
    {
        size = (int)((&amp;aData[pc + 2])[0] &lt;&lt; 8 | (&amp;aData[pc + 2])[1]);
        if ((x = (int)(size - nByte)) &gt;= (0))
        {
            if ((x) &lt; (4))
            {
                if ((aData[hdr + 7]) &gt; (57))
                    return null;
                CRuntime.memcpy(&amp;aData[iAddr], &amp;aData[pc], (ulong)(2));
                aData[hdr + 7] += ((byte)(x));
            }
            else if ((x + pc) &gt; (maxPC))
            {
                *pRc = (int)(sqlite3CorruptError((int)(67776)));
                return null;
            }
            else
            {
                ((&amp;aData[pc + 2])[0] = ((byte)((x) &gt;&gt; 8)), (&amp;aData[pc + 2])[1] = ((byte)(x)));
            }

            return &amp;aData[pc + x];
        }

        iAddr = (int)(pc);
        pc = (int)((&amp;aData[pc])[0] &lt;&lt; 8 | (&amp;aData[pc])[1]);
        if ((pc) &lt;= (iAddr + size))
        {
            if ((pc) != 0)
            {
                *pRc = (int)(sqlite3CorruptError((int)(67790)));
            }

            return null;
        }
    }

    if ((pc) &gt; (maxPC + nByte - 4))
    {
        *pRc = (int)(sqlite3CorruptError((int)(67797)));
    }

    return null;
}</function>
  <function>public static int pageFreeArray(MemPage pPg, int iFirst, int nCell, CellArray pCArray)
{
    byte* aData = pPg.aData;
    byte* pEnd = &amp;aData[pPg.pBt.usableSize];
    byte* pStart = &amp;aData[pPg.hdrOffset + 8 + pPg.childPtrSize];
    int nRet = (int)(0);
    int i = 0;
    int iEnd = (int)(iFirst + nCell);
    byte* pFree = null;
    int szFree = (int)(0);
    for (i = (int)(iFirst); (i) &lt; (iEnd); i++)
    {
        byte* pCell = pCArray.apCell[i];
        if (((((ulong)(pCell)) &gt;= ((ulong)(pStart))) &amp;&amp; (((ulong)(pCell)) &lt; ((ulong)(pEnd)))))
        {
            int sz = 0;
            sz = (int)(pCArray.szCell[i]);
            if (pFree != (pCell + sz))
            {
                if ((pFree) != null)
                {
                    freeSpace(pPg, (ushort)(pFree - aData), (ushort)(szFree));
                }

                pFree = pCell;
                szFree = (int)(sz);
                if ((pFree + sz) &gt; (pEnd))
                {
                    return (int)(0);
                }
            }
            else
            {
                pFree = pCell;
                szFree += (int)(sz);
            }

            nRet++;
        }
    }

    if ((pFree) != null)
    {
        freeSpace(pPg, (ushort)(pFree - aData), (ushort)(szFree));
    }

    return (int)(nRet);
}</function>
  <function>public static int pageInsertArray(MemPage pPg, byte* pBegin, byte** ppData, byte* pCellptr, int iFirst, int nCell, CellArray pCArray)
{
    int i = (int)(iFirst);
    byte* aData = pPg.aData;
    byte* pData = *ppData;
    int iEnd = (int)(iFirst + nCell);
    int k = 0;
    byte* pEnd;
    if ((iEnd) &lt;= (iFirst))
        return (int)(0);
    for (k = (int)(0); ((pCArray.ixNx[k]) &lt;= (i)) &amp;&amp; ((k) &lt; (3 * 2)); k++)
    {
    }

    pEnd = pCArray.apEnd[k];
    while ((1) != 0)
    {
        int sz = 0;
        int rc = 0;
        byte* pSlot;
        sz = (int)(pCArray.szCell[i]);
        if ((((aData[1]) == (0)) &amp;&amp; ((aData[2]) == (0))) || ((pSlot = pageFindSlot(pPg, (int)(sz), &amp;rc)) == (null)))
        {
            if ((pData - pBegin) &lt; (sz))
                return (int)(1);
            pData -= sz;
            pSlot = pData;
        }

        if ((((ulong)(pCArray.apCell[i] + sz)) &gt; ((ulong)(pEnd))) &amp;&amp; (((ulong)(pCArray.apCell[i])) &lt; ((ulong)(pEnd))))
        {
            (void)(sqlite3CorruptError((int)(73417)));
            return (int)(1);
        }

        CRuntime.memmove(pSlot, pCArray.apCell[i], (ulong)(sz));
        ((pCellptr)[0] = ((byte)((pSlot - aData) &gt;&gt; 8)), (pCellptr)[1] = ((byte)(pSlot - aData)));
        pCellptr += 2;
        i++;
        if ((i) &gt;= (iEnd))
            break;
        if ((pCArray.ixNx[k]) &lt;= (i))
        {
            k++;
            pEnd = pCArray.apEnd[k];
        }
    }

    *ppData = pData;
    return (int)(0);
}</function>
  <function>public static uint pager_cksum(Pager pPager, byte* aData)
{
    uint cksum = (uint)(pPager.cksumInit);
    int i = (int)(pPager.pageSize - 200);
    while ((i) &gt; (0))
    {
        cksum += (uint)(aData[i]);
        i -= (int)(200);
    }

    return (uint)(cksum);
}</function>
  <function>public static int pager_delsuper(Pager pPager, sbyte* zSuper)
{
    sqlite3_vfs pVfs = pPager.pVfs;
    int rc = 0;
    sqlite3_file pSuper;
    sqlite3_file pJournal;
    sbyte* zSuperJournal = null;
    long nSuperJournal = 0;
    sbyte* zJournal;
    sbyte* zSuperPtr;
    sbyte* zFree = null;
    int nSuperPtr = 0;
    pSuper = (sqlite3_file)(sqlite3MallocZero((ulong)(pVfs.szOsFile * 2)));
    if (pSuper == null)
    {
        rc = (int)(7);
        pJournal = null;
    }
    else
    {
        int flags = (int)(0x00000001 | 0x00004000);
        rc = (int)(sqlite3OsOpen(pVfs, zSuper, pSuper, (int)(flags), null));
        pJournal = (sqlite3_file)(((byte*)(pSuper)) + pVfs.szOsFile);
    }

    if (rc != 0)
        goto delsuper_out;
    rc = (int)(sqlite3OsFileSize(pSuper, &amp;nSuperJournal));
    if (rc != 0)
        goto delsuper_out;
    nSuperPtr = (int)(pVfs.mxPathname + 1);
    zFree = sqlite3Malloc((ulong)(4 + nSuperJournal + nSuperPtr + 2));
    if (zFree == null)
    {
        rc = (int)(7);
        goto delsuper_out;
    }

    zFree[0] = (sbyte)(zFree[1] = (sbyte)(zFree[2] = (sbyte)(zFree[3] = (sbyte)(0))));
    zSuperJournal = &amp;zFree[4];
    zSuperPtr = &amp;zSuperJournal[nSuperJournal + 2];
    rc = (int)(sqlite3OsRead(pSuper, zSuperJournal, (int)(nSuperJournal), (long)(0)));
    if (rc != 0)
        goto delsuper_out;
    zSuperJournal[nSuperJournal] = (sbyte)(0);
    zSuperJournal[nSuperJournal + 1] = (sbyte)(0);
    zJournal = zSuperJournal;
    while ((zJournal - zSuperJournal) &lt; (nSuperJournal))
    {
        int exists = 0;
        rc = (int)(sqlite3OsAccess(pVfs, zJournal, (int)(0), &amp;exists));
        if (rc != 0)
        {
            goto delsuper_out;
        }

        if ((exists) != 0)
        {
            int c = 0;
            int flags = (int)(0x00000001 | 0x00004000);
            rc = (int)(sqlite3OsOpen(pVfs, zJournal, pJournal, (int)(flags), null));
            if (rc != 0)
            {
                goto delsuper_out;
            }

            rc = (int)(readSuperJournal(pJournal, zSuperPtr, (uint)(nSuperPtr)));
            sqlite3OsClose(pJournal);
            if (rc != 0)
            {
                goto delsuper_out;
            }

            c = (int)((zSuperPtr[0] != 0) &amp;&amp; ((CRuntime.strcmp(zSuperPtr, zSuper)) == (0)) ? 1 : 0);
            if ((c) != 0)
            {
                goto delsuper_out;
            }
        }

        zJournal += (sqlite3Strlen30(zJournal) + 1);
    }

    sqlite3OsClose(pSuper);
    rc = (int)(sqlite3OsDelete(pVfs, zSuper, (int)(0)));
    delsuper_out:
        ; sqlite3_free ( zFree ) ; 
    if ((pSuper) != null)
    {
        sqlite3OsClose(pSuper);
        sqlite3_free(pSuper);
    }

    return (int)(rc);
}</function>
  <function>public static int pager_end_transaction(Pager pPager, int hasSuper, int bCommit)
{
    int rc = (int)(0);
    int rc2 = (int)(0);
    if (((pPager.eState) &lt; (2)) &amp;&amp; ((pPager.eLock) &lt; (2)))
    {
        return (int)(0);
    }

    releaseAllSavepoints(pPager);
    if (((pPager.jfd).pMethods != null))
    {
        if ((sqlite3JournalIsInMemory(pPager.jfd)) != 0)
        {
            sqlite3OsClose(pPager.jfd);
        }
        else if ((pPager.journalMode) == (3))
        {
            if ((pPager.journalOff) == (0))
            {
                rc = (int)(0);
            }
            else
            {
                rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(0)));
                if (((rc) == (0)) &amp;&amp; ((pPager.fullSync) != 0))
                {
                    rc = (int)(sqlite3OsSync(pPager.jfd, (int)(pPager.syncFlags)));
                }
            }

            pPager.journalOff = (long)(0);
        }
        else if (((pPager.journalMode) == (1)) || (((pPager.exclusiveMode) != 0) &amp;&amp; (pPager.journalMode != 5)))
        {
            rc = (int)(zeroJournalHdr(pPager, (((hasSuper) != 0) || ((pPager.tempFile) != 0) ? 1 : 0)));
            pPager.journalOff = (long)(0);
        }
        else
        {
            int bDelete = (int)(!pPager.tempFile);
            sqlite3OsClose(pPager.jfd);
            if ((bDelete) != 0)
            {
                rc = (int)(sqlite3OsDelete(pPager.pVfs, pPager.zJournal, (int)(pPager.extraSync)));
            }
        }
    }

    sqlite3BitvecDestroy(pPager.pInJournal);
    pPager.pInJournal = null;
    pPager.nRec = (int)(0);
    if ((rc) == (0))
    {
        if (((pPager.memDb) != 0) || ((pagerFlushOnCommit(pPager, (int)(bCommit))) != 0))
        {
            sqlite3PcacheCleanAll(pPager.pPCache);
        }
        else
        {
            sqlite3PcacheClearWritable(pPager.pPCache);
        }

        sqlite3PcacheTruncate(pPager.pPCache, (uint)(pPager.dbSize));
    }

    if (((pPager).pWal != null))
    {
        rc2 = (int)(sqlite3WalEndWriteTransaction(pPager.pWal));
    }
    else if ((((rc) == (0)) &amp;&amp; ((bCommit) != 0)) &amp;&amp; ((pPager.dbFileSize) &gt; (pPager.dbSize)))
    {
        rc = (int)(pager_truncate(pPager, (uint)(pPager.dbSize)));
    }

    if (((rc) == (0)) &amp;&amp; ((bCommit) != 0))
    {
        rc = (int)(sqlite3OsFileControl(pPager.fd, (int)(22), null));
        if ((rc) == (12))
            rc = (int)(0);
    }

    if ((pPager.exclusiveMode == 0) &amp;&amp; ((!((pPager).pWal != null)) || ((sqlite3WalExclusiveMode(pPager.pWal, (int)(0))) != 0)))
    {
        rc2 = (int)(pagerUnlockDb(pPager, (int)(1)));
    }

    pPager.eState = (byte)(1);
    pPager.setSuper = (byte)(0);
    return (int)((rc) == (0) ? rc2 : rc);
}</function>
  <function>public static int pager_error(Pager pPager, int rc)
{
    int rc2 = (int)(rc &amp; 0xff);
    if (((rc2) == (13)) || ((rc2) == (10)))
    {
        pPager.errCode = (int)(rc);
        pPager.eState = (byte)(6);
        setGetterMethod(pPager);
    }

    return (int)(rc);
}</function>
  <function>public static int pager_incr_changecounter(Pager pPager, int isDirectMode)
{
    int rc = (int)(0);
    if ((pPager.changeCountDone == 0) &amp;&amp; ((pPager.dbSize) &gt; (0)))
    {
        PgHdr pPgHdr;
        rc = (int)(sqlite3PagerGet(pPager, (uint)(1), pPgHdr, (int)(0)));
        if ((0 == 0) &amp;&amp; ((rc) == (0)))
        {
            rc = (int)(sqlite3PagerWrite(pPgHdr));
        }

        if ((rc) == (0))
        {
            pager_write_changecounter(pPgHdr);
            if ((0) != 0)
            {
                void* zBuf;
                zBuf = pPgHdr.pData;
                if ((rc) == (0))
                {
                    rc = (int)(sqlite3OsWrite(pPager.fd, zBuf, (int)(pPager.pageSize), (long)(0)));
                    pPager.aStat[2]++;
                }

                if ((rc) == (0))
                {
                    void* pCopy = (void*)(&amp;((sbyte*)(zBuf))[24]);
                    CRuntime.memcpy(&amp;pPager.dbFileVers, pCopy, (ulong)(16 * sizeof(sbyte)));
                    pPager.changeCountDone = (byte)(1);
                }
            }
            else
            {
                pPager.changeCountDone = (byte)(1);
            }
        }

        sqlite3PagerUnref(pPgHdr);
    }

    return (int)(rc);
}</function>
  <function>public static int pager_open_journal(Pager pPager)
{
    int rc = (int)(0);
    sqlite3_vfs pVfs = pPager.pVfs;
    if ((pPager.errCode) != 0)
        return (int)(pPager.errCode);
    if ((!((pPager).pWal != null)) &amp;&amp; (pPager.journalMode != 2))
    {
        pPager.pInJournal = sqlite3BitvecCreate((uint)(pPager.dbSize));
        if ((pPager.pInJournal) == (null))
        {
            return (int)(7);
        }

        if (!((pPager.jfd).pMethods != null))
        {
            if ((pPager.journalMode) == (4))
            {
                sqlite3MemJournalOpen(pPager.jfd);
            }
            else
            {
                int flags = (int)(0x00000002 | 0x00000004);
                int nSpill = 0;
                if ((pPager.tempFile) != 0)
                {
                    flags |= (int)(0x00000008 | 0x00001000);
                    nSpill = (int)(sqlite3Config.nStmtSpill);
                }
                else
                {
                    flags |= (int)(0x00000800);
                    nSpill = (int)(jrnlBufferSize(pPager));
                }

                rc = (int)(databaseIsUnmoved(pPager));
                if ((rc) == (0))
                {
                    rc = (int)(sqlite3JournalOpen(pVfs, pPager.zJournal, pPager.jfd, (int)(flags), (int)(nSpill)));
                }
            }
        }

        if ((rc) == (0))
        {
            pPager.nRec = (int)(0);
            pPager.journalOff = (long)(0);
            pPager.setSuper = (byte)(0);
            pPager.journalHdr = (long)(0);
            rc = (int)(writeJournalHdr(pPager));
        }
    }

    if (rc != 0)
    {
        sqlite3BitvecDestroy(pPager.pInJournal);
        pPager.pInJournal = null;
    }
    else
    {
        pPager.eState = (byte)(3);
    }

    return (int)(rc);
}</function>
  <function>public static int pager_playback(Pager pPager, int isHot)
{
    sqlite3_vfs pVfs = pPager.pVfs;
    long szJ = 0;
    uint nRec = 0;
    uint u = 0;
    uint mxPg = (uint)(0);
    int rc = 0;
    int res = (int)(1);
    sbyte* zSuper = null;
    int needPagerReset = 0;
    int nPlayback = (int)(0);
    uint savedPageSize = (uint)(pPager.pageSize);
    rc = (int)(sqlite3OsFileSize(pPager.jfd, &amp;szJ));
    if (rc != 0)
    {
        goto end_playback;
    }

    zSuper = pPager.pTmpSpace;
    rc = (int)(readSuperJournal(pPager.jfd, zSuper, (uint)(pPager.pVfs.mxPathname + 1)));
    if (((rc) == (0)) &amp;&amp; ((zSuper[0]) != 0))
    {
        rc = (int)(sqlite3OsAccess(pVfs, zSuper, (int)(0), &amp;res));
    }

    zSuper = null;
    if ((rc != 0) || (res == 0))
    {
        goto end_playback;
    }

    pPager.journalOff = (long)(0);
    needPagerReset = (int)(isHot);
    while ((1) != 0)
    {
        rc = (int)(readJournalHdr(pPager, (int)(isHot), (long)(szJ), &amp;nRec, &amp;mxPg));
        if (rc != 0)
        {
            if ((rc) == (101))
            {
                rc = (int)(0);
            }

            goto end_playback;
        }

        if ((nRec) == (0xffffffff))
        {
            nRec = (uint)((int)((szJ - (pPager.sectorSize)) / ((pPager.pageSize) + 8)));
        }

        if ((((nRec) == (0)) &amp;&amp; (isHot == 0)) &amp;&amp; ((pPager.journalHdr + (pPager.sectorSize)) == (pPager.journalOff)))
        {
            nRec = (uint)((int)((szJ - pPager.journalOff) / ((pPager.pageSize) + 8)));
        }

        if ((pPager.journalOff) == (pPager.sectorSize))
        {
            rc = (int)(pager_truncate(pPager, (uint)(mxPg)));
            if (rc != 0)
            {
                goto end_playback;
            }

            pPager.dbSize = (uint)(mxPg);
            if ((pPager.mxPgno) &lt; (mxPg))
            {
                pPager.mxPgno = (uint)(mxPg);
            }
        }

        for (u = (uint)(0); (u) &lt; (nRec); u++)
        {
            if ((needPagerReset) != 0)
            {
                pager_reset(pPager);
                needPagerReset = (int)(0);
            }

            rc = (int)(pager_playback_one_page(pPager, &amp;pPager.journalOff, null, (int)(1), (int)(0)));
            if ((rc) == (0))
            {
                nPlayback++;
            }
            else
            {
                if ((rc) == (101))
                {
                    pPager.journalOff = (long)(szJ);
                    break;
                }
                else if ((rc) == (10 | (2 &lt;&lt; 8)))
                {
                    rc = (int)(0);
                    goto end_playback;
                }
                else
                {
                    goto end_playback;
                }
            }
        }
    }

    end_playback:
        ; if  ( ( rc ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3PagerSetPagesize ( pPager ,  &amp; savedPageSize ,  ( int ) ( - 1 ) ) ) ;  }
    pPager.changeCountDone = (byte)(pPager.tempFile);
    if ((rc) == (0))
    {
        zSuper = &amp;pPager.pTmpSpace[4];
        rc = (int)(readSuperJournal(pPager.jfd, zSuper, (uint)(pPager.pVfs.mxPathname + 1)));
    }

    if (((rc) == (0)) &amp;&amp; (((pPager.eState) &gt;= (4)) || ((pPager.eState) == (0))))
    {
        rc = (int)(sqlite3PagerSync(pPager, null));
    }

    if ((rc) == (0))
    {
        rc = (int)(pager_end_transaction(pPager, (int)(zSuper[0] != 0), (int)(0)));
    }

    if ((((rc) == (0)) &amp;&amp; ((zSuper[0]) != 0)) &amp;&amp; ((res) != 0))
    {
        CRuntime.memset(&amp;zSuper[-4], (int)(0), (ulong)(4));
        rc = (int)(pager_delsuper(pPager, zSuper));
    }

    if (((isHot) != 0) &amp;&amp; ((nPlayback) != 0))
    {
        sqlite3_log((int)(27 | (2 &lt;&lt; 8)), "recovered %d pages from %s", (int)(nPlayback), pPager.zJournal);
    }

    setSectorSize(pPager);
    return (int)(rc);
}</function>
  <function>public static int pager_playback_one_page(Pager pPager, long* pOffset, Bitvec* pDone, int isMainJrnl, int isSavepnt)
{
    int rc = 0;
    PgHdr pPg;
    uint pgno = 0;
    uint cksum = 0;
    sbyte* aData;
    sqlite3_file jfd;
    int isSynced = 0;
    aData = pPager.pTmpSpace;
    jfd = (isMainJrnl) != 0 ? pPager.jfd : pPager.sjfd;
    rc = (int)(read32bits(jfd, (long)(*pOffset), &amp;pgno));
    if (rc != 0)
        return (int)(rc);
    rc = (int)(sqlite3OsRead(jfd, (byte*)(aData), (int)(pPager.pageSize), (long)((*pOffset) + 4)));
    if (rc != 0)
        return (int)(rc);
    *pOffset += (long)(pPager.pageSize + 4 + isMainJrnl * 4);
    if (((pgno) == (0)) || ((pgno) == ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1))))
    {
        return (int)(101);
    }

    if (((pgno) &gt; (pPager.dbSize)) || ((sqlite3BitvecTest(pDone, (uint)(pgno))) != 0))
    {
        return (int)(0);
    }

    if ((isMainJrnl) != 0)
    {
        rc = (int)(read32bits(jfd, (long)((*pOffset) - 4), &amp;cksum));
        if ((rc) != 0)
            return (int)(rc);
        if ((isSavepnt == 0) &amp;&amp; (pager_cksum(pPager, (byte*)(aData)) != cksum))
        {
            return (int)(101);
        }
    }

    if (((pDone) != null) &amp;&amp; ((rc = (int)(sqlite3BitvecSet(pDone, (uint)(pgno)))) != 0))
    {
        return (int)(rc);
    }

    if (((pgno) == (1)) &amp;&amp; (pPager.nReserve != ((byte*)(aData))[20]))
    {
        pPager.nReserve = (short)(((byte*)(aData))[20]);
    }

    if (((pPager).pWal != null))
    {
        pPg = null;
    }
    else
    {
        pPg = sqlite3PagerLookup(pPager, (uint)(pgno));
    }

    if ((isMainJrnl) != 0)
    {
        isSynced = (int)(((pPager.noSync) != 0) || ((*pOffset) &lt;= (pPager.journalHdr)) ? 1 : 0);
    }
    else
    {
        isSynced = (int)(((pPg) == (null)) || ((0) == (pPg.flags &amp; 0x008)) ? 1 : 0);
    }

    if ((((pPager.fd).pMethods != null) &amp;&amp; (((pPager.eState) &gt;= (4)) || ((pPager.eState) == (0)))) &amp;&amp; ((isSynced) != 0))
    {
        long ofst = (long)((pgno - 1) * pPager.pageSize);
        rc = (int)(sqlite3OsWrite(pPager.fd, (byte*)(aData), (int)(pPager.pageSize), (long)(ofst)));
        if ((pgno) &gt; (pPager.dbFileSize))
        {
            pPager.dbFileSize = (uint)(pgno);
        }

        if ((pPager.pBackup) != null)
        {
            sqlite3BackupUpdate(pPager.pBackup, (uint)(pgno), (byte*)(aData));
        }
    }
    else if ((isMainJrnl == 0) &amp;&amp; ((pPg) == (null)))
    {
        pPager.doNotSpill |= (byte)(0x02);
        rc = (int)(sqlite3PagerGet(pPager, (uint)(pgno), pPg, (int)(1)));
        pPager.doNotSpill &amp;= (byte)(~0x02);
        if (rc != 0)
            return (int)(rc);
        sqlite3PcacheMakeDirty(pPg);
    }

    if ((pPg) != null)
    {
        void* pData;
        pData = pPg.pData;
        CRuntime.memcpy(pData, (byte*)(aData), (ulong)(pPager.pageSize));
        pPager.xReiniter(pPg);
        if ((pgno) == (1))
        {
            CRuntime.memcpy(&amp;pPager.dbFileVers, &amp;((byte*)(pData))[24], (ulong)(16 * sizeof(sbyte)));
        }

        sqlite3PcacheRelease(pPg);
    }

    return (int)(rc);
}</function>
  <function>public static void pager_reset(Pager pPager)
{
    pPager.iDataVersion++;
    sqlite3BackupRestart(pPager.pBackup);
    sqlite3PcacheClear(pPager.pPCache);
}</function>
  <function>public static int pager_truncate(Pager pPager, uint nPage)
{
    int rc = (int)(0);
    if (((pPager.fd).pMethods != null) &amp;&amp; (((pPager.eState) &gt;= (4)) || ((pPager.eState) == (0))))
    {
        long currentSize = 0;
        long newSize = 0;
        int szPage = (int)(pPager.pageSize);
        rc = (int)(sqlite3OsFileSize(pPager.fd, &amp;currentSize));
        newSize = (long)(szPage * (long)(nPage));
        if (((rc) == (0)) &amp;&amp; (currentSize != newSize))
        {
            if ((currentSize) &gt; (newSize))
            {
                rc = (int)(sqlite3OsTruncate(pPager.fd, (long)(newSize)));
            }
            else if ((currentSize + szPage) &lt;= (newSize))
            {
                sbyte* pTmp = pPager.pTmpSpace;
                CRuntime.memset(pTmp, (int)(0), (ulong)(szPage));
                rc = (int)(sqlite3OsWrite(pPager.fd, pTmp, (int)(szPage), (long)(newSize - szPage)));
            }

            if ((rc) == (0))
            {
                pPager.dbFileSize = (uint)(nPage);
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static void pager_unlock(Pager pPager)
{
    sqlite3BitvecDestroy(pPager.pInJournal);
    pPager.pInJournal = null;
    releaseAllSavepoints(pPager);
    if (((pPager).pWal != null))
    {
        sqlite3WalEndReadTransaction(pPager.pWal);
        pPager.eState = (byte)(0);
    }
    else if (pPager.exclusiveMode == 0)
    {
        int rc = 0;
        int iDc = (int)(((pPager.fd).pMethods != null) ? sqlite3OsDeviceCharacteristics(pPager.fd) : 0);
        if (((0) == (iDc &amp; 0x00000800)) || (1 != (pPager.journalMode &amp; 5)))
        {
            sqlite3OsClose(pPager.jfd);
        }

        rc = (int)(pagerUnlockDb(pPager, (int)(0)));
        if ((rc != 0) &amp;&amp; ((pPager.eState) == (6)))
        {
            pPager.eLock = (byte)(4 + 1);
        }

        pPager.eState = (byte)(0);
    }

    if ((pPager.errCode) != 0)
    {
        if ((pPager.tempFile) == (0))
        {
            pager_reset(pPager);
            pPager.changeCountDone = (byte)(0);
            pPager.eState = (byte)(0);
        }
        else
        {
            pPager.eState = (byte)(((pPager.jfd).pMethods != null) ? 0 : 1);
        }

        if (((pPager).bUseFetch) != 0)
            sqlite3OsUnfetch(pPager.fd, (long)(0), null);
        pPager.errCode = (int)(0);
        setGetterMethod(pPager);
    }

    pPager.journalOff = (long)(0);
    pPager.journalHdr = (long)(0);
    pPager.setSuper = (byte)(0);
}</function>
  <function>public static int pager_wait_on_lock(Pager pPager, int locktype)
{
    int rc = 0;
    do
    {
        rc = (int)(pagerLockDb(pPager, (int)(locktype)));
    }
    while (((rc) == (5)) &amp;&amp; ((pPager.xBusyHandler(pPager.pBusyHandlerArg)) != 0));
    return (int)(rc);
}</function>
  <function>public static int pager_write(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    int rc = (int)(0);
    if ((pPager.eState) == (2))
    {
        rc = (int)(pager_open_journal(pPager));
        if (rc != 0)
            return (int)(rc);
    }

    sqlite3PcacheMakeDirty(pPg);
    if ((pPager.pInJournal != null) &amp;&amp; ((sqlite3BitvecTestNotNull(pPager.pInJournal, (uint)(pPg.pgno))) == (0)))
    {
        if ((pPg.pgno) &lt;= (pPager.dbOrigSize))
        {
            rc = (int)(pagerAddPageToRollbackJournal(pPg));
            if (rc != 0)
            {
                return (int)(rc);
            }
        }
        else
        {
            if (pPager.eState != 4)
            {
                pPg.flags |= (ushort)(0x008);
            }
        }
    }

    pPg.flags |= (ushort)(0x004);
    if ((pPager.nSavepoint) &gt; (0))
    {
        rc = (int)(subjournalPageIfRequired(pPg));
    }

    if ((pPager.dbSize) &lt; (pPg.pgno))
    {
        pPager.dbSize = (uint)(pPg.pgno);
    }

    return (int)(rc);
}</function>
  <function>public static void pager_write_changecounter(PgHdr pPg)
{
    uint change_counter = 0;
    if (((pPg) == (null)))
        return;
    change_counter = (uint)(sqlite3Get4byte((byte*)(pPg.pPager.dbFileVers)) + 1);
    sqlite3Put4byte((byte*)((sbyte*)(pPg.pData)) + 24, (uint)(change_counter));
    sqlite3Put4byte((byte*)((sbyte*)(pPg.pData)) + 92, (uint)(change_counter));
    sqlite3Put4byte((byte*)((sbyte*)(pPg.pData)) + 96, (uint)(3038002));
}</function>
  <function>public static int pager_write_pagelist(Pager pPager, PgHdr pList)
{
    int rc = (int)(0);
    if (!((pPager.fd).pMethods != null))
    {
        rc = (int)(pagerOpentemp(pPager, pPager.fd, (int)(pPager.vfsFlags)));
    }

    if ((((rc) == (0)) &amp;&amp; ((pPager.dbHintSize) &lt; (pPager.dbSize))) &amp;&amp; (((pList.pDirty) != null) || ((pList.pgno) &gt; (pPager.dbHintSize))))
    {
        long szFile = (long)(pPager.pageSize * (long)(pPager.dbSize));
        sqlite3OsFileControlHint(pPager.fd, (int)(5), &amp;szFile);
        pPager.dbHintSize = (uint)(pPager.dbSize);
    }

    while (((rc) == (0)) &amp;&amp; ((pList) != null))
    {
        uint pgno = (uint)(pList.pgno);
        if (((pgno) &lt;= (pPager.dbSize)) &amp;&amp; ((0) == (pList.flags &amp; 0x010)))
        {
            long offset = (long)((pgno - 1) * pPager.pageSize);
            sbyte* pData;
            if ((pList.pgno) == (1))
                pager_write_changecounter(pList);
            pData = pList.pData;
            rc = (int)(sqlite3OsWrite(pPager.fd, pData, (int)(pPager.pageSize), (long)(offset)));
            if ((pgno) == (1))
            {
                CRuntime.memcpy(&amp;pPager.dbFileVers, &amp;pData[24], (ulong)(16 * sizeof(sbyte)));
            }

            if ((pgno) &gt; (pPager.dbFileSize))
            {
                pPager.dbFileSize = (uint)(pgno);
            }

            pPager.aStat[2]++;
            sqlite3BackupUpdate(pPager.pBackup, (uint)(pgno), (byte*)(pList.pData));
        }
        else
        {
        }

        pList = pList.pDirty;
    }

    return (int)(rc);
}</function>
  <function>public static int pagerAcquireMapPage(Pager pPager, uint pgno, void* pData, PgHdr ppPage)
{
    PgHdr p;
    if ((pPager.pMmapFreelist) != null)
    {
        ppPage = p = pPager.pMmapFreelist;
        pPager.pMmapFreelist = p.pDirty;
        p.pDirty = null;
        CRuntime.memset(p.pExtra, (int)(0), (ulong)(8));
    }
    else
    {
        ppPage = p = (PgHdr)(sqlite3MallocZero((ulong)(sizeof(PgHdr) + pPager.nExtra)));
        if ((p) == (null))
        {
            sqlite3OsUnfetch(pPager.fd, (long)((long)(pgno - 1) * pPager.pageSize), pData);
            return (int)(7);
        }

        p.pExtra = (void*)(p[1]);
        p.flags = (ushort)(0x020);
        p.nRef = (short)(1);
        p.pPager = pPager;
    }

    p.pgno = (uint)(pgno);
    p.pData = pData;
    pPager.nMmapOut++;
    return (int)(0);
}</function>
  <function>public static int pagerAddPageToRollbackJournal(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    int rc = 0;
    uint cksum = 0;
    sbyte* pData2;
    long iOff = (long)(pPager.journalOff);
    pData2 = pPg.pData;
    cksum = (uint)(pager_cksum(pPager, (byte*)(pData2)));
    pPg.flags |= (ushort)(0x008);
    rc = (int)(write32bits(pPager.jfd, (long)(iOff), (uint)(pPg.pgno)));
    if (rc != 0)
        return (int)(rc);
    rc = (int)(sqlite3OsWrite(pPager.jfd, pData2, (int)(pPager.pageSize), (long)(iOff + 4)));
    if (rc != 0)
        return (int)(rc);
    rc = (int)(write32bits(pPager.jfd, (long)(iOff + pPager.pageSize + 4), (uint)(cksum)));
    if (rc != 0)
        return (int)(rc);
    pPager.journalOff += (long)(8 + pPager.pageSize);
    pPager.nRec++;
    rc = (int)(sqlite3BitvecSet(pPager.pInJournal, (uint)(pPg.pgno)));
    rc |= (int)(addToSavepointBitvecs(pPager, (uint)(pPg.pgno)));
    return (int)(rc);
}</function>
  <function>public static int pagerBeginReadTransaction(Pager pPager)
{
    int rc = 0;
    int changed = (int)(0);
    sqlite3WalEndReadTransaction(pPager.pWal);
    rc = (int)(sqlite3WalBeginReadTransaction(pPager.pWal, &amp;changed));
    if ((rc != 0) || ((changed) != 0))
    {
        pager_reset(pPager);
        if (((pPager).bUseFetch) != 0)
            sqlite3OsUnfetch(pPager.fd, (long)(0), null);
    }

    return (int)(rc);
}</function>
  <function>public static void pageReinit(PgHdr pData)
{
    MemPage pPage;
    pPage = (MemPage)(sqlite3PagerGetExtra(pData));
    if ((pPage.isInit) != 0)
    {
        pPage.isInit = (byte)(0);
        if ((sqlite3PagerPageRefcount(pData)) &gt; (1))
        {
            btreeInitPage(pPage);
        }
    }
}</function>
  <function>public static int pagerExclusiveLock(Pager pPager)
{
    int rc = 0;
    rc = (int)(pagerLockDb(pPager, (int)(4)));
    if (rc != 0)
    {
        pagerUnlockDb(pPager, (int)(1));
    }

    return (int)(rc);
}</function>
  <function>public static void pagerFixMaplimit(Pager pPager)
{
    sqlite3_file fd = pPager.fd;
    if (((fd).pMethods != null) &amp;&amp; ((fd.pMethods.iVersion) &gt;= (3)))
    {
        long sz = 0;
        sz = (long)(pPager.szMmap);
        pPager.bUseFetch = (byte)((sz) &gt; (0));
        setGetterMethod(pPager);
        sqlite3OsFileControlHint(pPager.fd, (int)(18), &amp;sz);
    }
}</function>
  <function>public static int pagerFlushOnCommit(Pager pPager, int bCommit)
{
    if ((pPager.tempFile) == (0))
        return (int)(1);
    if (bCommit == 0)
        return (int)(0);
    if (!((pPager.fd).pMethods != null))
        return (int)(0);
    return (((sqlite3PCachePercentDirty(pPager.pPCache)) &gt;= (25)) ? 1 : 0);
}</function>
  <function>public static void pagerFreeMapHdrs(Pager pPager)
{
    PgHdr p;
    PgHdr pNext;
    for (p = pPager.pMmapFreelist; p; p = pNext)
    {
        pNext = p.pDirty;
        sqlite3_free(p);
    }
}</function>
  <function>public static int pagerLockDb(Pager pPager, int eLock)
{
    int rc = (int)(0);
    if (((pPager.eLock) &lt; (eLock)) || ((pPager.eLock) == (4 + 1)))
    {
        rc = (int)((pPager.noLock) != 0 ? 0 : sqlite3OsLock(pPager.fd, (int)(eLock)));
        if (((rc) == (0)) &amp;&amp; ((pPager.eLock != (4 + 1)) || ((eLock) == (4))))
        {
            pPager.eLock = ((byte)(eLock));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int pagerOpenSavepoint(Pager pPager, int nSavepoint)
{
    int rc = (int)(0);
    int nCurrent = (int)(pPager.nSavepoint);
    int ii = 0;
    PagerSavepoint* aNew;
    aNew = (PagerSavepoint*)(sqlite3Realloc(pPager.aSavepoint, (ulong)(sizeof(PagerSavepoint) * nSavepoint)));
    if (aNew == null)
    {
        return (int)(7);
    }

    CRuntime.memset(&amp;aNew[nCurrent], (int)(0), (ulong)((nSavepoint - nCurrent) * sizeof(PagerSavepoint)));
    pPager.aSavepoint = aNew;
    for (ii = (int)(nCurrent); (ii) &lt; (nSavepoint); ii++)
    {
        aNew[ii].nOrig = (uint)(pPager.dbSize);
        if (((pPager.jfd).pMethods != null) &amp;&amp; ((pPager.journalOff) &gt; (0)))
        {
            aNew[ii].iOffset = (long)(pPager.journalOff);
        }
        else
        {
            aNew[ii].iOffset = (long)(pPager.sectorSize);
        }

        aNew[ii].iSubRec = (uint)(pPager.nSubRec);
        aNew[ii].pInSavepoint = sqlite3BitvecCreate((uint)(pPager.dbSize));
        aNew[ii].bTruncateOnRelease = (int)(1);
        if (aNew[ii].pInSavepoint == null)
        {
            return (int)(7);
        }

        if (((pPager).pWal != null))
        {
            sqlite3WalSavepoint(pPager.pWal, aNew[ii].aWalData);
        }

        pPager.nSavepoint = (int)(ii + 1);
    }

    return (int)(rc);
}</function>
  <function>public static int pagerOpentemp(Pager pPager, sqlite3_file pFile, int vfsFlags)
{
    int rc = 0;
    vfsFlags |= (int)(0x00000002 | 0x00000004 | 0x00000010 | 0x00000008);
    rc = (int)(sqlite3OsOpen(pPager.pVfs, null, pFile, (int)(vfsFlags), null));
    return (int)(rc);
}</function>
  <function>public static int pagerOpenWal(Pager pPager)
{
    int rc = (int)(0);
    if ((pPager.exclusiveMode) != 0)
    {
        rc = (int)(pagerExclusiveLock(pPager));
    }

    if ((rc) == (0))
    {
        rc = (int)(sqlite3WalOpen(pPager.pVfs, pPager.fd, pPager.zWal, (int)(pPager.exclusiveMode), (long)(pPager.journalSizeLimit), pPager.pWal));
    }

    pagerFixMaplimit(pPager);
    return (int)(rc);
}</function>
  <function>public static int pagerOpenWalIfPresent(Pager pPager)
{
    int rc = (int)(0);
    if (pPager.tempFile == 0)
    {
        int isWal = 0;
        rc = (int)(sqlite3OsAccess(pPager.pVfs, pPager.zWal, (int)(0), &amp;isWal));
        if ((rc) == (0))
        {
            if ((isWal) != 0)
            {
                uint nPage = 0;
                rc = (int)(pagerPagecount(pPager, &amp;nPage));
                if ((rc) != 0)
                    return (int)(rc);
                if ((nPage) == (0))
                {
                    rc = (int)(sqlite3OsDelete(pPager.pVfs, pPager.zWal, (int)(0)));
                }
                else
                {
                    rc = (int)(sqlite3PagerOpenWal(pPager, null));
                }
            }
            else if ((pPager.journalMode) == (5))
            {
                pPager.journalMode = (byte)(0);
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static int pagerPagecount(Pager pPager, uint* pnPage)
{
    uint nPage = 0;
    nPage = (uint)(sqlite3WalDbsize(pPager.pWal));
    if (((nPage) == (0)) &amp;&amp; (((pPager.fd).pMethods != null) != 0))
    {
        long n = (long)(0);
        int rc = (int)(sqlite3OsFileSize(pPager.fd, &amp;n));
        if (rc != 0)
        {
            return (int)(rc);
        }

        nPage = ((uint)((n + pPager.pageSize - 1) / pPager.pageSize));
    }

    if ((nPage) &gt; (pPager.mxPgno))
    {
        pPager.mxPgno = (uint)(nPage);
    }

    *pnPage = (uint)(nPage);
    return (int)(0);
}</function>
  <function>public static int pagerPlaybackSavepoint(Pager pPager, PagerSavepoint* pSavepoint)
{
    long szJ = 0;
    long iHdrOff = 0;
    int rc = (int)(0);
    Bitvec* pDone = null;
    if ((pSavepoint) != null)
    {
        pDone = sqlite3BitvecCreate((uint)(pSavepoint-&gt;nOrig));
        if (pDone == null)
        {
            return (int)(7);
        }
    }

    pPager.dbSize = (uint)(pSavepoint ? pSavepoint-&gt;nOrig : pPager.dbOrigSize);
    pPager.changeCountDone = (byte)(pPager.tempFile);
    if ((pSavepoint == null) &amp;&amp; ((pPager).pWal != null))
    {
        return (int)(pagerRollbackWal(pPager));
    }

    szJ = (long)(pPager.journalOff);
    if (((pSavepoint) != null) &amp;&amp; (!((pPager).pWal != null)))
    {
        iHdrOff = (long)((pSavepoint-&gt;iHdrOffset) != 0 ? pSavepoint-&gt;iHdrOffset : szJ);
        pPager.journalOff = (long)(pSavepoint-&gt;iOffset);
        while (((rc) == (0)) &amp;&amp; ((pPager.journalOff) &lt; (iHdrOff)))
        {
            rc = (int)(pager_playback_one_page(pPager, &amp;pPager.journalOff, pDone, (int)(1), (int)(1)));
        }
    }
    else
    {
        pPager.journalOff = (long)(0);
    }

    while (((rc) == (0)) &amp;&amp; ((pPager.journalOff) &lt; (szJ)))
    {
        uint ii = 0;
        uint nJRec = (uint)(0);
        uint dummy = 0;
        rc = (int)(readJournalHdr(pPager, (int)(0), (long)(szJ), &amp;nJRec, &amp;dummy));
        if (((nJRec) == (0)) &amp;&amp; ((pPager.journalHdr + (pPager.sectorSize)) == (pPager.journalOff)))
        {
            nJRec = ((uint)((szJ - pPager.journalOff) / ((pPager.pageSize) + 8)));
        }

        for (ii = (uint)(0); (((rc) == (0)) &amp;&amp; ((ii) &lt; (nJRec))) &amp;&amp; ((pPager.journalOff) &lt; (szJ)); ii++)
        {
            rc = (int)(pager_playback_one_page(pPager, &amp;pPager.journalOff, pDone, (int)(1), (int)(1)));
        }
    }

    if ((pSavepoint) != null)
    {
        uint ii = 0;
        long offset = (long)((long)(pSavepoint-&gt;iSubRec) * (4 + pPager.pageSize));
        if (((pPager).pWal != null))
        {
            rc = (int)(sqlite3WalSavepointUndo(pPager.pWal, pSavepoint-&gt;aWalData));
        }

        for (ii = (uint)(pSavepoint-&gt;iSubRec); ((rc) == (0)) &amp;&amp; ((ii) &lt; (pPager.nSubRec)); ii++)
        {
            rc = (int)(pager_playback_one_page(pPager, &amp;offset, pDone, (int)(0), (int)(1)));
        }
    }

    sqlite3BitvecDestroy(pDone);
    if ((rc) == (0))
    {
        pPager.journalOff = (long)(szJ);
    }

    return (int)(rc);
}</function>
  <function>public static void pagerReleaseMapPage(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    pPager.nMmapOut--;
    pPg.pDirty = pPager.pMmapFreelist;
    pPager.pMmapFreelist = pPg;
    sqlite3OsUnfetch(pPager.fd, (long)((long)(pPg.pgno - 1) * pPager.pageSize), pPg.pData);
}</function>
  <function>public static int pagerRollbackWal(Pager pPager)
{
    int rc = 0;
    PgHdr pList;
    pPager.dbSize = (uint)(pPager.dbOrigSize);
    rc = (int)(sqlite3WalUndo(pPager.pWal, pagerUndoCallback, (void*)(pPager)));
    pList = sqlite3PcacheDirtyList(pPager.pPCache);
    while (((pList) != null) &amp;&amp; ((rc) == (0)))
    {
        PgHdr pNext = pList.pDirty;
        rc = (int)(pagerUndoCallback((void*)(pPager), (uint)(pList.pgno)));
        pList = pNext;
    }

    return (int)(rc);
}</function>
  <function>public static int pagerStress(void* p, PgHdr pPg)
{
    Pager pPager = (Pager)(p);
    int rc = (int)(0);
    if ((pPager.errCode) != 0)
        return (int)(0);
    if (((pPager.doNotSpill) != 0) &amp;&amp; (((pPager.doNotSpill &amp; (0x02 | 0x01)) != 0) || ((pPg.flags &amp; 0x008) != 0)))
    {
        return (int)(0);
    }

    pPager.aStat[3]++;
    pPg.pDirty = null;
    if (((pPager).pWal != null))
    {
        rc = (int)(subjournalPageIfRequired(pPg));
        if ((rc) == (0))
        {
            rc = (int)(pagerWalFrames(pPager, pPg, (uint)(0), (int)(0)));
        }
    }
    else
    {
        if (((pPg.flags &amp; 0x008) != 0) || ((pPager.eState) == (3)))
        {
            rc = (int)(syncJournal(pPager, (int)(1)));
        }

        if ((rc) == (0))
        {
            rc = (int)(pager_write_pagelist(pPager, pPg));
        }
    }

    if ((rc) == (0))
    {
        sqlite3PcacheMakeClean(pPg);
    }

    return (int)(pager_error(pPager, (int)(rc)));
}</function>
  <function>public static int pagerSyncHotJournal(Pager pPager)
{
    int rc = (int)(0);
    if (pPager.noSync == 0)
    {
        rc = (int)(sqlite3OsSync(pPager.jfd, (int)(0x00002)));
    }

    if ((rc) == (0))
    {
        rc = (int)(sqlite3OsFileSize(pPager.jfd, &amp;pPager.journalHdr));
    }

    return (int)(rc);
}</function>
  <function>public static int pagerUndoCallback(void* pCtx, uint iPg)
{
    int rc = (int)(0);
    Pager pPager = (Pager)(pCtx);
    PgHdr pPg;
    pPg = sqlite3PagerLookup(pPager, (uint)(iPg));
    if ((pPg) != null)
    {
        if ((sqlite3PcachePageRefcount(pPg)) == (1))
        {
            sqlite3PcacheDrop(pPg);
        }
        else
        {
            rc = (int)(readDbPage(pPg));
            if ((rc) == (0))
            {
                pPager.xReiniter(pPg);
            }

            sqlite3PagerUnrefNotNull(pPg);
        }
    }

    sqlite3BackupRestart(pPager.pBackup);
    return (int)(rc);
}</function>
  <function>public static void pagerUnlockAndRollback(Pager pPager)
{
    if ((pPager.eState != 6) &amp;&amp; (pPager.eState != 0))
    {
        if ((pPager.eState) &gt;= (2))
        {
            sqlite3BeginBenignMalloc();
            sqlite3PagerRollback(pPager);
            sqlite3EndBenignMalloc();
        }
        else if (pPager.exclusiveMode == 0)
        {
            pager_end_transaction(pPager, (int)(0), (int)(0));
        }
    }

    pager_unlock(pPager);
}</function>
  <function>public static int pagerUnlockDb(Pager pPager, int eLock)
{
    int rc = (int)(0);
    if (((pPager.fd).pMethods != null))
    {
        rc = (int)((pPager.noLock) != 0 ? 0 : sqlite3OsUnlock(pPager.fd, (int)(eLock)));
        if (pPager.eLock != (4 + 1))
        {
            pPager.eLock = ((byte)(eLock));
        }
    }

    pPager.changeCountDone = (byte)(pPager.tempFile);
    return (int)(rc);
}</function>
  <function>public static void pagerUnlockIfUnused(Pager pPager)
{
    if ((sqlite3PcacheRefCount(pPager.pPCache)) == (0))
    {
        pagerUnlockAndRollback(pPager);
    }
}</function>
  <function>public static int pagerWalFrames(Pager pPager, PgHdr pList, uint nTruncate, int isCommit)
{
    int rc = 0;
    int nList = 0;
    PgHdr p;
    if ((isCommit) != 0)
    {
        PgHdr ppNext = pList;
        nList = (int)(0);
        for (p = pList; (ppNext = p) != null; p = p.pDirty)
        {
            if ((p.pgno) &lt;= (nTruncate))
            {
                ppNext = p.pDirty;
                nList++;
            }
        }
    }
    else
    {
        nList = (int)(1);
    }

    pPager.aStat[2] += (int)(nList);
    if ((pList.pgno) == (1))
        pager_write_changecounter(pList);
    rc = (int)(sqlite3WalFrames(pPager.pWal, (int)(pPager.pageSize), pList, (uint)(nTruncate), (int)(isCommit), (int)(pPager.walSyncFlags)));
    if (((rc) == (0)) &amp;&amp; ((pPager.pBackup) != null))
    {
        for (p = pList; p; p = p.pDirty)
        {
            sqlite3BackupUpdate(pPager.pBackup, (uint)(p.pgno), (byte*)(p.pData));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int pagerWriteLargeSector(PgHdr pPg)
{
    int rc = (int)(0);
    uint nPageCount = 0;
    uint pg1 = 0;
    int nPage = (int)(0);
    int ii = 0;
    int needSync = (int)(0);
    Pager pPager = pPg.pPager;
    uint nPagePerSector = (uint)(pPager.sectorSize / pPager.pageSize);
    pPager.doNotSpill |= (byte)(0x04);
    pg1 = (uint)(((pPg.pgno - 1) &amp; ~(nPagePerSector - 1)) + 1);
    nPageCount = (uint)(pPager.dbSize);
    if ((pPg.pgno) &gt; (nPageCount))
    {
        nPage = (int)((pPg.pgno - pg1) + 1);
    }
    else if ((pg1 + nPagePerSector - 1) &gt; (nPageCount))
    {
        nPage = (int)(nPageCount + 1 - pg1);
    }
    else
    {
        nPage = (int)(nPagePerSector);
    }

    for (ii = (int)(0); ((ii) &lt; (nPage)) &amp;&amp; ((rc) == (0)); ii++)
    {
        uint pg = (uint)(pg1 + ii);
        PgHdr pPage;
        if (((pg) == (pPg.pgno)) || (sqlite3BitvecTest(pPager.pInJournal, (uint)(pg)) == 0))
        {
            if (pg != ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1)))
            {
                rc = (int)(sqlite3PagerGet(pPager, (uint)(pg), pPage, (int)(0)));
                if ((rc) == (0))
                {
                    rc = (int)(pager_write(pPage));
                    if ((pPage.flags &amp; 0x008) != 0)
                    {
                        needSync = (int)(1);
                    }

                    sqlite3PagerUnrefNotNull(pPage);
                }
            }
        }
        else if ((pPage = sqlite3PagerLookup(pPager, (uint)(pg))) != null)
        {
            if ((pPage.flags &amp; 0x008) != 0)
            {
                needSync = (int)(1);
            }

            sqlite3PagerUnrefNotNull(pPage);
        }
    }

    if (((rc) == (0)) &amp;&amp; ((needSync) != 0))
    {
        for (ii = (int)(0); (ii) &lt; (nPage); ii++)
        {
            PgHdr pPage = sqlite3PagerLookup(pPager, (uint)(pg1 + ii));
            if ((pPage) != null)
            {
                pPage.flags |= (ushort)(0x008);
                sqlite3PagerUnrefNotNull(pPage);
            }
        }
    }

    pPager.doNotSpill &amp;= (byte)(~0x04);
    return (int)(rc);
}</function>
  <function>public static int parseDateOrTime(sqlite3_context context, sbyte* zDate, DateTime* p)
{
    double r = 0;
    if ((parseYyyyMmDd(zDate, p)) == (0))
    {
        return (int)(0);
    }
    else if ((parseHhMmSs(zDate, p)) == (0))
    {
        return (int)(0);
    }
    else if (((sqlite3StrICmp(zDate, "now")) == (0)) &amp;&amp; ((sqlite3NotPureFunc(context)) != 0))
    {
        return (int)(setDateTimeToCurrent(context, p));
    }
    else if ((sqlite3AtoF(zDate, &amp;r, (int)(sqlite3Strlen30(zDate)), (byte)(1))) &gt; (0))
    {
        setRawDateNumber(p, (double)(r));
        return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static int parseHhMmSs(sbyte* zDate, DateTime* p)
{
    int h = 0; int  m  =  0 ;  int  s  =  0 ; 
    double ms = (double)(0.0);
    if (getDigits(zDate, "20c:20e", &amp;h, &amp;m) != 2)
    {
        return (int)(1);
    }

    zDate += 5;
    if ((*zDate) == (58))
    {
        zDate++;
        if (getDigits(zDate, "20e", &amp;s) != 1)
        {
            return (int)(1);
        }

        zDate += 2;
        if (((*zDate) == (46)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zDate[1])] &amp; 0x04) != 0))
        {
            double rScale = (double)(1.0);
            zDate++;
            while ((sqlite3CtypeMap[(byte)(*zDate)] &amp; 0x04) != 0)
            {
                ms = (double)(ms * 10.0 + *zDate - 48);
                rScale *= (double)(10.0);
                zDate++;
            }

            ms /= (double)(rScale);
        }
    }
    else
    {
        s = (int)(0);
    }

    p-&gt;validJD = (sbyte)(0);
    p-&gt;rawS = (sbyte)(0);
    p-&gt;validHMS = (sbyte)(1);
    p-&gt;h = (int)(h);
    p-&gt;m = (int)(m);
    p-&gt;s = (double)(s + ms);
    if ((parseTimezone(zDate, p)) != 0)
        return (int)(1);
    p-&gt;validTZ = (sbyte)((p-&gt;tz != 0) ? 1 : 0);
    return (int)(0);
}</function>
  <function>public static int parseModifier(sqlite3_context pCtx, sbyte* z, int n, DateTime* p, int idx)
{
    int rc = (int)(1);
    double r = 0;
    switch (sqlite3UpperToLower[(byte)(z[0])])
    {
        case 97:
        {
            if ((sqlite3_stricmp(z, "auto")) == (0))
            {
                if ((idx) &gt; (1))
                    return (int)(1);
                if ((p-&gt;rawS == 0) || ((p-&gt;validJD) != 0))
                {
                    rc = (int)(0);
                    p-&gt;rawS = (sbyte)(0);
                }
                else if (((p-&gt;s) &gt;= (-21086676 * (long)(10000))) &amp;&amp; ((p-&gt;s) &lt;= ((25340230 * (long)(10000)) + 799)))
                {
                    r = (double)(p-&gt;s * 1000.0 + 210866760000000.0);
                    clearYMD_HMS_TZ(p);
                    p-&gt;iJD = ((long)(r + 0.5));
                    p-&gt;validJD = (sbyte)(1);
                    p-&gt;rawS = (sbyte)(0);
                    rc = (int)(0);
                }
            }

            break;
        }

        case 106:
        {
            if ((sqlite3_stricmp(z, "julianday")) == (0))
            {
                if ((idx) &gt; (1))
                    return (int)(1);
                if (((p-&gt;validJD) != 0) &amp;&amp; ((p-&gt;rawS) != 0))
                {
                    rc = (int)(0);
                    p-&gt;rawS = (sbyte)(0);
                }
            }

            break;
        }

        case 108:
        {
            if (((sqlite3_stricmp(z, "localtime")) == (0)) &amp;&amp; ((sqlite3NotPureFunc(pCtx)) != 0))
            {
                rc = (int)(toLocaltime(p, pCtx));
            }

            break;
        }

        case 117:
        {
            if (((sqlite3_stricmp(z, "unixepoch")) == (0)) &amp;&amp; ((p-&gt;rawS) != 0))
            {
                if ((idx) &gt; (1))
                    return (int)(1);
                r = (double)(p-&gt;s * 1000.0 + 210866760000000.0);
                if (((r) &gt;= (0.0)) &amp;&amp; ((r) &lt; (464269060800000.0)))
                {
                    clearYMD_HMS_TZ(p);
                    p-&gt;iJD = ((long)(r + 0.5));
                    p-&gt;validJD = (sbyte)(1);
                    p-&gt;rawS = (sbyte)(0);
                    rc = (int)(0);
                }
            }
            else if (((sqlite3_stricmp(z, "utc")) == (0)) &amp;&amp; ((sqlite3NotPureFunc(pCtx)) != 0))
            {
                if ((p-&gt;tzSet) == (0))
                {
                    long iOrigJD = 0;
                    long iGuess = 0;
                    int cnt = (int)(0);
                    int iErr = 0;
                    computeJD(p);
                    iGuess = (long)(iOrigJD = (long)(p-&gt;iJD));
                    iErr = (int)(0);
                    do
                    {
                        DateTime new = new DateTime();
                        CRuntime.memset(&amp;new, (int)(0), (ulong)(sizeof(DateTime)));
                        iGuess -= (long)(iErr);
                        new.iJD = (long)(iGuess);
                        new.validJD = (sbyte)(1);
                        rc = (int)(toLocaltime(&amp;new, pCtx));
                        if ((rc) != 0)
                            return (int)(rc);
                        computeJD(&amp;new);
                        iErr = (int)(new.iJD - iOrigJD);
                    }
                    while (((iErr) != 0) &amp;&amp; ((cnt++) &lt; (3)));
                    CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
                    p-&gt;iJD = (long)(iGuess);
                    p-&gt;validJD = (sbyte)(1);
                    p-&gt;tzSet = (sbyte)(1);
                }

                rc = (int)(0);
            }

            break;
        }

        case 119:
        {
            if ((((((sqlite3_strnicmp(z, "weekday ", (int)(8))) == (0)) &amp;&amp; ((sqlite3AtoF(&amp;z[8], &amp;r, (int)(sqlite3Strlen30(&amp;z[8])), (byte)(1))) &gt; (0))) &amp;&amp; ((n = ((int)(r))) == (r))) &amp;&amp; ((n) &gt;= (0))) &amp;&amp; ((r) &lt; (7)))
            {
                long Z = 0;
                computeYMD_HMS(p);
                p-&gt;validTZ = (sbyte)(0);
                p-&gt;validJD = (sbyte)(0);
                computeJD(p);
                Z = (long)(((p-&gt;iJD + 129600000) / 86400000) % 7);
                if ((Z) &gt; (n))
                    Z -= (long)(7);
                p-&gt;iJD += (long)((n - Z) * 86400000);
                clearYMD_HMS_TZ(p);
                rc = (int)(0);
            }

            break;
        }

        case 115:
        {
            if (sqlite3_strnicmp(z, "start of ", (int)(9)) != 0)
                break;
            if (((p-&gt;validJD == 0) &amp;&amp; (p-&gt;validYMD == 0)) &amp;&amp; (p-&gt;validHMS == 0))
                break;
            z += 9;
            computeYMD(p);
            p-&gt;validHMS = (sbyte)(1);
            p-&gt;h = (int)(p-&gt;m = (int)(0));
            p-&gt;s = (double)(0.0);
            p-&gt;rawS = (sbyte)(0);
            p-&gt;validTZ = (sbyte)(0);
            p-&gt;validJD = (sbyte)(0);
            if ((sqlite3_stricmp(z, "month")) == (0))
            {
                p-&gt;D = (int)(1);
                rc = (int)(0);
            }
            else if ((sqlite3_stricmp(z, "year")) == (0))
            {
                p-&gt;M = (int)(1);
                p-&gt;D = (int)(1);
                rc = (int)(0);
            }
            else if ((sqlite3_stricmp(z, "day")) == (0))
            {
                rc = (int)(0);
            }

            break;
        }

        case 43:
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        {
            double rRounder = 0;
            int i = 0;
            for (n = (int)(1); (((z[n]) != 0) &amp;&amp; (z[n] != 58)) &amp;&amp; ((sqlite3CtypeMap[(byte)(z[n])] &amp; 0x01) == 0); n++)
            {
            }

            if ((sqlite3AtoF(z, &amp;r, (int)(n), (byte)(1))) &lt;= (0))
            {
                rc = (int)(1);
                break;
            }

            if ((z[n]) == (58))
            {
                sbyte* z2 = z;
                DateTime tx = new DateTime();
                long day = 0;
                if ((sqlite3CtypeMap[(byte)(*z2)] &amp; 0x04) == 0)
                    z2++;
                CRuntime.memset(&amp;tx, (int)(0), (ulong)(sizeof(DateTime)));
                if ((parseHhMmSs(z2, &amp;tx)) != 0)
                    break;
                computeJD(&amp;tx);
                tx.iJD -= (long)(43200000);
                day = (long)(tx.iJD / 86400000);
                tx.iJD -= (long)(day * 86400000);
                if ((z[0]) == (45))
                    tx.iJD = (long)(-tx.iJD);
                computeJD(p);
                clearYMD_HMS_TZ(p);
                p-&gt;iJD += (long)(tx.iJD);
                rc = (int)(0);
                break;
            }

            z += n;
            while ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x01) != 0)
            {
                z++;
            }

            n = (int)(sqlite3Strlen30(z));
            if (((n) &gt; (10)) || ((n) &lt; (3)))
                break;
            if ((sqlite3UpperToLower[(byte)(z[n - 1])]) == (115))
                n--;
            computeJD(p);
            rc = (int)(1);
            rRounder = (double)((r) &lt; (0) ? -0.5 : +0.5);
            for (i = (int)(0); (i) &lt; ((int)(6 * sizeof(aXformTypeDef) / sizeof(aXformTypeDef))); i++)
            {
                if (((((aXformType[i].nName) == (n)) &amp;&amp; ((sqlite3_strnicmp(aXformType[i].zName, z, (int)(n))) == (0))) &amp;&amp; ((r) &gt; (-aXformType[i].rLimit))) &amp;&amp; ((r) &lt; (aXformType[i].rLimit)))
                {
                    switch (i)
                    {
                        case 4:
                        {
                            int x = 0;
                            computeYMD_HMS(p);
                            p-&gt;M += ((int)(r));
                            x = (int)((p-&gt;M) &gt; (0) ? (p-&gt;M - 1) / 12 : (p-&gt;M - 12) / 12);
                            p-&gt;Y += (int)(x);
                            p-&gt;M -= (int)(x * 12);
                            p-&gt;validJD = (sbyte)(0);
                            r -= (double)((int)(r));
                            break;
                        }

                        case 5:
                        {
                            int y = (int)(r);
                            computeYMD_HMS(p);
                            p-&gt;Y += (int)(y);
                            p-&gt;validJD = (sbyte)(0);
                            r -= (double)((int)(r));
                            break;
                        }
                    }

                    computeJD(p);
                    p-&gt;iJD += ((long)(r * 1000.0 * aXformType[i].rXform + rRounder));
                    rc = (int)(0);
                    break;
                }
            }

            clearYMD_HMS_TZ(p);
            break;
        }

        default:
        {
            break;
        }
    }

    return (int)(rc);
}</function>
  <function>public static ExprList parserAddExprIdListTerm(Parse pParse, ExprList pPrior, Token* pIdToken, int hasCollate, int sortOrder)
{
    ExprList p = sqlite3ExprListAppend(pParse, pPrior, null);
    if ((((hasCollate) != 0) || (sortOrder != -1)) &amp;&amp; ((pParse.db.init.busy) == (0)))
    {
        sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"", (uint)(pIdToken-&gt;n), pIdToken-&gt;z);
    }

    sqlite3ExprListSetName(pParse, p, pIdToken, (int)(1));
    return p;
}</function>
  <function>public static void parserDoubleLinkSelect(Parse pParse, Select p)
{
    if ((p.pPrior) != null)
    {
        Select pNext = null;
        Select pLoop = p;
        int mxSelect = 0;
        int cnt = (int)(1);
        while ((1) != 0)
        {
            pLoop.pNext = pNext;
            pLoop.selFlags |= (uint)(0x0000100);
            pNext = pLoop;
            pLoop = pLoop.pPrior;
            if ((pLoop) == (null))
                break;
            cnt++;
            if (((pLoop.pOrderBy) != null) || ((pLoop.pLimit) != null))
            {
                sqlite3ErrorMsg(pParse, "%s clause should come after %s not before", pLoop.pOrderBy != null ? "ORDER BY" : "LIMIT", sqlite3SelectOpName((int)(pNext.op)));
                break;
            }
        }

        if ((((p.selFlags &amp; 0x0000400) == (0)) &amp;&amp; ((mxSelect = (int)(pParse.db.aLimit[4])) &gt; (0))) &amp;&amp; ((cnt) &gt; (mxSelect)))
        {
            sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
        }
    }
}</function>
  <function>public static int parseTimezone(sbyte* zDate, DateTime* p)
{
    int sgn = (int)(0);
    int nHr = 0; int  nMn  =  0 ; 
    int c = 0;
    while ((sqlite3CtypeMap[(byte)(*zDate)] &amp; 0x01) != 0)
    {
        zDate++;
    }

    p-&gt;tz = (int)(0);
    c = (int)(*zDate);
    if ((c) == (45))
    {
        sgn = (int)(-1);
    }
    else if ((c) == (43))
    {
        sgn = (int)(+1);
    }
    else if (((c) == (90)) || ((c) == (122)))
    {
        zDate++;
        goto zulu_time;
    }
    else
    {
        return (int)(c != 0);
    }

    zDate++;
    if (getDigits(zDate, "20b:20e", &amp;nHr, &amp;nMn) != 2)
    {
        return (int)(1);
    }

    zDate += 5;
    p-&gt;tz = (int)(sgn * (nMn + nHr * 60));
    zulu_time:
        ; while  ( ( sqlite3CtypeMap [ ( byte ) ( * zDate ) ] &amp; 0x01 ) != 0 ) { zDate ++ ;  }
    p-&gt;tzSet = (sbyte)(1);
    return (int)(*zDate != 0);
}</function>
  <function>public static int parseYyyyMmDd(sbyte* zDate, DateTime* p)
{
    int Y = 0; int  M  =  0 ;  int  D  =  0 ;  int  neg  =  0 ; 
    if ((zDate[0]) == (45))
    {
        zDate++;
        neg = (int)(1);
    }
    else
    {
        neg = (int)(0);
    }

    if (getDigits(zDate, "40f-21a-21d", &amp;Y, &amp;M, &amp;D) != 3)
    {
        return (int)(1);
    }

    zDate += 10;
    while (((sqlite3CtypeMap[(byte)(*zDate)] &amp; 0x01) != 0) || ((84) == (*(byte*)(zDate))))
    {
        zDate++;
    }

    if ((parseHhMmSs(zDate, p)) == (0))
    {
    }
    else if ((*zDate) == (0))
    {
        p-&gt;validHMS = (sbyte)(0);
    }
    else
    {
        return (int)(1);
    }

    p-&gt;validJD = (sbyte)(0);
    p-&gt;validYMD = (sbyte)(1);
    p-&gt;Y = (int)((neg) != 0 ? -Y : Y);
    p-&gt;M = (int)(M);
    p-&gt;D = (int)(D);
    if ((p-&gt;validTZ) != 0)
    {
        computeJD(p);
    }

    return (int)(0);
}</function>
  <function>public static int patternCompare(byte* zPattern, byte* zString, compareInfo* pInfo, uint matchOther)
{
    uint c = 0; uint  c2  =  0 ; 
    uint matchOne = (uint)(pInfo-&gt;matchOne);
    uint matchAll = (uint)(pInfo-&gt;matchAll);
    byte noCase = (byte)(pInfo-&gt;noCase);
    byte* zEscaped = null;
    while ((c = (uint)((zPattern[0]) &lt; (0x80) ? *(zPattern++) : sqlite3Utf8Read(&amp;zPattern))) != 0)
    {
        if ((c) == (matchAll))
        {
            while (((c = (uint)((zPattern[0]) &lt; (0x80) ? *(zPattern++) : sqlite3Utf8Read(&amp;zPattern))) == (matchAll)) || (((c) == (matchOne)) &amp;&amp; (matchOne != 0)))
            {
                if (((c) == (matchOne)) &amp;&amp; ((sqlite3Utf8Read(&amp;zString)) == (0)))
                {
                    return (int)(2);
                }
            }

            if ((c) == (0))
            {
                return (int)(0);
            }
            else if ((c) == (matchOther))
            {
                if ((pInfo-&gt;matchSet) == (0))
                {
                    c = (uint)(sqlite3Utf8Read(&amp;zPattern));
                    if ((c) == (0))
                        return (int)(2);
                }
                else
                {
                    while ((*zString) != 0)
                    {
                        int bMatch = (int)(patternCompare(&amp;zPattern[-1], zString, pInfo, (uint)(matchOther)));
                        if (bMatch != 1)
                            return (int)(bMatch);
                        {
                            if ((*(zString++)) &gt;= (0xc0))
                            {
                                while ((*zString &amp; 0xc0) == (0x80))
                                {
                                    zString++;
                                }
                            }
                        }
                    }

                    return (int)(2);
                }
            }

            if ((c) &lt;= (0x80))
            {
                sbyte* zStop = stackalloc sbyte[3];
                int bMatch = 0;
                if ((noCase) != 0)
                {
                    zStop[0] = (sbyte)((c) &amp; ~(sqlite3CtypeMap[(byte)(c)] &amp; 0x20));
                    zStop[1] = (sbyte)(sqlite3UpperToLower[(byte)(c)]);
                    zStop[2] = (sbyte)(0);
                }
                else
                {
                    zStop[0] = (sbyte)(c);
                    zStop[1] = (sbyte)(0);
                }

                while ((1) != 0)
                {
                    zString += strcspn((sbyte*)(zString), zStop);
                    if ((zString[0]) == (0))
                        break;
                    zString++;
                    bMatch = (int)(patternCompare(zPattern, zString, pInfo, (uint)(matchOther)));
                    if (bMatch != 1)
                        return (int)(bMatch);
                }
            }
            else
            {
                int bMatch = 0;
                while ((c2 = (uint)((zString[0]) &lt; (0x80) ? *(zString++) : sqlite3Utf8Read(&amp;zString))) != 0)
                {
                    if (c2 != c)
                        continue;
                    bMatch = (int)(patternCompare(zPattern, zString, pInfo, (uint)(matchOther)));
                    if (bMatch != 1)
                        return (int)(bMatch);
                }
            }

            return (int)(2);
        }

        if ((c) == (matchOther))
        {
            if ((pInfo-&gt;matchSet) == (0))
            {
                c = (uint)(sqlite3Utf8Read(&amp;zPattern));
                if ((c) == (0))
                    return (int)(1);
                zEscaped = zPattern;
            }
            else
            {
                uint prior_c = (uint)(0);
                int seen = (int)(0);
                int invert = (int)(0);
                c = (uint)(sqlite3Utf8Read(&amp;zString));
                if ((c) == (0))
                    return (int)(1);
                c2 = (uint)(sqlite3Utf8Read(&amp;zPattern));
                if ((c2) == (94))
                {
                    invert = (int)(1);
                    c2 = (uint)(sqlite3Utf8Read(&amp;zPattern));
                }

                if ((c2) == (93))
                {
                    if ((c) == (93))
                        seen = (int)(1);
                    c2 = (uint)(sqlite3Utf8Read(&amp;zPattern));
                }

                while (((c2) != 0) &amp;&amp; (c2 != 93))
                {
                    if (((((c2) == (45)) &amp;&amp; (zPattern[0] != 93)) &amp;&amp; (zPattern[0] != 0)) &amp;&amp; ((prior_c) &gt; (0)))
                    {
                        c2 = (uint)(sqlite3Utf8Read(&amp;zPattern));
                        if (((c) &gt;= (prior_c)) &amp;&amp; ((c) &lt;= (c2)))
                            seen = (int)(1);
                        prior_c = (uint)(0);
                    }
                    else
                    {
                        if ((c) == (c2))
                        {
                            seen = (int)(1);
                        }

                        prior_c = (uint)(c2);
                    }

                    c2 = (uint)(sqlite3Utf8Read(&amp;zPattern));
                }

                if (((c2) == (0)) || ((seen ^ invert) == (0)))
                {
                    return (int)(1);
                }

                continue;
            }
        }

        c2 = (uint)((zString[0]) &lt; (0x80) ? *(zString++) : sqlite3Utf8Read(&amp;zString));
        if ((c) == (c2))
            continue;
        if (((((noCase) != 0) &amp;&amp; ((sqlite3UpperToLower[(byte)(c)]) == (sqlite3UpperToLower[(byte)(c2)]))) &amp;&amp; ((c) &lt; (0x80))) &amp;&amp; ((c2) &lt; (0x80)))
        {
            continue;
        }

        if ((((c) == (matchOne)) &amp;&amp; (zPattern != zEscaped)) &amp;&amp; (c2 != 0))
            continue;
        return (int)(1);
    }

    return (int)((*zString) == (0) ? 0 : 1);
}</function>
  <function>public static void* pcache1Alloc(int nByte)
{
    void* p = null;
    if ((nByte) &lt;= ((pcache1_g).szSlot))
    {
        sqlite3_mutex_enter((pcache1_g).mutex);
        p = (PgHdr1*)((pcache1_g).pFree);
        if ((p) != null)
        {
            (pcache1_g).pFree = (pcache1_g).pFree-&gt;pNext;
            (pcache1_g).nFreeSlot--;
            (pcache1_g).bUnderPressure = (int)(((pcache1_g).nFreeSlot) &lt; ((pcache1_g).nReserve) ? 1 : 0);
            sqlite3StatusHighwater((int)(7), (int)(nByte));
            sqlite3StatusUp((int)(1), (int)(1));
        }

        sqlite3_mutex_leave((pcache1_g).mutex);
    }

    if ((p) == (null))
    {
        p = sqlite3Malloc((ulong)(nByte));
        if ((p) != null)
        {
            int sz = (int)(sqlite3MallocSize(p));
            sqlite3_mutex_enter((pcache1_g).mutex);
            sqlite3StatusHighwater((int)(7), (int)(nByte));
            sqlite3StatusUp((int)(2), (int)(sz));
            sqlite3_mutex_leave((pcache1_g).mutex);
        }
    }

    return p;
}</function>
  <function>public static PgHdr1* pcache1AllocPage(PCache1* pCache, int benignMalloc)
{
    PgHdr1* p = null;
    void* pPg;
    if (((pCache-&gt;pFree) != null) || (((pCache-&gt;nPage) == (0)) &amp;&amp; ((pcache1InitBulk(pCache)) != 0)))
    {
        p = pCache-&gt;pFree;
        pCache-&gt;pFree = p-&gt;pNext;
        p-&gt;pNext = null;
    }
    else
    {
        if ((benignMalloc) != 0)
        {
            sqlite3BeginBenignMalloc();
        }

        pPg = pcache1Alloc((int)(pCache-&gt;szAlloc));
        if ((benignMalloc) != 0)
        {
            sqlite3EndBenignMalloc();
        }

        if ((pPg) == (null))
            return null;
        p = (PgHdr1*)(&amp;((byte*)(pPg))[pCache-&gt;szPage]);
        p-&gt;page.pBuf = pPg;
        p-&gt;page.pExtra = &amp;p[1];
        p-&gt;isBulkLocal = (ushort)(0);
        p-&gt;isAnchor = (ushort)(0);
        p-&gt;pLruPrev = null;
    }

    (*pCache-&gt;pnPurgeable)++;
    return p;
}</function>
  <function>public static void pcache1Cachesize(sqlite3_pcache* p, int nMax)
{
    PCache1* pCache = (PCache1*)(p);
    uint n = 0;
    if ((pCache-&gt;bPurgeable) != 0)
    {
        PGroup* pGroup = pCache-&gt;pGroup;
        n = ((uint)(nMax));
        if ((n) &gt; (0x7fff0000 - pGroup-&gt;nMaxPage + pCache-&gt;nMax))
        {
            n = (uint)(0x7fff0000 - pGroup-&gt;nMaxPage + pCache-&gt;nMax);
        }

        pGroup-&gt;nMaxPage += (uint)(n - pCache-&gt;nMax);
        pGroup-&gt;mxPinned = (uint)(pGroup-&gt;nMaxPage + 10 - pGroup-&gt;nMinPage);
        pCache-&gt;nMax = (uint)(n);
        pCache-&gt;n90pct = (uint)(pCache-&gt;nMax * 9 / 10);
        pcache1EnforceMaxPage(pCache);
    }
}</function>
  <function>public static sqlite3_pcache* pcache1Create(int szPage, int szExtra, int bPurgeable)
{
    PCache1* pCache;
    PGroup* pGroup;
    int sz = 0;
    sz = (int)(sizeof(PCache1) + sizeof(PGroup) * (pcache1_g).separateCache);
    pCache = (PCache1*)(sqlite3MallocZero((ulong)(sz)));
    if ((pCache) != null)
    {
        if (((pcache1_g).separateCache) != 0)
        {
            pGroup = (PGroup*)(&amp;pCache[1]);
            pGroup-&gt;mxPinned = (uint)(10);
        }
        else
        {
            pGroup = &amp;(pcache1_g).grp;
        }

        if ((pGroup-&gt;lru.isAnchor) == (0))
        {
            pGroup-&gt;lru.isAnchor = (ushort)(1);
            pGroup-&gt;lru.pLruPrev = pGroup-&gt;lru.pLruNext = &amp;pGroup-&gt;lru;
        }

        pCache-&gt;pGroup = pGroup;
        pCache-&gt;szPage = (int)(szPage);
        pCache-&gt;szExtra = (int)(szExtra);
        pCache-&gt;szAlloc = (int)(szPage + szExtra + (((sizeof(PgHdr1)) + 7) &amp; ~7));
        pCache-&gt;bPurgeable = (int)((bPurgeable) != 0 ? 1 : 0);
        pcache1ResizeHash(pCache);
        if ((bPurgeable) != 0)
        {
            pCache-&gt;nMin = (uint)(10);
            pGroup-&gt;nMinPage += (uint)(pCache-&gt;nMin);
            pGroup-&gt;mxPinned = (uint)(pGroup-&gt;nMaxPage + 10 - pGroup-&gt;nMinPage);
            pCache-&gt;pnPurgeable = &amp;pGroup-&gt;nPurgeable;
        }
        else
        {
            pCache-&gt;pnPurgeable = &amp;pCache-&gt;nPurgeableDummy;
        }

        if ((pCache-&gt;nHash) == (0))
        {
            pcache1Destroy((sqlite3_pcache*)(pCache));
            pCache = null;
        }
    }

    return (sqlite3_pcache*)(pCache);
}</function>
  <function>public static void pcache1Destroy(sqlite3_pcache* p)
{
    PCache1* pCache = (PCache1*)(p);
    PGroup* pGroup = pCache-&gt;pGroup;
    if ((pCache-&gt;nPage) != 0)
        pcache1TruncateUnsafe(pCache, (uint)(0));
    pGroup-&gt;nMaxPage -= (uint)(pCache-&gt;nMax);
    pGroup-&gt;nMinPage -= (uint)(pCache-&gt;nMin);
    pGroup-&gt;mxPinned = (uint)(pGroup-&gt;nMaxPage + 10 - pGroup-&gt;nMinPage);
    pcache1EnforceMaxPage(pCache);
    sqlite3_free(pCache-&gt;pBulk);
    sqlite3_free(pCache-&gt;apHash);
    sqlite3_free(pCache);
}</function>
  <function>public static void pcache1EnforceMaxPage(PCache1* pCache)
{
    PGroup* pGroup = pCache-&gt;pGroup;
    PgHdr1* p;
    while (((pGroup-&gt;nPurgeable) &gt; (pGroup-&gt;nMaxPage)) &amp;&amp; (((p = pGroup-&gt;lru.pLruPrev)-&gt;isAnchor) == (0)))
    {
        pcache1PinPage(p);
        pcache1RemoveFromHash(p, (int)(1));
    }

    if (((pCache-&gt;nPage) == (0)) &amp;&amp; ((pCache-&gt;pBulk) != null))
    {
        sqlite3_free(pCache-&gt;pBulk);
        pCache-&gt;pBulk = pCache-&gt;pFree = null;
    }
}</function>
  <function>public static sqlite3_pcache_page* pcache1Fetch(sqlite3_pcache* p, uint iKey, int createFlag)
{
    {
        return (sqlite3_pcache_page*)(pcache1FetchNoMutex(p, (uint)(iKey), (int)(createFlag)));
    }
}</function>
  <function>public static PgHdr1* pcache1FetchNoMutex(sqlite3_pcache* p, uint iKey, int createFlag)
{
    PCache1* pCache = (PCache1*)(p);
    PgHdr1* pPage = null;
    pPage = pCache-&gt;apHash[iKey % pCache-&gt;nHash];
    while (((pPage) != null) &amp;&amp; (pPage-&gt;iKey != iKey))
    {
        pPage = pPage-&gt;pNext;
    }

    if ((pPage) != null)
    {
        if (((pPage)-&gt;pLruNext != null))
        {
            return pcache1PinPage(pPage);
        }
        else
        {
            return pPage;
        }
    }
    else if ((createFlag) != 0)
    {
        return pcache1FetchStage2(pCache, (uint)(iKey), (int)(createFlag));
    }
    else
    {
        return null;
    }
}</function>
  <function>public static PgHdr1* pcache1FetchStage2(PCache1* pCache, uint iKey, int createFlag)
{
    uint nPinned = 0;
    PGroup* pGroup = pCache-&gt;pGroup;
    PgHdr1* pPage = null;
    nPinned = (uint)(pCache-&gt;nPage - pCache-&gt;nRecyclable);
    if (((createFlag) == (1)) &amp;&amp; ((((nPinned) &gt;= (pGroup-&gt;mxPinned)) || ((nPinned) &gt;= (pCache-&gt;n90pct))) || (((pcache1UnderMemoryPressure(pCache)) != 0) &amp;&amp; ((pCache-&gt;nRecyclable) &lt; (nPinned)))))
    {
        return null;
    }

    if ((pCache-&gt;nPage) &gt;= (pCache-&gt;nHash))
        pcache1ResizeHash(pCache);
    if ((((pCache-&gt;bPurgeable) != 0) &amp;&amp; (pGroup-&gt;lru.pLruPrev-&gt;isAnchor == 0)) &amp;&amp; (((pCache-&gt;nPage + 1) &gt;= (pCache-&gt;nMax)) || ((pcache1UnderMemoryPressure(pCache)) != 0)))
    {
        PCache1* pOther;
        pPage = pGroup-&gt;lru.pLruPrev;
        pcache1RemoveFromHash(pPage, (int)(0));
        pcache1PinPage(pPage);
        pOther = pPage-&gt;pCache;
        if (pOther-&gt;szAlloc != pCache-&gt;szAlloc)
        {
            pcache1FreePage(pPage);
            pPage = null;
        }
        else
        {
            pGroup-&gt;nPurgeable -= (uint)(pOther-&gt;bPurgeable - pCache-&gt;bPurgeable);
        }
    }

    if (pPage == null)
    {
        pPage = pcache1AllocPage(pCache, ((createFlag) == (1) ? 1 : 0));
    }

    if ((pPage) != null)
    {
        uint h = (uint)(iKey % pCache-&gt;nHash);
        pCache-&gt;nPage++;
        pPage-&gt;iKey = (uint)(iKey);
        pPage-&gt;pNext = pCache-&gt;apHash[h];
        pPage-&gt;pCache = pCache;
        pPage-&gt;pLruNext = null;
        *(void**)(pPage-&gt;page.pExtra) = null;
        pCache-&gt;apHash[h] = pPage;
        if ((iKey) &gt; (pCache-&gt;iMaxKey))
        {
            pCache-&gt;iMaxKey = (uint)(iKey);
        }
    }

    return pPage;
}</function>
  <function>public static void pcache1Free(void* p)
{
    if ((p) == (null))
        return;
    if (((((ulong)(p)) &gt;= ((ulong)((pcache1_g).pStart))) &amp;&amp; (((ulong)(p)) &lt; ((ulong)((pcache1_g).pEnd)))))
    {
        PgFreeslot* pSlot;
        sqlite3_mutex_enter((pcache1_g).mutex);
        sqlite3StatusDown((int)(1), (int)(1));
        pSlot = (PgFreeslot*)(p);
        pSlot-&gt;pNext = (pcache1_g).pFree;
        (pcache1_g).pFree = pSlot;
        (pcache1_g).nFreeSlot++;
        (pcache1_g).bUnderPressure = (int)(((pcache1_g).nFreeSlot) &lt; ((pcache1_g).nReserve) ? 1 : 0);
        sqlite3_mutex_leave((pcache1_g).mutex);
    }
    else
    {
        {
            int nFreed = (int)(0);
            nFreed = (int)(sqlite3MallocSize(p));
            sqlite3_mutex_enter((pcache1_g).mutex);
            sqlite3StatusDown((int)(2), (int)(nFreed));
            sqlite3_mutex_leave((pcache1_g).mutex);
        }

        sqlite3_free(p);
    }
}</function>
  <function>public static void pcache1FreePage(PgHdr1* p)
{
    PCache1* pCache;
    pCache = p-&gt;pCache;
    if ((p-&gt;isBulkLocal) != 0)
    {
        p-&gt;pNext = pCache-&gt;pFree;
        pCache-&gt;pFree = p;
    }
    else
    {
        pcache1Free(p-&gt;page.pBuf);
    }

    (*pCache-&gt;pnPurgeable)--;
}</function>
  <function>public static int pcache1Init(void* NotUsed)
{
    CRuntime.memset(&amp;(pcache1_g), (int)(0), (ulong)(sizeof(PCacheGlobal)));
    (pcache1_g).separateCache = (int)(((sqlite3Config.pPage) == (null)) || ((sqlite3Config.bCoreMutex) &gt; (0)) ? 1 : 0);
    if ((sqlite3Config.bCoreMutex) != 0)
    {
        (pcache1_g).grp.mutex = sqlite3MutexAlloc((int)(6));
        (pcache1_g).mutex = sqlite3MutexAlloc((int)(7));
    }

    if (((((pcache1_g).separateCache) != 0) &amp;&amp; (sqlite3Config.nPage != 0)) &amp;&amp; ((sqlite3Config.pPage) == (null)))
    {
        (pcache1_g).nInitPage = (int)(sqlite3Config.nPage);
    }
    else
    {
        (pcache1_g).nInitPage = (int)(0);
    }

    (pcache1_g).grp.mxPinned = (uint)(10);
    (pcache1_g).isInit = (int)(1);
    return (int)(0);
}</function>
  <function>public static int pcache1InitBulk(PCache1* pCache)
{
    long szBulk = 0;
    sbyte* zBulk;
    if (((pcache1_g).nInitPage) == (0))
        return (int)(0);
    if ((pCache-&gt;nMax) &lt; (3))
        return (int)(0);
    sqlite3BeginBenignMalloc();
    if (((pcache1_g).nInitPage) &gt; (0))
    {
        szBulk = (long)(pCache-&gt;szAlloc * (long)((pcache1_g).nInitPage));
    }
    else
    {
        szBulk = (long)(-1024 * (long)((pcache1_g).nInitPage));
    }

    if ((szBulk) &gt; (pCache-&gt;szAlloc * (long)(pCache-&gt;nMax)))
    {
        szBulk = (long)(pCache-&gt;szAlloc * (long)(pCache-&gt;nMax));
    }

    zBulk = pCache-&gt;pBulk = sqlite3Malloc((ulong)(szBulk));
    sqlite3EndBenignMalloc();
    if ((zBulk) != null)
    {
        int nBulk = (int)(sqlite3MallocSize(zBulk) / pCache-&gt;szAlloc);
        do
        {
            PgHdr1* pX = (PgHdr1*)(&amp;zBulk[pCache-&gt;szPage]);
            pX-&gt;page.pBuf = zBulk;
            pX-&gt;page.pExtra = &amp;pX[1];
            pX-&gt;isBulkLocal = (ushort)(1);
            pX-&gt;isAnchor = (ushort)(0);
            pX-&gt;pNext = pCache-&gt;pFree;
            pX-&gt;pLruPrev = null;
            pCache-&gt;pFree = pX;
            zBulk += pCache-&gt;szAlloc;
        }
        while ((--nBulk) != 0);
    }

    return (int)(pCache-&gt;pFree != null);
}</function>
  <function>public static int pcache1Pagecount(sqlite3_pcache* p)
{
    int n = 0;
    PCache1* pCache = (PCache1*)(p);
    n = (int)(pCache-&gt;nPage);
    return (int)(n);
}</function>
  <function>public static PgHdr1* pcache1PinPage(PgHdr1* pPage)
{
    pPage-&gt;pLruPrev-&gt;pLruNext = pPage-&gt;pLruNext;
    pPage-&gt;pLruNext-&gt;pLruPrev = pPage-&gt;pLruPrev;
    pPage-&gt;pLruNext = null;
    pPage-&gt;pCache-&gt;nRecyclable--;
    return pPage;
}</function>
  <function>public static void pcache1Rekey(sqlite3_pcache* p, sqlite3_pcache_page* pPg, uint iOld, uint iNew)
{
    PCache1* pCache = (PCache1*)(p);
    PgHdr1* pPage = (PgHdr1*)(pPg);
    PgHdr1** pp;
    uint h = 0;
    h = (uint)(iOld % pCache-&gt;nHash);
    pp = &amp;pCache-&gt;apHash[h];
    while ((*pp) != pPage)
    {
        pp = &amp;(*pp)-&gt;pNext;
    }

    *pp = pPage-&gt;pNext;
    h = (uint)(iNew % pCache-&gt;nHash);
    pPage-&gt;iKey = (uint)(iNew);
    pPage-&gt;pNext = pCache-&gt;apHash[h];
    pCache-&gt;apHash[h] = pPage;
    if ((iNew) &gt; (pCache-&gt;iMaxKey))
    {
        pCache-&gt;iMaxKey = (uint)(iNew);
    }
}</function>
  <function>public static void pcache1RemoveFromHash(PgHdr1* pPage, int freeFlag)
{
    uint h = 0;
    PCache1* pCache = pPage-&gt;pCache;
    PgHdr1** pp;
    h = (uint)(pPage-&gt;iKey % pCache-&gt;nHash);
    for (pp = &amp;pCache-&gt;apHash[h]; (*pp) != pPage; pp = &amp;(*pp)-&gt;pNext)
    {
    }

    *pp = (*pp)-&gt;pNext;
    pCache-&gt;nPage--;
    if ((freeFlag) != 0)
        pcache1FreePage(pPage);
}</function>
  <function>public static void pcache1ResizeHash(PCache1* p)
{
    PgHdr1** apNew;
    uint nNew = 0;
    uint i = 0;
    nNew = (uint)(p-&gt;nHash * 2);
    if ((nNew) &lt; (256))
    {
        nNew = (uint)(256);
    }

    if ((p-&gt;nHash) != 0)
    {
        sqlite3BeginBenignMalloc();
    }

    apNew = (PgHdr1**)(sqlite3MallocZero((ulong)(sizeof(PgHdr1) * nNew)));
    if ((p-&gt;nHash) != 0)
    {
        sqlite3EndBenignMalloc();
    }

    if ((apNew) != null)
    {
        for (i = (uint)(0); (i) &lt; (p-&gt;nHash); i++)
        {
            PgHdr1* pPage;
            PgHdr1* pNext = p-&gt;apHash[i];
            while ((pPage = pNext) != null)
            {
                uint h = (uint)(pPage-&gt;iKey % nNew);
                pNext = pPage-&gt;pNext;
                pPage-&gt;pNext = apNew[h];
                apNew[h] = pPage;
            }
        }

        sqlite3_free(p-&gt;apHash);
        p-&gt;apHash = apNew;
        p-&gt;nHash = (uint)(nNew);
    }
}</function>
  <function>public static void pcache1Shrink(sqlite3_pcache* p)
{
    PCache1* pCache = (PCache1*)(p);
    if ((pCache-&gt;bPurgeable) != 0)
    {
        PGroup* pGroup = pCache-&gt;pGroup;
        uint savedMaxPage = 0;
        savedMaxPage = (uint)(pGroup-&gt;nMaxPage);
        pGroup-&gt;nMaxPage = (uint)(0);
        pcache1EnforceMaxPage(pCache);
        pGroup-&gt;nMaxPage = (uint)(savedMaxPage);
    }
}</function>
  <function>public static void pcache1Shutdown(void* NotUsed)
{
    CRuntime.memset(&amp;(pcache1_g), (int)(0), (ulong)(sizeof(PCacheGlobal)));
}</function>
  <function>public static void pcache1Truncate(sqlite3_pcache* p, uint iLimit)
{
    PCache1* pCache = (PCache1*)(p);
    if ((iLimit) &lt;= (pCache-&gt;iMaxKey))
    {
        pcache1TruncateUnsafe(pCache, (uint)(iLimit));
        pCache-&gt;iMaxKey = (uint)(iLimit - 1);
    }
}</function>
  <function>public static void pcache1TruncateUnsafe(PCache1* pCache, uint iLimit)
{
    uint h = 0; uint  iStop  =  0 ; 
    if ((pCache-&gt;iMaxKey - iLimit) &lt; (pCache-&gt;nHash))
    {
        h = (uint)(iLimit % pCache-&gt;nHash);
        iStop = (uint)(pCache-&gt;iMaxKey % pCache-&gt;nHash);
    }
    else
    {
        h = (uint)(pCache-&gt;nHash / 2);
        iStop = (uint)(h - 1);
    }

    for (;;)
    {
        PgHdr1** pp;
        PgHdr1* pPage;
        pp = &amp;pCache-&gt;apHash[h];
        while ((pPage = *pp) != null)
        {
            if ((pPage-&gt;iKey) &gt;= (iLimit))
            {
                pCache-&gt;nPage--;
                *pp = pPage-&gt;pNext;
                if (((pPage)-&gt;pLruNext != null))
                    pcache1PinPage(pPage);
                pcache1FreePage(pPage);
            }
            else
            {
                pp = &amp;pPage-&gt;pNext;
            }
        }

        if ((h) == (iStop))
            break;
        h = (uint)((h + 1) % pCache-&gt;nHash);
    }
}</function>
  <function>public static int pcache1UnderMemoryPressure(PCache1* pCache)
{
    if ((((pcache1_g).nSlot) != 0) &amp;&amp; ((pCache-&gt;szPage + pCache-&gt;szExtra) &lt;= ((pcache1_g).szSlot)))
    {
        return (int)((pcache1_g).bUnderPressure);
    }
    else
    {
        return (int)(sqlite3HeapNearlyFull());
    }
}</function>
  <function>public static void pcache1Unpin(sqlite3_pcache* p, sqlite3_pcache_page* pPg, int reuseUnlikely)
{
    PCache1* pCache = (PCache1*)(p);
    PgHdr1* pPage = (PgHdr1*)(pPg);
    PGroup* pGroup = pCache-&gt;pGroup;
    if (((reuseUnlikely) != 0) || ((pGroup-&gt;nPurgeable) &gt; (pGroup-&gt;nMaxPage)))
    {
        pcache1RemoveFromHash(pPage, (int)(1));
    }
    else
    {
        PgHdr1** ppFirst = &amp;pGroup-&gt;lru.pLruNext;
        pPage-&gt;pLruPrev = &amp;pGroup-&gt;lru;
        (pPage-&gt;pLruNext = *ppFirst)-&gt;pLruPrev = pPage;
        *ppFirst = pPage;
        pCache-&gt;nRecyclable++;
    }
}</function>
  <function>public static PgHdr pcacheFetchFinishWithInit(PCache pCache, uint pgno, sqlite3_pcache_page* pPage)
{
    PgHdr pPgHdr;
    pPgHdr = (PgHdr)(pPage-&gt;pExtra);
    CRuntime.memset(pPgHdr.pDirty, (int)(0), (ulong)(sizeof(PgHdr) - ((ulong)((0).pDirty))));
    pPgHdr.pPage = pPage;
    pPgHdr.pData = pPage-&gt;pBuf;
    pPgHdr.pExtra = (void*)(pPgHdr[1]);
    CRuntime.memset(pPgHdr.pExtra, (int)(0), (ulong)(8));
    pPgHdr.pCache = pCache;
    pPgHdr.pgno = (uint)(pgno);
    pPgHdr.flags = (ushort)(0x001);
    return sqlite3PcacheFetchFinish(pCache, (uint)(pgno), pPage);
}</function>
  <function>public static void pcacheManageDirtyList(PgHdr pPage, byte addRemove)
{
    PCache p = pPage.pCache;
    if ((addRemove &amp; 1) != 0)
    {
        if ((p.pSynced) == (pPage))
        {
            p.pSynced = pPage.pDirtyPrev;
        }

        if ((pPage.pDirtyNext) != null)
        {
            pPage.pDirtyNext.pDirtyPrev = pPage.pDirtyPrev;
        }
        else
        {
            p.pDirtyTail = pPage.pDirtyPrev;
        }

        if ((pPage.pDirtyPrev) != null)
        {
            pPage.pDirtyPrev.pDirtyNext = pPage.pDirtyNext;
        }
        else
        {
            p.pDirty = pPage.pDirtyNext;
            if ((p.pDirty) == (null))
            {
                p.eCreate = (byte)(2);
            }
        }
    }

    if ((addRemove &amp; 2) != 0)
    {
        pPage.pDirtyPrev = null;
        pPage.pDirtyNext = p.pDirty;
        if ((pPage.pDirtyNext) != null)
        {
            pPage.pDirtyNext.pDirtyPrev = pPage;
        }
        else
        {
            p.pDirtyTail = pPage;
            if ((p.bPurgeable) != 0)
            {
                p.eCreate = (byte)(1);
            }
        }

        p.pDirty = pPage;
        if ((p.pSynced == null) &amp;&amp; ((0) == (pPage.flags &amp; 0x008)))
        {
            p.pSynced = pPage;
        }
    }
}</function>
  <function>public static PgHdr pcacheMergeDirtyList(PgHdr pA, PgHdr pB)
{
    PgHdr result = new PgHdr(); PgHdr  pTail ; 
    pTail = result;
    for (;;)
    {
        if ((pA.pgno) &lt; (pB.pgno))
        {
            pTail.pDirty = pA;
            pTail = pA;
            pA = pA.pDirty;
            if ((pA) == (null))
            {
                pTail.pDirty = pB;
                break;
            }
        }
        else
        {
            pTail.pDirty = pB;
            pTail = pB;
            pB = pB.pDirty;
            if ((pB) == (null))
            {
                pTail.pDirty = pA;
                break;
            }
        }
    }

    return result.pDirty;
}</function>
  <function>public static PgHdr pcacheSortDirtyList(PgHdr pIn)
{
    var a = new PgHdr[32]; a [ 0 ]  =  new  PgHdr ( ) ;  a [ 1 ]  =  new  PgHdr ( ) ;  a [ 2 ]  =  new  PgHdr ( ) ;  a [ 3 ]  =  new  PgHdr ( ) ;  a [ 4 ]  =  new  PgHdr ( ) ;  a [ 5 ]  =  new  PgHdr ( ) ;  a [ 6 ]  =  new  PgHdr ( ) ;  a [ 7 ]  =  new  PgHdr ( ) ;  a [ 8 ]  =  new  PgHdr ( ) ;  a [ 9 ]  =  new  PgHdr ( ) ;  a [ 10 ]  =  new  PgHdr ( ) ;  a [ 11 ]  =  new  PgHdr ( ) ;  a [ 12 ]  =  new  PgHdr ( ) ;  a [ 13 ]  =  new  PgHdr ( ) ;  a [ 14 ]  =  new  PgHdr ( ) ;  a [ 15 ]  =  new  PgHdr ( ) ;  a [ 16 ]  =  new  PgHdr ( ) ;  a [ 17 ]  =  new  PgHdr ( ) ;  a [ 18 ]  =  new  PgHdr ( ) ;  a [ 19 ]  =  new  PgHdr ( ) ;  a [ 20 ]  =  new  PgHdr ( ) ;  a [ 21 ]  =  new  PgHdr ( ) ;  a [ 22 ]  =  new  PgHdr ( ) ;  a [ 23 ]  =  new  PgHdr ( ) ;  a [ 24 ]  =  new  PgHdr ( ) ;  a [ 25 ]  =  new  PgHdr ( ) ;  a [ 26 ]  =  new  PgHdr ( ) ;  a [ 27 ]  =  new  PgHdr ( ) ;  a [ 28 ]  =  new  PgHdr ( ) ;  a [ 29 ]  =  new  PgHdr ( ) ;  a [ 30 ]  =  new  PgHdr ( ) ;  a [ 31 ]  =  new  PgHdr ( ) ;  PgHdr  p ; 
    int i = 0;
    CRuntime.memset(a, (int)(0), (ulong)(32 * sizeof(PgHdr)));
    while ((pIn) != null)
    {
        p = pIn;
        pIn = p.pDirty;
        p.pDirty = null;
        for (i = (int)(0); ((i) &lt; (32 - 1)); i++)
        {
            if ((a[i]) == (null))
            {
                a[i] = p;
                break;
            }
            else
            {
                p = pcacheMergeDirtyList(a[i], p);
                a[i] = null;
            }
        }

        if (((i) == (32 - 1)))
        {
            a[i] = pcacheMergeDirtyList(a[i], p);
        }
    }

    p = a[0];
    for (i = (int)(1); (i) &lt; (32); i++)
    {
        if ((a[i]) == (null))
            continue;
        p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];
    }

    return p;
}</function>
  <function>public static void pcacheUnpin(PgHdr p)
{
    if ((p.pCache.bPurgeable) != 0)
    {
        sqlite3Config.pcache2.xUnpin(p.pCache.pCache, p.pPage, (int)(0));
    }
}</function>
  <function>public static void percent_rankInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    p-&gt;nStep++;
}</function>
  <function>public static void percent_rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
    {
        p-&gt;nTotal++;
    }
}</function>
  <function>public static void percent_rankValueFunc(sqlite3_context pCtx)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
    {
        p-&gt;nValue = (long)(p-&gt;nStep);
        if ((p-&gt;nTotal) &gt; (1))
        {
            double r = (double)((double)(p-&gt;nValue) / (double)(p-&gt;nTotal - 1));
            sqlite3_result_double(pCtx, (double)(r));
        }
        else
        {
            sqlite3_result_double(pCtx, (double)(0.0));
        }
    }
}</function>
  <function>public static void populateCellCache(CellArray p, int idx, int N)
{
    while ((N) &gt; (0))
    {
        if ((p.szCell[idx]) == (0))
        {
            p.szCell[idx] = (ushort)(p.pRef.xCellSize(p.pRef, p.apCell[idx]));
        }
        else
        {
        }

        idx++;
        N--;
    }
}</function>
  <function>public static void pragmaFunclistLine(Vdbe v, FuncDef p, int isBuiltin, int showInternFuncs)
{
    for (p;; p = p.pNext)
    {
        sbyte* zType;
        if ((p.xSFunc) == (null))
            continue;
        if (((p.funcFlags &amp; 0x00040000) != 0) &amp;&amp; ((showInternFuncs) == (0)))
        {
            continue;
        }

        if (p.xValue != null)
        {
            zType = "w";
        }
        else if (p.xFinalize != null)
        {
            zType = "a";
        }
        else
        {
            zType = "s";
        }

        sqlite3VdbeMultiLoad(v, (int)(1), "sissii", p.zName, (int)(isBuiltin), zType, pragmaFunclistLine_azEnc[p.funcFlags &amp; 0x0003], (int)(p.nArg), (uint)((p.funcFlags &amp; pragmaFunclistLine_mask) ^ 0x000200000));
    }
}</function>
  <function>public static PragmaName* pragmaLocate(sbyte* zName)
{
    int upr = 0; int  lwr  =  0 ;  int  mid  =  ( int ) ( 0 ) ;  int  rc  =  0 ; 
    lwr = (int)(0);
    upr = (int)(((int)(67 * sizeof(PragmaName) / sizeof(PragmaName))) - 1);
    while ((lwr) &lt;= (upr))
    {
        mid = (int)((lwr + upr) / 2);
        rc = (int)(sqlite3_stricmp(zName, aPragmaName[mid].zName));
        if ((rc) == (0))
            break;
        if ((rc) &lt; (0))
        {
            upr = (int)(mid - 1);
        }
        else
        {
            lwr = (int)(mid + 1);
        }
    }

    return (lwr) &gt; (upr) ? null : &amp;aPragmaName[mid];
}</function>
  <function>public static int pragmaVtabBestIndex(sqlite3_vtab tab, sqlite3_index_info* pIdxInfo)
{
    PragmaVtab pTab = (PragmaVtab)(tab);
    sqlite3_index_constraint* pConstraint;
    int i = 0; int  j  =  0 ; 
    int* seen = stackalloc int[2];
    pIdxInfo-&gt;estimatedCost = ((double)(1));
    if ((pTab.nHidden) == (0))
    {
        return (int)(0);
    }

    pConstraint = pIdxInfo-&gt;aConstraint;
    seen[0] = (int)(0);
    seen[1] = (int)(0);
    for (i = (int)(0); (i) &lt; (pIdxInfo-&gt;nConstraint); i++, pConstraint++)
    {
        if ((pConstraint-&gt;usable) == (0))
            continue;
        if (pConstraint-&gt;op != 2)
            continue;
        if ((pConstraint-&gt;iColumn) &lt; (pTab.iHidden))
            continue;
        j = (int)(pConstraint-&gt;iColumn - pTab.iHidden);
        seen[j] = (int)(i + 1);
    }

    if ((seen[0]) == (0))
    {
        pIdxInfo-&gt;estimatedCost = ((double)(2147483647));
        pIdxInfo-&gt;estimatedRows = (long)(2147483647);
        return (int)(0);
    }

    j = (int)(seen[0] - 1);
    pIdxInfo-&gt;aConstraintUsage[j].argvIndex = (int)(1);
    pIdxInfo-&gt;aConstraintUsage[j].omit = (byte)(1);
    if ((seen[1]) == (0))
        return (int)(0);
    pIdxInfo-&gt;estimatedCost = ((double)(20));
    pIdxInfo-&gt;estimatedRows = (long)(20);
    j = (int)(seen[1] - 1);
    pIdxInfo-&gt;aConstraintUsage[j].argvIndex = (int)(2);
    pIdxInfo-&gt;aConstraintUsage[j].omit = (byte)(1);
    return (int)(0);
}</function>
  <function>public static int pragmaVtabClose(sqlite3_vtab_cursor cur)
{
    PragmaVtabCursor pCsr = (PragmaVtabCursor)(cur);
    pragmaVtabCursorClear(pCsr);
    sqlite3_free(pCsr);
    return (int)(0);
}</function>
  <function>public static int pragmaVtabColumn(sqlite3_vtab_cursor pVtabCursor, sqlite3_context ctx, int i)
{
    PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
    PragmaVtab pTab = (PragmaVtab)(pVtabCursor.pVtab);
    if ((i) &lt; (pTab.iHidden))
    {
        sqlite3_result_value(ctx, sqlite3_column_value(pCsr.pPragma, (int)(i)));
    }
    else
    {
        sqlite3_result_text(ctx, pCsr.azArg[i - pTab.iHidden], (int)(-1), ((Void(Void * ))(-1)));
    }

    return (int)(0);
}</function>
  <function>public static int pragmaVtabConnect(sqlite3 db, void* pAux, int argc, sbyte** argv, sqlite3_vtab ppVtab, sbyte** pzErr)
{
    PragmaName* pPragma = (PragmaName*)(pAux);
    PragmaVtab pTab = null;
    int rc = 0;
    int i = 0; int  j  =  0 ; 
    sbyte cSep = (sbyte)(40);
    sqlite3_str acc = new sqlite3_str();
    sbyte* zBuf = stackalloc sbyte[200];
    sqlite3StrAccumInit(acc, null, zBuf, (int)(200 * sizeof(sbyte)), (int)(0));
    sqlite3_str_appendall(acc, "CREATE TABLE x");
    for (i = (int)(0), j = (int)(pPragma-&gt;iPragCName); (i) &lt; (pPragma-&gt;nPragCName); i++, j++)
    {
        sqlite3_str_appendf(acc, "%c\"%s\"", (int)(cSep), pragCName[j]);
        cSep = (sbyte)(44);
    }

    if ((i) == (0))
    {
        sqlite3_str_appendf(acc, "(\"%s\"", pPragma-&gt;zName);
        i++;
    }

    j = (int)(0);
    if ((pPragma-&gt;mPragFlg &amp; 0x20) != 0)
    {
        sqlite3_str_appendall(acc, ",arg HIDDEN");
        j++;
    }

    if ((pPragma-&gt;mPragFlg &amp; (0x40 | 0x80)) != 0)
    {
        sqlite3_str_appendall(acc, ",schema HIDDEN");
        j++;
    }

    sqlite3_str_append(acc, ")", (int)(1));
    sqlite3StrAccumFinish(acc);
    rc = (int)(sqlite3_declare_vtab(db, zBuf));
    if ((rc) == (0))
    {
        pTab = (PragmaVtab)(sqlite3_malloc((int)(sizeof(PragmaVtab))));
        if ((pTab) == (null))
        {
            rc = (int)(7);
        }
        else
        {
            CRuntime.memset(pTab, (int)(0), (ulong)(sizeof(PragmaVtab)));
            pTab.pName = pPragma;
            pTab.db = db;
            pTab.iHidden = (byte)(i);
            pTab.nHidden = (byte)(j);
        }
    }
    else
    {
        *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
    }

    ppVtab = (sqlite3_vtab)(pTab);
    return (int)(rc);
}</function>
  <function>public static void pragmaVtabCursorClear(PragmaVtabCursor pCsr)
{
    int i = 0;
    sqlite3_finalize(pCsr.pPragma);
    pCsr.pPragma = null;
    for (i = (int)(0); (i) &lt; ((int)(2 * sizeof(sbyte) / sizeof(sbyte*))); i++)
    {
        sqlite3_free(pCsr.azArg[i]);
        pCsr.azArg[i] = null;
    }
}</function>
  <function>public static int pragmaVtabDisconnect(sqlite3_vtab pVtab)
{
    PragmaVtab pTab = (PragmaVtab)(pVtab);
    sqlite3_free(pTab);
    return (int)(0);
}</function>
  <function>public static int pragmaVtabEof(sqlite3_vtab_cursor pVtabCursor)
{
    PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
    return (((pCsr.pPragma) == (null)) ? 1 : 0);
}</function>
  <function>public static int pragmaVtabFilter(sqlite3_vtab_cursor pVtabCursor, int idxNum, sbyte* idxStr, int argc, sqlite3_value argv)
{
    PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
    PragmaVtab pTab = (PragmaVtab)(pVtabCursor.pVtab);
    int rc = 0;
    int i = 0; int  j  =  0 ; 
    sqlite3_str acc = new sqlite3_str();
    sbyte* zSql;
    pragmaVtabCursorClear(pCsr);
    j = (int)((pTab.pName-&gt;mPragFlg &amp; 0x20) != 0 ? 0 : 1);
    for (i = (int)(0); (i) &lt; (argc); i++, j++)
    {
        sbyte* zText = (sbyte*)(sqlite3_value_text(argv[i]));
        if ((zText) != null)
        {
            pCsr.azArg[j] = sqlite3_mprintf("%s", zText);
            if ((pCsr.azArg[j]) == (null))
            {
                return (int)(7);
            }
        }
    }

    sqlite3StrAccumInit(acc, null, null, (int)(0), (int)(pTab.db.aLimit[1]));
    sqlite3_str_appendall(acc, "PRAGMA ");
    if ((pCsr.azArg[1]) != null)
    {
        sqlite3_str_appendf(acc, "%Q.", pCsr.azArg[1]);
    }

    sqlite3_str_appendall(acc, pTab.pName-&gt;zName);
    if ((pCsr.azArg[0]) != null)
    {
        sqlite3_str_appendf(acc, "=%Q", pCsr.azArg[0]);
    }

    zSql = sqlite3StrAccumFinish(acc);
    if ((zSql) == (null))
        return (int)(7);
    rc = (int)(sqlite3_prepare_v2(pTab.db, zSql, (int)(-1), &amp;pCsr.pPragma, null));
    sqlite3_free(zSql);
    if (rc != 0)
    {
        pTab._base_.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab.db));
        return (int)(rc);
    }

    return (int)(pragmaVtabNext(pVtabCursor));
}</function>
  <function>public static int pragmaVtabNext(sqlite3_vtab_cursor pVtabCursor)
{
    PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
    int rc = (int)(0);
    pCsr.iRowid++;
    if (100 != sqlite3_step(pCsr.pPragma))
    {
        rc = (int)(sqlite3_finalize(pCsr.pPragma));
        pCsr.pPragma = null;
        pragmaVtabCursorClear(pCsr);
    }

    return (int)(rc);
}</function>
  <function>public static int pragmaVtabOpen(sqlite3_vtab pVtab, sqlite3_vtab_cursor ppCursor)
{
    PragmaVtabCursor pCsr;
    pCsr = (PragmaVtabCursor)(sqlite3_malloc((int)(sizeof(PragmaVtabCursor))));
    if ((pCsr) == (null))
        return (int)(7);
    CRuntime.memset(pCsr, (int)(0), (ulong)(sizeof(PragmaVtabCursor)));
    pCsr._base_.pVtab = pVtab;
    ppCursor = pCsr._base_;
    return (int)(0);
}</function>
  <function>public static int pragmaVtabRowid(sqlite3_vtab_cursor pVtabCursor, long* p)
{
    PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
    *p = (long)(pCsr.iRowid);
    return (int)(0);
}</function>
  <function>public static void preserveExpr(IdxExprTrans pTrans, Expr pExpr)
{
    WhereExprMod pNew;
    pNew = sqlite3DbMallocRaw(pTrans.db, (ulong)(sizeof(WhereExprMod)));
    if ((pNew) == (null))
        return;
    pNew.pNext = pTrans.pWInfo.pExprMods;
    pTrans.pWInfo.pExprMods = pNew;
    pNew.pExpr = pExpr;
    CRuntime.memcpy(pNew.orig, pExpr, (ulong)(sizeof(Expr)));
}</function>
  <function>public static void printfFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    PrintfArguments x = new PrintfArguments();
    sqlite3_str str = new sqlite3_str();
    sbyte* zFormat;
    int n = 0;
    sqlite3 db = sqlite3_context_db_handle(context);
    if (((argc) &gt;= (1)) &amp;&amp; ((zFormat = (sbyte*)(sqlite3_value_text(argv[0]))) != null))
    {
        x.nArg = (int)(argc - 1);
        x.nUsed = (int)(0);
        x.apArg = argv[1];
        sqlite3StrAccumInit(str, db, null, (int)(0), (int)(db.aLimit[0]));
        str.printfFlags = (byte)(0x02);
        sqlite3_str_appendf(str, zFormat, x);
        n = (int)(str.nChar);
        sqlite3_result_text(context, sqlite3StrAccumFinish(str), (int)(n), ((Void(Void * ))(sqlite3OomFault)));
    }
}</function>
  <function>public static sbyte* printfTempBuf(sqlite3_str pAccum, long n)
{
    sbyte* z;
    if ((pAccum.accError) != 0)
        return null;
    if (((n) &gt; (pAccum.nAlloc)) &amp;&amp; ((n) &gt; (pAccum.mxAlloc)))
    {
        sqlite3StrAccumSetError(pAccum, (byte)(18));
        return null;
    }

    z = sqlite3DbMallocRaw(pAccum.db, (ulong)(n));
    if ((z) == (null))
    {
        sqlite3StrAccumSetError(pAccum, (byte)(7));
    }

    return z;
}</function>
  <function>public static int propagateConstantExprRewrite(Walker pWalker, Expr pExpr)
{
    WhereConst pConst = pWalker.u.pConst;
    if ((pConst.bHasAffBlob) != 0)
    {
        if ((((pExpr.op) &gt;= (53)) &amp;&amp; ((pExpr.op) &lt;= (57))) || ((pExpr.op) == (45)))
        {
            propagateConstantExprRewriteOne(pConst, pExpr.pLeft, (int)(0));
            if ((pConst.pOomFault[0]) != 0)
                return (int)(1);
            if (sqlite3ExprAffinity(pExpr.pLeft) != 0x42)
            {
                propagateConstantExprRewriteOne(pConst, pExpr.pRight, (int)(0));
            }
        }
    }

    return (int)(propagateConstantExprRewriteOne(pConst, pExpr, (int)(pConst.bHasAffBlob)));
}</function>
  <function>public static int propagateConstantExprRewriteOne(WhereConst pConst, Expr pExpr, int bIgnoreAffBlob)
{
    int i = 0;
    if ((pConst.pOomFault[0]) != 0)
        return (int)(1);
    if (pExpr.op != 167)
        return (int)(0);
    if ((((pExpr).flags &amp; (0x000008 | 0x000001)) != 0))
    {
        return (int)(0);
    }

    for (i = (int)(0); (i) &lt; (pConst.nConst); i++)
    {
        Expr pColumn = pConst.apExpr[i * 2];
        if ((pColumn) == (pExpr))
            continue;
        if (pColumn.iTable != pExpr.iTable)
            continue;
        if (pColumn.iColumn != pExpr.iColumn)
            continue;
        if (((bIgnoreAffBlob) != 0) &amp;&amp; ((sqlite3ExprAffinity(pColumn)) == (0x41)))
        {
            break;
        }

        pConst.nChng++;
        (pExpr).flags &amp;= (uint)(~(0x800000));
        (pExpr).flags |= (uint)(0x000008);
        pExpr.pLeft = sqlite3ExprDup(pConst.pParse.db, pConst.apExpr[i * 2 + 1], (int)(0));
        if ((pConst.pParse.db.mallocFailed) != 0)
            return (int)(1);
        break;
    }

    return (int)(1);
}</function>
  <function>public static int propagateConstants(Parse pParse, Select p)
{
    WhereConst x = new WhereConst();
    Walker w = new Walker();
    int nChng = (int)(0);
    x.pParse = pParse;
    x.pOomFault = &amp;pParse.db.mallocFailed;
    do
    {
        x.nConst = (int)(0);
        x.nChng = (int)(0);
        x.apExpr = null;
        x.bHasAffBlob = (int)(0);
        findConstInWhere(x, p.pWhere);
        if ((x.nConst) != 0)
        {
            CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
            w.pParse = pParse;
            w.xExprCallback = propagateConstantExprRewrite;
            w.xSelectCallback = sqlite3SelectWalkNoop;
            w.xSelectCallback2 = null;
            w.walkerDepth = (int)(0);
            w.u.pConst = x;
            sqlite3WalkExpr(w, p.pWhere);
            sqlite3DbFree(x.pParse.db, x.apExpr);
            nChng += (int)(x.nChng);
        }
    }
    while ((x.nChng) != 0);
    return (int)(nChng);
}</function>
  <function>public static int ptrmapGet(BtShared pBt, uint key, byte* pEType, uint* pPgno)
{
    PgHdr pDbPage;
    int iPtrmap = 0;
    byte* pPtrmap;
    int offset = 0;
    int rc = 0;
    iPtrmap = (int)(ptrmapPageno(pBt, (uint)(key)));
    rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(iPtrmap), pDbPage, (int)(0)));
    if (rc != 0)
    {
        return (int)(rc);
    }

    pPtrmap = (byte*)(sqlite3PagerGetData(pDbPage));
    offset = (int)(5 * (key - iPtrmap - 1));
    if ((offset) &lt; (0))
    {
        sqlite3PagerUnref(pDbPage);
        return (int)(sqlite3CorruptError((int)(67235)));
    }

    *pEType = (byte)(pPtrmap[offset]);
    if ((pPgno) != null)
        *pPgno = (uint)(sqlite3Get4byte(&amp;pPtrmap[offset + 1]));
    sqlite3PagerUnref(pDbPage);
    if (((*pEType) &lt; (1)) || ((*pEType) &gt; (5)))
        return (int)(sqlite3CorruptError((int)(67243)));
    return (int)(0);
}</function>
  <function>public static uint ptrmapPageno(BtShared pBt, uint pgno)
{
    int nPagesPerMapPage = 0;
    uint iPtrMap = 0; uint  ret  =  0 ; 
    if ((pgno) &lt; (2))
        return (uint)(0);
    nPagesPerMapPage = (int)((pBt.usableSize / 5) + 1);
    iPtrMap = (uint)((pgno - 2) / nPagesPerMapPage);
    ret = (uint)((iPtrMap * nPagesPerMapPage) + 2);
    if ((ret) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
    {
        ret++;
    }

    return (uint)(ret);
}</function>
  <function>public static void ptrmapPut(BtShared pBt, uint key, byte eType, uint parent, int* pRC)
{
    PgHdr pDbPage;
    byte* pPtrmap;
    uint iPtrmap = 0;
    int offset = 0;
    int rc = 0;
    if ((*pRC) != 0)
        return;
    if ((key) == (0))
    {
        *pRC = (int)(sqlite3CorruptError((int)(67172)));
        return;
    }

    iPtrmap = (uint)(ptrmapPageno(pBt, (uint)(key)));
    rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(iPtrmap), pDbPage, (int)(0)));
    if (rc != 0)
    {
        *pRC = (int)(rc);
        return;
    }

    if (((sbyte*)(sqlite3PagerGetExtra(pDbPage)))[0] != 0)
    {
        *pRC = (int)(sqlite3CorruptError((int)(67185)));
        goto ptrmap_exit;
    }

    offset = (int)(5 * (key - iPtrmap - 1));
    if ((offset) &lt; (0))
    {
        *pRC = (int)(sqlite3CorruptError((int)(67190)));
        goto ptrmap_exit;
    }

    pPtrmap = (byte*)(sqlite3PagerGetData(pDbPage));
    if ((eType != pPtrmap[offset]) || (sqlite3Get4byte(&amp;pPtrmap[offset + 1]) != parent))
    {
        *pRC = (int)(rc = (int)(sqlite3PagerWrite(pDbPage)));
        if ((rc) == (0))
        {
            pPtrmap[offset] = (byte)(eType);
            sqlite3Put4byte(&amp;pPtrmap[offset + 1], (uint)(parent));
        }
    }

    ptrmap_exit:
        ; sqlite3PagerUnref ( pDbPage ) ; 
}</function>
  <function>public static void ptrmapPutOvflPtr(MemPage pPage, MemPage pSrc, byte* pCell, int* pRC)
{
    CellInfo info = new CellInfo();
    if ((*pRC) != 0)
        return;
    pPage.xParseCell(pPage, pCell, &amp;info);
    if ((info.nLocal) &lt; (info.nPayload))
    {
        uint ovfl = 0;
        if (((((ulong)(pSrc.aDataEnd)) &gt;= ((ulong)(pCell))) &amp;&amp; (((ulong)(pSrc.aDataEnd)) &lt; ((ulong)(pCell + info.nLocal)))))
        {
            *pRC = (int)(sqlite3CorruptError((int)(67589)));
            return;
        }

        ovfl = (uint)(sqlite3Get4byte(&amp;pCell[info.nSize - 4]));
        ptrmapPut(pPage.pBt, (uint)(ovfl), (byte)(3), (uint)(pPage.pgno), pRC);
    }
}</function>
  <function>public static int pushDownWhereTerms(Parse pParse, Select pSubq, Expr pWhere, int iCursor, int isLeftJoin)
{
    Expr pNew;
    int nChng = (int)(0);
    if ((pWhere) == (null))
        return (int)(0);
    if ((pSubq.selFlags &amp; (0x0002000 | 0x2000000)) != 0)
        return (int)(0);
    if ((pSubq.pPrior) != null)
    {
        Select pSel;
        for (pSel = pSubq; pSel; pSel = pSel.pPrior)
        {
            if ((pSel.pWin) != null)
                return (int)(0);
        }
    }
    else
    {
        if (((pSubq.pWin) != null) &amp;&amp; ((pSubq.pWin.pPartition) == (null)))
            return (int)(0);
    }

    if (pSubq.pLimit != null)
    {
        return (int)(0);
    }

    while ((pWhere.op) == (44))
    {
        nChng += (int)(pushDownWhereTerms(pParse, pSubq, pWhere.pRight, (int)(iCursor), (int)(isLeftJoin)));
        pWhere = pWhere.pLeft;
    }

    if (((isLeftJoin) != 0) &amp;&amp; (((((pWhere).flags &amp; (0x000001)) != 0) == (0)) || (pWhere.w.iRightJoinTable != iCursor)))
    {
        return (int)(0);
    }

    if ((((pWhere).flags &amp; (0x000001)) != 0) &amp;&amp; (pWhere.w.iRightJoinTable != iCursor))
    {
        return (int)(0);
    }

    if ((sqlite3ExprIsTableConstant(pWhere, (int)(iCursor))) != 0)
    {
        nChng++;
        pSubq.selFlags |= (uint)(0x1000000);
        while ((pSubq) != null)
        {
            SubstContext x = new SubstContext();
            pNew = sqlite3ExprDup(pParse.db, pWhere, (int)(0));
            unsetJoinExpr(pNew, (int)(-1));
            x.pParse = pParse;
            x.iTable = (int)(iCursor);
            x.iNewTable = (int)(iCursor);
            x.isLeftJoin = (int)(0);
            x.pEList = pSubq.pEList;
            pNew = substExpr(x, pNew);
            if (((pSubq.pWin) != null) &amp;&amp; ((0) == (pushDownWindowCheck(pParse, pSubq, pNew))))
            {
                sqlite3ExprDelete(pParse.db, pNew);
                nChng--;
                break;
            }

            if ((pSubq.selFlags &amp; 0x0000008) != 0)
            {
                pSubq.pHaving = sqlite3ExprAnd(pParse, pSubq.pHaving, pNew);
            }
            else
            {
                pSubq.pWhere = sqlite3ExprAnd(pParse, pSubq.pWhere, pNew);
            }

            pSubq = pSubq.pPrior;
        }
    }

    return (int)(nChng);
}</function>
  <function>public static int pushDownWindowCheck(Parse pParse, Select pSubq, Expr pExpr)
{
    return (int)(sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq.pWin.pPartition));
}</function>
  <function>public static void pushOntoSorter(Parse pParse, SortCtx pSort, Select pSelect, int regData, int regOrigData, int nData, int nPrefixReg)
{
    Vdbe v = pParse.pVdbe;
    int bSeq = (int)(((pSort.sortFlags &amp; 0x01) == (0)) ? 1 : 0);
    int nExpr = (int)(pSort.pOrderBy.nExpr);
    int nBase = (int)(nExpr + bSeq + nData);
    int regBase = 0;
    int regRecord = (int)(0);
    int nOBSat = (int)(pSort.nOBSat);
    int op = 0;
    int iLimit = 0;
    int iSkip = (int)(0);
    if ((nPrefixReg) != 0)
    {
        regBase = (int)(regData - nPrefixReg);
    }
    else
    {
        regBase = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nBase);
    }

    iLimit = (int)((pSelect.iOffset) != 0 ? pSelect.iOffset + 1 : pSelect.iLimit);
    pSort.labelDone = (int)(sqlite3VdbeMakeLabel(pParse));
    sqlite3ExprCodeExprList(pParse, pSort.pOrderBy, (int)(regBase), (int)(regOrigData), (byte)(0x01 | ((regOrigData) != 0 ? 0x04 : 0)));
    if ((bSeq) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(125), (int)(pSort.iECursor), (int)(regBase + nExpr));
    }

    if (((nPrefixReg) == (0)) &amp;&amp; ((nData) &gt; (0)))
    {
        sqlite3ExprCodeMove(pParse, (int)(regData), (int)(regBase + nExpr + bSeq), (int)(nData));
    }

    if ((nOBSat) &gt; (0))
    {
        int regPrevKey = 0;
        int addrFirst = 0;
        int addrJmp = 0;
        VdbeOp* pOp;
        int nKey = 0;
        KeyInfo pKI;
        regRecord = (int)(makeSorterRecord(pParse, pSort, pSelect, (int)(regBase), (int)(nBase)));
        regPrevKey = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(pSort.nOBSat);
        nKey = (int)(nExpr - pSort.nOBSat + bSeq);
        if ((bSeq) != 0)
        {
            addrFirst = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regBase + nExpr)));
        }
        else
        {
            addrFirst = (int)(sqlite3VdbeAddOp1(v, (int)(119), (int)(pSort.iECursor)));
        }

        sqlite3VdbeAddOp3(v, (int)(89), (int)(regPrevKey), (int)(regBase), (int)(pSort.nOBSat));
        pOp = sqlite3VdbeGetOp(v, (int)(pSort.addrSortIndex));
        if ((pParse.db.mallocFailed) != 0)
            return;
        pOp-&gt;p2 = (int)(nKey + nData);
        pKI = pOp-&gt;p4.pKeyInfo;
        CRuntime.memset(pKI.aSortFlags, (int)(0), (ulong)(pKI.nKeyField));
        sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pKI), (int)(-9));
        pOp-&gt;p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pSort.pOrderBy, (int)(nOBSat), (int)(pKI.nAllField - pKI.nKeyField - 1));
        pOp = null;
        addrJmp = (int)(sqlite3VdbeCurrentAddr(v));
        sqlite3VdbeAddOp3(v, (int)(16), (int)(addrJmp + 1), (int)(0), (int)(addrJmp + 1));
        pSort.labelBkOut = (int)(sqlite3VdbeMakeLabel(pParse));
        pSort.regReturn = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(12), (int)(pSort.regReturn), (int)(pSort.labelBkOut));
        sqlite3VdbeAddOp1(v, (int)(145), (int)(pSort.iECursor));
        if ((iLimit) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(20), (int)(iLimit), (int)(pSort.labelDone));
        }

        sqlite3VdbeJumpHere(v, (int)(addrFirst));
        sqlite3ExprCodeMove(pParse, (int)(regBase), (int)(regPrevKey), (int)(pSort.nOBSat));
        sqlite3VdbeJumpHere(v, (int)(addrJmp));
    }

    if ((iLimit) != 0)
    {
        int iCsr = (int)(pSort.iECursor);
        sqlite3VdbeAddOp2(v, (int)(59), (int)(iLimit), (int)(sqlite3VdbeCurrentAddr(v) + 4));
        sqlite3VdbeAddOp2(v, (int)(34), (int)(iCsr), (int)(0));
        iSkip = (int)(sqlite3VdbeAddOp4Int(v, (int)(39), (int)(iCsr), (int)(0), (int)(regBase + nOBSat), (int)(nExpr - nOBSat)));
        sqlite3VdbeAddOp1(v, (int)(129), (int)(iCsr));
    }

    if ((regRecord) == (0))
    {
        regRecord = (int)(makeSorterRecord(pParse, pSort, pSelect, (int)(regBase), (int)(nBase)));
    }

    if ((pSort.sortFlags &amp; 0x01) != 0)
    {
        op = (int)(138);
    }
    else
    {
        op = (int)(137);
    }

    sqlite3VdbeAddOp4Int(v, (int)(op), (int)(pSort.iECursor), (int)(regRecord), (int)(regBase + nOBSat), (int)(nBase - nOBSat));
    if ((iSkip) != 0)
    {
        sqlite3VdbeChangeP2(v, (int)(iSkip), (int)((pSort.labelOBLopt) != 0 ? pSort.labelOBLopt : sqlite3VdbeCurrentAddr(v)));
    }
}</function>
  <function>public static int putVarint64(byte* p, ulong v)
{
    int i = 0; int  j  =  0 ;  int  n  =  0 ; 
    byte* buf = stackalloc byte[10];
    if ((v &amp; (((ulong)(0xff000000)) &lt;&lt; 32)) != 0)
    {
        p[8] = ((byte)(v));
        v &gt;&gt;= 8;
        for (i = (int)(7); (i) &gt;= (0); i--)
        {
            p[i] = ((byte)((v &amp; 0x7f) | 0x80));
            v &gt;&gt;= 7;
        }

        return (int)(9);
    }

    n = (int)(0);
    do
    {
        buf[n++] = ((byte)((v &amp; 0x7f) | 0x80));
        v &gt;&gt;= 7;
    }
    while (v != 0);
    buf[0] &amp;= (byte)(0x7f);
    for (i = (int)(0), j = (int)(n - 1); (j) &gt;= (0); j--, i++)
    {
        p[i] = (byte)(buf[j]);
    }

    return (int)(n);
}</function>
  <function>public static int querySharedCacheTableLock(Btree p, uint iTab, byte eLock)
{
    BtShared pBt = p.pBt;
    BtLock pIter;
    if (p.sharable == 0)
    {
        return (int)(0);
    }

    if ((pBt.pWriter != p) &amp;&amp; ((pBt.btsFlags &amp; 0x0040) != 0))
    {
        return (int)(6 | (1 &lt;&lt; 8));
    }

    for (pIter = pBt.pLock; pIter; pIter = pIter.pNext)
    {
        if (((pIter.pBtree != p) &amp;&amp; ((pIter.iTable) == (iTab))) &amp;&amp; (pIter.eLock != eLock))
        {
            if ((eLock) == (2))
            {
                pBt.btsFlags |= (ushort)(0x0080);
            }

            return (int)(6 | (1 &lt;&lt; 8));
        }
    }

    return (int)(0);
}</function>
  <function>public static void quoteFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    sqlite3_str str = new sqlite3_str();
    sqlite3 db = sqlite3_context_db_handle(context);
    sqlite3StrAccumInit(str, db, null, (int)(0), (int)(db.aLimit[0]));
    sqlite3QuoteValue(str, argv[0]);
    sqlite3_result_text(context, sqlite3StrAccumFinish(str), (int)(str.nChar), ((Void(Void * ))(sqlite3OomFault)));
    if (str.accError != 0)
    {
        sqlite3_result_null(context);
        sqlite3_result_error_code(context, (int)(str.accError));
    }
}</function>
  <function>public static void randomBlob(sqlite3_context context, int argc, sqlite3_value argv)
{
    long n = 0;
    byte* p;
    n = (long)(sqlite3_value_int64(argv[0]));
    if ((n) &lt; (1))
    {
        n = (long)(1);
    }

    p = contextMalloc(context, (long)(n));
    if ((p) != null)
    {
        sqlite3_randomness((int)(n), p);
        sqlite3_result_blob(context, (sbyte*)(p), (int)(n), sqlite3_free);
    }
}</function>
  <function>public static void randomFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    long r = 0;
    sqlite3_randomness((int)(sizeof(long)), &amp;r);
    if ((r) &lt; (0))
    {
        r = (long)(-(r &amp; (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))));
    }

    sqlite3_result_int64(context, (long)(r));
}</function>
  <function>public static void rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
    {
        p-&gt;nStep++;
        if ((p-&gt;nValue) == (0))
        {
            p-&gt;nValue = (long)(p-&gt;nStep);
        }
    }
}</function>
  <function>public static void rankValueFunc(sqlite3_context pCtx)
{
    CallCount* p;
    p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
    if ((p) != null)
    {
        sqlite3_result_int64(pCtx, (long)(p-&gt;nValue));
        p-&gt;nValue = (long)(0);
    }
}</function>
  <function>public static int read32bits(sqlite3_file fd, long offset, uint* pRes)
{
    byte* ac = stackalloc byte[4];
    int rc = (int)(sqlite3OsRead(fd, ac, (int)(4 * sizeof(byte)), (long)(offset)));
    if ((rc) == (0))
    {
        *pRes = (uint)(sqlite3Get4byte(ac));
    }

    return (int)(rc);
}</function>
  <function>public static int readDbPage(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    int rc = (int)(0);
    uint iFrame = (uint)(0);
    if (((pPager).pWal != null))
    {
        rc = (int)(sqlite3WalFindFrame(pPager.pWal, (uint)(pPg.pgno), &amp;iFrame));
        if ((rc) != 0)
            return (int)(rc);
    }

    if ((iFrame) != 0)
    {
        rc = (int)(sqlite3WalReadFrame(pPager.pWal, (uint)(iFrame), (int)(pPager.pageSize), pPg.pData));
    }
    else
    {
        long iOffset = (long)((pPg.pgno - 1) * pPager.pageSize);
        rc = (int)(sqlite3OsRead(pPager.fd, pPg.pData, (int)(pPager.pageSize), (long)(iOffset)));
        if ((rc) == (10 | (2 &lt;&lt; 8)))
        {
            rc = (int)(0);
        }
    }

    if ((pPg.pgno) == (1))
    {
        if ((rc) != 0)
        {
            CRuntime.memset(pPager.dbFileVers, (int)(0xff), (ulong)(16 * sizeof(sbyte)));
        }
        else
        {
            byte* dbFileVers = &amp;((byte*)(pPg.pData))[24];
            CRuntime.memcpy(&amp;pPager.dbFileVers, dbFileVers, (ulong)(16 * sizeof(sbyte)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int readJournalHdr(Pager pPager, int isHot, long journalSize, uint* pNRec, uint* pDbSize)
{
    int rc = 0;
    byte* aMagic = stackalloc byte[8];
    long iHdrOff = 0;
    pPager.journalOff = (long)(journalHdrOffset(pPager));
    if ((pPager.journalOff + (pPager.sectorSize)) &gt; (journalSize))
    {
        return (int)(101);
    }

    iHdrOff = (long)(pPager.journalOff);
    if (((isHot) != 0) || (iHdrOff != pPager.journalHdr))
    {
        rc = (int)(sqlite3OsRead(pPager.jfd, aMagic, (int)(8 * sizeof(byte)), (long)(iHdrOff)));
        if ((rc) != 0)
        {
            return (int)(rc);
        }

        if (memcmp(aMagic, aJournalMagic, (ulong)(8 * sizeof(byte))) != 0)
        {
            return (int)(101);
        }
    }

    if (((0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 8), pNRec)))) || (0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 12), &amp;pPager.cksumInit))))) || (0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 16), pDbSize)))))
    {
        return (int)(rc);
    }

    if ((pPager.journalOff) == (0))
    {
        uint iPageSize = 0;
        uint iSectorSize = 0;
        if ((0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 20), &amp;iSectorSize)))) || (0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 24), &amp;iPageSize)))))
        {
            return (int)(rc);
        }

        if ((iPageSize) == (0))
        {
            iPageSize = (uint)(pPager.pageSize);
        }

        if (((((((iPageSize) &lt; (512)) || ((iSectorSize) &lt; (32))) || ((iPageSize) &gt; (65536))) || ((iSectorSize) &gt; (0x10000))) || (((iPageSize - 1) &amp; iPageSize) != 0)) || (((iSectorSize - 1) &amp; iSectorSize) != 0))
        {
            return (int)(101);
        }

        rc = (int)(sqlite3PagerSetPagesize(pPager, &amp;iPageSize, (int)(-1)));
        pPager.sectorSize = (uint)(iSectorSize);
    }

    pPager.journalOff += (long)(pPager.sectorSize);
    return (int)(rc);
}</function>
  <function>public static int readsTable(Parse p, int iDb, Table pTab)
{
    Vdbe v = sqlite3GetVdbe(p);
    int i = 0;
    int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
    VTable pVTab = (((pTab).eTabType) == (1)) ? sqlite3GetVTable(p.db, pTab) : null;
    for (i = (int)(1); (i) &lt; (iEnd); i++)
    {
        VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(i));
        if (((pOp-&gt;opcode) == (101)) &amp;&amp; ((pOp-&gt;p3) == (iDb)))
        {
            Index pIndex;
            uint tnum = (uint)(pOp-&gt;p2);
            if ((tnum) == (pTab.tnum))
            {
                return (int)(1);
            }

            for (pIndex = pTab.pIndex; pIndex; pIndex = pIndex.pNext)
            {
                if ((tnum) == (pIndex.tnum))
                {
                    return (int)(1);
                }
            }
        }

        if (((pOp-&gt;opcode) == (172)) &amp;&amp; ((pOp-&gt;p4.pVtab) == (pVTab)))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int readSuperJournal(sqlite3_file pJrnl, sbyte* zSuper, uint nSuper)
{
    int rc = 0;
    uint len = 0;
    long szJ = 0;
    uint cksum = 0;
    uint u = 0;
    byte* aMagic = stackalloc byte[8];
    zSuper[0] = (sbyte)(0);
    if ((((((((((0 != (rc = (int)(sqlite3OsFileSize(pJrnl, &amp;szJ)))) || ((szJ) &lt; (16))) || (0 != (rc = (int)(read32bits(pJrnl, (long)(szJ - 16), &amp;len))))) || ((len) &gt;= (nSuper))) || ((len) &gt; (szJ - 16))) || ((len) == (0))) || (0 != (rc = (int)(read32bits(pJrnl, (long)(szJ - 12), &amp;cksum))))) || (0 != (rc = (int)(sqlite3OsRead(pJrnl, aMagic, (int)(8), (long)(szJ - 8)))))) || ((memcmp(aMagic, aJournalMagic, (ulong)(8))) != 0)) || (0 != (rc = (int)(sqlite3OsRead(pJrnl, zSuper, (int)(len), (long)(szJ - 16 - len))))))
    {
        return (int)(rc);
    }

    for (u = (uint)(0); (u) &lt; (len); u++)
    {
        cksum -= (uint)(zSuper[u]);
    }

    if ((cksum) != 0)
    {
        len = (uint)(0);
    }

    zSuper[len] = (sbyte)(0);
    zSuper[len + 1] = (sbyte)(0);
    return (int)(0);
}</function>
  <function>public static int rebuildPage(CellArray pCArray, int iFirst, int nCell, MemPage pPg)
{
    int hdr = (int)(pPg.hdrOffset);
    byte* aData = pPg.aData;
    int usableSize = (int)(pPg.pBt.usableSize);
    byte* pEnd = &amp;aData[usableSize];
    int i = (int)(iFirst);
    uint j = 0;
    int iEnd = (int)(i + nCell);
    byte* pCellptr = pPg.aCellIdx;
    byte* pTmp = sqlite3PagerTempSpace(pPg.pBt.pPager);
    byte* pData;
    int k = 0;
    byte* pSrcEnd;
    j = (uint)((&amp;aData[hdr + 5])[0] &lt;&lt; 8 | (&amp;aData[hdr + 5])[1]);
    if ((j) &gt; ((uint)(usableSize)))
    {
        j = (uint)(0);
    }

    CRuntime.memcpy(&amp;pTmp[j], &amp;aData[j], (ulong)(usableSize - j));
    for (k = (int)(0); ((pCArray.ixNx[k]) &lt;= (i)) &amp;&amp; ((k) &lt; (3 * 2)); k++)
    {
    }

    pSrcEnd = pCArray.apEnd[k];
    pData = pEnd;
    while ((1) != 0)
    {
        byte* pCell = pCArray.apCell[i];
        ushort sz = (ushort)(pCArray.szCell[i]);
        if (((((ulong)(pCell)) &gt;= ((ulong)(aData + j))) &amp;&amp; (((ulong)(pCell)) &lt; ((ulong)(pEnd)))))
        {
            if (((ulong)(pCell + sz)) &gt; ((ulong)(pEnd)))
                return (int)(sqlite3CorruptError((int)(73321)));
            pCell = &amp;pTmp[pCell - aData];
        }
        else if ((((ulong)(pCell + sz)) &gt; ((ulong)(pSrcEnd))) &amp;&amp; (((ulong)(pCell)) &lt; ((ulong)(pSrcEnd))))
        {
            return (int)(sqlite3CorruptError((int)(73326)));
        }

        pData -= sz;
        ((pCellptr)[0] = ((byte)((pData - aData) &gt;&gt; 8)), (pCellptr)[1] = ((byte)(pData - aData)));
        pCellptr += 2;
        if ((pData) &lt; (pCellptr))
            return (int)(sqlite3CorruptError((int)(73332)));
        CRuntime.memmove(pData, pCell, (ulong)(sz));
        i++;
        if ((i) &gt;= (iEnd))
            break;
        if ((pCArray.ixNx[k]) &lt;= (i))
        {
            k++;
            pSrcEnd = pCArray.apEnd[k];
        }
    }

    pPg.nCell = (ushort)(nCell);
    pPg.nOverflow = (byte)(0);
    ((&amp;aData[hdr + 1])[0] = ((byte)((0) &gt;&gt; 8)), (&amp;aData[hdr + 1])[1] = ((byte)(0)));
    ((&amp;aData[hdr + 3])[0] = ((byte)((pPg.nCell) &gt;&gt; 8)), (&amp;aData[hdr + 3])[1] = ((byte)(pPg.nCell)));
    ((&amp;aData[hdr + 5])[0] = ((byte)((pData - aData) &gt;&gt; 8)), (&amp;aData[hdr + 5])[1] = ((byte)(pData - aData)));
    aData[hdr + 7] = (byte)(0x00);
    return (int)(0);
}</function>
  <function>public static void recomputeColumnsNotIndexed(Index pIdx)
{
    ulong m = (ulong)(0);
    int j = 0;
    Table pTab = pIdx.pTable;
    for (j = (int)(pIdx.nColumn - 1); (j) &gt;= (0); j--)
    {
        int x = (int)(pIdx.aiColumn[j]);
        if (((x) &gt;= (0)) &amp;&amp; ((pTab.aCol[x].colFlags &amp; 0x0020) == (0)))
        {
            if ((x) &lt; (((int)(sizeof(ulong) * 8)) - 1))
                m |= (ulong)(((ulong)(1)) &lt;&lt; (x));
        }
    }

    pIdx.colNotIdxed = (ulong)(~m);
}</function>
  <function>public static void recomputeColumnsUsed(Select pSelect, SrcItem pSrcItem)
{
    Walker w = new Walker();
    if (((pSrcItem.pTab) == (null)))
        return;
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    w.xExprCallback = recomputeColumnsUsedExpr;
    w.xSelectCallback = sqlite3SelectWalkNoop;
    w.u.pSrcItem = pSrcItem;
    pSrcItem.colUsed = (ulong)(0);
    sqlite3WalkSelect(w, pSelect);
}</function>
  <function>public static int recomputeColumnsUsedExpr(Walker pWalker, Expr pExpr)
{
    SrcItem pItem;
    if (pExpr.op != 167)
        return (int)(0);
    pItem = pWalker.u.pSrcItem;
    if (pItem.iCursor != pExpr.iTable)
        return (int)(0);
    if ((pExpr.iColumn) &lt; (0))
        return (int)(0);
    pItem.colUsed |= (ulong)(sqlite3ExprColUsed(pExpr));
    return (int)(0);
}</function>
  <function>public static int rehash(Hash* pH, uint new_size)
{
    _ht* new_ht;
    HashElem* elem; HashElem * next_elem ; 
    if ((new_size * sizeof(_ht)) &gt; (1024))
    {
        new_size = (uint)(1024 / sizeof(_ht));
    }

    if ((new_size) == (pH-&gt;htsize))
        return (int)(0);
    sqlite3BeginBenignMalloc();
    new_ht = (_ht*)(sqlite3Malloc((ulong)(new_size * sizeof(_ht))));
    sqlite3EndBenignMalloc();
    if ((new_ht) == (null))
        return (int)(0);
    sqlite3_free(pH-&gt;ht);
    pH-&gt;ht = new_ht;
    pH-&gt;htsize = (uint)(new_size = (uint)(sqlite3MallocSize(new_ht) / sizeof(_ht)));
    CRuntime.memset(new_ht, (int)(0), (ulong)(new_size * sizeof(_ht)));
    for (elem = pH-&gt;first, pH-&gt;first = null; elem; elem = next_elem)
    {
        uint h = (uint)(strHash(elem-&gt;pKey) % new_size);
        next_elem = elem-&gt;next;
        insertElement(pH, &amp;new_ht[h], elem);
    }

    return (int)(1);
}</function>
  <function>public static void reindexDatabases(Parse pParse, sbyte* zColl)
{
    Db pDb;
    int iDb = 0;
    sqlite3 db = pParse.db;
    HashElem* k;
    Table pTab;
    for (iDb = (int)(0), pDb = db.aDb; (iDb) &lt; (db.nDb); iDb++, pDb++)
    {
        for (k = ((&amp;pDb.pSchema.tblHash)-&gt;first); k; k = ((k)-&gt;next))
        {
            pTab = (Table)((k)-&gt;data);
            reindexTable(pParse, pTab, zColl);
        }
    }
}</function>
  <function>public static void reindexTable(Parse pParse, Table pTab, sbyte* zColl)
{
    if (!(((pTab).eTabType) == (1)))
    {
        Index pIndex;
        for (pIndex = pTab.pIndex; pIndex; pIndex = pIndex.pNext)
        {
            if (((zColl) == (null)) || ((collationMatch(zColl, pIndex)) != 0))
            {
                int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
                sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
                sqlite3RefillIndex(pParse, pIndex, (int)(-1));
            }
        }
    }
}</function>
  <function>public static void releaseAllSavepoints(Pager pPager)
{
    int ii = 0;
    for (ii = (int)(0); (ii) &lt; (pPager.nSavepoint); ii++)
    {
        sqlite3BitvecDestroy(pPager.aSavepoint[ii].pInSavepoint);
    }

    if ((pPager.exclusiveMode == 0) || ((sqlite3JournalIsInMemory(pPager.sjfd)) != 0))
    {
        sqlite3OsClose(pPager.sjfd);
    }

    sqlite3_free(pPager.aSavepoint);
    pPager.aSavepoint = null;
    pPager.nSavepoint = (int)(0);
    pPager.nSubRec = (uint)(0);
}</function>
  <function>public static void releaseMemArray(sqlite3_value p, int N)
{
    if (((p) != null) &amp;&amp; ((N) != 0))
    {
        sqlite3_value pEnd = p[N];
        sqlite3 db = p.db;
        if ((db.pnBytesFreed) != null)
        {
            do
            {
                if ((p.szMalloc) != 0)
                    sqlite3DbFree(db, p.zMalloc);
            }
            while ((++p) &lt; (pEnd));
            return;
        }

        do
        {
            if ((p.flags &amp; (0x2000 | 0x0400)) != 0)
            {
                sqlite3VdbeMemRelease(p);
            }
            else if ((p.szMalloc) != 0)
            {
                sqlite3DbFreeNN(db, p.zMalloc);
                p.szMalloc = (int)(0);
            }

            p.flags = (ushort)(0x0080);
        }
        while ((++p) &lt; (pEnd));
    }
}</function>
  <function>public static void releasePage(MemPage pPage)
{
    if ((pPage) != null)
        releasePageNotNull(pPage);
}</function>
  <function>public static void releasePageNotNull(MemPage pPage)
{
    sqlite3PagerUnrefNotNull(pPage.pDbPage);
}</function>
  <function>public static void releasePageOne(MemPage pPage)
{
    sqlite3PagerUnrefPageOne(pPage.pDbPage);
}</function>
  <function>public static int relocatePage(BtShared pBt, MemPage pDbPage, byte eType, uint iPtrPage, uint iFreePage, int isCommit)
{
    MemPage pPtrPage;
    uint iDbPage = (uint)(pDbPage.pgno);
    Pager pPager = pBt.pPager;
    int rc = 0;
    if ((iDbPage) &lt; (3))
        return (int)(sqlite3CorruptError((int)(69895)));
    rc = (int)(sqlite3PagerMovepage(pPager, pDbPage.pDbPage, (uint)(iFreePage), (int)(isCommit)));
    if (rc != 0)
    {
        return (int)(rc);
    }

    pDbPage.pgno = (uint)(iFreePage);
    if (((eType) == (5)) || ((eType) == (1)))
    {
        rc = (int)(setChildPtrmaps(pDbPage));
        if (rc != 0)
        {
            return (int)(rc);
        }
    }
    else
    {
        uint nextOvfl = (uint)(sqlite3Get4byte(pDbPage.aData));
        if (nextOvfl != 0)
        {
            ptrmapPut(pBt, (uint)(nextOvfl), (byte)(4), (uint)(iFreePage), &amp;rc);
            if (rc != 0)
            {
                return (int)(rc);
            }
        }
    }

    if (eType != 1)
    {
        rc = (int)(btreeGetPage(pBt, (uint)(iPtrPage), pPtrPage, (int)(0)));
        if (rc != 0)
        {
            return (int)(rc);
        }

        rc = (int)(sqlite3PagerWrite(pPtrPage.pDbPage));
        if (rc != 0)
        {
            releasePage(pPtrPage);
            return (int)(rc);
        }

        rc = (int)(modifyPagePointer(pPtrPage, (uint)(iDbPage), (uint)(iFreePage), (byte)(eType)));
        releasePage(pPtrPage);
        if ((rc) == (0))
        {
            ptrmapPut(pBt, (uint)(iFreePage), (byte)(eType), (uint)(iPtrPage), &amp;rc);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void removeElementGivenHash(Hash* pH, HashElem* elem, uint h)
{
    _ht* pEntry;
    if ((elem-&gt;prev) != null)
    {
        elem-&gt;prev-&gt;next = elem-&gt;next;
    }
    else
    {
        pH-&gt;first = elem-&gt;next;
    }

    if ((elem-&gt;next) != null)
    {
        elem-&gt;next-&gt;prev = elem-&gt;prev;
    }

    if ((pH-&gt;ht) != null)
    {
        pEntry = &amp;pH-&gt;ht[h];
        if ((pEntry-&gt;chain) == (elem))
        {
            pEntry-&gt;chain = elem-&gt;next;
        }

        pEntry-&gt;count--;
    }

    sqlite3_free(elem);
    pH-&gt;count--;
    if ((pH-&gt;count) == (0))
    {
        sqlite3HashClear(pH);
    }
}</function>
  <function>public static int removeFromSharingList(BtShared pBt)
{
    sqlite3_mutex* pMainMtx;
    BtShared pList;
    int removed = (int)(0);
    pMainMtx = sqlite3MutexAlloc((int)(2));
    sqlite3_mutex_enter(pMainMtx);
    pBt.nRef--;
    if ((pBt.nRef) &lt;= (0))
    {
        if ((sqlite3SharedCacheList) == (pBt))
        {
            sqlite3SharedCacheList = pBt.pNext;
        }
        else
        {
            pList = sqlite3SharedCacheList;
            while (((pList) != null) &amp;&amp; (pList.pNext != pBt))
            {
                pList = pList.pNext;
            }

            if ((pList) != null)
            {
                pList.pNext = pBt.pNext;
            }
        }

        if ((1) != 0)
        {
            sqlite3_mutex_free(pBt.mutex);
        }

        removed = (int)(1);
    }

    sqlite3_mutex_leave(pMainMtx);
    return (int)(removed);
}</function>
  <function>public static Expr removeUnindexableInClauseTerms(Parse pParse, int iEq, WhereLoop pLoop, Expr pX)
{
    sqlite3 db = pParse.db;
    Expr pNew;
    pNew = sqlite3ExprDup(db, pX, (int)(0));
    if ((db.mallocFailed) == (0))
    {
        ExprList pOrigRhs;
        ExprList pOrigLhs;
        ExprList pRhs = null;
        ExprList pLhs = null;
        int i = 0;
        Select pSelect;
        pOrigRhs = pNew.x.pSelect.pEList;
        pOrigLhs = pNew.pLeft.x.pList;
        for (i = (int)(iEq); (i) &lt; (pLoop.nLTerm); i++)
        {
            if ((pLoop.aLTerm[i].pExpr) == (pX))
            {
                int iField = 0;
                iField = (int)(pLoop.aLTerm[i].u.x.iField - 1);
                if ((pOrigRhs.a[iField].pExpr) == (null))
                    continue;
                pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs.a[iField].pExpr);
                pOrigRhs.a[iField].pExpr = null;
                pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs.a[iField].pExpr);
                pOrigLhs.a[iField].pExpr = null;
            }
        }

        sqlite3ExprListDelete(db, pOrigRhs);
        sqlite3ExprListDelete(db, pOrigLhs);
        pNew.pLeft.x.pList = pLhs;
        pNew.x.pSelect.pEList = pRhs;
        if (((pLhs) != null) &amp;&amp; ((pLhs.nExpr) == (1)))
        {
            Expr p = pLhs.a[0].pExpr;
            pLhs.a[0].pExpr = null;
            sqlite3ExprDelete(db, pNew.pLeft);
            pNew.pLeft = p;
        }

        pSelect = pNew.x.pSelect;
        if ((pSelect.pOrderBy) != null)
        {
            ExprList pOrderBy = pSelect.pOrderBy;
            for (i = (int)(0); (i) &lt; (pOrderBy.nExpr); i++)
            {
                pOrderBy.a[i].u.x.iOrderByCol = (ushort)(0);
            }
        }
    }

    return pNew;
}</function>
  <function>public static void renameColumnElistNames(Parse pParse, RenameCtx pCtx, ExprList pEList, sbyte* zOld)
{
    if ((pEList) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
        {
            sbyte* zName = pEList.a[i].zEName;
            if ((((pEList.a[i].eEName) == (0)) &amp;&amp; (zName != null)) &amp;&amp; ((0) == (sqlite3_stricmp(zName, zOld))))
            {
                renameTokenFind(pParse, pCtx, (void*)(zName));
            }
        }
    }
}</function>
  <function>public static int renameColumnExprCb(Walker pWalker, Expr pExpr)
{
    RenameCtx p = pWalker.u.pRename;
    if ((((pExpr.op) == (77)) &amp;&amp; ((pExpr.iColumn) == (p.iCol))) &amp;&amp; ((pWalker.pParse.pTriggerTab) == (p.pTab)))
    {
        renameTokenFind(pWalker.pParse, p, (void*)(pExpr));
    }
    else if (((((pExpr.op) == (167)) &amp;&amp; ((pExpr.iColumn) == (p.iCol))) &amp;&amp; ((((pExpr).flags &amp; (0x1000000 | 0x2000000)) == (0)) != 0)) &amp;&amp; ((p.pTab) == (pExpr.y.pTab)))
    {
        renameTokenFind(pWalker.pParse, p, (void*)(pExpr));
    }

    return (int)(0);
}</function>
  <function>public static void renameColumnFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    RenameCtx sCtx = new RenameCtx();
    sbyte* zSql = (sbyte*)(sqlite3_value_text(argv[0]));
    sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[3]));
    sbyte* zTable = (sbyte*)(sqlite3_value_text(argv[4]));
    int iCol = (int)(sqlite3_value_int(argv[5]));
    sbyte* zNew = (sbyte*)(sqlite3_value_text(argv[6]));
    int bQuote = (int)(sqlite3_value_int(argv[7]));
    int bTemp = (int)(sqlite3_value_int(argv[8]));
    sbyte* zOld;
    int rc = 0;
    Parse sParse = new Parse();
    Walker sWalker = new Walker();
    Index pIdx;
    int i = 0;
    Table pTab;
    delegate67 xAuth = db.xAuth;
    if ((zSql) == (null))
        return;
    if ((zTable) == (null))
        return;
    if ((zNew) == (null))
        return;
    if ((iCol) &lt; (0))
        return;
    sqlite3BtreeEnterAll(db);
    pTab = sqlite3FindTable(db, zTable, zDb);
    if (((pTab) == (null)) || ((iCol) &gt;= (pTab.nCol)))
    {
        sqlite3BtreeLeaveAll(db);
        return;
    }

    zOld = pTab.aCol[iCol].zCnName;
    CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
    sCtx.iCol = (int)(((iCol) == (pTab.iPKey)) ? -1 : iCol);
    db.xAuth = null;
    rc = (int)(renameParseSql(sParse, zDb, db, zSql, (int)(bTemp)));
    CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
    sWalker.pParse = sParse;
    sWalker.xExprCallback = renameColumnExprCb;
    sWalker.xSelectCallback = renameColumnSelectCb;
    sWalker.u.pRename = sCtx;
    sCtx.pTab = pTab;
    if (rc != 0)
        goto renameColumnFunc_done;
    if ((sParse.pNewTable) != null)
    {
        if ((((sParse.pNewTable).eTabType) == (2)))
        {
            Select pSelect = sParse.pNewTable.u.view.pSelect;
            pSelect.selFlags &amp;= (uint)(~0x0200000);
            sParse.rc = (int)(0);
            sqlite3SelectPrep(sParse, pSelect, null);
            rc = (int)((db.mallocFailed) != 0 ? 7 : sParse.rc);
            if ((rc) == (0))
            {
                sqlite3WalkSelect(sWalker, pSelect);
            }

            if (rc != 0)
                goto renameColumnFunc_done;
        }
        else if ((((sParse.pNewTable).eTabType) == (0)))
        {
            int bFKOnly = (int)(sqlite3_stricmp(zTable, sParse.pNewTable.zName));
            FKey pFKey;
            sCtx.pTab = sParse.pNewTable;
            if ((bFKOnly) == (0))
            {
                if ((iCol) &lt; (sParse.pNewTable.nCol))
                {
                    renameTokenFind(sParse, sCtx, (void*)(sParse.pNewTable.aCol[iCol].zCnName));
                }

                if ((sCtx.iCol) &lt; (0))
                {
                    renameTokenFind(sParse, sCtx, (void*)(&amp;sParse.pNewTable.iPKey));
                }

                sqlite3WalkExprList(sWalker, sParse.pNewTable.pCheck);
                for (pIdx = sParse.pNewTable.pIndex; pIdx; pIdx = pIdx.pNext)
                {
                    sqlite3WalkExprList(sWalker, pIdx.aColExpr);
                }

                for (pIdx = sParse.pNewIndex; pIdx; pIdx = pIdx.pNext)
                {
                    sqlite3WalkExprList(sWalker, pIdx.aColExpr);
                }

                for (i = (int)(0); (i) &lt; (sParse.pNewTable.nCol); i++)
                {
                    Expr pExpr = sqlite3ColumnExpr(sParse.pNewTable, &amp;sParse.pNewTable.aCol[i]);
                    sqlite3WalkExpr(sWalker, pExpr);
                }
            }

            for (pFKey = sParse.pNewTable.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
            {
                for (i = (int)(0); (i) &lt; (pFKey.nCol); i++)
                {
                    if (((bFKOnly) == (0)) &amp;&amp; ((pFKey.aCol[i].iFrom) == (iCol)))
                    {
                        renameTokenFind(sParse, sCtx, (void*)(&amp;pFKey.aCol[i]));
                    }

                    if (((0) == (sqlite3_stricmp(pFKey.zTo, zTable))) &amp;&amp; ((0) == (sqlite3_stricmp(pFKey.aCol[i].zCol, zOld))))
                    {
                        renameTokenFind(sParse, sCtx, (void*)(pFKey.aCol[i].zCol));
                    }
                }
            }
        }
    }
    else if ((sParse.pNewIndex) != null)
    {
        sqlite3WalkExprList(sWalker, sParse.pNewIndex.aColExpr);
        sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
    }
    else
    {
        TriggerStep pStep;
        rc = (int)(renameResolveTrigger(sParse));
        if (rc != 0)
            goto renameColumnFunc_done;
        for (pStep = sParse.pNewTrigger.step_list; pStep; pStep = pStep.pNext)
        {
            if ((pStep.zTarget) != null)
            {
                Table pTarget = sqlite3LocateTable(sParse, (uint)(0), pStep.zTarget, zDb);
                if ((pTarget) == (pTab))
                {
                    if ((pStep.pUpsert) != null)
                    {
                        ExprList pUpsertSet = pStep.pUpsert.pUpsertSet;
                        renameColumnElistNames(sParse, sCtx, pUpsertSet, zOld);
                    }

                    renameColumnIdlistNames(sParse, sCtx, pStep.pIdList, zOld);
                    renameColumnElistNames(sParse, sCtx, pStep.pExprList, zOld);
                }
            }
        }

        if ((sParse.pTriggerTab) == (pTab))
        {
            renameColumnIdlistNames(sParse, sCtx, sParse.pNewTrigger.pColumns, zOld);
        }

        renameWalkTrigger(sWalker, sParse.pNewTrigger);
    }

    rc = (int)(renameEditSql(context, sCtx, zSql, zNew, (int)(bQuote)));
    renameColumnFunc_done:
        ; if  ( rc != 0 ) { if  ( ( ( rc ) == ( 1 ) ) &amp;&amp; ( ( sqlite3WritableSchema ( db ) ) != 0 ) ) { sqlite3_result_value ( context ,  argv [ 0 ] ) ;  } else  if  ( ( sParse . zErrMsg ) != null ) { renameColumnParseError ( context ,  "" ,  argv [ 1 ] ,  argv [ 2 ] ,  sParse ) ;  } else  { sqlite3_result_error_code ( context ,  ( int ) ( rc ) ) ;  } }
    renameParseCleanup(sParse);
    renameTokenFree(db, sCtx.pList);
    db.xAuth = xAuth;
    sqlite3BtreeLeaveAll(db);
}</function>
  <function>public static void renameColumnIdlistNames(Parse pParse, RenameCtx pCtx, IdList* pIdList, sbyte* zOld)
{
    if ((pIdList) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pIdList-&gt;nId); i++)
        {
            sbyte* zName = pIdList-&gt;a[i].zName;
            if ((0) == (sqlite3_stricmp(zName, zOld)))
            {
                renameTokenFind(pParse, pCtx, (void*)(zName));
            }
        }
    }
}</function>
  <function>public static void renameColumnParseError(sqlite3_context pCtx, sbyte* zWhen, sqlite3_value pType, sqlite3_value pObject, Parse pParse)
{
    sbyte* zT = (sbyte*)(sqlite3_value_text(pType));
    sbyte* zN = (sbyte*)(sqlite3_value_text(pObject));
    sbyte* zErr;
    zErr = sqlite3MPrintf(pParse.db, "error in %s %s%s%s: %s", zT, zN, ((zWhen[0]) != 0 ? " " : ""), zWhen, pParse.zErrMsg);
    sqlite3_result_error(pCtx, zErr, (int)(-1));
    sqlite3DbFree(pParse.db, zErr);
}</function>
  <function>public static int renameColumnSelectCb(Walker pWalker, Select p)
{
    if ((p.selFlags &amp; (0x0200000 | 0x4000000)) != 0)
    {
        return (int)(1);
    }

    renameWalkWith(pWalker, p);
    return (int)(0);
}</function>
  <function>public static RenameToken* renameColumnTokenNext(RenameCtx pCtx)
{
    RenameToken* pBest = pCtx.pList;
    RenameToken* pToken;
    RenameToken** pp;
    for (pToken = pBest-&gt;pNext; pToken; pToken = pToken-&gt;pNext)
    {
        if ((pToken-&gt;t.z) &gt; (pBest-&gt;t.z))
            pBest = pToken;
    }

    for (pp = &amp;pCtx.pList; *pp != pBest; pp = &amp;(*pp)-&gt;pNext)
    {
    }

    *pp = pBest-&gt;pNext;
    return pBest;
}</function>
  <function>public static int renameEditSql(sqlite3_context pCtx, RenameCtx pRename, sbyte* zSql, sbyte* zNew, int bQuote)
{
    long nNew = (long)(sqlite3Strlen30(zNew));
    long nSql = (long)(sqlite3Strlen30(zSql));
    sqlite3 db = sqlite3_context_db_handle(pCtx);
    int rc = (int)(0);
    sbyte* zQuot = null;
    sbyte* zOut;
    long nQuot = (long)(0);
    sbyte* zBuf1 = null;
    sbyte* zBuf2 = null;
    if ((zNew) != null)
    {
        zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);
        if ((zQuot) == (null))
        {
            return (int)(7);
        }
        else
        {
            nQuot = (long)(sqlite3Strlen30(zQuot) - 1);
        }

        zOut = sqlite3DbMallocZero(db, (ulong)(nSql + pRename.nList * nQuot + 1));
    }
    else
    {
        zOut = (sbyte*)(sqlite3DbMallocZero(db, (ulong)((nSql * 2 + 1) * 3)));
        if ((zOut) != null)
        {
            zBuf1 = &amp;zOut[nSql * 2 + 1];
            zBuf2 = &amp;zOut[nSql * 4 + 2];
        }
    }

    if ((zOut) != null)
    {
        int nOut = (int)(nSql);
        CRuntime.memcpy(zOut, zSql, (ulong)(nSql));
        while ((pRename.pList) != null)
        {
            int iOff = 0;
            uint nReplace = 0;
            sbyte* zReplace;
            RenameToken* pBest = renameColumnTokenNext(pRename);
            if ((zNew) != null)
            {
                if (((bQuote) == (0)) &amp;&amp; ((sqlite3IsIdChar((byte)(*pBest-&gt;t.z))) != 0))
                {
                    nReplace = (uint)(nNew);
                    zReplace = zNew;
                }
                else
                {
                    nReplace = (uint)(nQuot);
                    zReplace = zQuot;
                    if ((pBest-&gt;t.z[pBest-&gt;t.n]) == (34))
                        nReplace++;
                }
            }
            else
            {
                CRuntime.memcpy(zBuf1, pBest-&gt;t.z, (ulong)(pBest-&gt;t.n));
                zBuf1[pBest-&gt;t.n] = (sbyte)(0);
                sqlite3Dequote(zBuf1);
                sqlite3_snprintf((int)(nSql * 2), zBuf2, "%Q%s", zBuf1, (pBest-&gt;t.z[pBest-&gt;t.n]) == (39) ? " " : "");
                zReplace = zBuf2;
                nReplace = (uint)(sqlite3Strlen30(zReplace));
            }

            iOff = (int)(pBest-&gt;t.z - zSql);
            if (pBest-&gt;t.n != nReplace)
            {
                CRuntime.memmove(&amp;zOut[iOff + nReplace], &amp;zOut[iOff + pBest-&gt;t.n], (ulong)(nOut - (iOff + pBest-&gt;t.n)));
                nOut += (int)(nReplace - pBest-&gt;t.n);
                zOut[nOut] = (sbyte)(0);
            }

            CRuntime.memcpy(&amp;zOut[iOff], zReplace, (ulong)(nReplace));
            sqlite3DbFree(db, pBest);
        }

        sqlite3_result_text(pCtx, zOut, (int)(-1), ((Void(Void * ))(-1)));
        sqlite3DbFree(db, zOut);
    }
    else
    {
        rc = (int)(7);
    }

    sqlite3_free(zQuot);
    return (int)(rc);
}</function>
  <function>public static void renameFixQuotes(Parse pParse, sbyte* zDb, int bTemp)
{
    sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_quotefix(%Q, sql)WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%'", zDb, zDb);
    if ((bTemp) == (0))
    {
        sqlite3NestedParse(pParse, "UPDATE temp.sqlite_master SET sql = sqlite_rename_quotefix('temp', sql)WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%'");
    }
}</function>
  <function>public static void renameParseCleanup(Parse pParse)
{
    sqlite3 db = pParse.db;
    Index pIdx;
    if ((pParse.pVdbe) != null)
    {
        sqlite3VdbeFinalize(pParse.pVdbe);
    }

    sqlite3DeleteTable(db, pParse.pNewTable);
    while ((pIdx = pParse.pNewIndex) != null)
    {
        pParse.pNewIndex = pIdx.pNext;
        sqlite3FreeIndex(db, pIdx);
    }

    sqlite3DeleteTrigger(db, pParse.pNewTrigger);
    sqlite3DbFree(db, pParse.zErrMsg);
    renameTokenFree(db, pParse.pRename);
    sqlite3ParseObjectReset(pParse);
}</function>
  <function>public static int renameParseSql(Parse p, sbyte* zDb, sqlite3 db, sbyte* zSql, int bTemp)
{
    int rc = 0;
    sqlite3ParseObjectInit(p, db);
    if ((zSql) == (null))
    {
        return (int)(7);
    }

    if (sqlite3_strnicmp(zSql, "CREATE ", (int)(7)) != 0)
    {
        return (int)(sqlite3CorruptError((int)(109974)));
    }

    db.init.iDb = (byte)((bTemp) != 0 ? 1 : sqlite3FindDbName(db, zDb));
    p.eParseMode = (byte)(2);
    p.db = db;
    p.nQueryLoop = (uint)(1);
    rc = (int)(sqlite3RunParser(p, zSql));
    if ((db.mallocFailed) != 0)
        rc = (int)(7);
    if (((rc) == (0)) &amp;&amp; ((((p.pNewTable) == (null)) &amp;&amp; ((p.pNewIndex) == (null))) &amp;&amp; ((p.pNewTrigger) == (null))))
    {
        rc = (int)(sqlite3CorruptError((int)(109985)));
    }

    db.init.iDb = (byte)(0);
    return (int)(rc);
}</function>
  <function>public static int renameQuotefixExprCb(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (117)) &amp;&amp; ((pExpr.flags &amp; 0x000040) != 0))
    {
        renameTokenFind(pWalker.pParse, pWalker.u.pRename, (void*)(pExpr));
    }

    return (int)(0);
}</function>
  <function>public static void renameQuotefixFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
    sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[1]));
    delegate67 xAuth = db.xAuth;
    db.xAuth = null;
    sqlite3BtreeEnterAll(db);
    if (((zDb) != null) &amp;&amp; ((zInput) != null))
    {
        int rc = 0;
        Parse sParse = new Parse();
        rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(0)));
        if ((rc) == (0))
        {
            RenameCtx sCtx = new RenameCtx();
            Walker sWalker = new Walker();
            CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
            CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
            sWalker.pParse = sParse;
            sWalker.xExprCallback = renameQuotefixExprCb;
            sWalker.xSelectCallback = renameColumnSelectCb;
            sWalker.u.pRename = sCtx;
            if ((sParse.pNewTable) != null)
            {
                if ((((sParse.pNewTable).eTabType) == (2)))
                {
                    Select pSelect = sParse.pNewTable.u.view.pSelect;
                    pSelect.selFlags &amp;= (uint)(~0x0200000);
                    sParse.rc = (int)(0);
                    sqlite3SelectPrep(sParse, pSelect, null);
                    rc = (int)((db.mallocFailed) != 0 ? 7 : sParse.rc);
                    if ((rc) == (0))
                    {
                        sqlite3WalkSelect(sWalker, pSelect);
                    }
                }
                else
                {
                    int i = 0;
                    sqlite3WalkExprList(sWalker, sParse.pNewTable.pCheck);
                    for (i = (int)(0); (i) &lt; (sParse.pNewTable.nCol); i++)
                    {
                        sqlite3WalkExpr(sWalker, sqlite3ColumnExpr(sParse.pNewTable, &amp;sParse.pNewTable.aCol[i]));
                    }
                }
            }
            else if ((sParse.pNewIndex) != null)
            {
                sqlite3WalkExprList(sWalker, sParse.pNewIndex.aColExpr);
                sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
            }
            else
            {
                rc = (int)(renameResolveTrigger(sParse));
                if ((rc) == (0))
                {
                    renameWalkTrigger(sWalker, sParse.pNewTrigger);
                }
            }

            if ((rc) == (0))
            {
                rc = (int)(renameEditSql(context, sCtx, zInput, null, (int)(0)));
            }

            renameTokenFree(db, sCtx.pList);
        }

        if (rc != 0)
        {
            if (((sqlite3WritableSchema(db)) != 0) &amp;&amp; ((rc) == (1)))
            {
                sqlite3_result_value(context, argv[1]);
            }
            else
            {
                sqlite3_result_error_code(context, (int)(rc));
            }
        }

        renameParseCleanup(sParse);
    }

    db.xAuth = xAuth;
    sqlite3BtreeLeaveAll(db);
}</function>
  <function>public static void renameReloadSchema(Parse pParse, int iDb, ushort p5)
{
    Vdbe v = pParse.pVdbe;
    if ((v) != null)
    {
        sqlite3ChangeCookie(pParse, (int)(iDb));
        sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, (int)(iDb), null, (ushort)(p5));
        if (iDb != 1)
            sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, (int)(1), null, (ushort)(p5));
    }
}</function>
  <function>public static int renameResolveTrigger(Parse pParse)
{
    sqlite3 db = pParse.db;
    Trigger pNew = pParse.pNewTrigger;
    TriggerStep pStep;
    NameContext sNC = new NameContext();
    int rc = (int)(0);
    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    sNC.pParse = pParse;
    pParse.pTriggerTab = sqlite3FindTable(db, pNew.table, db.aDb[sqlite3SchemaToIndex(db, pNew.pTabSchema)].zDbSName);
    pParse.eTriggerOp = (byte)(pNew.op);
    if ((pParse.pTriggerTab) != null)
    {
        rc = (int)(sqlite3ViewGetColumnNames(pParse, pParse.pTriggerTab));
    }

    if (((rc) == (0)) &amp;&amp; ((pNew.pWhen) != null))
    {
        rc = (int)(sqlite3ResolveExprNames(sNC, pNew.pWhen));
    }

    for (pStep = pNew.step_list; ((rc) == (0)) &amp;&amp; ((pStep) != null); pStep = pStep.pNext)
    {
        if ((pStep.pSelect) != null)
        {
            sqlite3SelectPrep(pParse, pStep.pSelect, sNC);
            if ((pParse.nErr) != 0)
                rc = (int)(pParse.rc);
        }

        if (((rc) == (0)) &amp;&amp; ((pStep.zTarget) != null))
        {
            SrcList pSrc = sqlite3TriggerStepSrc(pParse, pStep);
            if ((pSrc) != null)
            {
                int i = 0;
                for (i = (int)(0); ((i) &lt; (pSrc.nSrc)) &amp;&amp; ((rc) == (0)); i++)
                {
                    SrcItem p = pSrc.a[i];
                    p.iCursor = (int)(pParse.nTab++);
                    if ((p.pSelect) != null)
                    {
                        sqlite3SelectPrep(pParse, p.pSelect, null);
                        sqlite3ExpandSubquery(pParse, p);
                        sqlite3SelectPrep(pParse, pStep.pFrom.a[i - 1].pSelect, null);
                    }
                    else
                    {
                        p.pTab = sqlite3LocateTableItem(pParse, (uint)(0), p);
                        if ((p.pTab) == (null))
                        {
                            rc = (int)(1);
                        }
                        else
                        {
                            p.pTab.nTabRef++;
                            rc = (int)(sqlite3ViewGetColumnNames(pParse, p.pTab));
                        }
                    }
                }

                if (((rc) == (0)) &amp;&amp; ((db.mallocFailed) != 0))
                {
                    rc = (int)(7);
                }

                sNC.pSrcList = pSrc;
                if (((rc) == (0)) &amp;&amp; ((pStep.pWhere) != null))
                {
                    rc = (int)(sqlite3ResolveExprNames(sNC, pStep.pWhere));
                }

                if ((rc) == (0))
                {
                    rc = (int)(sqlite3ResolveExprListNames(sNC, pStep.pExprList));
                }

                if (((pStep.pUpsert) != null) &amp;&amp; ((rc) == (0)))
                {
                    Upsert pUpsert = pStep.pUpsert;
                    pUpsert.pUpsertSrc = pSrc;
                    sNC.uNC.pUpsert = pUpsert;
                    sNC.ncFlags = (int)(0x000200);
                    rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsert.pUpsertTarget));
                    if ((rc) == (0))
                    {
                        ExprList pUpsertSet = pUpsert.pUpsertSet;
                        rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsertSet));
                    }

                    if ((rc) == (0))
                    {
                        rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertWhere));
                    }

                    if ((rc) == (0))
                    {
                        rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertTargetWhere));
                    }

                    sNC.ncFlags = (int)(0);
                }

                sNC.pSrcList = null;
                sqlite3SrcListDelete(db, pSrc);
            }
            else
            {
                rc = (int)(7);
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static int renameTableExprCb(Walker pWalker, Expr pExpr)
{
    RenameCtx p = pWalker.u.pRename;
    if ((((pExpr.op) == (167)) &amp;&amp; ((((pExpr).flags &amp; (0x1000000 | 0x2000000)) == (0)) != 0)) &amp;&amp; ((p.pTab) == (pExpr.y.pTab)))
    {
        renameTokenFind(pWalker.pParse, p, (void*)(pExpr.y.pTab));
    }

    return (int)(0);
}</function>
  <function>public static void renameTableFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
    sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[3]));
    sbyte* zOld = (sbyte*)(sqlite3_value_text(argv[4]));
    sbyte* zNew = (sbyte*)(sqlite3_value_text(argv[5]));
    int bTemp = (int)(sqlite3_value_int(argv[6]));
    if ((((zInput) != null) &amp;&amp; ((zOld) != null)) &amp;&amp; ((zNew) != null))
    {
        Parse sParse = new Parse();
        int rc = 0;
        int bQuote = (int)(1);
        RenameCtx sCtx = new RenameCtx();
        Walker sWalker = new Walker();
        delegate67 xAuth = db.xAuth;
        db.xAuth = null;
        sqlite3BtreeEnterAll(db);
        CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
        sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
        CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
        sWalker.pParse = sParse;
        sWalker.xExprCallback = renameTableExprCb;
        sWalker.xSelectCallback = renameTableSelectCb;
        sWalker.u.pRename = sCtx;
        rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(bTemp)));
        if ((rc) == (0))
        {
            int isLegacy = (int)(db.flags &amp; 0x04000000);
            if ((sParse.pNewTable) != null)
            {
                Table pTab = sParse.pNewTable;
                if ((((pTab).eTabType) == (2)))
                {
                    if ((isLegacy) == (0))
                    {
                        Select pSelect = pTab.u.view.pSelect;
                        NameContext sNC = new NameContext();
                        CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
                        sNC.pParse = sParse;
                        pSelect.selFlags &amp;= (uint)(~0x0200000);
                        sqlite3SelectPrep(sParse, pTab.u.view.pSelect, sNC);
                        if ((sParse.nErr) != 0)
                        {
                            rc = (int)(sParse.rc);
                        }
                        else
                        {
                            sqlite3WalkSelect(sWalker, pTab.u.view.pSelect);
                        }
                    }
                }
                else
                {
                    if ((((isLegacy) == (0)) || ((db.flags &amp; 0x00004000) != 0)) &amp;&amp; (!(((pTab).eTabType) == (1))))
                    {
                        FKey pFKey;
                        for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
                        {
                            if ((sqlite3_stricmp(pFKey.zTo, zOld)) == (0))
                            {
                                renameTokenFind(sParse, sCtx, (void*)(pFKey.zTo));
                            }
                        }
                    }

                    if ((sqlite3_stricmp(zOld, pTab.zName)) == (0))
                    {
                        sCtx.pTab = pTab;
                        if ((isLegacy) == (0))
                        {
                            sqlite3WalkExprList(sWalker, pTab.pCheck);
                        }

                        renameTokenFind(sParse, sCtx, pTab.zName);
                    }
                }
            }
            else if ((sParse.pNewIndex) != null)
            {
                renameTokenFind(sParse, sCtx, sParse.pNewIndex.zName);
                if ((isLegacy) == (0))
                {
                    sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
                }
            }
            else
            {
                Trigger pTrigger = sParse.pNewTrigger;
                TriggerStep pStep;
                if (((0) == (sqlite3_stricmp(sParse.pNewTrigger.table, zOld))) &amp;&amp; ((sCtx.pTab.pSchema) == (pTrigger.pTabSchema)))
                {
                    renameTokenFind(sParse, sCtx, sParse.pNewTrigger.table);
                }

                if ((isLegacy) == (0))
                {
                    rc = (int)(renameResolveTrigger(sParse));
                    if ((rc) == (0))
                    {
                        renameWalkTrigger(sWalker, pTrigger);
                        for (pStep = pTrigger.step_list; pStep; pStep = pStep.pNext)
                        {
                            if (((pStep.zTarget) != null) &amp;&amp; ((0) == (sqlite3_stricmp(pStep.zTarget, zOld))))
                            {
                                renameTokenFind(sParse, sCtx, pStep.zTarget);
                            }
                        }
                    }
                }
            }
        }

        if ((rc) == (0))
        {
            rc = (int)(renameEditSql(context, sCtx, zInput, zNew, (int)(bQuote)));
        }

        if (rc != 0)
        {
            if (((rc) == (1)) &amp;&amp; ((sqlite3WritableSchema(db)) != 0))
            {
                sqlite3_result_value(context, argv[3]);
            }
            else if ((sParse.zErrMsg) != null)
            {
                renameColumnParseError(context, "", argv[1], argv[2], sParse);
            }
            else
            {
                sqlite3_result_error_code(context, (int)(rc));
            }
        }

        renameParseCleanup(sParse);
        renameTokenFree(db, sCtx.pList);
        sqlite3BtreeLeaveAll(db);
        db.xAuth = xAuth;
    }

    return;
}</function>
  <function>public static int renameTableSelectCb(Walker pWalker, Select pSelect)
{
    int i = 0;
    RenameCtx p = pWalker.u.pRename;
    SrcList pSrc = pSelect.pSrc;
    if ((pSelect.selFlags &amp; (0x0200000 | 0x4000000)) != 0)
    {
        return (int)(1);
    }

    if (((pSrc) == (null)))
    {
        return (int)(2);
    }

    for (i = (int)(0); (i) &lt; (pSrc.nSrc); i++)
    {
        SrcItem pItem = pSrc.a[i];
        if ((pItem.pTab) == (p.pTab))
        {
            renameTokenFind(pWalker.pParse, p, pItem.zName);
        }
    }

    renameWalkWith(pWalker, pSelect);
    return (int)(0);
}</function>
  <function>public static void renameTableTest(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
    sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[1]));
    int bTemp = (int)(sqlite3_value_int(argv[4]));
    int isLegacy = (int)(db.flags &amp; 0x04000000);
    sbyte* zWhen = (sbyte*)(sqlite3_value_text(argv[5]));
    int bNoDQS = (int)(sqlite3_value_int(argv[6]));
    delegate67 xAuth = db.xAuth;
    db.xAuth = null;
    if (((zDb) != null) &amp;&amp; ((zInput) != null))
    {
        int rc = 0;
        Parse sParse = new Parse();
        int flags = (int)(db.flags);
        if ((bNoDQS) != 0)
            db.flags &amp;= (ulong)(~(0x40000000 | 0x20000000));
        rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(bTemp)));
        db.flags |= (ulong)(flags &amp; (0x40000000 | 0x20000000));
        if ((rc) == (0))
        {
            if ((((isLegacy) == (0)) &amp;&amp; ((sParse.pNewTable) != null)) &amp;&amp; (((sParse.pNewTable).eTabType) == (2)))
            {
                NameContext sNC = new NameContext();
                CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
                sNC.pParse = sParse;
                sqlite3SelectPrep(sParse, sParse.pNewTable.u.view.pSelect, sNC);
                if ((sParse.nErr) != 0)
                    rc = (int)(sParse.rc);
            }
            else if ((sParse.pNewTrigger) != null)
            {
                if ((isLegacy) == (0))
                {
                    rc = (int)(renameResolveTrigger(sParse));
                }

                if ((rc) == (0))
                {
                    int i1 = (int)(sqlite3SchemaToIndex(db, sParse.pNewTrigger.pTabSchema));
                    int i2 = (int)(sqlite3FindDbName(db, zDb));
                    if ((i1) == (i2))
                    {
                        sqlite3_result_int(context, (int)(1));
                    }
                }
            }
        }

        if (((rc != 0) &amp;&amp; ((zWhen) != null)) &amp;&amp; (sqlite3WritableSchema(db) == 0))
        {
            renameColumnParseError(context, zWhen, argv[2], argv[3], sParse);
        }

        renameParseCleanup(sParse);
    }

    db.xAuth = xAuth;
}</function>
  <function>public static void renameTestSchema(Parse pParse, sbyte* zDb, int bTemp, sbyte* zWhen, int bNoDQS)
{
    pParse.colNamesSet = (byte)(1);
    sqlite3NestedParse(pParse, "SELECT 1 FROM \"%w\".sqlite_master WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%' AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ", zDb, zDb, (int)(bTemp), zWhen, (int)(bNoDQS));
    if ((bTemp) == (0))
    {
        sqlite3NestedParse(pParse, "SELECT 1 FROM temp.sqlite_master WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%' AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ", zDb, zWhen, (int)(bNoDQS));
    }
}</function>
  <function>public static RenameToken* renameTokenFind(Parse pParse, RenameCtx pCtx, void* pPtr)
{
    RenameToken** pp;
    if (((pPtr) == (null)))
    {
        return null;
    }

    for (pp = &amp;pParse.pRename; (*pp); pp = &amp;(*pp)-&gt;pNext)
    {
        if (((*pp)-&gt;p) == (pPtr))
        {
            RenameToken* pToken = *pp;
            if ((pCtx) != null)
            {
                *pp = pToken-&gt;pNext;
                pToken-&gt;pNext = pCtx.pList;
                pCtx.pList = pToken;
                pCtx.nList++;
            }

            return pToken;
        }
    }

    return null;
}</function>
  <function>public static void renameTokenFree(sqlite3 db, RenameToken* pToken)
{
    RenameToken* pNext;
    RenameToken* p;
    for (p = pToken; p; p = pNext)
    {
        pNext = p-&gt;pNext;
        sqlite3DbFree(db, p);
    }
}</function>
  <function>public static int renameUnmapExprCb(Walker pWalker, Expr pExpr)
{
    Parse pParse = pWalker.pParse;
    sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr));
    if ((((pExpr).flags &amp; (0x1000000 | 0x2000000)) == (0)))
    {
        sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr.y.pTab));
    }

    return (int)(0);
}</function>
  <function>public static int renameUnmapSelectCb(Walker pWalker, Select p)
{
    Parse pParse = pWalker.pParse;
    int i = 0;
    if ((pParse.nErr) != 0)
        return (int)(2);
    if ((p.selFlags &amp; (0x0200000 | 0x4000000)) != 0)
    {
        return (int)(1);
    }

    if ((p.pEList) != null)
    {
        ExprList pList = p.pEList;
        for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
        {
            if (((pList.a[i].zEName) != null) &amp;&amp; ((pList.a[i].eEName) == (0)))
            {
                sqlite3RenameTokenRemap(pParse, null, (void*)(pList.a[i].zEName));
            }
        }
    }

    if ((p.pSrc) != null)
    {
        SrcList pSrc = p.pSrc;
        for (i = (int)(0); (i) &lt; (pSrc.nSrc); i++)
        {
            sqlite3RenameTokenRemap(pParse, null, (void*)(pSrc.a[i].zName));
            sqlite3WalkExpr(pWalker, pSrc.a[i].pOn);
            unmapColumnIdlistNames(pParse, pSrc.a[i].pUsing);
        }
    }

    renameWalkWith(pWalker, p);
    return (int)(0);
}</function>
  <function>public static void renameWalkTrigger(Walker pWalker, Trigger pTrigger)
{
    TriggerStep pStep;
    sqlite3WalkExpr(pWalker, pTrigger.pWhen);
    for (pStep = pTrigger.step_list; pStep; pStep = pStep.pNext)
    {
        sqlite3WalkSelect(pWalker, pStep.pSelect);
        sqlite3WalkExpr(pWalker, pStep.pWhere);
        sqlite3WalkExprList(pWalker, pStep.pExprList);
        if ((pStep.pUpsert) != null)
        {
            Upsert pUpsert = pStep.pUpsert;
            sqlite3WalkExprList(pWalker, pUpsert.pUpsertTarget);
            sqlite3WalkExprList(pWalker, pUpsert.pUpsertSet);
            sqlite3WalkExpr(pWalker, pUpsert.pUpsertWhere);
            sqlite3WalkExpr(pWalker, pUpsert.pUpsertTargetWhere);
        }

        if ((pStep.pFrom) != null)
        {
            int i = 0;
            for (i = (int)(0); (i) &lt; (pStep.pFrom.nSrc); i++)
            {
                sqlite3WalkSelect(pWalker, pStep.pFrom.a[i].pSelect);
            }
        }
    }
}</function>
  <function>public static void renameWalkWith(Walker pWalker, Select pSelect)
{
    With pWith = pSelect.pWith;
    if ((pWith) != null)
    {
        Parse pParse = pWalker.pParse;
        int i = 0;
        With pCopy = null;
        if ((pWith.a[0].pSelect.selFlags &amp; 0x0000040) == (0))
        {
            pCopy = sqlite3WithDup(pParse.db, pWith);
            pCopy = sqlite3WithPush(pParse, pCopy, (byte)(1));
        }

        for (i = (int)(0); (i) &lt; (pWith.nCte); i++)
        {
            Select p = pWith.a[i].pSelect;
            NameContext sNC = new NameContext();
            CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
            sNC.pParse = pParse;
            if ((pCopy) != null)
                sqlite3SelectPrep(sNC.pParse, p, sNC);
            if ((sNC.pParse.db.mallocFailed) != 0)
                return;
            sqlite3WalkSelect(pWalker, p);
            sqlite3RenameExprlistUnmap(pParse, pWith.a[i].pCols);
        }

        if (((pCopy) != null) &amp;&amp; ((pParse.pWith) == (pCopy)))
        {
            pParse.pWith = pCopy.pOuter;
        }
    }
}</function>
  <function>public static void renderLogMsg(int iErrCode, sbyte* zFormat, sbyte* ap)
{
    sqlite3_str acc = new sqlite3_str();
    sbyte* zMsg = stackalloc sbyte[210];
    sqlite3StrAccumInit(acc, null, zMsg, (int)(210 * sizeof(sbyte)), (int)(0));
    sqlite3_str_vappendf(acc, zFormat, ap);
    sqlite3Config.xLog(sqlite3Config.pLogArg, (int)(iErrCode), sqlite3StrAccumFinish(acc));
}</function>
  <function>public static void renumberCursorDoMapping(Walker pWalker, int* piCursor)
{
    int* aCsrMap = pWalker.u.aiCol;
    int iCsr = (int)(*piCursor);
    if (((iCsr) &lt; (aCsrMap[0])) &amp;&amp; ((aCsrMap[iCsr + 1]) &gt; (0)))
    {
        *piCursor = (int)(aCsrMap[iCsr + 1]);
    }
}</function>
  <function>public static void renumberCursors(Parse pParse, Select p, int iExcept, int* aCsrMap)
{
    Walker w = new Walker();
    srclistRenumberCursors(pParse, aCsrMap, p.pSrc, (int)(iExcept));
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    w.u.aiCol = aCsrMap;
    w.xExprCallback = renumberCursorsCb;
    w.xSelectCallback = sqlite3SelectWalkNoop;
    sqlite3WalkSelect(w, p);
}</function>
  <function>public static int renumberCursorsCb(Walker pWalker, Expr pExpr)
{
    int op = (int)(pExpr.op);
    if (((op) == (167)) || ((op) == (179)))
    {
        renumberCursorDoMapping(pWalker, &amp;pExpr.iTable);
    }

    if ((((pExpr).flags &amp; (0x000001)) != 0))
    {
        renumberCursorDoMapping(pWalker, &amp;pExpr.w.iRightJoinTable);
    }

    return (int)(0);
}</function>
  <function>public static void replaceFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* zStr;
    byte* zPattern;
    byte* zRep;
    byte* zOut;
    int nStr = 0;
    int nPattern = 0;
    int nRep = 0;
    long nOut = 0;
    int loopLimit = 0;
    int i = 0; int  j  =  0 ; 
    uint cntExpand = 0;
    sqlite3 db = sqlite3_context_db_handle(context);
    zStr = sqlite3_value_text(argv[0]);
    if ((zStr) == (null))
        return;
    nStr = (int)(sqlite3_value_bytes(argv[0]));
    zPattern = sqlite3_value_text(argv[1]);
    if ((zPattern) == (null))
    {
        return;
    }

    if ((zPattern[0]) == (0))
    {
        sqlite3_result_value(context, argv[0]);
        return;
    }

    nPattern = (int)(sqlite3_value_bytes(argv[1]));
    zRep = sqlite3_value_text(argv[2]);
    if ((zRep) == (null))
        return;
    nRep = (int)(sqlite3_value_bytes(argv[2]));
    nOut = (long)(nStr + 1);
    zOut = contextMalloc(context, (long)(nOut));
    if ((zOut) == (null))
    {
        return;
    }

    loopLimit = (int)(nStr - nPattern);
    cntExpand = (uint)(0);
    for (i = (int)(j = (int)(0)); (i) &lt;= (loopLimit); i++)
    {
        if ((zStr[i] != zPattern[0]) || ((memcmp(&amp;zStr[i], zPattern, (ulong)(nPattern))) != 0))
        {
            zOut[j++] = (byte)(zStr[i]);
        }
        else
        {
            if ((nRep) &gt; (nPattern))
            {
                nOut += (long)(nRep - nPattern);
                if ((nOut - 1) &gt; (db.aLimit[0]))
                {
                    sqlite3_result_error_toobig(context);
                    sqlite3_free(zOut);
                    return;
                }

                cntExpand++;
                if ((cntExpand &amp; (cntExpand - 1)) == (0))
                {
                    byte* zOld;
                    zOld = zOut;
                    zOut = sqlite3Realloc(zOut, (ulong)((int)(nOut) + (nOut - nStr - 1)));
                    if ((zOut) == (null))
                    {
                        sqlite3_result_error_nomem(context);
                        sqlite3_free(zOld);
                        return;
                    }
                }
            }

            CRuntime.memcpy(&amp;zOut[j], zRep, (ulong)(nRep));
            j += (int)(nRep);
            i += (int)(nPattern - 1);
        }
    }

    CRuntime.memcpy(&amp;zOut[j], &amp;zStr[i], (ulong)(nStr - i));
    j += (int)(nStr - i);
    zOut[j] = (byte)(0);
    sqlite3_result_text(context, (sbyte*)(zOut), (int)(j), sqlite3_free);
}</function>
  <function>public static void resetAccumulator(Parse pParse, AggInfo pAggInfo)
{
    Vdbe v = pParse.pVdbe;
    int i = 0;
    AggInfo_func pFunc;
    int nReg = (int)(pAggInfo.nFunc + pAggInfo.nColumn);
    if ((nReg) == (0))
        return;
    if ((pParse.nErr) != 0)
        return;
    sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(pAggInfo.mnReg), (int)(pAggInfo.mxReg));
    for (pFunc = pAggInfo.aFunc, i = (int)(0); (i) &lt; (pAggInfo.nFunc); i++, pFunc++)
    {
        if ((pFunc.iDistinct) &gt;= (0))
        {
            Expr pE = pFunc.pFExpr;
            if (((pE.x.pList) == (null)) || (pE.x.pList.nExpr != 1))
            {
                sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one argument");
                pFunc.iDistinct = (int)(-1);
            }
            else
            {
                KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE.x.pList, (int)(0), (int)(0));
                pFunc.iDistAddr = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(pFunc.iDistinct), (int)(0), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
                sqlite3VdbeExplain(pParse, (byte)(0), "USE TEMP B-TREE FOR %s(DISTINCT)", pFunc.pFunc.zName);
            }
        }
    }
}</function>
  <function>public static int resizeIndexObject(sqlite3 db, Index pIdx, int N)
{
    sbyte* zExtra;
    int nByte = 0;
    if ((pIdx.nColumn) &gt;= (N))
        return (int)(0);
    nByte = (int)((sizeof(char*) + sizeof(short) + sizeof(short) + 1) * N);
    zExtra = sqlite3DbMallocZero(db, (ulong)(nByte));
    if ((zExtra) == (null))
        return (int)(7);
    CRuntime.memcpy(zExtra, pIdx.azColl, (ulong)(sizeof(char*) * pIdx.nColumn));
    pIdx.azColl = (sbyte**)(zExtra);
    zExtra += sizeof(char*) * N;
    CRuntime.memcpy(zExtra, pIdx.aiRowLogEst, (ulong)(sizeof(short) * (pIdx.nKeyCol + 1)));
    pIdx.aiRowLogEst = (short*)(zExtra);
    zExtra += sizeof(short) * N;
    CRuntime.memcpy(zExtra, pIdx.aiColumn, (ulong)(sizeof(short) * pIdx.nColumn));
    pIdx.aiColumn = (short*)(zExtra);
    zExtra += sizeof(short) * N;
    CRuntime.memcpy(zExtra, pIdx.aSortOrder, (ulong)(pIdx.nColumn));
    pIdx.aSortOrder = (byte*)(zExtra);
    pIdx.nColumn = (ushort)(N);
    pIdx.isResized = (uint)(1);
    return (int)(0);
}</function>
  <function>public static void resizeResolveLabel(Parse p, Vdbe v, int j)
{
    int nNewSize = (int)(10 - p.nLabel);
    p.aLabel = sqlite3DbReallocOrFree(p.db, p.aLabel, (ulong)(nNewSize * sizeof(int)));
    if ((p.aLabel) == (null))
    {
        p.nLabelAlloc = (int)(0);
    }
    else
    {
        p.nLabelAlloc = (int)(nNewSize);
        p.aLabel[j] = (int)(v.nOp);
    }
}</function>
  <function>public static void resolveAlias(Parse pParse, ExprList pEList, int iCol, Expr pExpr, int nSubquery)
{
    Expr pOrig;
    Expr pDup;
    sqlite3 db;
    pOrig = pEList.a[iCol].pExpr;
    db = pParse.db;
    pDup = sqlite3ExprDup(db, pOrig, (int)(0));
    if ((db.mallocFailed) != 0)
    {
        sqlite3ExprDelete(db, pDup);
        pDup = null;
    }
    else
    {
        incrAggFunctionDepth(pDup, (int)(nSubquery));
        if ((pExpr.op) == (113))
        {
            pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr.u.zToken);
        }

        (pExpr).flags |= (uint)(0x8000000);
        sqlite3ExprDelete(db, pExpr);
        CRuntime.memcpy(pExpr, pDup, (ulong)(sizeof(Expr)));
        if ((!(((pExpr).flags &amp; (0x000400)) != 0)) &amp;&amp; (pExpr.u.zToken != null))
        {
            pExpr.u.zToken = sqlite3DbStrDup(db, pExpr.u.zToken);
            pExpr.flags |= (uint)(0x010000);
        }

        if ((((pExpr).flags &amp; (0x1000000)) != 0))
        {
            if ((pExpr.y.pWin != null))
            {
                pExpr.y.pWin.pOwner = pExpr;
            }
        }

        sqlite3DbFree(db, pDup);
    }
}</function>
  <function>public static int resolveAsName(Parse pParse, ExprList pEList, Expr pE)
{
    int i = 0;
    if ((pE.op) == (59))
    {
        sbyte* zCol;
        zCol = pE.u.zToken;
        for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
        {
            if (((pEList.a[i].eEName) == (0)) &amp;&amp; ((sqlite3_stricmp(pEList.a[i].zEName, zCol)) == (0)))
            {
                return (int)(i + 1);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int resolveAttachExpr(NameContext pName, Expr pExpr)
{
    int rc = (int)(0);
    if ((pExpr) != null)
    {
        if (pExpr.op != 59)
        {
            rc = (int)(sqlite3ResolveExprNames(pName, pExpr));
        }
        else
        {
            pExpr.op = (byte)(117);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int resolveCompoundOrderBy(Parse pParse, Select pSelect)
{
    int i = 0;
    ExprList pOrderBy;
    ExprList pEList;
    sqlite3 db;
    int moreToDo = (int)(1);
    pOrderBy = pSelect.pOrderBy;
    if ((pOrderBy) == (null))
        return (int)(0);
    db = pParse.db;
    if ((pOrderBy.nExpr) &gt; (db.aLimit[2]))
    {
        sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
        return (int)(1);
    }

    for (i = (int)(0); (i) &lt; (pOrderBy.nExpr); i++)
    {
        pOrderBy.a[i].done = (uint)(0);
    }

    pSelect.pNext = null;
    while ((pSelect.pPrior) != null)
    {
        pSelect.pPrior.pNext = pSelect;
        pSelect = pSelect.pPrior;
    }

    while (((pSelect) != null) &amp;&amp; ((moreToDo) != 0))
    {
        ExprList_item* pItem;
        moreToDo = (int)(0);
        pEList = pSelect.pEList;
        for (i = (int)(0), pItem = pOrderBy.a; (i) &lt; (pOrderBy.nExpr); i++, pItem++)
        {
            int iCol = (int)(-1);
            Expr pE;
            Expr pDup;
            if ((pItem-&gt;done) != 0)
                continue;
            pE = sqlite3ExprSkipCollateAndLikely(pItem-&gt;pExpr);
            if (((pE) == (null)))
                continue;
            if ((sqlite3ExprIsInteger(pE, &amp;iCol)) != 0)
            {
                if (((iCol) &lt;= (0)) || ((iCol) &gt; (pEList.nExpr)))
                {
                    resolveOutOfRangeError(pParse, "ORDER", (int)(i + 1), (int)(pEList.nExpr), pE);
                    return (int)(1);
                }
            }
            else
            {
                iCol = (int)(resolveAsName(pParse, pEList, pE));
                if ((iCol) == (0))
                {
                    pDup = sqlite3ExprDup(db, pE, (int)(0));
                    if (db.mallocFailed == 0)
                    {
                        iCol = (int)(resolveOrderByTermToExprList(pParse, pSelect, pDup));
                        if (((pParse.eParseMode) &gt;= (2)) &amp;&amp; ((iCol) &gt; (0)))
                        {
                            resolveOrderByTermToExprList(pParse, pSelect, pE);
                        }
                    }

                    sqlite3ExprDelete(db, pDup);
                }
            }

            if ((iCol) &gt; (0))
            {
                if (!((pParse.eParseMode) &gt;= (2)))
                {
                    Expr pNew = sqlite3Expr(db, (int)(155), null);
                    if ((pNew) == (null))
                        return (int)(1);
                    pNew.flags |= (uint)(0x000400);
                    pNew.u.iValue = (int)(iCol);
                    if ((pItem-&gt;pExpr) == (pE))
                    {
                        pItem-&gt;pExpr = pNew;
                    }
                    else
                    {
                        Expr pParent = pItem-&gt;pExpr;
                        while ((pParent.pLeft.op) == (113))
                        {
                            pParent = pParent.pLeft;
                        }

                        pParent.pLeft = pNew;
                    }

                    sqlite3ExprDelete(db, pE);
                    pItem-&gt;u.x.iOrderByCol = ((ushort)(iCol));
                }

                pItem-&gt;done = (uint)(1);
            }
            else
            {
                moreToDo = (int)(1);
            }
        }

        pSelect = pSelect.pNext;
    }

    for (i = (int)(0); (i) &lt; (pOrderBy.nExpr); i++)
    {
        if ((pOrderBy.a[i].done) == (0))
        {
            sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any column in the result set", (int)(i + 1));
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int resolveExprStep(Walker pWalker, Expr pExpr)
{
    NameContext pNC;
    Parse pParse;
    pNC = pWalker.u.pNC;
    pParse = pNC.pParse;
    switch (pExpr.op)
    {
        case 75:
        {
            SrcList pSrcList = pNC.pSrcList;
            SrcItem pItem;
            pItem = pSrcList.a;
            pExpr.op = (byte)(167);
            pExpr.y.pTab = pItem.pTab;
            pExpr.iTable = (int)(pItem.iCursor);
            pExpr.iColumn--;
            pExpr.affExpr = (sbyte)(0x44);
            break;
        }

        case 51:
        case 50:
        {
            int* anRef = stackalloc int[8];
            NameContext p;
            int i = 0;
            for (i = (int)(0), p = pNC; ((p) != null) &amp;&amp; ((i) &lt; ((int)(8 * sizeof(int) / sizeof(int)))); p = p.pNext, i++)
            {
                anRef[i] = (int)(p.nRef);
            }

            sqlite3WalkExpr(pWalker, pExpr.pLeft);
            if (((0) == (sqlite3ExprCanBeNull(pExpr.pLeft))) &amp;&amp; (!((pParse.eParseMode) &gt;= (2))))
            {
                if ((pExpr.op) == (51))
                {
                    pExpr.u.zToken = "true";
                    (pExpr).flags |= (uint)(0x10000000);
                }
                else
                {
                    pExpr.u.zToken = "false";
                    (pExpr).flags |= (uint)(0x20000000);
                }

                pExpr.op = (byte)(170);
                for (i = (int)(0), p = pNC; ((p) != null) &amp;&amp; ((i) &lt; ((int)(8 * sizeof(int) / sizeof(int)))); p = p.pNext, i++)
                {
                    p.nRef = (int)(anRef[i]);
                }

                sqlite3ExprDelete(pParse.db, pExpr.pLeft);
                pExpr.pLeft = null;
            }

            return (int)(1);
        }

        case 59:
        case 141:
        {
            sbyte* zColumn;
            sbyte* zTable;
            sbyte* zDb;
            Expr pRight;
            if ((pExpr.op) == (59))
            {
                zDb = null;
                zTable = null;
                zColumn = pExpr.u.zToken;
            }
            else
            {
                Expr pLeft = pExpr.pLeft;
                if (((pNC).ncFlags &amp; (0x000020 | 0x000008)) != 0)
                    notValidImpl(pParse, pNC, "the \".\" operator", null, pExpr);
                pRight = pExpr.pRight;
                if ((pRight.op) == (59))
                {
                    zDb = null;
                }
                else
                {
                    zDb = pLeft.u.zToken;
                    pLeft = pRight.pLeft;
                    pRight = pRight.pRight;
                }

                zTable = pLeft.u.zToken;
                zColumn = pRight.u.zToken;
                if (((pParse.eParseMode) &gt;= (2)))
                {
                    sqlite3RenameTokenRemap(pParse, (void*)(pExpr), (void*)(pRight));
                    sqlite3RenameTokenRemap(pParse, (void*)(pExpr.y.pTab), (void*)(pLeft));
                }
            }

            return (int)(lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr));
        }

        case 172:
        {
            ExprList pList = pExpr.x.pList;
            int n = (int)(pList ? pList.nExpr : 0);
            int no_such_func = (int)(0);
            int wrong_num_args = (int)(0);
            int is_agg = (int)(0);
            sbyte* zId;
            FuncDef pDef;
            byte enc = (byte)((pParse.db).enc);
            int savedAllowFlags = (int)(pNC.ncFlags &amp; (0x000001 | 0x004000));
            Window pWin = (((((pExpr).flags &amp; (0x1000000)) != 0) &amp;&amp; (pExpr.y.pWin.eFrmType != 166)) ? pExpr.y.pWin : null);
            zId = pExpr.u.zToken;
            pDef = sqlite3FindFunction(pParse.db, zId, (int)(n), (byte)(enc), (byte)(0));
            if ((pDef) == (null))
            {
                pDef = sqlite3FindFunction(pParse.db, zId, (int)(-2), (byte)(enc), (byte)(0));
                if ((pDef) == (null))
                {
                    no_such_func = (int)(1);
                }
                else
                {
                    wrong_num_args = (int)(1);
                }
            }
            else
            {
                is_agg = (int)(pDef.xFinalize != null);
                if ((pDef.funcFlags &amp; 0x0400) != 0)
                {
                    (pExpr).flags |= (uint)(0x040000);
                    if ((n) == (2))
                    {
                        pExpr.iTable = (int)(exprProbability(pList.a[1].pExpr));
                        if ((pExpr.iTable) &lt; (0))
                        {
                            sqlite3ErrorMsg(pParse, "second argument to %#T() must be a constant between 0.0 and 1.0", pExpr);
                            pNC.nNcErr++;
                        }
                    }
                    else
                    {
                        pExpr.iTable = (int)((pDef.zName[0]) == (117) ? 8388608 : 125829120);
                    }
                }

                {
                    int auth = (int)(sqlite3AuthCheck(pParse, (int)(31), null, pDef.zName, null));
                    if (auth != 0)
                    {
                        if ((auth) == (1))
                        {
                            sqlite3ErrorMsg(pParse, "not authorized to use function: %#T", pExpr);
                            pNC.nNcErr++;
                        }

                        pExpr.op = (byte)(121);
                        return (int)(1);
                    }
                }

                if ((pDef.funcFlags &amp; (0x0800 | 0x2000)) != 0)
                {
                    (pExpr).flags |= (uint)(0x080000);
                }

                if ((pDef.funcFlags &amp; 0x0800) == (0))
                {
                    if (((pNC).ncFlags &amp; (0x000020 | 0x000002 | 0x000008)) != 0)
                        notValidImpl(pParse, pNC, "non-deterministic functions", null, pExpr);
                }
                else
                {
                    pExpr.op2 = (byte)(pNC.ncFlags &amp; 0x00002e);
                    if ((pNC.ncFlags &amp; 0x040000) != 0)
                        (pExpr).flags |= (uint)(0x40000000);
                }

                if ((((pDef.funcFlags &amp; 0x00040000) != 0) &amp;&amp; ((pParse.nested) == (0))) &amp;&amp; ((pParse.db.mDbFlags &amp; 0x0020) == (0)))
                {
                    no_such_func = (int)(1);
                    pDef = null;
                }
                else if (((pDef.funcFlags &amp; (0x00080000 | 0x00200000)) != 0) &amp;&amp; (!((pParse.eParseMode) &gt;= (2))))
                {
                    sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
                }
            }

            if ((0) == ((pParse.eParseMode) &gt;= (2)))
            {
                if ((((pDef) != null) &amp;&amp; ((pDef.xValue) == (null))) &amp;&amp; ((pWin) != null))
                {
                    sqlite3ErrorMsg(pParse, "%#T() may not be used as a window function", pExpr);
                    pNC.nNcErr++;
                }
                else if (((((is_agg) != 0) &amp;&amp; ((pNC.ncFlags &amp; 0x000001) == (0))) || ((((is_agg) != 0) &amp;&amp; ((pDef.funcFlags &amp; 0x00010000) != 0)) &amp;&amp; (pWin == null))) || ((((is_agg) != 0) &amp;&amp; ((pWin) != null)) &amp;&amp; ((pNC.ncFlags &amp; 0x004000) == (0))))
                {
                    sbyte* zType;
                    if (((pDef.funcFlags &amp; 0x00010000) != 0) || ((pWin) != null))
                    {
                        zType = "window";
                    }
                    else
                    {
                        zType = "aggregate";
                    }

                    sqlite3ErrorMsg(pParse, "misuse of %s function %#T()", zType, pExpr);
                    pNC.nNcErr++;
                    is_agg = (int)(0);
                }
                else if (((no_such_func) != 0) &amp;&amp; ((pParse.db.init.busy) == (0)))
                {
                    sqlite3ErrorMsg(pParse, "no such function: %#T", pExpr);
                    pNC.nNcErr++;
                }
                else if ((wrong_num_args) != 0)
                {
                    sqlite3ErrorMsg(pParse, "wrong number of arguments to function %#T()", pExpr);
                    pNC.nNcErr++;
                }
                else if (((is_agg) == (0)) &amp;&amp; (((pExpr).flags &amp; (0x1000000)) != 0))
                {
                    sqlite3ErrorMsg(pParse, "FILTER may not be used with non-aggregate %#T()", pExpr);
                    pNC.nNcErr++;
                }

                if ((is_agg) != 0)
                {
                    pNC.ncFlags &amp;= (int)(~(0x004000 | ((!pWin) != 0 ? 0x000001 : 0)));
                }
            }
            else if ((((pExpr).flags &amp; (0x1000000)) != 0))
            {
                is_agg = (int)(1);
            }

            sqlite3WalkExprList(pWalker, pList);
            if ((is_agg) != 0)
            {
                if ((pWin) != null)
                {
                    Select pSel = pNC.pWinSelect;
                    if (((pParse.eParseMode) &gt;= (2)) == (0))
                    {
                        sqlite3WindowUpdate(pParse, pSel ? pSel.pWinDefn : null, pWin, pDef);
                        if ((pParse.db.mallocFailed) != 0)
                            break;
                    }

                    sqlite3WalkExprList(pWalker, pWin.pPartition);
                    sqlite3WalkExprList(pWalker, pWin.pOrderBy);
                    sqlite3WalkExpr(pWalker, pWin.pFilter);
                    sqlite3WindowLink(pSel, pWin);
                    pNC.ncFlags |= (int)(0x008000);
                }
                else
                {
                    NameContext pNC2;
                    pExpr.op = (byte)(168);
                    pExpr.op2 = (byte)(0);
                    if ((((pExpr).flags &amp; (0x1000000)) != 0))
                    {
                        sqlite3WalkExpr(pWalker, pExpr.y.pWin.pFilter);
                    }

                    pNC2 = pNC;
                    while (((pNC2) != null) &amp;&amp; ((sqlite3ReferencesSrcList(pParse, pExpr, pNC2.pSrcList)) == (0)))
                    {
                        pExpr.op2++;
                        pNC2 = pNC2.pNext;
                    }

                    if (((pNC2) != null) &amp;&amp; ((pDef) != null))
                    {
                        pNC2.ncFlags |= (int)(0x000010 | ((pDef.funcFlags ^ 0x08000000) &amp; (0x1000 | 0x08000000)));
                    }
                }

                pNC.ncFlags |= (int)(savedAllowFlags);
            }

            return (int)(1);
        }

        case 138:
        case 20:
            ;
        case 49:
        {
            if ((((pExpr).flags &amp; 0x000800) != 0))
            {
                int nRef = (int)(pNC.nRef);
                if ((pNC.ncFlags &amp; 0x00002e) != 0)
                {
                    notValidImpl(pParse, pNC, "subqueries", pExpr, pExpr);
                }
                else
                {
                    sqlite3WalkSelect(pWalker, pExpr.x.pSelect);
                }

                if (nRef != pNC.nRef)
                {
                    (pExpr).flags |= (uint)(0x000020);
                    pNC.ncFlags |= (int)(0x000040);
                }
            }

            break;
        }

        case 156:
        {
            if (((pNC).ncFlags &amp; (0x000004 | 0x000002 | 0x000020 | 0x000008)) != 0)
                notValidImpl(pParse, pNC, "parameters", pExpr, pExpr);
            break;
        }

        case 45:
        case 171:
        {
            Expr pRight = sqlite3ExprSkipCollateAndLikely(pExpr.pRight);
            if (((pRight) != null) &amp;&amp; (((pRight.op) == (59)) || ((pRight.op) == (170))))
            {
                int rc = (int)(resolveExprStep(pWalker, pRight));
                if ((rc) == (2))
                    return (int)(2);
                if ((pRight.op) == (170))
                {
                    pExpr.op2 = (byte)(pExpr.op);
                    pExpr.op = (byte)(175);
                    return (int)(0);
                }
            }
        }

        case 48:
        case 53:
        case 52:
        case 56:
        case 55:
        case 54:
        case 57:
        {
            int nLeft = 0;
            int nRight = 0;
            if ((pParse.db.mallocFailed) != 0)
                break;
            nLeft = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
            if ((pExpr.op) == (48))
            {
                nRight = (int)(sqlite3ExprVectorSize(pExpr.x.pList.a[0].pExpr));
                if ((nRight) == (nLeft))
                {
                    nRight = (int)(sqlite3ExprVectorSize(pExpr.x.pList.a[1].pExpr));
                }
            }
            else
            {
                nRight = (int)(sqlite3ExprVectorSize(pExpr.pRight));
            }

            if (nLeft != nRight)
            {
                sqlite3ErrorMsg(pParse, "row value misused");
                sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
            }

            break;
        }
    }

    return (int)((pParse.nErr) != 0 ? 2 : 0);
}</function>
  <function>public static int resolveFromTermToCte(Parse pParse, Walker pWalker, SrcItem pFrom)
{
    Cte pCte;
    With pWith;
    if ((pParse.pWith) == (null))
    {
        return (int)(0);
    }

    if ((pParse.nErr) != 0)
    {
        return (int)(0);
    }

    if (pFrom.zDatabase != null)
    {
        return (int)(0);
    }

    if ((pFrom.fg.notCte) != 0)
    {
        return (int)(0);
    }

    pCte = searchWith(pParse.pWith, pFrom, pWith);
    if ((pCte) != null)
    {
        sqlite3 db = pParse.db;
        Table pTab;
        ExprList pEList;
        Select pSel;
        Select pLeft;
        Select pRecTerm;
        int bMayRecursive = 0;
        With pSavedWith;
        int iRecTab = (int)(-1);
        CteUse* pCteUse;
        if ((pCte.zCteErr) != null)
        {
            sqlite3ErrorMsg(pParse, pCte.zCteErr, pCte.zName);
            return (int)(2);
        }

        if ((cannotBeFunction(pParse, pFrom)) != 0)
            return (int)(2);
        pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
        if ((pTab) == (null))
            return (int)(2);
        pCteUse = pCte.pUse;
        if ((pCteUse) == (null))
        {
            pCte.pUse = pCteUse = sqlite3DbMallocZero(db, (ulong)(sizeof(CteUse)));
            if (((pCteUse) == (null)) || ((sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pCteUse)) == (null)))
            {
                sqlite3DbFree(db, pTab);
                return (int)(2);
            }

            pCteUse-&gt;eM10d = (byte)(pCte.eM10d);
        }

        pFrom.pTab = pTab;
        pTab.nTabRef = (uint)(1);
        pTab.zName = sqlite3DbStrDup(db, pCte.zName);
        pTab.iPKey = (short)(-1);
        pTab.nRowLogEst = (short)(200);
        pTab.tabFlags |= (uint)(0x00004000 | 0x00000200);
        pFrom.pSelect = sqlite3SelectDup(db, pCte.pSelect, (int)(0));
        if ((db.mallocFailed) != 0)
            return (int)(2);
        pFrom.pSelect.selFlags |= (uint)(0x4000000);
        if ((pFrom.fg.isIndexedBy) != 0)
        {
            sqlite3ErrorMsg(pParse, "no such index: \"%s\"", pFrom.u1.zIndexedBy);
            return (int)(2);
        }

        pFrom.fg.isCte = (uint)(1);
        pFrom.u2.pCteUse = pCteUse;
        pCteUse-&gt;nUse++;
        if (((pCteUse-&gt;nUse) &gt;= (2)) &amp;&amp; ((pCteUse-&gt;eM10d) == (1)))
        {
            pCteUse-&gt;eM10d = (byte)(0);
        }

        pRecTerm = pSel = pFrom.pSelect;
        bMayRecursive = (int)(((pSel.op) == (135)) || ((pSel.op) == (134)) ? 1 : 0);
        while (((bMayRecursive) != 0) &amp;&amp; ((pRecTerm.op) == (pSel.op)))
        {
            int i = 0;
            SrcList pSrc = pRecTerm.pSrc;
            for (i = (int)(0); (i) &lt; (pSrc.nSrc); i++)
            {
                SrcItem pItem = pSrc.a[i];
                if ((((pItem.zDatabase) == (null)) &amp;&amp; (pItem.zName != null)) &amp;&amp; ((0) == (sqlite3StrICmp(pItem.zName, pCte.zName))))
                {
                    pItem.pTab = pTab;
                    pTab.nTabRef++;
                    pItem.fg.isRecursive = (uint)(1);
                    if ((pRecTerm.selFlags &amp; 0x0002000) != 0)
                    {
                        sqlite3ErrorMsg(pParse, "multiple references to recursive table: %s", pCte.zName);
                        return (int)(2);
                    }

                    pRecTerm.selFlags |= (uint)(0x0002000);
                    if ((iRecTab) &lt; (0))
                        iRecTab = (int)(pParse.nTab++);
                    pItem.iCursor = (int)(iRecTab);
                }
            }

            if ((pRecTerm.selFlags &amp; 0x0002000) == (0))
                break;
            pRecTerm = pRecTerm.pPrior;
        }

        pCte.zCteErr = "circular reference: %s";
        pSavedWith = pParse.pWith;
        pParse.pWith = pWith;
        if ((pSel.selFlags &amp; 0x0002000) != 0)
        {
            int rc = 0;
            pRecTerm.pWith = pSel.pWith;
            rc = (int)(sqlite3WalkSelect(pWalker, pRecTerm));
            pRecTerm.pWith = null;
            if ((rc) != 0)
            {
                pParse.pWith = pSavedWith;
                return (int)(2);
            }
        }
        else
        {
            if ((sqlite3WalkSelect(pWalker, pSel)) != 0)
            {
                pParse.pWith = pSavedWith;
                return (int)(2);
            }
        }

        pParse.pWith = pWith;
        for (pLeft = pSel; pLeft.pPrior; pLeft = pLeft.pPrior)
        {
        }

        pEList = pLeft.pEList;
        if ((pCte.pCols) != null)
        {
            if (((pEList) != null) &amp;&amp; (pEList.nExpr != pCte.pCols.nExpr))
            {
                sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns", pCte.zName, (int)(pEList.nExpr), (int)(pCte.pCols.nExpr));
                pParse.pWith = pSavedWith;
                return (int)(2);
            }

            pEList = pCte.pCols;
        }

        sqlite3ColumnsFromExprList(pParse, pEList, &amp;pTab.nCol, &amp;pTab.aCol);
        if ((bMayRecursive) != 0)
        {
            if ((pSel.selFlags &amp; 0x0002000) != 0)
            {
                pCte.zCteErr = "multiple recursive references: %s";
            }
            else
            {
                pCte.zCteErr = "recursive reference in a subquery: %s";
            }

            sqlite3WalkSelect(pWalker, pSel);
        }

        pCte.zCteErr = null;
        pParse.pWith = pSavedWith;
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int resolveOrderByTermToExprList(Parse pParse, Select pSelect, Expr pE)
{
    int i = 0;
    ExprList pEList;
    NameContext nc = new NameContext();
    sqlite3 db;
    int rc = 0;
    byte savedSuppErr = 0;
    pEList = pSelect.pEList;
    CRuntime.memset(nc, (int)(0), (ulong)(sizeof(NameContext)));
    nc.pParse = pParse;
    nc.pSrcList = pSelect.pSrc;
    nc.uNC.pEList = pEList;
    nc.ncFlags = (int)(0x000001 | 0x000080 | 0x080000);
    nc.nNcErr = (int)(0);
    db = pParse.db;
    savedSuppErr = (byte)(db.suppressErr);
    db.suppressErr = (byte)(1);
    rc = (int)(sqlite3ResolveExprNames(nc, pE));
    db.suppressErr = (byte)(savedSuppErr);
    if ((rc) != 0)
        return (int)(0);
    for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
    {
        if ((sqlite3ExprCompare(null, pEList.a[i].pExpr, pE, (int)(-1))) &lt; (2))
        {
            return (int)(i + 1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int resolveOrderGroupBy(NameContext pNC, Select pSelect, ExprList pOrderBy, sbyte* zType)
{
    int i = 0; int  j  =  0 ; 
    int iCol = 0;
    ExprList_item* pItem;
    Parse pParse;
    int nResult = 0;
    nResult = (int)(pSelect.pEList.nExpr);
    pParse = pNC.pParse;
    for (i = (int)(0), pItem = pOrderBy.a; (i) &lt; (pOrderBy.nExpr); i++, pItem++)
    {
        Expr pE = pItem-&gt;pExpr;
        Expr pE2 = sqlite3ExprSkipCollateAndLikely(pE);
        if (((pE2) == (null)))
            continue;
        if (zType[0] != 71)
        {
            iCol = (int)(resolveAsName(pParse, pSelect.pEList, pE2));
            if ((iCol) &gt; (0))
            {
                pItem-&gt;u.x.iOrderByCol = ((ushort)(iCol));
                continue;
            }
        }

        if ((sqlite3ExprIsInteger(pE2, &amp;iCol)) != 0)
        {
            if (((iCol) &lt; (1)) || ((iCol) &gt; (0xffff)))
            {
                resolveOutOfRangeError(pParse, zType, (int)(i + 1), (int)(nResult), pE2);
                return (int)(1);
            }

            pItem-&gt;u.x.iOrderByCol = ((ushort)(iCol));
            continue;
        }

        pItem-&gt;u.x.iOrderByCol = (ushort)(0);
        if ((sqlite3ResolveExprNames(pNC, pE)) != 0)
        {
            return (int)(1);
        }

        for (j = (int)(0); (j) &lt; (pSelect.pEList.nExpr); j++)
        {
            if ((sqlite3ExprCompare(null, pE, pSelect.pEList.a[j].pExpr, (int)(-1))) == (0))
            {
                windowRemoveExprFromSelect(pSelect, pE);
                pItem-&gt;u.x.iOrderByCol = (ushort)(j + 1);
            }
        }
    }

    return (int)(sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType));
}</function>
  <function>public static void resolveOutOfRangeError(Parse pParse, sbyte* zType, int i, int mx, Expr pError)
{
    sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be between 1 and %d", (int)(i), zType, (int)(mx));
    sqlite3RecordErrorOffsetOfExpr(pParse.db, pError);
}</function>
  <function>public static void resolveP2Values(Vdbe p, int* pMaxFuncArgs)
{
    int nMaxArgs = (int)(*pMaxFuncArgs);
    VdbeOp* pOp;
    Parse pParse = p.pParse;
    int* aLabel = pParse.aLabel;
    p.readOnly = (uint)(1);
    p.bIsReader = (uint)(0);
    pOp = &amp;p.aOp[p.nOp - 1];
    while ((1) != 0)
    {
        if ((pOp-&gt;opcode) &lt;= (64))
        {
            switch (pOp-&gt;opcode)
            {
                case 2:
                {
                    if (pOp-&gt;p2 != 0)
                        p.readOnly = (uint)(0);
                }

                case 1:
                case 0:
                {
                    p.bIsReader = (uint)(1);
                    break;
                }

                case 6:
                case 8:
                case 7:
                {
                    p.readOnly = (uint)(0);
                    p.bIsReader = (uint)(1);
                    break;
                }

                case 5:
                case 3:
                {
                    pOp-&gt;p4.xAdvance = sqlite3BtreeNext;
                    pOp-&gt;p4type = (sbyte)(-5);
                    break;
                }

                case 4:
                {
                    pOp-&gt;p4.xAdvance = sqlite3BtreePrevious;
                    pOp-&gt;p4type = (sbyte)(-5);
                    break;
                }

                case 10:
                {
                    if ((pOp-&gt;p2) &gt; (nMaxArgs))
                        nMaxArgs = (int)(pOp-&gt;p2);
                    break;
                }

                case 9:
                {
                    int n = 0;
                    n = (int)(pOp[-1].p1);
                    if ((n) &gt; (nMaxArgs))
                        nMaxArgs = (int)(n);
                }

                default:
                {
                    if ((pOp-&gt;p2) &lt; (0))
                    {
                        pOp-&gt;p2 = (int)(aLabel[(~(pOp-&gt;p2))]);
                    }

                    break;
                }
            }
        }

        if ((pOp) == (p.aOp))
            break;
        pOp--;
    }

    sqlite3DbFree(p.db, pParse.aLabel);
    pParse.aLabel = null;
    pParse.nLabel = (int)(0);
    *pMaxFuncArgs = (int)(nMaxArgs);
}</function>
  <function>public static int resolveRemoveWindowsCb(Walker pWalker, Expr pExpr)
{
    if ((((pExpr).flags &amp; (0x1000000)) != 0))
    {
        Window pWin = pExpr.y.pWin;
        sqlite3WindowUnlinkFromSelect(pWin);
    }

    return (int)(0);
}</function>
  <function>public static int resolveSelectStep(Walker pWalker, Select p)
{
    NameContext pOuterNC;
    NameContext sNC = new NameContext();
    int isCompound = 0;
    int nCompound = 0;
    Parse pParse;
    int i = 0;
    ExprList pGroupBy;
    Select pLeftmost;
    sqlite3 db;
    if ((p.selFlags &amp; 0x0000004) != 0)
    {
        return (int)(1);
    }

    pOuterNC = pWalker.u.pNC;
    pParse = pWalker.pParse;
    db = pParse.db;
    if ((p.selFlags &amp; 0x0000040) == (0))
    {
        sqlite3SelectPrep(pParse, p, pOuterNC);
        return (int)((pParse.nErr) != 0 ? 2 : 1);
    }

    isCompound = (int)(p.pPrior != null);
    nCompound = (int)(0);
    pLeftmost = p;
    while ((p) != null)
    {
        p.selFlags |= (uint)(0x0000004);
        CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
        sNC.pParse = pParse;
        sNC.pWinSelect = p;
        if ((sqlite3ResolveExprNames(sNC, p.pLimit)) != 0)
        {
            return (int)(2);
        }

        if ((p.selFlags &amp; 0x0010000) != 0)
        {
            Select pSub = p.pSrc.a[0].pSelect;
            pSub.pOrderBy = p.pOrderBy;
            p.pOrderBy = null;
        }

        for (i = (int)(0); (i) &lt; (p.pSrc.nSrc); i++)
        {
            SrcItem pItem = p.pSrc.a[i];
            if (((pItem.pSelect) != null) &amp;&amp; ((pItem.pSelect.selFlags &amp; 0x0000004) == (0)))
            {
                int nRef = (int)(pOuterNC ? pOuterNC.nRef : 0);
                sbyte* zSavedContext = pParse.zAuthContext;
                if ((pItem.zName) != null)
                    pParse.zAuthContext = pItem.zName;
                sqlite3ResolveSelectNames(pParse, pItem.pSelect, pOuterNC);
                pParse.zAuthContext = zSavedContext;
                if ((pParse.nErr) != 0)
                    return (int)(2);
                if ((pOuterNC) != null)
                {
                    pItem.fg.isCorrelated = (uint)((pOuterNC.nRef) &gt; (nRef));
                }
            }
        }

        sNC.ncFlags = (int)(0x000001 | 0x004000);
        sNC.pSrcList = p.pSrc;
        sNC.pNext = pOuterNC;
        if ((sqlite3ResolveExprListNames(sNC, p.pEList)) != 0)
            return (int)(2);
        sNC.ncFlags &amp;= (int)(~0x004000);
        pGroupBy = p.pGroupBy;
        if (((pGroupBy) != null) || ((sNC.ncFlags &amp; 0x000010) != 0))
        {
            p.selFlags |= (uint)(0x0000008 | (sNC.ncFlags &amp; (0x001000 | 0x8000000)));
        }
        else
        {
            sNC.ncFlags &amp;= (int)(~0x000001);
        }

        sNC.uNC.pEList = p.pEList;
        sNC.ncFlags |= (int)(0x000080);
        if ((p.pHaving) != null)
        {
            if (pGroupBy == null)
            {
                sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
                return (int)(2);
            }

            if ((sqlite3ResolveExprNames(sNC, p.pHaving)) != 0)
                return (int)(2);
        }

        if ((sqlite3ResolveExprNames(sNC, p.pWhere)) != 0)
            return (int)(2);
        for (i = (int)(0); (i) &lt; (p.pSrc.nSrc); i++)
        {
            SrcItem pItem = p.pSrc.a[i];
            if (((pItem.fg.isTabFunc) != 0) &amp;&amp; ((sqlite3ResolveExprListNames(sNC, pItem.u1.pFuncArg)) != 0))
            {
                return (int)(2);
            }
        }

        if (((pParse.eParseMode) &gt;= (2)))
        {
            Window pWin;
            for (pWin = p.pWinDefn; pWin; pWin = pWin.pNextWin)
            {
                if (((sqlite3ResolveExprListNames(sNC, pWin.pOrderBy)) != 0) || ((sqlite3ResolveExprListNames(sNC, pWin.pPartition)) != 0))
                {
                    return (int)(2);
                }
            }
        }

        sNC.pNext = null;
        sNC.ncFlags |= (int)(0x000001 | 0x004000);
        if ((p.selFlags &amp; 0x0010000) != 0)
        {
            Select pSub = p.pSrc.a[0].pSelect;
            p.pOrderBy = pSub.pOrderBy;
            pSub.pOrderBy = null;
        }

        if (((p.pOrderBy != null) &amp;&amp; ((isCompound) &lt;= (nCompound))) &amp;&amp; ((resolveOrderGroupBy(sNC, p, p.pOrderBy, "ORDER")) != 0))
        {
            return (int)(2);
        }

        if ((db.mallocFailed) != 0)
        {
            return (int)(2);
        }

        sNC.ncFlags &amp;= (int)(~0x004000);
        if ((pGroupBy) != null)
        {
            ExprList_item* pItem;
            if (((resolveOrderGroupBy(sNC, p, pGroupBy, "GROUP")) != 0) || ((db.mallocFailed) != 0))
            {
                return (int)(2);
            }

            for (i = (int)(0), pItem = pGroupBy.a; (i) &lt; (pGroupBy.nExpr); i++, pItem++)
            {
                if ((((pItem-&gt;pExpr).flags &amp; (0x000010)) != 0))
                {
                    sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in the GROUP BY clause");
                    return (int)(2);
                }
            }
        }

        if (((p.pNext) != null) &amp;&amp; (p.pEList.nExpr != p.pNext.pEList.nExpr))
        {
            sqlite3SelectWrongNumTermsError(pParse, p.pNext);
            return (int)(2);
        }

        p = p.pPrior;
        nCompound++;
    }

    if (((isCompound) != 0) &amp;&amp; ((resolveCompoundOrderBy(pParse, pLeftmost)) != 0))
    {
        return (int)(2);
    }

    return (int)(1);
}</function>
  <function>public static void returnSingleInt(Vdbe v, long value)
{
    sqlite3VdbeAddOp4Dup8(v, (int)(72), (int)(0), (int)(1), (int)(0), (byte*)(&amp;value), (int)(-14));
    sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
}</function>
  <function>public static void returnSingleText(Vdbe v, sbyte* zValue)
{
    if ((zValue) != null)
    {
        sqlite3VdbeLoadString(v, (int)(1), zValue);
        sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
    }
}</function>
  <function>public static void roundFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    int n = (int)(0);
    double r = 0;
    sbyte* zBuf;
    if ((argc) == (2))
    {
        if ((5) == (sqlite3_value_type(argv[1])))
            return;
        n = (int)(sqlite3_value_int(argv[1]));
        if ((n) &gt; (30))
            n = (int)(30);
        if ((n) &lt; (0))
            n = (int)(0);
    }

    if ((sqlite3_value_type(argv[0])) == (5))
        return;
    r = (double)(sqlite3_value_double(argv[0]));
    if (((r) &lt; (-4503599627370496.0)) || ((r) &gt; (+4503599627370496.0)))
    {
    }
    else if ((n) == (0))
    {
        r = ((double)((long)(r + ((r) &lt; (0) ? -0.5 : +0.5))));
    }
    else
    {
        zBuf = sqlite3_mprintf("%.*f", (int)(n), (double)(r));
        if ((zBuf) == (null))
        {
            sqlite3_result_error_nomem(context);
            return;
        }

        sqlite3AtoF(zBuf, &amp;r, (int)(sqlite3Strlen30(zBuf)), (byte)(1));
        sqlite3_free(zBuf);
    }

    sqlite3_result_double(context, (double)(r));
}</function>
  <function>public static void row_numberStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
{
    long* p = (long*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(long))));
    if ((p) != null)
        (*p)++;
}</function>
  <function>public static void row_numberValueFunc(sqlite3_context pCtx)
{
    long* p = (long*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(long))));
    sqlite3_result_int64(pCtx, (long)((p) != 0 ? *p : 0));
}</function>
  <function>public static RowSetEntry* rowSetEntryAlloc(RowSet p)
{
    if ((p.nFresh) == (0))
    {
        RowSetChunk pNew;
        pNew = sqlite3DbMallocRawNN(p.db, (ulong)(sizeof(RowSetChunk)));
        if ((pNew) == (null))
        {
            return null;
        }

        pNew.pNextChunk = p.pChunk;
        p.pChunk = pNew;
        p.pFresh = pNew.aEntry;
        p.nFresh = (ushort)((1024 - 8) / sizeof(RowSetEntry));
    }

    p.nFresh--;
    return p.pFresh++;
}</function>
  <function>public static RowSetEntry* rowSetEntryMerge(RowSetEntry* pA, RowSetEntry* pB)
{
    RowSetEntry head = new RowSetEntry();
    RowSetEntry* pTail;
    pTail = &amp;head;
    for (;;)
    {
        if ((pA-&gt;v) &lt;= (pB-&gt;v))
        {
            if ((pA-&gt;v) &lt; (pB-&gt;v))
                pTail = pTail-&gt;pRight = pA;
            pA = pA-&gt;pRight;
            if ((pA) == (null))
            {
                pTail-&gt;pRight = pB;
                break;
            }
        }
        else
        {
            pTail = pTail-&gt;pRight = pB;
            pB = pB-&gt;pRight;
            if ((pB) == (null))
            {
                pTail-&gt;pRight = pA;
                break;
            }
        }
    }

    return head.pRight;
}</function>
  <function>public static RowSetEntry* rowSetEntrySort(RowSetEntry* pIn)
{
    uint i = 0;
    RowSetEntry* pNext; RowSetEntry * * aBucket  =  stackalloc  RowSetEntry [ 40 ] ; 
    CRuntime.memset(aBucket, (int)(0), (ulong)(40 * sizeof(RowSetEntry)));
    while ((pIn) != null)
    {
        pNext = pIn-&gt;pRight;
        pIn-&gt;pRight = null;
        for (i = (uint)(0); aBucket[i]; i++)
        {
            pIn = rowSetEntryMerge(aBucket[i], pIn);
            aBucket[i] = null;
        }

        aBucket[i] = pIn;
        pIn = pNext;
    }

    pIn = aBucket[0];
    for (i = (uint)(1); (i) &lt; (40 * sizeof(RowSetEntry) / sizeof(RowSetEntry*)); i++)
    {
        if ((aBucket[i]) == (null))
            continue;
        pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];
    }

    return pIn;
}</function>
  <function>public static RowSetEntry* rowSetListToTree(RowSetEntry* pList)
{
    int iDepth = 0;
    RowSetEntry* p;
    RowSetEntry* pLeft;
    p = pList;
    pList = p-&gt;pRight;
    p-&gt;pLeft = p-&gt;pRight = null;
    for (iDepth = (int)(1); pList; iDepth++)
    {
        pLeft = p;
        p = pList;
        pList = p-&gt;pRight;
        p-&gt;pLeft = pLeft;
        p-&gt;pRight = rowSetNDeepTree(&amp;pList, (int)(iDepth));
    }

    return p;
}</function>
  <function>public static RowSetEntry* rowSetNDeepTree(RowSetEntry** ppList, int iDepth)
{
    RowSetEntry* p;
    RowSetEntry* pLeft;
    if ((*ppList) == (null))
    {
        return null;
    }

    if ((iDepth) &gt; (1))
    {
        pLeft = rowSetNDeepTree(ppList, (int)(iDepth - 1));
        p = *ppList;
        if ((p) == (null))
        {
            return pLeft;
        }

        p-&gt;pLeft = pLeft;
        *ppList = p-&gt;pRight;
        p-&gt;pRight = rowSetNDeepTree(ppList, (int)(iDepth - 1));
    }
    else
    {
        p = *ppList;
        *ppList = p-&gt;pRight;
        p-&gt;pLeft = p-&gt;pRight = null;
    }

    return p;
}</function>
  <function>public static void rowSetTreeToList(RowSetEntry* pIn, RowSetEntry** ppFirst, RowSetEntry** ppLast)
{
    if ((pIn-&gt;pLeft) != null)
    {
        RowSetEntry* p;
        rowSetTreeToList(pIn-&gt;pLeft, ppFirst, &amp;p);
        p-&gt;pRight = pIn;
    }
    else
    {
        *ppFirst = pIn;
    }

    if ((pIn-&gt;pRight) != null)
    {
        rowSetTreeToList(pIn-&gt;pRight, &amp;pIn-&gt;pRight, ppLast);
    }
    else
    {
        *ppLast = pIn;
    }
}</function>
  <function>public static int rtrimCollFunc(void* pUser, int nKey1, void* pKey1, int nKey2, void* pKey2)
{
    byte* pK1 = (byte*)(pKey1);
    byte* pK2 = (byte*)(pKey2);
    while (((nKey1) != 0) &amp;&amp; ((pK1[nKey1 - 1]) == (32)))
    {
        nKey1--;
    }

    while (((nKey2) != 0) &amp;&amp; ((pK2[nKey2 - 1]) == (32)))
    {
        nKey2--;
    }

    return (int)(binCollFunc(pUser, (int)(nKey1), pKey1, (int)(nKey2), pKey2));
}</function>
  <function>public static int saveAllCursors(BtShared pBt, uint iRoot, BtCursor pExcept)
{
    BtCursor p;
    for (p = pBt.pCursor; p; p = p.pNext)
    {
        if ((p != pExcept) &amp;&amp; (((0) == (iRoot)) || ((p.pgnoRoot) == (iRoot))))
            break;
    }

    if ((p) != null)
        return (int)(saveCursorsOnList(p, (uint)(iRoot), pExcept));
    if ((pExcept) != null)
        pExcept.curFlags &amp;= (byte)(~0x20);
    return (int)(0);
}</function>
  <function>public static int saveCursorKey(BtCursor pCur)
{
    int rc = (int)(0);
    if ((pCur.curIntKey) != 0)
    {
        pCur.nKey = (long)(sqlite3BtreeIntegerKey(pCur));
    }
    else
    {
        void* pKey;
        pCur.nKey = (long)(sqlite3BtreePayloadSize(pCur));
        pKey = sqlite3Malloc((ulong)(pCur.nKey + 9 + 8));
        if ((pKey) != null)
        {
            rc = (int)(sqlite3BtreePayload(pCur, (uint)(0), (uint)((int)(pCur.nKey)), pKey));
            if ((rc) == (0))
            {
                CRuntime.memset(((byte*)(pKey)) + pCur.nKey, (int)(0), (ulong)(9 + 8));
                pCur.pKey = pKey;
            }
            else
            {
                sqlite3_free(pKey);
            }
        }
        else
        {
            rc = (int)(7);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int saveCursorPosition(BtCursor pCur)
{
    int rc = 0;
    if ((pCur.curFlags &amp; 0x40) != 0)
    {
        return (int)(19 | (11 &lt;&lt; 8));
    }

    if ((pCur.eState) == (2))
    {
        pCur.eState = (byte)(0);
    }
    else
    {
        pCur.skipNext = (int)(0);
    }

    rc = (int)(saveCursorKey(pCur));
    if ((rc) == (0))
    {
        btreeReleaseAllCursorPages(pCur);
        pCur.eState = (byte)(3);
    }

    pCur.curFlags &amp;= (byte)(~(0x02 | 0x04 | 0x08));
    return (int)(rc);
}</function>
  <function>public static int saveCursorsOnList(BtCursor p, uint iRoot, BtCursor pExcept)
{
    do
    {
        if ((p != pExcept) &amp;&amp; (((0) == (iRoot)) || ((p.pgnoRoot) == (iRoot))))
        {
            if (((p.eState) == (0)) || ((p.eState) == (2)))
            {
                int rc = (int)(saveCursorPosition(p));
                if (0 != rc)
                {
                    return (int)(rc);
                }
            }
            else
            {
                btreeReleaseAllCursorPages(p);
            }
        }

        p = p.pNext;
    }
    while ((p) != null);
    return (int)(0);
}</function>
  <function>public static void schemaIsValid(Parse pParse)
{
    sqlite3 db = pParse.db;
    int iDb = 0;
    int rc = 0;
    int cookie = 0;
    for (iDb = (int)(0); (iDb) &lt; (db.nDb); iDb++)
    {
        int openedTransaction = (int)(0);
        Btree pBt = db.aDb[iDb].pBt;
        if ((pBt) == (null))
            continue;
        if ((sqlite3BtreeTxnState(pBt)) == (0))
        {
            rc = (int)(sqlite3BtreeBeginTrans(pBt, (int)(0), null));
            if (((rc) == (7)) || ((rc) == (10 | (12 &lt;&lt; 8))))
            {
                sqlite3OomFault(db);
                pParse.rc = (int)(7);
            }

            if (rc != 0)
                return;
            openedTransaction = (int)(1);
        }

        sqlite3BtreeGetMeta(pBt, (int)(1), (uint*)(&amp;cookie));
        if (cookie != db.aDb[iDb].pSchema.schema_cookie)
        {
            sqlite3ResetOneSchema(db, (int)(iDb));
            pParse.rc = (int)(17);
        }

        if ((openedTransaction) != 0)
        {
            sqlite3BtreeCommit(pBt);
        }
    }
}</function>
  <function>public static Cte searchWith(With pWith, SrcItem pItem, With ppContext)
{
    sbyte* zName = pItem.zName;
    With p;
    for (p = pWith; p; p = p.pOuter)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (p.nCte); i++)
        {
            if ((sqlite3StrICmp(zName, p.a[i].zName)) == (0))
            {
                ppContext = p;
                return p.a[i];
            }
        }

        if ((p.bView) != 0)
            break;
    }

    return null;
}</function>
  <function>public static void selectAddSubqueryTypeInfo(Walker pWalker, Select p)
{
    Parse pParse;
    int i = 0;
    SrcList pTabList;
    SrcItem pFrom;
    if ((p.selFlags &amp; 0x0000080) != 0)
        return;
    p.selFlags |= (uint)(0x0000080);
    pParse = pWalker.pParse;
    pTabList = p.pSrc;
    for (i = (int)(0), pFrom = pTabList.a; (i) &lt; (pTabList.nSrc); i++, pFrom++)
    {
        Table pTab = pFrom.pTab;
        if ((pTab.tabFlags &amp; 0x00004000) != 0)
        {
            Select pSel = pFrom.pSelect;
            if ((pSel) != null)
            {
                while ((pSel.pPrior) != null)
                {
                    pSel = pSel.pPrior;
                }

                sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel, (sbyte)(0x40));
            }
        }
    }
}</function>
  <function>public static int selectExpander(Walker pWalker, Select p)
{
    Parse pParse = pWalker.pParse;
    int i = 0; int  j  =  0 ;  int  k  =  0 ;  int  rc  =  0 ; 
    SrcList pTabList;
    ExprList pEList;
    SrcItem pFrom;
    sqlite3 db = pParse.db;
    Expr pE; Expr  pRight ;  Expr  pExpr ; 
    ushort selFlags = (ushort)(p.selFlags);
    uint elistFlags = (uint)(0);
    p.selFlags |= (uint)(0x0000040);
    if ((db.mallocFailed) != 0)
    {
        return (int)(2);
    }

    if ((selFlags &amp; 0x0000040) != 0)
    {
        return (int)(1);
    }

    if ((pWalker.eCode) != 0)
    {
        p.selId = (uint)(++pParse.nSelect);
    }

    pTabList = p.pSrc;
    pEList = p.pEList;
    if (((pParse.pWith) != null) &amp;&amp; ((p.selFlags &amp; 0x0200000) != 0))
    {
        if ((p.pWith) == (null))
        {
            p.pWith = (With)(sqlite3DbMallocZero(db, (ulong)(sizeof(With))));
            if ((p.pWith) == (null))
            {
                return (int)(2);
            }
        }

        p.pWith.bView = (int)(1);
    }

    sqlite3WithPush(pParse, p.pWith, (byte)(0));
    sqlite3SrcListAssignCursors(pParse, pTabList);
    for (i = (int)(0), pFrom = pTabList.a; (i) &lt; (pTabList.nSrc); i++, pFrom++)
    {
        Table pTab;
        if ((pFrom.pTab) != null)
            continue;
        if ((pFrom.zName) == (null))
        {
            Select pSel = pFrom.pSelect;
            if ((sqlite3WalkSelect(pWalker, pSel)) != 0)
                return (int)(2);
            if ((sqlite3ExpandSubquery(pParse, pFrom)) != 0)
                return (int)(2);
        }
        else if ((rc = (int)(resolveFromTermToCte(pParse, pWalker, pFrom))) != 0)
        {
            if ((rc) &gt; (1))
                return (int)(2);
            pTab = pFrom.pTab;
        }
        else
        {
            pFrom.pTab = pTab = sqlite3LocateTableItem(pParse, (uint)(0), pFrom);
            if ((pTab) == (null))
                return (int)(2);
            if ((pTab.nTabRef) &gt;= (0xffff))
            {
                sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535", pTab.zName);
                pFrom.pTab = null;
                return (int)(2);
            }

            pTab.nTabRef++;
            if ((!(((pTab).eTabType) == (1))) &amp;&amp; ((cannotBeFunction(pParse, pFrom)) != 0))
            {
                return (int)(2);
            }

            if (!(((pTab).eTabType) == (0)))
            {
                short nCol = 0;
                byte eCodeOrig = (byte)(pWalker.eCode);
                if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
                    return (int)(2);
                if ((((pTab).eTabType) == (2)))
                {
                    if (((db.flags &amp; 0x80000000) == (0)) &amp;&amp; (pTab.pSchema != db.aDb[1].pSchema))
                    {
                        sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited", pTab.zName);
                    }

                    pFrom.pSelect = sqlite3SelectDup(db, pTab.u.view.pSelect, (int)(0));
                }
                else if (((((((pTab).eTabType) == (1)) != 0) &amp;&amp; ((pFrom.fg.fromDDL) != 0)) &amp;&amp; (pTab.u.vtab.p != null)) &amp;&amp; ((pTab.u.vtab.p.eVtabRisk) &gt; ((db.flags &amp; 0x00000080) != 0)))
                {
                    sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"", pTab.zName);
                }

                nCol = (short)(pTab.nCol);
                pTab.nCol = (short)(-1);
                pWalker.eCode = (ushort)(1);
                sqlite3WalkSelect(pWalker, pFrom.pSelect);
                pWalker.eCode = (ushort)(eCodeOrig);
                pTab.nCol = (short)(nCol);
            }
        }

        if (((pFrom.fg.isIndexedBy) != 0) &amp;&amp; ((sqlite3IndexedByLookup(pParse, pFrom)) != 0))
        {
            return (int)(2);
        }
    }

    if (((pParse.nErr) != 0) || ((sqliteProcessJoin(pParse, p)) != 0))
    {
        return (int)(2);
    }

    for (k = (int)(0); (k) &lt; (pEList.nExpr); k++)
    {
        pE = pEList.a[k].pExpr;
        if ((pE.op) == (180))
            break;
        if (((pE.op) == (141)) &amp;&amp; ((pE.pRight.op) == (180)))
            break;
        elistFlags |= (uint)(pE.flags);
    }

    if ((k) &lt; (pEList.nExpr))
    {
        ExprList_item* a = pEList.a;
        ExprList pNew = null;
        int flags = (int)(pParse.db.flags);
        int longNames = (int)(((flags &amp; 0x00000004) != 0) &amp;&amp; ((flags &amp; 0x00000040) == (0)) ? 1 : 0);
        for (k = (int)(0); (k) &lt; (pEList.nExpr); k++)
        {
            pE = a[k].pExpr;
            elistFlags |= (uint)(pE.flags);
            pRight = pE.pRight;
            if ((pE.op != 180) &amp;&amp; ((pE.op != 141) || (pRight.op != 180)))
            {
                pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
                if ((pNew) != null)
                {
                    pNew.a[pNew.nExpr - 1].zEName = a[k].zEName;
                    pNew.a[pNew.nExpr - 1].eEName = (uint)(a[k].eEName);
                    a[k].zEName = null;
                }

                a[k].pExpr = null;
            }
            else
            {
                int tableSeen = (int)(0);
                sbyte* zTName = null;
                if ((pE.op) == (141))
                {
                    zTName = pE.pLeft.u.zToken;
                }

                for (i = (int)(0), pFrom = pTabList.a; (i) &lt; (pTabList.nSrc); i++, pFrom++)
                {
                    Table pTab = pFrom.pTab;
                    Select pSub = pFrom.pSelect;
                    sbyte* zTabName = pFrom.zAlias;
                    sbyte* zSchemaName = null;
                    int iDb = 0;
                    if ((zTabName) == (null))
                    {
                        zTabName = pTab.zName;
                    }

                    if ((db.mallocFailed) != 0)
                        break;
                    if (((pSub) == (null)) || ((pSub.selFlags &amp; 0x0000800) == (0)))
                    {
                        pSub = null;
                        if (((zTName) != null) &amp;&amp; (sqlite3StrICmp(zTName, zTabName) != 0))
                        {
                            continue;
                        }

                        iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
                        zSchemaName = (iDb) &gt;= (0) ? db.aDb[iDb].zDbSName : "*";
                    }

                    for (j = (int)(0); (j) &lt; (pTab.nCol); j++)
                    {
                        sbyte* zName = pTab.aCol[j].zCnName;
                        sbyte* zColname;
                        sbyte* zToFree;
                        Token sColname = new Token();
                        if ((((zTName) != null) &amp;&amp; ((pSub) != null)) &amp;&amp; ((sqlite3MatchEName(&amp;pSub.pEList.a[j], null, zTName, null)) == (0)))
                        {
                            continue;
                        }

                        if (((p.selFlags &amp; 0x0020000) == (0)) &amp;&amp; (((&amp;pTab.aCol[j])-&gt;colFlags &amp; 0x0002) != 0))
                        {
                            continue;
                        }

                        tableSeen = (int)(1);
                        if (((i) &gt; (0)) &amp;&amp; ((zTName) == (null)))
                        {
                            if (((pFrom.fg.jointype &amp; 0x0004) != 0) &amp;&amp; ((tableAndColumnIndex(pTabList, (int)(i), zName, null, null, (int)(1))) != 0))
                            {
                                continue;
                            }

                            if ((sqlite3IdListIndex(pFrom.pUsing, zName)) &gt;= (0))
                            {
                                continue;
                            }
                        }

                        pRight = sqlite3Expr(db, (int)(59), zName);
                        zColname = zName;
                        zToFree = null;
                        if (((longNames) != 0) || ((pTabList.nSrc) &gt; (1)))
                        {
                            Expr pLeft;
                            pLeft = sqlite3Expr(db, (int)(59), zTabName);
                            pExpr = sqlite3PExpr(pParse, (int)(141), pLeft, pRight);
                            if ((zSchemaName) != null)
                            {
                                pLeft = sqlite3Expr(db, (int)(59), zSchemaName);
                                pExpr = sqlite3PExpr(pParse, (int)(141), pLeft, pExpr);
                            }

                            if ((longNames) != 0)
                            {
                                zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
                                zToFree = zColname;
                            }
                        }
                        else
                        {
                            pExpr = pRight;
                        }

                        pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
                        sqlite3TokenInit(&amp;sColname, zColname);
                        sqlite3ExprListSetName(pParse, pNew, &amp;sColname, (int)(0));
                        if ((((pNew) != null) &amp;&amp; ((p.selFlags &amp; 0x0000800) != 0)) &amp;&amp; (!((pParse.eParseMode) &gt;= (2))))
                        {
                            ExprList_item* pX = &amp;pNew.a[pNew.nExpr - 1];
                            sqlite3DbFree(db, pX-&gt;zEName);
                            if ((pSub) != null)
                            {
                                pX-&gt;zEName = sqlite3DbStrDup(db, pSub.pEList.a[j].zEName);
                            }
                            else
                            {
                                pX-&gt;zEName = sqlite3MPrintf(db, "%s.%s.%s", zSchemaName, zTabName, zColname);
                            }

                            pX-&gt;eEName = (uint)(2);
                        }

                        sqlite3DbFree(db, zToFree);
                    }
                }

                if (tableSeen == 0)
                {
                    if ((zTName) != null)
                    {
                        sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
                    }
                    else
                    {
                        sqlite3ErrorMsg(pParse, "no tables specified");
                    }
                }
            }
        }

        sqlite3ExprListDelete(db, pEList);
        p.pEList = pNew;
    }

    if ((p.pEList) != null)
    {
        if ((p.pEList.nExpr) &gt; (db.aLimit[2]))
        {
            sqlite3ErrorMsg(pParse, "too many columns in result set");
            return (int)(2);
        }

        if ((elistFlags &amp; (0x000004 | 0x200000)) != 0)
        {
            p.selFlags |= (uint)(0x0040000);
        }
    }

    return (int)(0);
}</function>
  <function>public static void selectInnerLoop(Parse pParse, Select p, int srcTab, SortCtx pSort, DistinctCtx* pDistinct, SelectDest pDest, int iContinue, int iBreak)
{
    Vdbe v = pParse.pVdbe;
    int i = 0;
    int hasDistinct = 0;
    int eDest = (int)(pDest.eDest);
    int iParm = (int)(pDest.iSDParm);
    int nResultCol = 0;
    int nPrefixReg = (int)(0);
    RowLoadInfo sRowLoadInfo = new RowLoadInfo();
    int regResult = 0;
    int regOrig = 0;
    hasDistinct = (int)(pDistinct ? pDistinct-&gt;eTnctType : 0);
    if (((pSort) != null) &amp;&amp; ((pSort.pOrderBy) == (null)))
        pSort = null;
    if (((pSort) == (null)) &amp;&amp; (hasDistinct == 0))
    {
        codeOffset(v, (int)(p.iOffset), (int)(iContinue));
    }

    nResultCol = (int)(p.pEList.nExpr);
    if ((pDest.iSdst) == (0))
    {
        if ((pSort) != null)
        {
            nPrefixReg = (int)(pSort.pOrderBy.nExpr);
            if ((pSort.sortFlags &amp; 0x01) == 0)
                nPrefixReg++;
            pParse.nMem += (int)(nPrefixReg);
        }

        pDest.iSdst = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nResultCol);
    }
    else if ((pDest.iSdst + nResultCol) &gt; (pParse.nMem))
    {
        pParse.nMem += (int)(nResultCol);
    }

    pDest.nSdst = (int)(nResultCol);
    regOrig = (int)(regResult = (int)(pDest.iSdst));
    if ((srcTab) &gt;= (0))
    {
        for (i = (int)(0); (i) &lt; (nResultCol); i++)
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(i), (int)(regResult + i));
        }
    }
    else if (eDest != 3)
    {
        byte ecelFlags = 0;
        ExprList pEList;
        if ((((eDest) == (10)) || ((eDest) == (9))) || ((eDest) == (13)))
        {
            ecelFlags = (byte)(0x01);
        }
        else
        {
            ecelFlags = (byte)(0);
        }

        if (((((pSort) != null) &amp;&amp; ((hasDistinct) == (0))) &amp;&amp; (eDest != 12)) &amp;&amp; (eDest != 14))
        {
            ecelFlags |= (byte)(0x08 | 0x04);
            for (i = (int)(pSort.nOBSat); (i) &lt; (pSort.pOrderBy.nExpr); i++)
            {
                int j = 0;
                if ((j = (int)(pSort.pOrderBy.a[i].u.x.iOrderByCol)) &gt; (0))
                {
                    p.pEList.a[j - 1].u.x.iOrderByCol = (ushort)(i + 1 - pSort.nOBSat);
                }
            }

            pEList = p.pEList;
            for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
            {
                if ((pEList.a[i].u.x.iOrderByCol) &gt; (0))
                {
                    nResultCol--;
                    regOrig = (int)(0);
                }
            }
        }

        sRowLoadInfo.regResult = (int)(regResult);
        sRowLoadInfo.ecelFlags = (byte)(ecelFlags);
        if ((((p.iLimit) != 0) &amp;&amp; ((ecelFlags &amp; 0x08) != 0)) &amp;&amp; ((nPrefixReg) &gt; (0)))
        {
            pSort.pDeferredRowLoad = &amp;sRowLoadInfo;
            regOrig = (int)(0);
        }
        else
        {
            innerLoopLoadRow(pParse, p, &amp;sRowLoadInfo);
        }
    }

    if ((hasDistinct) != 0)
    {
        int eType = (int)(pDistinct-&gt;eTnctType);
        int iTab = (int)(pDistinct-&gt;tabTnct);
        iTab = (int)(codeDistinct(pParse, (int)(eType), (int)(iTab), (int)(iContinue), p.pEList, (int)(regResult)));
        fixDistinctOpenEph(pParse, (int)(eType), (int)(iTab), (int)(pDistinct-&gt;addrTnct));
        if ((pSort) == (null))
        {
            codeOffset(v, (int)(p.iOffset), (int)(iContinue));
        }
    }

    switch (eDest)
    {
        case 1:
        {
            int r1 = 0;
            r1 = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1));
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(nResultCol));
            sqlite3ReleaseTempReg(pParse, (int)(r1));
            break;
        }

        case 2:
        {
            sqlite3VdbeAddOp3(v, (int)(139), (int)(iParm), (int)(regResult), (int)(nResultCol));
            break;
        }

        case 8:
        case 5:
        case 14:
        case 12:
        {
            int r1 = (int)(sqlite3GetTempRange(pParse, (int)(nPrefixReg + 1)));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1 + nPrefixReg));
            if ((eDest) == (5))
            {
                int addr = (int)(sqlite3VdbeCurrentAddr(v) + 4);
                sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iParm + 1), (int)(addr), (int)(r1), (int)(0));
                sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm + 1), (int)(r1), (int)(regResult), (int)(nResultCol));
            }

            if ((pSort) != null)
            {
                pushOntoSorter(pParse, pSort, p, (int)(r1 + nPrefixReg), (int)(regOrig), (int)(1), (int)(nPrefixReg));
            }
            else
            {
                int r2 = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp2(v, (int)(126), (int)(iParm), (int)(r2));
                sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(r2));
                sqlite3VdbeChangeP5(v, (ushort)(0x08));
                sqlite3ReleaseTempReg(pParse, (int)(r2));
            }

            sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(nPrefixReg + 1));
            break;
        }

        case 15:
        {
            if ((pSort) != null)
            {
                pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
            }
            else
            {
                int i2 = (int)(pDest.iSDParm2);
                int r1 = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp2(v, (int)(50), (int)(regResult), (int)(iBreak));
                sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult + ((i2) &lt; (0))), (int)(nResultCol - ((i2) &lt; (0))), (int)(r1));
                if ((i2) &lt; (0))
                {
                    sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(regResult));
                }
                else
                {
                    sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(i2));
                }
            }

            break;
        }

        case 11:
        {
            if ((pSort) != null)
            {
                pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
            }
            else
            {
                int r1 = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp4(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1), pDest.zAffSdst, (int)(nResultCol));
                sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(nResultCol));
                sqlite3ReleaseTempReg(pParse, (int)(r1));
            }

            break;
        }

        case 3:
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iParm));
            break;
        }

        case 10:
        {
            if ((pSort) != null)
            {
                pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
            }
            else
            {
            }

            break;
        }

        case 13:
        case 9:
        {
            if ((pSort) != null)
            {
                pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
            }
            else if ((eDest) == (13))
            {
                sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(83), (int)(regResult), (int)(nResultCol));
            }

            break;
        }

        case 6:
        case 7:
        {
            int nKey = 0;
            int r1 = 0;
            int r2 = 0;
            int r3 = 0;
            int addrTest = (int)(0);
            ExprList pSO;
            pSO = pDest.pOrderBy;
            nKey = (int)(pSO.nExpr);
            r1 = (int)(sqlite3GetTempReg(pParse));
            r2 = (int)(sqlite3GetTempRange(pParse, (int)(nKey + 2)));
            r3 = (int)(r2 + nKey + 1);
            if ((eDest) == (6))
            {
                addrTest = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iParm + 1), (int)(0), (int)(regResult), (int)(nResultCol)));
            }

            sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r3));
            if ((eDest) == (6))
            {
                sqlite3VdbeAddOp2(v, (int)(137), (int)(iParm + 1), (int)(r3));
                sqlite3VdbeChangeP5(v, (ushort)(0x10));
            }

            for (i = (int)(0); (i) &lt; (nKey); i++)
            {
                sqlite3VdbeAddOp2(v, (int)(80), (int)(regResult + pSO.a[i].u.x.iOrderByCol - 1), (int)(r2 + i));
            }

            sqlite3VdbeAddOp2(v, (int)(125), (int)(iParm), (int)(r2 + nKey));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(r2), (int)(nKey + 2), (int)(r1));
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(r2), (int)(nKey + 2));
            if ((addrTest) != 0)
                sqlite3VdbeJumpHere(v, (int)(addrTest));
            sqlite3ReleaseTempReg(pParse, (int)(r1));
            sqlite3ReleaseTempRange(pParse, (int)(r2), (int)(nKey + 2));
            break;
        }

        default:
        {
            break;
        }
    }

    if (((pSort) == (null)) &amp;&amp; ((p.iLimit) != 0))
    {
        sqlite3VdbeAddOp2(v, (int)(60), (int)(p.iLimit), (int)(iBreak));
    }
}</function>
  <function>public static int selectRefEnter(Walker pWalker, Select pSelect)
{
    RefSrcList p = pWalker.u.pRefSrcList;
    SrcList pSrc = pSelect.pSrc;
    long i = 0; long  j  =  0 ; 
    int* piNew;
    if ((pSrc.nSrc) == (0))
        return (int)(0);
    j = (long)(p.nExclude);
    p.nExclude += (long)(pSrc.nSrc);
    piNew = sqlite3DbRealloc(p.db, p.aiExclude, (ulong)(p.nExclude * sizeof(int)));
    if ((piNew) == (null))
    {
        p.nExclude = (long)(0);
        return (int)(2);
    }
    else
    {
        p.aiExclude = piNew;
    }

    for (i = (long)(0); (i) &lt; (pSrc.nSrc); i++, j++)
    {
        p.aiExclude[j] = (int)(pSrc.a[i].iCursor);
    }

    return (int)(0);
}</function>
  <function>public static void selectRefLeave(Walker pWalker, Select pSelect)
{
    RefSrcList p = pWalker.u.pRefSrcList;
    SrcList pSrc = pSelect.pSrc;
    if ((p.nExclude) != 0)
    {
        p.nExclude -= (long)(pSrc.nSrc);
    }
}</function>
  <function>public static void selectWindowRewriteEList(Parse pParse, Window pWin, SrcList pSrc, ExprList pEList, Table pTab, ExprList ppSub)
{
    Walker sWalker = new Walker();
    WindowRewrite sRewrite = new WindowRewrite();
    CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
    CRuntime.memset(sRewrite, (int)(0), (ulong)(sizeof(WindowRewrite)));
    sRewrite.pSub = ppSub;
    sRewrite.pWin = pWin;
    sRewrite.pSrc = pSrc;
    sRewrite.pTab = pTab;
    sWalker.pParse = pParse;
    sWalker.xExprCallback = selectWindowRewriteExprCb;
    sWalker.xSelectCallback = selectWindowRewriteSelectCb;
    sWalker.u.pRewrite = sRewrite;
    (void)(sqlite3WalkExprList(sWalker, pEList));
    ppSub = sRewrite.pSub;
}</function>
  <function>public static int selectWindowRewriteExprCb(Walker pWalker, Expr pExpr)
{
    WindowRewrite p = pWalker.u.pRewrite;
    Parse pParse = pWalker.pParse;
    if ((p.pSubSelect) != null)
    {
        if (pExpr.op != 167)
        {
            return (int)(0);
        }
        else
        {
            int nSrc = (int)(p.pSrc.nSrc);
            int i = 0;
            for (i = (int)(0); (i) &lt; (nSrc); i++)
            {
                if ((pExpr.iTable) == (p.pSrc.a[i].iCursor))
                    break;
            }

            if ((i) == (nSrc))
                return (int)(0);
        }
    }

    switch (pExpr.op)
    {
        case 172:
            if (!(((pExpr).flags &amp; (0x1000000)) != 0))
            {
                break;
            }
            else
            {
                Window pWin;
                for (pWin = p.pWin; pWin; pWin = pWin.pNextWin)
                {
                    if ((pExpr.y.pWin) == (pWin))
                    {
                        return (int)(1);
                    }
                }
            }

        case 168:
        case 167:
        {
            int iCol = (int)(-1);
            if ((pParse.db.mallocFailed) != 0)
                return (int)(2);
            if ((p.pSub) != null)
            {
                int i = 0;
                for (i = (int)(0); (i) &lt; (p.pSub.nExpr); i++)
                {
                    if ((0) == (sqlite3ExprCompare(null, p.pSub.a[i].pExpr, pExpr, (int)(-1))))
                    {
                        iCol = (int)(i);
                        break;
                    }
                }
            }

            if ((iCol) &lt; (0))
            {
                Expr pDup = sqlite3ExprDup(pParse.db, pExpr, (int)(0));
                if (((pDup) != null) &amp;&amp; ((pDup.op) == (168)))
                    pDup.op = (byte)(172);
                p.pSub = sqlite3ExprListAppend(pParse, p.pSub, pDup);
            }

            if ((p.pSub) != null)
            {
                int f = (int)(pExpr.flags &amp; 0x000100);
                (pExpr).flags |= (uint)(0x8000000);
                sqlite3ExprDelete(pParse.db, pExpr);
                (pExpr).flags &amp;= (uint)(~(0x8000000));
                CRuntime.memset(pExpr, (int)(0), (ulong)(sizeof(Expr)));
                pExpr.op = (byte)(167);
                pExpr.iColumn = (short)((iCol) &lt; (0) ? p.pSub.nExpr - 1 : iCol);
                pExpr.iTable = (int)(p.pWin.iEphCsr);
                pExpr.y.pTab = p.pTab;
                pExpr.flags = (uint)(f);
            }

            if ((pParse.db.mallocFailed) != 0)
                return (int)(2);
            break;
        }

        default:
            break;
    }

    return (int)(0);
}</function>
  <function>public static int selectWindowRewriteSelectCb(Walker pWalker, Select pSelect)
{
    WindowRewrite p = pWalker.u.pRewrite;
    Select pSave = p.pSubSelect;
    if ((pSave) == (pSelect))
    {
        return (int)(0);
    }
    else
    {
        p.pSubSelect = pSelect;
        sqlite3WalkSelect(pWalker, pSelect);
        p.pSubSelect = pSave;
    }

    return (int)(1);
}</function>
  <function>public static void serialGet(byte* buf, uint serial_type, sqlite3_value pMem)
{
    ulong x = (ulong)(((uint)((buf)[0]) &lt;&lt; 24) | ((buf)[1] &lt;&lt; 16) | ((buf)[2] &lt;&lt; 8) | (buf)[3]);
    uint y = (uint)(((uint)((buf + 4)[0]) &lt;&lt; 24) | ((buf + 4)[1] &lt;&lt; 16) | ((buf + 4)[2] &lt;&lt; 8) | (buf + 4)[3]);
    x = (ulong)((x &lt;&lt; 32) + y);
    if ((serial_type) == (6))
    {
        pMem.u.i = (long)(*(long*)(&amp;x));
        pMem.flags = (ushort)(0x0004);
    }
    else
    {
        CRuntime.memcpy(&amp;pMem.u.r, &amp;x, (ulong)(sizeof(ulong)));
        pMem.flags = (ushort)(((((x) &amp; (((ulong)(0x7ff)) &lt;&lt; 52)) == (((ulong)(0x7ff)) &lt;&lt; 52)) &amp;&amp; (((x) &amp; ((((ulong)(1)) &lt;&lt; 52) - 1)) != 0)) ? 0x0001 : 0x0008);
    }
}</function>
  <function>public static void setAllPagerFlags(sqlite3 db)
{
    if ((db.autoCommit) != 0)
    {
        Db pDb = db.aDb;
        int n = (int)(db.nDb);
        while ((n--) &gt; (0))
        {
            if ((pDb.pBt) != null)
            {
                sqlite3BtreeSetPagerFlags(pDb.pBt, (uint)(pDb.safety_level | (db.flags &amp; 0x38)));
            }

            pDb++;
        }
    }
}</function>
  <function>public static int setChildPtrmaps(MemPage pPage)
{
    int i = 0;
    int nCell = 0;
    int rc = 0;
    BtShared pBt = pPage.pBt;
    uint pgno = (uint)(pPage.pgno);
    rc = (int)((pPage.isInit) != 0 ? 0 : btreeInitPage(pPage));
    if (rc != 0)
        return (int)(rc);
    nCell = (int)(pPage.nCell);
    for (i = (int)(0); (i) &lt; (nCell); i++)
    {
        byte* pCell = ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (i)])))));
        ptrmapPutOvflPtr(pPage, pPage, pCell, &amp;rc);
        if (pPage.leaf == 0)
        {
            uint childPgno = (uint)(sqlite3Get4byte(pCell));
            ptrmapPut(pBt, (uint)(childPgno), (byte)(5), (uint)(pgno), &amp;rc);
        }
    }

    if (pPage.leaf == 0)
    {
        uint childPgno = (uint)(sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]));
        ptrmapPut(pBt, (uint)(childPgno), (byte)(5), (uint)(pgno), &amp;rc);
    }

    return (int)(rc);
}</function>
  <function>public static int setDateTimeToCurrent(sqlite3_context context, DateTime* p)
{
    p-&gt;iJD = (long)(sqlite3StmtCurrentTime(context));
    if ((p-&gt;iJD) &gt; (0))
    {
        p-&gt;validJD = (sbyte)(1);
        return (int)(0);
    }
    else
    {
        return (int)(1);
    }
}</function>
  <function>public static int setDestPgsz(sqlite3_backup p)
{
    int rc = 0;
    rc = (int)(sqlite3BtreeSetPageSize(p.pDest, (int)(sqlite3BtreeGetPageSize(p.pSrc)), (int)(0), (int)(0)));
    return (int)(rc);
}</function>
  <function>public static void setDoNotMergeFlagOnCopy(Vdbe v)
{
    if ((sqlite3VdbeGetOp(v, (int)(-1))-&gt;opcode) == (79))
    {
        sqlite3VdbeChangeP5(v, (ushort)(1));
    }
}</function>
  <function>public static void setGetterMethod(Pager pPager)
{
    if ((pPager.errCode) != 0)
    {
        pPager.xGet = getPageError;
    }
    else if (((pPager).bUseFetch) != 0)
    {
        pPager.xGet = getPageMMap;
    }
    else
    {
        pPager.xGet = getPageNormal;
    }
}</function>
  <function>public static void setPageReferenced(IntegrityCk pCheck, uint iPg)
{
    pCheck.aPgRef[iPg / 8] |= (byte)(1 &lt;&lt; (iPg &amp; 0x07));
}</function>
  <function>public static void setPragmaResultColumnNames(Vdbe v, PragmaName* pPragma)
{
    byte n = (byte)(pPragma-&gt;nPragCName);
    sqlite3VdbeSetNumCols(v, (int)((n) == (0) ? 1 : n));
    if ((n) == (0))
    {
        sqlite3VdbeSetColName(v, (int)(0), (int)(0), pPragma-&gt;zName, null);
    }
    else
    {
        int i = 0;
        int j = 0;
        for (i = (int)(0), j = (int)(pPragma-&gt;iPragCName); (i) &lt; (n); i++, j++)
        {
            sqlite3VdbeSetColName(v, (int)(i), (int)(0), pragCName[j], null);
        }
    }
}</function>
  <function>public static void setRawDateNumber(DateTime* p, double r)
{
    p-&gt;s = (double)(r);
    p-&gt;rawS = (sbyte)(1);
    if (((r) &gt;= (0.0)) &amp;&amp; ((r) &lt; (5373484.5)))
    {
        p-&gt;iJD = ((long)(r * 86400000.0 + 0.5));
        p-&gt;validJD = (sbyte)(1);
    }
}</function>
  <function>public static void setResultStrOrError(sqlite3_context pCtx, sbyte* z, int n, byte enc, delegate17 xDel)
{
    int rc = (int)(sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(enc), xDel));
    if ((rc) != 0)
    {
        if ((rc) == (18))
        {
            sqlite3_result_error_toobig(pCtx);
        }
        else
        {
            sqlite3_result_error_nomem(pCtx);
        }
    }
}</function>
  <function>public static void setSectorSize(Pager pPager)
{
    if (((pPager.tempFile) != 0) || ((sqlite3OsDeviceCharacteristics(pPager.fd) &amp; 0x00001000) != 0))
    {
        pPager.sectorSize = (uint)(512);
    }
    else
    {
        pPager.sectorSize = (uint)(sqlite3SectorSize(pPager.fd));
    }
}</function>
  <function>public static int setSharedCacheTableLock(Btree p, uint iTable, byte eLock)
{
    BtShared pBt = p.pBt;
    BtLock pLock = null;
    BtLock pIter;
    for (pIter = pBt.pLock; pIter; pIter = pIter.pNext)
    {
        if (((pIter.iTable) == (iTable)) &amp;&amp; ((pIter.pBtree) == (p)))
        {
            pLock = pIter;
            break;
        }
    }

    if (pLock == null)
    {
        pLock = (BtLock)(sqlite3MallocZero((ulong)(sizeof(BtLock))));
        if (pLock == null)
        {
            return (int)(7);
        }

        pLock.iTable = (uint)(iTable);
        pLock.pBtree = p;
        pLock.pNext = pBt.pLock;
        pBt.pLock = pLock;
    }

    if ((eLock) &gt; (pLock.eLock))
    {
        pLock.eLock = (byte)(eLock);
    }

    return (int)(0);
}</function>
  <function>public static int setupLookaside(sqlite3 db, void* pBuf, int sz, int cnt)
{
    void* pStart;
    long szAlloc = (long)(sz * (long)(cnt));
    int nBig = 0;
    int nSm = 0;
    if ((sqlite3LookasideUsed(db, null)) &gt; (0))
    {
        return (int)(5);
    }

    if ((db.lookaside.bMalloced) != 0)
    {
        sqlite3_free(db.lookaside.pStart);
    }

    sz = (int)((sz) &amp; ~7);
    if ((sz) &lt;= ((int)(sizeof(LookasideSlot))))
        sz = (int)(0);
    if ((cnt) &lt; (0))
        cnt = (int)(0);
    if (((sz) == (0)) || ((cnt) == (0)))
    {
        sz = (int)(0);
        pStart = null;
    }
    else if ((pBuf) == (null))
    {
        sqlite3BeginBenignMalloc();
        pStart = sqlite3Malloc((ulong)(szAlloc));
        sqlite3EndBenignMalloc();
        if ((pStart) != null)
            szAlloc = (long)(sqlite3MallocSize(pStart));
    }
    else
    {
        pStart = pBuf;
    }

    if ((sz) &gt;= (128 * 3))
    {
        nBig = (int)(szAlloc / (3 * 128 + sz));
        nSm = (int)((szAlloc - sz * nBig) / 128);
    }
    else if ((sz) &gt;= (128 * 2))
    {
        nBig = (int)(szAlloc / (128 + sz));
        nSm = (int)((szAlloc - sz * nBig) / 128);
    }
    else if ((sz) &gt; (0))
    {
        nBig = (int)(szAlloc / sz);
        nSm = (int)(0);
    }
    else
    {
        nBig = (int)(nSm = (int)(0));
    }

    db.lookaside.pStart = pStart;
    db.lookaside.pInit = null;
    db.lookaside.pFree = null;
    db.lookaside.sz = ((ushort)(sz));
    db.lookaside.szTrue = ((ushort)(sz));
    if ((pStart) != null)
    {
        int i = 0;
        LookasideSlot* p;
        p = (LookasideSlot*)(pStart);
        for (i = (int)(0); (i) &lt; (nBig); i++)
        {
            p-&gt;pNext = db.lookaside.pInit;
            db.lookaside.pInit = p;
            p = (LookasideSlot*)(&amp;((byte*)(p))[sz]);
        }

        db.lookaside.pSmallInit = null;
        db.lookaside.pSmallFree = null;
        db.lookaside.pMiddle = p;
        for (i = (int)(0); (i) &lt; (nSm); i++)
        {
            p-&gt;pNext = db.lookaside.pSmallInit;
            db.lookaside.pSmallInit = p;
            p = (LookasideSlot*)(&amp;((byte*)(p))[128]);
        }

        db.lookaside.pEnd = p;
        db.lookaside.bDisable = (uint)(0);
        db.lookaside.bMalloced = (byte)((pBuf) == (null) ? 1 : 0);
        db.lookaside.nSlot = (uint)(nBig + nSm);
    }
    else
    {
        db.lookaside.pStart = db;
        db.lookaside.pSmallInit = null;
        db.lookaside.pSmallFree = null;
        db.lookaside.pMiddle = db;
        db.lookaside.pEnd = db;
        db.lookaside.bDisable = (uint)(1);
        db.lookaside.sz = (ushort)(0);
        db.lookaside.bMalloced = (byte)(0);
        db.lookaside.nSlot = (uint)(0);
    }

    return (int)(0);
}</function>
  <function>public static void signFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    int type0 = 0;
    double x = 0;
    type0 = (int)(sqlite3_value_numeric_type(argv[0]));
    if ((type0 != 1) &amp;&amp; (type0 != 2))
        return;
    x = (double)(sqlite3_value_double(argv[0]));
    sqlite3_result_int(context, (int)((x) &lt; (0.0) ? -1 : (x) &gt; (0.0) ? +1 : 0));
}</function>
  <function>public static void sourceidFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    sqlite3_result_text(context, sqlite3_sourceid(), (int)(-1), null);
}</function>
  <function>public static void* sqlite3_aggregate_context(sqlite3_context p, int nByte)
{
    if ((p.pMem.flags &amp; 0x2000) == (0))
    {
        return createAggContext(p, (int)(nByte));
    }
    else
    {
        return (void*)(p.pMem.z);
    }
}</function>
  <function>public static int sqlite3_aggregate_count(sqlite3_context p)
{
    return (int)(p.pMem.n);
}</function>
  <function>public static int sqlite3_auto_extension(delegate74 xInit)
{
    int rc = (int)(0);
    rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
    {
        return (int)(rc);
    }
    else
    {
        uint i = 0;
        sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
        sqlite3_mutex_enter(mutex);
        for (i = (uint)(0); (i) &lt; (sqlite3Autoext.nExt); i++)
        {
            if ((sqlite3Autoext.aExt[i]) == (xInit))
                break;
        }

        if ((i) == (sqlite3Autoext.nExt))
        {
            ulong nByte = (ulong)((sqlite3Autoext.nExt + 1) * sizeof(Void()) )
            ;
            delegate171 aNew;
            aNew = sqlite3_realloc64(sqlite3Autoext.aExt, (ulong)(nByte));
            if ((aNew) == (null))
            {
                rc = (int)(7);
            }
            else
            {
                sqlite3Autoext.aExt = aNew;
                sqlite3Autoext.aExt[sqlite3Autoext.nExt] = xInit;
                sqlite3Autoext.nExt++;
            }
        }

        sqlite3_mutex_leave(mutex);
        return (int)(rc);
    }
}</function>
  <function>public static int sqlite3_autovacuum_pages(sqlite3 db, delegate65 xCallback, void* pArg, delegate17 xDestructor)
{
    sqlite3_mutex_enter(db.mutex);
    if ((db.xAutovacDestr) != null)
    {
        db.xAutovacDestr(db.pAutovacPagesArg);
    }

    db.xAutovacPages = xCallback;
    db.pAutovacPagesArg = pArg;
    db.xAutovacDestr = xDestructor;
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_backup_finish(sqlite3_backup p)
{
    sqlite3_backup pp;
    sqlite3 pSrcDb;
    int rc = 0;
    if ((p) == (null))
        return (int)(0);
    pSrcDb = p.pSrcDb;
    sqlite3_mutex_enter(pSrcDb.mutex);
    sqlite3BtreeEnter(p.pSrc);
    if ((p.pDestDb) != null)
    {
        sqlite3_mutex_enter(p.pDestDb.mutex);
    }

    if ((p.pDestDb) != null)
    {
        p.pSrc.nBackup--;
    }

    if ((p.isAttached) != 0)
    {
        pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p.pSrc));
        while (pp != p)
        {
            pp = (pp).pNext;
        }

        pp = p.pNext;
    }

    sqlite3BtreeRollback(p.pDest, (int)(0), (int)(0));
    rc = (int)(((p.rc) == (101)) ? 0 : p.rc);
    if ((p.pDestDb) != null)
    {
        sqlite3Error(p.pDestDb, (int)(rc));
        sqlite3LeaveMutexAndCloseZombie(p.pDestDb);
    }

    sqlite3BtreeLeave(p.pSrc);
    if ((p.pDestDb) != null)
    {
        sqlite3_free(p);
    }

    sqlite3LeaveMutexAndCloseZombie(pSrcDb);
    return (int)(rc);
}</function>
  <function>public static sqlite3_backup sqlite3_backup_init(sqlite3 pDestDb, sbyte* zDestDb, sqlite3 pSrcDb, sbyte* zSrcDb)
{
    sqlite3_backup p;
    sqlite3_mutex_enter(pSrcDb.mutex);
    sqlite3_mutex_enter(pDestDb.mutex);
    if ((pSrcDb) == (pDestDb))
    {
        sqlite3ErrorWithMsg(pDestDb, (int)(1), "source and destination must be distinct");
        p = null;
    }
    else
    {
        p = (sqlite3_backup)(sqlite3MallocZero((ulong)(sizeof(sqlite3_backup))));
        if (p == null)
        {
            sqlite3Error(pDestDb, (int)(7));
        }
    }

    if ((p) != null)
    {
        p.pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
        p.pDest = findBtree(pDestDb, pDestDb, zDestDb);
        p.pDestDb = pDestDb;
        p.pSrcDb = pSrcDb;
        p.iNext = (uint)(1);
        p.isAttached = (int)(0);
        if ((((null) == (p.pSrc)) || ((null) == (p.pDest))) || (checkReadTransaction(pDestDb, p.pDest) != 0))
        {
            sqlite3_free(p);
            p = null;
        }
    }

    if ((p) != null)
    {
        p.pSrc.nBackup++;
    }

    sqlite3_mutex_leave(pDestDb.mutex);
    sqlite3_mutex_leave(pSrcDb.mutex);
    return p;
}</function>
  <function>public static int sqlite3_backup_pagecount(sqlite3_backup p)
{
    return (int)(p.nPagecount);
}</function>
  <function>public static int sqlite3_backup_remaining(sqlite3_backup p)
{
    return (int)(p.nRemaining);
}</function>
  <function>public static int sqlite3_backup_step(sqlite3_backup p, int nPage)
{
    int rc = 0;
    int destMode = 0;
    int pgszSrc = (int)(0);
    int pgszDest = (int)(0);
    sqlite3_mutex_enter(p.pSrcDb.mutex);
    sqlite3BtreeEnter(p.pSrc);
    if ((p.pDestDb) != null)
    {
        sqlite3_mutex_enter(p.pDestDb.mutex);
    }

    rc = (int)(p.rc);
    if (isFatalError((int)(rc)) == 0)
    {
        Pager pSrcPager = sqlite3BtreePager(p.pSrc);
        Pager pDestPager = sqlite3BtreePager(p.pDest);
        int ii = 0;
        int nSrcPage = (int)(-1);
        int bCloseTrans = (int)(0);
        if (((p.pDestDb) != null) &amp;&amp; ((p.pSrc.pBt.inTransaction) == (2)))
        {
            rc = (int)(5);
        }
        else
        {
            rc = (int)(0);
        }

        if (((rc) == (0)) &amp;&amp; ((0) == (sqlite3BtreeTxnState(p.pSrc))))
        {
            rc = (int)(sqlite3BtreeBeginTrans(p.pSrc, (int)(0), null));
            bCloseTrans = (int)(1);
        }

        if ((((p.bDestLocked) == (0)) &amp;&amp; ((rc) == (0))) &amp;&amp; ((setDestPgsz(p)) == (7)))
        {
            rc = (int)(7);
        }

        if ((((0) == (rc)) &amp;&amp; ((p.bDestLocked) == (0))) &amp;&amp; ((0) == (rc = (int)(sqlite3BtreeBeginTrans(p.pDest, (int)(2), (int*)(&amp;p.iDestSchema))))))
        {
            p.bDestLocked = (int)(1);
        }

        pgszSrc = (int)(sqlite3BtreeGetPageSize(p.pSrc));
        pgszDest = (int)(sqlite3BtreeGetPageSize(p.pDest));
        destMode = (int)(sqlite3PagerGetJournalMode(sqlite3BtreePager(p.pDest)));
        if ((((0) == (rc)) &amp;&amp; ((destMode) == (5))) &amp;&amp; (pgszSrc != pgszDest))
        {
            rc = (int)(8);
        }

        nSrcPage = ((int)(sqlite3BtreeLastPage(p.pSrc)));
        for (ii = (int)(0); ((((nPage) &lt; (0)) || ((ii) &lt; (nPage))) &amp;&amp; ((p.iNext) &lt;= ((uint)(nSrcPage)))) &amp;&amp; (rc == 0); ii++)
        {
            uint iSrcPg = (uint)(p.iNext);
            if (iSrcPg != ((sqlite3PendingByte / ((p.pSrc.pBt).pageSize)) + 1))
            {
                PgHdr pSrcPg;
                rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(iSrcPg), pSrcPg, (int)(0x02)));
                if ((rc) == (0))
                {
                    rc = (int)(backupOnePage(p, (uint)(iSrcPg), sqlite3PagerGetData(pSrcPg), (int)(0)));
                    sqlite3PagerUnref(pSrcPg);
                }
            }

            p.iNext++;
        }

        if ((rc) == (0))
        {
            p.nPagecount = (uint)(nSrcPage);
            p.nRemaining = (uint)(nSrcPage + 1 - p.iNext);
            if ((p.iNext) &gt; ((uint)(nSrcPage)))
            {
                rc = (int)(101);
            }
            else if (p.isAttached == 0)
            {
                attachBackupObject(p);
            }
        }

        if ((rc) == (101))
        {
            if ((nSrcPage) == (0))
            {
                rc = (int)(sqlite3BtreeNewDb(p.pDest));
                nSrcPage = (int)(1);
            }

            if (((rc) == (0)) || ((rc) == (101)))
            {
                rc = (int)(sqlite3BtreeUpdateMeta(p.pDest, (int)(1), (uint)(p.iDestSchema + 1)));
            }

            if ((rc) == (0))
            {
                if ((p.pDestDb) != null)
                {
                    sqlite3ResetAllSchemasOfConnection(p.pDestDb);
                }

                if ((destMode) == (5))
                {
                    rc = (int)(sqlite3BtreeSetVersion(p.pDest, (int)(2)));
                }
            }

            if ((rc) == (0))
            {
                int nDestTruncate = 0;
                if ((pgszSrc) &lt; (pgszDest))
                {
                    int ratio = (int)(pgszDest / pgszSrc);
                    nDestTruncate = (int)((nSrcPage + ratio - 1) / ratio);
                    if ((nDestTruncate) == ((int)((sqlite3PendingByte / ((p.pDest.pBt).pageSize)) + 1)))
                    {
                        nDestTruncate--;
                    }
                }
                else
                {
                    nDestTruncate = (int)(nSrcPage * (pgszSrc / pgszDest));
                }

                if ((pgszSrc) &lt; (pgszDest))
                {
                    long iSize = (long)((long)(pgszSrc) * (long)(nSrcPage));
                    sqlite3_file pFile = sqlite3PagerFile(pDestPager);
                    uint iPg = 0;
                    int nDstPage = 0;
                    long iOff = 0;
                    long iEnd = 0;
                    sqlite3PagerPagecount(pDestPager, &amp;nDstPage);
                    for (iPg = (uint)(nDestTruncate); ((rc) == (0)) &amp;&amp; ((iPg) &lt;= ((uint)(nDstPage))); iPg++)
                    {
                        if (iPg != ((sqlite3PendingByte / ((p.pDest.pBt).pageSize)) + 1))
                        {
                            PgHdr pPg;
                            rc = (int)(sqlite3PagerGet(pDestPager, (uint)(iPg), pPg, (int)(0)));
                            if ((rc) == (0))
                            {
                                rc = (int)(sqlite3PagerWrite(pPg));
                                sqlite3PagerUnref(pPg);
                            }
                        }
                    }

                    if ((rc) == (0))
                    {
                        rc = (int)(sqlite3PagerCommitPhaseOne(pDestPager, null, (int)(1)));
                    }

                    iEnd = (long)((sqlite3PendingByte + pgszDest) &lt; (iSize) ? (sqlite3PendingByte + pgszDest) : (iSize));
                    for (iOff = (long)(sqlite3PendingByte + pgszSrc); ((rc) == (0)) &amp;&amp; ((iOff) &lt; (iEnd)); iOff += (long)(pgszSrc))
                    {
                        PgHdr pSrcPg = null;
                        uint iSrcPg = (uint)((iOff / pgszSrc) + 1);
                        rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(iSrcPg), pSrcPg, (int)(0)));
                        if ((rc) == (0))
                        {
                            byte* zData = sqlite3PagerGetData(pSrcPg);
                            rc = (int)(sqlite3OsWrite(pFile, zData, (int)(pgszSrc), (long)(iOff)));
                        }

                        sqlite3PagerUnref(pSrcPg);
                    }

                    if ((rc) == (0))
                    {
                        rc = (int)(backupTruncateFile(pFile, (long)(iSize)));
                    }

                    if ((rc) == (0))
                    {
                        rc = (int)(sqlite3PagerSync(pDestPager, null));
                    }
                }
                else
                {
                    sqlite3PagerTruncateImage(pDestPager, (uint)(nDestTruncate));
                    rc = (int)(sqlite3PagerCommitPhaseOne(pDestPager, null, (int)(0)));
                }

                if (((0) == (rc)) &amp;&amp; ((0) == (rc = (int)(sqlite3BtreeCommitPhaseTwo(p.pDest, (int)(0))))))
                {
                    rc = (int)(101);
                }
            }
        }

        if ((bCloseTrans) != 0)
        {
            sqlite3BtreeCommitPhaseOne(p.pSrc, null);
            sqlite3BtreeCommitPhaseTwo(p.pSrc, (int)(0));
        }

        if ((rc) == (10 | (12 &lt;&lt; 8)))
        {
            rc = (int)(7);
        }

        p.rc = (int)(rc);
    }

    if ((p.pDestDb) != null)
    {
        sqlite3_mutex_leave(p.pDestDb.mutex);
    }

    sqlite3BtreeLeave(p.pSrc);
    sqlite3_mutex_leave(p.pSrcDb.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_blob(sqlite3_stmt* pStmt, int i, void* zData, int nData, delegate17 xDel)
{
    return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(0)));
}</function>
  <function>public static int sqlite3_bind_blob64(sqlite3_stmt* pStmt, int i, void* zData, ulong nData, delegate17 xDel)
{
    return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(0)));
}</function>
  <function>public static int sqlite3_bind_double(sqlite3_stmt* pStmt, int i, double rValue)
{
    int rc = 0;
    Vdbe p = (Vdbe)(pStmt);
    rc = (int)(vdbeUnbind(p, (int)(i)));
    if ((rc) == (0))
    {
        sqlite3VdbeMemSetDouble(p.aVar[i - 1], (double)(rValue));
        sqlite3_mutex_leave(p.db.mutex);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_int(sqlite3_stmt* p, int i, int iValue)
{
    return (int)(sqlite3_bind_int64(p, (int)(i), (long)(iValue)));
}</function>
  <function>public static int sqlite3_bind_int64(sqlite3_stmt* pStmt, int i, long iValue)
{
    int rc = 0;
    Vdbe p = (Vdbe)(pStmt);
    rc = (int)(vdbeUnbind(p, (int)(i)));
    if ((rc) == (0))
    {
        sqlite3VdbeMemSetInt64(p.aVar[i - 1], (long)(iValue));
        sqlite3_mutex_leave(p.db.mutex);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_null(sqlite3_stmt* pStmt, int i)
{
    int rc = 0;
    Vdbe p = (Vdbe)(pStmt);
    rc = (int)(vdbeUnbind(p, (int)(i)));
    if ((rc) == (0))
    {
        sqlite3_mutex_leave(p.db.mutex);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_parameter_count(sqlite3_stmt* pStmt)
{
    Vdbe p = (Vdbe)(pStmt);
    return (int)(p ? p.nVar : 0);
}</function>
  <function>public static int sqlite3_bind_parameter_index(sqlite3_stmt* pStmt, sbyte* zName)
{
    return (int)(sqlite3VdbeParameterIndex((Vdbe)(pStmt), zName, (int)(sqlite3Strlen30(zName))));
}</function>
  <function>public static sbyte* sqlite3_bind_parameter_name(sqlite3_stmt* pStmt, int i)
{
    Vdbe p = (Vdbe)(pStmt);
    if ((p) == (null))
        return null;
    return sqlite3VListNumToName(p.pVList, (int)(i));
}</function>
  <function>public static int sqlite3_bind_pointer(sqlite3_stmt* pStmt, int i, void* pPtr, sbyte* zPTtype, delegate17 xDestructor)
{
    int rc = 0;
    Vdbe p = (Vdbe)(pStmt);
    rc = (int)(vdbeUnbind(p, (int)(i)));
    if ((rc) == (0))
    {
        sqlite3VdbeMemSetPointer(p.aVar[i - 1], pPtr, zPTtype, xDestructor);
        sqlite3_mutex_leave(p.db.mutex);
    }
    else if ((xDestructor) != null)
    {
        xDestructor(pPtr);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_text(sqlite3_stmt* pStmt, int i, sbyte* zData, int nData, delegate17 xDel)
{
    return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(1)));
}</function>
  <function>public static int sqlite3_bind_text16(sqlite3_stmt* pStmt, int i, void* zData, int nData, delegate17 xDel)
{
    return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(2)));
}</function>
  <function>public static int sqlite3_bind_text64(sqlite3_stmt* pStmt, int i, sbyte* zData, ulong nData, delegate17 xDel, byte enc)
{
    if ((enc) == (4))
        enc = (byte)(2);
    return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(enc)));
}</function>
  <function>public static int sqlite3_bind_value(sqlite3_stmt* pStmt, int i, sqlite3_value pValue)
{
    int rc = 0;
    switch (sqlite3_value_type(pValue))
    {
        case 1:
        {
            rc = (int)(sqlite3_bind_int64(pStmt, (int)(i), (long)(pValue.u.i)));
            break;
        }

        case 2:
        {
            rc = (int)(sqlite3_bind_double(pStmt, (int)(i), (double)((pValue.flags &amp; 0x0008) ? pValue.u.r : (double)(pValue.u.i))));
            break;
        }

        case 4:
        {
            if ((pValue.flags &amp; 0x4000) != 0)
            {
                rc = (int)(sqlite3_bind_zeroblob(pStmt, (int)(i), (int)(pValue.u.nZero)));
            }
            else
            {
                rc = (int)(sqlite3_bind_blob(pStmt, (int)(i), pValue.z, (int)(pValue.n), ((Void(Void * ))(-1))));
            }

            break;
        }

        case 3:
        {
            rc = (int)(bindText(pStmt, (int)(i), pValue.z, (long)(pValue.n), ((Void(Void * ))(-1)), (byte)(pValue.enc)));
            break;
        }

        default:
        {
            rc = (int)(sqlite3_bind_null(pStmt, (int)(i)));
            break;
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_zeroblob(sqlite3_stmt* pStmt, int i, int n)
{
    int rc = 0;
    Vdbe p = (Vdbe)(pStmt);
    rc = (int)(vdbeUnbind(p, (int)(i)));
    if ((rc) == (0))
    {
        sqlite3VdbeMemSetZeroBlob(p.aVar[i - 1], (int)(n));
        sqlite3_mutex_leave(p.db.mutex);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_bind_zeroblob64(sqlite3_stmt* pStmt, int i, ulong n)
{
    int rc = 0;
    Vdbe p = (Vdbe)(pStmt);
    sqlite3_mutex_enter(p.db.mutex);
    if ((n) &gt; ((ulong)(p.db.aLimit[0])))
    {
        rc = (int)(18);
    }
    else
    {
        rc = (int)(sqlite3_bind_zeroblob(pStmt, (int)(i), (int)(n)));
    }

    rc = (int)(sqlite3ApiExit(p.db, (int)(rc)));
    sqlite3_mutex_leave(p.db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_blob_bytes(sqlite3_blob* pBlob)
{
    Incrblob p = (Incrblob)(pBlob);
    return (int)((((p) != null) &amp;&amp; ((p.pStmt) != null)) ? p.nByte : 0);
}</function>
  <function>public static int sqlite3_blob_close(sqlite3_blob* pBlob)
{
    Incrblob p = (Incrblob)(pBlob);
    int rc = 0;
    sqlite3 db;
    if ((p) != null)
    {
        sqlite3_stmt* pStmt = p.pStmt;
        db = p.db;
        sqlite3_mutex_enter(db.mutex);
        sqlite3DbFree(db, p);
        sqlite3_mutex_leave(db.mutex);
        rc = (int)(sqlite3_finalize(pStmt));
    }
    else
    {
        rc = (int)(0);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_blob_open(sqlite3 db, sbyte* zDb, sbyte* zTable, sbyte* zColumn, long iRow, int wrFlag, sqlite3_blob** ppBlob)
{
    int nAttempt = (int)(0);
    int iCol = 0;
    int rc = (int)(0);
    sbyte* zErr = null;
    Table pTab;
    Incrblob pBlob = null;
    Parse sParse = new Parse();
    *ppBlob = null;
    wrFlag = (int)(!!wrFlag);
    sqlite3_mutex_enter(db.mutex);
    pBlob = (Incrblob)(sqlite3DbMallocZero(db, (ulong)(sizeof(Incrblob))));
    while ((1) != 0)
    {
        sqlite3ParseObjectInit(sParse, db);
        if (pBlob == null)
            goto blob_open_out;
        sqlite3DbFree(db, zErr);
        zErr = null;
        sqlite3BtreeEnterAll(db);
        pTab = sqlite3LocateTable(sParse, (uint)(0), zTable, zDb);
        if (((pTab) != null) &amp;&amp; (((pTab).eTabType) == (1)))
        {
            pTab = null;
            sqlite3ErrorMsg(sParse, "cannot open virtual table: %s", zTable);
        }

        if (((pTab) != null) &amp;&amp; (!(((pTab).tabFlags &amp; 0x00000080) == (0))))
        {
            pTab = null;
            sqlite3ErrorMsg(sParse, "cannot open table without rowid: %s", zTable);
        }

        if (((pTab) != null) &amp;&amp; (((pTab).eTabType) == (2)))
        {
            pTab = null;
            sqlite3ErrorMsg(sParse, "cannot open view: %s", zTable);
        }

        if (pTab == null)
        {
            if ((sParse.zErrMsg) != null)
            {
                sqlite3DbFree(db, zErr);
                zErr = sParse.zErrMsg;
                sParse.zErrMsg = null;
            }

            rc = (int)(1);
            sqlite3BtreeLeaveAll(db);
            goto blob_open_out;
        }

        pBlob.pTab = pTab;
        pBlob.zDb = db.aDb[sqlite3SchemaToIndex(db, pTab.pSchema)].zDbSName;
        for (iCol = (int)(0); (iCol) &lt; (pTab.nCol); iCol++)
        {
            if ((sqlite3StrICmp(pTab.aCol[iCol].zCnName, zColumn)) == (0))
            {
                break;
            }
        }

        if ((iCol) == (pTab.nCol))
        {
            sqlite3DbFree(db, zErr);
            zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
            rc = (int)(1);
            sqlite3BtreeLeaveAll(db);
            goto blob_open_out;
        }

        if ((wrFlag) != 0)
        {
            sbyte* zFault = null;
            Index pIdx;
            if ((db.flags &amp; 0x00004000) != 0)
            {
                FKey pFKey;
                for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
                {
                    int j = 0;
                    for (j = (int)(0); (j) &lt; (pFKey.nCol); j++)
                    {
                        if ((pFKey.aCol[j].iFrom) == (iCol))
                        {
                            zFault = "foreign key";
                        }
                    }
                }
            }

            for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
            {
                int j = 0;
                for (j = (int)(0); (j) &lt; (pIdx.nKeyCol); j++)
                {
                    if (((pIdx.aiColumn[j]) == (iCol)) || ((pIdx.aiColumn[j]) == (-2)))
                    {
                        zFault = "indexed";
                    }
                }
            }

            if ((zFault) != null)
            {
                sqlite3DbFree(db, zErr);
                zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
                rc = (int)(1);
                sqlite3BtreeLeaveAll(db);
                goto blob_open_out;
            }
        }

        pBlob.pStmt = (sqlite3_stmt*)(sqlite3VdbeCreate(sParse));
        if ((pBlob.pStmt) != null)
        {
            Vdbe v = (Vdbe)(pBlob.pStmt);
            int iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
            VdbeOp* aOp;
            sqlite3VdbeAddOp4Int(v, (int)(2), (int)(iDb), (int)(wrFlag), (int)(pTab.pSchema.schema_cookie), (int)(pTab.pSchema.iGeneration));
            sqlite3VdbeChangeP5(v, (ushort)(1));
            aOp = sqlite3VdbeAddOpList(v, ((int)(6 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3_blob_open_openBlob, (int)(sqlite3_blob_open_iLn));
            sqlite3VdbeUsesBtree(v, (int)(iDb));
            if ((db.mallocFailed) == (0))
            {
                aOp[0].p1 = (int)(iDb);
                aOp[0].p2 = (int)(pTab.tnum);
                aOp[0].p3 = (int)(wrFlag);
                sqlite3VdbeChangeP4(v, (int)(2), pTab.zName, (int)(0));
            }

            if ((db.mallocFailed) == (0))
            {
                if ((wrFlag) != 0)
                    aOp[1].opcode = (byte)(112);
                aOp[1].p2 = (int)(pTab.tnum);
                aOp[1].p3 = (int)(iDb);
                aOp[1].p4type = (sbyte)(-3);
                aOp[1].p4.i = (int)(pTab.nCol + 1);
                aOp[3].p2 = (int)(pTab.nCol);
                sParse.nVar = (short)(0);
                sParse.nMem = (int)(1);
                sParse.nTab = (int)(1);
                sqlite3VdbeMakeReady(v, sParse);
            }
        }

        pBlob.iCol = (ushort)(iCol);
        pBlob.db = db;
        sqlite3BtreeLeaveAll(db);
        if ((db.mallocFailed) != 0)
        {
            goto blob_open_out;
        }

        rc = (int)(blobSeekToRow(pBlob, (long)(iRow), &amp;zErr));
        if (((++nAttempt) &gt;= (50)) || (rc != 17))
            break;
        sqlite3ParseObjectReset(sParse);
    }

    blob_open_out:
        ; if  ( ( ( rc ) == ( 0 ) ) &amp;&amp; ( ( db . mallocFailed ) == ( 0 ) ) ) { * ppBlob  =  ( sqlite3_blob * ) ( pBlob ) ;  } else  { if  ( ( ( pBlob ) != null ) &amp;&amp; ( ( pBlob . pStmt ) != null ) ) sqlite3VdbeFinalize ( ( Vdbe ) ( pBlob . pStmt ) ) ;  sqlite3DbFree ( db ,  pBlob ) ;  }
    sqlite3ErrorWithMsg(db, (int)(rc), ((zErr) != 0 ? "%s" : null), zErr);
    sqlite3DbFree(db, zErr);
    sqlite3ParseObjectReset(sParse);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_blob_read(sqlite3_blob* pBlob, void* z, int n, int iOffset)
{
    return (int)(blobReadWrite(pBlob, z, (int)(n), (int)(iOffset), sqlite3BtreePayloadChecked));
}</function>
  <function>public static int sqlite3_blob_reopen(sqlite3_blob* pBlob, long iRow)
{
    int rc = 0;
    Incrblob p = (Incrblob)(pBlob);
    sqlite3 db;
    if ((p) == (null))
        return (int)(sqlite3MisuseError((int)(96497)));
    db = p.db;
    sqlite3_mutex_enter(db.mutex);
    if ((p.pStmt) == (null))
    {
        rc = (int)(4);
    }
    else
    {
        sbyte* zErr;
        ((Vdbe)(p.pStmt)).rc = (int)(0);
        rc = (int)(blobSeekToRow(p, (long)(iRow), &amp;zErr));
        if (rc != 0)
        {
            sqlite3ErrorWithMsg(db, (int)(rc), ((zErr) != 0 ? "%s" : null), zErr);
            sqlite3DbFree(db, zErr);
        }
    }

    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_blob_write(sqlite3_blob* pBlob, void* z, int n, int iOffset)
{
    return (int)(blobReadWrite(pBlob, z, (int)(n), (int)(iOffset), sqlite3BtreePutData));
}</function>
  <function>public static int sqlite3_busy_handler(sqlite3 db, delegate59 xBusy, void* pArg)
{
    sqlite3_mutex_enter(db.mutex);
    db.busyHandler.xBusyHandler = xBusy;
    db.busyHandler.pBusyArg = pArg;
    db.busyHandler.nBusy = (int)(0);
    db.busyTimeout = (int)(0);
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_busy_timeout(sqlite3 db, int ms)
{
    if ((ms) &gt; (0))
    {
        sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)(db));
        db.busyTimeout = (int)(ms);
    }
    else
    {
        sqlite3_busy_handler(db, null, null);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3_cancel_auto_extension(delegate74 xInit)
{
    sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
    int i = 0;
    int n = (int)(0);
    sqlite3_mutex_enter(mutex);
    for (i = (int)((int)(sqlite3Autoext.nExt) - 1); (i) &gt;= (0); i--)
    {
        if ((sqlite3Autoext.aExt[i]) == (xInit))
        {
            sqlite3Autoext.nExt--;
            sqlite3Autoext.aExt[i] = sqlite3Autoext.aExt[sqlite3Autoext.nExt];
            n++;
            break;
        }
    }

    sqlite3_mutex_leave(mutex);
    return (int)(n);
}</function>
  <function>public static int sqlite3_changes(sqlite3 db)
{
    return (int)(sqlite3_changes64(db));
}</function>
  <function>public static long sqlite3_changes64(sqlite3 db)
{
    return (long)(db.nChange);
}</function>
  <function>public static int sqlite3_clear_bindings(sqlite3_stmt* pStmt)
{
    int i = 0;
    int rc = (int)(0);
    Vdbe p = (Vdbe)(pStmt);
    sqlite3_mutex* mutex = ((Vdbe)(pStmt)).db.mutex;
    sqlite3_mutex_enter(mutex);
    for (i = (int)(0); (i) &lt; (p.nVar); i++)
    {
        sqlite3VdbeMemRelease(p.aVar[i]);
        p.aVar[i].flags = (ushort)(0x0001);
    }

    if ((p.expmask) != 0)
    {
        p.expired = (uint)(1);
    }

    sqlite3_mutex_leave(mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_close(sqlite3 db)
{
    return (int)(sqlite3Close(db, (int)(0)));
}</function>
  <function>public static int sqlite3_close_v2(sqlite3 db)
{
    return (int)(sqlite3Close(db, (int)(1)));
}</function>
  <function>public static int sqlite3_collation_needed(sqlite3 db, void* pCollNeededArg, delegate66 xCollNeeded)
{
    sqlite3_mutex_enter(db.mutex);
    db.xCollNeeded = xCollNeeded;
    db.xCollNeeded16 = null;
    db.pCollNeededArg = pCollNeededArg;
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_collation_needed16(sqlite3 db, void* pCollNeededArg, delegate66 xCollNeeded16)
{
    sqlite3_mutex_enter(db.mutex);
    db.xCollNeeded = null;
    db.xCollNeeded16 = xCollNeeded16;
    db.pCollNeededArg = pCollNeededArg;
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static void* sqlite3_column_blob(sqlite3_stmt* pStmt, int i)
{
    void* val;
    val = sqlite3_value_blob(columnMem(pStmt, (int)(i)));
    columnMallocFailure(pStmt);
    return val;
}</function>
  <function>public static int sqlite3_column_bytes(sqlite3_stmt* pStmt, int i)
{
    int val = (int)(sqlite3_value_bytes(columnMem(pStmt, (int)(i))));
    columnMallocFailure(pStmt);
    return (int)(val);
}</function>
  <function>public static int sqlite3_column_bytes16(sqlite3_stmt* pStmt, int i)
{
    int val = (int)(sqlite3_value_bytes16(columnMem(pStmt, (int)(i))));
    columnMallocFailure(pStmt);
    return (int)(val);
}</function>
  <function>public static int sqlite3_column_count(sqlite3_stmt* pStmt)
{
    Vdbe pVm = (Vdbe)(pStmt);
    return (int)(pVm ? pVm.nResColumn : 0);
}</function>
  <function>public static sbyte* sqlite3_column_decltype(sqlite3_stmt* pStmt, int N)
{
    return columnName(pStmt, (int)(N), (int)(0), (int)(1));
}</function>
  <function>public static void* sqlite3_column_decltype16(sqlite3_stmt* pStmt, int N)
{
    return columnName(pStmt, (int)(N), (int)(1), (int)(1));
}</function>
  <function>public static double sqlite3_column_double(sqlite3_stmt* pStmt, int i)
{
    double val = (double)(sqlite3_value_double(columnMem(pStmt, (int)(i))));
    columnMallocFailure(pStmt);
    return (double)(val);
}</function>
  <function>public static int sqlite3_column_int(sqlite3_stmt* pStmt, int i)
{
    int val = (int)(sqlite3_value_int(columnMem(pStmt, (int)(i))));
    columnMallocFailure(pStmt);
    return (int)(val);
}</function>
  <function>public static long sqlite3_column_int64(sqlite3_stmt* pStmt, int i)
{
    long val = (long)(sqlite3_value_int64(columnMem(pStmt, (int)(i))));
    columnMallocFailure(pStmt);
    return (long)(val);
}</function>
  <function>public static sbyte* sqlite3_column_name(sqlite3_stmt* pStmt, int N)
{
    return columnName(pStmt, (int)(N), (int)(0), (int)(0));
}</function>
  <function>public static void* sqlite3_column_name16(sqlite3_stmt* pStmt, int N)
{
    return columnName(pStmt, (int)(N), (int)(1), (int)(0));
}</function>
  <function>public static byte* sqlite3_column_text(sqlite3_stmt* pStmt, int i)
{
    byte* val = sqlite3_value_text(columnMem(pStmt, (int)(i)));
    columnMallocFailure(pStmt);
    return val;
}</function>
  <function>public static void* sqlite3_column_text16(sqlite3_stmt* pStmt, int i)
{
    void* val = sqlite3_value_text16(columnMem(pStmt, (int)(i)));
    columnMallocFailure(pStmt);
    return val;
}</function>
  <function>public static int sqlite3_column_type(sqlite3_stmt* pStmt, int i)
{
    int iType = (int)(sqlite3_value_type(columnMem(pStmt, (int)(i))));
    columnMallocFailure(pStmt);
    return (int)(iType);
}</function>
  <function>public static sqlite3_value sqlite3_column_value(sqlite3_stmt* pStmt, int i)
{
    sqlite3_value pOut = columnMem(pStmt, (int)(i));
    if ((pOut.flags &amp; 0x0800) != 0)
    {
        pOut.flags &amp;= (ushort)(~0x0800);
        pOut.flags |= (ushort)(0x1000);
    }

    columnMallocFailure(pStmt);
    return pOut;
}</function>
  <function>public static void* sqlite3_commit_hook(sqlite3 db, delegate19 xCallback, void* pArg)
{
    void* pOld;
    sqlite3_mutex_enter(db.mutex);
    pOld = db.pCommitArg;
    db.xCommitCallback = xCallback;
    db.pCommitArg = pArg;
    sqlite3_mutex_leave(db.mutex);
    return pOld;
}</function>
  <function>public static sbyte* sqlite3_compileoption_get(int N)
{
    int nOpt = 0;
    sbyte** azCompileOpt;
    azCompileOpt = sqlite3CompileOptions(&amp;nOpt);
    if (((N) &gt;= (0)) &amp;&amp; ((N) &lt; (nOpt)))
    {
        return azCompileOpt[N];
    }

    return null;
}</function>
  <function>public static int sqlite3_compileoption_used(sbyte* zOptName)
{
    int i = 0; int  n  =  0 ; 
    int nOpt = 0;
    sbyte** azCompileOpt;
    azCompileOpt = sqlite3CompileOptions(&amp;nOpt);
    if ((sqlite3_strnicmp(zOptName, "SQLITE_", (int)(7))) == (0))
        zOptName += 7;
    n = (int)(sqlite3Strlen30(zOptName));
    for (i = (int)(0); (i) &lt; (nOpt); i++)
    {
        if (((sqlite3_strnicmp(zOptName, azCompileOpt[i], (int)(n))) == (0)) &amp;&amp; ((sqlite3IsIdChar((byte)(azCompileOpt[i][n]))) == (0)))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3_complete(sbyte* zSql)
{
    byte state = (byte)(0);
    byte token = 0;
    while ((*zSql) != 0)
    {
        switch (*zSql)
        {
            case 59:
            {
                token = (byte)(0);
                break;
            }

            case 32:
            case 13:
            case 9:
            case 10:
            case 12:
            {
                token = (byte)(1);
                break;
            }

            case 47:
            {
                if (zSql[1] != 42)
                {
                    token = (byte)(2);
                    break;
                }

                zSql += 2;
                while (((zSql[0]) != 0) &amp;&amp; ((zSql[0] != 42) || (zSql[1] != 47)))
                {
                    zSql++;
                }

                if ((zSql[0]) == (0))
                    return (int)(0);
                zSql++;
                token = (byte)(1);
                break;
            }

            case 45:
            {
                if (zSql[1] != 45)
                {
                    token = (byte)(2);
                    break;
                }

                while (((*zSql) != 0) &amp;&amp; (*zSql != 10))
                {
                    zSql++;
                }

                if ((*zSql) == (0))
                    return ((state) == (1) ? 1 : 0);
                token = (byte)(1);
                break;
            }

            case 91:
            {
                zSql++;
                while (((*zSql) != 0) &amp;&amp; (*zSql != 93))
                {
                    zSql++;
                }

                if ((*zSql) == (0))
                    return (int)(0);
                token = (byte)(2);
                break;
            }

            case 96:
            case 34:
            case 39:
            {
                int c = (int)(*zSql);
                zSql++;
                while (((*zSql) != 0) &amp;&amp; (*zSql != c))
                {
                    zSql++;
                }

                if ((*zSql) == (0))
                    return (int)(0);
                token = (byte)(2);
                break;
            }

            default:
            {
                if (((sqlite3CtypeMap[(byte)(*zSql)] &amp; 0x46) != 0))
                {
                    int nId = 0;
                    for (nId = (int)(1); ((sqlite3CtypeMap[(byte)(zSql[nId])] &amp; 0x46) != 0); nId++)
                    {
                    }

                    switch (*zSql)
                    {
                        case 99:
                        case 67:
                        {
                            if (((nId) == (6)) &amp;&amp; ((sqlite3_strnicmp(zSql, "create", (int)(6))) == (0)))
                            {
                                token = (byte)(4);
                            }
                            else
                            {
                                token = (byte)(2);
                            }

                            break;
                        }

                        case 116:
                        case 84:
                        {
                            if (((nId) == (7)) &amp;&amp; ((sqlite3_strnicmp(zSql, "trigger", (int)(7))) == (0)))
                            {
                                token = (byte)(6);
                            }
                            else if (((nId) == (4)) &amp;&amp; ((sqlite3_strnicmp(zSql, "temp", (int)(4))) == (0)))
                            {
                                token = (byte)(5);
                            }
                            else if (((nId) == (9)) &amp;&amp; ((sqlite3_strnicmp(zSql, "temporary", (int)(9))) == (0)))
                            {
                                token = (byte)(5);
                            }
                            else
                            {
                                token = (byte)(2);
                            }

                            break;
                        }

                        case 101:
                        case 69:
                        {
                            if (((nId) == (3)) &amp;&amp; ((sqlite3_strnicmp(zSql, "end", (int)(3))) == (0)))
                            {
                                token = (byte)(7);
                            }
                            else if (((nId) == (7)) &amp;&amp; ((sqlite3_strnicmp(zSql, "explain", (int)(7))) == (0)))
                            {
                                token = (byte)(3);
                            }
                            else
                            {
                                token = (byte)(2);
                            }

                            break;
                        }

                        default:
                        {
                            token = (byte)(2);
                            break;
                        }
                    }

                    zSql += nId - 1;
                }
                else
                {
                    token = (byte)(2);
                }

                break;
            }
        }

        state = (byte)(sqlite3_complete_trans[state][token]);
        zSql++;
    }

    return ((state) == (1) ? 1 : 0);
}</function>
  <function>public static int sqlite3_complete16(void* zSql)
{
    sqlite3_value pVal;
    sbyte* zSql8;
    int rc = 0;
    rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (int)(rc);
    pVal = sqlite3ValueNew(null);
    sqlite3ValueSetStr(pVal, (int)(-1), zSql, (byte)(2), null);
    zSql8 = sqlite3ValueText(pVal, (byte)(1));
    if ((zSql8) != null)
    {
        rc = (int)(sqlite3_complete(zSql8));
    }
    else
    {
        rc = (int)(7);
    }

    sqlite3ValueFree(pVal);
    return (int)(rc &amp; 0xff);
}</function>
  <function>public static int sqlite3_config(int op)
{
    sbyte* ap;
    int rc = (int)(0);
    if ((sqlite3Config.isInit) != 0)
        return (int)(sqlite3MisuseError((int)(168919)));
    (__va_start(&amp;ap, (int)(op)));
    switch (op)
    {
        case 1:
        {
            sqlite3Config.bCoreMutex = (byte)(0);
            sqlite3Config.bFullMutex = (byte)(0);
            break;
        }

        case 2:
        {
            sqlite3Config.bCoreMutex = (byte)(1);
            sqlite3Config.bFullMutex = (byte)(0);
            break;
        }

        case 3:
        {
            sqlite3Config.bCoreMutex = (byte)(1);
            sqlite3Config.bFullMutex = (byte)(1);
            break;
        }

        case 10:
        {
            sqlite3Config.mutex = (sqlite3_mutex_methods)((((sizeof(sqlite3_mutex_methods)) &gt; ()) || ((sizeof(sqlite3_mutex_methods) &amp; (sizeof(sqlite3_mutex_methods) - 1)) != 0)) ? (sqlite3_mutex_methods)((ap += ) - ) : (sqlite3_mutex_methods)((ap += ) - ));
            break;
        }

        case 11:
        {
            ((((sizeof(sqlite3_mutex_methods)) &gt; ()) || ((sizeof(sqlite3_mutex_methods) &amp; (sizeof(sqlite3_mutex_methods) - 1)) != 0)) ? (sqlite3_mutex_methods)((ap += ) - ) : (sqlite3_mutex_methods)((ap += ) - )) = (sqlite3_mutex_methods)(sqlite3Config.mutex);
            break;
        }

        case 4:
        {
            sqlite3Config.m = (sqlite3_mem_methods)((((sizeof(sqlite3_mem_methods)) &gt; ()) || ((sizeof(sqlite3_mem_methods) &amp; (sizeof(sqlite3_mem_methods) - 1)) != 0)) ? (sqlite3_mem_methods)((ap += ) - ) : (sqlite3_mem_methods)((ap += ) - ));
            break;
        }

        case 5:
        {
            if ((sqlite3Config.m.xMalloc) == (null))
                sqlite3MemSetDefault();
            ((((sizeof(sqlite3_mem_methods)) &gt; ()) || ((sizeof(sqlite3_mem_methods) &amp; (sizeof(sqlite3_mem_methods) - 1)) != 0)) ? (sqlite3_mem_methods)((ap += ) - ) : (sqlite3_mem_methods)((ap += ) - )) = (sqlite3_mem_methods)(sqlite3Config.m);
            break;
        }

        case 9:
        {
            sqlite3Config.bMemstat = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 27:
        {
            sqlite3Config.bSmallMalloc = (byte)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 7:
        {
            sqlite3Config.pPage = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
            sqlite3Config.szPage = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            sqlite3Config.nPage = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 24:
        {
            *(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(sqlite3HeaderSizeBtree() + sqlite3HeaderSizePcache() + sqlite3HeaderSizePcache1());
            break;
        }

        case 14:
        {
            break;
        }

        case 15:
        {
            rc = (int)(1);
            break;
        }

        case 18:
        {
            sqlite3Config.pcache2 = (sqlite3_pcache_methods2)((((sizeof(sqlite3_pcache_methods2)) &gt; ()) || ((sizeof(sqlite3_pcache_methods2) &amp; (sizeof(sqlite3_pcache_methods2) - 1)) != 0)) ? (sqlite3_pcache_methods2)((ap += ) - ) : (sqlite3_pcache_methods2)((ap += ) - ));
            break;
        }

        case 19:
        {
            if ((sqlite3Config.pcache2.xInit) == (null))
            {
                sqlite3PCacheSetDefault();
            }

            ((((sizeof(sqlite3_pcache_methods2)) &gt; ()) || ((sizeof(sqlite3_pcache_methods2) &amp; (sizeof(sqlite3_pcache_methods2) - 1)) != 0)) ? (sqlite3_pcache_methods2)((ap += ) - ) : (sqlite3_pcache_methods2)((ap += ) - )) = (sqlite3_pcache_methods2)(sqlite3Config.pcache2);
            break;
        }

        case 13:
        {
            sqlite3Config.szLookaside = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            sqlite3Config.nLookaside = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 16:
        {
            sqlite3Config.xLog = ((((sizeof(Void(Void * , Void * , Void * ))) &gt; ()) || ((sizeof(Void(Void * , Void * , Void * )) &amp; (sizeof(Void(Void * , Void * , Void * )) - 1)) != 0 ) ) ?
            **(Void(Void * , Void * , Void * ))((ap += ) - ) : 
            *(Void(Void * , Void * , Void * ))((ap += ) - ) )
            ;
            sqlite3Config.pLogArg = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
            break;
        }

        case 17:
        {
            sqlite3Config.bOpenUri = (byte)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 20:
        {
            sqlite3Config.bUseCis = (byte)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 22:
        {
            long szMmap = (long)((((sizeof(long)) &gt; ()) || ((sizeof(long) &amp; (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
            long mxMmap = (long)((((sizeof(long)) &gt; ()) || ((sizeof(long) &amp; (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
            if (((mxMmap) &lt; (0)) || ((mxMmap) &gt; (0x7fff0000)))
            {
                mxMmap = (long)(0x7fff0000);
            }

            if ((szMmap) &lt; (0))
                szMmap = (long)(0);
            if ((szMmap) &gt; (mxMmap))
                szMmap = (long)(mxMmap);
            sqlite3Config.mxMmap = (long)(mxMmap);
            sqlite3Config.szMmap = (long)(szMmap);
            break;
        }

        case 25:
        {
            sqlite3Config.szPma = (uint)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
            break;
        }

        case 26:
        {
            sqlite3Config.nStmtSpill = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 29:
        {
            sqlite3Config.mxMemdbSize = (long)((((sizeof(long)) &gt; ()) || ((sizeof(long) &amp; (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
            break;
        }

        default:
        {
            rc = (int)(1);
            break;
        }
    }

    ((void)(ap = null));
    return (int)(rc);
}</function>
  <function>public static sqlite3 sqlite3_context_db_handle(sqlite3_context p)
{
    return p.pOut.db;
}</function>
  <function>public static int sqlite3_create_collation(sqlite3 db, sbyte* zName, int enc, void* pCtx, delegate70 xCompare)
{
    return (int)(sqlite3_create_collation_v2(db, zName, (int)(enc), pCtx, xCompare, null));
}</function>
  <function>public static int sqlite3_create_collation_v2(sqlite3 db, sbyte* zName, int enc, void* pCtx, delegate70 xCompare, delegate17 xDel)
{
    int rc = 0;
    sqlite3_mutex_enter(db.mutex);
    rc = (int)(createCollation(db, zName, (byte)(enc), pCtx, xCompare, xDel));
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_create_collation16(sqlite3 db, void* zName, int enc, void* pCtx, delegate70 xCompare)
{
    int rc = (int)(0);
    sbyte* zName8;
    sqlite3_mutex_enter(db.mutex);
    zName8 = sqlite3Utf16to8(db, zName, (int)(-1), (byte)(2));
    if ((zName8) != null)
    {
        rc = (int)(createCollation(db, zName8, (byte)(enc), pCtx, xCompare, null));
        sqlite3DbFree(db, zName8);
    }

    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3_create_filename(sbyte* zDatabase, sbyte* zJournal, sbyte* zWal, int nParam, sbyte** azParam)
{
    long nByte = 0;
    int i = 0;
    sbyte* pResult; sbyte  * p ; 
    nByte = (long)(CRuntime.strlen(zDatabase) + CRuntime.strlen(zJournal) + CRuntime.strlen(zWal) + 10);
    for (i = (int)(0); (i) &lt; (nParam * 2); i++)
    {
        nByte += (long)(CRuntime.strlen(azParam[i]) + 1);
    }

    pResult = p = sqlite3_malloc64((ulong)(nByte));
    if ((p) == (null))
        return null;
    CRuntime.memset(p, (int)(0), (ulong)(4));
    p += 4;
    p = appendText(p, zDatabase);
    for (i = (int)(0); (i) &lt; (nParam * 2); i++)
    {
        p = appendText(p, azParam[i]);
    }

    *(p++) = (sbyte)(0);
    p = appendText(p, zJournal);
    p = appendText(p, zWal);
    *(p++) = (sbyte)(0);
    *(p++) = (sbyte)(0);
    return pResult + 4;
}</function>
  <function>public static int sqlite3_create_function(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal)
{
    return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, null, null, null));
}</function>
  <function>public static int sqlite3_create_function_v2(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal, delegate17 xDestroy)
{
    return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, null, null, xDestroy));
}</function>
  <function>public static int sqlite3_create_function16(sqlite3 db, void* zFunctionName, int nArg, int eTextRep, void* p, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal)
{
    int rc = 0;
    sbyte* zFunc8;
    sqlite3_mutex_enter(db.mutex);
    zFunc8 = sqlite3Utf16to8(db, zFunctionName, (int)(-1), (byte)(2));
    rc = (int)(sqlite3CreateFunc(db, zFunc8, (int)(nArg), (int)(eTextRep), p, xSFunc, xStep, xFinal, null, null, null));
    sqlite3DbFree(db, zFunc8);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_create_module(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux)
{
    return (int)(createModule(db, zName, pModule, pAux, null));
}</function>
  <function>public static int sqlite3_create_module_v2(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
{
    return (int)(createModule(db, zName, pModule, pAux, xDestroy));
}</function>
  <function>public static int sqlite3_create_window_function(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate68 xStep, delegate69 xFinal, delegate69 xValue, delegate68 xInverse, delegate17 xDestroy)
{
    return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, null, xStep, xFinal, xValue, xInverse, xDestroy));
}</function>
  <function>public static int sqlite3_data_count(sqlite3_stmt* pStmt)
{
    Vdbe pVm = (Vdbe)(pStmt);
    if (((pVm) == (null)) || ((pVm.pResultSet) == (null)))
        return (int)(0);
    return (int)(pVm.nResColumn);
}</function>
  <function>public static sqlite3_file sqlite3_database_file_object(sbyte* zName)
{
    Pager pPager;
    while ((((zName[-1] != 0) || (zName[-2] != 0)) || (zName[-3] != 0)) || (zName[-4] != 0))
    {
        zName--;
    }

    pPager = (Pager)(zName - 4 - sizeof(Pager));
    return pPager.fd;
}</function>
  <function>public static int sqlite3_db_cacheflush(sqlite3 db)
{
    int i = 0;
    int rc = (int)(0);
    int bSeenBusy = (int)(0);
    sqlite3_mutex_enter(db.mutex);
    sqlite3BtreeEnterAll(db);
    for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nDb)); i++)
    {
        Btree pBt = db.aDb[i].pBt;
        if (((pBt) != null) &amp;&amp; ((sqlite3BtreeTxnState(pBt)) == (2)))
        {
            Pager pPager = sqlite3BtreePager(pBt);
            rc = (int)(sqlite3PagerFlush(pPager));
            if ((rc) == (5))
            {
                bSeenBusy = (int)(1);
                rc = (int)(0);
            }
        }
    }

    sqlite3BtreeLeaveAll(db);
    sqlite3_mutex_leave(db.mutex);
    return (int)((((rc) == (0)) &amp;&amp; ((bSeenBusy) != 0)) ? 5 : rc);
}</function>
  <function>public static int sqlite3_db_config(sqlite3 db, int op)
{
    sbyte* ap;
    int rc = 0;
    (__va_start(&amp;ap, (int)(op)));
    switch (op)
    {
        case 1000:
        {
            db.aDb[0].zDbSName = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
            rc = (int)(0);
            break;
        }

        case 1001:
        {
            void* pBuf = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
            int sz = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            int cnt = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            rc = (int)(setupLookaside(db, pBuf, (int)(sz), (int)(cnt)));
            break;
        }

        default:
        {
            uint i = 0;
            rc = (int)(1);
            for (i = (uint)(0); (i) &lt; ((int)(16 * sizeof(aFlagOpType) / sizeof(aFlagOpType))); i++)
            {
                if ((sqlite3_db_config_aFlagOp[i].op) == (op))
                {
                    int onoff = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
                    int* pRes = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ));
                    ulong oldFlags = (ulong)(db.flags);
                    if ((onoff) &gt; (0))
                    {
                        db.flags |= (ulong)(sqlite3_db_config_aFlagOp[i].mask);
                    }
                    else if ((onoff) == (0))
                    {
                        db.flags &amp;= (ulong)(~(ulong)(sqlite3_db_config_aFlagOp[i].mask));
                    }

                    if (oldFlags != db.flags)
                    {
                        sqlite3ExpirePreparedStatements(db, (int)(0));
                    }

                    if ((pRes) != null)
                    {
                        *pRes = (int)((db.flags &amp; sqlite3_db_config_aFlagOp[i].mask) != 0);
                    }

                    rc = (int)(0);
                    break;
                }
            }

            break;
        }
    }

    ((void)(ap = null));
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3_db_filename(sqlite3 db, sbyte* zDbName)
{
    Btree pBt;
    pBt = sqlite3DbNameToBtree(db, zDbName);
    return pBt ? sqlite3BtreeGetFilename(pBt) : null;
}</function>
  <function>public static sqlite3 sqlite3_db_handle(sqlite3_stmt* pStmt)
{
    return pStmt ? ((Vdbe)(pStmt)).db : null;
}</function>
  <function>public static sqlite3_mutex* sqlite3_db_mutex(sqlite3 db)
{
    return db.mutex;
}</function>
  <function>public static int sqlite3_db_readonly(sqlite3 db, sbyte* zDbName)
{
    Btree pBt;
    pBt = sqlite3DbNameToBtree(db, zDbName);
    return (int)(pBt ? sqlite3BtreeIsReadonly(pBt) : -1);
}</function>
  <function>public static int sqlite3_db_release_memory(sqlite3 db)
{
    int i = 0;
    sqlite3_mutex_enter(db.mutex);
    sqlite3BtreeEnterAll(db);
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        Btree pBt = db.aDb[i].pBt;
        if ((pBt) != null)
        {
            Pager pPager = sqlite3BtreePager(pBt);
            sqlite3PagerShrink(pPager);
        }
    }

    sqlite3BtreeLeaveAll(db);
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_db_status(sqlite3 db, int op, int* pCurrent, int* pHighwater, int resetFlag)
{
    int rc = (int)(0);
    sqlite3_mutex_enter(db.mutex);
    switch (op)
    {
        case 0:
        {
            *pCurrent = (int)(sqlite3LookasideUsed(db, pHighwater));
            if ((resetFlag) != 0)
            {
                LookasideSlot* p = db.lookaside.pFree;
                if ((p) != null)
                {
                    while ((p-&gt;pNext) != null)
                    {
                        p = p-&gt;pNext;
                    }

                    p-&gt;pNext = db.lookaside.pInit;
                    db.lookaside.pInit = db.lookaside.pFree;
                    db.lookaside.pFree = null;
                }

                p = db.lookaside.pSmallFree;
                if ((p) != null)
                {
                    while ((p-&gt;pNext) != null)
                    {
                        p = p-&gt;pNext;
                    }

                    p-&gt;pNext = db.lookaside.pSmallInit;
                    db.lookaside.pSmallInit = db.lookaside.pSmallFree;
                    db.lookaside.pSmallFree = null;
                }
            }

            break;
        }

        case 4:
        case 5:
        case 6:
        {
            *pCurrent = (int)(0);
            *pHighwater = (int)(db.lookaside.anStat[op - 4]);
            if ((resetFlag) != 0)
            {
                db.lookaside.anStat[op - 4] = (uint)(0);
            }

            break;
        }

        case 11:
        case 1:
        {
            int totalUsed = (int)(0);
            int i = 0;
            sqlite3BtreeEnterAll(db);
            for (i = (int)(0); (i) &lt; (db.nDb); i++)
            {
                Btree pBt = db.aDb[i].pBt;
                if ((pBt) != null)
                {
                    Pager pPager = sqlite3BtreePager(pBt);
                    int nByte = (int)(sqlite3PagerMemUsed(pPager));
                    if ((op) == (11))
                    {
                        nByte = (int)(nByte / sqlite3BtreeConnectionCount(pBt));
                    }

                    totalUsed += (int)(nByte);
                }
            }

            sqlite3BtreeLeaveAll(db);
            *pCurrent = (int)(totalUsed);
            *pHighwater = (int)(0);
            break;
        }

        case 2:
        {
            int i = 0;
            int nByte = (int)(0);
            sqlite3BtreeEnterAll(db);
            db.pnBytesFreed = &amp;nByte;
            for (i = (int)(0); (i) &lt; (db.nDb); i++)
            {
                Schema pSchema = db.aDb[i].pSchema;
                if ((pSchema != null))
                {
                    HashElem* p;
                    nByte += (int)(sqlite3Config.m.xRoundup((int)(sizeof(HashElem))) * (pSchema.tblHash.count + pSchema.trigHash.count + pSchema.idxHash.count + pSchema.fkeyHash.count));
                    nByte += (int)(sqlite3_msize(pSchema.tblHash.ht));
                    nByte += (int)(sqlite3_msize(pSchema.trigHash.ht));
                    nByte += (int)(sqlite3_msize(pSchema.idxHash.ht));
                    nByte += (int)(sqlite3_msize(pSchema.fkeyHash.ht));
                    for (p = ((&amp;pSchema.trigHash)-&gt;first); p; p = ((p)-&gt;next))
                    {
                        sqlite3DeleteTrigger(db, (Trigger)((p)-&gt;data));
                    }

                    for (p = ((&amp;pSchema.tblHash)-&gt;first); p; p = ((p)-&gt;next))
                    {
                        sqlite3DeleteTable(db, (Table)((p)-&gt;data));
                    }
                }
            }

            db.pnBytesFreed = null;
            sqlite3BtreeLeaveAll(db);
            *pHighwater = (int)(0);
            *pCurrent = (int)(nByte);
            break;
        }

        case 3:
        {
            Vdbe pVdbe;
            int nByte = (int)(0);
            db.pnBytesFreed = &amp;nByte;
            for (pVdbe = db.pVdbe; pVdbe; pVdbe = pVdbe.pNext)
            {
                sqlite3VdbeClearObject(db, pVdbe);
                sqlite3DbFree(db, pVdbe);
            }

            db.pnBytesFreed = null;
            *pHighwater = (int)(0);
            *pCurrent = (int)(nByte);
            break;
        }

        case 12:
            op = (int)(9 + 1);
        case 7:
        case 8:
        case 9:
        {
            int i = 0;
            int nRet = (int)(0);
            for (i = (int)(0); (i) &lt; (db.nDb); i++)
            {
                if ((db.aDb[i].pBt) != null)
                {
                    Pager pPager = sqlite3BtreePager(db.aDb[i].pBt);
                    sqlite3PagerCacheStat(pPager, (int)(op), (int)(resetFlag), &amp;nRet);
                }
            }

            *pHighwater = (int)(0);
            *pCurrent = (int)(nRet);
            break;
        }

        case 10:
        {
            *pHighwater = (int)(0);
            *pCurrent = (int)(((db.nDeferredImmCons) &gt; (0)) || ((db.nDeferredCons) &gt; (0)) ? 1 : 0);
            break;
        }

        default:
        {
            rc = (int)(1);
        }
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_declare_vtab(sqlite3 db, sbyte* zCreateTable)
{
    VtabCtx pCtx;
    int rc = (int)(0);
    Table pTab;
    Parse sParse = new Parse();
    int initBusy = 0;
    sqlite3_mutex_enter(db.mutex);
    pCtx = db.pVtabCtx;
    if ((pCtx == null) || ((pCtx.bDeclared) != 0))
    {
        sqlite3Error(db, (int)(21));
        sqlite3_mutex_leave(db.mutex);
        return (int)(sqlite3MisuseError((int)(146305)));
    }

    pTab = pCtx.pTab;
    sqlite3ParseObjectInit(sParse, db);
    sParse.eParseMode = (byte)(1);
    sParse.disableTriggers = (byte)(1);
    initBusy = (int)(db.init.busy);
    db.init.busy = (byte)(0);
    sParse.nQueryLoop = (uint)(1);
    if (((((0) == (sqlite3RunParser(sParse, zCreateTable))) &amp;&amp; (sParse.pNewTable != null)) &amp;&amp; ((!db.mallocFailed) != 0)) &amp;&amp; (((sParse.pNewTable).eTabType) == (0)))
    {
        if (pTab.aCol == null)
        {
            Table pNew = sParse.pNewTable;
            Index pIdx;
            pTab.aCol = pNew.aCol;
            sqlite3ExprListDelete(db, pNew.u.tab.pDfltList);
            pTab.nNVCol = (short)(pTab.nCol = (short)(pNew.nCol));
            pTab.tabFlags |= (uint)(pNew.tabFlags &amp; (0x00000080 | 0x00000200));
            pNew.nCol = (short)(0);
            pNew.aCol = null;
            if (((!(((pNew).tabFlags &amp; 0x00000080) == (0))) &amp;&amp; (pCtx.pVTable.pMod.pModule.xUpdate != null)) &amp;&amp; (sqlite3PrimaryKeyIndex(pNew).nKeyCol != 1))
            {
                rc = (int)(1);
            }

            pIdx = pNew.pIndex;
            if ((pIdx) != null)
            {
                pTab.pIndex = pIdx;
                pNew.pIndex = null;
                pIdx.pTable = pTab;
            }
        }

        pCtx.bDeclared = (int)(1);
    }
    else
    {
        sqlite3ErrorWithMsg(db, (int)(1), ((sParse.zErrMsg) != 0 ? "%s" : null), sParse.zErrMsg);
        sqlite3DbFree(db, sParse.zErrMsg);
        rc = (int)(1);
    }

    sParse.eParseMode = (byte)(0);
    if ((sParse.pVdbe) != null)
    {
        sqlite3VdbeFinalize(sParse.pVdbe);
    }

    sqlite3DeleteTable(db, sParse.pNewTable);
    sqlite3ParseObjectReset(sParse);
    db.init.busy = (byte)(initBusy);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_deserialize(sqlite3 db, sbyte* zSchema, byte* pData, long szDb, long szBuf, uint mFlags)
{
    MemFile p;
    sbyte* zSql;
    sqlite3_stmt* pStmt = null;
    int rc = 0;
    int iDb = 0;
    sqlite3_mutex_enter(db.mutex);
    if ((zSchema) == (null))
        zSchema = db.aDb[0].zDbSName;
    iDb = (int)(sqlite3FindDbName(db, zSchema));
    if (((iDb) &lt; (2)) &amp;&amp; (iDb != 0))
    {
        rc = (int)(1);
        goto end_deserialize;
    }

    zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);
    if ((zSql) == (null))
    {
        rc = (int)(7);
    }
    else
    {
        rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &amp;pStmt, null));
        sqlite3_free(zSql);
    }

    if ((rc) != 0)
        goto end_deserialize;
    db.init.iDb = ((byte)(iDb));
    db.init.reopenMemdb = (uint)(1);
    rc = (int)(sqlite3_step(pStmt));
    db.init.reopenMemdb = (uint)(0);
    if (rc != 101)
    {
        rc = (int)(1);
        goto end_deserialize;
    }

    p = memdbFromDbSchema(db, zSchema);
    if ((p) == (null))
    {
        rc = (int)(1);
    }
    else
    {
        MemStore* pStore = p.pStore;
        pStore-&gt;aData = pData;
        pData = null;
        pStore-&gt;sz = (long)(szDb);
        pStore-&gt;szAlloc = (long)(szBuf);
        pStore-&gt;szMax = (long)(szBuf);
        if ((pStore-&gt;szMax) &lt; (sqlite3Config.mxMemdbSize))
        {
            pStore-&gt;szMax = (long)(sqlite3Config.mxMemdbSize);
        }

        pStore-&gt;mFlags = (uint)(mFlags);
        rc = (int)(0);
    }

    end_deserialize:
        ; sqlite3_finalize ( pStmt ) ; 
    if (((pData) != null) &amp;&amp; ((mFlags &amp; 1) != 0))
    {
        sqlite3_free(pData);
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_drop_modules(sqlite3 db, sbyte** azNames)
{
    HashElem* pThis; HashElem * pNext ; 
    for (pThis = ((&amp;db.aModule)-&gt;first); pThis; pThis = pNext)
    {
        Module pMod = (Module)((pThis)-&gt;data);
        pNext = ((pThis)-&gt;next);
        if ((azNames) != null)
        {
            int ii = 0;
            for (ii = (int)(0); (azNames[ii] != null) &amp;&amp; (CRuntime.strcmp(azNames[ii], pMod.zName) != 0); ii++)
            {
            }

            if (azNames[ii] != null)
                continue;
        }

        createModule(db, pMod.zName, null, null, null);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3_enable_load_extension(sqlite3 db, int onoff)
{
    sqlite3_mutex_enter(db.mutex);
    if ((onoff) != 0)
    {
        db.flags |= (ulong)(0x00010000 | 0x00020000);
    }
    else
    {
        db.flags &amp;= (ulong)(~(ulong)(0x00010000 | 0x00020000));
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_enable_shared_cache(int enable)
{
    sqlite3Config.sharedCacheEnabled = (int)(enable);
    return (int)(0);
}</function>
  <function>public static int sqlite3_errcode(sqlite3 db)
{
    if (((db) != null) &amp;&amp; (sqlite3SafetyCheckSickOrOk(db) == 0))
    {
        return (int)(sqlite3MisuseError((int)(171145)));
    }

    if ((db == null) || ((db.mallocFailed) != 0))
    {
        return (int)(7);
    }

    return (int)(db.errCode &amp; db.errMask);
}</function>
  <function>public static sbyte* sqlite3_errmsg(sqlite3 db)
{
    sbyte* z;
    if (db == null)
    {
        return sqlite3ErrStr((int)(7));
    }

    if (sqlite3SafetyCheckSickOrOk(db) == 0)
    {
        return sqlite3ErrStr((int)(sqlite3MisuseError((int)(171066))));
    }

    sqlite3_mutex_enter(db.mutex);
    if ((db.mallocFailed) != 0)
    {
        z = sqlite3ErrStr((int)(7));
    }
    else
    {
        z = (db.errCode) != 0 ? (sbyte*)(sqlite3_value_text(db.pErr)) : null;
        if ((z) == (null))
        {
            z = sqlite3ErrStr((int)(db.errCode));
        }
    }

    sqlite3_mutex_leave(db.mutex);
    return z;
}</function>
  <function>public static void* sqlite3_errmsg16(sqlite3 db)
{
    void* z;
    if (db == null)
    {
        return (void*)(sqlite3_errmsg16_outOfMem);
    }

    if (sqlite3SafetyCheckSickOrOk(db) == 0)
    {
        return (void*)(sqlite3_errmsg16_misuse);
    }

    sqlite3_mutex_enter(db.mutex);
    if ((db.mallocFailed) != 0)
    {
        z = (void*)(sqlite3_errmsg16_outOfMem);
    }
    else
    {
        z = sqlite3_value_text16(db.pErr);
        if ((z) == (null))
        {
            sqlite3ErrorWithMsg(db, (int)(db.errCode), sqlite3ErrStr((int)(db.errCode)));
            z = sqlite3_value_text16(db.pErr);
        }

        sqlite3OomClear(db);
    }

    sqlite3_mutex_leave(db.mutex);
    return z;
}</function>
  <function>public static int sqlite3_error_offset(sqlite3 db)
{
    int iOffset = (int)(-1);
    if ((((db) != null) &amp;&amp; ((sqlite3SafetyCheckSickOrOk(db)) != 0)) &amp;&amp; ((db.errCode) != 0))
    {
        sqlite3_mutex_enter(db.mutex);
        iOffset = (int)(db.errByteOffset);
        sqlite3_mutex_leave(db.mutex);
    }

    return (int)(iOffset);
}</function>
  <function>public static sbyte* sqlite3_errstr(int rc)
{
    return sqlite3ErrStr((int)(rc));
}</function>
  <function>public static int sqlite3_exec(sqlite3 db, sbyte* zSql, delegate54 xCallback, void* pArg, sbyte** pzErrMsg)
{
    int rc = (int)(0);
    sbyte* zLeftover;
    sqlite3_stmt* pStmt = null;
    sbyte** azCols = null;
    int callbackIsInit = 0;
    if (sqlite3SafetyCheckOk(db) == 0)
        return (int)(sqlite3MisuseError((int)(128113)));
    if ((zSql) == (null))
        zSql = "";
    sqlite3_mutex_enter(db.mutex);
    sqlite3Error(db, (int)(0));
    while (((rc) == (0)) &amp;&amp; ((zSql[0]) != 0))
    {
        int nCol = (int)(0);
        sbyte** azVals = null;
        pStmt = null;
        rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &amp;pStmt, &amp;zLeftover));
        if (rc != 0)
        {
            continue;
        }

        if (pStmt == null)
        {
            zSql = zLeftover;
            continue;
        }

        callbackIsInit = (int)(0);
        while ((1) != 0)
        {
            int i = 0;
            rc = (int)(sqlite3_step(pStmt));
            if (((xCallback) != null) &amp;&amp; (((100) == (rc)) || ((((101) == (rc)) &amp;&amp; (callbackIsInit == 0)) &amp;&amp; ((db.flags &amp; 0x00000100) != 0))))
            {
                if (callbackIsInit == 0)
                {
                    nCol = (int)(sqlite3_column_count(pStmt));
                    azCols = sqlite3DbMallocRaw(db, (ulong)((2 * nCol + 1) * sizeof(constchar*)));
                    if ((azCols) == (null))
                    {
                        goto exec_out;
                    }

                    for (i = (int)(0); (i) &lt; (nCol); i++)
                    {
                        azCols[i] = sqlite3_column_name(pStmt, (int)(i));
                    }

                    callbackIsInit = (int)(1);
                }

                if ((rc) == (100))
                {
                    azVals = &amp;azCols[nCol];
                    for (i = (int)(0); (i) &lt; (nCol); i++)
                    {
                        azVals[i] = (sbyte*)(sqlite3_column_text(pStmt, (int)(i)));
                        if ((azVals[i] == null) &amp;&amp; (sqlite3_column_type(pStmt, (int)(i)) != 5))
                        {
                            sqlite3OomFault(db);
                            goto exec_out;
                        }
                    }

                    azVals[i] = null;
                }

                if ((xCallback(pArg, (int)(nCol), azVals, azCols)) != 0)
                {
                    rc = (int)(4);
                    sqlite3VdbeFinalize((Vdbe)(pStmt));
                    pStmt = null;
                    sqlite3Error(db, (int)(4));
                    goto exec_out;
                }
            }

            if (rc != 100)
            {
                rc = (int)(sqlite3VdbeFinalize((Vdbe)(pStmt)));
                pStmt = null;
                zSql = zLeftover;
                while ((sqlite3CtypeMap[(byte)(zSql[0])] &amp; 0x01) != 0)
                {
                    zSql++;
                }

                break;
            }
        }

        sqlite3DbFree(db, azCols);
        azCols = null;
    }

    exec_out:
        ; if  ( ( pStmt ) != null ) sqlite3VdbeFinalize ( ( Vdbe ) ( pStmt ) ) ; 
    sqlite3DbFree(db, azCols);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    if ((rc != 0) &amp;&amp; ((pzErrMsg) != null))
    {
        *pzErrMsg = sqlite3DbStrDup(null, sqlite3_errmsg(db));
        if ((*pzErrMsg) == (null))
        {
            rc = (int)(7);
            sqlite3Error(db, (int)(7));
        }
    }
    else if ((pzErrMsg) != null)
    {
        *pzErrMsg = null;
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3_expanded_sql(sqlite3_stmt* pStmt)
{
    sbyte* z = null;
    sbyte* zSql = sqlite3_sql(pStmt);
    if ((zSql) != null)
    {
        Vdbe p = (Vdbe)(pStmt);
        sqlite3_mutex_enter(p.db.mutex);
        z = sqlite3VdbeExpandSql(p, zSql);
        sqlite3_mutex_leave(p.db.mutex);
    }

    return z;
}</function>
  <function>public static int sqlite3_expired(sqlite3_stmt* pStmt)
{
    Vdbe p = (Vdbe)(pStmt);
    return (((p) == (null)) || ((p.expired) != 0) ? 1 : 0);
}</function>
  <function>public static int sqlite3_extended_errcode(sqlite3 db)
{
    if (((db) != null) &amp;&amp; (sqlite3SafetyCheckSickOrOk(db) == 0))
    {
        return (int)(sqlite3MisuseError((int)(171154)));
    }

    if ((db == null) || ((db.mallocFailed) != 0))
    {
        return (int)(7);
    }

    return (int)(db.errCode);
}</function>
  <function>public static int sqlite3_extended_result_codes(sqlite3 db, int onoff)
{
    sqlite3_mutex_enter(db.mutex);
    db.errMask = (int)((onoff) != 0 ? 0xffffffff : 0xff);
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_file_control(sqlite3 db, sbyte* zDbName, int op, void* pArg)
{
    int rc = (int)(1);
    Btree pBtree;
    sqlite3_mutex_enter(db.mutex);
    pBtree = sqlite3DbNameToBtree(db, zDbName);
    if ((pBtree) != null)
    {
        Pager pPager;
        sqlite3_file fd;
        sqlite3BtreeEnter(pBtree);
        pPager = sqlite3BtreePager(pBtree);
        fd = sqlite3PagerFile(pPager);
        if ((op) == (7))
        {
            (sqlite3_file)(pArg) = fd;
            rc = (int)(0);
        }
        else if ((op) == (27))
        {
            (sqlite3_vfs)(pArg) = sqlite3PagerVfs(pPager);
            rc = (int)(0);
        }
        else if ((op) == (28))
        {
            (sqlite3_file)(pArg) = sqlite3PagerJrnlFile(pPager);
            rc = (int)(0);
        }
        else if ((op) == (35))
        {
            *(uint*)(pArg) = (uint)(sqlite3PagerDataVersion(pPager));
            rc = (int)(0);
        }
        else if ((op) == (38))
        {
            int iNew = (int)(*(int*)(pArg));
            *(int*)(pArg) = (int)(sqlite3BtreeGetRequestedReserve(pBtree));
            if (((iNew) &gt;= (0)) &amp;&amp; ((iNew) &lt;= (255)))
            {
                sqlite3BtreeSetPageSize(pBtree, (int)(0), (int)(iNew), (int)(0));
            }

            rc = (int)(0);
        }
        else
        {
            int nSave = (int)(db.busyHandler.nBusy);
            rc = (int)(sqlite3OsFileControl(fd, (int)(op), pArg));
            db.busyHandler.nBusy = (int)(nSave);
        }

        sqlite3BtreeLeave(pBtree);
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3_filename_database(sbyte* zFilename)
{
    if ((zFilename) == (null))
        return null;
    return databaseName(zFilename);
}</function>
  <function>public static sbyte* sqlite3_filename_journal(sbyte* zFilename)
{
    if ((zFilename) == (null))
        return null;
    zFilename = databaseName(zFilename);
    zFilename += sqlite3Strlen30(zFilename) + 1;
    while (((zFilename) != null) &amp;&amp; ((zFilename[0]) != 0))
    {
        zFilename += sqlite3Strlen30(zFilename) + 1;
        zFilename += sqlite3Strlen30(zFilename) + 1;
    }

    return zFilename + 1;
}</function>
  <function>public static sbyte* sqlite3_filename_wal(sbyte* zFilename)
{
    zFilename = sqlite3_filename_journal(zFilename);
    if ((zFilename) != null)
        zFilename += sqlite3Strlen30(zFilename) + 1;
    return zFilename;
}</function>
  <function>public static int sqlite3_finalize(sqlite3_stmt* pStmt)
{
    int rc = 0;
    if ((pStmt) == (null))
    {
        rc = (int)(0);
    }
    else
    {
        Vdbe v = (Vdbe)(pStmt);
        sqlite3 db = v.db;
        if ((vdbeSafety(v)) != 0)
            return (int)(sqlite3MisuseError((int)(85171)));
        sqlite3_mutex_enter(db.mutex);
        if (((v).startTime) &gt; (0))
        {
            invokeProfileCallback(db, v);
        }

        rc = (int)(sqlite3VdbeFinalize(v));
        rc = (int)(sqlite3ApiExit(db, (int)(rc)));
        sqlite3LeaveMutexAndCloseZombie(db);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3_free(void* p)
{
    if ((p) == (null))
        return;
    if ((sqlite3Config.bMemstat) != 0)
    {
        sqlite3_mutex_enter(mem0.mutex);
        sqlite3StatusDown((int)(0), (int)(sqlite3MallocSize(p)));
        sqlite3StatusDown((int)(9), (int)(1));
        sqlite3Config.m.xFree(p);
        sqlite3_mutex_leave(mem0.mutex);
    }
    else
    {
        sqlite3Config.m.xFree(p);
    }
}</function>
  <function>public static void sqlite3_free_filename(sbyte* p)
{
    if ((p) == (null))
        return;
    p = databaseName(p);
    sqlite3_free(p - 4);
}</function>
  <function>public static void sqlite3_free_table(sbyte** azResult)
{
    if ((azResult) != null)
    {
        int i = 0;
        int n = 0;
        azResult--;
        n = ((int)((long)(azResult[0])));
        for (i = (int)(1); (i) &lt; (n); i++)
        {
            if ((azResult[i]) != null)
                sqlite3_free(azResult[i]);
        }

        sqlite3_free(azResult);
    }
}</function>
  <function>public static int sqlite3_get_autocommit(sqlite3 db)
{
    return (int)(db.autoCommit);
}</function>
  <function>public static void* sqlite3_get_auxdata(sqlite3_context pCtx, int iArg)
{
    AuxData pAuxData;
    for (pAuxData = pCtx.pVdbe.pAuxData; pAuxData; pAuxData = pAuxData.pNextAux)
    {
        if (((pAuxData.iAuxArg) == (iArg)) &amp;&amp; (((pAuxData.iAuxOp) == (pCtx.iOp)) || ((iArg) &lt; (0))))
        {
            return pAuxData.pAux;
        }
    }

    return null;
}</function>
  <function>public static int sqlite3_get_table(sqlite3 db, sbyte* zSql, sbyte*** pazResult, int* pnRow, int* pnColumn, sbyte** pzErrMsg)
{
    int rc = 0;
    TabResult res = new TabResult();
    *pazResult = null;
    if ((pnColumn) != null)
        *pnColumn = (int)(0);
    if ((pnRow) != null)
        *pnRow = (int)(0);
    if ((pzErrMsg) != null)
        *pzErrMsg = null;
    res.zErrMsg = null;
    res.nRow = (uint)(0);
    res.nColumn = (uint)(0);
    res.nData = (uint)(1);
    res.nAlloc = (uint)(20);
    res.rc = (int)(0);
    res.azResult = sqlite3_malloc64((ulong)(sizeof(char*) * res.nAlloc));
    if ((res.azResult) == (null))
    {
        db.errCode = (int)(7);
        return (int)(7);
    }

    res.azResult[0] = null;
    rc = (int)(sqlite3_exec(db, zSql, sqlite3_get_table_cb, &amp;res, pzErrMsg));
    res.azResult[0] = ((void*)((long)(res.nData)));
    if ((rc &amp; 0xff) == (4))
    {
        sqlite3_free_table(&amp;res.azResult[1]);
        if ((res.zErrMsg) != null)
        {
            if ((pzErrMsg) != null)
            {
                sqlite3_free(*pzErrMsg);
                *pzErrMsg = sqlite3_mprintf("%s", res.zErrMsg);
            }

            sqlite3_free(res.zErrMsg);
        }

        db.errCode = (int)(res.rc);
        return (int)(res.rc);
    }

    sqlite3_free(res.zErrMsg);
    if (rc != 0)
    {
        sqlite3_free_table(&amp;res.azResult[1]);
        return (int)(rc);
    }

    if ((res.nAlloc) &gt; (res.nData))
    {
        sbyte** azNew;
        azNew = sqlite3Realloc(res.azResult, (ulong)(sizeof(char*) * res.nData));
        if ((azNew) == (null))
        {
            sqlite3_free_table(&amp;res.azResult[1]);
            db.errCode = (int)(7);
            return (int)(7);
        }

        res.azResult = azNew;
    }

    *pazResult = &amp;res.azResult[1];
    if ((pnColumn) != null)
        *pnColumn = (int)(res.nColumn);
    if ((pnRow) != null)
        *pnRow = (int)(res.nRow);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_get_table_cb(void* pArg, int nCol, sbyte** argv, sbyte** colv)
{
    TabResult* p = (TabResult*)(pArg);
    int need = 0;
    int i = 0;
    sbyte* z;
    if (((p-&gt;nRow) == (0)) &amp;&amp; (argv != null))
    {
        need = (int)(nCol * 2);
    }
    else
    {
        need = (int)(nCol);
    }

    if ((p-&gt;nData + need) &gt; (p-&gt;nAlloc))
    {
        sbyte** azNew;
        p-&gt;nAlloc = (uint)(p-&gt;nAlloc * 2 + need);
        azNew = sqlite3Realloc(p-&gt;azResult, (ulong)(sizeof(char*) * p-&gt;nAlloc));
        if ((azNew) == (null))
            goto malloc_failed;
        p-&gt;azResult = azNew;
    }

    if ((p-&gt;nRow) == (0))
    {
        p-&gt;nColumn = (uint)(nCol);
        for (i = (int)(0); (i) &lt; (nCol); i++)
        {
            z = sqlite3_mprintf("%s", colv[i]);
            if ((z) == (null))
                goto malloc_failed;
            p-&gt;azResult[p-&gt;nData++] = z;
        }
    }
    else if ((int)(p-&gt;nColumn) != nCol)
    {
        sqlite3_free(p-&gt;zErrMsg);
        p-&gt;zErrMsg = sqlite3_mprintf("sqlite3_get_table() called with two or more incompatible queries");
        p-&gt;rc = (int)(1);
        return (int)(1);
    }

    if (argv != null)
    {
        for (i = (int)(0); (i) &lt; (nCol); i++)
        {
            if ((argv[i]) == (null))
            {
                z = null;
            }
            else
            {
                int n = (int)(sqlite3Strlen30(argv[i]) + 1);
                z = sqlite3_malloc64((ulong)(n));
                if ((z) == (null))
                    goto malloc_failed;
                CRuntime.memcpy(z, argv[i], (ulong)(n));
            }

            p-&gt;azResult[p-&gt;nData++] = z;
        }

        p-&gt;nRow++;
    }

    return (int)(0);
    malloc_failed:
        ; p -&gt; rc  =  ( int ) ( 7 ) ; 
    return (int)(1);
}</function>
  <function>public static int sqlite3_global_recover()
{
    return (int)(0);
}</function>
  <function>public static long sqlite3_hard_heap_limit64(long n)
{
    long priorLimit = 0;
    int rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (long)(-1);
    sqlite3_mutex_enter(mem0.mutex);
    priorLimit = (long)(mem0.hardLimit);
    if ((n) &gt;= (0))
    {
        mem0.hardLimit = (long)(n);
        if (((n) &lt; (mem0.alarmThreshold)) || ((mem0.alarmThreshold) == (0)))
        {
            mem0.alarmThreshold = (long)(n);
        }
    }

    sqlite3_mutex_leave(mem0.mutex);
    return (long)(priorLimit);
}</function>
  <function>public static int sqlite3_initialize()
{
    sqlite3_mutex* pMainMtx;
    int rc = 0;
    if ((sqlite3Config.isInit) != 0)
    {
        sqlite3MemoryBarrier();
        return (int)(0);
    }

    rc = (int)(sqlite3MutexInit());
    if ((rc) != 0)
        return (int)(rc);
    pMainMtx = sqlite3MutexAlloc((int)(2));
    sqlite3_mutex_enter(pMainMtx);
    sqlite3Config.isMutexInit = (int)(1);
    if (sqlite3Config.isMallocInit == 0)
    {
        rc = (int)(sqlite3MallocInit());
    }

    if ((rc) == (0))
    {
        sqlite3Config.isMallocInit = (int)(1);
        if (sqlite3Config.pInitMutex == null)
        {
            sqlite3Config.pInitMutex = sqlite3MutexAlloc((int)(1));
            if (((sqlite3Config.bCoreMutex) != 0) &amp;&amp; (sqlite3Config.pInitMutex == null))
            {
                rc = (int)(7);
            }
        }
    }

    if ((rc) == (0))
    {
        sqlite3Config.nRefInitMutex++;
    }

    sqlite3_mutex_leave(pMainMtx);
    if (rc != 0)
    {
        return (int)(rc);
    }

    sqlite3_mutex_enter(sqlite3Config.pInitMutex);
    if (((sqlite3Config.isInit) == (0)) &amp;&amp; ((sqlite3Config.inProgress) == (0)))
    {
        sqlite3Config.inProgress = (int)(1);
        CRuntime.memset(sqlite3BuiltinFunctions, (int)(0), (ulong)(sizeof(FuncDefHash)));
        sqlite3RegisterBuiltinFunctions();
        if ((sqlite3Config.isPCacheInit) == (0))
        {
            rc = (int)(sqlite3PcacheInitialize());
        }

        if ((rc) == (0))
        {
            sqlite3Config.isPCacheInit = (int)(1);
            rc = (int)(sqlite3OsInit());
        }

        if ((rc) == (0))
        {
            rc = (int)(sqlite3MemdbInit());
        }

        if ((rc) == (0))
        {
            sqlite3PCacheBufferSetup(sqlite3Config.pPage, (int)(sqlite3Config.szPage), (int)(sqlite3Config.nPage));
            sqlite3MemoryBarrier();
            sqlite3Config.isInit = (int)(1);
        }

        sqlite3Config.inProgress = (int)(0);
    }

    sqlite3_mutex_leave(sqlite3Config.pInitMutex);
    sqlite3_mutex_enter(pMainMtx);
    sqlite3Config.nRefInitMutex--;
    if ((sqlite3Config.nRefInitMutex) &lt;= (0))
    {
        sqlite3_mutex_free(sqlite3Config.pInitMutex);
        sqlite3Config.pInitMutex = null;
    }

    sqlite3_mutex_leave(pMainMtx);
    return (int)(rc);
}</function>
  <function>public static void sqlite3_interrupt(sqlite3 db)
{
    (1);
}</function>
  <function>public static int sqlite3_keyword_check(sbyte* zName, int nName)
{
    return (int)(59 != sqlite3KeywordCode((byte*)(zName), (int)(nName)));
}</function>
  <function>public static int sqlite3_keyword_count()
{
    return (int)(147);
}</function>
  <function>public static int sqlite3_keyword_name(int i, sbyte** pzName, int* pnName)
{
    if (((i) &lt; (0)) || ((i) &gt;= (147)))
        return (int)(1);
    *pzName = zKWText + aKWOffset[i];
    *pnName = (int)(aKWLen[i]);
    return (int)(0);
}</function>
  <function>public static long sqlite3_last_insert_rowid(sqlite3 db)
{
    return (long)(db.lastRowid);
}</function>
  <function>public static sbyte* sqlite3_libversion()
{
    return sqlite3_version;
}</function>
  <function>public static int sqlite3_libversion_number()
{
    return (int)(3038002);
}</function>
  <function>public static int sqlite3_limit(sqlite3 db, int limitId, int newLimit)
{
    int oldLimit = 0;
    if (((limitId) &lt; (0)) || ((limitId) &gt;= (11 + 1)))
    {
        return (int)(-1);
    }

    oldLimit = (int)(db.aLimit[limitId]);
    if ((newLimit) &gt;= (0))
    {
        if ((newLimit) &gt; (aHardLimit[limitId]))
        {
            newLimit = (int)(aHardLimit[limitId]);
        }
        else if (((newLimit) &lt; (1)) &amp;&amp; ((limitId) == (0)))
        {
            newLimit = (int)(1);
        }

        db.aLimit[limitId] = (int)(newLimit);
    }

    return (int)(oldLimit);
}</function>
  <function>public static int sqlite3_load_extension(sqlite3 db, sbyte* zFile, sbyte* zProc, sbyte** pzErrMsg)
{
    int rc = 0;
    sqlite3_mutex_enter(db.mutex);
    rc = (int)(sqlite3LoadExtension(db, zFile, zProc, pzErrMsg));
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static void sqlite3_log(int iErrCode, sbyte* zFormat)
{
    sbyte* ap;
    if ((sqlite3Config.xLog) != null)
    {
        (__va_start(&amp;ap, zFormat));
        renderLogMsg((int)(iErrCode), zFormat, ap);
        ((void)(ap = null));
    }
}</function>
  <function>public static void* sqlite3_malloc(int n)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return (n) &lt;= (0) ? null : sqlite3Malloc((ulong)(n));
}</function>
  <function>public static void* sqlite3_malloc64(ulong n)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return sqlite3Malloc((ulong)(n));
}</function>
  <function>public static int sqlite3_memory_alarm(delegate63 xCallback, void* pArg, long iThreshold)
{
    (void)(xCallback);
    (void)(pArg);
    (void)(iThreshold);
    return (int)(0);
}</function>
  <function>public static long sqlite3_memory_highwater(int resetFlag)
{
    long res = 0; long  mx  =  0 ; 
    sqlite3_status64((int)(0), &amp;res, &amp;mx, (int)(resetFlag));
    return (long)(mx);
}</function>
  <function>public static long sqlite3_memory_used()
{
    long res = 0; long  mx  =  0 ; 
    sqlite3_status64((int)(0), &amp;res, &amp;mx, (int)(0));
    return (long)(res);
}</function>
  <function>public static sbyte* sqlite3_mprintf(sbyte* zFormat)
{
    sbyte* ap;
    sbyte* z;
    if ((sqlite3_initialize()) != 0)
        return null;
    (__va_start(&amp;ap, zFormat));
    z = sqlite3_vmprintf(zFormat, ap);
    ((void)(ap = null));
    return z;
}</function>
  <function>public static ulong sqlite3_msize(void* p)
{
    return (ulong)(p ? sqlite3Config.m.xSize(p) : 0);
}</function>
  <function>public static sqlite3_mutex* sqlite3_mutex_alloc(int id)
{
    if (((id) &lt;= (1)) &amp;&amp; ((sqlite3_initialize()) != 0))
        return null;
    if (((id) &gt; (1)) &amp;&amp; ((sqlite3MutexInit()) != 0))
        return null;
    return sqlite3Config.mutex.xMutexAlloc((int)(id));
}</function>
  <function>public static void sqlite3_mutex_enter(sqlite3_mutex* p)
{
    if ((p) != null)
    {
        sqlite3Config.mutex.xMutexEnter(p);
    }
}</function>
  <function>public static void sqlite3_mutex_free(sqlite3_mutex* p)
{
    if ((p) != null)
    {
        sqlite3Config.mutex.xMutexFree(p);
    }
}</function>
  <function>public static void sqlite3_mutex_leave(sqlite3_mutex* p)
{
    if ((p) != null)
    {
        sqlite3Config.mutex.xMutexLeave(p);
    }
}</function>
  <function>public static int sqlite3_mutex_try(sqlite3_mutex* p)
{
    int rc = (int)(0);
    if ((p) != null)
    {
        return (int)(sqlite3Config.mutex.xMutexTry(p));
    }

    return (int)(rc);
}</function>
  <function>public static sqlite3_stmt* sqlite3_next_stmt(sqlite3 pDb, sqlite3_stmt* pStmt)
{
    sqlite3_stmt* pNext;
    sqlite3_mutex_enter(pDb.mutex);
    if ((pStmt) == (null))
    {
        pNext = (sqlite3_stmt*)(pDb.pVdbe);
    }
    else
    {
        pNext = (sqlite3_stmt*)(((Vdbe)(pStmt)).pNext);
    }

    sqlite3_mutex_leave(pDb.mutex);
    return pNext;
}</function>
  <function>public static int sqlite3_open(sbyte* zFilename, sqlite3 ppDb)
{
    return (int)(openDatabase(zFilename, ppDb, (uint)(0x00000002 | 0x00000004), null));
}</function>
  <function>public static int sqlite3_open_v2(sbyte* filename, sqlite3 ppDb, int flags, sbyte* zVfs)
{
    return (int)(openDatabase(filename, ppDb, (uint)(flags), zVfs));
}</function>
  <function>public static int sqlite3_open16(void* zFilename, sqlite3 ppDb)
{
    sbyte* zFilename8;
    sqlite3_value pVal;
    int rc = 0;
    ppDb = null;
    rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (int)(rc);
    if ((zFilename) == (null))
        zFilename = "\000\000";
    pVal = sqlite3ValueNew(null);
    sqlite3ValueSetStr(pVal, (int)(-1), zFilename, (byte)(2), null);
    zFilename8 = sqlite3ValueText(pVal, (byte)(1));
    if ((zFilename8) != null)
    {
        rc = (int)(openDatabase(zFilename8, ppDb, (uint)(0x00000002 | 0x00000004), null));
        if (((rc) == (0)) &amp;&amp; (!(((ppDb).aDb[0].pSchema.schemaFlags &amp; (0x0001)) == (0x0001))))
        {
            ((ppDb).aDb[0].pSchema.enc) = (byte)(((ppDb).enc) = (byte)(2));
        }
    }
    else
    {
        rc = (int)(7);
    }

    sqlite3ValueFree(pVal);
    return (int)(rc &amp; 0xff);
}</function>
  <function>public static int sqlite3_os_end()
{
    winBigLock = null;
    return (int)(0);
}</function>
  <function>public static int sqlite3_os_init()
{
    CRuntime.memset(&amp;winSysInfo, (int)(0), (ulong)(sizeof(_SYSTEM_INFO)));
    (Void(_SYSTEM_INFO * ))(aSyscall[28].pCurrent)(&amp;winSysInfo);
    sqlite3_vfs_register(sqlite3_os_init_winVfs, (int)(1));
    sqlite3_vfs_register(sqlite3_os_init_winLongPathVfs, (int)(0));
    sqlite3_vfs_register(sqlite3_os_init_winNolockVfs, (int)(0));
    sqlite3_vfs_register(sqlite3_os_init_winLongPathNolockVfs, (int)(0));
    winBigLock = sqlite3MutexAlloc((int)(11));
    return (int)(0);
}</function>
  <function>public static int sqlite3_overload_function(sqlite3 db, sbyte* zName, int nArg)
{
    int rc = 0;
    sbyte* zCopy;
    sqlite3_mutex_enter(db.mutex);
    rc = (int)(sqlite3FindFunction(db, zName, (int)(nArg), (byte)(1), (byte)(0)) != null);
    sqlite3_mutex_leave(db.mutex);
    if ((rc) != 0)
        return (int)(0);
    zCopy = sqlite3_mprintf(zName);
    if ((zCopy) == (null))
        return (int)(7);
    return (int)(sqlite3_create_function_v2(db, zName, (int)(nArg), (int)(1), zCopy, sqlite3InvalidFunction, null, null, sqlite3_free));
}</function>
  <function>public static int sqlite3_prepare(sqlite3 db, sbyte* zSql, int nBytes, sqlite3_stmt** ppStmt, sbyte** pzTail)
{
    int rc = 0;
    rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0), null, ppStmt, pzTail));
    return (int)(rc);
}</function>
  <function>public static int sqlite3_prepare_v2(sqlite3 db, sbyte* zSql, int nBytes, sqlite3_stmt** ppStmt, sbyte** pzTail)
{
    int rc = 0;
    rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0x80), null, ppStmt, pzTail));
    return (int)(rc);
}</function>
  <function>public static int sqlite3_prepare_v3(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, sbyte** pzTail)
{
    int rc = 0;
    rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0x80 | (prepFlags &amp; 0x0f)), null, ppStmt, pzTail));
    return (int)(rc);
}</function>
  <function>public static int sqlite3_prepare16(sqlite3 db, void* zSql, int nBytes, sqlite3_stmt** ppStmt, void** pzTail)
{
    int rc = 0;
    rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0), ppStmt, pzTail));
    return (int)(rc);
}</function>
  <function>public static int sqlite3_prepare16_v2(sqlite3 db, void* zSql, int nBytes, sqlite3_stmt** ppStmt, void** pzTail)
{
    int rc = 0;
    rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0x80), ppStmt, pzTail));
    return (int)(rc);
}</function>
  <function>public static int sqlite3_prepare16_v3(sqlite3 db, void* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, void** pzTail)
{
    int rc = 0;
    rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0x80 | (prepFlags &amp; 0x0f)), ppStmt, pzTail));
    return (int)(rc);
}</function>
  <function>public static void* sqlite3_profile(sqlite3 db, delegate63 xProfile, void* pArg)
{
    void* pOld;
    sqlite3_mutex_enter(db.mutex);
    pOld = db.pProfileArg;
    db.xProfile = xProfile;
    db.pProfileArg = pArg;
    db.mTrace &amp;= (byte)(0x0f);
    if ((db.xProfile) != null)
        db.mTrace |= (byte)(0x80);
    sqlite3_mutex_leave(db.mutex);
    return pOld;
}</function>
  <function>public static void sqlite3_progress_handler(sqlite3 db, int nOps, delegate19 xProgress, void* pArg)
{
    sqlite3_mutex_enter(db.mutex);
    if ((nOps) &gt; (0))
    {
        db.xProgress = xProgress;
        db.nProgressOps = ((uint)(nOps));
        db.pProgressArg = pArg;
    }
    else
    {
        db.xProgress = null;
        db.nProgressOps = (uint)(0);
        db.pProgressArg = null;
    }

    sqlite3_mutex_leave(db.mutex);
}</function>
  <function>public static void sqlite3_randomness(int N, void* pBuf)
{
    byte t = 0;
    byte* zBuf = pBuf;
    sqlite3_mutex* mutex;
    if ((sqlite3_initialize()) != 0)
        return;
    mutex = sqlite3MutexAlloc((int)(5));
    sqlite3_mutex_enter(mutex);
    if (((N) &lt;= (0)) || ((pBuf) == (null)))
    {
        sqlite3Prng.isInit = (byte)(0);
        sqlite3_mutex_leave(mutex);
        return;
    }

    if (sqlite3Prng.isInit == 0)
    {
        sqlite3_vfs pVfs = sqlite3_vfs_find(null);
        int i = 0;
        sbyte* k = stackalloc sbyte[256];
        sqlite3Prng.j = (byte)(0);
        sqlite3Prng.i = (byte)(0);
        if (((pVfs) == (null)))
        {
            CRuntime.memset(k, (int)(0), (ulong)(256 * sizeof(sbyte)));
        }
        else
        {
            sqlite3OsRandomness(pVfs, (int)(256), k);
        }

        for (i = (int)(0); (i) &lt; (256); i++)
        {
            sqlite3Prng.s[i] = ((byte)(i));
        }

        for (i = (int)(0); (i) &lt; (256); i++)
        {
            sqlite3Prng.j += (byte)(sqlite3Prng.s[i] + k[i]);
            t = (byte)(sqlite3Prng.s[sqlite3Prng.j]);
            sqlite3Prng.s[sqlite3Prng.j] = (byte)(sqlite3Prng.s[i]);
            sqlite3Prng.s[i] = (byte)(t);
        }

        sqlite3Prng.isInit = (byte)(1);
    }

    do
    {
        sqlite3Prng.i++;
        t = (byte)(sqlite3Prng.s[sqlite3Prng.i]);
        sqlite3Prng.j += (byte)(t);
        sqlite3Prng.s[sqlite3Prng.i] = (byte)(sqlite3Prng.s[sqlite3Prng.j]);
        sqlite3Prng.s[sqlite3Prng.j] = (byte)(t);
        t += (byte)(sqlite3Prng.s[sqlite3Prng.i]);
        *(zBuf++) = (byte)(sqlite3Prng.s[t]);
    }
    while ((--N) != 0);
    sqlite3_mutex_leave(mutex);
}</function>
  <function>public static void* sqlite3_realloc(void* pOld, int n)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    if ((n) &lt; (0))
        n = (int)(0);
    return sqlite3Realloc(pOld, (ulong)(n));
}</function>
  <function>public static void* sqlite3_realloc64(void* pOld, ulong n)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return sqlite3Realloc(pOld, (ulong)(n));
}</function>
  <function>public static int sqlite3_release_memory(int n)
{
    return (int)(0);
}</function>
  <function>public static int sqlite3_reset(sqlite3_stmt* pStmt)
{
    int rc = 0;
    if ((pStmt) == (null))
    {
        rc = (int)(0);
    }
    else
    {
        Vdbe v = (Vdbe)(pStmt);
        sqlite3 db = v.db;
        sqlite3_mutex_enter(db.mutex);
        if (((v).startTime) &gt; (0))
        {
            invokeProfileCallback(db, v);
        }

        rc = (int)(sqlite3VdbeReset(v));
        sqlite3VdbeRewind(v);
        rc = (int)(sqlite3ApiExit(db, (int)(rc)));
        sqlite3_mutex_leave(db.mutex);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3_reset_auto_extension()
{
    if ((sqlite3_initialize()) == (0))
    {
        sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
        sqlite3_mutex_enter(mutex);
        sqlite3_free(sqlite3Autoext.aExt);
        sqlite3Autoext.aExt = null;
        sqlite3Autoext.nExt = (uint)(0);
        sqlite3_mutex_leave(mutex);
    }
}</function>
  <function>public static void sqlite3_result_blob(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
{
    setResultStrOrError(pCtx, z, (int)(n), (byte)(0), xDel);
}</function>
  <function>public static void sqlite3_result_blob64(sqlite3_context pCtx, void* z, ulong n, delegate17 xDel)
{
    if ((n) &gt; (0x7fffffff))
    {
        (void)(invokeValueDestructor(z, xDel, pCtx));
    }
    else
    {
        setResultStrOrError(pCtx, z, (int)(n), (byte)(0), xDel);
    }
}</function>
  <function>public static void sqlite3_result_double(sqlite3_context pCtx, double rVal)
{
    sqlite3VdbeMemSetDouble(pCtx.pOut, (double)(rVal));
}</function>
  <function>public static void sqlite3_result_error(sqlite3_context pCtx, sbyte* z, int n)
{
    pCtx.isError = (int)(1);
    sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(1), ((Void(Void * ))(-1)));
}</function>
  <function>public static void sqlite3_result_error_code(sqlite3_context pCtx, int errCode)
{
    pCtx.isError = (int)((errCode) != 0 ? errCode : -1);
    if ((pCtx.pOut.flags &amp; 0x0001) != 0)
    {
        sqlite3VdbeMemSetStr(pCtx.pOut, sqlite3ErrStr((int)(errCode)), (long)(-1), (byte)(1), null);
    }
}</function>
  <function>public static void sqlite3_result_error_nomem(sqlite3_context pCtx)
{
    sqlite3VdbeMemSetNull(pCtx.pOut);
    pCtx.isError = (int)(7);
    sqlite3OomFault(pCtx.pOut.db);
}</function>
  <function>public static void sqlite3_result_error_toobig(sqlite3_context pCtx)
{
    pCtx.isError = (int)(18);
    sqlite3VdbeMemSetStr(pCtx.pOut, "string or blob too big", (long)(-1), (byte)(1), null);
}</function>
  <function>public static void sqlite3_result_error16(sqlite3_context pCtx, void* z, int n)
{
    pCtx.isError = (int)(1);
    sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(2), ((Void(Void * ))(-1)));
}</function>
  <function>public static void sqlite3_result_int(sqlite3_context pCtx, int iVal)
{
    sqlite3VdbeMemSetInt64(pCtx.pOut, (long)(iVal));
}</function>
  <function>public static void sqlite3_result_int64(sqlite3_context pCtx, long iVal)
{
    sqlite3VdbeMemSetInt64(pCtx.pOut, (long)(iVal));
}</function>
  <function>public static void sqlite3_result_null(sqlite3_context pCtx)
{
    sqlite3VdbeMemSetNull(pCtx.pOut);
}</function>
  <function>public static void sqlite3_result_pointer(sqlite3_context pCtx, void* pPtr, sbyte* zPType, delegate17 xDestructor)
{
    sqlite3_value pOut = pCtx.pOut;
    sqlite3VdbeMemRelease(pOut);
    pOut.flags = (ushort)(0x0001);
    sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
}</function>
  <function>public static void sqlite3_result_subtype(sqlite3_context pCtx, uint eSubtype)
{
    sqlite3_value pOut = pCtx.pOut;
    pOut.eSubtype = (byte)(eSubtype &amp; 0xff);
    pOut.flags |= (ushort)(0x8000);
}</function>
  <function>public static void sqlite3_result_text(sqlite3_context pCtx, sbyte* z, int n, delegate17 xDel)
{
    setResultStrOrError(pCtx, z, (int)(n), (byte)(1), xDel);
}</function>
  <function>public static void sqlite3_result_text16(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
{
    setResultStrOrError(pCtx, z, (int)(n), (byte)(2), xDel);
}</function>
  <function>public static void sqlite3_result_text16be(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
{
    setResultStrOrError(pCtx, z, (int)(n), (byte)(3), xDel);
}</function>
  <function>public static void sqlite3_result_text16le(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
{
    setResultStrOrError(pCtx, z, (int)(n), (byte)(2), xDel);
}</function>
  <function>public static void sqlite3_result_text64(sqlite3_context pCtx, sbyte* z, ulong n, delegate17 xDel, byte enc)
{
    if ((enc) == (4))
        enc = (byte)(2);
    if ((n) &gt; (0x7fffffff))
    {
        (void)(invokeValueDestructor(z, xDel, pCtx));
    }
    else
    {
        setResultStrOrError(pCtx, z, (int)(n), (byte)(enc), xDel);
    }
}</function>
  <function>public static void sqlite3_result_value(sqlite3_context pCtx, sqlite3_value pValue)
{
    sqlite3VdbeMemCopy(pCtx.pOut, pValue);
}</function>
  <function>public static void sqlite3_result_zeroblob(sqlite3_context pCtx, int n)
{
    sqlite3VdbeMemSetZeroBlob(pCtx.pOut, (int)(n));
}</function>
  <function>public static int sqlite3_result_zeroblob64(sqlite3_context pCtx, ulong n)
{
    sqlite3_value pOut = pCtx.pOut;
    if ((n) &gt; ((ulong)(pOut.db.aLimit[0])))
    {
        return (int)(18);
    }

    sqlite3VdbeMemSetZeroBlob(pCtx.pOut, (int)(n));
    return (int)(0);
}</function>
  <function>public static void* sqlite3_rollback_hook(sqlite3 db, delegate17 xCallback, void* pArg)
{
    void* pRet;
    sqlite3_mutex_enter(db.mutex);
    pRet = db.pRollbackArg;
    db.xRollbackCallback = xCallback;
    db.pRollbackArg = pArg;
    sqlite3_mutex_leave(db.mutex);
    return pRet;
}</function>
  <function>public static byte* sqlite3_serialize(sqlite3 db, sbyte* zSchema, long* piSize, uint mFlags)
{
    MemFile p;
    int iDb = 0;
    Btree pBt;
    long sz = 0;
    int szPage = (int)(0);
    sqlite3_stmt* pStmt = null;
    byte* pOut;
    sbyte* zSql;
    int rc = 0;
    if ((zSchema) == (null))
        zSchema = db.aDb[0].zDbSName;
    p = memdbFromDbSchema(db, zSchema);
    iDb = (int)(sqlite3FindDbName(db, zSchema));
    if ((piSize) != null)
        *piSize = (long)(-1);
    if ((iDb) &lt; (0))
        return null;
    if ((p) != null)
    {
        MemStore* pStore = p.pStore;
        if ((piSize) != null)
            *piSize = (long)(pStore-&gt;sz);
        if ((mFlags &amp; 0x001) != 0)
        {
            pOut = pStore-&gt;aData;
        }
        else
        {
            pOut = sqlite3_malloc64((ulong)(pStore-&gt;sz));
            if ((pOut) != null)
                CRuntime.memcpy(pOut, pStore-&gt;aData, (ulong)(pStore-&gt;sz));
        }

        return pOut;
    }

    pBt = db.aDb[iDb].pBt;
    if ((pBt) == (null))
        return null;
    szPage = (int)(sqlite3BtreeGetPageSize(pBt));
    zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);
    rc = (int)((zSql) != 0 ? sqlite3_prepare_v2(db, zSql, (int)(-1), &amp;pStmt, null) : 7);
    sqlite3_free(zSql);
    if ((rc) != 0)
        return null;
    rc = (int)(sqlite3_step(pStmt));
    if (rc != 100)
    {
        pOut = null;
    }
    else
    {
        sz = (long)(sqlite3_column_int64(pStmt, (int)(0)) * szPage);
        if ((piSize) != null)
            *piSize = (long)(sz);
        if ((mFlags &amp; 0x001) != 0)
        {
            pOut = null;
        }
        else
        {
            pOut = sqlite3_malloc64((ulong)(sz));
            if ((pOut) != null)
            {
                int nPage = (int)(sqlite3_column_int(pStmt, (int)(0)));
                Pager pPager = sqlite3BtreePager(pBt);
                int pgno = 0;
                for (pgno = (int)(1); (pgno) &lt;= (nPage); pgno++)
                {
                    PgHdr pPage = null;
                    byte* pTo = pOut + szPage * (long)(pgno - 1);
                    rc = (int)(sqlite3PagerGet(pPager, (uint)(pgno), pPage, (int)(0)));
                    if ((rc) == (0))
                    {
                        CRuntime.memcpy(pTo, sqlite3PagerGetData(pPage), (ulong)(szPage));
                    }
                    else
                    {
                        CRuntime.memset(pTo, (int)(0), (ulong)(szPage));
                    }

                    sqlite3PagerUnref(pPage);
                }
            }
        }
    }

    sqlite3_finalize(pStmt);
    return pOut;
}</function>
  <function>public static int sqlite3_set_authorizer(sqlite3 db, delegate67 xAuth, void* pArg)
{
    sqlite3_mutex_enter(db.mutex);
    db.xAuth = xAuth;
    db.pAuthArg = pArg;
    if ((db.xAuth) != null)
        sqlite3ExpirePreparedStatements(db, (int)(1));
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static void sqlite3_set_auxdata(sqlite3_context pCtx, int iArg, void* pAux, delegate17 xDelete)
{
    AuxData pAuxData;
    Vdbe pVdbe = pCtx.pVdbe;
    for (pAuxData = pVdbe.pAuxData; pAuxData; pAuxData = pAuxData.pNextAux)
    {
        if (((pAuxData.iAuxArg) == (iArg)) &amp;&amp; (((pAuxData.iAuxOp) == (pCtx.iOp)) || ((iArg) &lt; (0))))
        {
            break;
        }
    }

    if ((pAuxData) == (null))
    {
        pAuxData = sqlite3DbMallocZero(pVdbe.db, (ulong)(sizeof(AuxData)));
        if (pAuxData == null)
            goto failed;
        pAuxData.iAuxOp = (int)(pCtx.iOp);
        pAuxData.iAuxArg = (int)(iArg);
        pAuxData.pNextAux = pVdbe.pAuxData;
        pVdbe.pAuxData = pAuxData;
        if ((pCtx.isError) == (0))
            pCtx.isError = (int)(-1);
    }
    else if ((pAuxData.xDeleteAux) != null)
    {
        pAuxData.xDeleteAux(pAuxData.pAux);
    }

    pAuxData.pAux = pAux;
    pAuxData.xDeleteAux = xDelete;
    return;
    failed:
        ; if  ( ( xDelete ) != null ) { xDelete ( pAux ) ;  }
}</function>
  <function>public static void sqlite3_set_last_insert_rowid(sqlite3 db, long iRowid)
{
    sqlite3_mutex_enter(db.mutex);
    db.lastRowid = (long)(iRowid);
    sqlite3_mutex_leave(db.mutex);
}</function>
  <function>public static int sqlite3_shutdown()
{
    if ((sqlite3Config.isInit) != 0)
    {
        sqlite3_os_end();
        sqlite3_reset_auto_extension();
        sqlite3Config.isInit = (int)(0);
    }

    if ((sqlite3Config.isPCacheInit) != 0)
    {
        sqlite3PcacheShutdown();
        sqlite3Config.isPCacheInit = (int)(0);
    }

    if ((sqlite3Config.isMallocInit) != 0)
    {
        sqlite3MallocEnd();
        sqlite3Config.isMallocInit = (int)(0);
        sqlite3_data_directory = null;
        sqlite3_temp_directory = null;
    }

    if ((sqlite3Config.isMutexInit) != 0)
    {
        sqlite3MutexEnd();
        sqlite3Config.isMutexInit = (int)(0);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3_sleep(int ms)
{
    sqlite3_vfs pVfs;
    int rc = 0;
    pVfs = sqlite3_vfs_find(null);
    if ((pVfs) == (null))
        return (int)(0);
    rc = (int)(sqlite3OsSleep(pVfs, (int)(1000 * ms)) / 1000);
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3_snprintf(int n, sbyte* zBuf, sbyte* zFormat)
{
    sbyte* z;
    sbyte* ap;
    (__va_start(&amp;ap, zFormat));
    z = sqlite3_vsnprintf((int)(n), zBuf, zFormat, ap);
    ((void)(ap = null));
    return z;
}</function>
  <function>public static void sqlite3_soft_heap_limit(int n)
{
    if ((n) &lt; (0))
        n = (int)(0);
    sqlite3_soft_heap_limit64((long)(n));
}</function>
  <function>public static long sqlite3_soft_heap_limit64(long n)
{
    long priorLimit = 0;
    long excess = 0;
    long nUsed = 0;
    int rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (long)(-1);
    sqlite3_mutex_enter(mem0.mutex);
    priorLimit = (long)(mem0.alarmThreshold);
    if ((n) &lt; (0))
    {
        sqlite3_mutex_leave(mem0.mutex);
        return (long)(priorLimit);
    }

    if (((mem0.hardLimit) &gt; (0)) &amp;&amp; (((n) &gt; (mem0.hardLimit)) || ((n) == (0))))
    {
        n = (long)(mem0.hardLimit);
    }

    mem0.alarmThreshold = (long)(n);
    nUsed = (long)(sqlite3StatusValue((int)(0)));
    (((n) &gt; (0)) &amp;&amp; ((n) &lt;= (nUsed)));
    sqlite3_mutex_leave(mem0.mutex);
    excess = (long)(sqlite3_memory_used() - n);
    if ((excess) &gt; (0))
        sqlite3_release_memory((int)(excess &amp; 0x7fffffff));
    return (long)(priorLimit);
}</function>
  <function>public static sbyte* sqlite3_sourceid()
{
    return "2022-03-26 13:51:10 d33c709cc0af66bc5b6dc6216eba9f1f0b40960b9ae83694c986fbf4c1d6f08f";
}</function>
  <function>public static sbyte* sqlite3_sql(sqlite3_stmt* pStmt)
{
    Vdbe p = (Vdbe)(pStmt);
    return p ? p.zSql : null;
}</function>
  <function>public static int sqlite3_status(int op, int* pCurrent, int* pHighwater, int resetFlag)
{
    long iCur = (long)(0); long  iHwtr  =  ( long ) ( 0 ) ; 
    int rc = 0;
    rc = (int)(sqlite3_status64((int)(op), &amp;iCur, &amp;iHwtr, (int)(resetFlag)));
    if ((rc) == (0))
    {
        *pCurrent = ((int)(iCur));
        *pHighwater = ((int)(iHwtr));
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_status64(int op, long* pCurrent, long* pHighwater, int resetFlag)
{
    sqlite3_mutex* pMutex;
    if (((op) &lt; (0)) || ((op) &gt;= ((int)(10 * sizeof(long) / sizeof(long)))))
    {
        return (int)(sqlite3MisuseError((int)(22813)));
    }

    pMutex = (statMutex[op]) != 0 ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
    sqlite3_mutex_enter(pMutex);
    *pCurrent = (long)(sqlite3Stat.nowValue[op]);
    *pHighwater = (long)(sqlite3Stat.mxValue[op]);
    if ((resetFlag) != 0)
    {
        sqlite3Stat.mxValue[op] = (long)(sqlite3Stat.nowValue[op]);
    }

    sqlite3_mutex_leave(pMutex);
    (void)(pMutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_step(sqlite3_stmt* pStmt)
{
    int rc = (int)(0);
    Vdbe v = (Vdbe)(pStmt);
    int cnt = (int)(0);
    sqlite3 db;
    if ((vdbeSafetyNotNull(v)) != 0)
    {
        return (int)(sqlite3MisuseError((int)(85831)));
    }

    db = v.db;
    sqlite3_mutex_enter(db.mutex);
    v.doingRerun = (byte)(0);
    while (((rc = (int)(sqlite3Step(v))) == (17)) &amp;&amp; ((cnt++) &lt; (50)))
    {
        int savedPc = (int)(v.pc);
        rc = (int)(sqlite3Reprepare(v));
        if (rc != 0)
        {
            sbyte* zErr = (sbyte*)(sqlite3_value_text(db.pErr));
            sqlite3DbFree(db, v.zErrMsg);
            if (db.mallocFailed == 0)
            {
                v.zErrMsg = sqlite3DbStrDup(db, zErr);
                v.rc = (int)(rc = (int)(sqlite3ApiExit(db, (int)(rc))));
            }
            else
            {
                v.zErrMsg = null;
                v.rc = (int)(rc = (int)(7));
            }

            break;
        }

        sqlite3_reset(pStmt);
        if ((savedPc) &gt;= (0))
            v.doingRerun = (byte)(1);
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_stmt_busy(sqlite3_stmt* pStmt)
{
    Vdbe v = (Vdbe)(pStmt);
    return (((v != null) &amp;&amp; ((v.iVdbeMagic) == (0x2df20da3))) &amp;&amp; ((v.pc) &gt;= (0)) ? 1 : 0);
}</function>
  <function>public static int sqlite3_stmt_isexplain(sqlite3_stmt* pStmt)
{
    return (int)(pStmt ? ((Vdbe)(pStmt)).explain : 0);
}</function>
  <function>public static int sqlite3_stmt_readonly(sqlite3_stmt* pStmt)
{
    return (int)(pStmt ? ((Vdbe)(pStmt)).readOnly : 1);
}</function>
  <function>public static int sqlite3_stmt_status(sqlite3_stmt* pStmt, int op, int resetFlag)
{
    Vdbe pVdbe = (Vdbe)(pStmt);
    uint v = 0;
    if ((op) == (99))
    {
        sqlite3 db = pVdbe.db;
        sqlite3_mutex_enter(db.mutex);
        v = (uint)(0);
        db.pnBytesFreed = (int*)(&amp;v);
        sqlite3VdbeClearObject(db, pVdbe);
        sqlite3DbFree(db, pVdbe);
        db.pnBytesFreed = null;
        sqlite3_mutex_leave(db.mutex);
    }
    else
    {
        v = (uint)(pVdbe.aCounter[op]);
        if ((resetFlag) != 0)
            pVdbe.aCounter[op] = (uint)(0);
    }

    return (int)(v);
}</function>
  <function>public static void sqlite3_str_append(sqlite3_str p, sbyte* z, int N)
{
    if ((p.nChar + N) &gt;= (p.nAlloc))
    {
        enlargeAndAppend(p, z, (int)(N));
    }
    else if ((N) != 0)
    {
        p.nChar += (uint)(N);
        CRuntime.memcpy(&amp;p.zText[p.nChar - N], z, (ulong)(N));
    }
}</function>
  <function>public static void sqlite3_str_appendall(sqlite3_str p, sbyte* z)
{
    sqlite3_str_append(p, z, (int)(sqlite3Strlen30(z)));
}</function>
  <function>public static void sqlite3_str_appendchar(sqlite3_str p, int N, sbyte c)
{
    if (((p.nChar + (long)(N)) &gt;= (p.nAlloc)) &amp;&amp; ((N = (int)(sqlite3StrAccumEnlarge(p, (int)(N)))) &lt;= (0)))
    {
        return;
    }

    while ((N--) &gt; (0))
    {
        p.zText[p.nChar++] = (sbyte)(c);
    }
}</function>
  <function>public static void sqlite3_str_appendf(sqlite3_str p, sbyte* zFormat)
{
    sbyte* ap;
    (__va_start(&amp;ap, zFormat));
    sqlite3_str_vappendf(p, zFormat, ap);
    ((void)(ap = null));
}</function>
  <function>public static int sqlite3_str_errcode(sqlite3_str p)
{
    return (int)(p ? p.accError : 7);
}</function>
  <function>public static sbyte* sqlite3_str_finish(sqlite3_str p)
{
    sbyte* z;
    if ((p != null) &amp;&amp; (p != sqlite3OomStr))
    {
        z = sqlite3StrAccumFinish(p);
        sqlite3_free(p);
    }
    else
    {
        z = null;
    }

    return z;
}</function>
  <function>public static int sqlite3_str_length(sqlite3_str p)
{
    return (int)(p ? p.nChar : 0);
}</function>
  <function>public static sqlite3_str sqlite3_str_new(sqlite3 db)
{
    sqlite3_str p = sqlite3_malloc64((ulong)(sizeof(sqlite3_str)));
    if ((p) != null)
    {
        sqlite3StrAccumInit(p, null, null, (int)(0), (int)(db ? db.aLimit[0] : 1000000000));
    }
    else
    {
        p = sqlite3OomStr;
    }

    return p;
}</function>
  <function>public static void sqlite3_str_reset(sqlite3_str p)
{
    if ((((p).printfFlags &amp; 0x04) != 0))
    {
        sqlite3DbFree(p.db, p.zText);
        p.printfFlags &amp;= (byte)(~0x04);
    }

    p.nAlloc = (uint)(0);
    p.nChar = (uint)(0);
    p.zText = null;
}</function>
  <function>public static sbyte* sqlite3_str_value(sqlite3_str p)
{
    if (((p) == (null)) || ((p.nChar) == (0)))
        return null;
    p.zText[p.nChar] = (sbyte)(0);
    return p.zText;
}</function>
  <function>public static void sqlite3_str_vappendf(sqlite3_str pAccum, sbyte* fmt, sbyte* ap)
{
    int c = 0;
    sbyte* bufpt;
    int precision = 0;
    int length = 0;
    int idx = 0;
    int width = 0;
    byte flag_leftjustify = 0;
    byte flag_prefix = 0;
    byte flag_alternateform = 0;
    byte flag_altform2 = 0;
    byte flag_zeropad = 0;
    byte flag_long = 0;
    byte done = 0;
    byte cThousand = 0;
    byte xtype = (byte)(17);
    byte bArgList = 0;
    sbyte prefix = 0;
    ulong longvalue = 0;
    double realvalue = 0;
    et_info* infop;
    sbyte* zOut;
    int nOut = 0;
    sbyte* zExtra = null;
    int exp = 0; int  e2  =  0 ; 
    int nsd = 0;
    double rounder = 0;
    byte flag_dp = 0;
    byte flag_rtz = 0;
    PrintfArguments pArgList = null;
    sbyte* buf = stackalloc sbyte[70];
    bufpt = null;
    if ((pAccum.printfFlags &amp; 0x02) != 0)
    {
        pArgList = ((((sizeof(PrintfArguments)) &gt; ()) || ((sizeof(PrintfArguments) &amp; (sizeof(PrintfArguments) - 1)) != 0)) ? (PrintfArguments)((ap += ) - ) : (PrintfArguments)((ap += ) - ));
        bArgList = (byte)(1);
    }
    else
    {
        bArgList = (byte)(0);
    }

    for (; (c = (int)(*fmt)) != 0; ++fmt)
    {
        if (c != 37)
        {
            bufpt = fmt;
            do
            {
                fmt++;
            }
            while (((*fmt) != 0) &amp;&amp; (*fmt != 37));
            sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));
            if ((*fmt) == (0))
                break;
        }

        if ((c = (int)(*++fmt)) == (0))
        {
            sqlite3_str_append(pAccum, "%", (int)(1));
            break;
        }

        flag_leftjustify = (byte)(flag_prefix = (byte)(cThousand = (byte)(flag_alternateform = (byte)(flag_altform2 = (byte)(flag_zeropad = (byte)(0))))));
        done = (byte)(0);
        width = (int)(0);
        flag_long = (byte)(0);
        precision = (int)(-1);
        do
        {
            switch (c)
            {
                case 45:
                    flag_leftjustify = (byte)(1);
                    break;
                case 43:
                    flag_prefix = (byte)(43);
                    break;
                case 32:
                    flag_prefix = (byte)(32);
                    break;
                case 35:
                    flag_alternateform = (byte)(1);
                    break;
                case 33:
                    flag_altform2 = (byte)(1);
                    break;
                case 48:
                    flag_zeropad = (byte)(1);
                    break;
                case 44:
                    cThousand = (byte)(44);
                    break;
                default:
                    done = (byte)(1);
                    break;
                case 108:
                {
                    flag_long = (byte)(1);
                    c = (int)(*++fmt);
                    if ((c) == (108))
                    {
                        c = (int)(*++fmt);
                        flag_long = (byte)(2);
                    }

                    done = (byte)(1);
                    break;
                }

                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                {
                    uint wx = (uint)(c - 48);
                    while (((c = (int)(*++fmt)) &gt;= (48)) &amp;&amp; ((c) &lt;= (57)))
                    {
                        wx = (uint)(wx * 10 + c - 48);
                    }

                    width = (int)(wx &amp; 0x7fffffff);
                    if ((c != 46) &amp;&amp; (c != 108))
                    {
                        done = (byte)(1);
                    }
                    else
                    {
                        fmt--;
                    }

                    break;
                }

                case 42:
                {
                    if ((bArgList) != 0)
                    {
                        width = ((int)(getIntArg(pArgList)));
                    }
                    else
                    {
                        width = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
                    }

                    if ((width) &lt; (0))
                    {
                        flag_leftjustify = (byte)(1);
                        width = (int)((width) &gt;= (-2147483647) ? -width : 0);
                    }

                    if (((c = (int)(fmt[1])) != 46) &amp;&amp; (c != 108))
                    {
                        c = (int)(*++fmt);
                        done = (byte)(1);
                    }

                    break;
                }

                case 46:
                {
                    c = (int)(*++fmt);
                    if ((c) == (42))
                    {
                        if ((bArgList) != 0)
                        {
                            precision = ((int)(getIntArg(pArgList)));
                        }
                        else
                        {
                            precision = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
                        }

                        if ((precision) &lt; (0))
                        {
                            precision = (int)((precision) &gt;= (-2147483647) ? -precision : -1);
                        }

                        c = (int)(*++fmt);
                    }
                    else
                    {
                        uint px = (uint)(0);
                        while (((c) &gt;= (48)) &amp;&amp; ((c) &lt;= (57)))
                        {
                            px = (uint)(px * 10 + c - 48);
                            c = (int)(*++fmt);
                        }

                        precision = (int)(px &amp; 0x7fffffff);
                    }

                    if ((c) == (108))
                    {
                        --fmt;
                    }
                    else
                    {
                        done = (byte)(1);
                    }

                    break;
                }
            }
        }
        while ((done == 0) &amp;&amp; ((c = (int)(*++fmt)) != 0));
        infop = &amp;fmtinfo[0];
        xtype = (byte)(17);
        for (idx = (int)(0); (idx) &lt; ((int)(23 * sizeof(et_info) / sizeof(et_info))); idx++)
        {
            if ((c) == (fmtinfo[idx].fmttype))
            {
                infop = &amp;fmtinfo[idx];
                xtype = (byte)(infop-&gt;type);
                break;
            }
        }

        switch (xtype)
        {
            case 13:
                flag_long = (byte)((sizeof(char*)) == (sizeof(long)) ? 2 : (sizeof(char*)) == (sizeof(longint)) ? 1 : 0);
            case 15:
            case 0:
                cThousand = (byte)(0);
            case 16:
                if ((infop-&gt;flags &amp; 1) != 0)
                {
                    long v = 0;
                    if ((bArgList) != 0)
                    {
                        v = (long)(getIntArg(pArgList));
                    }
                    else if ((flag_long) != 0)
                    {
                        if ((flag_long) == (2))
                        {
                            v = (long)((((sizeof(long)) &gt; ()) || ((sizeof(long) &amp; (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
                        }
                        else
                        {
                            v = (long)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
                        }
                    }
                    else
                    {
                        v = (long)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
                    }

                    if ((v) &lt; (0))
                    {
                        longvalue = (ulong)(~v);
                        longvalue++;
                        prefix = (sbyte)(45);
                    }
                    else
                    {
                        longvalue = (ulong)(v);
                        prefix = (sbyte)(flag_prefix);
                    }
                }
                else
                {
                    if ((bArgList) != 0)
                    {
                        longvalue = ((ulong)(getIntArg(pArgList)));
                    }
                    else if ((flag_long) != 0)
                    {
                        if ((flag_long) == (2))
                        {
                            longvalue = (ulong)((((sizeof(ulong)) &gt; ()) || ((sizeof(ulong) &amp; (sizeof(ulong) - 1)) != 0)) ? **(ulong**)((ap += ) - ) : *(ulong*)((ap += ) - ));
                        }
                        else
                        {
                            longvalue = (ulong)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
                        }
                    }
                    else
                    {
                        longvalue = (ulong)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
                    }

                    prefix = (sbyte)(0);
                }

                if ((longvalue) == (0))
                    flag_alternateform = (byte)(0);
                if (((flag_zeropad) != 0) &amp;&amp; ((precision) &lt; (width - (prefix != 0))))
                {
                    precision = (int)(width - (prefix != 0));
                }

                if ((precision) &lt; (70 - 10 - 70 / 3))
                {
                    nOut = (int)(70);
                    zOut = buf;
                }
                else
                {
                    ulong n = 0;
                    n = (ulong)((ulong)(precision) + 10);
                    if ((cThousand) != 0)
                        n += (ulong)(precision / 3);
                    zOut = zExtra = printfTempBuf(pAccum, (long)(n));
                    if ((zOut) == (null))
                        return;
                    nOut = ((int)(n));
                }

                bufpt = &amp;zOut[nOut - 1];
                if ((xtype) == (15))
                {
                    int x = (int)(longvalue % 10);
                    if (((x) &gt;= (4)) || (((longvalue / 10) % 10) == (1)))
                    {
                        x = (int)(0);
                    }

                    *(--bufpt) = (sbyte)(sqlite3_str_vappendf_zOrd[x * 2 + 1]);
                    *(--bufpt) = (sbyte)(sqlite3_str_vappendf_zOrd[x * 2]);
                }

            {
                sbyte* cset = &amp;aDigits[infop-&gt;charset];
                byte _base_ = (byte)(infop-&gt;_base_);
                do
                {
                    *(--bufpt) = (sbyte)(cset[longvalue % _base_]);
                    longvalue = (ulong)(longvalue / _base_);
                }
                while ((longvalue) &gt; (0));
            }

                length = ((int)(&amp;zOut[nOut - 1] - bufpt));
                while ((precision) &gt; (length))
                {
                    *(--bufpt) = (sbyte)(48);
                    length++;
                }

                if ((cThousand) != 0)
                {
                    int nn = (int)((length - 1) / 3);
                    int ix = (int)((length - 1) % 3 + 1);
                    bufpt -= nn;
                    for (idx = (int)(0); (nn) &gt; (0); idx++)
                    {
                        bufpt[idx] = (sbyte)(bufpt[idx + nn]);
                        ix--;
                        if ((ix) == (0))
                        {
                            bufpt[++idx] = (sbyte)(cThousand);
                            nn--;
                            ix = (int)(3);
                        }
                    }
                }

                if ((prefix) != 0)
                    *(--bufpt) = (sbyte)(prefix);
                if (((flag_alternateform) != 0) &amp;&amp; ((infop-&gt;prefix) != 0))
                {
                    sbyte* pre;
                    sbyte x = 0;
                    pre = &amp;aPrefix[infop-&gt;prefix];
                    for (; (x = (sbyte)(*pre)) != 0; pre++)
                    {
                        *(--bufpt) = (sbyte)(x);
                    }
                }

                length = ((int)(&amp;zOut[nOut - 1] - bufpt));
                break;
            case 1:
            case 2:
            case 3:
                if ((bArgList) != 0)
                {
                    realvalue = (double)(getDoubleArg(pArgList));
                }
                else
                {
                    realvalue = (double)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(double**)((ap += ) - ) : *(double*)((ap += ) - ));
                }

                if ((precision) &lt; (0))
                    precision = (int)(6);
                if ((precision) &gt; (100000000))
                {
                    precision = (int)(100000000);
                }

                if ((realvalue) &lt; (0.0))
                {
                    realvalue = (double)(-realvalue);
                    prefix = (sbyte)(45);
                }
                else
                {
                    prefix = (sbyte)(flag_prefix);
                }

                if (((xtype) == (3)) &amp;&amp; ((precision) &gt; (0)))
                    precision--;
                idx = (int)(precision &amp; 0xfff);
                rounder = (double)(arRound[idx % 10]);
                while ((idx) &gt;= (10))
                {
                    rounder *= (double)(1.0e-10);
                    idx -= (int)(10);
                }

                if ((xtype) == (1))
                {
                    double rx = (double)(realvalue);
                    ulong u = 0;
                    int ex = 0;
                    CRuntime.memcpy(&amp;u, &amp;rx, (ulong)(sizeof(ulong)));
                    ex = (int)(-1023 + (int)((u &gt;&gt; 52) &amp; 0x7ff));
                    if ((precision + (ex / 3)) &lt; (15))
                        rounder += (double)(realvalue * 3e-16);
                    realvalue += (double)(rounder);
                }

                exp = (int)(0);
                if ((sqlite3IsNaN((double)(realvalue))) != 0)
                {
                    bufpt = "NaN";
                    length = (int)(3);
                    break;
                }

                if ((realvalue) &gt; (0.0))
                {
                    double scale = (double)(1.0);
                    while (((realvalue) &gt;= (1e100 * scale)) &amp;&amp; ((exp) &lt;= (350)))
                    {
                        scale *= (double)(1e100);
                        exp += (int)(100);
                    }

                    while (((realvalue) &gt;= (1e10 * scale)) &amp;&amp; ((exp) &lt;= (350)))
                    {
                        scale *= (double)(1e10);
                        exp += (int)(10);
                    }

                    while (((realvalue) &gt;= (10.0 * scale)) &amp;&amp; ((exp) &lt;= (350)))
                    {
                        scale *= (double)(10.0);
                        exp++;
                    }

                    realvalue /= (double)(scale);
                    while ((realvalue) &lt; (1e-8))
                    {
                        realvalue *= (double)(1e8);
                        exp -= (int)(8);
                    }

                    while ((realvalue) &lt; (1.0))
                    {
                        realvalue *= (double)(10.0);
                        exp--;
                    }

                    if ((exp) &gt; (350))
                    {
                        bufpt = buf;
                        buf[0] = (sbyte)(prefix);
                        CRuntime.memcpy(buf + (prefix != 0), "Inf", (ulong)(4));
                        length = (int)(3 + (prefix != 0));
                        break;
                    }
                }

                bufpt = buf;
                if (xtype != 1)
                {
                    realvalue += (double)(rounder);
                    if ((realvalue) &gt;= (10.0))
                    {
                        realvalue *= (double)(0.1);
                        exp++;
                    }
                }

                if ((xtype) == (3))
                {
                    flag_rtz = (byte)(!flag_alternateform);
                    if (((exp) &lt; (-4)) || ((exp) &gt; (precision)))
                    {
                        xtype = (byte)(2);
                    }
                    else
                    {
                        precision = (int)(precision - exp);
                        xtype = (byte)(1);
                    }
                }
                else
                {
                    flag_rtz = (byte)(flag_altform2);
                }

                if ((xtype) == (2))
                {
                    e2 = (int)(0);
                }
                else
                {
                    e2 = (int)(exp);
                }

            {
                long szBufNeeded = 0;
                szBufNeeded = (long)(((e2) &gt; (0) ? (e2) : (0)) + (long)(precision) + (long)(width) + 15);
                if ((szBufNeeded) &gt; (70))
                {
                    bufpt = zExtra = printfTempBuf(pAccum, (long)(szBufNeeded));
                    if ((bufpt) == (null))
                        return;
                }
            }

                zOut = bufpt;
                nsd = (int)(16 + flag_altform2 * 10);
                flag_dp = (byte)(((precision) &gt; (0) ? 1 : 0) | flag_alternateform | flag_altform2);
                if ((prefix) != 0)
                {
                    *(bufpt++) = (sbyte)(prefix);
                }

                if ((e2) &lt; (0))
                {
                    *(bufpt++) = (sbyte)(48);
                }
                else
                {
                    for (; (e2) &gt;= (0); e2--)
                    {
                        *(bufpt++) = (sbyte)(et_getdigit(&amp;realvalue, &amp;nsd));
                    }
                }

                if ((flag_dp) != 0)
                {
                    *(bufpt++) = (sbyte)(46);
                }

                for (e2++; (e2) &lt; (0); precision--, e2++)
                {
                    *(bufpt++) = (sbyte)(48);
                }

                while ((precision--) &gt; (0))
                {
                    *(bufpt++) = (sbyte)(et_getdigit(&amp;realvalue, &amp;nsd));
                }

                if (((flag_rtz) != 0) &amp;&amp; ((flag_dp) != 0))
                {
                    while ((bufpt[-1]) == (48))
                    {
                        *(--bufpt) = (sbyte)(0);
                    }

                    if ((bufpt[-1]) == (46))
                    {
                        if ((flag_altform2) != 0)
                        {
                            *(bufpt++) = (sbyte)(48);
                        }
                        else
                        {
                            *(--bufpt) = (sbyte)(0);
                        }
                    }
                }

                if ((xtype) == (2))
                {
                    *(bufpt++) = (sbyte)(aDigits[infop-&gt;charset]);
                    if ((exp) &lt; (0))
                    {
                        *(bufpt++) = (sbyte)(45);
                        exp = (int)(-exp);
                    }
                    else
                    {
                        *(bufpt++) = (sbyte)(43);
                    }

                    if ((exp) &gt;= (100))
                    {
                        *(bufpt++) = ((sbyte)((exp / 100) + 48));
                        exp %= (int)(100);
                    }

                    *(bufpt++) = ((sbyte)(exp / 10 + 48));
                    *(bufpt++) = ((sbyte)(exp % 10 + 48));
                }

                *bufpt = (sbyte)(0);
                length = ((int)(bufpt - zOut));
                bufpt = zOut;
                if ((((flag_zeropad) != 0) &amp;&amp; (flag_leftjustify == 0)) &amp;&amp; ((length) &lt; (width)))
                {
                    int i = 0;
                    int nPad = (int)(width - length);
                    for (i = (int)(width); (i) &gt;= (nPad); i--)
                    {
                        bufpt[i] = (sbyte)(bufpt[i - nPad]);
                    }

                    i = (int)(prefix != 0);
                    while ((nPad--) != 0)
                    {
                        bufpt[i++] = (sbyte)(48);
                    }

                    length = (int)(width);
                }

                break;
            case 4:
                if (bArgList == 0)
                {
                    *(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(pAccum.nChar);
                }

                length = (int)(width = (int)(0));
                break;
            case 7:
                buf[0] = (sbyte)(37);
                bufpt = buf;
                length = (int)(1);
                break;
            case 8:
                if ((bArgList) != 0)
                {
                    bufpt = getTextArg(pArgList);
                    length = (int)(1);
                    if ((bufpt) != null)
                    {
                        buf[0] = (sbyte)(c = (int)(*(bufpt++)));
                        if ((c &amp; 0xc0) == (0xc0))
                        {
                            while (((length) &lt; (4)) &amp;&amp; ((bufpt[0] &amp; 0xc0) == (0x80)))
                            {
                                buf[length++] = (sbyte)(*(bufpt++));
                            }
                        }
                    }
                    else
                    {
                        buf[0] = (sbyte)(0);
                    }
                }
                else
                {
                    uint ch = (uint)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
                    if ((ch) &lt; (0x00080))
                    {
                        buf[0] = (sbyte)(ch &amp; 0xff);
                        length = (int)(1);
                    }
                    else if ((ch) &lt; (0x00800))
                    {
                        buf[0] = (sbyte)(0xc0 + (byte)((ch &gt;&gt; 6) &amp; 0x1f));
                        buf[1] = (sbyte)(0x80 + (byte)(ch &amp; 0x3f));
                        length = (int)(2);
                    }
                    else if ((ch) &lt; (0x10000))
                    {
                        buf[0] = (sbyte)(0xe0 + (byte)((ch &gt;&gt; 12) &amp; 0x0f));
                        buf[1] = (sbyte)(0x80 + (byte)((ch &gt;&gt; 6) &amp; 0x3f));
                        buf[2] = (sbyte)(0x80 + (byte)(ch &amp; 0x3f));
                        length = (int)(3);
                    }
                    else
                    {
                        buf[0] = (sbyte)(0xf0 + (byte)((ch &gt;&gt; 18) &amp; 0x07));
                        buf[1] = (sbyte)(0x80 + (byte)((ch &gt;&gt; 12) &amp; 0x3f));
                        buf[2] = (sbyte)(0x80 + (byte)((ch &gt;&gt; 6) &amp; 0x3f));
                        buf[3] = (sbyte)(0x80 + (byte)(ch &amp; 0x3f));
                        length = (int)(4);
                    }
                }

                if ((precision) &gt; (1))
                {
                    width -= (int)(precision - 1);
                    if (((width) &gt; (1)) &amp;&amp; (flag_leftjustify == 0))
                    {
                        sqlite3_str_appendchar(pAccum, (int)(width - 1), (sbyte)(32));
                        width = (int)(0);
                    }

                    while ((precision--) &gt; (1))
                    {
                        sqlite3_str_append(pAccum, buf, (int)(length));
                    }
                }

                bufpt = buf;
                flag_altform2 = (byte)(1);
                goto adjust_width_for_utf8;
            case 5:
            case 6:
                if ((bArgList) != 0)
                {
                    bufpt = getTextArg(pArgList);
                    xtype = (byte)(5);
                }
                else
                {
                    bufpt = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
                }

                if ((bufpt) == (null))
                {
                    bufpt = "";
                }
                else if ((xtype) == (6))
                {
                    if ((((((pAccum.nChar) == (0)) &amp;&amp; ((pAccum.mxAlloc) != 0)) &amp;&amp; ((width) == (0))) &amp;&amp; ((precision) &lt; (0))) &amp;&amp; ((pAccum.accError) == (0)))
                    {
                        pAccum.zText = bufpt;
                        pAccum.nAlloc = (uint)(sqlite3DbMallocSize(pAccum.db, bufpt));
                        pAccum.nChar = (uint)(0x7fffffff &amp; (int)(CRuntime.strlen(bufpt)));
                        pAccum.printfFlags |= (byte)(0x04);
                        length = (int)(0);
                        break;
                    }

                    zExtra = bufpt;
                }

                if ((precision) &gt;= (0))
                {
                    if ((flag_altform2) != 0)
                    {
                        byte* z = (byte*)(bufpt);
                        while (((precision--) &gt; (0)) &amp;&amp; ((z[0]) != 0))
                        {
                            {
                                if ((*(z++)) &gt;= (0xc0))
                                {
                                    while ((*z &amp; 0xc0) == (0x80))
                                    {
                                        z++;
                                    }
                                }
                            }
                        }

                        length = ((int)(z - (byte*)(bufpt)));
                    }
                    else
                    {
                        for (length = (int)(0); ((length) &lt; (precision)) &amp;&amp; ((bufpt[length]) != 0); length++)
                        {
                        }
                    }
                }
                else
                {
                    length = (int)(0x7fffffff &amp; (int)(CRuntime.strlen(bufpt)));
                }

                adjust_width_for_utf8:
                    ;
                if (((flag_altform2) != 0) &amp;&amp; ((width) &gt; (0)))
                {
                    int ii = (int)(length - 1);
                    while ((ii) &gt;= (0))
                    {
                        if ((bufpt[ii--] &amp; 0xc0) == (0x80))
                            width++;
                    }
                }

                break;
            case 9:
            case 10:
            case 14:
            {
                int i = 0;
                int j = 0;
                int k = 0;
                int n = 0;
                int isnull = 0;
                int needQuote = 0;
                sbyte ch = 0;
                sbyte q = (sbyte)(((xtype) == (14)) ? 34 : 39);
                sbyte* escarg;
                if ((bArgList) != 0)
                {
                    escarg = getTextArg(pArgList);
                }
                else
                {
                    escarg = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
                }

                isnull = (int)((escarg) == (null) ? 1 : 0);
                if ((isnull) != 0)
                    escarg = ((xtype) == (10) ? "NULL" : "(NULL)");
                k = (int)(precision);
                for (i = (int)(n = (int)(0)); (k != 0) &amp;&amp; ((ch = (sbyte)(escarg[i])) != 0); i++, k--)
                {
                    if ((ch) == (q))
                        n++;
                    if (((flag_altform2) != 0) &amp;&amp; ((ch &amp; 0xc0) == (0xc0)))
                    {
                        while ((escarg[i + 1] &amp; 0xc0) == (0x80))
                        {
                            i++;
                        }
                    }
                }

                needQuote = (int)((isnull == 0) &amp;&amp; ((xtype) == (10)) ? 1 : 0);
                n += (int)(i + 3);
                if ((n) &gt; (70))
                {
                    bufpt = zExtra = printfTempBuf(pAccum, (long)(n));
                    if ((bufpt) == (null))
                        return;
                }
                else
                {
                    bufpt = buf;
                }

                j = (int)(0);
                if ((needQuote) != 0)
                    bufpt[j++] = (sbyte)(q);
                k = (int)(i);
                for (i = (int)(0); (i) &lt; (k); i++)
                {
                    bufpt[j++] = (sbyte)(ch = (sbyte)(escarg[i]));
                    if ((ch) == (q))
                        bufpt[j++] = (sbyte)(ch);
                }

                if ((needQuote) != 0)
                    bufpt[j++] = (sbyte)(q);
                bufpt[j] = (sbyte)(0);
                length = (int)(j);
                goto adjust_width_for_utf8;
            }

            case 11:
            {
                if ((pAccum.printfFlags &amp; 0x01) == (0))
                    return;
                if ((flag_alternateform) != 0)
                {
                    Expr pExpr = ((((sizeof(Expr)) &gt; ()) || ((sizeof(Expr) &amp; (sizeof(Expr) - 1)) != 0)) ? (Expr)((ap += ) - ) : (Expr)((ap += ) - ));
                    if (((pExpr) != null) &amp;&amp; ((!(((pExpr).flags &amp; (0x000400)) != 0)) != 0))
                    {
                        sqlite3_str_appendall(pAccum, pExpr.u.zToken);
                        sqlite3RecordErrorOffsetOfExpr(pAccum.db, pExpr);
                    }
                }
                else
                {
                    Token* pToken = ((((sizeof(Token)) &gt; ()) || ((sizeof(Token) &amp; (sizeof(Token) - 1)) != 0)) ? **(Token***)((ap += ) - ) : *(Token**)((ap += ) - ));
                    if (((pToken) != null) &amp;&amp; ((pToken-&gt;n) != 0))
                    {
                        sqlite3_str_append(pAccum, pToken-&gt;z, (int)(pToken-&gt;n));
                        sqlite3RecordErrorByteOffset(pAccum.db, pToken-&gt;z);
                    }
                }

                length = (int)(width = (int)(0));
                break;
            }

            case 12:
            {
                SrcItem pItem;
                if ((pAccum.printfFlags &amp; 0x01) == (0))
                    return;
                pItem = ((((sizeof(SrcItem)) &gt; ()) || ((sizeof(SrcItem) &amp; (sizeof(SrcItem) - 1)) != 0)) ? (SrcItem)((ap += ) - ) : (SrcItem)((ap += ) - ));
                if (((pItem.zAlias) != null) &amp;&amp; (flag_altform2 == 0))
                {
                    sqlite3_str_appendall(pAccum, pItem.zAlias);
                }
                else if ((pItem.zName) != null)
                {
                    if ((pItem.zDatabase) != null)
                    {
                        sqlite3_str_appendall(pAccum, pItem.zDatabase);
                        sqlite3_str_append(pAccum, ".", (int)(1));
                    }

                    sqlite3_str_appendall(pAccum, pItem.zName);
                }
                else if ((pItem.zAlias) != null)
                {
                    sqlite3_str_appendall(pAccum, pItem.zAlias);
                }
                else if ((pItem.pSelect) != null)
                {
                    sqlite3_str_appendf(pAccum, "SUBQUERY %u", (uint)(pItem.pSelect.selId));
                }

                length = (int)(width = (int)(0));
                break;
            }

            default:
            {
                return;
            }
        }

        width -= (int)(length);
        if ((width) &gt; (0))
        {
            if (flag_leftjustify == 0)
                sqlite3_str_appendchar(pAccum, (int)(width), (sbyte)(32));
            sqlite3_str_append(pAccum, bufpt, (int)(length));
            if ((flag_leftjustify) != 0)
                sqlite3_str_appendchar(pAccum, (int)(width), (sbyte)(32));
        }
        else
        {
            sqlite3_str_append(pAccum, bufpt, (int)(length));
        }

        if ((zExtra) != null)
        {
            sqlite3DbFree(pAccum.db, zExtra);
            zExtra = null;
        }
    }
}</function>
  <function>public static int sqlite3_strglob(sbyte* zGlobPattern, sbyte* zString)
{
    return (int)(patternCompare((byte*)(zGlobPattern), (byte*)(zString), &amp;globInfo, (uint)(91)));
}</function>
  <function>public static int sqlite3_stricmp(sbyte* zLeft, sbyte* zRight)
{
    if ((zLeft) == (null))
    {
        return (int)((zRight) != 0 ? -1 : 0);
    }
    else if ((zRight) == (null))
    {
        return (int)(1);
    }

    return (int)(sqlite3StrICmp(zLeft, zRight));
}</function>
  <function>public static int sqlite3_strlike(sbyte* zPattern, sbyte* zStr, uint esc)
{
    return (int)(patternCompare((byte*)(zPattern), (byte*)(zStr), &amp;likeInfoNorm, (uint)(esc)));
}</function>
  <function>public static int sqlite3_strnicmp(sbyte* zLeft, sbyte* zRight, int N)
{
    byte* a; byte  * b ; 
    if ((zLeft) == (null))
    {
        return (int)((zRight) != 0 ? -1 : 0);
    }
    else if ((zRight) == (null))
    {
        return (int)(1);
    }

    a = (byte*)(zLeft);
    b = (byte*)(zRight);
    while ((((N--) &gt; (0)) &amp;&amp; (*a != 0)) &amp;&amp; ((sqlite3UpperToLower[*a]) == (sqlite3UpperToLower[*b])))
    {
        a++;
        b++;
    }

    return (int)((N) &lt; (0) ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b]);
}</function>
  <function>public static int sqlite3_system_errno(sqlite3 db)
{
    return (int)(db ? db.iSysErrno : 0);
}</function>
  <function>public static int sqlite3_table_column_metadata(sqlite3 db, sbyte* zDbName, sbyte* zTableName, sbyte* zColumnName, sbyte** pzDataType, sbyte** pzCollSeq, int* pNotNull, int* pPrimaryKey, int* pAutoinc)
{
    int rc = 0;
    sbyte* zErrMsg = null;
    Table pTab = null;
    Column* pCol = null;
    int iCol = (int)(0);
    sbyte* zDataType = null;
    sbyte* zCollSeq = null;
    int notnull = (int)(0);
    int primarykey = (int)(0);
    int autoinc = (int)(0);
    sqlite3_mutex_enter(db.mutex);
    sqlite3BtreeEnterAll(db);
    rc = (int)(sqlite3Init(db, &amp;zErrMsg));
    if (0 != rc)
    {
        goto error_out;
    }

    pTab = sqlite3FindTable(db, zTableName, zDbName);
    if ((pTab == null) || (((pTab).eTabType) == (2)))
    {
        pTab = null;
        goto error_out;
    }

    if ((zColumnName) == (null))
    {
    }
    else
    {
        for (iCol = (int)(0); (iCol) &lt; (pTab.nCol); iCol++)
        {
            pCol = &amp;pTab.aCol[iCol];
            if ((0) == (sqlite3StrICmp(pCol-&gt;zCnName, zColumnName)))
            {
                break;
            }
        }

        if ((iCol) == (pTab.nCol))
        {
            if ((((pTab).tabFlags &amp; 0x00000080) == (0)) &amp;&amp; ((sqlite3IsRowid(zColumnName)) != 0))
            {
                iCol = (int)(pTab.iPKey);
                pCol = (iCol) &gt;= (0) ? &amp;pTab.aCol[iCol] : null;
            }
            else
            {
                pTab = null;
                goto error_out;
            }
        }
    }

    if ((pCol) != null)
    {
        zDataType = sqlite3ColumnType(pCol, null);
        zCollSeq = sqlite3ColumnColl(pCol);
        notnull = (int)(pCol-&gt;notNull != 0);
        primarykey = (int)((pCol-&gt;colFlags &amp; 0x0001) != 0);
        autoinc = (int)(((pTab.iPKey) == (iCol)) &amp;&amp; ((pTab.tabFlags &amp; 0x00000008) != 0) ? 1 : 0);
    }
    else
    {
        zDataType = "INTEGER";
        primarykey = (int)(1);
    }

    if (zCollSeq == null)
    {
        zCollSeq = sqlite3StrBINARY;
    }

    error_out:
        ; sqlite3BtreeLeaveAll ( db ) ; 
    if ((pzDataType) != null)
        *pzDataType = zDataType;
    if ((pzCollSeq) != null)
        *pzCollSeq = zCollSeq;
    if ((pNotNull) != null)
        *pNotNull = (int)(notnull);
    if ((pPrimaryKey) != null)
        *pPrimaryKey = (int)(primarykey);
    if ((pAutoinc) != null)
        *pAutoinc = (int)(autoinc);
    if (((0) == (rc)) &amp;&amp; (pTab == null))
    {
        sqlite3DbFree(db, zErrMsg);
        zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName, zColumnName);
        rc = (int)(1);
    }

    sqlite3ErrorWithMsg(db, (int)(rc), ((zErrMsg) != 0 ? "%s" : null), zErrMsg);
    sqlite3DbFree(db, zErrMsg);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_test_control(int op)
{
    int rc = (int)(0);
    sbyte* ap;
    (__va_start(&amp;ap, (int)(op)));
    switch (op)
    {
        case 5:
        {
            sqlite3PrngSaveState();
            break;
        }

        case 6:
        {
            sqlite3PrngRestoreState();
            break;
        }

        case 28:
        {
            int x = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            int y = 0;
            sqlite3 db = ((((sizeof(sqlite3)) &gt; ()) || ((sizeof(sqlite3) &amp; (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
            if (((db) != null) &amp;&amp; ((y = (int)(db.aDb[0].pSchema.schema_cookie)) != 0))
            {
                x = (int)(y);
            }

            sqlite3Config.iPrngSeed = (uint)(x);
            sqlite3_randomness((int)(0), null);
            break;
        }

        case 8:
        {
            int sz = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            int* aProg = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ));
            rc = (int)(sqlite3BitvecBuiltinTest((int)(sz), aProg));
            break;
        }

        case 9:
        {
            sqlite3Config.xTestCallback = ((((sizeof(Int(Int))) &gt; ()) || ((sizeof(Int(Int)) &amp; (sizeof(Int(Int)) - 1)) != 0 ) ) ?
            **(Int(Int))((ap += ) - ) : 
            *(Int(Int))((ap += ) - ) )
            ;
            rc = (int)(sqlite3FaultSim((int)(0)));
            break;
        }

        case 10:
        {
            delegate74 xBenignBegin;
            delegate74 xBenignEnd;
            xBenignBegin = ((((sizeof(Void())) &gt; ()) || ((sizeof(Void()) &amp; (sizeof(Void()) - 1)) != 0 ) ) ?
            **(Void())((ap += ) - ) : 
            *(Void())((ap += ) - ) )
            ;
            xBenignEnd = ((((sizeof(Void())) &gt; ()) || ((sizeof(Void()) &amp; (sizeof(Void()) - 1)) != 0 ) ) ?
            **(Void())((ap += ) - ) : 
            *(Void())((ap += ) - ) )
            ;
            sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
            break;
        }

        case 11:
        {
            rc = (int)(sqlite3PendingByte);
            {
                uint newVal = (uint)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
                if ((newVal) != 0)
                    sqlite3PendingByte = (int)(newVal);
            }

            break;
        }

        case 12:
        {
            int x = (int)(0);
            rc = (int)(x);
            break;
        }

        case 13:
        {
            int x = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            rc = (int)((x) != 0 ? (x) : 0);
            break;
        }

        case 22:
        {
            rc = (int)(1234 * 100 + 1 * 10 + 0);
            break;
        }

        case 15:
        {
            sqlite3 db = ((((sizeof(sqlite3)) &gt; ()) || ((sizeof(sqlite3) &amp; (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
            db.dbOptFlags = (uint)((((sizeof(uint)) &gt; ()) || ((sizeof(uint) &amp; (sizeof(uint) - 1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
            break;
        }

        case 18:
        {
            sqlite3Config.bLocaltimeFault = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            if ((sqlite3Config.bLocaltimeFault) == (2))
            {
                sqlite3Config.xAltLocaltime = ((((sizeof(Int(Void * , Void * ))) &gt; ()) || ((sizeof(Int(Void * , Void * )) &amp; (sizeof(Int(Void * , Void * )) - 1)) != 0 ) ) ?
                **(Int(Void * , Void * ))((ap += ) - ) : 
                *(Int(Void * , Void * ))((ap += ) - ) )
                ;
            }
            else
            {
                sqlite3Config.xAltLocaltime = null;
            }

            break;
        }

        case 17:
        {
            sqlite3 db = ((((sizeof(sqlite3)) &gt; ()) || ((sizeof(sqlite3) &amp; (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
            db.mDbFlags ^= (uint)(0x0020);
            break;
        }

        case 20:
        {
            sqlite3Config.neverCorrupt = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 29:
        {
            sqlite3Config.bExtraSchemaChecks = (byte)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 19:
        {
            sqlite3Config.iOnceResetThreshold = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 21:
        {
            break;
        }

        case 24:
        {
            sqlite3 db = ((((sizeof(sqlite3)) &gt; ()) || ((sizeof(sqlite3) &amp; (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
            db.nMaxSorterMmap = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            break;
        }

        case 23:
        {
            if ((sqlite3Config.isInit) == (0))
                rc = (int)(1);
            break;
        }

        case 25:
        {
            sqlite3 db = ((((sizeof(sqlite3)) &gt; ()) || ((sizeof(sqlite3) &amp; (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
            int iDb = 0;
            sqlite3_mutex_enter(db.mutex);
            iDb = (int)(sqlite3FindDbName(db, (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ))));
            if ((iDb) &gt;= (0))
            {
                db.init.iDb = (byte)(iDb);
                db.init.busy = (byte)(db.init.imposterTable = (uint)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )));
                db.init.newTnum = (uint)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
                if (((db.init.busy) == (0)) &amp;&amp; ((db.init.newTnum) &gt; (0)))
                {
                    sqlite3ResetAllSchemasOfConnection(db);
                }
            }

            sqlite3_mutex_leave(db.mutex);
            break;
        }

        case 27:
        {
            sqlite3_context pCtx = ((((sizeof(sqlite3_context)) &gt; ()) || ((sizeof(sqlite3_context) &amp; (sizeof(sqlite3_context) - 1)) != 0)) ? (sqlite3_context)((ap += ) - ) : (sqlite3_context)((ap += ) - ));
            sqlite3ResultIntReal(pCtx);
            break;
        }

        case 30:
        {
            sqlite3 db = ((((sizeof(sqlite3)) &gt; ()) || ((sizeof(sqlite3) &amp; (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
            ulong* pn = ((((sizeof(ulong)) &gt; ()) || ((sizeof(ulong) &amp; (sizeof(ulong) - 1)) != 0)) ? **(ulong***)((ap += ) - ) : *(ulong**)((ap += ) - ));
            *pn = (ulong)(0);
            (void)(db);
            break;
        }

        case 31:
        {
            int opTrace = (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
            uint* ptr = ((((sizeof(uint)) &gt; ()) || ((sizeof(uint) &amp; (sizeof(uint) - 1)) != 0)) ? **(uint***)((ap += ) - ) : *(uint**)((ap += ) - ));
            switch (opTrace)
            {
                case 0:
                    *ptr = (uint)(sqlite3SelectTrace);
                    break;
                case 1:
                    sqlite3SelectTrace = (uint)(*ptr);
                    break;
                case 2:
                    *ptr = (uint)(sqlite3WhereTrace);
                    break;
                case 3:
                    sqlite3WhereTrace = (uint)(*ptr);
                    break;
            }

            break;
        }

        case 33:
        {
            double rIn = (double)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(double**)((ap += ) - ) : *(double*)((ap += ) - ));
            short rLogEst = (short)(sqlite3LogEstFromDouble((double)(rIn)));
            ulong iInt = (ulong)(sqlite3LogEstToInt((short)(rLogEst)));
            (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ))[0] = (int)(rLogEst);
            ((((sizeof(ulong)) &gt; ()) || ((sizeof(ulong) &amp; (sizeof(ulong) - 1)) != 0)) ? **(ulong***)((ap += ) - ) : *(ulong**)((ap += ) - ))[0] = (ulong)(iInt);
            (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ))[0] = (int)(sqlite3LogEst((ulong)(iInt)));
            break;
        }
    }

    ((void)(ap = null));
    return (int)(rc);
}</function>
  <function>public static void sqlite3_thread_cleanup()
{
}</function>
  <function>public static int sqlite3_threadsafe()
{
    return (int)(1);
}</function>
  <function>public static int sqlite3_total_changes(sqlite3 db)
{
    return (int)(sqlite3_total_changes64(db));
}</function>
  <function>public static long sqlite3_total_changes64(sqlite3 db)
{
    return (long)(db.nTotalChange);
}</function>
  <function>public static void* sqlite3_trace(sqlite3 db, delegate61 xTrace, void* pArg)
{
    void* pOld;
    sqlite3_mutex_enter(db.mutex);
    pOld = db.pTraceArg;
    db.mTrace = (byte)(xTrace ? 0x40 : 0);
    db.trace.xLegacy = xTrace;
    db.pTraceArg = pArg;
    sqlite3_mutex_leave(db.mutex);
    return pOld;
}</function>
  <function>public static int sqlite3_trace_v2(sqlite3 db, uint mTrace, delegate62 xTrace, void* pArg)
{
    sqlite3_mutex_enter(db.mutex);
    if ((mTrace) == (0))
        xTrace = null;
    if ((xTrace) == (null))
        mTrace = (uint)(0);
    db.mTrace = (byte)(mTrace);
    db.trace.xV2 = xTrace;
    db.pTraceArg = pArg;
    sqlite3_mutex_leave(db.mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_transfer_bindings(sqlite3_stmt* pFromStmt, sqlite3_stmt* pToStmt)
{
    Vdbe pFrom = (Vdbe)(pFromStmt);
    Vdbe pTo = (Vdbe)(pToStmt);
    if (pFrom.nVar != pTo.nVar)
    {
        return (int)(1);
    }

    if ((pTo.expmask) != 0)
    {
        pTo.expired = (uint)(1);
    }

    if ((pFrom.expmask) != 0)
    {
        pFrom.expired = (uint)(1);
    }

    return (int)(sqlite3TransferBindings(pFromStmt, pToStmt));
}</function>
  <function>public static int sqlite3_txn_state(sqlite3 db, sbyte* zSchema)
{
    int iDb = 0; int  nDb  =  0 ; 
    int iTxn = (int)(-1);
    sqlite3_mutex_enter(db.mutex);
    if ((zSchema) != null)
    {
        nDb = (int)(iDb = (int)(sqlite3FindDbName(db, zSchema)));
        if ((iDb) &lt; (0))
            nDb--;
    }
    else
    {
        iDb = (int)(0);
        nDb = (int)(db.nDb - 1);
    }

    for (; (iDb) &lt;= (nDb); iDb++)
    {
        Btree pBt = db.aDb[iDb].pBt;
        int x = (int)(pBt != null ? sqlite3BtreeTxnState(pBt) : 0);
        if ((x) &gt; (iTxn))
            iTxn = (int)(x);
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(iTxn);
}</function>
  <function>public static void* sqlite3_update_hook(sqlite3 db, delegate64 xCallback, void* pArg)
{
    void* pRet;
    sqlite3_mutex_enter(db.mutex);
    pRet = db.pUpdateArg;
    db.xUpdateCallback = xCallback;
    db.pUpdateArg = pArg;
    sqlite3_mutex_leave(db.mutex);
    return pRet;
}</function>
  <function>public static int sqlite3_uri_boolean(sbyte* zFilename, sbyte* zParam, int bDflt)
{
    sbyte* z = sqlite3_uri_parameter(zFilename, zParam);
    bDflt = (int)(bDflt != 0);
    return (int)((z) != 0 ? sqlite3GetBoolean(z, (byte)(bDflt)) : bDflt);
}</function>
  <function>public static long sqlite3_uri_int64(sbyte* zFilename, sbyte* zParam, long bDflt)
{
    sbyte* z = sqlite3_uri_parameter(zFilename, zParam);
    long v = 0;
    if (((z) != null) &amp;&amp; ((sqlite3DecOrHexToI64(z, &amp;v)) == (0)))
    {
        bDflt = (long)(v);
    }

    return (long)(bDflt);
}</function>
  <function>public static sbyte* sqlite3_uri_key(sbyte* zFilename, int N)
{
    if (((zFilename) == (null)) || ((N) &lt; (0)))
        return null;
    zFilename = databaseName(zFilename);
    zFilename += sqlite3Strlen30(zFilename) + 1;
    while ((((zFilename) != null) &amp;&amp; ((zFilename[0]) != 0)) &amp;&amp; ((N--) &gt; (0)))
    {
        zFilename += sqlite3Strlen30(zFilename) + 1;
        zFilename += sqlite3Strlen30(zFilename) + 1;
    }

    return (zFilename[0]) != 0 ? zFilename : null;
}</function>
  <function>public static sbyte* sqlite3_uri_parameter(sbyte* zFilename, sbyte* zParam)
{
    if (((zFilename) == (null)) || ((zParam) == (null)))
        return null;
    zFilename = databaseName(zFilename);
    return uriParameter(zFilename, zParam);
}</function>
  <function>public static void* sqlite3_user_data(sqlite3_context p)
{
    return p.pFunc.pUserData;
}</function>
  <function>public static void* sqlite3_value_blob(sqlite3_value pVal)
{
    sqlite3_value p = pVal;
    if ((p.flags &amp; (0x0010 | 0x0002)) != 0)
    {
        if ((((p).flags &amp; 0x4000) ? sqlite3VdbeMemExpandBlob(p) : 0) != 0)
        {
            return null;
        }

        p.flags |= (ushort)(0x0010);
        return (p.n) != 0 ? p.z : null;
    }
    else
    {
        return sqlite3_value_text(pVal);
    }
}</function>
  <function>public static int sqlite3_value_bytes(sqlite3_value pVal)
{
    return (int)(sqlite3ValueBytes(pVal, (byte)(1)));
}</function>
  <function>public static int sqlite3_value_bytes16(sqlite3_value pVal)
{
    return (int)(sqlite3ValueBytes(pVal, (byte)(2)));
}</function>
  <function>public static double sqlite3_value_double(sqlite3_value pVal)
{
    return (double)(sqlite3VdbeRealValue(pVal));
}</function>
  <function>public static sqlite3_value sqlite3_value_dup(sqlite3_value pOrig)
{
    sqlite3_value pNew;
    if ((pOrig) == (null))
        return null;
    pNew = sqlite3_malloc((int)(sizeof(sqlite3_value)));
    if ((pNew) == (null))
        return null;
    CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(sqlite3_value)));
    CRuntime.memcpy(pNew, pOrig, ((ulong)(&amp;((0).zMalloc))));
    pNew.flags &amp;= (ushort)(~0x0400);
    pNew.db = null;
    if ((pNew.flags &amp; (0x0002 | 0x0010)) != 0)
    {
        pNew.flags &amp;= (ushort)(~(0x0800 | 0x0400));
        pNew.flags |= (ushort)(0x1000);
        if (sqlite3VdbeMemMakeWriteable(pNew) != 0)
        {
            sqlite3ValueFree(pNew);
            pNew = null;
        }
    }

    return pNew;
}</function>
  <function>public static void sqlite3_value_free(sqlite3_value pOld)
{
    sqlite3ValueFree(pOld);
}</function>
  <function>public static int sqlite3_value_frombind(sqlite3_value pVal)
{
    return (int)((pVal.flags &amp; 0x0040) != 0);
}</function>
  <function>public static int sqlite3_value_int(sqlite3_value pVal)
{
    return (int)(sqlite3VdbeIntValue(pVal));
}</function>
  <function>public static long sqlite3_value_int64(sqlite3_value pVal)
{
    return (long)(sqlite3VdbeIntValue(pVal));
}</function>
  <function>public static int sqlite3_value_nochange(sqlite3_value pVal)
{
    return ((pVal.flags &amp; (0x0001 | 0x4000)) == (0x0001 | 0x4000) ? 1 : 0);
}</function>
  <function>public static int sqlite3_value_numeric_type(sqlite3_value pVal)
{
    int eType = (int)(sqlite3_value_type(pVal));
    if ((eType) == (3))
    {
        sqlite3_value pMem = pVal;
        applyNumericAffinity(pMem, (int)(0));
        eType = (int)(sqlite3_value_type(pVal));
    }

    return (int)(eType);
}</function>
  <function>public static void* sqlite3_value_pointer(sqlite3_value pVal, sbyte* zPType)
{
    sqlite3_value p = pVal;
    if (((((p.flags &amp; (0xc1bf | 0x0200 | 0x8000)) == (0x0001 | 0x0200 | 0x8000)) &amp;&amp; (zPType != null)) &amp;&amp; ((p.eSubtype) == (112))) &amp;&amp; ((CRuntime.strcmp(p.u.zPType, zPType)) == (0)))
    {
        return (void*)(p.z);
    }
    else
    {
        return null;
    }
}</function>
  <function>public static uint sqlite3_value_subtype(sqlite3_value pVal)
{
    sqlite3_value pMem = pVal;
    return (uint)((pMem.flags &amp; 0x8000) ? pMem.eSubtype : 0);
}</function>
  <function>public static byte* sqlite3_value_text(sqlite3_value pVal)
{
    return (byte*)(sqlite3ValueText(pVal, (byte)(1)));
}</function>
  <function>public static void* sqlite3_value_text16(sqlite3_value pVal)
{
    return sqlite3ValueText(pVal, (byte)(2));
}</function>
  <function>public static void* sqlite3_value_text16be(sqlite3_value pVal)
{
    return sqlite3ValueText(pVal, (byte)(3));
}</function>
  <function>public static void* sqlite3_value_text16le(sqlite3_value pVal)
{
    return sqlite3ValueText(pVal, (byte)(2));
}</function>
  <function>public static int sqlite3_value_type(sqlite3_value pVal)
{
    return (int)(sqlite3_value_type_aType[pVal.flags &amp; 0x003f]);
}</function>
  <function>public static sqlite3_vfs sqlite3_vfs_find(sbyte* zVfs)
{
    sqlite3_vfs pVfs = null;
    sqlite3_mutex* mutex;
    int rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return null;
    mutex = sqlite3MutexAlloc((int)(2));
    sqlite3_mutex_enter(mutex);
    for (pVfs = vfsList; pVfs; pVfs = pVfs.pNext)
    {
        if ((zVfs) == (null))
            break;
        if ((CRuntime.strcmp(zVfs, pVfs.zName)) == (0))
            break;
    }

    sqlite3_mutex_leave(mutex);
    return pVfs;
}</function>
  <function>public static int sqlite3_vfs_register(sqlite3_vfs pVfs, int makeDflt)
{
    sqlite3_mutex* mutex;
    int rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (int)(rc);
    mutex = sqlite3MutexAlloc((int)(2));
    sqlite3_mutex_enter(mutex);
    vfsUnlink(pVfs);
    if (((makeDflt) != 0) || ((vfsList) == (null)))
    {
        pVfs.pNext = vfsList;
        vfsList = pVfs;
    }
    else
    {
        pVfs.pNext = vfsList.pNext;
        vfsList.pNext = pVfs;
    }

    sqlite3_mutex_leave(mutex);
    return (int)(0);
}</function>
  <function>public static int sqlite3_vfs_unregister(sqlite3_vfs pVfs)
{
    sqlite3_mutex* mutex;
    int rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (int)(rc);
    mutex = sqlite3MutexAlloc((int)(2));
    sqlite3_mutex_enter(mutex);
    vfsUnlink(pVfs);
    sqlite3_mutex_leave(mutex);
    return (int)(0);
}</function>
  <function>public static sbyte* sqlite3_vmprintf(sbyte* zFormat, sbyte* ap)
{
    sbyte* z;
    sbyte* zBase = stackalloc sbyte[70];
    sqlite3_str acc = new sqlite3_str();
    if ((sqlite3_initialize()) != 0)
        return null;
    sqlite3StrAccumInit(acc, null, zBase, (int)(70 * sizeof(sbyte)), (int)(1000000000));
    sqlite3_str_vappendf(acc, zFormat, ap);
    z = sqlite3StrAccumFinish(acc);
    return z;
}</function>
  <function>public static sbyte* sqlite3_vsnprintf(int n, sbyte* zBuf, sbyte* zFormat, sbyte* ap)
{
    sqlite3_str acc = new sqlite3_str();
    if ((n) &lt;= (0))
        return zBuf;
    sqlite3StrAccumInit(acc, null, zBuf, (int)(n), (int)(0));
    sqlite3_str_vappendf(acc, zFormat, ap);
    zBuf[acc.nChar] = (sbyte)(0);
    return zBuf;
}</function>
  <function>public static sbyte* sqlite3_vtab_collation(sqlite3_index_info* pIdxInfo, int iCons)
{
    HiddenIndexInfo pHidden = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    sbyte* zRet = null;
    if (((iCons) &gt;= (0)) &amp;&amp; ((iCons) &lt; (pIdxInfo-&gt;nConstraint)))
    {
        CollSeq pC = null;
        int iTerm = (int)(pIdxInfo-&gt;aConstraint[iCons].iTermOffset);
        Expr pX = pHidden.pWC.a[iTerm].pExpr;
        if ((pX.pLeft) != null)
        {
            pC = sqlite3ExprCompareCollSeq(pHidden.pParse, pX);
        }

        zRet = (pC ? pC.zName : sqlite3StrBINARY);
    }

    return zRet;
}</function>
  <function>public static int sqlite3_vtab_config(sqlite3 db, int op)
{
    sbyte* ap;
    int rc = (int)(0);
    VtabCtx p;
    sqlite3_mutex_enter(db.mutex);
    p = db.pVtabCtx;
    if (p == null)
    {
        rc = (int)(sqlite3MisuseError((int)(146796)));
    }
    else
    {
        (__va_start(&amp;ap, (int)(op)));
        switch (op)
        {
            case 1:
            {
                p.pVTable.bConstraint = ((byte)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )));
                break;
            }

            case 2:
            {
                p.pVTable.eVtabRisk = (byte)(0);
                break;
            }

            case 3:
            {
                p.pVTable.eVtabRisk = (byte)(2);
                break;
            }

            default:
            {
                rc = (int)(sqlite3MisuseError((int)(146814)));
                break;
            }
        }

        ((void)(ap = null));
    }

    if (rc != 0)
        sqlite3Error(db, (int)(rc));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_vtab_distinct(sqlite3_index_info* pIdxInfo)
{
    HiddenIndexInfo pHidden = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    return (int)(pHidden.eDistinct);
}</function>
  <function>public static int sqlite3_vtab_in(sqlite3_index_info* pIdxInfo, int iCons, int bHandle)
{
    HiddenIndexInfo pHidden = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    uint m = (uint)((iCons) &lt;= (31) ? ((uint)(1)) &lt;&lt; (iCons) : 0);
    if ((m &amp; pHidden.mIn) != 0)
    {
        if ((bHandle) == (0))
        {
            pHidden.mHandleIn &amp;= (uint)(~m);
        }
        else if ((bHandle) &gt; (0))
        {
            pHidden.mHandleIn |= (uint)(m);
        }

        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3_vtab_in_first(sqlite3_value pVal, sqlite3_value ppOut)
{
    return (int)(valueFromValueList(pVal, ppOut, (int)(0)));
}</function>
  <function>public static int sqlite3_vtab_in_next(sqlite3_value pVal, sqlite3_value ppOut)
{
    return (int)(valueFromValueList(pVal, ppOut, (int)(1)));
}</function>
  <function>public static int sqlite3_vtab_nochange(sqlite3_context p)
{
    return (int)(sqlite3_value_nochange(p.pOut));
}</function>
  <function>public static int sqlite3_vtab_on_conflict(sqlite3 db)
{
    return (int)(sqlite3_vtab_on_conflict_aMap[db.vtabOnConflict - 1]);
}</function>
  <function>public static int sqlite3_vtab_rhs_value(sqlite3_index_info* pIdxInfo, int iCons, sqlite3_value ppVal)
{
    HiddenIndexInfo pH = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    sqlite3_value pVal = null;
    int rc = (int)(0);
    if (((iCons) &lt; (0)) || ((iCons) &gt;= (pIdxInfo-&gt;nConstraint)))
    {
        rc = (int)(21);
    }
    else
    {
        if ((pH.aRhs[iCons]) == (null))
        {
            WhereTerm pTerm = pH.pWC.a[pIdxInfo-&gt;aConstraint[iCons].iTermOffset];
            rc = (int)(sqlite3ValueFromExpr(pH.pParse.db, pTerm.pExpr.pRight, (byte)((pH.pParse.db).enc), (byte)(0x41), pH.aRhs[iCons]));
        }

        pVal = pH.aRhs[iCons];
    }

    ppVal = pVal;
    if (((rc) == (0)) &amp;&amp; ((pVal) == (null)))
    {
        rc = (int)(12);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3_wal_autocheckpoint(sqlite3 db, int nFrame)
{
    if ((nFrame) &gt; (0))
    {
        sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void*)((long)(nFrame))));
    }
    else
    {
        sqlite3_wal_hook(db, null, null);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3_wal_checkpoint(sqlite3 db, sbyte* zDb)
{
    return (int)(sqlite3_wal_checkpoint_v2(db, zDb, (int)(0), null, null));
}</function>
  <function>public static int sqlite3_wal_checkpoint_v2(sqlite3 db, sbyte* zDb, int eMode, int* pnLog, int* pnCkpt)
{
    int rc = 0;
    int iDb = 0;
    if ((pnLog) != null)
        *pnLog = (int)(-1);
    if ((pnCkpt) != null)
        *pnCkpt = (int)(-1);
    if (((eMode) &lt; (0)) || ((eMode) &gt; (3)))
    {
        return (int)(21);
    }

    sqlite3_mutex_enter(db.mutex);
    if (((zDb) != null) &amp;&amp; ((zDb[0]) != 0))
    {
        iDb = (int)(sqlite3FindDbName(db, zDb));
    }
    else
    {
        iDb = (int)(10 + 2);
    }

    if ((iDb) &lt; (0))
    {
        rc = (int)(1);
        sqlite3ErrorWithMsg(db, (int)(1), "unknown database: %s", zDb);
    }
    else
    {
        db.busyHandler.nBusy = (int)(0);
        rc = (int)(sqlite3Checkpoint(db, (int)(iDb), (int)(eMode), pnLog, pnCkpt));
        sqlite3Error(db, (int)(rc));
    }

    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    if ((db.nVdbeActive) == (0))
    {
        (0);
    }

    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static void* sqlite3_wal_hook(sqlite3 db, delegate54 xCallback, void* pArg)
{
    void* pRet;
    sqlite3_mutex_enter(db.mutex);
    pRet = db.pWalArg;
    db.xWalCallback = xCallback;
    db.pWalArg = pArg;
    sqlite3_mutex_leave(db.mutex);
    return pRet;
}</function>
  <function>public static int sqlite3_win32_is_nt()
{
    return (int)(1);
}</function>
  <function>public static sbyte* sqlite3_win32_mbcs_to_utf8(sbyte* zText)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return winMbcsToUtf8(zText, (int)((Int())(aSyscall[0].pCurrent)()));
}</function>
  <function>public static sbyte* sqlite3_win32_mbcs_to_utf8_v2(sbyte* zText, int useAnsi)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return winMbcsToUtf8(zText, (int)(useAnsi));
}</function>
  <function>public static int sqlite3_win32_set_directory(uint type, void* zValue)
{
    return (int)(sqlite3_win32_set_directory16((uint)(type), zValue));
}</function>
  <function>public static int sqlite3_win32_set_directory16(uint type, void* zValue)
{
    int rc = 0;
    sbyte* zUtf8 = null;
    if ((zValue) != null)
    {
        zUtf8 = sqlite3_win32_unicode_to_utf8(zValue);
        if ((zUtf8) == (null))
            return (int)(7);
    }

    rc = (int)(sqlite3_win32_set_directory8((uint)(type), zUtf8));
    if ((zUtf8) != null)
        sqlite3_free(zUtf8);
    return (int)(rc);
}</function>
  <function>public static int sqlite3_win32_set_directory8(uint type, sbyte* zValue)
{
    sbyte** ppDirectory = null;
    int rc = (int)(sqlite3_initialize());
    if ((rc) != 0)
        return (int)(rc);
    if ((type) == (1))
    {
        ppDirectory = &amp;sqlite3_data_directory;
    }
    else if ((type) == (2))
    {
        ppDirectory = &amp;sqlite3_temp_directory;
    }

    if ((ppDirectory) != null)
    {
        sbyte* zCopy = null;
        if (((zValue) != null) &amp;&amp; ((zValue[0]) != 0))
        {
            zCopy = sqlite3_mprintf("%s", zValue);
            if ((zCopy) == (null))
            {
                return (int)(7);
            }
        }

        sqlite3_free(*ppDirectory);
        *ppDirectory = zCopy;
        return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static void sqlite3_win32_sleep(uint milliseconds)
{
    (Void(Uint))(aSyscall[55].pCurrent)((uint)(milliseconds));
}</function>
  <function>public static sbyte* sqlite3_win32_unicode_to_utf8(ushort* zWideText)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return winUnicodeToUtf8(zWideText);
}</function>
  <function>public static sbyte* sqlite3_win32_utf8_to_mbcs(sbyte* zText)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return winUtf8ToMbcs(zText, (int)((Int())(aSyscall[0].pCurrent)()));
}</function>
  <function>public static sbyte* sqlite3_win32_utf8_to_mbcs_v2(sbyte* zText, int useAnsi)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return winUtf8ToMbcs(zText, (int)(useAnsi));
}</function>
  <function>public static ushort* sqlite3_win32_utf8_to_unicode(sbyte* zText)
{
    if ((sqlite3_initialize()) != 0)
        return null;
    return winUtf8ToUnicode(zText);
}</function>
  <function>public static void sqlite3_win32_write_debug(sbyte* zBuf, int nBuf)
{
    sbyte* zDbgBuf = stackalloc sbyte[4092];
    int nMin = (int)((nBuf) &lt; (((int)(4096 - sizeof(uint))) - 1) ? (nBuf) : (((int)(4096 - sizeof(uint))) - 1));
    if ((nMin) &lt; (-1))
        nMin = (int)(-1);
    if ((nMin) &gt; (0))
    {
        CRuntime.memset(zDbgBuf, (int)(0), (ulong)((int)(4096 - sizeof(uint))));
        CRuntime.memcpy(zDbgBuf, zBuf, (ulong)(nMin));
        (Void(Sbyte * ))(aSyscall[72].pCurrent)(zDbgBuf);
    }
    else
    {
        (Void(Sbyte * ))(aSyscall[72].pCurrent)(zBuf);
    }
}</function>
  <function>public static int sqlite3AbsInt32(int x)
{
    if ((x) &gt;= (0))
        return (int)(x);
    if ((x) == ((int)(0x80000000)))
        return (int)(0x7fffffff);
    return (int)(-x);
}</function>
  <function>public static void sqlite3AddCheckConstraint(Parse pParse, Expr pCheckExpr, sbyte* zStart, sbyte* zEnd)
{
    Table pTab = pParse.pNewTable;
    sqlite3 db = pParse.db;
    if ((((pTab) != null) &amp;&amp; (!((pParse.eParseMode) == (1)))) &amp;&amp; (sqlite3BtreeIsReadonly(db.aDb[db.init.iDb].pBt) == 0))
    {
        pTab.pCheck = sqlite3ExprListAppend(pParse, pTab.pCheck, pCheckExpr);
        if ((pParse.constraintName.n) != 0)
        {
            sqlite3ExprListSetName(pParse, pTab.pCheck, &amp;pParse.constraintName, (int)(1));
        }
        else
        {
            Token t = new Token();
            for (zStart++; (sqlite3CtypeMap[(byte)(zStart[0])] &amp; 0x01); zStart++)
            {
            }

            while ((sqlite3CtypeMap[(byte)(zEnd[-1])] &amp; 0x01) != 0)
            {
                zEnd--;
            }

            t.z = zStart;
            t.n = (uint)((int)(zEnd - t.z));
            sqlite3ExprListSetName(pParse, pTab.pCheck, &amp;t, (int)(1));
        }
    }
    else
    {
        sqlite3ExprDelete(pParse.db, pCheckExpr);
    }
}</function>
  <function>public static void sqlite3AddCollateType(Parse pParse, Token* pToken)
{
    Table p;
    int i = 0;
    sbyte* zColl;
    sqlite3 db;
    if (((p = pParse.pNewTable) == (null)) || ((pParse.eParseMode) &gt;= (2)))
        return;
    i = (int)(p.nCol - 1);
    db = pParse.db;
    zColl = sqlite3NameFromToken(db, pToken);
    if (zColl == null)
        return;
    if ((sqlite3LocateCollSeq(pParse, zColl)) != null)
    {
        Index pIdx;
        sqlite3ColumnSetColl(db, &amp;p.aCol[i], zColl);
        for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            if ((pIdx.aiColumn[0]) == (i))
            {
                pIdx.azColl[0] = sqlite3ColumnColl(&amp;p.aCol[i]);
            }
        }
    }

    sqlite3DbFree(db, zColl);
}</function>
  <function>public static void sqlite3AddColumn(Parse pParse, Token sName, Token sType)
{
    Table p;
    int i = 0;
    sbyte* z;
    sbyte* zType;
    Column* pCol;
    sqlite3 db = pParse.db;
    byte hName = 0;
    Column* aNew;
    byte eType = (byte)(0);
    byte szEst = (byte)(1);
    sbyte affinity = (sbyte)(0x41);
    if ((p = pParse.pNewTable) == (null))
        return;
    if ((p.nCol + 1) &gt; (db.aLimit[2]))
    {
        sqlite3ErrorMsg(pParse, "too many columns on %s", p.zName);
        return;
    }

    if (!((pParse.eParseMode) &gt;= (2)))
        sqlite3DequoteToken(&amp;sName);
    if (((sType.n) &gt;= (16)) &amp;&amp; ((sqlite3_strnicmp(sType.z + (sType.n - 6), "always", (int)(6))) == (0)))
    {
        sType.n -= (uint)(6);
        while (((sType.n) &gt; (0)) &amp;&amp; ((sqlite3CtypeMap[(byte)(sType.z[sType.n - 1])] &amp; 0x01) != 0))
        {
            sType.n--;
        }

        if (((sType.n) &gt;= (9)) &amp;&amp; ((sqlite3_strnicmp(sType.z + (sType.n - 9), "generated", (int)(9))) == (0)))
        {
            sType.n -= (uint)(9);
            while (((sType.n) &gt; (0)) &amp;&amp; ((sqlite3CtypeMap[(byte)(sType.z[sType.n - 1])] &amp; 0x01) != 0))
            {
                sType.n--;
            }
        }
    }

    if ((sType.n) &gt;= (3))
    {
        sqlite3DequoteToken(&amp;sType);
        for (i = (int)(0); (i) &lt; (6); i++)
        {
            if (((sType.n) == (sqlite3StdTypeLen[i])) &amp;&amp; ((sqlite3_strnicmp(sType.z, sqlite3StdType[i], (int)(sType.n))) == (0)))
            {
                sType.n = (uint)(0);
                eType = (byte)(i + 1);
                affinity = (sbyte)(sqlite3StdTypeAffinity[i]);
                if ((affinity) &lt;= (0x42))
                    szEst = (byte)(5);
                break;
            }
        }
    }

    z = sqlite3DbMallocRaw(db, (ulong)((long)(sName.n) + 1 + (long)(sType.n) + ((sType.n) &gt; (0))));
    if ((z) == (null))
        return;
    if (((pParse.eParseMode) &gt;= (2)))
        sqlite3RenameTokenMap(pParse, (void*)(z), &amp;sName);
    CRuntime.memcpy(z, sName.z, (ulong)(sName.n));
    z[sName.n] = (sbyte)(0);
    sqlite3Dequote(z);
    hName = (byte)(sqlite3StrIHash(z));
    for (i = (int)(0); (i) &lt; (p.nCol); i++)
    {
        if (((p.aCol[i].hName) == (hName)) &amp;&amp; ((sqlite3StrICmp(z, p.aCol[i].zCnName)) == (0)))
        {
            sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
            sqlite3DbFree(db, z);
            return;
        }
    }

    aNew = sqlite3DbRealloc(db, p.aCol, (ulong)(((long)(p.nCol) + 1) * sizeof(Column)));
    if ((aNew) == (null))
    {
        sqlite3DbFree(db, z);
        return;
    }

    p.aCol = aNew;
    pCol = &amp;p.aCol[p.nCol];
    CRuntime.memset(pCol, (int)(0), (ulong)(sizeof(Column)));
    pCol-&gt;zCnName = z;
    pCol-&gt;hName = (byte)(hName);
    if ((sType.n) == (0))
    {
        pCol-&gt;affinity = (sbyte)(affinity);
        pCol-&gt;eCType = (uint)(eType);
        pCol-&gt;szEst = (byte)(szEst);
    }
    else
    {
        zType = z + sqlite3Strlen30(z) + 1;
        CRuntime.memcpy(zType, sType.z, (ulong)(sType.n));
        zType[sType.n] = (sbyte)(0);
        sqlite3Dequote(zType);
        pCol-&gt;affinity = (sbyte)(sqlite3AffinityType(zType, pCol));
        pCol-&gt;colFlags |= (ushort)(0x0004);
    }

    p.nCol++;
    p.nNVCol++;
    pParse.constraintName.n = (uint)(0);
}</function>
  <function>public static void sqlite3AddDefaultValue(Parse pParse, Expr pExpr, sbyte* zStart, sbyte* zEnd)
{
    Table p;
    Column* pCol;
    sqlite3 db = pParse.db;
    p = pParse.pNewTable;
    if (p != null)
    {
        int isInit = (int)(((db.init.busy) != 0) &amp;&amp; (db.init.iDb != 1) ? 1 : 0);
        pCol = &amp;(p.aCol[p.nCol - 1]);
        if (sqlite3ExprIsConstantOrFunction(pExpr, (byte)(isInit)) == 0)
        {
            sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", pCol-&gt;zCnName);
        }
        else if ((pCol-&gt;colFlags &amp; 0x0060) != 0)
        {
            sqlite3ErrorMsg(pParse, "cannot use DEFAULT on a generated column");
        }
        else
        {
            Expr x = new Expr();
            Expr pDfltExpr;
            CRuntime.memset(x, (int)(0), (ulong)(sizeof(Expr)));
            x.op = (byte)(181);
            x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
            x.pLeft = pExpr;
            x.flags = (uint)(0x001000);
            pDfltExpr = sqlite3ExprDup(db, x, (int)(0x0001));
            sqlite3DbFree(db, x.u.zToken);
            sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr);
        }
    }

    if (((pParse.eParseMode) &gt;= (2)))
    {
        sqlite3RenameExprUnmap(pParse, pExpr);
    }

    sqlite3ExprDelete(db, pExpr);
}</function>
  <function>public static void sqlite3AddGenerated(Parse pParse, Expr pExpr, Token* pType)
{
    byte eType = (byte)(0x0020);
    Table pTab = pParse.pNewTable;
    Column* pCol;
    if ((pTab) == (null))
    {
        goto generated_done;
    }

    pCol = &amp;(pTab.aCol[pTab.nCol - 1]);
    if (((pParse.eParseMode) == (1)))
    {
        sqlite3ErrorMsg(pParse, "virtual tables cannot use computed columns");
        goto generated_done;
    }

    if ((pCol-&gt;iDflt) &gt; (0))
        goto generated_error;
    if ((pType) != null)
    {
        if (((pType-&gt;n) == (7)) &amp;&amp; ((sqlite3_strnicmp("virtual", pType-&gt;z, (int)(7))) == (0)))
        {
        }
        else if (((pType-&gt;n) == (6)) &amp;&amp; ((sqlite3_strnicmp("stored", pType-&gt;z, (int)(6))) == (0)))
        {
            eType = (byte)(0x0040);
        }
        else
        {
            goto generated_error;
        }
    }

    if ((eType) == (0x0020))
        pTab.nNVCol--;
    pCol-&gt;colFlags |= (ushort)(eType);
    pTab.tabFlags |= (uint)(eType);
    if ((pCol-&gt;colFlags &amp; 0x0001) != 0)
    {
        makeColumnPartOfPrimaryKey(pParse, pCol);
    }

    sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);
    pExpr = null;
    goto generated_done;
    generated_error:
        ; sqlite3ErrorMsg ( pParse ,  "error in generated column \"%s\"" ,  pCol -&gt; zCnName ) ; 
    generated_done:
        ; sqlite3ExprDelete ( pParse . db ,  pExpr ) ; 
}</function>
  <function>public static int sqlite3AddInt64(long* pA, long iB)
{
    long iA = (long)(*pA);
    if ((iB) &gt;= (0))
    {
        if (((iA) &gt; (0)) &amp;&amp; (((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) - iA) &lt; (iB)))
            return (int)(1);
    }
    else
    {
        if (((iA) &lt; (0)) &amp;&amp; ((-(iA + (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)))) &gt; (iB + 1)))
            return (int)(1);
    }

    *pA += (long)(iB);
    return (int)(0);
}</function>
  <function>public static void sqlite3AddNotNull(Parse pParse, int onError)
{
    Table p;
    Column* pCol;
    p = pParse.pNewTable;
    if (((p) == (null)) || ((p.nCol) &lt; (1)))
        return;
    pCol = &amp;p.aCol[p.nCol - 1];
    pCol-&gt;notNull = (uint)((byte)(onError));
    p.tabFlags |= (uint)(0x00000800);
    if ((pCol-&gt;colFlags &amp; 0x0008) != 0)
    {
        Index pIdx;
        for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            if ((pIdx.aiColumn[0]) == (p.nCol - 1))
            {
                pIdx.uniqNotNull = (uint)(1);
            }
        }
    }
}</function>
  <function>public static void sqlite3AddPrimaryKey(Parse pParse, ExprList pList, int onError, int autoInc, int sortOrder)
{
    Table pTab = pParse.pNewTable;
    Column* pCol = null;
    int iCol = (int)(-1); int  i  =  0 ; 
    int nTerm = 0;
    if ((pTab) == (null))
        goto primary_key_exit;
    if ((pTab.tabFlags &amp; 0x00000004) != 0)
    {
        sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", pTab.zName);
        goto primary_key_exit;
    }

    pTab.tabFlags |= (uint)(0x00000004);
    if ((pList) == (null))
    {
        iCol = (int)(pTab.nCol - 1);
        pCol = &amp;pTab.aCol[iCol];
        makeColumnPartOfPrimaryKey(pParse, pCol);
        nTerm = (int)(1);
    }
    else
    {
        nTerm = (int)(pList.nExpr);
        for (i = (int)(0); (i) &lt; (nTerm); i++)
        {
            Expr pCExpr = sqlite3ExprSkipCollate(pList.a[i].pExpr);
            sqlite3StringToId(pCExpr);
            if ((pCExpr.op) == (59))
            {
                sbyte* zCName;
                zCName = pCExpr.u.zToken;
                for (iCol = (int)(0); (iCol) &lt; (pTab.nCol); iCol++)
                {
                    if ((sqlite3StrICmp(zCName, pTab.aCol[iCol].zCnName)) == (0))
                    {
                        pCol = &amp;pTab.aCol[iCol];
                        makeColumnPartOfPrimaryKey(pParse, pCol);
                        break;
                    }
                }
            }
        }
    }

    if (((((nTerm) == (1)) &amp;&amp; ((pCol) != null)) &amp;&amp; ((pCol-&gt;eCType) == (4))) &amp;&amp; (sortOrder != 1))
    {
        if (((pParse.eParseMode) &gt;= (2)) &amp;&amp; ((pList) != null))
        {
            Expr pCExpr = sqlite3ExprSkipCollate(pList.a[0].pExpr);
            sqlite3RenameTokenRemap(pParse, &amp;pTab.iPKey, pCExpr);
        }

        pTab.iPKey = (short)(iCol);
        pTab.keyConf = ((byte)(onError));
        pTab.tabFlags |= (uint)(autoInc * 0x00000008);
        if ((pList) != null)
            pParse.iPkSortOrder = (byte)(pList.a[0].sortFlags);
        (void)(sqlite3HasExplicitNulls(pParse, pList));
    }
    else if ((autoInc) != 0)
    {
        sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY");
    }
    else
    {
        sqlite3CreateIndex(pParse, null, null, null, pList, (int)(onError), null, null, (int)(sortOrder), (int)(0), (byte)(2));
        pList = null;
    }

    primary_key_exit:
        ; sqlite3ExprListDelete ( pParse . db ,  pList ) ; 
    return;
}</function>
  <function>public static void sqlite3AddReturning(Parse pParse, ExprList pList)
{
    Returning pRet;
    Hash* pHash;
    sqlite3 db = pParse.db;
    if ((pParse.pNewTrigger) != null)
    {
        sqlite3ErrorMsg(pParse, "cannot use RETURNING in a trigger");
    }
    else
    {
    }

    pParse.bReturning = (byte)(1);
    pRet = sqlite3DbMallocZero(db, (ulong)(sizeof(Returning)));
    if ((pRet) == (null))
    {
        sqlite3ExprListDelete(db, pList);
        return;
    }

    pParse.u1.pReturning = pRet;
    pRet.pParse = pParse;
    pRet.pReturnEL = pList;
    sqlite3ParserAddCleanup(pParse, sqlite3DeleteReturning, pRet);
    if ((db.mallocFailed) != 0)
        return;
    pRet.retTrig.zName = "sqlite_returning";
    pRet.retTrig.op = (byte)(150);
    pRet.retTrig.tr_tm = (byte)(2);
    pRet.retTrig.bReturning = (byte)(1);
    pRet.retTrig.pSchema = db.aDb[1].pSchema;
    pRet.retTrig.pTabSchema = db.aDb[1].pSchema;
    pRet.retTrig.step_list = pRet.retTStep;
    pRet.retTStep.op = (byte)(150);
    pRet.retTStep.pTrig = pRet.retTrig;
    pRet.retTStep.pExprList = pList;
    pHash = &amp;(db.aDb[1].pSchema.trigHash);
    if ((sqlite3HashInsert(pHash, "sqlite_returning", pRet.retTrig)) == (pRet.retTrig))
    {
        sqlite3OomFault(db);
    }
}</function>
  <function>public static sbyte sqlite3AffinityType(sbyte* zIn, Column* pCol)
{
    uint h = (uint)(0);
    sbyte aff = (sbyte)(0x43);
    sbyte* zChar = null;
    while ((zIn[0]) != 0)
    {
        h = (uint)((h &lt;&lt; 8) + sqlite3UpperToLower[(*zIn) &amp; 0xff]);
        zIn++;
        if ((h) == ((99 &lt;&lt; 24) + (104 &lt;&lt; 16) + (97 &lt;&lt; 8) + 114))
        {
            aff = (sbyte)(0x42);
            zChar = zIn;
        }
        else if ((h) == ((99 &lt;&lt; 24) + (108 &lt;&lt; 16) + (111 &lt;&lt; 8) + 98))
        {
            aff = (sbyte)(0x42);
        }
        else if ((h) == ((116 &lt;&lt; 24) + (101 &lt;&lt; 16) + (120 &lt;&lt; 8) + 116))
        {
            aff = (sbyte)(0x42);
        }
        else if (((h) == ((98 &lt;&lt; 24) + (108 &lt;&lt; 16) + (111 &lt;&lt; 8) + 98)) &amp;&amp; (((aff) == (0x43)) || ((aff) == (0x45))))
        {
            aff = (sbyte)(0x41);
            if ((zIn[0]) == (40))
                zChar = zIn;
        }
        else if (((h) == ((114 &lt;&lt; 24) + (101 &lt;&lt; 16) + (97 &lt;&lt; 8) + 108)) &amp;&amp; ((aff) == (0x43)))
        {
            aff = (sbyte)(0x45);
        }
        else if (((h) == ((102 &lt;&lt; 24) + (108 &lt;&lt; 16) + (111 &lt;&lt; 8) + 97)) &amp;&amp; ((aff) == (0x43)))
        {
            aff = (sbyte)(0x45);
        }
        else if (((h) == ((100 &lt;&lt; 24) + (111 &lt;&lt; 16) + (117 &lt;&lt; 8) + 98)) &amp;&amp; ((aff) == (0x43)))
        {
            aff = (sbyte)(0x45);
        }
        else if ((h &amp; 0x00FFFFFF) == ((105 &lt;&lt; 16) + (110 &lt;&lt; 8) + 116))
        {
            aff = (sbyte)(0x44);
            break;
        }
    }

    if ((pCol) != null)
    {
        int v = (int)(0);
        if ((aff) &lt; (0x43))
        {
            if ((zChar) != null)
            {
                while ((zChar[0]) != 0)
                {
                    if ((sqlite3CtypeMap[(byte)(zChar[0])] &amp; 0x04) != 0)
                    {
                        sqlite3GetInt32(zChar, &amp;v);
                        break;
                    }

                    zChar++;
                }
            }
            else
            {
                v = (int)(16);
            }
        }

        v = (int)(v / 4 + 1);
        if ((v) &gt; (255))
            v = (int)(255);
        pCol-&gt;szEst = (byte)(v);
    }

    return (sbyte)(aff);
}</function>
  <function>public static void sqlite3AggInfoPersistWalkerInit(Walker pWalker, Parse pParse)
{
    CRuntime.memset(pWalker, (int)(0), (ulong)(sizeof(Walker)));
    pWalker.pParse = pParse;
    pWalker.xExprCallback = agginfoPersistExprCb;
    pWalker.xSelectCallback = sqlite3SelectWalkNoop;
}</function>
  <function>public static Index sqlite3AllocateIndexObject(sqlite3 db, short nCol, int nExtra, sbyte** ppExtra)
{
    Index p;
    int nByte = 0;
    nByte = (int)((((sizeof(Index)) + 7) &amp; ~7) + (((sizeof(char*) * nCol) + 7) &amp; ~7) + (((sizeof(short) * (nCol + 1) + sizeof(short) * nCol + sizeof(byte) * nCol) + 7) &amp; ~7));
    p = sqlite3DbMallocZero(db, (ulong)(nByte + nExtra));
    if ((p) != null)
    {
        sbyte* pExtra = ((sbyte*)(p)) + (((sizeof(Index)) + 7) &amp; ~7);
        p.azColl = (sbyte**)(pExtra);
        pExtra += (((sizeof(char*) * nCol) + 7) &amp; ~7);
        p.aiRowLogEst = (short*)(pExtra);
        pExtra += sizeof(short) * (nCol + 1);
        p.aiColumn = (short*)(pExtra);
        pExtra += sizeof(short) * nCol;
        p.aSortOrder = (byte*)(pExtra);
        p.nColumn = (ushort)(nCol);
        p.nKeyCol = (ushort)(nCol - 1);
        *ppExtra = ((sbyte*)(p)) + nByte;
    }

    return p;
}</function>
  <function>public static void sqlite3AlterBeginAddColumn(Parse pParse, SrcList pSrc)
{
    Table pNew;
    Table pTab;
    int iDb = 0;
    int i = 0;
    int nAlloc = 0;
    sqlite3 db = pParse.db;
    if ((db.mallocFailed) != 0)
        goto exit_begin_add_column;
    pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
    if (pTab == null)
        goto exit_begin_add_column;
    if ((((pTab).eTabType) == (1)))
    {
        sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
        goto exit_begin_add_column;
    }

    if ((((pTab).eTabType) == (2)))
    {
        sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
        goto exit_begin_add_column;
    }

    if (0 != isAlterableTable(pParse, pTab))
    {
        goto exit_begin_add_column;
    }

    sqlite3MayAbort(pParse);
    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    pNew = (Table)(sqlite3DbMallocZero(db, (ulong)(sizeof(Table))));
    if (pNew == null)
        goto exit_begin_add_column;
    pParse.pNewTable = pNew;
    pNew.nTabRef = (uint)(1);
    pNew.nCol = (short)(pTab.nCol);
    nAlloc = (int)((((pNew.nCol - 1) / 8) * 8) + 8);
    pNew.aCol = (Column*)(sqlite3DbMallocZero(db, (ulong)(sizeof(Column) * nAlloc)));
    pNew.zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab.zName);
    if ((pNew.aCol == null) || (pNew.zName == null))
    {
        goto exit_begin_add_column;
    }

    CRuntime.memcpy(pNew.aCol, pTab.aCol, (ulong)(sizeof(Column) * pNew.nCol));
    for (i = (int)(0); (i) &lt; (pNew.nCol); i++)
    {
        Column* pCol = &amp;pNew.aCol[i];
        pCol-&gt;zCnName = sqlite3DbStrDup(db, pCol-&gt;zCnName);
        pCol-&gt;hName = (byte)(sqlite3StrIHash(pCol-&gt;zCnName));
    }

    pNew.u.tab.pDfltList = sqlite3ExprListDup(db, pTab.u.tab.pDfltList, (int)(0));
    pNew.pSchema = db.aDb[iDb].pSchema;
    pNew.u.tab.addColOffset = (int)(pTab.u.tab.addColOffset);
    pNew.nTabRef = (uint)(1);
    exit_begin_add_column:
        ; sqlite3SrcListDelete ( db ,  pSrc ) ; 
    return;
}</function>
  <function>public static void sqlite3AlterDropColumn(Parse pParse, SrcList pSrc, Token* pName)
{
    sqlite3 db = pParse.db;
    Table pTab;
    int iDb = 0;
    sbyte* zDb;
    sbyte* zCol = null;
    int iCol = 0;
    if ((db.mallocFailed) != 0)
        goto exit_drop_column;
    pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
    if (pTab == null)
        goto exit_drop_column;
    if (0 != isAlterableTable(pParse, pTab))
        goto exit_drop_column;
    if (0 != isRealTable(pParse, pTab, (int)(1)))
        goto exit_drop_column;
    zCol = sqlite3NameFromToken(db, pName);
    if ((zCol) == (null))
    {
        goto exit_drop_column;
    }

    iCol = (int)(sqlite3ColumnIndex(pTab, zCol));
    if ((iCol) &lt; (0))
    {
        sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pName);
        goto exit_drop_column;
    }

    if ((pTab.aCol[iCol].colFlags &amp; (0x0001 | 0x0008)) != 0)
    {
        sqlite3ErrorMsg(pParse, "cannot drop %s column: \"%s\"", (pTab.aCol[iCol].colFlags &amp; 0x0001) ? "PRIMARY KEY" : "UNIQUE", zCol);
        goto exit_drop_column;
    }

    if ((pTab.nCol) &lt;= (1))
    {
        sqlite3ErrorMsg(pParse, "cannot drop column \"%s\": no other columns exist", zCol);
        goto exit_drop_column;
    }

    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    zDb = db.aDb[iDb].zDbSName;
    if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, zCol)) != 0)
    {
        goto exit_drop_column;
    }

    renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "", (int)(0));
    renameFixQuotes(pParse, zDb, ((iDb) == (1) ? 1 : 0));
    sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_drop_column(%d, sql, %d) WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)", zDb, (int)(iDb), (int)(iCol), pTab.zName);
    renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0002));
    renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "after drop column", (int)(1));
    if (((pParse.nErr) == (0)) &amp;&amp; ((pTab.aCol[iCol].colFlags &amp; 0x0020) == (0)))
    {
        int i = 0;
        int addr = 0;
        int reg = 0;
        int regRec = 0;
        Index pPk = null;
        int nField = (int)(0);
        int iCur = 0;
        Vdbe v = sqlite3GetVdbe(pParse);
        iCur = (int)(pParse.nTab++);
        sqlite3OpenTable(pParse, (int)(iCur), (int)(iDb), pTab, (int)(112));
        addr = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
        reg = (int)(++pParse.nMem);
        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(reg));
            pParse.nMem += (int)(pTab.nCol);
        }
        else
        {
            pPk = sqlite3PrimaryKeyIndex(pTab);
            pParse.nMem += (int)(pPk.nColumn);
            for (i = (int)(0); (i) &lt; (pPk.nKeyCol); i++)
            {
                sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(i), (int)(reg + i + 1));
            }

            nField = (int)(pPk.nKeyCol);
        }

        regRec = (int)(++pParse.nMem);
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            if ((i != iCol) &amp;&amp; ((pTab.aCol[i].colFlags &amp; 0x0020) == (0)))
            {
                int regOut = 0;
                if ((pPk) != null)
                {
                    int iPos = (int)(sqlite3TableColumnToIndex(pPk, (short)(i)));
                    int iColPos = (int)(sqlite3TableColumnToIndex(pPk, (short)(iCol)));
                    if ((iPos) &lt; (pPk.nKeyCol))
                        continue;
                    regOut = (int)(reg + 1 + iPos - ((iPos) &gt; (iColPos)));
                }
                else
                {
                    regOut = (int)(reg + 1 + nField);
                }

                if ((i) == (pTab.iPKey))
                {
                    sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regOut));
                }
                else
                {
                    sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(i), (int)(regOut));
                }

                nField++;
            }
        }

        if ((nField) == (0))
        {
            pParse.nMem++;
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(reg + 1));
            nField = (int)(1);
        }

        sqlite3VdbeAddOp3(v, (int)(96), (int)(reg + 1), (int)(nField), (int)(regRec));
        if ((pPk) != null)
        {
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iCur), (int)(regRec), (int)(reg + 1), (int)(pPk.nKeyCol));
        }
        else
        {
            sqlite3VdbeAddOp3(v, (int)(127), (int)(iCur), (int)(regRec), (int)(reg));
        }

        sqlite3VdbeChangeP5(v, (ushort)(0x02));
        sqlite3VdbeAddOp2(v, (int)(5), (int)(iCur), (int)(addr + 1));
        sqlite3VdbeJumpHere(v, (int)(addr));
    }

    exit_drop_column:
        ; sqlite3DbFree ( db ,  zCol ) ; 
    sqlite3SrcListDelete(db, pSrc);
}</function>
  <function>public static void sqlite3AlterFinishAddColumn(Parse pParse, Token* pColDef)
{
    Table pNew;
    Table pTab;
    int iDb = 0;
    sbyte* zDb;
    sbyte* zTab;
    sbyte* zCol;
    Column* pCol;
    Expr pDflt;
    sqlite3 db;
    Vdbe v;
    int r1 = 0;
    db = pParse.db;
    if ((pParse.nErr) != 0)
        return;
    pNew = pParse.pNewTable;
    iDb = (int)(sqlite3SchemaToIndex(db, pNew.pSchema));
    zDb = db.aDb[iDb].zDbSName;
    zTab = &amp;pNew.zName[16];
    pCol = &amp;pNew.aCol[pNew.nCol - 1];
    pDflt = sqlite3ColumnExpr(pNew, pCol);
    pTab = sqlite3FindTable(db, zTab, zDb);
    if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
    {
        return;
    }

    if ((pCol-&gt;colFlags &amp; 0x0001) != 0)
    {
        sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
        return;
    }

    if ((pNew.pIndex) != null)
    {
        sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
        return;
    }

    if ((pCol-&gt;colFlags &amp; 0x0060) == (0))
    {
        if (((pDflt) != null) &amp;&amp; ((pDflt.pLeft.op) == (121)))
        {
            pDflt = null;
        }

        if ((((db.flags &amp; 0x00004000) != 0) &amp;&amp; ((pNew.u.tab.pFKey) != null)) &amp;&amp; ((pDflt) != null))
        {
            sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a REFERENCES column with non-NULL default value");
        }

        if (((pCol-&gt;notNull) != 0) &amp;&amp; (pDflt == null))
        {
            sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a NOT NULL column with default value NULL");
        }

        if ((pDflt) != null)
        {
            sqlite3_value pVal = null;
            int rc = 0;
            rc = (int)(sqlite3ValueFromExpr(db, pDflt, (byte)(1), (byte)(0x41), pVal));
            if (rc != 0)
            {
                return;
            }

            if (pVal == null)
            {
                sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a column with non-constant default");
            }

            sqlite3ValueFree(pVal);
        }
    }
    else if ((pCol-&gt;colFlags &amp; 0x0040) != 0)
    {
        sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "cannot add a STORED column");
    }

    zCol = sqlite3DbStrNDup(db, pColDef-&gt;z, (ulong)(pColDef-&gt;n));
    if ((zCol) != null)
    {
        sbyte* zEnd = &amp;zCol[pColDef-&gt;n - 1];
        while (((zEnd) &gt; (zCol)) &amp;&amp; (((*zEnd) == (59)) || ((sqlite3CtypeMap[(byte)(*zEnd)] &amp; 0x01) != 0)))
        {
            *zEnd-- = (sbyte)(0);
        }

        sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = printf('%%.%ds, ',sql) || %Q || substr(sql,1+length(printf('%%.%ds',sql))) WHERE type = 'table' AND name = %Q", zDb, (int)(pNew.u.tab.addColOffset), zCol, (int)(pNew.u.tab.addColOffset), zTab);
        sqlite3DbFree(db, zCol);
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) != null)
    {
        r1 = (int)(sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp3(v, (int)(98), (int)(iDb), (int)(r1), (int)(2));
        sqlite3VdbeUsesBtree(v, (int)(iDb));
        sqlite3VdbeAddOp2(v, (int)(85), (int)(r1), (int)(-2));
        sqlite3VdbeAddOp2(v, (int)(49), (int)(r1), (int)(sqlite3VdbeCurrentAddr(v) + 2));
        sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(2), (int)(3));
        sqlite3ReleaseTempReg(pParse, (int)(r1));
        renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0003));
        if ((pNew.pCheck != null) || (((pCol-&gt;notNull) != 0) &amp;&amp; ((pCol-&gt;colFlags &amp; 0x0060) != 0)))
        {
            sqlite3NestedParse(pParse, "SELECT CASE WHEN quick_check GLOB 'CHECK*' THEN raise(ABORT,'CHECK constraint failed') ELSE raise(ABORT,'NOT NULL constraint failed') END  FROM pragma_quick_check(%Q,%Q) WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'", zTab, zDb);
        }
    }
}</function>
  <function>public static void sqlite3AlterFunctions()
{
    sqlite3InsertBuiltinFuncs(sqlite3AlterFunctions_aAlterTableFuncs, ((int)(5 * sizeof(FuncDef) / sizeof(FuncDef))));
}</function>
  <function>public static void sqlite3AlterRenameColumn(Parse pParse, SrcList pSrc, Token* pOld, Token* pNew)
{
    sqlite3 db = pParse.db;
    Table pTab;
    int iCol = 0;
    sbyte* zOld = null;
    sbyte* zNew = null;
    sbyte* zDb;
    int iSchema = 0;
    int bQuote = 0;
    pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
    if (pTab == null)
        goto exit_rename_column;
    if (0 != isAlterableTable(pParse, pTab))
        goto exit_rename_column;
    if (0 != isRealTable(pParse, pTab, (int)(0)))
        goto exit_rename_column;
    iSchema = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    zDb = db.aDb[iSchema].zDbSName;
    if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
    {
        goto exit_rename_column;
    }

    zOld = sqlite3NameFromToken(db, pOld);
    if (zOld == null)
        goto exit_rename_column;
    for (iCol = (int)(0); (iCol) &lt; (pTab.nCol); iCol++)
    {
        if ((0) == (sqlite3StrICmp(pTab.aCol[iCol].zCnName, zOld)))
            break;
    }

    if ((iCol) == (pTab.nCol))
    {
        sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pOld);
        goto exit_rename_column;
    }

    renameTestSchema(pParse, zDb, ((iSchema) == (1) ? 1 : 0), "", (int)(0));
    renameFixQuotes(pParse, zDb, ((iSchema) == (1) ? 1 : 0));
    sqlite3MayAbort(pParse);
    zNew = sqlite3NameFromToken(db, pNew);
    if (zNew == null)
        goto exit_rename_column;
    bQuote = (int)(sqlite3CtypeMap[(byte)(pNew-&gt;z[0])] &amp; 0x80);
    sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'  AND (type != 'index' OR tbl_name = %Q)", zDb, zDb, pTab.zName, (int)(iCol), zNew, (int)(bQuote), ((iSchema) == (1) ? 1 : 0), pTab.zName);
    sqlite3NestedParse(pParse, "UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN ('trigger', 'view')", zDb, pTab.zName, (int)(iCol), zNew, (int)(bQuote));
    renameReloadSchema(pParse, (int)(iSchema), (ushort)(0x0001));
    renameTestSchema(pParse, zDb, ((iSchema) == (1) ? 1 : 0), "after rename", (int)(1));
    exit_rename_column:
        ; sqlite3SrcListDelete ( db ,  pSrc ) ; 
    sqlite3DbFree(db, zOld);
    sqlite3DbFree(db, zNew);
    return;
}</function>
  <function>public static void sqlite3AlterRenameTable(Parse pParse, SrcList pSrc, Token* pName)
{
    int iDb = 0;
    sbyte* zDb;
    Table pTab;
    sbyte* zName = null;
    sqlite3 db = pParse.db;
    int nTabName = 0;
    sbyte* zTabName;
    Vdbe v;
    VTable pVTab = null;
    if ((db.mallocFailed) != 0)
        goto exit_rename_table;
    pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
    if (pTab == null)
        goto exit_rename_table;
    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
    zDb = db.aDb[iDb].zDbSName;
    zName = sqlite3NameFromToken(db, pName);
    if (zName == null)
        goto exit_rename_table;
    if ((((sqlite3FindTable(db, zName, zDb)) != null) || ((sqlite3FindIndex(db, zName, zDb)) != null)) || ((sqlite3IsShadowTableOf(db, pTab, zName)) != 0))
    {
        sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s", zName);
        goto exit_rename_table;
    }

    if (0 != isAlterableTable(pParse, pTab))
    {
        goto exit_rename_table;
    }

    if (0 != sqlite3CheckObjectName(pParse, zName, "table", zName))
    {
        goto exit_rename_table;
    }

    if ((((pTab).eTabType) == (2)))
    {
        sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab.zName);
        goto exit_rename_table;
    }

    if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
    {
        goto exit_rename_table;
    }

    if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
    {
        goto exit_rename_table;
    }

    if ((((pTab).eTabType) == (1)))
    {
        pVTab = sqlite3GetVTable(db, pTab);
        if ((pVTab.pVtab.pModule.xRename) == (null))
        {
            pVTab = null;
        }
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) == (null))
    {
        goto exit_rename_table;
    }

    sqlite3MayAbort(pParse);
    zTabName = pTab.zName;
    nTabName = (int)(sqlite3Utf8CharLen(zTabName, (int)(-1)));
    sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'", zDb, zDb, zTabName, zName, (((iDb) == (1)) ? 1 : 0), zTabName);
    sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X'      AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type='table' OR type='index' OR type='trigger');", zDb, zName, zName, zName, (int)(nTabName), zTabName);
    if ((sqlite3FindTable(db, "sqlite_sequence", zDb)) != null)
    {
        sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q", zDb, zName, pTab.zName);
    }

    if (iDb != 1)
    {
        sqlite3NestedParse(pParse, "UPDATE sqlite_temp_schema SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND   sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) THEN %Q ELSE tbl_name END WHERE type IN ('view', 'trigger')", zDb, zTabName, zName, zTabName, zDb, zName);
    }

    if ((pVTab) != null)
    {
        int i = (int)(++pParse.nMem);
        sqlite3VdbeLoadString(v, (int)(i), zName);
        sqlite3VdbeAddOp4(v, (int)(175), (int)(i), (int)(0), (int)(0), (sbyte*)(pVTab), (int)(-12));
    }

    renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0001));
    renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "after rename", (int)(0));
    exit_rename_table:
        ; sqlite3SrcListDelete ( db ,  pSrc ) ; 
    sqlite3DbFree(db, zName);
}</function>
  <function>public static int sqlite3AnalysisLoad(sqlite3 db, int iDb)
{
    analysisInfo sInfo = new analysisInfo();
    HashElem* i;
    sbyte* zSql;
    int rc = (int)(0);
    Schema pSchema = db.aDb[iDb].pSchema;
    Table pStat1;
    for (i = ((&amp;pSchema.tblHash)-&gt;first); i; i = ((i)-&gt;next))
    {
        Table pTab = ((i)-&gt;data);
        pTab.tabFlags &amp;= (uint)(~0x00000010);
    }

    for (i = ((&amp;pSchema.idxHash)-&gt;first); i; i = ((i)-&gt;next))
    {
        Index pIdx = ((i)-&gt;data);
        pIdx.hasStat1 = (uint)(0);
    }

    sInfo.db = db;
    sInfo.zDatabase = db.aDb[iDb].zDbSName;
    if ((pStat1 = sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase)) &amp;&amp; (((pStat1).eTabType) == (0)))
    {
        zSql = sqlite3MPrintf(db, "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
        if ((zSql) == (null))
        {
            rc = (int)(7);
        }
        else
        {
            rc = (int)(sqlite3_exec(db, zSql, analysisLoader, sInfo, null));
            sqlite3DbFree(db, zSql);
        }
    }

    for (i = ((&amp;pSchema.idxHash)-&gt;first); i; i = ((i)-&gt;next))
    {
        Index pIdx = ((i)-&gt;data);
        if (pIdx.hasStat1 == 0)
            sqlite3DefaultRowEst(pIdx);
    }

    if ((rc) == (7))
    {
        sqlite3OomFault(db);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3Analyze(Parse pParse, Token* pName1, Token* pName2)
{
    sqlite3 db = pParse.db;
    int iDb = 0;
    int i = 0;
    sbyte* z; sbyte  * zDb ; 
    Table pTab;
    Index pIdx;
    Token* pTableName;
    Vdbe v;
    if (0 != sqlite3ReadSchema(pParse))
    {
        return;
    }

    if ((pName1) == (null))
    {
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            if ((i) == (1))
                continue;
            analyzeDatabase(pParse, (int)(i));
        }
    }
    else if (((pName2-&gt;n) == (0)) &amp;&amp; ((iDb = (int)(sqlite3FindDb(db, pName1))) &gt;= (0)))
    {
        analyzeDatabase(pParse, (int)(iDb));
    }
    else
    {
        iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &amp;pTableName));
        if ((iDb) &gt;= (0))
        {
            zDb = (pName2-&gt;n) != 0 ? db.aDb[iDb].zDbSName : null;
            z = sqlite3NameFromToken(db, pTableName);
            if ((z) != null)
            {
                if ((pIdx = sqlite3FindIndex(db, z, zDb)) != null)
                {
                    analyzeTable(pParse, pIdx.pTable, pIdx);
                }
                else if ((pTab = sqlite3LocateTable(pParse, (uint)(0), z, zDb)) != null)
                {
                    analyzeTable(pParse, pTab, null);
                }

                sqlite3DbFree(db, z);
            }
        }
    }

    if (((db.nSqlExec) == (0)) &amp;&amp; ((v = sqlite3GetVdbe(pParse)) != null))
    {
        sqlite3VdbeAddOp0(v, (int)(165));
    }
}</function>
  <function>public static int sqlite3ApiExit(sqlite3 db, int rc)
{
    if (((db.mallocFailed) != 0) || ((rc) != 0))
    {
        return (int)(apiHandleError(db, (int)(rc)));
    }

    return (int)(rc &amp; db.errMask);
}</function>
  <function>public static void* sqlite3ArrayAllocate(sqlite3 db, void* pArray, int szEntry, int* pnEntry, int* pIdx)
{
    sbyte* z;
    long n = (long)(*pIdx = (int)(*pnEntry));
    if ((n &amp; (n - 1)) == (0))
    {
        long sz = (long)(((n) == (0)) ? 1 : 2 * n);
        void* pNew = sqlite3DbRealloc(db, pArray, (ulong)(sz * szEntry));
        if ((pNew) == (null))
        {
            *pIdx = (int)(-1);
            return pArray;
        }

        pArray = pNew;
    }

    z = (sbyte*)(pArray);
    CRuntime.memset(&amp;z[n * szEntry], (int)(0), (ulong)(szEntry));
    ++*pnEntry;
    return pArray;
}</function>
  <function>public static int sqlite3AtoF(sbyte* z, double* pResult, int length, byte enc)
{
    int incr = 0;
    sbyte* zEnd;
    int sign = (int)(1);
    long s = (long)(0);
    int d = (int)(0);
    int esign = (int)(1);
    int e = (int)(0);
    int eValid = (int)(1);
    double result = 0;
    int nDigit = (int)(0);
    int eType = (int)(1);
    *pResult = (double)(0.0);
    if ((length) == (0))
        return (int)(0);
    if ((enc) == (1))
    {
        incr = (int)(1);
        zEnd = z + length;
    }
    else
    {
        int i = 0;
        incr = (int)(2);
        length &amp;= (int)(~1);
        for (i = (int)(3 - enc); ((i) &lt; (length)) &amp;&amp; ((z[i]) == (0)); i += (int)(2))
        {
        }

        if ((i) &lt; (length))
            eType = (int)(-100);
        zEnd = &amp;z[i ^ 1];
        z += (enc &amp; 1);
    }

    while (((z) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x01) != 0))
    {
        z += incr;
    }

    if ((z) &gt;= (zEnd))
        return (int)(0);
    if ((*z) == (45))
    {
        sign = (int)(-1);
        z += incr;
    }
    else if ((*z) == (43))
    {
        z += incr;
    }

    while (((z) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x04) != 0))
    {
        s = (long)(s * 10 + (*z - 48));
        z += incr;
        nDigit++;
        if ((s) &gt;= (((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) - 9) / 10))
        {
            while (((z) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x04) != 0))
            {
                z += incr;
                d++;
            }
        }
    }

    if ((z) &gt;= (zEnd))
        goto do_atof_calc;
    if ((*z) == (46))
    {
        z += incr;
        eType++;
        while (((z) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x04) != 0))
        {
            if ((s) &lt; (((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) - 9) / 10))
            {
                s = (long)(s * 10 + (*z - 48));
                d--;
                nDigit++;
            }

            z += incr;
        }
    }

    if ((z) &gt;= (zEnd))
        goto do_atof_calc;
    if (((*z) == (101)) || ((*z) == (69)))
    {
        z += incr;
        eValid = (int)(0);
        eType++;
        if ((z) &gt;= (zEnd))
            goto do_atof_calc;
        if ((*z) == (45))
        {
            esign = (int)(-1);
            z += incr;
        }
        else if ((*z) == (43))
        {
            z += incr;
        }

        while (((z) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x04) != 0))
        {
            e = (int)((e) &lt; (10000) ? (e * 10 + (*z - 48)) : 10000);
            z += incr;
            eValid = (int)(1);
        }
    }

    while (((z) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*z)] &amp; 0x01) != 0))
    {
        z += incr;
    }

    do_atof_calc:
        ; e  =  ( int ) ( ( e * esign ) + d ) ; 
    if ((e) &lt; (0))
    {
        esign = (int)(-1);
        e *= (int)(-1);
    }
    else
    {
        esign = (int)(1);
    }

    if ((s) == (0))
    {
        result = (double)((sign) &lt; (0) ? -(double)(0) : (double)(0));
    }
    else
    {
        while ((e) &gt; (0))
        {
            if ((esign) &gt; (0))
            {
                if ((s) &gt;= ((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) / 10))
                    break;
                s *= (long)(10);
            }
            else
            {
                if (s % 10 != 0)
                    break;
                s /= (long)(10);
            }

            e--;
        }

        s = (long)((sign) &lt; (0) ? -s : s);
        if ((e) == (0))
        {
            result = ((double)(s));
        }
        else
        {
            if ((e) &gt; (307))
            {
                if ((e) &lt; (342))
                {
                    double scale = (double)(sqlite3Pow10((int)(e - 308)));
                    if ((esign) &lt; (0))
                    {
                        result = (double)(s / scale);
                        result /= (double)(1.0e+308);
                    }
                    else
                    {
                        result = (double)(s * scale);
                        result *= (double)(1.0e+308);
                    }
                }
                else
                {
                    if ((esign) &lt; (0))
                    {
                        result = (double)(0.0 * s);
                    }
                    else
                    {
                        result = (double)(((float)(1e+300 * 1e+300)) * s);
                    }
                }
            }
            else
            {
                double scale = (double)(sqlite3Pow10((int)(e)));
                if ((esign) &lt; (0))
                {
                    result = (double)(s / scale);
                }
                else
                {
                    result = (double)(s * scale);
                }
            }
        }
    }

    *pResult = (double)(result);
    if (((((z) == (zEnd)) &amp;&amp; ((nDigit) &gt; (0))) &amp;&amp; ((eValid) != 0)) &amp;&amp; ((eType) &gt; (0)))
    {
        return (int)(eType);
    }
    else if ((((eType) &gt;= (2)) &amp;&amp; (((eType) == (3)) || ((eValid) != 0))) &amp;&amp; ((nDigit) &gt; (0)))
    {
        return (int)(-1);
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static int sqlite3Atoi(sbyte* z)
{
    int x = (int)(0);
    sqlite3GetInt32(z, &amp;x);
    return (int)(x);
}</function>
  <function>public static int sqlite3Atoi64(sbyte* zNum, long* pNum, int length, byte enc)
{
    int incr = 0;
    ulong u = (ulong)(0);
    int neg = (int)(0);
    int i = 0;
    int c = (int)(0);
    int nonNum = (int)(0);
    int rc = 0;
    sbyte* zStart;
    sbyte* zEnd = zNum + length;
    if ((enc) == (1))
    {
        incr = (int)(1);
    }
    else
    {
        incr = (int)(2);
        length &amp;= (int)(~1);
        for (i = (int)(3 - enc); ((i) &lt; (length)) &amp;&amp; ((zNum[i]) == (0)); i += (int)(2))
        {
        }

        nonNum = (int)((i) &lt; (length) ? 1 : 0);
        zEnd = &amp;zNum[i ^ 1];
        zNum += (enc &amp; 1);
    }

    while (((zNum) &lt; (zEnd)) &amp;&amp; ((sqlite3CtypeMap[(byte)(*zNum)] &amp; 0x01) != 0))
    {
        zNum += incr;
    }

    if ((zNum) &lt; (zEnd))
    {
        if ((*zNum) == (45))
        {
            neg = (int)(1);
            zNum += incr;
        }
        else if ((*zNum) == (43))
        {
            zNum += incr;
        }
    }

    zStart = zNum;
    while (((zNum) &lt; (zEnd)) &amp;&amp; ((zNum[0]) == (48)))
    {
        zNum += incr;
    }

    for (i = (int)(0); (((&amp;zNum[i]) &lt; (zEnd)) &amp;&amp; ((c = (int)(zNum[i])) &gt;= (48))) &amp;&amp; ((c) &lt;= (57)); i += (int)(incr))
    {
        u = (ulong)(u * 10 + c - 48);
    }

    if ((u) &gt; (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)))
    {
        *pNum = (long)((neg) != 0 ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))) : (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)));
    }
    else if ((neg) != 0)
    {
        *pNum = (long)(-(long)(u));
    }
    else
    {
        *pNum = ((long)(u));
    }

    rc = (int)(0);
    if (((i) == (0)) &amp;&amp; ((zStart) == (zNum)))
    {
        rc = (int)(-1);
    }
    else if ((nonNum) != 0)
    {
        rc = (int)(1);
    }
    else if ((&amp;zNum[i]) &lt; (zEnd))
    {
        int jj = (int)(i);
        do
        {
            if ((sqlite3CtypeMap[(byte)(zNum[jj])] &amp; 0x01) == 0)
            {
                rc = (int)(1);
                break;
            }

            jj += (int)(incr);
        }
        while ((&amp;zNum[jj]) &lt; (zEnd));
    }

    if ((i) &lt; (19 * incr))
    {
        return (int)(rc);
    }
    else
    {
        c = (int)((i) &gt; (19 * incr) ? 1 : compare2pow63(zNum, (int)(incr)));
        if ((c) &lt; (0))
        {
            return (int)(rc);
        }
        else
        {
            *pNum = (long)((neg) != 0 ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))) : (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)));
            if ((c) &gt; (0))
            {
                return (int)(2);
            }
            else
            {
                return (int)((neg) != 0 ? rc : 3);
            }
        }
    }
}</function>
  <function>public static void sqlite3Attach(Parse pParse, Expr p, Expr pDbname, Expr pKey)
{
    codeAttach(pParse, (int)(24), sqlite3Attach_attach_func, p, p, pDbname, pKey);
}</function>
  <function>public static int sqlite3AuthCheck(Parse pParse, int code, sbyte* zArg1, sbyte* zArg2, sbyte* zArg3)
{
    sqlite3 db = pParse.db;
    int rc = 0;
    if ((((db.xAuth) == (null)) || ((db.init.busy) != 0)) || (pParse.eParseMode != 0))
    {
        return (int)(0);
    }

    rc = (int)(db.xAuth(db.pAuthArg, (int)(code), zArg1, zArg2, zArg3, pParse.zAuthContext));
    if ((rc) == (1))
    {
        sqlite3ErrorMsg(pParse, "not authorized");
        pParse.rc = (int)(23);
    }
    else if ((rc != 0) &amp;&amp; (rc != 2))
    {
        rc = (int)(1);
        sqliteAuthBadReturnCode(pParse);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3AuthContextPop(AuthContext pContext)
{
    if ((pContext.pParse) != null)
    {
        pContext.pParse.zAuthContext = pContext.zAuthContext;
        pContext.pParse = null;
    }
}</function>
  <function>public static void sqlite3AuthContextPush(Parse pParse, AuthContext pContext, sbyte* zContext)
{
    pContext.pParse = pParse;
    pContext.zAuthContext = pParse.zAuthContext;
    pParse.zAuthContext = zContext;
}</function>
  <function>public static void sqlite3AuthRead(Parse pParse, Expr pExpr, Schema pSchema, SrcList pTabList)
{
    Table pTab = null;
    sbyte* zCol;
    int iSrc = 0;
    int iDb = 0;
    int iCol = 0;
    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pSchema));
    if ((iDb) &lt; (0))
    {
        return;
    }

    if ((pExpr.op) == (77))
    {
        pTab = pParse.pTriggerTab;
    }
    else
    {
        for (iSrc = (int)(0); (iSrc) &lt; (pTabList.nSrc); iSrc++)
        {
            if ((pExpr.iTable) == (pTabList.a[iSrc].iCursor))
            {
                pTab = pTabList.a[iSrc].pTab;
                break;
            }
        }
    }

    iCol = (int)(pExpr.iColumn);
    if ((pTab) == (null))
        return;
    if ((iCol) &gt;= (0))
    {
        zCol = pTab.aCol[iCol].zCnName;
    }
    else if ((pTab.iPKey) &gt;= (0))
    {
        zCol = pTab.aCol[pTab.iPKey].zCnName;
    }
    else
    {
        zCol = "ROWID";
    }

    if ((2) == (sqlite3AuthReadCol(pParse, pTab.zName, zCol, (int)(iDb))))
    {
        pExpr.op = (byte)(121);
    }
}</function>
  <function>public static int sqlite3AuthReadCol(Parse pParse, sbyte* zTab, sbyte* zCol, int iDb)
{
    sqlite3 db = pParse.db;
    sbyte* zDb = db.aDb[iDb].zDbSName;
    int rc = 0;
    if ((db.init.busy) != 0)
        return (int)(0);
    rc = (int)(db.xAuth(db.pAuthArg, (int)(20), zTab, zCol, zDb, pParse.zAuthContext));
    if ((rc) == (1))
    {
        sbyte* z = sqlite3_mprintf("%s.%s", zTab, zCol);
        if (((db.nDb) &gt; (2)) || (iDb != 0))
            z = sqlite3_mprintf("%s.%z", zDb, z);
        sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);
        pParse.rc = (int)(23);
    }
    else if ((rc != 2) &amp;&amp; (rc != 0))
    {
        sqliteAuthBadReturnCode(pParse);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3AutoincrementBegin(Parse pParse)
{
    AutoincInfo p;
    sqlite3 db = pParse.db;
    Db pDb;
    int memId = 0;
    Vdbe v = pParse.pVdbe;
    for (p = pParse.pAinc; p; p = p.pNext)
    {
        VdbeOp* aOp;
        pDb = db.aDb[p.iDb];
        memId = (int)(p.regCtr);
        sqlite3OpenTable(pParse, (int)(0), (int)(p.iDb), pDb.pSchema.pSeqTab, (int)(101));
        sqlite3VdbeLoadString(v, (int)(memId - 1), p.pTab.zName);
        aOp = sqlite3VdbeAddOpList(v, ((int)(12 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3AutoincrementBegin_autoInc, (int)(sqlite3AutoincrementBegin_iLn));
        if ((aOp) == (null))
            break;
        aOp[0].p2 = (int)(memId);
        aOp[0].p3 = (int)(memId + 2);
        aOp[2].p3 = (int)(memId);
        aOp[3].p1 = (int)(memId - 1);
        aOp[3].p3 = (int)(memId);
        aOp[3].p5 = (ushort)(0x10);
        aOp[4].p2 = (int)(memId + 1);
        aOp[5].p3 = (int)(memId);
        aOp[6].p1 = (int)(memId);
        aOp[7].p2 = (int)(memId + 2);
        aOp[7].p1 = (int)(memId);
        aOp[10].p2 = (int)(memId);
        if ((pParse.nTab) == (0))
            pParse.nTab = (int)(1);
    }
}</function>
  <function>public static void sqlite3AutoincrementEnd(Parse pParse)
{
    if ((pParse.pAinc) != null)
        autoIncrementEnd(pParse);
}</function>
  <function>public static void sqlite3AutoLoadExtensions(sqlite3 db)
{
    uint i = 0;
    int go = (int)(1);
    int rc = 0;
    delegate88 xInit;
    if ((sqlite3Autoext.nExt) == (0))
    {
        return;
    }

    for (i = (uint)(0); go; i++)
    {
        sbyte* zErrmsg;
        sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
        sqlite3_api_routines pThunk = sqlite3Apis;
        sqlite3_mutex_enter(mutex);
        if ((i) &gt;= (sqlite3Autoext.nExt))
        {
            xInit = null;
            go = (int)(0);
        }
        else
        {
            xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3Autoext.aExt[i]);
        }

        sqlite3_mutex_leave(mutex);
        zErrmsg = null;
        if (((xInit) != null) &amp;&amp; ((rc = (int)(xInit(db, &amp;zErrmsg, pThunk))) != 0))
        {
            sqlite3ErrorWithMsg(db, (int)(rc), "automatic extension loading failed: %s", zErrmsg);
            go = (int)(0);
        }

        sqlite3_free(zErrmsg);
    }
}</function>
  <function>public static void sqlite3BackupRestart(sqlite3_backup pBackup)
{
    sqlite3_backup p;
    for (p = pBackup; p; p = p.pNext)
    {
        p.iNext = (uint)(1);
    }
}</function>
  <function>public static void sqlite3BackupUpdate(sqlite3_backup pBackup, uint iPage, byte* aData)
{
    if ((pBackup) != null)
        backupUpdate(pBackup, (uint)(iPage), aData);
}</function>
  <function>public static void sqlite3BeginBenignMalloc()
{
    if ((sqlite3Hooks.xBenignBegin) != null)
    {
        sqlite3Hooks.xBenignBegin();
    }
}</function>
  <function>public static void sqlite3BeginTransaction(Parse pParse, int type)
{
    sqlite3 db;
    Vdbe v;
    int i = 0;
    db = pParse.db;
    if ((sqlite3AuthCheck(pParse, (int)(22), "BEGIN", null, null)) != 0)
    {
        return;
    }

    v = sqlite3GetVdbe(pParse);
    if (v == null)
        return;
    if (type != 7)
    {
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            int eTxnType = 0;
            Btree pBt = db.aDb[i].pBt;
            if (((pBt) != null) &amp;&amp; ((sqlite3BtreeIsReadonly(pBt)) != 0))
            {
                eTxnType = (int)(0);
            }
            else if ((type) == (9))
            {
                eTxnType = (int)(2);
            }
            else
            {
                eTxnType = (int)(1);
            }

            sqlite3VdbeAddOp2(v, (int)(2), (int)(i), (int)(eTxnType));
            sqlite3VdbeUsesBtree(v, (int)(i));
        }
    }

    sqlite3VdbeAddOp0(v, (int)(1));
}</function>
  <function>public static void sqlite3BeginTrigger(Parse pParse, Token* pName1, Token* pName2, int tr_tm, int op, IdList* pColumns, SrcList pTableName, Expr pWhen, int isTemp, int noErr)
{
    Trigger pTrigger = null;
    Table pTab;
    sbyte* zName = null;
    sqlite3 db = pParse.db;
    int iDb = 0;
    Token* pName;
    DbFixer sFix = new DbFixer();
    if ((isTemp) != 0)
    {
        if ((pName2-&gt;n) &gt; (0))
        {
            sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
            goto trigger_cleanup;
        }

        iDb = (int)(1);
        pName = pName1;
    }
    else
    {
        iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &amp;pName));
        if ((iDb) &lt; (0))
        {
            goto trigger_cleanup;
        }
    }

    if ((pTableName == null) || ((db.mallocFailed) != 0))
    {
        goto trigger_cleanup;
    }

    if (((db.init.busy) != 0) &amp;&amp; (iDb != 1))
    {
        sqlite3DbFree(db, pTableName.a[0].zDatabase);
        pTableName.a[0].zDatabase = null;
    }

    pTab = sqlite3SrcListLookup(pParse, pTableName);
    if (((((db.init.busy) == (0)) &amp;&amp; ((pName2-&gt;n) == (0))) &amp;&amp; ((pTab) != null)) &amp;&amp; ((pTab.pSchema) == (db.aDb[1].pSchema)))
    {
        iDb = (int)(1);
    }

    if ((db.mallocFailed) != 0)
        goto trigger_cleanup;
    sqlite3FixInit(sFix, pParse, (int)(iDb), "trigger", pName);
    if ((sqlite3FixSrcList(sFix, pTableName)) != 0)
    {
        goto trigger_cleanup;
    }

    pTab = sqlite3SrcListLookup(pParse, pTableName);
    if (pTab == null)
    {
        goto trigger_orphan_error;
    }

    if ((((pTab).eTabType) == (1)))
    {
        sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
        goto trigger_orphan_error;
    }

    zName = sqlite3NameFromToken(db, pName);
    if ((zName) == (null))
    {
        goto trigger_cleanup;
    }

    if ((sqlite3CheckObjectName(pParse, zName, "trigger", pTab.zName)) != 0)
    {
        goto trigger_cleanup;
    }

    if (!((pParse.eParseMode) &gt;= (2)))
    {
        if ((sqlite3HashFind(&amp;(db.aDb[iDb].pSchema.trigHash), zName)) != null)
        {
            if (noErr == 0)
            {
                sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
            }
            else
            {
                sqlite3CodeVerifySchema(pParse, (int)(iDb));
            }

            goto trigger_cleanup;
        }
    }

    if ((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0))
    {
        sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
        goto trigger_cleanup;
    }

    if ((((pTab).eTabType) == (2)) &amp;&amp; (tr_tm != 65))
    {
        sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", ((tr_tm) == (33)) ? "BEFORE" : "AFTER", pTableName.a);
        goto trigger_orphan_error;
    }

    if ((!(((pTab).eTabType) == (2))) &amp;&amp; ((tr_tm) == (65)))
    {
        sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF trigger on table: %S", pTableName.a);
        goto trigger_orphan_error;
    }

    if (!((pParse.eParseMode) &gt;= (2)))
    {
        int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
        int code = (int)(7);
        sbyte* zDb = db.aDb[iTabDb].zDbSName;
        sbyte* zDbTrig = (isTemp) != 0 ? db.aDb[1].zDbSName : zDb;
        if (((iTabDb) == (1)) || ((isTemp) != 0))
            code = (int)(5);
        if ((sqlite3AuthCheck(pParse, (int)(code), zName, pTab.zName, zDbTrig)) != 0)
        {
            goto trigger_cleanup;
        }

        if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) &amp;&amp; ((iTabDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
        {
            goto trigger_cleanup;
        }
    }

    if ((tr_tm) == (65))
    {
        tr_tm = (int)(33);
    }

    pTrigger = (Trigger)(sqlite3DbMallocZero(db, (ulong)(sizeof(Trigger))));
    if ((pTrigger) == (null))
        goto trigger_cleanup;
    pTrigger.zName = zName;
    zName = null;
    pTrigger.table = sqlite3DbStrDup(db, pTableName.a[0].zName);
    pTrigger.pSchema = db.aDb[iDb].pSchema;
    pTrigger.pTabSchema = pTab.pSchema;
    pTrigger.op = ((byte)(op));
    pTrigger.tr_tm = (byte)((tr_tm) == (33) ? 1 : 2);
    if (((pParse.eParseMode) &gt;= (2)))
    {
        sqlite3RenameTokenRemap(pParse, pTrigger.table, pTableName.a[0].zName);
        pTrigger.pWhen = pWhen;
        pWhen = null;
    }
    else
    {
        pTrigger.pWhen = sqlite3ExprDup(db, pWhen, (int)(0x0001));
    }

    pTrigger.pColumns = pColumns;
    pColumns = null;
    pParse.pNewTrigger = pTrigger;
    trigger_cleanup:
        ; sqlite3DbFree ( db ,  zName ) ; 
    sqlite3SrcListDelete(db, pTableName);
    sqlite3IdListDelete(db, pColumns);
    sqlite3ExprDelete(db, pWhen);
    if (pParse.pNewTrigger == null)
    {
        sqlite3DeleteTrigger(db, pTrigger);
    }
    else
    {
    }

    return;
    trigger_orphan_error:
        ; if  ( ( db . init . iDb ) == ( 1 ) ) { db . init . orphanTrigger  =  ( uint ) ( 1 ) ;  }
    goto trigger_cleanup;
}</function>
  <function>public static void sqlite3BeginWriteOperation(Parse pParse, int setStatement, int iDb)
{
    Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    sqlite3CodeVerifySchemaAtToplevel(pToplevel, (int)(iDb));
    (pToplevel.writeMask) |= (uint)(((uint)(1)) &lt;&lt; (iDb));
    pToplevel.isMultiWrite |= (byte)(setStatement);
}</function>
  <function>public static void sqlite3BenignMallocHooks(delegate74 xBenignBegin, delegate74 xBenignEnd)
{
    sqlite3Hooks.xBenignBegin = xBenignBegin;
    sqlite3Hooks.xBenignEnd = xBenignEnd;
}</function>
  <function>public static CollSeq sqlite3BinaryCompareCollSeq(Parse pParse, Expr pLeft, Expr pRight)
{
    CollSeq pColl;
    if ((pLeft.flags &amp; 0x000100) != 0)
    {
        pColl = sqlite3ExprCollSeq(pParse, pLeft);
    }
    else if (((pRight) != null) &amp;&amp; ((pRight.flags &amp; 0x000100) != 0))
    {
        pColl = sqlite3ExprCollSeq(pParse, pRight);
    }
    else
    {
        pColl = sqlite3ExprCollSeq(pParse, pLeft);
        if (pColl == null)
        {
            pColl = sqlite3ExprCollSeq(pParse, pRight);
        }
    }

    return pColl;
}</function>
  <function>public static int sqlite3BitvecBuiltinTest(int sz, int* aOp)
{
    Bitvec* pBitvec = null;
    byte* pV = null;
    int rc = (int)(-1);
    int i = 0; int  nx  =  0 ;  int  pc  =  0 ;  int  op  =  0 ; 
    void* pTmpSpace;
    pBitvec = sqlite3BitvecCreate((uint)(sz));
    pV = sqlite3MallocZero((ulong)((sz + 7) / 8 + 1));
    pTmpSpace = sqlite3_malloc64((ulong)(512));
    if ((((pBitvec) == (null)) || ((pV) == (null))) || ((pTmpSpace) == (null)))
        goto bitvec_end;
    sqlite3BitvecSet(null, (uint)(1));
    sqlite3BitvecClear(null, (uint)(1), pTmpSpace);
    pc = (int)(i = (int)(0));
    while ((op = (int)(aOp[pc])) != 0)
    {
        switch (op)
        {
            case 1:
            case 2:
            case 5:
            {
                nx = (int)(4);
                i = (int)(aOp[pc + 2] - 1);
                aOp[pc + 2] += (int)(aOp[pc + 3]);
                break;
            }

            case 3:
            case 4:
            default:
            {
                nx = (int)(2);
                sqlite3_randomness((int)(sizeof(int)), &amp;i);
                break;
            }
        }

        if ((--aOp[pc + 1]) &gt; (0))
            nx = (int)(0);
        pc += (int)(nx);
        i = (int)((i &amp; 0x7fffffff) % sz);
        if ((op &amp; 1) != 0)
        {
            pV[(i + 1) &gt;&gt; 3] |= (byte)(1 &lt;&lt; ((i + 1) &amp; 7));
            if (op != 5)
            {
                if ((sqlite3BitvecSet(pBitvec, (uint)(i + 1))) != 0)
                    goto bitvec_end;
            }
        }
        else
        {
            pV[(i + 1) &gt;&gt; 3] &amp;= (byte)(~(1 &lt;&lt; ((i + 1) &amp; 7)));
            sqlite3BitvecClear(pBitvec, (uint)(i + 1), pTmpSpace);
        }
    }

    rc = (int)(sqlite3BitvecTest(null, (uint)(0)) + sqlite3BitvecTest(pBitvec, (uint)(sz + 1)) + sqlite3BitvecTest(pBitvec, (uint)(0)) + (sqlite3BitvecSize(pBitvec) - sz));
    for (i = (int)(1); (i) &lt;= (sz); i++)
    {
        if (((pV[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))) != 0) != sqlite3BitvecTest(pBitvec, (uint)(i)))
        {
            rc = (int)(i);
            break;
        }
    }

    bitvec_end:
        ; sqlite3_free ( pTmpSpace ) ; 
    sqlite3_free(pV);
    sqlite3BitvecDestroy(pBitvec);
    return (int)(rc);
}</function>
  <function>public static void sqlite3BitvecClear(Bitvec* p, uint i, void* pBuf)
{
    if ((p) == (null))
        return;
    i--;
    while ((p-&gt;iDivisor) != 0)
    {
        uint bin = (uint)(i / p-&gt;iDivisor);
        i = (uint)(i % p-&gt;iDivisor);
        p = p-&gt;u.apSub[bin];
        if (p == null)
        {
            return;
        }
    }

    if ((p-&gt;iSize) &lt;= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
    {
        p-&gt;u.aBitmap[i / 8] &amp;= (byte)(~(1 &lt;&lt; (i &amp; (8 - 1))));
    }
    else
    {
        uint j = 0;
        uint* aiValues = pBuf;
        CRuntime.memcpy(aiValues, p-&gt;u.aHash, (ulong)(124 * sizeof(uint)));
        CRuntime.memset(p-&gt;u.aHash, (int)(0), (ulong)(124 * sizeof(uint)));
        p-&gt;nSet = (uint)(0);
        for (j = (uint)(0); (j) &lt; ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)); j++)
        {
            if (((aiValues[j]) != 0) &amp;&amp; (aiValues[j] != (i + 1)))
            {
                uint h = (uint)(((aiValues[j] - 1) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
                p-&gt;nSet++;
                while ((p-&gt;u.aHash[h]) != 0)
                {
                    h++;
                    if ((h) &gt;= ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)))
                        h = (uint)(0);
                }

                p-&gt;u.aHash[h] = (uint)(aiValues[j]);
            }
        }
    }
}</function>
  <function>public static Bitvec* sqlite3BitvecCreate(uint iSize)
{
    Bitvec* p;
    p = sqlite3MallocZero((ulong)(sizeof(Bitvec)));
    if ((p) != null)
    {
        p-&gt;iSize = (uint)(iSize);
    }

    return p;
}</function>
  <function>public static void sqlite3BitvecDestroy(Bitvec* p)
{
    if ((p) == (null))
        return;
    if ((p-&gt;iDivisor) != 0)
    {
        uint i = 0;
        for (i = (uint)(0); (i) &lt; ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec)); i++)
        {
            sqlite3BitvecDestroy(p-&gt;u.apSub[i]);
        }
    }

    sqlite3_free(p);
}</function>
  <function>public static int sqlite3BitvecSet(Bitvec* p, uint i)
{
    uint h = 0;
    if ((p) == (null))
        return (int)(0);
    i--;
    while (((p-&gt;iSize) &gt; (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8)) &amp;&amp; ((p-&gt;iDivisor) != 0))
    {
        uint bin = (uint)(i / p-&gt;iDivisor);
        i = (uint)(i % p-&gt;iDivisor);
        if ((p-&gt;u.apSub[bin]) == (null))
        {
            p-&gt;u.apSub[bin] = sqlite3BitvecCreate((uint)(p-&gt;iDivisor));
            if ((p-&gt;u.apSub[bin]) == (null))
                return (int)(7);
        }

        p = p-&gt;u.apSub[bin];
    }

    if ((p-&gt;iSize) &lt;= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
    {
        p-&gt;u.aBitmap[i / 8] |= (byte)(1 &lt;&lt; (i &amp; (8 - 1)));
        return (int)(0);
    }

    h = (uint)(((i++) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
    if (p-&gt;u.aHash[h] == 0)
    {
        if ((p-&gt;nSet) &lt; (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)) - 1))
        {
            goto bitvec_set_end;
        }
        else
        {
            goto bitvec_set_rehash;
        }
    }

    do
    {
        if ((p-&gt;u.aHash[h]) == (i))
            return (int)(0);
        h++;
        if ((h) &gt;= ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)))
            h = (uint)(0);
    }
    while ((p-&gt;u.aHash[h]) != 0);
    bitvec_set_rehash:
        ; if  ( ( p -&gt; nSet ) &gt;= ( ( ( ( ( 512 - ( 3 * sizeof ( uint ) ) ) / sizeof ( Bitvec ) ) * sizeof ( Bitvec ) ) / sizeof ( uint ) ) / 2 ) ) { uint  j  =  0 ;  int  rc  =  0 ;  uint  * aiValues  =  sqlite3DbMallocRaw ( null ,  ( ulong ) ( 124 * sizeof ( uint ) ) ) ;  if  ( ( aiValues ) == ( null ) ) { return  ( int ) ( 7 ) ;  } else  { CRuntime . memcpy ( aiValues ,  p -&gt; u . aHash ,  ( ulong ) ( 124 * sizeof ( uint ) ) ) ;  CRuntime . memset ( p -&gt; u . apSub ,  ( int ) ( 0 ) ,  ( ulong ) ( 62 * sizeof ( Bitvec ) ) ) ;  p -&gt; iDivisor  =  ( uint ) ( ( p -&gt; iSize + ( ( ( ( 512 - ( 3 * sizeof ( uint ) ) ) / sizeof ( Bitvec ) ) * sizeof ( Bitvec ) ) / sizeof ( Bitvec ) ) - 1 ) / ( ( ( ( 512 - ( 3 * sizeof ( uint ) ) ) / sizeof ( Bitvec ) ) * sizeof ( Bitvec ) ) / sizeof ( Bitvec ) ) ) ;  rc  =  ( int ) ( sqlite3BitvecSet ( p ,  ( uint ) ( i ) ) ) ;  for  ( j  =  ( uint ) ( 0 ) ;  ( j ) &lt; ( ( ( ( 512 - ( 3 * sizeof ( uint ) ) ) / sizeof ( Bitvec ) ) * sizeof ( Bitvec ) ) / sizeof ( uint ) ) ;  j ++ ) { if  ( ( aiValues [ j ] ) != 0 ) rc |= ( int ) ( sqlite3BitvecSet ( p ,  ( uint ) ( aiValues [ j ] ) ) ) ;  } sqlite3DbFree ( null ,  aiValues ) ;  return  ( int ) ( rc ) ;  } }
    bitvec_set_end:
        ; p -&gt; nSet ++ ; 
    p-&gt;u.aHash[h] = (uint)(i);
    return (int)(0);
}</function>
  <function>public static uint sqlite3BitvecSize(Bitvec* p)
{
    return (uint)(p-&gt;iSize);
}</function>
  <function>public static int sqlite3BitvecTest(Bitvec* p, uint i)
{
    return ((p != null) &amp;&amp; ((sqlite3BitvecTestNotNull(p, (uint)(i))) != 0) ? 1 : 0);
}</function>
  <function>public static int sqlite3BitvecTestNotNull(Bitvec* p, uint i)
{
    i--;
    if ((i) &gt;= (p-&gt;iSize))
        return (int)(0);
    while ((p-&gt;iDivisor) != 0)
    {
        uint bin = (uint)(i / p-&gt;iDivisor);
        i = (uint)(i % p-&gt;iDivisor);
        p = p-&gt;u.apSub[bin];
        if (p == null)
        {
            return (int)(0);
        }
    }

    if ((p-&gt;iSize) &lt;= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
    {
        return (int)((p-&gt;u.aBitmap[i / 8] &amp; (1 &lt;&lt; (i &amp; (8 - 1)))) != 0);
    }
    else
    {
        uint h = (uint)(((i++) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
        while ((p-&gt;u.aHash[h]) != 0)
        {
            if ((p-&gt;u.aHash[h]) == (i))
                return (int)(1);
            h = (uint)((h + 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
        }

        return (int)(0);
    }
}</function>
  <function>public static int sqlite3BlobCompare(sqlite3_value pB1, sqlite3_value pB2)
{
    int c = 0;
    int n1 = (int)(pB1.n);
    int n2 = (int)(pB2.n);
    if (((pB1.flags | pB2.flags) &amp; 0x4000) != 0)
    {
        if ((pB1.flags &amp; pB2.flags &amp; 0x4000) != 0)
        {
            return (int)(pB1.u.nZero - pB2.u.nZero);
        }
        else if ((pB1.flags &amp; 0x4000) != 0)
        {
            if (isAllZero(pB2.z, (int)(pB2.n)) == 0)
                return (int)(-1);
            return (int)(pB1.u.nZero - n2);
        }
        else
        {
            if (isAllZero(pB1.z, (int)(pB1.n)) == 0)
                return (int)(+1);
            return (int)(n1 - pB2.u.nZero);
        }
    }

    c = (int)(memcmp(pB1.z, pB2.z, (ulong)((n1) &gt; (n2) ? n2 : n1)));
    if ((c) != 0)
        return (int)(c);
    return (int)(n1 - n2);
}</function>
  <function>public static int sqlite3BtreeBeginStmt(Btree p, int iStatement)
{
    int rc = 0;
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    rc = (int)(sqlite3PagerOpenSavepoint(pBt.pPager, (int)(iStatement)));
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeBeginTrans(Btree p, int wrflag, int* pSchemaVersion)
{
    BtShared pBt = p.pBt;
    Pager pPager = pBt.pPager;
    int rc = (int)(0);
    sqlite3BtreeEnter(p);
    if (((p.inTrans) == (2)) || (((p.inTrans) == (1)) &amp;&amp; (wrflag == 0)))
    {
        goto trans_begun;
    }

    if (((p.db.flags &amp; 0x02000000) != 0) &amp;&amp; ((sqlite3PagerIsreadonly(pPager)) == (0)))
    {
        pBt.btsFlags &amp;= (ushort)(~0x0001);
    }

    if (((pBt.btsFlags &amp; 0x0001) != 0) &amp;&amp; ((wrflag) != 0))
    {
        rc = (int)(8);
        goto trans_begun;
    }

    {
        sqlite3 pBlock = null;
        if ((((wrflag) != 0) &amp;&amp; ((pBt.inTransaction) == (2))) || ((pBt.btsFlags &amp; 0x0080) != 0))
        {
            pBlock = pBt.pWriter.db;
        }
        else if ((wrflag) &gt; (1))
        {
            BtLock pIter;
            for (pIter = pBt.pLock; pIter; pIter = pIter.pNext)
            {
                if (pIter.pBtree != p)
                {
                    pBlock = pIter.pBtree.db;
                    break;
                }
            }
        }

        if ((pBlock) != null)
        {
            rc = (int)(6 | (1 &lt;&lt; 8));
            goto trans_begun;
        }
    }

    rc = (int)(querySharedCacheTableLock(p, (uint)(1), (byte)(1)));
    if (0 != rc)
        goto trans_begun;
    pBt.btsFlags &amp;= (ushort)(~0x0010);
    if ((pBt.nPage) == (0))
        pBt.btsFlags |= (ushort)(0x0010);
    do
    {
        while (((pBt.pPage1) == (null)) &amp;&amp; ((0) == (rc = (int)(lockBtree(pBt)))))
        {
        }

        if (((rc) == (0)) &amp;&amp; ((wrflag) != 0))
        {
            if ((pBt.btsFlags &amp; 0x0001) != 0)
            {
                rc = (int)(8);
            }
            else
            {
                rc = (int)(sqlite3PagerBegin(pPager, ((wrflag) &gt; (1) ? 1 : 0), (int)(sqlite3TempInMemory(p.db))));
                if ((rc) == (0))
                {
                    rc = (int)(newDatabase(pBt));
                }
                else if (((rc) == (5 | (2 &lt;&lt; 8))) &amp;&amp; ((pBt.inTransaction) == (0)))
                {
                    rc = (int)(5);
                }
            }
        }

        if (rc != 0)
        {
            (void)(0);
            unlockBtreeIfUnused(pBt);
        }
    }
    while ((((rc &amp; 0xFF) == (5)) &amp;&amp; ((pBt.inTransaction) == (0))) &amp;&amp; ((btreeInvokeBusyHandler(pBt)) != 0));
    if ((rc) == (0))
    {
        if ((p.inTrans) == (0))
        {
            pBt.nTransaction++;
            if ((p.sharable) != 0)
            {
                p._lock_.eLock = (byte)(1);
                p._lock_.pNext = pBt.pLock;
                pBt.pLock = p._lock_;
            }
        }

        p.inTrans = (byte)((wrflag) != 0 ? 2 : 1);
        if ((p.inTrans) &gt; (pBt.inTransaction))
        {
            pBt.inTransaction = (byte)(p.inTrans);
        }

        if ((wrflag) != 0)
        {
            MemPage pPage1 = pBt.pPage1;
            pBt.pWriter = p;
            pBt.btsFlags &amp;= (ushort)(~0x0040);
            if ((wrflag) &gt; (1))
                pBt.btsFlags |= (ushort)(0x0040);
            if (pBt.nPage != sqlite3Get4byte(&amp;pPage1.aData[28]))
            {
                rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
                if ((rc) == (0))
                {
                    sqlite3Put4byte(&amp;pPage1.aData[28], (uint)(pBt.nPage));
                }
            }
        }
    }

    trans_begun:
        ; if  ( ( rc ) == ( 0 ) ) { if  ( ( pSchemaVersion ) != null ) { * pSchemaVersion  =  ( int ) ( sqlite3Get4byte ( &amp; pBt . pPage1 . aData [ 40 ] ) ) ;  } if  ( ( wrflag ) != 0 ) { rc  =  ( int ) ( sqlite3PagerOpenSavepoint ( pPager ,  ( int ) ( p . db . nSavepoint ) ) ) ;  } }
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeCheckpoint(Btree p, int eMode, int* pnLog, int* pnCkpt)
{
    int rc = (int)(0);
    if ((p) != null)
    {
        BtShared pBt = p.pBt;
        sqlite3BtreeEnter(p);
        if (pBt.inTransaction != 0)
        {
            rc = (int)(6);
        }
        else
        {
            rc = (int)(sqlite3PagerCheckpoint(pBt.pPager, p.db, (int)(eMode), pnLog, pnCkpt));
        }

        sqlite3BtreeLeave(p);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3BtreeClearCursor(BtCursor pCur)
{
    sqlite3_free(pCur.pKey);
    pCur.pKey = null;
    pCur.eState = (byte)(1);
}</function>
  <function>public static int sqlite3BtreeClearTable(Btree p, int iTable, long* pnChange)
{
    int rc = 0;
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    rc = (int)(saveAllCursors(pBt, (uint)(iTable), null));
    if ((0) == (rc))
    {
        if ((p.hasIncrblobCur) != 0)
        {
            invalidateIncrblobCursors(p, (uint)(iTable), (long)(0), (int)(1));
        }

        rc = (int)(clearDatabasePage(pBt, (uint)(iTable), (int)(0), pnChange));
    }

    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeClearTableOfCursor(BtCursor pCur)
{
    return (int)(sqlite3BtreeClearTable(pCur.pBtree, (int)(pCur.pgnoRoot), null));
}</function>
  <function>public static int sqlite3BtreeClose(Btree p)
{
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    sqlite3BtreeRollback(p, (int)(0), (int)(0));
    sqlite3BtreeLeave(p);
    if ((p.sharable == 0) || ((removeFromSharingList(pBt)) != 0))
    {
        sqlite3PagerClose(pBt.pPager, p.db);
        if (((pBt.xFreeSchema) != null) &amp;&amp; ((pBt.pSchema) != null))
        {
            pBt.xFreeSchema(pBt.pSchema);
        }

        sqlite3DbFree(null, pBt.pSchema);
        freeTempSpace(pBt);
        sqlite3_free(pBt);
    }

    if ((p.pPrev) != null)
        p.pPrev.pNext = p.pNext;
    if ((p.pNext) != null)
        p.pNext.pPrev = p.pPrev;
    sqlite3_free(p);
    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeCloseCursor(BtCursor pCur)
{
    Btree pBtree = pCur.pBtree;
    if ((pBtree) != null)
    {
        BtShared pBt = pCur.pBt;
        sqlite3BtreeEnter(pBtree);
        if ((pBt.pCursor) == (pCur))
        {
            pBt.pCursor = pCur.pNext;
        }
        else
        {
            BtCursor pPrev = pBt.pCursor;
            do
            {
                if ((pPrev.pNext) == (pCur))
                {
                    pPrev.pNext = pCur.pNext;
                    break;
                }

                pPrev = pPrev.pNext;
            }
            while ((pPrev) != null);
        }

        btreeReleaseAllCursorPages(pCur);
        unlockBtreeIfUnused(pBt);
        sqlite3_free(pCur.aOverflow);
        sqlite3_free(pCur.pKey);
        if (((pBt.openFlags &amp; 4) != 0) &amp;&amp; ((pBt.pCursor) == (null)))
        {
            sqlite3BtreeClose(pBtree);
        }
        else
        {
            sqlite3BtreeLeave(pBtree);
        }

        pCur.pBtree = null;
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeCommit(Btree p)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    rc = (int)(sqlite3BtreeCommitPhaseOne(p, null));
    if ((rc) == (0))
    {
        rc = (int)(sqlite3BtreeCommitPhaseTwo(p, (int)(0)));
    }

    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeCommitPhaseOne(Btree p, sbyte* zSuperJrnl)
{
    int rc = (int)(0);
    if ((p.inTrans) == (2))
    {
        BtShared pBt = p.pBt;
        sqlite3BtreeEnter(p);
        if ((pBt.autoVacuum) != 0)
        {
            rc = (int)(autoVacuumCommit(p));
            if (rc != 0)
            {
                sqlite3BtreeLeave(p);
                return (int)(rc);
            }
        }

        if ((pBt.bDoTruncate) != 0)
        {
            sqlite3PagerTruncateImage(pBt.pPager, (uint)(pBt.nPage));
        }

        rc = (int)(sqlite3PagerCommitPhaseOne(pBt.pPager, zSuperJrnl, (int)(0)));
        sqlite3BtreeLeave(p);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeCommitPhaseTwo(Btree p, int bCleanup)
{
    if ((p.inTrans) == (0))
        return (int)(0);
    sqlite3BtreeEnter(p);
    if ((p.inTrans) == (2))
    {
        int rc = 0;
        BtShared pBt = p.pBt;
        rc = (int)(sqlite3PagerCommitPhaseTwo(pBt.pPager));
        if ((rc != 0) &amp;&amp; ((bCleanup) == (0)))
        {
            sqlite3BtreeLeave(p);
            return (int)(rc);
        }

        p.iBDataVersion--;
        pBt.inTransaction = (byte)(1);
        btreeClearHasContent(pBt);
    }

    btreeEndTransaction(p);
    sqlite3BtreeLeave(p);
    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeConnectionCount(Btree p)
{
    return (int)(p.pBt.nRef);
}</function>
  <function>public static int sqlite3BtreeCopyFile(Btree pTo, Btree pFrom)
{
    int rc = 0;
    sqlite3_file pFd;
    sqlite3_backup b = new sqlite3_backup();
    sqlite3BtreeEnter(pTo);
    sqlite3BtreeEnter(pFrom);
    pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));
    if ((pFd.pMethods) != null)
    {
        long nByte = (long)(sqlite3BtreeGetPageSize(pFrom) * (long)(sqlite3BtreeLastPage(pFrom)));
        rc = (int)(sqlite3OsFileControl(pFd, (int)(11), &amp;nByte));
        if ((rc) == (12))
            rc = (int)(0);
        if ((rc) != 0)
            goto copy_finished;
    }

    CRuntime.memset(b, (int)(0), (ulong)(sizeof(sqlite3_backup)));
    b.pSrcDb = pFrom.db;
    b.pSrc = pFrom;
    b.pDest = pTo;
    b.iNext = (uint)(1);
    sqlite3_backup_step(b, (int)(0x7FFFFFFF));
    rc = (int)(sqlite3_backup_finish(b));
    if ((rc) == (0))
    {
        pTo.pBt.btsFlags &amp;= (ushort)(~0x0002);
    }
    else
    {
        sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
    }

    copy_finished:
        ; sqlite3BtreeLeave ( pFrom ) ; 
    sqlite3BtreeLeave(pTo);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeCount(sqlite3 db, BtCursor pCur, long* pnEntry)
{
    long nEntry = (long)(0);
    int rc = 0;
    rc = (int)(moveToRoot(pCur));
    if ((rc) == (16))
    {
        *pnEntry = (long)(0);
        return (int)(0);
    }

    while (((rc) == (0)) &amp;&amp; (0 == 0))
    {
        int iIdx = 0;
        MemPage pPage;
        pPage = pCur.pPage;
        if (((pPage.leaf) != 0) || (pPage.intKey == 0))
        {
            nEntry += (long)(pPage.nCell);
        }

        if ((pPage.leaf) != 0)
        {
            do
            {
                if ((pCur.iPage) == (0))
                {
                    *pnEntry = (long)(nEntry);
                    return (int)(moveToRoot(pCur));
                }

                moveToParent(pCur);
            }
            while ((pCur.ix) &gt;= (pCur.pPage.nCell));
            pCur.ix++;
            pPage = pCur.pPage;
        }

        iIdx = (int)(pCur.ix);
        if ((iIdx) == (pPage.nCell))
        {
            rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]))));
        }
        else
        {
            rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (iIdx)])))))))));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeCreateTable(Btree p, uint* piTable, int flags)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    rc = (int)(btreeCreateTable(p, piTable, (int)(flags)));
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeCursor(Btree p, uint iTable, int wrFlag, KeyInfo pKeyInfo, BtCursor pCur)
{
    if ((p.sharable) != 0)
    {
        return (int)(btreeCursorWithLock(p, (uint)(iTable), (int)(wrFlag), pKeyInfo, pCur));
    }
    else
    {
        return (int)(btreeCursor(p, (uint)(iTable), (int)(wrFlag), pKeyInfo, pCur));
    }
}</function>
  <function>public static int sqlite3BtreeCursorHasHint(BtCursor pCsr, uint mask)
{
    return (int)((pCsr.hints &amp; mask) != 0);
}</function>
  <function>public static int sqlite3BtreeCursorHasMoved(BtCursor pCur)
{
    return (int)(0 != *(byte*)(pCur));
}</function>
  <function>public static void sqlite3BtreeCursorHintFlags(BtCursor pCur, uint x)
{
    pCur.hints = (byte)(x);
}</function>
  <function>public static int sqlite3BtreeCursorIsValidNN(BtCursor pCur)
{
    return ((pCur.eState) == (0) ? 1 : 0);
}</function>
  <function>public static void sqlite3BtreeCursorPin(BtCursor pCur)
{
    pCur.curFlags |= (byte)(0x40);
}</function>
  <function>public static int sqlite3BtreeCursorRestore(BtCursor pCur, int* pDifferentRow)
{
    int rc = 0;
    rc = (int)((pCur.eState) &gt;= (3) ? btreeRestoreCursorPosition(pCur) : 0);
    if ((rc) != 0)
    {
        *pDifferentRow = (int)(1);
        return (int)(rc);
    }

    if (pCur.eState != 0)
    {
        *pDifferentRow = (int)(1);
    }
    else
    {
        *pDifferentRow = (int)(0);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeCursorSize()
{
    return (int)(((sizeof(BtCursor)) + 7) &amp; ~7);
}</function>
  <function>public static void sqlite3BtreeCursorUnpin(BtCursor pCur)
{
    pCur.curFlags &amp;= (byte)(~0x40);
}</function>
  <function>public static void sqlite3BtreeCursorZero(BtCursor p)
{
    CRuntime.memset(p, (int)(0), ((ulong)((0).pBt)));
}</function>
  <function>public static int sqlite3BtreeDelete(BtCursor pCur, byte flags)
{
    Btree p = pCur.pBtree;
    BtShared pBt = p.pBt;
    int rc = 0;
    MemPage pPage;
    byte* pCell;
    int iCellIdx = 0;
    int iCellDepth = 0;
    CellInfo info = new CellInfo();
    byte bPreserve = 0;
    if (pCur.eState != 0)
    {
        if ((pCur.eState) &gt;= (3))
        {
            rc = (int)(btreeRestoreCursorPosition(pCur));
            if (((rc) != 0) || (pCur.eState != 0))
                return (int)(rc);
        }
        else
        {
            return (int)(sqlite3CorruptError((int)(75436)));
        }
    }

    iCellDepth = (int)(pCur.iPage);
    iCellIdx = (int)(pCur.ix);
    pPage = pCur.pPage;
    if ((pPage.nCell) &lt;= (iCellIdx))
    {
        return (int)(sqlite3CorruptError((int)(75445)));
    }

    pCell = ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (iCellIdx)])))));
    if (((pPage.nFree) &lt; (0)) &amp;&amp; ((btreeComputeFreeSpace(pPage)) != 0))
    {
        return (int)(sqlite3CorruptError((int)(75449)));
    }

    bPreserve = (byte)((flags &amp; 0x02) != 0);
    if ((bPreserve) != 0)
    {
        if (((pPage.leaf == 0) || ((pPage.nFree + cellSizePtr(pPage, pCell) + 2) &gt; ((int)(pBt.usableSize * 2 / 3)))) || ((pPage.nCell) == (1)))
        {
            rc = (int)(saveCursorKey(pCur));
            if ((rc) != 0)
                return (int)(rc);
        }
        else
        {
            bPreserve = (byte)(2);
        }
    }

    if (pPage.leaf == 0)
    {
        rc = (int)(sqlite3BtreePrevious(pCur, (int)(0)));
        if ((rc) != 0)
            return (int)(rc);
    }

    if ((pCur.curFlags &amp; 0x20) != 0)
    {
        rc = (int)(saveAllCursors(pBt, (uint)(pCur.pgnoRoot), pCur));
        if ((rc) != 0)
            return (int)(rc);
    }

    if (((pCur.pKeyInfo) == (null)) &amp;&amp; ((p.hasIncrblobCur) != 0))
    {
        invalidateIncrblobCursors(p, (uint)(pCur.pgnoRoot), (long)(pCur.info.nKey), (int)(0));
    }

    rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
    if ((rc) != 0)
        return (int)(rc);
    pPage.xParseCell(pPage, pCell, &amp;info);
    if (info.nLocal != info.nPayload)
    {
        rc = (int)(clearCellOverflow(pPage, pCell, &amp;info));
    }
    else
    {
        rc = (int)(0);
    }

    dropCell(pPage, (int)(iCellIdx), (int)(info.nSize), &amp;rc);
    if ((rc) != 0)
        return (int)(rc);
    if (pPage.leaf == 0)
    {
        MemPage pLeaf = pCur.pPage;
        int nCell = 0;
        uint n = 0;
        byte* pTmp;
        if ((pLeaf.nFree) &lt; (0))
        {
            rc = (int)(btreeComputeFreeSpace(pLeaf));
            if ((rc) != 0)
                return (int)(rc);
        }

        if ((iCellDepth) &lt; (pCur.iPage - 1))
        {
            n = (uint)(pCur.apPage[iCellDepth + 1].pgno);
        }
        else
        {
            n = (uint)(pCur.pPage.pgno);
        }

        pCell = ((pLeaf).aData + ((pLeaf).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pLeaf).aCellIdx[2 * (pLeaf.nCell - 1)])))));
        if ((pCell) &lt; (&amp;pLeaf.aData[4]))
            return (int)(sqlite3CorruptError((int)(75539)));
        nCell = (int)(pLeaf.xCellSize(pLeaf, pCell));
        pTmp = pBt.pTmpSpace;
        rc = (int)(sqlite3PagerWrite(pLeaf.pDbPage));
        if ((rc) == (0))
        {
            insertCell(pPage, (int)(iCellIdx), pCell - 4, (int)(nCell + 4), pTmp, (uint)(n), &amp;rc);
        }

        dropCell(pLeaf, (int)(pLeaf.nCell - 1), (int)(nCell), &amp;rc);
        if ((rc) != 0)
            return (int)(rc);
    }

    rc = (int)(balance(pCur));
    if (((rc) == (0)) &amp;&amp; ((pCur.iPage) &gt; (iCellDepth)))
    {
        releasePageNotNull(pCur.pPage);
        pCur.iPage--;
        while ((pCur.iPage) &gt; (iCellDepth))
        {
            releasePage(pCur.apPage[pCur.iPage--]);
        }

        pCur.pPage = pCur.apPage[pCur.iPage];
        rc = (int)(balance(pCur));
    }

    if ((rc) == (0))
    {
        if ((bPreserve) &gt; (1))
        {
            pCur.eState = (byte)(2);
            if ((iCellIdx) &gt;= (pPage.nCell))
            {
                pCur.skipNext = (int)(-1);
                pCur.ix = (ushort)(pPage.nCell - 1);
            }
            else
            {
                pCur.skipNext = (int)(1);
            }
        }
        else
        {
            rc = (int)(moveToRoot(pCur));
            if ((bPreserve) != 0)
            {
                btreeReleaseAllCursorPages(pCur);
                pCur.eState = (byte)(3);
            }

            if ((rc) == (16))
                rc = (int)(0);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeDropTable(Btree p, int iTable, int* piMoved)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    rc = (int)(btreeDropTable(p, (uint)(iTable), piMoved));
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static void sqlite3BtreeEnter(Btree p)
{
    if (p.sharable == 0)
        return;
    p.wantToLock++;
    if ((p.locked) != 0)
        return;
    btreeLockCarefully(p);
}</function>
  <function>public static void sqlite3BtreeEnterAll(sqlite3 db)
{
    if ((db.noSharedCache) == (0))
        btreeEnterAll(db);
}</function>
  <function>public static void sqlite3BtreeEnterCursor(BtCursor pCur)
{
    sqlite3BtreeEnter(pCur.pBtree);
}</function>
  <function>public static int sqlite3BtreeEof(BtCursor pCur)
{
    return (int)(0 != pCur.eState);
}</function>
  <function>public static BtCursor sqlite3BtreeFakeValidCursor()
{
    return (BtCursor)(&amp;sqlite3BtreeFakeValidCursor_fakeCursor);
}</function>
  <function>public static int sqlite3BtreeFirst(BtCursor pCur, int* pRes)
{
    int rc = 0;
    rc = (int)(moveToRoot(pCur));
    if ((rc) == (0))
    {
        *pRes = (int)(0);
        rc = (int)(moveToLeftmost(pCur));
    }
    else if ((rc) == (16))
    {
        *pRes = (int)(1);
        rc = (int)(0);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeGetAutoVacuum(Btree p)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    rc = (int)((!p.pBt.autoVacuum) ? 0 : (!p.pBt.incrVacuum) ? 1 : 2);
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3BtreeGetFilename(Btree p)
{
    return sqlite3PagerFilename(p.pBt.pPager, (int)(1));
}</function>
  <function>public static sbyte* sqlite3BtreeGetJournalname(Btree p)
{
    return sqlite3PagerJournalname(p.pBt.pPager);
}</function>
  <function>public static void sqlite3BtreeGetMeta(Btree p, int idx, uint* pMeta)
{
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    if ((idx) == (15))
    {
        *pMeta = (uint)(sqlite3PagerDataVersion(pBt.pPager) + p.iBDataVersion);
    }
    else
    {
        *pMeta = (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[36 + idx * 4]));
    }

    sqlite3BtreeLeave(p);
}</function>
  <function>public static int sqlite3BtreeGetPageSize(Btree p)
{
    return (int)(p.pBt.pageSize);
}</function>
  <function>public static int sqlite3BtreeGetRequestedReserve(Btree p)
{
    int n1 = 0; int  n2  =  0 ; 
    sqlite3BtreeEnter(p);
    n1 = ((int)(p.pBt.nReserveWanted));
    n2 = (int)(sqlite3BtreeGetReserveNoMutex(p));
    sqlite3BtreeLeave(p);
    return (int)((n1) &gt; (n2) ? n1 : n2);
}</function>
  <function>public static int sqlite3BtreeGetReserveNoMutex(Btree p)
{
    int n = 0;
    n = (int)(p.pBt.pageSize - p.pBt.usableSize);
    return (int)(n);
}</function>
  <function>public static void sqlite3BtreeIncrblobCursor(BtCursor pCur)
{
    pCur.curFlags |= (byte)(0x10);
    pCur.pBtree.hasIncrblobCur = (byte)(1);
}</function>
  <function>public static int sqlite3BtreeIncrVacuum(Btree p)
{
    int rc = 0;
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    if (pBt.autoVacuum == 0)
    {
        rc = (int)(101);
    }
    else
    {
        uint nOrig = (uint)(btreePagecount(pBt));
        uint nFree = (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[36]));
        uint nFin = (uint)(finalDbSize(pBt, (uint)(nOrig), (uint)(nFree)));
        if (((nOrig) &lt; (nFin)) || ((nFree) &gt;= (nOrig)))
        {
            rc = (int)(sqlite3CorruptError((int)(70108)));
        }
        else if ((nFree) &gt; (0))
        {
            rc = (int)(saveAllCursors(pBt, (uint)(0), null));
            if ((rc) == (0))
            {
                invalidateAllOverflowCache(pBt);
                rc = (int)(incrVacuumStep(pBt, (uint)(nFin), (uint)(nOrig), (int)(0)));
            }

            if ((rc) == (0))
            {
                rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
                sqlite3Put4byte(&amp;pBt.pPage1.aData[28], (uint)(pBt.nPage));
            }
        }
        else
        {
            rc = (int)(101);
        }
    }

    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeIndexMoveto(BtCursor pCur, UnpackedRecord pIdxKey, int* pRes)
{
    int rc = 0;
    delegate157 xRecordCompare;
    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
    pIdxKey.errCode = (byte)(0);
    rc = (int)(moveToRoot(pCur));
    if ((rc) != 0)
    {
        if ((rc) == (16))
        {
            *pRes = (int)(-1);
            return (int)(0);
        }

        return (int)(rc);
    }

    for (;;)
    {
        int lwr = 0;
        int upr = 0;
        int idx = 0;
        int c = 0;
        uint chldPg = 0;
        MemPage pPage = pCur.pPage;
        byte* pCell;
        lwr = (int)(0);
        upr = (int)(pPage.nCell - 1);
        idx = (int)(upr &gt;&gt; 1);
        for (;;)
        {
            int nCell = 0;
            pCell = ((pPage).aDataOfst + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (idx)])))));
            nCell = (int)(pCell[0]);
            if ((nCell) &lt;= (pPage.max1bytePayload))
            {
                c = (int)(xRecordCompare((int)(nCell), (void*)(&amp;pCell[1]), pIdxKey));
            }
            else if (((pCell[1] &amp; 0x80) == 0) &amp;&amp; ((nCell = (int)(((nCell &amp; 0x7f) &lt;&lt; 7) + pCell[1])) &lt;= (pPage.maxLocal)))
            {
                c = (int)(xRecordCompare((int)(nCell), (void*)(&amp;pCell[2]), pIdxKey));
            }
            else
            {
                void* pCellKey;
                byte* pCellBody = pCell - pPage.childPtrSize;
                int nOverrun = (int)(18);
                pPage.xParseCell(pPage, pCellBody, &amp;pCur.info);
                nCell = ((int)(pCur.info.nKey));
                if (((nCell) &lt; (2)) || ((nCell / pCur.pBt.usableSize) &gt; (pCur.pBt.nPage)))
                {
                    rc = (int)(sqlite3CorruptError((int)(71931)));
                    goto moveto_index_finish;
                }

                pCellKey = sqlite3Malloc((ulong)(nCell + nOverrun));
                if ((pCellKey) == (null))
                {
                    rc = (int)(7);
                    goto moveto_index_finish;
                }

                pCur.ix = ((ushort)(idx));
                rc = (int)(accessPayload(pCur, (uint)(0), (uint)(nCell), (byte*)(pCellKey), (int)(0)));
                CRuntime.memset(((byte*)(pCellKey)) + nCell, (int)(0), (ulong)(nOverrun));
                pCur.curFlags &amp;= (byte)(~0x04);
                if ((rc) != 0)
                {
                    sqlite3_free(pCellKey);
                    goto moveto_index_finish;
                }

                c = (int)(sqlite3VdbeRecordCompare((int)(nCell), pCellKey, pIdxKey));
                sqlite3_free(pCellKey);
            }

            if ((c) &lt; (0))
            {
                lwr = (int)(idx + 1);
            }
            else if ((c) &gt; (0))
            {
                upr = (int)(idx - 1);
            }
            else
            {
                *pRes = (int)(0);
                rc = (int)(0);
                pCur.ix = ((ushort)(idx));
                if ((pIdxKey.errCode) != 0)
                    rc = (int)(sqlite3CorruptError((int)(71963)));
                goto moveto_index_finish;
            }

            if ((lwr) &gt; (upr))
                break;
            idx = (int)((lwr + upr) &gt;&gt; 1);
        }

        if ((pPage.leaf) != 0)
        {
            pCur.ix = ((ushort)(idx));
            *pRes = (int)(c);
            rc = (int)(0);
            goto moveto_index_finish;
        }

        if ((lwr) &gt;= (pPage.nCell))
        {
            chldPg = (uint)(sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]));
        }
        else
        {
            chldPg = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (lwr)])))))));
        }

        pCur.ix = ((ushort)(lwr));
        rc = (int)(moveToChild(pCur, (uint)(chldPg)));
        if ((rc) != 0)
            break;
    }

    moveto_index_finish:
        ; pCur . info . nSize  =  ( ushort ) ( 0 ) ; 
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeInsert(BtCursor pCur, BtreePayload pX, int flags, int seekResult)
{
    int rc = 0;
    int loc = (int)(seekResult);
    int szNew = (int)(0);
    int idx = 0;
    MemPage pPage;
    Btree p = pCur.pBtree;
    BtShared pBt = p.pBt;
    byte* oldCell;
    byte* newCell = null;
    if ((pCur.curFlags &amp; 0x20) != 0)
    {
        rc = (int)(saveAllCursors(pBt, (uint)(pCur.pgnoRoot), pCur));
        if ((rc) != 0)
            return (int)(rc);
        if (((loc) != 0) &amp;&amp; ((pCur.iPage) &lt; (0)))
        {
            return (int)(sqlite3CorruptError((int)(75033)));
        }
    }

    if ((pCur.eState) &gt;= (3))
    {
        rc = (int)(moveToRoot(pCur));
        if (((rc) != 0) &amp;&amp; (rc != 16))
            return (int)(rc);
    }

    if ((pCur.pKeyInfo) == (null))
    {
        if ((p.hasIncrblobCur) != 0)
        {
            invalidateIncrblobCursors(p, (uint)(pCur.pgnoRoot), (long)(pX.nKey), (int)(0));
        }

        if (((pCur.curFlags &amp; 0x02) != 0) &amp;&amp; ((pX.nKey) == (pCur.info.nKey)))
        {
            if ((pCur.info.nSize != 0) &amp;&amp; ((pCur.info.nPayload) == ((uint)(pX.nData) + pX.nZero)))
            {
                return (int)(btreeOverwriteCell(pCur, pX));
            }
        }
        else if ((loc) == (0))
        {
            rc = (int)(sqlite3BtreeTableMoveto(pCur, (long)(pX.nKey), (int)((flags &amp; 0x08) != 0), &amp;loc));
            if ((rc) != 0)
                return (int)(rc);
        }
    }
    else
    {
        if (((loc) == (0)) &amp;&amp; ((flags &amp; 0x02) == (0)))
        {
            if ((pX.nMem) != 0)
            {
                UnpackedRecord r = new UnpackedRecord();
                r.pKeyInfo = pCur.pKeyInfo;
                r.aMem = pX.aMem;
                r.nField = (ushort)(pX.nMem);
                r.default_rc = (sbyte)(0);
                r.eqSeen = (byte)(0);
                rc = (int)(sqlite3BtreeIndexMoveto(pCur, r, &amp;loc));
            }
            else
            {
                rc = (int)(btreeMoveto(pCur, pX.pKey, (long)(pX.nKey), (int)((flags &amp; 0x08) != 0), &amp;loc));
            }

            if ((rc) != 0)
                return (int)(rc);
        }

        if ((loc) == (0))
        {
            getCellInfo(pCur);
            if ((pCur.info.nKey) == (pX.nKey))
            {
                BtreePayload x2 = new BtreePayload();
                x2.pData = pX.pKey;
                x2.nData = (int)(pX.nKey);
                x2.nZero = (int)(0);
                return (int)(btreeOverwriteCell(pCur, x2));
            }
        }
    }

    pPage = pCur.pPage;
    if ((pPage.nFree) &lt; (0))
    {
        if ((pCur.eState) &gt; (1))
        {
            rc = (int)(sqlite3CorruptError((int)(75150)));
        }
        else
        {
            rc = (int)(btreeComputeFreeSpace(pPage));
        }

        if ((rc) != 0)
            return (int)(rc);
    }

    newCell = pBt.pTmpSpace;
    if ((flags &amp; 0x80) != 0)
    {
        rc = (int)(0);
        szNew = (int)(pBt.nPreformatSize);
        if ((szNew) &lt; (4))
            szNew = (int)(4);
        if (((pBt.autoVacuum) != 0) &amp;&amp; ((szNew) &gt; (pPage.maxLocal)))
        {
            CellInfo info = new CellInfo();
            pPage.xParseCell(pPage, newCell, &amp;info);
            if (info.nPayload != info.nLocal)
            {
                uint ovfl = (uint)(sqlite3Get4byte(&amp;newCell[szNew - 4]));
                ptrmapPut(pBt, (uint)(ovfl), (byte)(3), (uint)(pPage.pgno), &amp;rc);
            }
        }
    }
    else
    {
        rc = (int)(fillInCell(pPage, newCell, pX, &amp;szNew));
    }

    if ((rc) != 0)
        goto end_insert;
    idx = (int)(pCur.ix);
    if ((loc) == (0))
    {
        CellInfo info = new CellInfo();
        if ((idx) &gt;= (pPage.nCell))
        {
            return (int)(sqlite3CorruptError((int)(75186)));
        }

        rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
        if ((rc) != 0)
        {
            goto end_insert;
        }

        oldCell = ((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (idx)])))));
        if (pPage.leaf == 0)
        {
            CRuntime.memcpy(newCell, oldCell, (ulong)(4));
        }

        pPage.xParseCell(pPage, oldCell, &amp;info);
        if (info.nLocal != info.nPayload)
        {
            rc = (int)(clearCellOverflow(pPage, oldCell, &amp;info));
        }
        else
        {
            rc = (int)(0);
        }

        (pCur.curFlags &amp;= (byte)(~0x04));
        if ((((info.nSize) == (szNew)) &amp;&amp; ((info.nLocal) == (info.nPayload))) &amp;&amp; (((pBt.autoVacuum) == 0) || ((szNew) &lt; (pPage.minLocal))))
        {
            if ((oldCell) &lt; (pPage.aData + pPage.hdrOffset + 10))
            {
                return (int)(sqlite3CorruptError((int)(75213)));
            }

            if ((oldCell + szNew) &gt; (pPage.aDataEnd))
            {
                return (int)(sqlite3CorruptError((int)(75216)));
            }

            CRuntime.memcpy(oldCell, newCell, (ulong)(szNew));
            return (int)(0);
        }

        dropCell(pPage, (int)(idx), (int)(info.nSize), &amp;rc);
        if ((rc) != 0)
            goto end_insert;
    }
    else if (((loc) &lt; (0)) &amp;&amp; ((pPage.nCell) &gt; (0)))
    {
        idx = (int)(++pCur.ix);
        pCur.curFlags &amp;= (byte)(~0x02);
    }
    else
    {
    }

    insertCell(pPage, (int)(idx), newCell, (int)(szNew), null, (uint)(0), &amp;rc);
    pCur.info.nSize = (ushort)(0);
    if ((pPage.nOverflow) != 0)
    {
        pCur.curFlags &amp;= (byte)(~(0x02));
        rc = (int)(balance(pCur));
        pCur.pPage.nOverflow = (byte)(0);
        pCur.eState = (byte)(1);
        if (((flags &amp; 0x02) != 0) &amp;&amp; ((rc) == (0)))
        {
            btreeReleaseAllCursorPages(pCur);
            if ((pCur.pKeyInfo) != null)
            {
                pCur.pKey = sqlite3Malloc((ulong)(pX.nKey));
                if ((pCur.pKey) == (null))
                {
                    rc = (int)(7);
                }
                else
                {
                    CRuntime.memcpy(pCur.pKey, pX.pKey, (ulong)(pX.nKey));
                }
            }

            pCur.eState = (byte)(3);
            pCur.nKey = (long)(pX.nKey);
        }
    }

    end_insert:
        ; return  ( int ) ( rc ) ; 
}</function>
  <function>public static long sqlite3BtreeIntegerKey(BtCursor pCur)
{
    getCellInfo(pCur);
    return (long)(pCur.info.nKey);
}</function>
  <function>public static sbyte* sqlite3BtreeIntegrityCheck(sqlite3 db, Btree p, uint* aRoot, int nRoot, int mxErr, int* pnErr)
{
    uint i = 0;
    IntegrityCk sCheck = new IntegrityCk();
    BtShared pBt = p.pBt;
    ulong savedDbFlags = (ulong)(pBt.db.flags);
    sbyte* zErr = stackalloc sbyte[100];
    int bPartial = (int)(0);
    int bCkFreelist = (int)(1);
    if ((aRoot[0]) == (0))
    {
        bPartial = (int)(1);
        if (aRoot[1] != 1)
            bCkFreelist = (int)(0);
    }

    sqlite3BtreeEnter(p);
    sCheck.db = db;
    sCheck.pBt = pBt;
    sCheck.pPager = pBt.pPager;
    sCheck.nPage = (uint)(btreePagecount(sCheck.pBt));
    sCheck.mxErr = (int)(mxErr);
    sCheck.nErr = (int)(0);
    sCheck.bOomFault = (int)(0);
    sCheck.zPfx = null;
    sCheck.v1 = (uint)(0);
    sCheck.v2 = (int)(0);
    sCheck.aPgRef = null;
    sCheck.heap = null;
    sqlite3StrAccumInit(sCheck.errMsg, null, zErr, (int)(100 * sizeof(sbyte)), (int)(1000000000));
    sCheck.errMsg.printfFlags = (byte)(0x01);
    if ((sCheck.nPage) == (0))
    {
        goto integrity_ck_cleanup;
    }

    sCheck.aPgRef = sqlite3MallocZero((ulong)((sCheck.nPage / 8) + 1));
    if (sCheck.aPgRef == null)
    {
        sCheck.bOomFault = (int)(1);
        goto integrity_ck_cleanup;
    }

    sCheck.heap = (uint*)(sqlite3PageMalloc((int)(pBt.pageSize)));
    if ((sCheck.heap) == (null))
    {
        sCheck.bOomFault = (int)(1);
        goto integrity_ck_cleanup;
    }

    i = (uint)((sqlite3PendingByte / ((pBt).pageSize)) + 1);
    if ((i) &lt;= (sCheck.nPage))
        setPageReferenced(sCheck, (uint)(i));
    if ((bCkFreelist) != 0)
    {
        sCheck.zPfx = "Main freelist: ";
        checkList(sCheck, (int)(1), (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[32])), (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[36])));
        sCheck.zPfx = null;
    }

    if (bPartial == 0)
    {
        if ((pBt.autoVacuum) != 0)
        {
            uint mx = (uint)(0);
            uint mxInHdr = 0;
            for (i = (uint)(0); ((int)(i)) &lt; (nRoot); i++)
            {
                if ((mx) &lt; (aRoot[i]))
                    mx = (uint)(aRoot[i]);
            }

            mxInHdr = (uint)(sqlite3Get4byte(&amp;pBt.pPage1.aData[52]));
            if (mx != mxInHdr)
            {
                checkAppendMsg(sCheck, "max rootpage (%d) disagrees with header (%d)", (uint)(mx), (uint)(mxInHdr));
            }
        }
        else if (sqlite3Get4byte(&amp;pBt.pPage1.aData[64]) != 0)
        {
            checkAppendMsg(sCheck, "incremental_vacuum enabled with a max rootpage of zero");
        }
    }

    pBt.db.flags &amp;= (ulong)(~(ulong)(0x00200000));
    for (i = (uint)(0); (((int)(i)) &lt; (nRoot)) &amp;&amp; ((sCheck.mxErr) != 0); i++)
    {
        long notUsed = 0;
        if ((aRoot[i]) == (0))
            continue;
        if ((((pBt.autoVacuum) != 0) &amp;&amp; ((aRoot[i]) &gt; (1))) &amp;&amp; (bPartial == 0))
        {
            checkPtrmap(sCheck, (uint)(aRoot[i]), (byte)(1), (uint)(0));
        }

        checkTreePage(sCheck, (uint)(aRoot[i]), &amp;notUsed, (long)(0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)));
    }

    pBt.db.flags = (ulong)(savedDbFlags);
    if (bPartial == 0)
    {
        for (i = (uint)(1); ((i) &lt;= (sCheck.nPage)) &amp;&amp; ((sCheck.mxErr) != 0); i++)
        {
            if (((getPageReferenced(sCheck, (uint)(i))) == (0)) &amp;&amp; ((ptrmapPageno(pBt, (uint)(i)) != i) || (pBt.autoVacuum == 0)))
            {
                checkAppendMsg(sCheck, "Page %d is never used", (uint)(i));
            }

            if ((getPageReferenced(sCheck, (uint)(i)) != 0) &amp;&amp; (((ptrmapPageno(pBt, (uint)(i))) == (i)) &amp;&amp; ((pBt.autoVacuum) != 0)))
            {
                checkAppendMsg(sCheck, "Pointer map page %d is referenced", (uint)(i));
            }
        }
    }

    integrity_ck_cleanup:
        ; sqlite3PageFree ( sCheck . heap ) ; 
    sqlite3_free(sCheck.aPgRef);
    if ((sCheck.bOomFault) != 0)
    {
        sqlite3_str_reset(sCheck.errMsg);
        sCheck.nErr++;
    }

    *pnErr = (int)(sCheck.nErr);
    if ((sCheck.nErr) == (0))
        sqlite3_str_reset(sCheck.errMsg);
    sqlite3BtreeLeave(p);
    return sqlite3StrAccumFinish(sCheck.errMsg);
}</function>
  <function>public static int sqlite3BtreeIsInBackup(Btree p)
{
    return (int)(p.nBackup != 0);
}</function>
  <function>public static int sqlite3BtreeIsReadonly(Btree p)
{
    return (int)((p.pBt.btsFlags &amp; 0x0001) != 0);
}</function>
  <function>public static int sqlite3BtreeLast(BtCursor pCur, int* pRes)
{
    int rc = 0;
    if (((0) == (pCur.eState)) &amp;&amp; ((pCur.curFlags &amp; 0x08) != 0))
    {
        *pRes = (int)(0);
        return (int)(0);
    }

    rc = (int)(moveToRoot(pCur));
    if ((rc) == (0))
    {
        *pRes = (int)(0);
        rc = (int)(moveToRightmost(pCur));
        if ((rc) == (0))
        {
            pCur.curFlags |= (byte)(0x08);
        }
        else
        {
            pCur.curFlags &amp;= (byte)(~0x08);
        }
    }
    else if ((rc) == (16))
    {
        *pRes = (int)(1);
        rc = (int)(0);
    }

    return (int)(rc);
}</function>
  <function>public static uint sqlite3BtreeLastPage(Btree p)
{
    return (uint)(btreePagecount(p.pBt));
}</function>
  <function>public static void sqlite3BtreeLeave(Btree p)
{
    if ((p.sharable) != 0)
    {
        p.wantToLock--;
        if ((p.wantToLock) == (0))
        {
            unlockBtreeMutex(p);
        }
    }
}</function>
  <function>public static void sqlite3BtreeLeaveAll(sqlite3 db)
{
    if ((db.noSharedCache) == (0))
        btreeLeaveAll(db);
}</function>
  <function>public static void sqlite3BtreeLeaveCursor(BtCursor pCur)
{
    sqlite3BtreeLeave(pCur.pBtree);
}</function>
  <function>public static int sqlite3BtreeLockTable(Btree p, int iTab, byte isWriteLock)
{
    int rc = (int)(0);
    if ((p.sharable) != 0)
    {
        byte lockType = (byte)(1 + isWriteLock);
        sqlite3BtreeEnter(p);
        rc = (int)(querySharedCacheTableLock(p, (uint)(iTab), (byte)(lockType)));
        if ((rc) == (0))
        {
            rc = (int)(setSharedCacheTableLock(p, (uint)(iTab), (byte)(lockType)));
        }

        sqlite3BtreeLeave(p);
    }

    return (int)(rc);
}</function>
  <function>public static uint sqlite3BtreeMaxPageCount(Btree p, uint mxPage)
{
    uint n = 0;
    sqlite3BtreeEnter(p);
    n = (uint)(sqlite3PagerMaxPageCount(p.pBt.pPager, (uint)(mxPage)));
    sqlite3BtreeLeave(p);
    return (uint)(n);
}</function>
  <function>public static long sqlite3BtreeMaxRecordSize(BtCursor pCur)
{
    return (long)(pCur.pBt.pageSize * (long)(pCur.pBt.nPage));
}</function>
  <function>public static int sqlite3BtreeNewDb(Btree p)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    p.pBt.nPage = (uint)(0);
    rc = (int)(newDatabase(p.pBt));
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeNext(BtCursor pCur, int flags)
{
    MemPage pPage;
    pCur.info.nSize = (ushort)(0);
    pCur.curFlags &amp;= (byte)(~(0x02 | 0x04));
    if (pCur.eState != 0)
        return (int)(btreeNext(pCur));
    pPage = pCur.pPage;
    if ((++pCur.ix) &gt;= (pPage.nCell))
    {
        pCur.ix--;
        return (int)(btreeNext(pCur));
    }

    if ((pPage.leaf) != 0)
    {
        return (int)(0);
    }
    else
    {
        return (int)(moveToLeftmost(pCur));
    }
}</function>
  <function>public static int sqlite3BtreeOpen(sqlite3_vfs pVfs, sbyte* zFilename, sqlite3 db, Btree ppBtree, int flags, int vfsFlags)
{
    BtShared pBt = null;
    Btree p;
    sqlite3_mutex* mutexOpen = null;
    int rc = (int)(0);
    byte nReserve = 0;
    byte* zDbHeader = stackalloc byte[100];
    int isTempDb = (int)(((zFilename) == (null)) || ((zFilename[0]) == (0)) ? 1 : 0);
    int isMemdb = (int)(((((zFilename) != null) &amp;&amp; ((CRuntime.strcmp(zFilename, ":memory:")) == (0))) || (((isTempDb) != 0) &amp;&amp; ((sqlite3TempInMemory(db)) != 0))) || ((vfsFlags &amp; 0x00000080) != 0) ? 1 : 0);
    if ((isMemdb) != 0)
    {
        flags |= (int)(2);
    }

    if (((vfsFlags &amp; 0x00000100) != 0) &amp;&amp; (((isMemdb) != 0) || ((isTempDb) != 0)))
    {
        vfsFlags = (int)((vfsFlags &amp; ~0x00000100) | 0x00000200);
    }

    p = sqlite3MallocZero((ulong)(sizeof(Btree)));
    if (p == null)
    {
        return (int)(7);
    }

    p.inTrans = (byte)(0);
    p.db = db;
    p._lock_.pBtree = p;
    p._lock_.iTable = (uint)(1);
    if (((isTempDb) == (0)) &amp;&amp; (((isMemdb) == (0)) || ((vfsFlags &amp; 0x00000040) != 0)))
    {
        if ((vfsFlags &amp; 0x00020000) != 0)
        {
            int nFilename = (int)(sqlite3Strlen30(zFilename) + 1);
            int nFullPathname = (int)(pVfs.mxPathname + 1);
            sbyte* zFullPathname = sqlite3Malloc((ulong)((nFullPathname) &gt; (nFilename) ? (nFullPathname) : (nFilename)));
            sqlite3_mutex* mutexShared;
            p.sharable = (byte)(1);
            if (zFullPathname == null)
            {
                sqlite3_free(p);
                return (int)(7);
            }

            if ((isMemdb) != 0)
            {
                CRuntime.memcpy(zFullPathname, zFilename, (ulong)(nFilename));
            }
            else
            {
                rc = (int)(sqlite3OsFullPathname(pVfs, zFilename, (int)(nFullPathname), zFullPathname));
                if ((rc) != 0)
                {
                    if ((rc) == (0 | (2 &lt;&lt; 8)))
                    {
                        rc = (int)(0);
                    }
                    else
                    {
                        sqlite3_free(zFullPathname);
                        sqlite3_free(p);
                        return (int)(rc);
                    }
                }
            }

            mutexOpen = sqlite3MutexAlloc((int)(4));
            sqlite3_mutex_enter(mutexOpen);
            mutexShared = sqlite3MutexAlloc((int)(2));
            sqlite3_mutex_enter(mutexShared);
            for (pBt = sqlite3SharedCacheList; pBt; pBt = pBt.pNext)
            {
                if (((0) == (CRuntime.strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager, (int)(0))))) &amp;&amp; ((sqlite3PagerVfs(pBt.pPager)) == (pVfs)))
                {
                    int iDb = 0;
                    for (iDb = (int)(db.nDb - 1); (iDb) &gt;= (0); iDb--)
                    {
                        Btree pExisting = db.aDb[iDb].pBt;
                        if (((pExisting) != null) &amp;&amp; ((pExisting.pBt) == (pBt)))
                        {
                            sqlite3_mutex_leave(mutexShared);
                            sqlite3_mutex_leave(mutexOpen);
                            sqlite3_free(zFullPathname);
                            sqlite3_free(p);
                            return (int)(19);
                        }
                    }

                    p.pBt = pBt;
                    pBt.nRef++;
                    break;
                }
            }

            sqlite3_mutex_leave(mutexShared);
            sqlite3_free(zFullPathname);
        }
    }

    if ((pBt) == (null))
    {
        pBt = sqlite3MallocZero((ulong)(sizeof(BtShared)));
        if ((pBt) == (null))
        {
            rc = (int)(7);
            goto btree_open_out;
        }

        rc = (int)(sqlite3PagerOpen(pVfs, pBt.pPager, zFilename, (int)(sizeof(MemPage)), (int)(flags), (int)(vfsFlags), pageReinit));
        if ((rc) == (0))
        {
            sqlite3PagerSetMmapLimit(pBt.pPager, (long)(db.szMmap));
            rc = (int)(sqlite3PagerReadFileheader(pBt.pPager, (int)(100 * sizeof(byte)), zDbHeader));
        }

        if (rc != 0)
        {
            goto btree_open_out;
        }

        pBt.openFlags = ((byte)(flags));
        pBt.db = db;
        sqlite3PagerSetBusyHandler(pBt.pPager, btreeInvokeBusyHandler, pBt);
        p.pBt = pBt;
        pBt.pCursor = null;
        pBt.pPage1 = null;
        if ((sqlite3PagerIsreadonly(pBt.pPager)) != 0)
            pBt.btsFlags |= (ushort)(0x0001);
        pBt.pageSize = (uint)((zDbHeader[16] &lt;&lt; 8) | (zDbHeader[17] &lt;&lt; 16));
        if ((((pBt.pageSize) &lt; (512)) || ((pBt.pageSize) &gt; (65536))) || (((pBt.pageSize - 1) &amp; pBt.pageSize) != 0))
        {
            pBt.pageSize = (uint)(0);
            if (((zFilename) != null) &amp;&amp; (isMemdb == 0))
            {
                pBt.autoVacuum = (byte)((0) != 0 ? 1 : 0);
                pBt.incrVacuum = (byte)((0) == (2) ? 1 : 0);
            }

            nReserve = (byte)(0);
        }
        else
        {
            nReserve = (byte)(zDbHeader[20]);
            pBt.btsFlags |= (ushort)(0x0002);
            pBt.autoVacuum = (byte)((sqlite3Get4byte(&amp;zDbHeader[36 + 4 * 4])) != 0 ? 1 : 0);
            pBt.incrVacuum = (byte)((sqlite3Get4byte(&amp;zDbHeader[36 + 7 * 4])) != 0 ? 1 : 0);
        }

        rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &amp;pBt.pageSize, (int)(nReserve)));
        if ((rc) != 0)
            goto btree_open_out;
        pBt.usableSize = (uint)(pBt.pageSize - nReserve);
        pBt.nRef = (int)(1);
        if ((p.sharable) != 0)
        {
            sqlite3_mutex* mutexShared;
            mutexShared = sqlite3MutexAlloc((int)(2));
            if (((1) != 0) &amp;&amp; ((sqlite3Config.bCoreMutex) != 0))
            {
                pBt.mutex = sqlite3MutexAlloc((int)(0));
                if ((pBt.mutex) == (null))
                {
                    rc = (int)(7);
                    goto btree_open_out;
                }
            }

            sqlite3_mutex_enter(mutexShared);
            pBt.pNext = sqlite3SharedCacheList;
            sqlite3SharedCacheList = pBt;
            sqlite3_mutex_leave(mutexShared);
        }
    }

    if ((p.sharable) != 0)
    {
        int i = 0;
        Btree pSib;
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            if (((pSib = db.aDb[i].pBt) != null) &amp;&amp; ((pSib.sharable) != 0))
            {
                while ((pSib.pPrev) != null)
                {
                    pSib = pSib.pPrev;
                }

                if (((ulong)(p.pBt)) &lt; ((ulong)(pSib.pBt)))
                {
                    p.pNext = pSib;
                    p.pPrev = null;
                    pSib.pPrev = p;
                }
                else
                {
                    while (((pSib.pNext) != null) &amp;&amp; (((ulong)(pSib.pNext.pBt)) &lt; ((ulong)(p.pBt))))
                    {
                        pSib = pSib.pNext;
                    }

                    p.pNext = pSib.pNext;
                    p.pPrev = pSib;
                    if ((p.pNext) != null)
                    {
                        p.pNext.pPrev = p;
                    }

                    pSib.pNext = p;
                }

                break;
            }
        }
    }

    ppBtree = p;
    btree_open_out:
        ; if  ( rc != 0 ) { if  ( ( ( pBt ) != null ) &amp;&amp; ( ( pBt . pPager ) != null ) ) { sqlite3PagerClose ( pBt . pPager ,  null ) ;  } sqlite3_free ( pBt ) ;  sqlite3_free ( p ) ;  ppBtree  =  null ;  } else  { sqlite3_file  pFile ;  if  ( ( sqlite3BtreeSchema ( p ,  ( int ) ( 0 ) ,  null ) ) == ( null ) ) { sqlite3BtreeSetCacheSize ( p ,  ( int ) ( - 2000 ) ) ;  } pFile  =  sqlite3PagerFile ( pBt . pPager ) ;  if  ( ( pFile . pMethods ) != null ) { sqlite3OsFileControlHint ( pFile ,  ( int ) ( 30 ) ,  ( void  * ) ( pBt . db ) ) ;  } }
    if ((mutexOpen) != null)
    {
        sqlite3_mutex_leave(mutexOpen);
    }

    return (int)(rc);
}</function>
  <function>public static Pager sqlite3BtreePager(Btree p)
{
    return p.pBt.pPager;
}</function>
  <function>public static int sqlite3BtreePayload(BtCursor pCur, uint offset, uint amt, void* pBuf)
{
    return (int)(accessPayload(pCur, (uint)(offset), (uint)(amt), (byte*)(pBuf), (int)(0)));
}</function>
  <function>public static int sqlite3BtreePayloadChecked(BtCursor pCur, uint offset, uint amt, void* pBuf)
{
    if ((pCur.eState) == (0))
    {
        return (int)(accessPayload(pCur, (uint)(offset), (uint)(amt), pBuf, (int)(0)));
    }
    else
    {
        return (int)(accessPayloadChecked(pCur, (uint)(offset), (uint)(amt), pBuf));
    }
}</function>
  <function>public static void* sqlite3BtreePayloadFetch(BtCursor pCur, uint* pAmt)
{
    return fetchPayload(pCur, pAmt);
}</function>
  <function>public static uint sqlite3BtreePayloadSize(BtCursor pCur)
{
    getCellInfo(pCur);
    return (uint)(pCur.info.nPayload);
}</function>
  <function>public static int sqlite3BtreePrevious(BtCursor pCur, int flags)
{
    pCur.curFlags &amp;= (byte)(~(0x08 | 0x04 | 0x02));
    pCur.info.nSize = (ushort)(0);
    if (((pCur.eState != 0) || ((pCur.ix) == (0))) || ((pCur.pPage.leaf) == (0)))
    {
        return (int)(btreePrevious(pCur));
    }

    pCur.ix--;
    return (int)(0);
}</function>
  <function>public static int sqlite3BtreePutData(BtCursor pCsr, uint offset, uint amt, void* z)
{
    int rc = 0;
    rc = (int)((pCsr.eState) &gt;= (3) ? btreeRestoreCursorPosition(pCsr) : 0);
    if (rc != 0)
    {
        return (int)(rc);
    }

    if (pCsr.eState != 0)
    {
        return (int)(4);
    }

    saveAllCursors(pCsr.pBt, (uint)(pCsr.pgnoRoot), pCsr);
    if ((pCsr.curFlags &amp; 0x01) == (0))
    {
        return (int)(8);
    }

    return (int)(accessPayload(pCsr, (uint)(offset), (uint)(amt), (byte*)(z), (int)(1)));
}</function>
  <function>public static int sqlite3BtreeRollback(Btree p, int tripCode, int writeOnly)
{
    int rc = 0;
    BtShared pBt = p.pBt;
    MemPage pPage1;
    sqlite3BtreeEnter(p);
    if ((tripCode) == (0))
    {
        rc = (int)(tripCode = (int)(saveAllCursors(pBt, (uint)(0), null)));
        if ((rc) != 0)
            writeOnly = (int)(0);
    }
    else
    {
        rc = (int)(0);
    }

    if ((tripCode) != 0)
    {
        int rc2 = (int)(sqlite3BtreeTripAllCursors(p, (int)(tripCode), (int)(writeOnly)));
        if (rc2 != 0)
            rc = (int)(rc2);
    }

    if ((p.inTrans) == (2))
    {
        int rc2 = 0;
        rc2 = (int)(sqlite3PagerRollback(pBt.pPager));
        if (rc2 != 0)
        {
            rc = (int)(rc2);
        }

        if ((btreeGetPage(pBt, (uint)(1), pPage1, (int)(0))) == (0))
        {
            btreeSetNPage(pBt, pPage1);
            releasePageOne(pPage1);
        }

        pBt.inTransaction = (byte)(1);
        btreeClearHasContent(pBt);
    }

    btreeEndTransaction(p);
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static long sqlite3BtreeRowCountEst(BtCursor pCur)
{
    long n = 0;
    byte i = 0;
    if ((pCur.eState != 0))
        return (long)(-1);
    if (((pCur.pPage.leaf) == (0)))
        return (long)(-1);
    n = (long)(pCur.pPage.nCell);
    for (i = (byte)(0); (i) &lt; (pCur.iPage); i++)
    {
        n *= (long)(pCur.apPage[i].nCell);
    }

    return (long)(n);
}</function>
  <function>public static int sqlite3BtreeSavepoint(Btree p, int op, int iSavepoint)
{
    int rc = (int)(0);
    if (((p) != null) &amp;&amp; ((p.inTrans) == (2)))
    {
        BtShared pBt = p.pBt;
        sqlite3BtreeEnter(p);
        if ((op) == (2))
        {
            rc = (int)(saveAllCursors(pBt, (uint)(0), null));
        }

        if ((rc) == (0))
        {
            rc = (int)(sqlite3PagerSavepoint(pBt.pPager, (int)(op), (int)(iSavepoint)));
        }

        if ((rc) == (0))
        {
            if (((iSavepoint) &lt; (0)) &amp;&amp; ((pBt.btsFlags &amp; 0x0010) != 0))
            {
                pBt.nPage = (uint)(0);
            }

            rc = (int)(newDatabase(pBt));
            btreeSetNPage(pBt, pBt.pPage1);
        }

        sqlite3BtreeLeave(p);
    }

    return (int)(rc);
}</function>
  <function>public static void* sqlite3BtreeSchema(Btree p, int nBytes, delegate17 xFree)
{
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    if ((pBt.pSchema == null) &amp;&amp; ((nBytes) != 0))
    {
        pBt.pSchema = sqlite3DbMallocZero(null, (ulong)(nBytes));
        pBt.xFreeSchema = xFree;
    }

    sqlite3BtreeLeave(p);
    return pBt.pSchema;
}</function>
  <function>public static int sqlite3BtreeSchemaLocked(Btree p)
{
    int rc = 0;
    sqlite3BtreeEnter(p);
    rc = (int)(querySharedCacheTableLock(p, (uint)(1), (byte)(1)));
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeSecureDelete(Btree p, int newFlag)
{
    int b = 0;
    if ((p) == (null))
        return (int)(0);
    sqlite3BtreeEnter(p);
    if ((newFlag) &gt;= (0))
    {
        p.pBt.btsFlags &amp;= (ushort)(~0x000c);
        p.pBt.btsFlags |= (ushort)(0x0004 * newFlag);
    }

    b = (int)((p.pBt.btsFlags &amp; 0x000c) / 0x0004);
    sqlite3BtreeLeave(p);
    return (int)(b);
}</function>
  <function>public static int sqlite3BtreeSetAutoVacuum(Btree p, int autoVacuum)
{
    BtShared pBt = p.pBt;
    int rc = (int)(0);
    byte av = (byte)(autoVacuum);
    sqlite3BtreeEnter(p);
    if (((pBt.btsFlags &amp; 0x0002) != 0) &amp;&amp; (((av) != 0 ? 1 : 0) != pBt.autoVacuum))
    {
        rc = (int)(8);
    }
    else
    {
        pBt.autoVacuum = (byte)((av) != 0 ? 1 : 0);
        pBt.incrVacuum = (byte)((av) == (2) ? 1 : 0);
    }

    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeSetCacheSize(Btree p, int mxPage)
{
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    sqlite3PagerSetCachesize(pBt.pPager, (int)(mxPage));
    sqlite3BtreeLeave(p);
    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeSetMmapLimit(Btree p, long szMmap)
{
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    sqlite3PagerSetMmapLimit(pBt.pPager, (long)(szMmap));
    sqlite3BtreeLeave(p);
    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeSetPagerFlags(Btree p, uint pgFlags)
{
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    sqlite3PagerSetFlags(pBt.pPager, (uint)(pgFlags));
    sqlite3BtreeLeave(p);
    return (int)(0);
}</function>
  <function>public static int sqlite3BtreeSetPageSize(Btree p, int pageSize, int nReserve, int iFix)
{
    int rc = (int)(0);
    int x = 0;
    BtShared pBt = p.pBt;
    sqlite3BtreeEnter(p);
    pBt.nReserveWanted = (byte)(nReserve);
    x = (int)(pBt.pageSize - pBt.usableSize);
    if ((nReserve) &lt; (x))
        nReserve = (int)(x);
    if ((pBt.btsFlags &amp; 0x0002) != 0)
    {
        sqlite3BtreeLeave(p);
        return (int)(8);
    }

    if ((((pageSize) &gt;= (512)) &amp;&amp; ((pageSize) &lt;= (65536))) &amp;&amp; (((pageSize - 1) &amp; pageSize) == (0)))
    {
        if (((nReserve) &gt; (32)) &amp;&amp; ((pageSize) == (512)))
            pageSize = (int)(1024);
        pBt.pageSize = ((uint)(pageSize));
        freeTempSpace(pBt);
    }

    rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &amp;pBt.pageSize, (int)(nReserve)));
    pBt.usableSize = (uint)(pBt.pageSize - (ushort)(nReserve));
    if ((iFix) != 0)
        pBt.btsFlags |= (ushort)(0x0002);
    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeSetSpillSize(Btree p, int mxPage)
{
    BtShared pBt = p.pBt;
    int res = 0;
    sqlite3BtreeEnter(p);
    res = (int)(sqlite3PagerSetSpillsize(pBt.pPager, (int)(mxPage)));
    sqlite3BtreeLeave(p);
    return (int)(res);
}</function>
  <function>public static int sqlite3BtreeSetVersion(Btree pBtree, int iVersion)
{
    BtShared pBt = pBtree.pBt;
    int rc = 0;
    pBt.btsFlags &amp;= (ushort)(~0x0020);
    if ((iVersion) == (1))
        pBt.btsFlags |= (ushort)(0x0020);
    rc = (int)(sqlite3BtreeBeginTrans(pBtree, (int)(0), null));
    if ((rc) == (0))
    {
        byte* aData = pBt.pPage1.aData;
        if ((aData[18] != (byte)(iVersion)) || (aData[19] != (byte)(iVersion)))
        {
            rc = (int)(sqlite3BtreeBeginTrans(pBtree, (int)(2), null));
            if ((rc) == (0))
            {
                rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
                if ((rc) == (0))
                {
                    aData[18] = ((byte)(iVersion));
                    aData[19] = ((byte)(iVersion));
                }
            }
        }
    }

    pBt.btsFlags &amp;= (ushort)(~0x0020);
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeSharable(Btree p)
{
    return (int)(p.sharable);
}</function>
  <function>public static int sqlite3BtreeTableMoveto(BtCursor pCur, long intKey, int biasRight, int* pRes)
{
    int rc = 0;
    if (((pCur.eState) == (0)) &amp;&amp; ((pCur.curFlags &amp; 0x02) != 0))
    {
        if ((pCur.info.nKey) == (intKey))
        {
            *pRes = (int)(0);
            return (int)(0);
        }

        if ((pCur.info.nKey) &lt; (intKey))
        {
            if ((pCur.curFlags &amp; 0x08) != 0)
            {
                *pRes = (int)(-1);
                return (int)(0);
            }

            if ((pCur.info.nKey + 1) == (intKey))
            {
                *pRes = (int)(0);
                rc = (int)(sqlite3BtreeNext(pCur, (int)(0)));
                if ((rc) == (0))
                {
                    getCellInfo(pCur);
                    if ((pCur.info.nKey) == (intKey))
                    {
                        return (int)(0);
                    }
                }
                else if (rc != 101)
                {
                    return (int)(rc);
                }
            }
        }
    }

    rc = (int)(moveToRoot(pCur));
    if ((rc) != 0)
    {
        if ((rc) == (16))
        {
            *pRes = (int)(-1);
            return (int)(0);
        }

        return (int)(rc);
    }

    for (;;)
    {
        int lwr = 0;
        int upr = 0;
        int idx = 0;
        int c = 0;
        uint chldPg = 0;
        MemPage pPage = pCur.pPage;
        byte* pCell;
        lwr = (int)(0);
        upr = (int)(pPage.nCell - 1);
        idx = (int)(upr &gt;&gt; (1 - biasRight));
        for (;;)
        {
            long nCellKey = 0;
            pCell = ((pPage).aDataOfst + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (idx)])))));
            if ((pPage.intKeyLeaf) != 0)
            {
                while ((0x80) &lt;= (*(pCell++)))
                {
                    if ((pCell) &gt;= (pPage.aDataEnd))
                    {
                        return (int)(sqlite3CorruptError((int)(71750)));
                    }
                }
            }

            sqlite3GetVarint(pCell, (ulong*)(&amp;nCellKey));
            if ((nCellKey) &lt; (intKey))
            {
                lwr = (int)(idx + 1);
                if ((lwr) &gt; (upr))
                {
                    c = (int)(-1);
                    break;
                }
            }
            else if ((nCellKey) &gt; (intKey))
            {
                upr = (int)(idx - 1);
                if ((lwr) &gt; (upr))
                {
                    c = (int)(+1);
                    break;
                }
            }
            else
            {
                pCur.ix = ((ushort)(idx));
                if (pPage.leaf == 0)
                {
                    lwr = (int)(idx);
                    goto moveto_table_next_layer;
                }
                else
                {
                    pCur.curFlags |= (byte)(0x02);
                    pCur.info.nKey = (long)(nCellKey);
                    pCur.info.nSize = (ushort)(0);
                    *pRes = (int)(0);
                    return (int)(0);
                }
            }

            idx = (int)((lwr + upr) &gt;&gt; 1);
        }

        if ((pPage.leaf) != 0)
        {
            pCur.ix = ((ushort)(idx));
            *pRes = (int)(c);
            rc = (int)(0);
            goto moveto_table_finish;
        }

        moveto_table_next_layer:
            ;
        if ((lwr) &gt;= (pPage.nCell))
        {
            chldPg = (uint)(sqlite3Get4byte(&amp;pPage.aData[pPage.hdrOffset + 8]));
        }
        else
        {
            chldPg = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage &amp; _byteswap_ushort((ushort)(*(ushort*)(&amp;(pPage).aCellIdx[2 * (lwr)])))))));
        }

        pCur.ix = ((ushort)(lwr));
        rc = (int)(moveToChild(pCur, (uint)(chldPg)));
        if ((rc) != 0)
            break;
    }

    moveto_table_finish:
        ; pCur . info . nSize  =  ( ushort ) ( 0 ) ; 
    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeTransferRow(BtCursor pDest, BtCursor pSrc, long iKey)
{
    int rc = (int)(0);
    BtShared pBt = pDest.pBt;
    byte* aOut = pBt.pTmpSpace;
    byte* aIn;
    uint nIn = 0;
    uint nRem = 0;
    getCellInfo(pSrc);
    aOut += (byte)(((pSrc.info.nPayload) &lt; ((uint)(0x80))) ? (*(aOut) = ((byte)(pSrc.info.nPayload))), 1 :  sqlite3PutVarint ( ( aOut ) ,  ( ulong ) ( pSrc . info . nPayload ) ) ) ; 
    if ((pDest.pKeyInfo) == (null))
        aOut += sqlite3PutVarint(aOut, (ulong)(iKey));
    nIn = (uint)(pSrc.info.nLocal);
    aIn = pSrc.info.pPayload;
    if ((aIn + nIn) &gt; (pSrc.pPage.aDataEnd))
    {
        return (int)(sqlite3CorruptError((int)(75316)));
    }

    nRem = (uint)(pSrc.info.nPayload);
    if (((nIn) == (nRem)) &amp;&amp; ((nIn) &lt; (pDest.pPage.maxLocal)))
    {
        CRuntime.memcpy(aOut, aIn, (ulong)(nIn));
        pBt.nPreformatSize = (int)(nIn + (aOut - pBt.pTmpSpace));
    }
    else
    {
        Pager pSrcPager = pSrc.pBt.pPager;
        byte* pPgnoOut = null;
        uint ovflIn = (uint)(0);
        PgHdr pPageIn = null;
        MemPage pPageOut = null;
        uint nOut = 0;
        nOut = (uint)(btreePayloadToLocal(pDest.pPage, (long)(pSrc.info.nPayload)));
        pBt.nPreformatSize = (int)(nOut + (aOut - pBt.pTmpSpace));
        if ((nOut) &lt; (pSrc.info.nPayload))
        {
            pPgnoOut = &amp;aOut[nOut];
            pBt.nPreformatSize += (int)(4);
        }

        if ((nRem) &gt; (nIn))
        {
            if ((aIn + nIn + 4) &gt; (pSrc.pPage.aDataEnd))
            {
                return (int)(sqlite3CorruptError((int)(75339)));
            }

            ovflIn = (uint)(sqlite3Get4byte(&amp;pSrc.info.pPayload[nIn]));
        }

        do
        {
            nRem -= (uint)(nOut);
            do
            {
                if ((nIn) &gt; (0))
                {
                    int nCopy = (int)((nOut) &lt; (nIn) ? (nOut) : (nIn));
                    CRuntime.memcpy(aOut, aIn, (ulong)(nCopy));
                    nOut -= (uint)(nCopy);
                    nIn -= (uint)(nCopy);
                    aOut += nCopy;
                    aIn += nCopy;
                }

                if ((nOut) &gt; (0))
                {
                    sqlite3PagerUnref(pPageIn);
                    pPageIn = null;
                    rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(ovflIn), pPageIn, (int)(0x02)));
                    if ((rc) == (0))
                    {
                        aIn = (byte*)(sqlite3PagerGetData(pPageIn));
                        ovflIn = (uint)(sqlite3Get4byte(aIn));
                        aIn += 4;
                        nIn = (uint)(pSrc.pBt.usableSize - 4);
                    }
                }
            }
            while (((rc) == (0)) &amp;&amp; ((nOut) &gt; (0)));
            if ((((rc) == (0)) &amp;&amp; ((nRem) &gt; (0))) &amp;&amp; ((pPgnoOut) != null))
            {
                uint pgnoNew = 0;
                MemPage pNew = null;
                rc = (int)(allocateBtreePage(pBt, pNew, &amp;pgnoNew, (uint)(0), (byte)(0)));
                sqlite3Put4byte(pPgnoOut, (uint)(pgnoNew));
                if (((pBt.autoVacuum) != 0) &amp;&amp; ((pPageOut) != null))
                {
                    ptrmapPut(pBt, (uint)(pgnoNew), (byte)(4), (uint)(pPageOut.pgno), &amp;rc);
                }

                releasePage(pPageOut);
                pPageOut = pNew;
                if ((pPageOut) != null)
                {
                    pPgnoOut = pPageOut.aData;
                    sqlite3Put4byte(pPgnoOut, (uint)(0));
                    aOut = &amp;pPgnoOut[4];
                    nOut = (uint)((pBt.usableSize - 4) &lt; (nRem) ? (pBt.usableSize - 4) : (nRem));
                }
            }
        }
        while (((nRem) &gt; (0)) &amp;&amp; ((rc) == (0)));
        releasePage(pPageOut);
        sqlite3PagerUnref(pPageIn);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeTripAllCursors(Btree pBtree, int errCode, int writeOnly)
{
    BtCursor p;
    int rc = (int)(0);
    if ((pBtree) != null)
    {
        sqlite3BtreeEnter(pBtree);
        for (p = pBtree.pBt.pCursor; p; p = p.pNext)
        {
            if (((writeOnly) != 0) &amp;&amp; ((p.curFlags &amp; 0x01) == (0)))
            {
                if (((p.eState) == (0)) || ((p.eState) == (2)))
                {
                    rc = (int)(saveCursorPosition(p));
                    if (rc != 0)
                    {
                        (void)(sqlite3BtreeTripAllCursors(pBtree, (int)(rc), (int)(0)));
                        break;
                    }
                }
            }
            else
            {
                sqlite3BtreeClearCursor(p);
                p.eState = (byte)(4);
                p.skipNext = (int)(errCode);
            }

            btreeReleaseAllCursorPages(p);
        }

        sqlite3BtreeLeave(pBtree);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3BtreeTxnState(Btree p)
{
    return (int)(p ? p.inTrans : 0);
}</function>
  <function>public static int sqlite3BtreeUpdateMeta(Btree p, int idx, uint iMeta)
{
    BtShared pBt = p.pBt;
    byte* pP1;
    int rc = 0;
    sqlite3BtreeEnter(p);
    pP1 = pBt.pPage1.aData;
    rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
    if ((rc) == (0))
    {
        sqlite3Put4byte(&amp;pP1[36 + idx * 4], (uint)(iMeta));
        if ((idx) == (7))
        {
            pBt.incrVacuum = ((byte)(iMeta));
        }
    }

    sqlite3BtreeLeave(p);
    return (int)(rc);
}</function>
  <function>public static int sqlite3CantopenError(int lineno)
{
    return (int)(sqlite3ReportError((int)(14), (int)(lineno), "cannot open file"));
}</function>
  <function>public static void sqlite3ChangeCookie(Parse pParse, int iDb)
{
    sqlite3 db = pParse.db;
    Vdbe v = pParse.pVdbe;
    sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(1), (int)(1 + (uint)(db.aDb[iDb].pSchema.schema_cookie)));
}</function>
  <function>public static int sqlite3CheckCollSeq(Parse pParse, CollSeq pColl)
{
    if (((pColl) != null) &amp;&amp; ((pColl.xCmp) == (null)))
    {
        sbyte* zName = pColl.zName;
        sqlite3 db = pParse.db;
        CollSeq p = sqlite3GetCollSeq(pParse, (byte)((db).enc), pColl, zName);
        if (p == null)
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3CheckObjectName(Parse pParse, sbyte* zName, sbyte* zType, sbyte* zTblName)
{
    sqlite3 db = pParse.db;
    if ((((sqlite3WritableSchema(db)) != 0) || ((db.init.imposterTable) != 0)) || (sqlite3Config.bExtraSchemaChecks == 0))
    {
        return (int)(0);
    }

    if ((db.init.busy) != 0)
    {
        if ((((sqlite3_stricmp(zType, db.init.azInit[0])) != 0) || ((sqlite3_stricmp(zName, db.init.azInit[1])) != 0)) || ((sqlite3_stricmp(zTblName, db.init.azInit[2])) != 0))
        {
            sqlite3ErrorMsg(pParse, "");
            return (int)(1);
        }
    }
    else
    {
        if ((((pParse.nested) == (0)) &amp;&amp; ((0) == (sqlite3_strnicmp(zName, "sqlite_", (int)(7))))) || (((sqlite3ReadOnlyShadowTables(db)) != 0) &amp;&amp; ((sqlite3ShadowTableName(db, zName)) != 0)))
        {
            sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3Checkpoint(sqlite3 db, int iDb, int eMode, int* pnLog, int* pnCkpt)
{
    int rc = (int)(0);
    int i = 0;
    int bBusy = (int)(0);
    for (i = (int)(0); ((i) &lt; (db.nDb)) &amp;&amp; ((rc) == (0)); i++)
    {
        if (((i) == (iDb)) || ((iDb) == (10 + 2)))
        {
            rc = (int)(sqlite3BtreeCheckpoint(db.aDb[i].pBt, (int)(eMode), pnLog, pnCkpt));
            pnLog = null;
            pnCkpt = null;
            if ((rc) == (5))
            {
                bBusy = (int)(1);
                rc = (int)(0);
            }
        }
    }

    return (int)((((rc) == (0)) &amp;&amp; ((bBusy) != 0)) ? 5 : rc);
}</function>
  <function>public static void sqlite3ClearStatTables(Parse pParse, int iDb, sbyte* zType, sbyte* zName)
{
    int i = 0;
    sbyte* zDbName = pParse.db.aDb[iDb].zDbSName;
    for (i = (int)(1); (i) &lt;= (4); i++)
    {
        sbyte* zTab = stackalloc sbyte[24];
        sqlite3_snprintf((int)(24 * sizeof(sbyte)), zTab, "sqlite_stat%d", (int)(i));
        if ((sqlite3FindTable(pParse.db, zTab, zDbName)) != null)
        {
            sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", zDbName, zTab, zType, zName);
        }
    }
}</function>
  <function>public static void sqlite3ClearTempRegCache(Parse pParse)
{
    pParse.nTempReg = (byte)(0);
    pParse.nRangeReg = (int)(0);
}</function>
  <function>public static int sqlite3Close(sqlite3 db, int forceZombie)
{
    if (db == null)
    {
        return (int)(0);
    }

    if (sqlite3SafetyCheckSickOrOk(db) == 0)
    {
        return (int)(sqlite3MisuseError((int)(169692)));
    }

    sqlite3_mutex_enter(db.mutex);
    if ((db.mTrace &amp; 0x08) != 0)
    {
        db.trace.xV2((uint)(0x08), db.pTraceArg, db, null);
    }

    disconnectAllVtab(db);
    sqlite3VtabRollback(db);
    if ((forceZombie == 0) &amp;&amp; ((connectionIsBusy(db)) != 0))
    {
        sqlite3ErrorWithMsg(db, (int)(5), "unable to close due to unfinalized statements or unfinished backups");
        sqlite3_mutex_leave(db.mutex);
        return (int)(5);
    }

    db.eOpenState = (byte)(0xa7);
    sqlite3LeaveMutexAndCloseZombie(db);
    return (int)(0);
}</function>
  <function>public static void sqlite3CloseExtensions(sqlite3 db)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (db.nExtension); i++)
    {
        sqlite3OsDlClose(db.pVfs, db.aExtension[i]);
    }

    sqlite3DbFree(db, db.aExtension);
}</function>
  <function>public static void sqlite3CloseSavepoints(sqlite3 db)
{
    while ((db.pSavepoint) != null)
    {
        Savepoint* pTmp = db.pSavepoint;
        db.pSavepoint = pTmp-&gt;pNext;
        sqlite3DbFree(db, pTmp);
    }

    db.nSavepoint = (int)(0);
    db.nStatement = (int)(0);
    db.isTransactionSavepoint = (byte)(0);
}</function>
  <function>public static void sqlite3CodeChangeCount(Vdbe v, int regCounter, sbyte* zColName)
{
    sqlite3VdbeAddOp0(v, (int)(82));
    sqlite3VdbeAddOp2(v, (int)(83), (int)(regCounter), (int)(1));
    sqlite3VdbeSetNumCols(v, (int)(1));
    sqlite3VdbeSetColName(v, (int)(0), (int)(0), zColName, null);
}</function>
  <function>public static void sqlite3CodeDropTable(Parse pParse, Table pTab, int iDb, int isView)
{
    Vdbe v;
    sqlite3 db = pParse.db;
    Trigger pTrigger;
    Db pDb = db.aDb[iDb];
    v = sqlite3GetVdbe(pParse);
    sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
    if ((((pTab).eTabType) == (1)))
    {
        sqlite3VdbeAddOp0(v, (int)(169));
    }

    pTrigger = sqlite3TriggerList(pParse, pTab);
    while ((pTrigger) != null)
    {
        sqlite3DropTriggerPtr(pParse, pTrigger);
        pTrigger = pTrigger.pNext;
    }

    if ((pTab.tabFlags &amp; 0x00000008) != 0)
    {
        sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_sequence WHERE name=%Q", pDb.zDbSName, pTab.zName);
    }

    sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE tbl_name=%Q and type!='trigger'", pDb.zDbSName, pTab.zName);
    if ((isView == 0) &amp;&amp; (!(((pTab).eTabType) == (1))))
    {
        destroyTable(pParse, pTab);
    }

    if ((((pTab).eTabType) == (1)))
    {
        sqlite3VdbeAddOp4(v, (int)(171), (int)(iDb), (int)(0), (int)(0), pTab.zName, (int)(0));
        sqlite3MayAbort(pParse);
    }

    sqlite3VdbeAddOp4(v, (int)(150), (int)(iDb), (int)(0), (int)(0), pTab.zName, (int)(0));
    sqlite3ChangeCookie(pParse, (int)(iDb));
    sqliteViewResetAll(db, (int)(iDb));
}</function>
  <function>public static void sqlite3CodeRhsOfIN(Parse pParse, Expr pExpr, int iTab)
{
    int addrOnce = (int)(0);
    int addr = 0;
    Expr pLeft;
    KeyInfo pKeyInfo = null;
    int nVal = 0;
    Vdbe v;
    v = pParse.pVdbe;
    if ((!(((pExpr).flags &amp; (0x000020)) != 0)) &amp;&amp; ((pParse.iSelfTab) == (0)))
    {
        if ((((pExpr).flags &amp; (0x2000000)) != 0))
        {
            addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
            if ((((pExpr).flags &amp; 0x000800) != 0))
            {
                sqlite3VdbeExplain(pParse, (byte)(0), "REUSE LIST SUBQUERY %d", (uint)(pExpr.x.pSelect.selId));
            }

            sqlite3VdbeAddOp2(v, (int)(12), (int)(pExpr.y.sub.regReturn), (int)(pExpr.y.sub.iAddr));
            sqlite3VdbeAddOp2(v, (int)(113), (int)(iTab), (int)(pExpr.iTable));
            sqlite3VdbeJumpHere(v, (int)(addrOnce));
            return;
        }

        (pExpr).flags |= (uint)(0x2000000);
        pExpr.y.sub.regReturn = (int)(++pParse.nMem);
        pExpr.y.sub.iAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pExpr.y.sub.regReturn)) + 1);
        addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
    }

    pLeft = pExpr.pLeft;
    nVal = (int)(sqlite3ExprVectorSize(pLeft));
    pExpr.iTable = (int)(iTab);
    addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(pExpr.iTable), (int)(nVal)));
    pKeyInfo = sqlite3KeyInfoAlloc(pParse.db, (int)(nVal), (int)(1));
    if ((((pExpr).flags &amp; 0x000800) != 0))
    {
        Select pSelect = pExpr.x.pSelect;
        ExprList pEList = pSelect.pEList;
        sqlite3VdbeExplain(pParse, (byte)(1), "%sLIST SUBQUERY %d", (addrOnce) != 0 ? "" : "CORRELATED ", (uint)(pSelect.selId));
        if (((pEList.nExpr) == (nVal)))
        {
            Select pCopy;
            SelectDest dest = new SelectDest();
            int i = 0;
            int rc = 0;
            sqlite3SelectDestInit(dest, (int)(11), (int)(iTab));
            dest.zAffSdst = exprINAffinity(pParse, pExpr);
            pSelect.iLimit = (int)(0);
            pCopy = sqlite3SelectDup(pParse.db, pSelect, (int)(0));
            rc = (int)((pParse.db.mallocFailed) != 0 ? 1 : sqlite3Select(pParse, pCopy, dest));
            sqlite3SelectDelete(pParse.db, pCopy);
            sqlite3DbFree(pParse.db, dest.zAffSdst);
            if ((rc) != 0)
            {
                sqlite3KeyInfoUnref(pKeyInfo);
                return;
            }

            for (i = (int)(0); (i) &lt; (nVal); i++)
            {
                Expr p = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
                pKeyInfo.aColl[i] = sqlite3BinaryCompareCollSeq(pParse, p, pEList.a[i].pExpr);
            }
        }
    }
    else if ((pExpr.x.pList != null))
    {
        sbyte affinity = 0;
        int i = 0;
        ExprList pList = pExpr.x.pList;
        ExprList_item* pItem;
        int r1 = 0;
        int r2 = 0;
        affinity = (sbyte)(sqlite3ExprAffinity(pLeft));
        if ((affinity) &lt;= (0x40))
        {
            affinity = (sbyte)(0x41);
        }
        else if ((affinity) == (0x45))
        {
            affinity = (sbyte)(0x43);
        }

        if ((pKeyInfo) != null)
        {
            pKeyInfo.aColl[0] = sqlite3ExprCollSeq(pParse, pExpr.pLeft);
        }

        r1 = (int)(sqlite3GetTempReg(pParse));
        r2 = (int)(sqlite3GetTempReg(pParse));
        for (i = (int)(pList.nExpr), pItem = pList.a; (i) &gt; (0); i--, pItem++)
        {
            Expr pE2 = pItem-&gt;pExpr;
            if (((addrOnce) != 0) &amp;&amp; (sqlite3ExprIsConstant(pE2) == 0))
            {
                sqlite3VdbeChangeToNoop(v, (int)(addrOnce));
                (pExpr).flags &amp;= (uint)(~(0x2000000));
                addrOnce = (int)(0);
            }

            sqlite3ExprCode(pParse, pE2, (int)(r1));
            sqlite3VdbeAddOp4(v, (int)(96), (int)(r1), (int)(1), (int)(r2), &amp;affinity, (int)(1));
            sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iTab), (int)(r2), (int)(r1), (int)(1));
        }

        sqlite3ReleaseTempReg(pParse, (int)(r1));
        sqlite3ReleaseTempReg(pParse, (int)(r2));
    }

    if ((pKeyInfo) != null)
    {
        sqlite3VdbeChangeP4(v, (int)(addr), (void*)(pKeyInfo), (int)(-9));
    }

    if ((addrOnce) != 0)
    {
        sqlite3VdbeJumpHere(v, (int)(addrOnce));
        sqlite3VdbeAddOp1(v, (int)(67), (int)(pExpr.y.sub.regReturn));
        sqlite3VdbeChangeP1(v, (int)(pExpr.y.sub.iAddr - 1), (int)(sqlite3VdbeCurrentAddr(v) - 1));
        sqlite3ClearTempRegCache(pParse);
    }
}</function>
  <function>public static void sqlite3CodeRowTrigger(Parse pParse, Trigger pTrigger, int op, ExprList pChanges, int tr_tm, Table pTab, int reg, int orconf, int ignoreJump)
{
    Trigger p;
    for (p = pTrigger; p; p = p.pNext)
    {
        if (((((p.op) == (op)) || ((((p.bReturning) != 0) &amp;&amp; ((p.op) == (127))) &amp;&amp; ((op) == (129)))) &amp;&amp; ((p.tr_tm) == (tr_tm))) &amp;&amp; ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
        {
            if (p.bReturning == 0)
            {
                sqlite3CodeRowTriggerDirect(pParse, p, pTab, (int)(reg), (int)(orconf), (int)(ignoreJump));
            }
            else if ((((pParse).pToplevel) == (null)))
            {
                codeReturningTrigger(pParse, p, pTab, (int)(reg));
            }
        }
    }
}</function>
  <function>public static void sqlite3CodeRowTriggerDirect(Parse pParse, Trigger p, Table pTab, int reg, int orconf, int ignoreJump)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    TriggerPrg pPrg;
    pPrg = getRowTrigger(pParse, p, pTab, (int)(orconf));
    if ((pPrg) != null)
    {
        int bRecursive = (int)((((p.zName) != null) &amp;&amp; ((0) == (pParse.db.flags &amp; 0x00002000))) ? 1 : 0);
        sqlite3VdbeAddOp4(v, (int)(47), (int)(reg), (int)(ignoreJump), (int)(++pParse.nMem), (sbyte*)(pPrg.pProgram), (int)(-4));
        sqlite3VdbeChangeP5(v, (ushort)((byte)(bRecursive)));
    }
}</function>
  <function>public static int sqlite3CodeSubselect(Parse pParse, Expr pExpr)
{
    int addrOnce = (int)(0);
    int rReg = (int)(0);
    Select pSel;
    SelectDest dest = new SelectDest();
    int nReg = 0;
    Expr pLimit;
    Vdbe v = pParse.pVdbe;
    if ((pParse.nErr) != 0)
        return (int)(0);
    pSel = pExpr.x.pSelect;
    if ((((pExpr).flags &amp; (0x2000000)) != 0))
    {
        sqlite3VdbeExplain(pParse, (byte)(0), "REUSE SUBQUERY %d", (uint)(pSel.selId));
        sqlite3VdbeAddOp2(v, (int)(12), (int)(pExpr.y.sub.regReturn), (int)(pExpr.y.sub.iAddr));
        return (int)(pExpr.iTable);
    }

    (pExpr).flags |= (uint)(0x2000000);
    pExpr.y.sub.regReturn = (int)(++pParse.nMem);
    pExpr.y.sub.iAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pExpr.y.sub.regReturn)) + 1);
    if (!(((pExpr).flags &amp; (0x000020)) != 0))
    {
        addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
    }

    sqlite3VdbeExplain(pParse, (byte)(1), "%sSCALAR SUBQUERY %d", (addrOnce) != 0 ? "" : "CORRELATED ", (uint)(pSel.selId));
    nReg = (int)((pExpr.op) == (138) ? pSel.pEList.nExpr : 1);
    sqlite3SelectDestInit(dest, (int)(0), (int)(pParse.nMem + 1));
    pParse.nMem += (int)(nReg);
    if ((pExpr.op) == (138))
    {
        dest.eDest = (byte)(10);
        dest.iSdst = (int)(dest.iSDParm);
        dest.nSdst = (int)(nReg);
        sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(dest.iSDParm), (int)(dest.iSDParm + nReg - 1));
    }
    else
    {
        dest.eDest = (byte)(3);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(dest.iSDParm));
    }

    if ((pSel.pLimit) != null)
    {
        sqlite3 db = pParse.db;
        pLimit = sqlite3Expr(db, (int)(155), "0");
        if ((pLimit) != null)
        {
            pLimit.affExpr = (sbyte)(0x43);
            pLimit = sqlite3PExpr(pParse, (int)(52), sqlite3ExprDup(db, pSel.pLimit.pLeft, (int)(0)), pLimit);
        }

        sqlite3ExprDelete(db, pSel.pLimit.pLeft);
        pSel.pLimit.pLeft = pLimit;
    }
    else
    {
        pLimit = sqlite3Expr(pParse.db, (int)(155), "1");
        pSel.pLimit = sqlite3PExpr(pParse, (int)(148), pLimit, null);
    }

    pSel.iLimit = (int)(0);
    if ((sqlite3Select(pParse, pSel, dest)) != 0)
    {
        pExpr.op2 = (byte)(pExpr.op);
        pExpr.op = (byte)(182);
        return (int)(0);
    }

    pExpr.iTable = (int)(rReg = (int)(dest.iSDParm));
    if ((addrOnce) != 0)
    {
        sqlite3VdbeJumpHere(v, (int)(addrOnce));
    }

    sqlite3VdbeAddOp1(v, (int)(67), (int)(pExpr.y.sub.regReturn));
    sqlite3VdbeChangeP1(v, (int)(pExpr.y.sub.iAddr - 1), (int)(sqlite3VdbeCurrentAddr(v) - 1));
    sqlite3ClearTempRegCache(pParse);
    return (int)(rReg);
}</function>
  <function>public static void sqlite3CodeVerifyNamedSchema(Parse pParse, sbyte* zDb)
{
    sqlite3 db = pParse.db;
    int i = 0;
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        Db pDb = db.aDb[i];
        if (((pDb.pBt) != null) &amp;&amp; ((zDb == null) || ((0) == (sqlite3StrICmp(zDb, pDb.zDbSName)))))
        {
            sqlite3CodeVerifySchema(pParse, (int)(i));
        }
    }
}</function>
  <function>public static void sqlite3CodeVerifySchema(Parse pParse, int iDb)
{
    sqlite3CodeVerifySchemaAtToplevel(((pParse).pToplevel ? (pParse).pToplevel : (pParse)), (int)(iDb));
}</function>
  <function>public static void sqlite3CodeVerifySchemaAtToplevel(Parse pToplevel, int iDb)
{
    if ((((pToplevel.cookieMask) &amp; (((uint)(1)) &lt;&lt; (iDb))) != 0) == (0))
    {
        (pToplevel.cookieMask) |= (uint)(((uint)(1)) &lt;&lt; (iDb));
        if ((0 == 0) &amp;&amp; ((iDb) == (1)))
        {
            sqlite3OpenTempDatabase(pToplevel);
        }
    }
}</function>
  <function>public static void sqlite3CollapseDatabaseArray(sqlite3 db)
{
    int i = 0; int  j  =  0 ; 
    for (i = (int)(j = (int)(2)); (i) &lt; (db.nDb); i++)
    {
        Db pDb = db.aDb[i];
        if ((pDb.pBt) == (null))
        {
            sqlite3DbFree(db, pDb.zDbSName);
            pDb.zDbSName = null;
            continue;
        }

        if ((j) &lt; (i))
        {
            db.aDb[j] = (Db)(db.aDb[i]);
        }

        j++;
    }

    db.nDb = (int)(j);
    if (((db.nDb) &lt;= (2)) &amp;&amp; (db.aDb != db.aDbStatic))
    {
        CRuntime.memcpy(db.aDbStatic, db.aDb, (ulong)(2 * sizeof(Db)));
        sqlite3DbFree(db, db.aDb);
        db.aDb = db.aDbStatic;
    }
}</function>
  <function>public static sbyte* sqlite3ColumnColl(Column* pCol)
{
    sbyte* z;
    if ((pCol-&gt;colFlags &amp; 0x0200) == (0))
        return null;
    z = pCol-&gt;zCnName;
    while ((*z) != 0)
    {
        z++;
    }

    if ((pCol-&gt;colFlags &amp; 0x0004) != 0)
    {
        do
        {
            z++;
        }
        while ((*z) != 0);
    }

    return z + 1;
}</function>
  <function>public static void sqlite3ColumnDefault(Vdbe v, Table pTab, int i, int iReg)
{
    if (!(((pTab).eTabType) == (2)))
    {
        sqlite3_value pValue = null;
        byte enc = (byte)((sqlite3VdbeDb(v)).enc);
        Column* pCol = &amp;pTab.aCol[i];
        sqlite3ValueFromExpr(sqlite3VdbeDb(v), sqlite3ColumnExpr(pTab, pCol), (byte)(enc), (byte)(pCol-&gt;affinity), pValue);
        if ((pValue) != null)
        {
            sqlite3VdbeAppendP4(v, pValue, (int)(-11));
        }
    }

    if (((pTab.aCol[i].affinity) == (0x45)) &amp;&amp; (!(((pTab).eTabType) == (1))))
    {
        sqlite3VdbeAddOp1(v, (int)(86), (int)(iReg));
    }
}</function>
  <function>public static Expr sqlite3ColumnExpr(Table pTab, Column* pCol)
{
    if ((pCol-&gt;iDflt) == (0))
        return null;
    if ((!(((pTab).eTabType) == (0))) != 0)
        return null;
    if (((pTab.u.tab.pDfltList) == (null)))
        return null;
    if (((pTab.u.tab.pDfltList.nExpr) &lt; (pCol-&gt;iDflt)))
        return null;
    return pTab.u.tab.pDfltList.a[pCol-&gt;iDflt - 1].pExpr;
}</function>
  <function>public static int sqlite3ColumnIndex(Table pTab, sbyte* zCol)
{
    int i = 0;
    byte h = (byte)(sqlite3StrIHash(zCol));
    Column* pCol;
    for (pCol = pTab.aCol, i = (int)(0); (i) &lt; (pTab.nCol); pCol++, i++)
    {
        if (((pCol-&gt;hName) == (h)) &amp;&amp; ((sqlite3StrICmp(pCol-&gt;zCnName, zCol)) == (0)))
            return (int)(i);
    }

    return (int)(-1);
}</function>
  <function>public static void sqlite3ColumnSetColl(sqlite3 db, Column* pCol, sbyte* zColl)
{
    long nColl = 0;
    long n = 0;
    sbyte* zNew;
    n = (long)(sqlite3Strlen30(pCol-&gt;zCnName) + 1);
    if ((pCol-&gt;colFlags &amp; 0x0004) != 0)
    {
        n += (long)(sqlite3Strlen30(pCol-&gt;zCnName + n) + 1);
    }

    nColl = (long)(sqlite3Strlen30(zColl) + 1);
    zNew = sqlite3DbRealloc(db, pCol-&gt;zCnName, (ulong)(nColl + n));
    if ((zNew) != null)
    {
        pCol-&gt;zCnName = zNew;
        CRuntime.memcpy(pCol-&gt;zCnName + n, zColl, (ulong)(nColl));
        pCol-&gt;colFlags |= (ushort)(0x0200);
    }
}</function>
  <function>public static void sqlite3ColumnSetExpr(Parse pParse, Table pTab, Column* pCol, Expr pExpr)
{
    ExprList pList;
    pList = pTab.u.tab.pDfltList;
    if ((((pCol-&gt;iDflt) == (0)) || ((pList) == (null))) || ((pList.nExpr) &lt; (pCol-&gt;iDflt)))
    {
        pCol-&gt;iDflt = (ushort)((pList) == (null) ? 1 : pList.nExpr + 1);
        pTab.u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr);
    }
    else
    {
        sqlite3ExprDelete(pParse.db, pList.a[pCol-&gt;iDflt - 1].pExpr);
        pList.a[pCol-&gt;iDflt - 1].pExpr = pExpr;
    }
}</function>
  <function>public static int sqlite3ColumnsFromExprList(Parse pParse, ExprList pEList, short* pnCol, Column** paCol)
{
    sqlite3 db = pParse.db;
    int i = 0; int  j  =  0 ; 
    uint cnt = 0;
    Column* aCol; Column * pCol ; 
    int nCol = 0;
    sbyte* zName;
    int nName = 0;
    Hash ht = new Hash();
    Table pTab;
    sqlite3HashInit(&amp;ht);
    if ((pEList) != null)
    {
        nCol = (int)(pEList.nExpr);
        aCol = sqlite3DbMallocZero(db, (ulong)(sizeof(Column) * nCol));
        if (((nCol) &gt; (32767)))
            nCol = (int)(32767);
    }
    else
    {
        nCol = (int)(0);
        aCol = null;
    }

    *pnCol = (short)(nCol);
    *paCol = aCol;
    for (i = (int)(0), pCol = aCol; ((i) &lt; (nCol)) &amp;&amp; (db.mallocFailed == 0); i++, pCol++)
    {
        if (((zName = pEList.a[i].zEName) != null) &amp;&amp; ((pEList.a[i].eEName) == (0)))
        {
        }
        else
        {
            Expr pColExpr = sqlite3ExprSkipCollateAndLikely(pEList.a[i].pExpr);
            while ((pColExpr != null) &amp;&amp; ((pColExpr.op) == (141)))
            {
                pColExpr = pColExpr.pRight;
            }

            if ((((pColExpr.op) == (167)) &amp;&amp; ((((pColExpr).flags &amp; (0x1000000 | 0x2000000)) == (0)) != 0)) &amp;&amp; ((pTab = pColExpr.y.pTab) != null))
            {
                int iCol = (int)(pColExpr.iColumn);
                if ((iCol) &lt; (0))
                    iCol = (int)(pTab.iPKey);
                zName = (iCol) &gt;= (0) ? pTab.aCol[iCol].zCnName : "rowid";
            }
            else if ((pColExpr.op) == (59))
            {
                zName = pColExpr.u.zToken;
            }
            else
            {
                zName = pEList.a[i].zEName;
            }
        }

        if (((zName) != null) &amp;&amp; (sqlite3IsTrueOrFalse(zName) == 0))
        {
            zName = sqlite3DbStrDup(db, zName);
        }
        else
        {
            zName = sqlite3MPrintf(db, "column%d", (int)(i + 1));
        }

        cnt = (uint)(0);
        while (((zName) != null) &amp;&amp; (sqlite3HashFind(&amp;ht, zName) != null))
        {
            nName = (int)(sqlite3Strlen30(zName));
            if ((nName) &gt; (0))
            {
                for (j = (int)(nName - 1); ((j) &gt; (0)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zName[j])] &amp; 0x04) != 0); j--)
                {
                }

                if ((zName[j]) == (58))
                    nName = (int)(j);
            }

            zName = sqlite3MPrintf(db, "%.*z:%u", (int)(nName), zName, (uint)(++cnt));
            if ((cnt) &gt; (3))
                sqlite3_randomness((int)(sizeof(uint)), &amp;cnt);
        }

        pCol-&gt;zCnName = zName;
        pCol-&gt;hName = (byte)(sqlite3StrIHash(zName));
        if (((zName) != null) &amp;&amp; ((sqlite3HashInsert(&amp;ht, zName, pCol)) == (pCol)))
        {
            sqlite3OomFault(db);
        }
    }

    sqlite3HashClear(&amp;ht);
    if ((db.mallocFailed) != 0)
    {
        for (j = (int)(0); (j) &lt; (i); j++)
        {
            sqlite3DbFree(db, aCol[j].zCnName);
        }

        sqlite3DbFree(db, aCol);
        *paCol = null;
        *pnCol = (short)(0);
        return (int)(7);
    }

    return (int)(0);
}</function>
  <function>public static sbyte* sqlite3ColumnType(Column* pCol, sbyte* zDflt)
{
    if ((pCol-&gt;colFlags &amp; 0x0004) != 0)
    {
        return pCol-&gt;zCnName + CRuntime.strlen(pCol-&gt;zCnName) + 1;
    }
    else if ((pCol-&gt;eCType) != 0)
    {
        return sqlite3StdType[pCol-&gt;eCType - 1];
    }
    else
    {
        return zDflt;
    }
}</function>
  <function>public static void sqlite3CommitInternalChanges(sqlite3 db)
{
    db.mDbFlags &amp;= (uint)(~0x0001);
}</function>
  <function>public static sbyte sqlite3CompareAffinity(Expr pExpr, sbyte aff2)
{
    sbyte aff1 = (sbyte)(sqlite3ExprAffinity(pExpr));
    if (((aff1) &gt; (0x40)) &amp;&amp; ((aff2) &gt; (0x40)))
    {
        if (((aff1) &gt;= (0x43)) || ((aff2) &gt;= (0x43)))
        {
            return (sbyte)(0x43);
        }
        else
        {
            return (sbyte)(0x41);
        }
    }
    else
    {
        return (sbyte)(((aff1) &lt;= (0x40) ? aff2 : aff1) | 0x40);
    }
}</function>
  <function>public static sbyte** sqlite3CompileOptions(int* pnOpt)
{
    *pnOpt = (int)(36 * sizeof(sbyte) / sizeof(sbyte*));
    return sqlite3azCompileOpt;
}</function>
  <function>public static void sqlite3CompleteInsertion(Parse pParse, Table pTab, int iDataCur, int iIdxCur, int regNewData, int* aRegIdx, int update_flags, int appendBias, int useSeekResult)
{
    Vdbe v;
    Index pIdx;
    byte pik_flags = 0;
    int i = 0;
    v = pParse.pVdbe;
    for (i = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, i++)
    {
        if ((aRegIdx[i]) == (0))
            continue;
        if ((pIdx.pPartIdxWhere) != null)
        {
            sqlite3VdbeAddOp2(v, (int)(50), (int)(aRegIdx[i]), (int)(sqlite3VdbeCurrentAddr(v) + 2));
        }

        pik_flags = (byte)((useSeekResult) != 0 ? 0x10 : 0);
        if ((((pIdx).idxType) == (2)) &amp;&amp; (!(((pTab).tabFlags &amp; 0x00000080) == (0))))
        {
            pik_flags |= (byte)(0x01);
            pik_flags |= (byte)(update_flags &amp; 0x02);
            if ((update_flags) == (0))
            {
            }
        }

        sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iIdxCur + i), (int)(aRegIdx[i]), (int)(aRegIdx[i] + 1), (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol : pIdx.nColumn));
        sqlite3VdbeChangeP5(v, (ushort)(pik_flags));
    }

    if (!(((pTab).tabFlags &amp; 0x00000080) == (0)))
        return;
    if ((pParse.nested) != 0)
    {
        pik_flags = (byte)(0);
    }
    else
    {
        pik_flags = (byte)(0x01);
        pik_flags |= (byte)((update_flags) != 0 ? update_flags : 0x20);
    }

    if ((appendBias) != 0)
    {
        pik_flags |= (byte)(0x08);
    }

    if ((useSeekResult) != 0)
    {
        pik_flags |= (byte)(0x10);
    }

    sqlite3VdbeAddOp3(v, (int)(127), (int)(iDataCur), (int)(aRegIdx[i]), (int)(regNewData));
    if (pParse.nested == 0)
    {
        sqlite3VdbeAppendP4(v, pTab, (int)(-6));
    }

    sqlite3VdbeChangeP5(v, (ushort)(pik_flags));
}</function>
  <function>public static void sqlite3ComputeGeneratedColumns(Parse pParse, int iRegStore, Table pTab)
{
    int i = 0;
    Walker w = new Walker();
    Column* pRedo;
    int eProgress = 0;
    VdbeOp* pOp;
    sqlite3TableAffinity(pParse.pVdbe, pTab, (int)(iRegStore));
    if ((pTab.tabFlags &amp; 0x00000040) != 0)
    {
        pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(-1));
        if ((pOp-&gt;opcode) == (95))
        {
            int ii = 0;
            int jj = 0;
            sbyte* zP4 = pOp-&gt;p4.z;
            for (ii = (int)(jj = (int)(0)); zP4[jj]; ii++)
            {
                if ((pTab.aCol[ii].colFlags &amp; 0x0020) != 0)
                {
                    continue;
                }

                if ((pTab.aCol[ii].colFlags &amp; 0x0040) != 0)
                {
                    zP4[jj] = (sbyte)(0x40);
                }

                jj++;
            }
        }
        else if ((pOp-&gt;opcode) == (94))
        {
            pOp-&gt;p3 = (int)(1);
        }
    }

    for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
    {
        if ((pTab.aCol[i].colFlags &amp; 0x0060) != 0)
        {
            pTab.aCol[i].colFlags |= (ushort)(0x0080);
        }
    }

    w.u.pTab = pTab;
    w.xExprCallback = exprColumnFlagUnion;
    w.xSelectCallback = null;
    w.xSelectCallback2 = null;
    pParse.iSelfTab = (int)(-iRegStore);
    do
    {
        eProgress = (int)(0);
        pRedo = null;
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            Column* pCol = pTab.aCol + i;
            if ((pCol-&gt;colFlags &amp; 0x0080) != 0)
            {
                int x = 0;
                pCol-&gt;colFlags |= (ushort)(0x0100);
                w.eCode = (ushort)(0);
                sqlite3WalkExpr(w, sqlite3ColumnExpr(pTab, pCol));
                pCol-&gt;colFlags &amp;= (ushort)(~0x0100);
                if ((w.eCode &amp; 0x0080) != 0)
                {
                    pRedo = pCol;
                    continue;
                }

                eProgress = (int)(1);
                x = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + iRegStore);
                sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(x));
                pCol-&gt;colFlags &amp;= (ushort)(~0x0080);
            }
        }
    }
    while (((pRedo) != null) &amp;&amp; ((eProgress) != 0));
    if ((pRedo) != null)
    {
        sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pRedo-&gt;zCnName);
    }

    pParse.iSelfTab = (int)(0);
}</function>
  <function>public static void sqlite3ConstructBloomFilter(WhereInfo pWInfo, int iLevel, WhereLevel pLevel, ulong notReady)
{
    int addrOnce = 0;
    int addrTop = 0;
    int addrCont = 0;
    WhereTerm pTerm;
    WhereTerm pWCEnd;
    Parse pParse = pWInfo.pParse;
    Vdbe v = pParse.pVdbe;
    WhereLoop pLoop = pLevel.pWLoop;
    int iCur = 0;
    addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
    do
    {
        SrcItem pItem;
        Table pTab;
        ulong sz = 0;
        sqlite3WhereExplainBloomFilter(pParse, pWInfo, pLevel);
        addrCont = (int)(sqlite3VdbeMakeLabel(pParse));
        iCur = (int)(pLevel.iTabCur);
        pLevel.regFilter = (int)(++pParse.nMem);
        pItem = pWInfo.pTabList.a[pLevel.iFrom];
        pTab = pItem.pTab;
        sz = (ulong)(sqlite3LogEstToInt((short)(pTab.nRowLogEst)));
        if ((sz) &lt; (10000))
        {
            sz = (ulong)(10000);
        }
        else if ((sz) &gt; (10000000))
        {
            sz = (ulong)(10000000);
        }

        sqlite3VdbeAddOp2(v, (int)(76), (int)(sz), (int)(pLevel.regFilter));
        addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
        pWCEnd = pWInfo.sWC.a[pWInfo.sWC.nTerm];
        for (pTerm = pWInfo.sWC.a; (pTerm) &lt; (pWCEnd); pTerm++)
        {
            Expr pExpr = pTerm.pExpr;
            if (((pTerm.wtFlags &amp; 0x0002) == (0)) &amp;&amp; ((sqlite3ExprIsTableConstant(pExpr, (int)(iCur))) != 0))
            {
                sqlite3ExprIfFalse(pParse, pTerm.pExpr, (int)(addrCont), (int)(0x10));
            }
        }

        if ((pLoop.wsFlags &amp; 0x00000100) != 0)
        {
            int r1 = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(r1));
            sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(r1), (int)(1));
            sqlite3ReleaseTempReg(pParse, (int)(r1));
        }
        else
        {
            Index pIdx = pLoop.u.btree.pIndex;
            int n = (int)(pLoop.u.btree.nEq);
            int r1 = (int)(sqlite3GetTempRange(pParse, (int)(n)));
            int jj = 0;
            for (jj = (int)(0); (jj) &lt; (n); jj++)
            {
                int iCol = (int)(pIdx.aiColumn[jj]);
                sqlite3ExprCodeGetColumnOfTable(v, pIdx.pTable, (int)(iCur), (int)(iCol), (int)(r1 + jj));
            }

            sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(r1), (int)(n));
            sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(n));
        }

        sqlite3VdbeResolveLabel(v, (int)(addrCont));
        sqlite3VdbeAddOp2(v, (int)(5), (int)(pLevel.iTabCur), (int)(addrTop + 1));
        sqlite3VdbeJumpHere(v, (int)(addrTop));
        pLoop.wsFlags &amp;= (uint)(~0x00400000);
        if ((((pParse.db).dbOptFlags &amp; (0x00100000)) != 0))
            break;
        while ((++iLevel) &lt; (pWInfo.nLevel))
        {
            SrcItem pTabItem;
            pLevel = pWInfo.a[iLevel];
            pTabItem = pWInfo.pTabList.a[pLevel.iFrom];
            if ((pTabItem.fg.jointype &amp; 0x0008) != 0)
                continue;
            pLoop = pLevel.pWLoop;
            if (((pLoop) == (null)))
                continue;
            if ((pLoop.prereq &amp; notReady) != 0)
                continue;
            if ((pLoop.wsFlags &amp; (0x00400000 | 0x00000004)) == (0x00400000))
            {
                break;
            }
        }
    }
    while ((iLevel) &lt; (pWInfo.nLevel));
    sqlite3VdbeJumpHere(v, (int)(addrOnce));
}</function>
  <function>public static int sqlite3CorruptError(int lineno)
{
    return (int)(sqlite3ReportError((int)(11), (int)(lineno), "database corruption"));
}</function>
  <function>public static Expr sqlite3CreateColumnExpr(sqlite3 db, SrcList pSrc, int iSrc, int iCol)
{
    Expr p = sqlite3ExprAlloc(db, (int)(167), null, (int)(0));
    if ((p) != null)
    {
        SrcItem pItem = pSrc.a[iSrc];
        Table pTab;
        pTab = p.y.pTab = pItem.pTab;
        p.iTable = (int)(pItem.iCursor);
        if ((p.y.pTab.iPKey) == (iCol))
        {
            p.iColumn = (short)(-1);
        }
        else
        {
            p.iColumn = ((short)(iCol));
            if (((pTab.tabFlags &amp; 0x00000060) != 0) &amp;&amp; ((pTab.aCol[iCol].colFlags &amp; 0x0060) != 0))
            {
                pItem.colUsed = (ulong)((pTab.nCol) &gt;= (64) ? ((ulong)(-1)) : (((ulong)(1)) &lt;&lt; (pTab.nCol)) - 1);
            }
            else
            {
                pItem.colUsed |= (ulong)(((ulong)(1)) &lt;&lt; ((iCol) &gt;= ((int)(sizeof(ulong) * 8)) ? ((int)(sizeof(ulong) * 8)) - 1 : iCol));
            }
        }
    }

    return p;
}</function>
  <function>public static void sqlite3CreateForeignKey(Parse pParse, ExprList pFromCol, Token* pTo, ExprList pToCol, int flags)
{
    sqlite3 db = pParse.db;
    FKey pFKey = null;
    FKey pNextTo;
    Table p = pParse.pNewTable;
    long nByte = 0;
    int i = 0;
    int nCol = 0;
    sbyte* z;
    if (((p) == (null)) || ((pParse.eParseMode) == (1)))
        goto fk_end;
    if ((pFromCol) == (null))
    {
        int iCol = (int)(p.nCol - 1);
        if (((iCol) &lt; (0)))
            goto fk_end;
        if (((pToCol) != null) &amp;&amp; (pToCol.nExpr != 1))
        {
            sqlite3ErrorMsg(pParse, "foreign key on %s should reference only one column of table %T", p.aCol[iCol].zCnName, pTo);
            goto fk_end;
        }

        nCol = (int)(1);
    }
    else if (((pToCol) != null) &amp;&amp; (pToCol.nExpr != pFromCol.nExpr))
    {
        sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of columns in the referenced table");
        goto fk_end;
    }
    else
    {
        nCol = (int)(pFromCol.nExpr);
    }

    nByte = (long)(sizeof(FKey) + (nCol - 1) * sizeof(sColMap) + pTo-&gt;n + 1);
    if ((pToCol) != null)
    {
        for (i = (int)(0); (i) &lt; (pToCol.nExpr); i++)
        {
            nByte += (long)(sqlite3Strlen30(pToCol.a[i].zEName) + 1);
        }
    }

    pFKey = sqlite3DbMallocZero(db, (ulong)(nByte));
    if ((pFKey) == (null))
    {
        goto fk_end;
    }

    pFKey.pFrom = p;
    pFKey.pNextFrom = p.u.tab.pFKey;
    z = (sbyte*)(&amp;pFKey.aCol[nCol]);
    pFKey.zTo = z;
    if (((pParse.eParseMode) &gt;= (2)))
    {
        sqlite3RenameTokenMap(pParse, (void*)(z), pTo);
    }

    CRuntime.memcpy(z, pTo-&gt;z, (ulong)(pTo-&gt;n));
    z[pTo-&gt;n] = (sbyte)(0);
    sqlite3Dequote(z);
    z += pTo-&gt;n + 1;
    pFKey.nCol = (int)(nCol);
    if ((pFromCol) == (null))
    {
        pFKey.aCol[0].iFrom = (int)(p.nCol - 1);
    }
    else
    {
        for (i = (int)(0); (i) &lt; (nCol); i++)
        {
            int j = 0;
            for (j = (int)(0); (j) &lt; (p.nCol); j++)
            {
                if ((sqlite3StrICmp(p.aCol[j].zCnName, pFromCol.a[i].zEName)) == (0))
                {
                    pFKey.aCol[i].iFrom = (int)(j);
                    break;
                }
            }

            if ((j) &gt;= (p.nCol))
            {
                sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition", pFromCol.a[i].zEName);
                goto fk_end;
            }

            if (((pParse.eParseMode) &gt;= (2)))
            {
                sqlite3RenameTokenRemap(pParse, &amp;pFKey.aCol[i], pFromCol.a[i].zEName);
            }
        }
    }

    if ((pToCol) != null)
    {
        for (i = (int)(0); (i) &lt; (nCol); i++)
        {
            int n = (int)(sqlite3Strlen30(pToCol.a[i].zEName));
            pFKey.aCol[i].zCol = z;
            if (((pParse.eParseMode) &gt;= (2)))
            {
                sqlite3RenameTokenRemap(pParse, z, pToCol.a[i].zEName);
            }

            CRuntime.memcpy(z, pToCol.a[i].zEName, (ulong)(n));
            z[n] = (sbyte)(0);
            z += n + 1;
        }
    }

    pFKey.isDeferred = (byte)(0);
    pFKey.aAction[0] = ((byte)(flags &amp; 0xff));
    pFKey.aAction[1] = ((byte)((flags &gt;&gt; 8) &amp; 0xff));
    pNextTo = (FKey)(sqlite3HashInsert(&amp;p.pSchema.fkeyHash, pFKey.zTo, (void*)(pFKey)));
    if ((pNextTo) == (pFKey))
    {
        sqlite3OomFault(db);
        goto fk_end;
    }

    if ((pNextTo) != null)
    {
        pFKey.pNextTo = pNextTo;
        pNextTo.pPrevTo = pFKey;
    }

    p.u.tab.pFKey = pFKey;
    pFKey = null;
    fk_end:
        ; sqlite3DbFree ( db ,  pFKey ) ; 
    sqlite3ExprListDelete(db, pFromCol);
    sqlite3ExprListDelete(db, pToCol);
}</function>
  <function>public static int sqlite3CreateFunc(sqlite3 db, sbyte* zFunctionName, int nArg, int enc, void* pUserData, delegate68 xSFunc, delegate68 xStep, delegate69 xFinal, delegate69 xValue, delegate68 xInverse, FuncDestructor pDestructor)
{
    FuncDef p;
    int extraFlags = 0;
    if (((((((zFunctionName) == (null)) || ((xSFunc != null) &amp;&amp; (xFinal != null))) || (((xFinal) == (null)) != ((xStep) == (null)))) || (((xValue) == (null)) != ((xInverse) == (null)))) || (((nArg) &lt; (-1)) || ((nArg) &gt; (127)))) || ((255) &lt; (sqlite3Strlen30(zFunctionName))))
    {
        return (int)(sqlite3MisuseError((int)(170321)));
    }

    extraFlags = (int)(enc &amp; (0x000000800 | 0x000080000 | 0x000100000 | 0x000200000));
    enc &amp;= (int)(0x0003 | 5);
    extraFlags ^= (int)(0x00200000);
    switch (enc)
    {
        case 4:
            enc = (int)(2);
            break;
        case 5:
        {
            int rc = 0;
            rc = (int)(sqlite3CreateFunc(db, zFunctionName, (int)(nArg), (int)((1 | extraFlags) ^ 0x00200000), pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor));
            if ((rc) == (0))
            {
                rc = (int)(sqlite3CreateFunc(db, zFunctionName, (int)(nArg), (int)((2 | extraFlags) ^ 0x00200000), pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor));
            }

            if (rc != 0)
            {
                return (int)(rc);
            }

            enc = (int)(3);
            break;
        }

        case 1:
        case 2:
        case 3:
            break;
        default:
            enc = (int)(1);
            break;
    }

    p = sqlite3FindFunction(db, zFunctionName, (int)(nArg), (byte)(enc), (byte)(0));
    if ((((p) != null) &amp;&amp; ((p.funcFlags &amp; 0x0003) == ((uint)(enc)))) &amp;&amp; ((p.nArg) == (nArg)))
    {
        if ((db.nVdbeActive) != 0)
        {
            sqlite3ErrorWithMsg(db, (int)(5), "unable to delete/modify user-function due to active statements");
            return (int)(5);
        }
        else
        {
            sqlite3ExpirePreparedStatements(db, (int)(0));
        }
    }
    else if (((xSFunc) == (null)) &amp;&amp; ((xFinal) == (null)))
    {
        return (int)(0);
    }

    p = sqlite3FindFunction(db, zFunctionName, (int)(nArg), (byte)(enc), (byte)(1));
    if (p == null)
    {
        return (int)(7);
    }

    functionDestroy(db, p);
    if ((pDestructor) != null)
    {
        pDestructor.nRef++;
    }

    p.u.pDestructor = pDestructor;
    p.funcFlags = (uint)((p.funcFlags &amp; 0x0003) | extraFlags);
    p.xSFunc = xSFunc ? xSFunc : xStep;
    p.xFinalize = xFinal;
    p.xValue = xValue;
    p.xInverse = xInverse;
    p.pUserData = pUserData;
    p.nArg = (sbyte)((ushort)(nArg));
    return (int)(0);
}</function>
  <function>public static void sqlite3CreateIndex(Parse pParse, Token* pName1, Token* pName2, SrcList pTblName, ExprList pList, int onError, Token* pStart, Expr pPIWhere, int sortOrder, int ifNotExist, byte idxType)
{
    Table pTab = null;
    Index pIndex = null;
    sbyte* zName = null;
    int nName = 0;
    int i = 0; int  j  =  0 ; 
    DbFixer sFix = new DbFixer();
    int sortOrderMask = 0;
    sqlite3 db = pParse.db;
    Db pDb;
    int iDb = 0;
    Token* pName = null;
    ExprList_item* pListItem;
    int nExtra = (int)(0);
    int nExtraCol = 0;
    sbyte* zExtra = null;
    Index pPk = null;
    if ((pParse.nErr) != 0)
    {
        goto exit_create_index;
    }

    if (((pParse.eParseMode) == (1)) &amp;&amp; (idxType != 2))
    {
        goto exit_create_index;
    }

    if (0 != sqlite3ReadSchema(pParse))
    {
        goto exit_create_index;
    }

    if ((sqlite3HasExplicitNulls(pParse, pList)) != 0)
    {
        goto exit_create_index;
    }

    if (pTblName != null)
    {
        iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &amp;pName));
        if ((iDb) &lt; (0))
            goto exit_create_index;
        if (db.init.busy == 0)
        {
            pTab = sqlite3SrcListLookup(pParse, pTblName);
            if ((((pName2-&gt;n) == (0)) &amp;&amp; ((pTab) != null)) &amp;&amp; ((pTab.pSchema) == (db.aDb[1].pSchema)))
            {
                iDb = (int)(1);
            }
        }

        sqlite3FixInit(sFix, pParse, (int)(iDb), "index", pName);
        if ((sqlite3FixSrcList(sFix, pTblName)) != 0)
        {
        }

        pTab = sqlite3LocateTableItem(pParse, (uint)(0), pTblName.a[0]);
        if ((pTab) == (null))
            goto exit_create_index;
        if (((iDb) == (1)) &amp;&amp; (db.aDb[iDb].pSchema != pTab.pSchema))
        {
            sqlite3ErrorMsg(pParse, "cannot create a TEMP index on non-TEMP table \"%s\"", pTab.zName);
            goto exit_create_index;
        }

        if (!(((pTab).tabFlags &amp; 0x00000080) == (0)))
            pPk = sqlite3PrimaryKeyIndex(pTab);
    }
    else
    {
        pTab = pParse.pNewTable;
        if (pTab == null)
            goto exit_create_index;
        iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    }

    pDb = db.aDb[iDb];
    if ((((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0)) &amp;&amp; ((db.init.busy) == (0))) &amp;&amp; (pTblName != null))
    {
        sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab.zName);
        goto exit_create_index;
    }

    if ((((pTab).eTabType) == (2)))
    {
        sqlite3ErrorMsg(pParse, "views may not be indexed");
        goto exit_create_index;
    }

    if ((((pTab).eTabType) == (1)))
    {
        sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
        goto exit_create_index;
    }

    if ((pName) != null)
    {
        zName = sqlite3NameFromToken(db, pName);
        if ((zName) == (null))
            goto exit_create_index;
        if (0 != sqlite3CheckObjectName(pParse, zName, "index", pTab.zName))
        {
            goto exit_create_index;
        }

        if (!((pParse.eParseMode) &gt;= (2)))
        {
            if (db.init.busy == 0)
            {
                if (sqlite3FindTable(db, zName, null) != null)
                {
                    sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
                    goto exit_create_index;
                }
            }

            if (sqlite3FindIndex(db, zName, pDb.zDbSName) != null)
            {
                if (ifNotExist == 0)
                {
                    sqlite3ErrorMsg(pParse, "index %s already exists", zName);
                }
                else
                {
                    sqlite3CodeVerifySchema(pParse, (int)(iDb));
                    sqlite3ForceNotReadOnly(pParse);
                }

                goto exit_create_index;
            }
        }
    }
    else
    {
        int n = 0;
        Index pLoop;
        for (pLoop = pTab.pIndex, n = (int)(1); pLoop; pLoop = pLoop.pNext, n++)
        {
        }

        zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab.zName, (int)(n));
        if ((zName) == (null))
        {
            goto exit_create_index;
        }

        if ((pParse.eParseMode != 0))
            zName[7]++;
    }

    if (!((pParse.eParseMode) &gt;= (2)))
    {
        sbyte* zDb = pDb.zDbSName;
        if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) &amp;&amp; ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
        {
            goto exit_create_index;
        }

        i = (int)(1);
        if ((0 == 0) &amp;&amp; ((iDb) == (1)))
            i = (int)(3);
        if ((sqlite3AuthCheck(pParse, (int)(i), zName, pTab.zName, zDb)) != 0)
        {
            goto exit_create_index;
        }
    }

    if ((pList) == (null))
    {
        Token prevCol = new Token();
        Column* pCol = &amp;pTab.aCol[pTab.nCol - 1];
        pCol-&gt;colFlags |= (ushort)(0x0008);
        sqlite3TokenInit(&amp;prevCol, pCol-&gt;zCnName);
        pList = sqlite3ExprListAppend(pParse, null, sqlite3ExprAlloc(db, (int)(59), &amp;prevCol, (int)(0)));
        if ((pList) == (null))
            goto exit_create_index;
        sqlite3ExprListSetSortOrder(pList, (int)(sortOrder), (int)(-1));
    }
    else
    {
        sqlite3ExprListCheckLength(pParse, pList, "index");
        if ((pParse.nErr) != 0)
            goto exit_create_index;
    }

    for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
    {
        Expr pExpr = pList.a[i].pExpr;
        if ((pExpr.op) == (113))
        {
            nExtra += (int)(1 + sqlite3Strlen30(pExpr.u.zToken));
        }
    }

    nName = (int)(sqlite3Strlen30(zName));
    nExtraCol = (int)(pPk ? pPk.nKeyCol : 1);
    pIndex = sqlite3AllocateIndexObject(db, (short)(pList.nExpr + nExtraCol), (int)(nName + nExtra + 1), &amp;zExtra);
    if ((db.mallocFailed) != 0)
    {
        goto exit_create_index;
    }

    pIndex.zName = zExtra;
    zExtra += nName + 1;
    CRuntime.memcpy(pIndex.zName, zName, (ulong)(nName + 1));
    pIndex.pTable = pTab;
    pIndex.onError = ((byte)(onError));
    pIndex.uniqNotNull = (uint)(onError != 0);
    pIndex.idxType = (uint)(idxType);
    pIndex.pSchema = db.aDb[iDb].pSchema;
    pIndex.nKeyCol = (ushort)(pList.nExpr);
    if ((pPIWhere) != null)
    {
        sqlite3ResolveSelfReference(pParse, pTab, (int)(0x000002), pPIWhere, null);
        pIndex.pPartIdxWhere = pPIWhere;
        pPIWhere = null;
    }

    if ((pDb.pSchema.file_format) &gt;= (4))
    {
        sortOrderMask = (int)(-1);
    }
    else
    {
        sortOrderMask = (int)(0);
    }

    pListItem = pList.a;
    if (((pParse.eParseMode) &gt;= (2)))
    {
        pIndex.aColExpr = pList;
        pList = null;
    }

    for (i = (int)(0); (i) &lt; (pIndex.nKeyCol); i++, pListItem++)
    {
        Expr pCExpr;
        int requestedSortOrder = 0;
        sbyte* zColl;
        sqlite3StringToId(pListItem-&gt;pExpr);
        sqlite3ResolveSelfReference(pParse, pTab, (int)(0x000020), pListItem-&gt;pExpr, null);
        if ((pParse.nErr) != 0)
            goto exit_create_index;
        pCExpr = sqlite3ExprSkipCollate(pListItem-&gt;pExpr);
        if (pCExpr.op != 167)
        {
            if ((pTab) == (pParse.pNewTable))
            {
                sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and UNIQUE constraints");
                goto exit_create_index;
            }

            if ((pIndex.aColExpr) == (null))
            {
                pIndex.aColExpr = pList;
                pList = null;
            }

            j = (int)(-2);
            pIndex.aiColumn[i] = (short)(-2);
            pIndex.uniqNotNull = (uint)(0);
        }
        else
        {
            j = (int)(pCExpr.iColumn);
            if ((j) &lt; (0))
            {
                j = (int)(pTab.iPKey);
            }
            else
            {
                if ((pTab.aCol[j].notNull) == (0))
                {
                    pIndex.uniqNotNull = (uint)(0);
                }

                if ((pTab.aCol[j].colFlags &amp; 0x0020) != 0)
                {
                    pIndex.bHasVCol = (uint)(1);
                }
            }

            pIndex.aiColumn[i] = ((short)(j));
        }

        zColl = null;
        if ((pListItem-&gt;pExpr.op) == (113))
        {
            int nColl = 0;
            zColl = pListItem-&gt;pExpr.u.zToken;
            nColl = (int)(sqlite3Strlen30(zColl) + 1);
            CRuntime.memcpy(zExtra, zColl, (ulong)(nColl));
            zColl = zExtra;
            zExtra += nColl;
            nExtra -= (int)(nColl);
        }
        else if ((j) &gt;= (0))
        {
            zColl = sqlite3ColumnColl(&amp;pTab.aCol[j]);
        }

        if (zColl == null)
            zColl = sqlite3StrBINARY;
        if ((db.init.busy == 0) &amp;&amp; (sqlite3LocateCollSeq(pParse, zColl) == null))
        {
            goto exit_create_index;
        }

        pIndex.azColl[i] = zColl;
        requestedSortOrder = (int)(pListItem-&gt;sortFlags &amp; sortOrderMask);
        pIndex.aSortOrder[i] = ((byte)(requestedSortOrder));
    }

    if ((pPk) != null)
    {
        for (j = (int)(0); (j) &lt; (pPk.nKeyCol); j++)
        {
            int x = (int)(pPk.aiColumn[j]);
            if ((isDupColumn(pIndex, (int)(pIndex.nKeyCol), pPk, (int)(j))) != 0)
            {
                pIndex.nColumn--;
            }
            else
            {
                pIndex.aiColumn[i] = (short)(x);
                pIndex.azColl[i] = pPk.azColl[j];
                pIndex.aSortOrder[i] = (byte)(pPk.aSortOrder[j]);
                i++;
            }
        }
    }
    else
    {
        pIndex.aiColumn[i] = (short)(-1);
        pIndex.azColl[i] = sqlite3StrBINARY;
    }

    sqlite3DefaultRowEst(pIndex);
    if ((pParse.pNewTable) == (null))
        estimateIndexWidth(pIndex);
    recomputeColumnsNotIndexed(pIndex);
    if ((pTblName != null) &amp;&amp; ((pIndex.nColumn) &gt;= (pTab.nCol)))
    {
        pIndex.isCovering = (uint)(1);
        for (j = (int)(0); (j) &lt; (pTab.nCol); j++)
        {
            if ((j) == (pTab.iPKey))
                continue;
            if ((sqlite3TableColumnToIndex(pIndex, (short)(j))) &gt;= (0))
                continue;
            pIndex.isCovering = (uint)(0);
            break;
        }
    }

    if ((pTab) == (pParse.pNewTable))
    {
        Index pIdx;
        for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            int k = 0;
            if (pIdx.nKeyCol != pIndex.nKeyCol)
                continue;
            for (k = (int)(0); (k) &lt; (pIdx.nKeyCol); k++)
            {
                sbyte* z1;
                sbyte* z2;
                if (pIdx.aiColumn[k] != pIndex.aiColumn[k])
                    break;
                z1 = pIdx.azColl[k];
                z2 = pIndex.azColl[k];
                if ((sqlite3StrICmp(z1, z2)) != 0)
                    break;
            }

            if ((k) == (pIdx.nKeyCol))
            {
                if (pIdx.onError != pIndex.onError)
                {
                    if (!(((pIdx.onError) == (11)) || ((pIndex.onError) == (11))))
                    {
                        sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified", (int)(0));
                    }

                    if ((pIdx.onError) == (11))
                    {
                        pIdx.onError = (byte)(pIndex.onError);
                    }
                }

                if ((idxType) == (2))
                    pIdx.idxType = (uint)(idxType);
                if (((pParse.eParseMode) &gt;= (2)))
                {
                    pIndex.pNext = pParse.pNewIndex;
                    pParse.pNewIndex = pIndex;
                    pIndex = null;
                }

                goto exit_create_index;
            }
        }
    }

    if (!((pParse.eParseMode) &gt;= (2)))
    {
        if ((db.init.busy) != 0)
        {
            Index p;
            if (pTblName != null)
            {
                pIndex.tnum = (uint)(db.init.newTnum);
                if ((sqlite3IndexHasDuplicateRootPage(pIndex)) != 0)
                {
                    sqlite3ErrorMsg(pParse, "invalid rootpage");
                    pParse.rc = (int)(sqlite3CorruptError((int)(118261)));
                    goto exit_create_index;
                }
            }

            p = sqlite3HashInsert(&amp;pIndex.pSchema.idxHash, pIndex.zName, pIndex);
            if ((p) != null)
            {
                sqlite3OomFault(db);
                goto exit_create_index;
            }

            db.mDbFlags |= (uint)(0x0001);
        }
        else if ((((pTab).tabFlags &amp; 0x00000080) == (0)) || (pTblName != null))
        {
            Vdbe v;
            sbyte* zStmt;
            int iMem = (int)(++pParse.nMem);
            v = sqlite3GetVdbe(pParse);
            if ((v) == (null))
                goto exit_create_index;
            sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
            pIndex.tnum = ((uint)(sqlite3VdbeAddOp0(v, (int)(182))));
            sqlite3VdbeAddOp3(v, (int)(146), (int)(iDb), (int)(iMem), (int)(2));
            if ((pStart) != null)
            {
                int n = (int)((int)(pParse.sLastToken.z - pName-&gt;z) + pParse.sLastToken.n);
                if ((pName-&gt;z[n - 1]) == (59))
                    n--;
                zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s", (onError) == (0) ? "" : " UNIQUE", (int)(n), pName-&gt;z);
            }
            else
            {
                zStmt = null;
            }

            sqlite3NestedParse(pParse, "INSERT INTO %Q.sqlite_master VALUES('index',%Q,%Q,#%d,%Q);", db.aDb[iDb].zDbSName, pIndex.zName, pTab.zName, (int)(iMem), zStmt);
            sqlite3DbFree(db, zStmt);
            if ((pTblName) != null)
            {
                sqlite3RefillIndex(pParse, pIndex, (int)(iMem));
                sqlite3ChangeCookie(pParse, (int)(iDb));
                sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex.zName), (ushort)(0));
                sqlite3VdbeAddOp2(v, (int)(165), (int)(0), (int)(1));
            }

            sqlite3VdbeJumpHere(v, (int)(pIndex.tnum));
        }
    }

    if (((db.init.busy) != 0) || ((pTblName) == (null)))
    {
        pIndex.pNext = pTab.pIndex;
        pTab.pIndex = pIndex;
        pIndex = null;
    }
    else if (((pParse.eParseMode) &gt;= (2)))
    {
        pParse.pNewIndex = pIndex;
        pIndex = null;
    }

    exit_create_index:
        ; if  ( ( pIndex ) != null ) sqlite3FreeIndex ( db ,  pIndex ) ; 
    if ((pTab) != null)
    {
        Index ppFrom;
        Index pThis;
        for (ppFrom = pTab.pIndex; (pThis = ppFrom) != null; ppFrom = pThis.pNext)
        {
            Index pNext;
            if (pThis.onError != 5)
                continue;
            while (((pNext = pThis.pNext) != null) &amp;&amp; (pNext.onError != 5))
            {
                ppFrom = pNext;
                pThis.pNext = pNext.pNext;
                pNext.pNext = pThis;
                ppFrom = pNext.pNext;
            }

            break;
        }
    }

    sqlite3ExprDelete(db, pPIWhere);
    sqlite3ExprListDelete(db, pList);
    sqlite3SrcListDelete(db, pTblName);
    sqlite3DbFree(db, zName);
}</function>
  <function>public static void sqlite3CreateView(Parse pParse, Token* pBegin, Token* pName1, Token* pName2, ExprList pCNames, Select pSelect, int isTemp, int noErr)
{
    Table p;
    int n = 0;
    sbyte* z;
    Token sEnd = new Token();
    DbFixer sFix = new DbFixer();
    Token* pName = null;
    int iDb = 0;
    sqlite3 db = pParse.db;
    if ((pParse.nVar) &gt; (0))
    {
        sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
        goto create_view_fail;
    }

    sqlite3StartTable(pParse, pName1, pName2, (int)(isTemp), (int)(1), (int)(0), (int)(noErr));
    p = pParse.pNewTable;
    if (((p) == (null)) || ((pParse.nErr) != 0))
        goto create_view_fail;
    p.tabFlags |= (uint)(0x00000200);
    sqlite3TwoPartName(pParse, pName1, pName2, &amp;pName);
    iDb = (int)(sqlite3SchemaToIndex(db, p.pSchema));
    sqlite3FixInit(sFix, pParse, (int)(iDb), "view", pName);
    if ((sqlite3FixSelect(sFix, pSelect)) != 0)
        goto create_view_fail;
    pSelect.selFlags |= (uint)(0x0200000);
    if (((pParse.eParseMode) &gt;= (2)))
    {
        p.u.view.pSelect = pSelect;
        pSelect = null;
    }
    else
    {
        p.u.view.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001));
    }

    p.pCheck = sqlite3ExprListDup(db, pCNames, (int)(0x0001));
    p.eTabType = (byte)(2);
    if ((db.mallocFailed) != 0)
        goto create_view_fail;
    sEnd = (Token)(pParse.sLastToken);
    if (sEnd.z[0] != 59)
    {
        sEnd.z += sEnd.n;
    }

    sEnd.n = (uint)(0);
    n = ((int)(sEnd.z - pBegin-&gt;z));
    z = pBegin-&gt;z;
    while ((sqlite3CtypeMap[(byte)(z[n - 1])] &amp; 0x01) != 0)
    {
        n--;
    }

    sEnd.z = &amp;z[n - 1];
    sEnd.n = (uint)(1);
    sqlite3EndTable(pParse, null, &amp;sEnd, (uint)(0), null);
    create_view_fail:
        ; sqlite3SelectDelete ( db ,  pSelect ) ; 
    if (((pParse.eParseMode) &gt;= (2)))
    {
        sqlite3RenameExprlistUnmap(pParse, pCNames);
    }

    sqlite3ExprListDelete(db, pCNames);
    return;
}</function>
  <function>public static void sqlite3CteDelete(sqlite3 db, Cte pCte)
{
    cteClear(db, pCte);
    sqlite3DbFree(db, pCte);
}</function>
  <function>public static Cte sqlite3CteNew(Parse pParse, Token* pName, ExprList pArglist, Select pQuery, byte eM10d)
{
    Cte pNew;
    sqlite3 db = pParse.db;
    pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Cte)));
    if ((db.mallocFailed) != 0)
    {
        sqlite3ExprListDelete(db, pArglist);
        sqlite3SelectDelete(db, pQuery);
    }
    else
    {
        pNew.pSelect = pQuery;
        pNew.pCols = pArglist;
        pNew.zName = sqlite3NameFromToken(pParse.db, pName);
        pNew.eM10d = (byte)(eM10d);
    }

    return pNew;
}</function>
  <function>public static void sqlite3DbFree(sqlite3 db, void* p)
{
    if ((p) != null)
        sqlite3DbFreeNN(db, p);
}</function>
  <function>public static void sqlite3DbFreeNN(sqlite3 db, void* p)
{
    if ((db) != null)
    {
        if ((db.pnBytesFreed) != null)
        {
            measureAllocationSize(db, p);
            return;
        }

        if (((ulong)(p)) &lt; ((ulong)(db.lookaside.pEnd)))
        {
            if (((ulong)(p)) &gt;= ((ulong)(db.lookaside.pMiddle)))
            {
                LookasideSlot* pBuf = (LookasideSlot*)(p);
                pBuf-&gt;pNext = db.lookaside.pSmallFree;
                db.lookaside.pSmallFree = pBuf;
                return;
            }

            if (((ulong)(p)) &gt;= ((ulong)(db.lookaside.pStart)))
            {
                LookasideSlot* pBuf = (LookasideSlot*)(p);
                pBuf-&gt;pNext = db.lookaside.pFree;
                db.lookaside.pFree = pBuf;
                return;
            }
        }
    }

    sqlite3_free(p);
}</function>
  <function>public static int sqlite3DbIsNamed(sqlite3 db, int iDb, sbyte* zName)
{
    return ((((sqlite3StrICmp(db.aDb[iDb].zDbSName, zName)) == (0)) || (((iDb) == (0)) &amp;&amp; ((sqlite3StrICmp("main", zName)) == (0)))) ? 1 : 0);
}</function>
  <function>public static void* sqlite3DbMallocRaw(sqlite3 db, ulong n)
{
    void* p;
    if ((db) != null)
        return sqlite3DbMallocRawNN(db, (ulong)(n));
    p = sqlite3Malloc((ulong)(n));
    return p;
}</function>
  <function>public static void* sqlite3DbMallocRawNN(sqlite3 db, ulong n)
{
    LookasideSlot* pBuf;
    if ((n) &gt; (db.lookaside.sz))
    {
        if (db.lookaside.bDisable == 0)
        {
            db.lookaside.anStat[1]++;
        }
        else if ((db.mallocFailed) != 0)
        {
            return null;
        }

        return dbMallocRawFinish(db, (ulong)(n));
    }

    if ((n) &lt;= (128))
    {
        if ((pBuf = db.lookaside.pSmallFree) != null)
        {
            db.lookaside.pSmallFree = pBuf-&gt;pNext;
            db.lookaside.anStat[0]++;
            return (void*)(pBuf);
        }
        else if ((pBuf = db.lookaside.pSmallInit) != null)
        {
            db.lookaside.pSmallInit = pBuf-&gt;pNext;
            db.lookaside.anStat[0]++;
            return (void*)(pBuf);
        }
    }

    if ((pBuf = db.lookaside.pFree) != null)
    {
        db.lookaside.pFree = pBuf-&gt;pNext;
        db.lookaside.anStat[0]++;
        return (void*)(pBuf);
    }
    else if ((pBuf = db.lookaside.pInit) != null)
    {
        db.lookaside.pInit = pBuf-&gt;pNext;
        db.lookaside.anStat[0]++;
        return (void*)(pBuf);
    }
    else
    {
        db.lookaside.anStat[2]++;
    }

    return dbMallocRawFinish(db, (ulong)(n));
}</function>
  <function>public static int sqlite3DbMallocSize(sqlite3 db, void* p)
{
    if ((db) != null)
    {
        if (((ulong)(p)) &lt; ((ulong)(db.lookaside.pEnd)))
        {
            if (((ulong)(p)) &gt;= ((ulong)(db.lookaside.pMiddle)))
            {
                return (int)(128);
            }

            if (((ulong)(p)) &gt;= ((ulong)(db.lookaside.pStart)))
            {
                return (int)(db.lookaside.szTrue);
            }
        }
    }

    return (int)(sqlite3Config.m.xSize(p));
}</function>
  <function>public static void* sqlite3DbMallocZero(sqlite3 db, ulong n)
{
    void* p;
    p = sqlite3DbMallocRaw(db, (ulong)(n));
    if ((p) != null)
        CRuntime.memset(p, (int)(0), (ulong)(n));
    return p;
}</function>
  <function>public static Btree sqlite3DbNameToBtree(sqlite3 db, sbyte* zDbName)
{
    int iDb = (int)((zDbName) != 0 ? sqlite3FindDbName(db, zDbName) : 0);
    return (iDb) &lt; (0) ? null : db.aDb[iDb].pBt;
}</function>
  <function>public static void* sqlite3DbRealloc(sqlite3 db, void* p, ulong n)
{
    if ((p) == (null))
        return sqlite3DbMallocRawNN(db, (ulong)(n));
    if (((ulong)(p)) &lt; ((ulong)(db.lookaside.pEnd)))
    {
        if (((ulong)(p)) &gt;= ((ulong)(db.lookaside.pMiddle)))
        {
            if ((n) &lt;= (128))
                return p;
        }
        else if (((ulong)(p)) &gt;= ((ulong)(db.lookaside.pStart)))
        {
            if ((n) &lt;= (db.lookaside.szTrue))
                return p;
        }
    }

    return dbReallocFinish(db, p, (ulong)(n));
}</function>
  <function>public static void* sqlite3DbReallocOrFree(sqlite3 db, void* p, ulong n)
{
    void* pNew;
    pNew = sqlite3DbRealloc(db, p, (ulong)(n));
    if (pNew == null)
    {
        sqlite3DbFree(db, p);
    }

    return pNew;
}</function>
  <function>public static sbyte* sqlite3DbSpanDup(sqlite3 db, sbyte* zStart, sbyte* zEnd)
{
    int n = 0;
    while ((sqlite3CtypeMap[(byte)(zStart[0])] &amp; 0x01) != 0)
    {
        zStart++;
    }

    n = ((int)(zEnd - zStart));
    while (((n) &gt; (0)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zStart[n - 1])] &amp; 0x01) != 0))
    {
        n--;
    }

    return sqlite3DbStrNDup(db, zStart, (ulong)(n));
}</function>
  <function>public static sbyte* sqlite3DbStrDup(sqlite3 db, sbyte* z)
{
    sbyte* zNew;
    ulong n = 0;
    if ((z) == (null))
    {
        return null;
    }

    n = (ulong)(CRuntime.strlen(z) + 1);
    zNew = sqlite3DbMallocRaw(db, (ulong)(n));
    if ((zNew) != null)
    {
        CRuntime.memcpy(zNew, z, (ulong)(n));
    }

    return zNew;
}</function>
  <function>public static sbyte* sqlite3DbStrNDup(sqlite3 db, sbyte* z, ulong n)
{
    sbyte* zNew;
    zNew = (z) != 0 ? sqlite3DbMallocRawNN(db, (ulong)(n + 1)) : null;
    if ((zNew) != null)
    {
        CRuntime.memcpy(zNew, z, (ulong)(n));
        zNew[n] = (sbyte)(0);
    }

    return zNew;
}</function>
  <function>public static int sqlite3DecOrHexToI64(sbyte* z, long* pOut)
{
    if (((z[0]) == (48)) &amp;&amp; (((z[1]) == (120)) || ((z[1]) == (88))))
    {
        ulong u = (ulong)(0);
        int i = 0;
        int k = 0;
        for (i = (int)(2); (z[i]) == (48); i++)
        {
        }

        for (k = (int)(i); (sqlite3CtypeMap[(byte)(z[k])] &amp; 0x08); k++)
        {
            u = (ulong)(u * 16 + sqlite3HexToInt((int)(z[k])));
        }

        CRuntime.memcpy(pOut, &amp;u, (ulong)(8));
        return (int)((((z[k]) == (0)) &amp;&amp; ((k - i) &lt;= (16))) ? 0 : 2);
    }
    else
    {
        return (int)(sqlite3Atoi64(z, pOut, (int)(sqlite3Strlen30(z)), (byte)(1)));
    }
}</function>
  <function>public static sqlite3_mutex_methods sqlite3DefaultMutex()
{
    return sqlite3DefaultMutex_sMutex;
}</function>
  <function>public static void sqlite3DefaultRowEst(Index pIdx)
{
    short* a = pIdx.aiRowLogEst;
    short x = 0;
    int nCopy = (int)(((int)(5 * sizeof(short) / sizeof(short))) &lt; (pIdx.nKeyCol) ? ((int)(5 * sizeof(short) / sizeof(short))) : (pIdx.nKeyCol));
    int i = 0;
    x = (short)(pIdx.pTable.nRowLogEst);
    if ((x) &lt; (99))
    {
        pIdx.pTable.nRowLogEst = (short)(x = (short)(99));
    }

    if (pIdx.pPartIdxWhere != null)
    {
        x -= (short)(10);
    }

    a[0] = (short)(x);
    CRuntime.memcpy(&amp;a[1], sqlite3DefaultRowEst_aVal, (ulong)(nCopy * sizeof(short)));
    for (i = (int)(nCopy + 1); (i) &lt;= (pIdx.nKeyCol); i++)
    {
        a[i] = (short)(23);
    }

    if (((pIdx).onError != 0))
        a[pIdx.nKeyCol] = (short)(0);
}</function>
  <function>public static void sqlite3DeferForeignKey(Parse pParse, int isDeferred)
{
    Table pTab;
    FKey pFKey;
    if ((pTab = pParse.pNewTable) == (null))
        return;
    if ((!(((pTab).eTabType) == (0))) != 0)
        return;
    if ((pFKey = pTab.u.tab.pFKey) == (null))
        return;
    pFKey.isDeferred = ((byte)(isDeferred));
}</function>
  <function>public static void sqlite3DeleteColumnNames(sqlite3 db, Table pTable)
{
    int i = 0;
    Column* pCol;
    if ((pCol = pTable.aCol) != null)
    {
        for (i = (int)(0); (i) &lt; (pTable.nCol); i++, pCol++)
        {
            sqlite3DbFree(db, pCol-&gt;zCnName);
        }

        sqlite3DbFree(db, pTable.aCol);
        if ((((pTable).eTabType) == (0)))
        {
            sqlite3ExprListDelete(db, pTable.u.tab.pDfltList);
        }

        if (((db) == (null)) || ((db.pnBytesFreed) == (null)))
        {
            pTable.aCol = null;
            pTable.nCol = (short)(0);
            if ((((pTable).eTabType) == (0)))
            {
                pTable.u.tab.pDfltList = null;
            }
        }
    }
}</function>
  <function>public static void sqlite3DeleteFrom(Parse pParse, SrcList pTabList, Expr pWhere, ExprList pOrderBy, Expr pLimit)
{
    Vdbe v;
    Table pTab;
    int i = 0;
    WhereInfo pWInfo;
    Index pIdx;
    int iTabCur = 0;
    int iDataCur = (int)(0);
    int iIdxCur = (int)(0);
    int nIdx = 0;
    sqlite3 db;
    AuthContext sContext = new AuthContext();
    NameContext sNC = new NameContext();
    int iDb = 0;
    int memCnt = (int)(0);
    int rcauth = 0;
    int eOnePass = 0;
    int* aiCurOnePass = stackalloc int[2];
    byte* aToOpen = null;
    Index pPk;
    int iPk = (int)(0);
    short nPk = (short)(1);
    int iKey = 0;
    short nKey = 0;
    int iEphCur = (int)(0);
    int iRowSet = (int)(0);
    int addrBypass = (int)(0);
    int addrLoop = (int)(0);
    int addrEphOpen = (int)(0);
    int bComplex = 0;
    int isView = 0;
    Trigger pTrigger;
    CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(AuthContext)));
    db = pParse.db;
    if ((pParse.nErr) != 0)
    {
        goto delete_from_cleanup;
    }

    pTab = sqlite3SrcListLookup(pParse, pTabList);
    if ((pTab) == (null))
        goto delete_from_cleanup;
    pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(128), null, null);
    isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
    bComplex = (int)(((pTrigger) != null) || ((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) ? 1 : 0);
    if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
    {
        goto delete_from_cleanup;
    }

    if ((sqlite3IsReadOnly(pParse, pTab, (int)(pTrigger ? 1 : 0))) != 0)
    {
        goto delete_from_cleanup;
    }

    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    rcauth = (int)(sqlite3AuthCheck(pParse, (int)(9), pTab.zName, null, db.aDb[iDb].zDbSName));
    if ((rcauth) == (1))
    {
        goto delete_from_cleanup;
    }

    iTabCur = (int)(pTabList.a[0].iCursor = (int)(pParse.nTab++));
    for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
    {
        pParse.nTab++;
    }

    if ((isView) != 0)
    {
        sqlite3AuthContextPush(pParse, sContext, pTab.zName);
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) == (null))
    {
        goto delete_from_cleanup;
    }

    if ((pParse.nested) == (0))
        sqlite3VdbeCountChanges(v);
    sqlite3BeginWriteOperation(pParse, (int)(bComplex), (int)(iDb));
    if ((isView) != 0)
    {
        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, (int)(iTabCur));
        iDataCur = (int)(iIdxCur = (int)(iTabCur));
        pOrderBy = null;
        pLimit = null;
    }

    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    if ((sqlite3ResolveExprNames(sNC, pWhere)) != 0)
    {
        goto delete_from_cleanup;
    }

    if (((((db.flags &amp; ((ulong)(0x00001) &lt;&lt; 32)) != 0) &amp;&amp; (pParse.nested == 0)) &amp;&amp; (pParse.pTriggerTab == null)) &amp;&amp; (pParse.bReturning == 0))
    {
        memCnt = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(memCnt));
    }

    if (((((rcauth) == (0)) &amp;&amp; ((pWhere) == (null))) &amp;&amp; (bComplex == 0)) &amp;&amp; (!(((pTab).eTabType) == (1))))
    {
        sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(1), pTab.zName);
        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            sqlite3VdbeAddOp4(v, (int)(144), (int)(pTab.tnum), (int)(iDb), (int)((memCnt) != 0 ? memCnt : -1), pTab.zName, (int)(-1));
        }

        for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            sqlite3VdbeAddOp2(v, (int)(144), (int)(pIdx.tnum), (int)(iDb));
            if ((((pIdx).idxType) == (2)) &amp;&amp; (!(((pTab).tabFlags &amp; 0x00000080) == (0))))
            {
                sqlite3VdbeChangeP3(v, (int)(-1), (int)((memCnt) != 0 ? memCnt : -1));
            }
        }
    }
    else
    {
        ushort wcf = (ushort)(0x0004 | 0x0010);
        if ((sNC.ncFlags &amp; 0x000040) != 0)
            bComplex = (int)(1);
        wcf |= (ushort)((bComplex) != 0 ? 0 : 0x0008);
        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            pPk = null;
            nPk = (short)(1);
            iRowSet = (int)(++pParse.nMem);
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(iRowSet));
        }
        else
        {
            pPk = sqlite3PrimaryKeyIndex(pTab);
            nPk = (short)(pPk.nKeyCol);
            iPk = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(nPk);
            iEphCur = (int)(pParse.nTab++);
            addrEphOpen = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iEphCur), (int)(nPk)));
            sqlite3VdbeSetP4KeyInfo(pParse, pPk);
        }

        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, null, null, null, (ushort)(wcf), (int)(iTabCur + 1));
        if ((pWInfo) == (null))
            goto delete_from_cleanup;
        eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aiCurOnePass));
        if (eOnePass != 1)
            sqlite3MultiWrite(pParse);
        if ((sqlite3WhereUsesDeferredSeek(pWInfo)) != 0)
        {
            sqlite3VdbeAddOp1(v, (int)(142), (int)(iTabCur));
        }

        if ((memCnt) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(85), (int)(memCnt), (int)(1));
        }

        if ((pPk) != null)
        {
            for (i = (int)(0); (i) &lt; (nPk); i++)
            {
                sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iTabCur), (int)(pPk.aiColumn[i]), (int)(iPk + i));
            }

            iKey = (int)(iPk);
        }
        else
        {
            iKey = (int)(++pParse.nMem);
            sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iTabCur), (int)(-1), (int)(iKey));
        }

        if (eOnePass != 0)
        {
            nKey = (short)(nPk);
            aToOpen = sqlite3DbMallocRawNN(db, (ulong)(nIdx + 2));
            if ((aToOpen) == (null))
            {
                sqlite3WhereEnd(pWInfo);
                goto delete_from_cleanup;
            }

            CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
            aToOpen[nIdx + 1] = (byte)(0);
            if ((aiCurOnePass[0]) &gt;= (0))
                aToOpen[aiCurOnePass[0] - iTabCur] = (byte)(0);
            if ((aiCurOnePass[1]) &gt;= (0))
                aToOpen[aiCurOnePass[1] - iTabCur] = (byte)(0);
            if ((addrEphOpen) != 0)
                sqlite3VdbeChangeToNoop(v, (int)(addrEphOpen));
            addrBypass = (int)(sqlite3VdbeMakeLabel(pParse));
        }
        else
        {
            if ((pPk) != null)
            {
                iKey = (int)(++pParse.nMem);
                nKey = (short)(0);
                sqlite3VdbeAddOp4(v, (int)(96), (int)(iPk), (int)(nPk), (int)(iKey), sqlite3IndexAffinityStr(pParse.db, pPk), (int)(nPk));
                sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iEphCur), (int)(iKey), (int)(iPk), (int)(nPk));
            }
            else
            {
                nKey = (short)(1);
                sqlite3VdbeAddOp2(v, (int)(155), (int)(iRowSet), (int)(iKey));
            }

            sqlite3WhereEnd(pWInfo);
        }

        if (isView == 0)
        {
            int iAddrOnce = (int)(0);
            if ((eOnePass) == (2))
            {
                iAddrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
            }

            sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0x08), (int)(iTabCur), aToOpen, &amp;iDataCur, &amp;iIdxCur);
            if ((eOnePass) == (2))
            {
                sqlite3VdbeJumpHereOrPopInst(v, (int)(iAddrOnce));
            }
        }

        if (eOnePass != 0)
        {
            if ((!(((pTab).eTabType) == (1))) &amp;&amp; ((aToOpen[iDataCur - iTabCur]) != 0))
            {
                sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(addrBypass), (int)(iKey), (int)(nKey));
            }
        }
        else if ((pPk) != null)
        {
            addrLoop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iEphCur)));
            if ((((pTab).eTabType) == (1)))
            {
                sqlite3VdbeAddOp3(v, (int)(93), (int)(iEphCur), (int)(0), (int)(iKey));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(133), (int)(iEphCur), (int)(iKey));
            }
        }
        else
        {
            addrLoop = (int)(sqlite3VdbeAddOp3(v, (int)(45), (int)(iRowSet), (int)(0), (int)(iKey)));
        }

        if ((((pTab).eTabType) == (1)))
        {
            sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
            sqlite3VtabMakeWritable(pParse, pTab);
            sqlite3MayAbort(pParse);
            if ((eOnePass) == (1))
            {
                sqlite3VdbeAddOp1(v, (int)(121), (int)(iTabCur));
                if ((((pParse).pToplevel) == (null)))
                {
                    pParse.isMultiWrite = (byte)(0);
                }
            }

            sqlite3VdbeAddOp4(v, (int)(10), (int)(0), (int)(1), (int)(iKey), pVTab, (int)(-12));
            sqlite3VdbeChangeP5(v, (ushort)(2));
        }
        else
        {
            int count = (int)(((pParse.nested) == (0)) ? 1 : 0);
            sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(iKey), (short)(nKey), (byte)(count), (byte)(11), (byte)(eOnePass), (int)(aiCurOnePass[1]));
        }

        if (eOnePass != 0)
        {
            sqlite3VdbeResolveLabel(v, (int)(addrBypass));
            sqlite3WhereEnd(pWInfo);
        }
        else if ((pPk) != null)
        {
            sqlite3VdbeAddOp2(v, (int)(5), (int)(iEphCur), (int)(addrLoop + 1));
            sqlite3VdbeJumpHere(v, (int)(addrLoop));
        }
        else
        {
            sqlite3VdbeGoto(v, (int)(addrLoop));
            sqlite3VdbeJumpHere(v, (int)(addrLoop));
        }
    }

    if (((pParse.nested) == (0)) &amp;&amp; ((pParse.pTriggerTab) == (null)))
    {
        sqlite3AutoincrementEnd(pParse);
    }

    if ((memCnt) != 0)
    {
        sqlite3CodeChangeCount(v, (int)(memCnt), "rows deleted");
    }

    delete_from_cleanup:
        ; sqlite3AuthContextPop ( sContext ) ; 
    sqlite3SrcListDelete(db, pTabList);
    sqlite3ExprDelete(db, pWhere);
    sqlite3DbFree(db, aToOpen);
    return;
}</function>
  <function>public static void sqlite3DeleteIndexSamples(sqlite3 db, Index pIdx)
{
}</function>
  <function>public static void sqlite3DeleteReturning(sqlite3 db, Returning pRet)
{
    Hash* pHash;
    pHash = &amp;(db.aDb[1].pSchema.trigHash);
    sqlite3HashInsert(pHash, "sqlite_returning", null);
    sqlite3ExprListDelete(db, pRet.pReturnEL);
    sqlite3DbFree(db, pRet);
}</function>
  <function>public static void sqlite3DeleteTable(sqlite3 db, Table pTable)
{
    if (pTable == null)
        return;
    if ((((db == null) || ((db.pnBytesFreed) == (null))) &amp;&amp; ((--pTable.nTabRef) &gt; (0))))
        return;
    deleteTable(db, pTable);
}</function>
  <function>public static void sqlite3DeleteTrigger(sqlite3 db, Trigger pTrigger)
{
    if (((pTrigger) == (null)) || ((pTrigger.bReturning) != 0))
        return;
    sqlite3DeleteTriggerStep(db, pTrigger.step_list);
    sqlite3DbFree(db, pTrigger.zName);
    sqlite3DbFree(db, pTrigger.table);
    sqlite3ExprDelete(db, pTrigger.pWhen);
    sqlite3IdListDelete(db, pTrigger.pColumns);
    sqlite3DbFree(db, pTrigger);
}</function>
  <function>public static void sqlite3DeleteTriggerStep(sqlite3 db, TriggerStep pTriggerStep)
{
    while ((pTriggerStep) != null)
    {
        TriggerStep pTmp = pTriggerStep;
        pTriggerStep = pTriggerStep.pNext;
        sqlite3ExprDelete(db, pTmp.pWhere);
        sqlite3ExprListDelete(db, pTmp.pExprList);
        sqlite3SelectDelete(db, pTmp.pSelect);
        sqlite3IdListDelete(db, pTmp.pIdList);
        sqlite3UpsertDelete(db, pTmp.pUpsert);
        sqlite3SrcListDelete(db, pTmp.pFrom);
        sqlite3DbFree(db, pTmp.zSpan);
        sqlite3DbFree(db, pTmp);
    }
}</function>
  <function>public static void sqlite3Dequote(sbyte* z)
{
    sbyte quote = 0;
    int i = 0; int  j  =  0 ; 
    if ((z) == (null))
        return;
    quote = (sbyte)(z[0]);
    if ((sqlite3CtypeMap[(byte)(quote)] &amp; 0x80) == 0)
        return;
    if ((quote) == (91))
        quote = (sbyte)(93);
    for (i = (int)(1), j = (int)(0);; i++)
    {
        if ((z[i]) == (quote))
        {
            if ((z[i + 1]) == (quote))
            {
                z[j++] = (sbyte)(quote);
                i++;
            }
            else
            {
                break;
            }
        }
        else
        {
            z[j++] = (sbyte)(z[i]);
        }
    }

    z[j] = (sbyte)(0);
}</function>
  <function>public static void sqlite3DequoteExpr(Expr p)
{
    p.flags |= (uint)((p.u.zToken[0]) == (34) ? 0x4000000 | 0x000040 : 0x4000000);
    sqlite3Dequote(p.u.zToken);
}</function>
  <function>public static void sqlite3DequoteToken(Token* p)
{
    uint i = 0;
    if ((p-&gt;n) &lt; (2))
        return;
    if ((sqlite3CtypeMap[(byte)(p-&gt;z[0])] &amp; 0x80) == 0)
        return;
    for (i = (uint)(1); (i) &lt; (p-&gt;n - 1); i++)
    {
        if ((sqlite3CtypeMap[(byte)(p-&gt;z[i])] &amp; 0x80) != 0)
            return;
    }

    p-&gt;n -= (uint)(2);
    p-&gt;z++;
}</function>
  <function>public static void sqlite3Detach(Parse pParse, Expr pDbname)
{
    codeAttach(pParse, (int)(25), sqlite3Detach_detach_func, pDbname, null, null, pDbname);
}</function>
  <function>public static void sqlite3DropIndex(Parse pParse, SrcList pName, int ifExists)
{
    Index pIndex;
    Vdbe v;
    sqlite3 db = pParse.db;
    int iDb = 0;
    if ((db.mallocFailed) != 0)
    {
        goto exit_drop_index;
    }

    if (0 != sqlite3ReadSchema(pParse))
    {
        goto exit_drop_index;
    }

    pIndex = sqlite3FindIndex(db, pName.a[0].zName, pName.a[0].zDatabase);
    if ((pIndex) == (null))
    {
        if (ifExists == 0)
        {
            sqlite3ErrorMsg(pParse, "no such index: %S", pName.a);
        }
        else
        {
            sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
            sqlite3ForceNotReadOnly(pParse);
        }

        pParse.checkSchema = (byte)(1);
        goto exit_drop_index;
    }

    if (pIndex.idxType != 0)
    {
        sqlite3ErrorMsg(pParse, "index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped", (int)(0));
        goto exit_drop_index;
    }

    iDb = (int)(sqlite3SchemaToIndex(db, pIndex.pSchema));
    {
        int code = (int)(10);
        Table pTab = pIndex.pTable;
        sbyte* zDb = db.aDb[iDb].zDbSName;
        sbyte* zTab = (((!0) != 0) &amp;&amp; ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
        if ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0)
        {
            goto exit_drop_index;
        }

        if ((0 == 0) &amp;&amp; ((iDb) == (1)))
            code = (int)(12);
        if ((sqlite3AuthCheck(pParse, (int)(code), pIndex.zName, pTab.zName, zDb)) != 0)
        {
            goto exit_drop_index;
        }
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) != null)
    {
        sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
        sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='index'", db.aDb[iDb].zDbSName, pIndex.zName);
        sqlite3ClearStatTables(pParse, (int)(iDb), "idx", pIndex.zName);
        sqlite3ChangeCookie(pParse, (int)(iDb));
        destroyRootPage(pParse, (int)(pIndex.tnum), (int)(iDb));
        sqlite3VdbeAddOp4(v, (int)(151), (int)(iDb), (int)(0), (int)(0), pIndex.zName, (int)(0));
    }

    exit_drop_index:
        ; sqlite3SrcListDelete ( db ,  pName ) ; 
}</function>
  <function>public static void sqlite3DropTable(Parse pParse, SrcList pName, int isView, int noErr)
{
    Table pTab;
    Vdbe v;
    sqlite3 db = pParse.db;
    int iDb = 0;
    if ((db.mallocFailed) != 0)
    {
        goto exit_drop_table;
    }

    if ((sqlite3ReadSchema(pParse)) != 0)
        goto exit_drop_table;
    if ((noErr) != 0)
        db.suppressErr++;
    pTab = sqlite3LocateTableItem(pParse, (uint)(isView), pName.a[0]);
    if ((noErr) != 0)
        db.suppressErr--;
    if ((pTab) == (null))
    {
        if ((noErr) != 0)
        {
            sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
            sqlite3ForceNotReadOnly(pParse);
        }

        goto exit_drop_table;
    }

    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    if ((((pTab).eTabType) == (1)) &amp;&amp; ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0))
    {
        goto exit_drop_table;
    }

    {
        int code = 0;
        sbyte* zTab = (((!0) != 0) &amp;&amp; ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
        sbyte* zDb = db.aDb[iDb].zDbSName;
        sbyte* zArg2 = null;
        if ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0)
        {
            goto exit_drop_table;
        }

        if ((isView) != 0)
        {
            if ((0 == 0) &amp;&amp; ((iDb) == (1)))
            {
                code = (int)(15);
            }
            else
            {
                code = (int)(17);
            }
        }
        else if ((((pTab).eTabType) == (1)))
        {
            code = (int)(30);
            zArg2 = sqlite3GetVTable(db, pTab).pMod.zName;
        }
        else
        {
            if ((0 == 0) &amp;&amp; ((iDb) == (1)))
            {
                code = (int)(13);
            }
            else
            {
                code = (int)(11);
            }
        }

        if ((sqlite3AuthCheck(pParse, (int)(code), pTab.zName, zArg2, zDb)) != 0)
        {
            goto exit_drop_table;
        }

        if ((sqlite3AuthCheck(pParse, (int)(9), pTab.zName, null, zDb)) != 0)
        {
            goto exit_drop_table;
        }
    }

    if ((tableMayNotBeDropped(db, pTab)) != 0)
    {
        sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab.zName);
        goto exit_drop_table;
    }

    if (((isView) != 0) &amp;&amp; (!(((pTab).eTabType) == (2))))
    {
        sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab.zName);
        goto exit_drop_table;
    }

    if ((isView == 0) &amp;&amp; (((pTab).eTabType) == (2)))
    {
        sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab.zName);
        goto exit_drop_table;
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) != null)
    {
        sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
        if (isView == 0)
        {
            sqlite3ClearStatTables(pParse, (int)(iDb), "tbl", pTab.zName);
            sqlite3FkDropTable(pParse, pName, pTab);
        }

        sqlite3CodeDropTable(pParse, pTab, (int)(iDb), (int)(isView));
    }

    exit_drop_table:
        ; sqlite3SrcListDelete ( db ,  pName ) ; 
}</function>
  <function>public static void sqlite3DropTrigger(Parse pParse, SrcList pName, int noErr)
{
    Trigger pTrigger = null;
    int i = 0;
    sbyte* zDb;
    sbyte* zName;
    sqlite3 db = pParse.db;
    if ((db.mallocFailed) != 0)
        goto drop_trigger_cleanup;
    if (0 != sqlite3ReadSchema(pParse))
    {
        goto drop_trigger_cleanup;
    }

    zDb = pName.a[0].zDatabase;
    zName = pName.a[0].zName;
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        int j = (int)(((i) &lt; (2)) ? i ^ 1 : i);
        if (((zDb) != null) &amp;&amp; ((sqlite3DbIsNamed(db, (int)(j), zDb)) == (0)))
            continue;
        pTrigger = sqlite3HashFind(&amp;(db.aDb[j].pSchema.trigHash), zName);
        if ((pTrigger) != null)
            break;
    }

    if (pTrigger == null)
    {
        if (noErr == 0)
        {
            sqlite3ErrorMsg(pParse, "no such trigger: %S", pName.a);
        }
        else
        {
            sqlite3CodeVerifyNamedSchema(pParse, zDb);
        }

        pParse.checkSchema = (byte)(1);
        goto drop_trigger_cleanup;
    }

    sqlite3DropTriggerPtr(pParse, pTrigger);
    drop_trigger_cleanup:
        ; sqlite3SrcListDelete ( db ,  pName ) ; 
}</function>
  <function>public static void sqlite3DropTriggerPtr(Parse pParse, Trigger pTrigger)
{
    Table pTable;
    Vdbe v;
    sqlite3 db = pParse.db;
    int iDb = 0;
    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTrigger.pSchema));
    pTable = tableOfTrigger(pTrigger);
    if ((pTable) != null)
    {
        int code = (int)(16);
        sbyte* zDb = db.aDb[iDb].zDbSName;
        sbyte* zTab = (((!0) != 0) &amp;&amp; ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
        if ((iDb) == (1))
            code = (int)(14);
        if (((sqlite3AuthCheck(pParse, (int)(code), pTrigger.zName, pTable.zName, zDb)) != 0) || ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0))
        {
            return;
        }
    }

    if ((v = sqlite3GetVdbe(pParse)) != null)
    {
        sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='trigger'", db.aDb[iDb].zDbSName, pTrigger.zName);
        sqlite3ChangeCookie(pParse, (int)(iDb));
        sqlite3VdbeAddOp4(v, (int)(152), (int)(iDb), (int)(0), (int)(0), pTrigger.zName, (int)(0));
    }
}</function>
  <function>public static void sqlite3EndBenignMalloc()
{
    if ((sqlite3Hooks.xBenignEnd) != null)
    {
        sqlite3Hooks.xBenignEnd();
    }
}</function>
  <function>public static void sqlite3EndTable(Parse pParse, Token* pCons, Token* pEnd, uint tabOpts, Select pSelect)
{
    Table p;
    sqlite3 db = pParse.db;
    int iDb = 0;
    Index pIdx;
    if (((pEnd) == (null)) &amp;&amp; ((pSelect) == (null)))
    {
        return;
    }

    p = pParse.pNewTable;
    if ((p) == (null))
        return;
    if (((pSelect) == (null)) &amp;&amp; ((sqlite3ShadowTableName(db, p.zName)) != 0))
    {
        p.tabFlags |= (uint)(0x00001000);
    }

    if ((db.init.busy) != 0)
    {
        if (((pSelect) != null) || ((!(((p).eTabType) == (0))) &amp;&amp; ((db.init.newTnum) != 0)))
        {
            sqlite3ErrorMsg(pParse, "");
            return;
        }

        p.tnum = (uint)(db.init.newTnum);
        if ((p.tnum) == (1))
            p.tabFlags |= (uint)(0x00000001);
    }

    if ((tabOpts &amp; 0x00010000) != 0)
    {
        int ii = 0;
        p.tabFlags |= (uint)(0x00010000);
        for (ii = (int)(0); (ii) &lt; (p.nCol); ii++)
        {
            Column* pCol = &amp;p.aCol[ii];
            if ((pCol-&gt;eCType) == (0))
            {
                if ((pCol-&gt;colFlags &amp; 0x0004) != 0)
                {
                    sqlite3ErrorMsg(pParse, "unknown datatype for %s.%s: \"%s\"", p.zName, pCol-&gt;zCnName, sqlite3ColumnType(pCol, ""));
                }
                else
                {
                    sqlite3ErrorMsg(pParse, "missing datatype for %s.%s", p.zName, pCol-&gt;zCnName);
                }

                return;
            }
            else if ((pCol-&gt;eCType) == (1))
            {
                pCol-&gt;affinity = (sbyte)(0x41);
            }

            if ((((pCol-&gt;colFlags &amp; 0x0001) != 0) &amp;&amp; (p.iPKey != ii)) &amp;&amp; ((pCol-&gt;notNull) == (0)))
            {
                pCol-&gt;notNull = (uint)(2);
                p.tabFlags |= (uint)(0x00000800);
            }
        }
    }

    if ((tabOpts &amp; 0x00000080) != 0)
    {
        if ((p.tabFlags &amp; 0x00000008) != 0)
        {
            sqlite3ErrorMsg(pParse, "AUTOINCREMENT not allowed on WITHOUT ROWID tables");
            return;
        }

        if ((p.tabFlags &amp; 0x00000004) == (0))
        {
            sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p.zName);
            return;
        }

        p.tabFlags |= (uint)(0x00000080 | 0x00000200);
        convertToWithoutRowidTable(pParse, p);
    }

    iDb = (int)(sqlite3SchemaToIndex(db, p.pSchema));
    if ((p.pCheck) != null)
    {
        sqlite3ResolveSelfReference(pParse, p, (int)(0x000004), null, p.pCheck);
        if ((pParse.nErr) != 0)
        {
            sqlite3ExprListDelete(db, p.pCheck);
            p.pCheck = null;
        }
        else
        {
        }
    }

    if ((p.tabFlags &amp; 0x00000060) != 0)
    {
        int ii = 0;
        int nNG = (int)(0);
        for (ii = (int)(0); (ii) &lt; (p.nCol); ii++)
        {
            uint colFlags = (uint)(p.aCol[ii].colFlags);
            if ((colFlags &amp; 0x0060) != 0)
            {
                Expr pX = sqlite3ColumnExpr(p, &amp;p.aCol[ii]);
                if ((sqlite3ResolveSelfReference(pParse, p, (int)(0x000008), pX, null)) != 0)
                {
                    sqlite3ColumnSetExpr(pParse, p, &amp;p.aCol[ii], sqlite3ExprAlloc(db, (int)(121), null, (int)(0)));
                }
            }
            else
            {
                nNG++;
            }
        }

        if ((nNG) == (0))
        {
            sqlite3ErrorMsg(pParse, "must have at least one non-generated column");
            return;
        }
    }

    estimateTableWidth(p);
    for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
    {
        estimateIndexWidth(pIdx);
    }

    if (db.init.busy == 0)
    {
        int n = 0;
        Vdbe v;
        sbyte* zType;
        sbyte* zType2;
        sbyte* zStmt;
        v = sqlite3GetVdbe(pParse);
        if (((v) == (null)))
            return;
        sqlite3VdbeAddOp1(v, (int)(121), (int)(0));
        if ((((p).eTabType) == (0)))
        {
            zType = "table";
            zType2 = "TABLE";
        }
        else
        {
            zType = "view";
            zType2 = "VIEW";
        }

        if ((pSelect) != null)
        {
            SelectDest dest = new SelectDest();
            int regYield = 0;
            int addrTop = 0;
            int regRec = 0;
            int regRowid = 0;
            int addrInsLoop = 0;
            Table pSelTab;
            if ((pParse.eParseMode != 0))
            {
                pParse.rc = (int)(1);
                pParse.nErr++;
                return;
            }

            regYield = (int)(++pParse.nMem);
            regRec = (int)(++pParse.nMem);
            regRowid = (int)(++pParse.nMem);
            sqlite3MayAbort(pParse);
            sqlite3VdbeAddOp3(v, (int)(112), (int)(1), (int)(pParse.regRoot), (int)(iDb));
            sqlite3VdbeChangeP5(v, (ushort)(0x10));
            pParse.nTab = (int)(2);
            addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
            sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(addrTop));
            if ((pParse.nErr) != 0)
                return;
            pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, (sbyte)(0x41));
            if ((pSelTab) == (null))
                return;
            p.nCol = (short)(p.nNVCol = (short)(pSelTab.nCol));
            p.aCol = pSelTab.aCol;
            pSelTab.nCol = (short)(0);
            pSelTab.aCol = null;
            sqlite3DeleteTable(db, pSelTab);
            sqlite3SelectDestInit(dest, (int)(13), (int)(regYield));
            sqlite3Select(pParse, pSelect, dest);
            if ((pParse.nErr) != 0)
                return;
            sqlite3VdbeEndCoroutine(v, (int)(regYield));
            sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
            addrInsLoop = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm)));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(dest.iSdst), (int)(dest.nSdst), (int)(regRec));
            sqlite3TableAffinity(v, p, (int)(0));
            sqlite3VdbeAddOp2(v, (int)(126), (int)(1), (int)(regRowid));
            sqlite3VdbeAddOp3(v, (int)(127), (int)(1), (int)(regRec), (int)(regRowid));
            sqlite3VdbeGoto(v, (int)(addrInsLoop));
            sqlite3VdbeJumpHere(v, (int)(addrInsLoop));
            sqlite3VdbeAddOp1(v, (int)(121), (int)(1));
        }

        if ((pSelect) != null)
        {
            zStmt = createTableStmt(db, p);
        }
        else
        {
            Token* pEnd2 = (tabOpts) != 0 ? &amp;pParse.sLastToken : pEnd;
            n = ((int)(pEnd2-&gt;z - pParse.sNameToken.z));
            if (pEnd2-&gt;z[0] != 59)
                n += (int)(pEnd2-&gt;n);
            zStmt = sqlite3MPrintf(db, "CREATE %s %.*s", zType2, (int)(n), pParse.sNameToken.z);
        }

        sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q WHERE rowid=#%d", db.aDb[iDb].zDbSName, zType, p.zName, p.zName, (int)(pParse.regRoot), zStmt, (int)(pParse.regRowid));
        sqlite3DbFree(db, zStmt);
        sqlite3ChangeCookie(pParse, (int)(iDb));
        if (((p.tabFlags &amp; 0x00000008) != 0) &amp;&amp; (!(pParse.eParseMode != 0)))
        {
            Db pDb = db.aDb[iDb];
            if ((pDb.pSchema.pSeqTab) == (null))
            {
                sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", pDb.zDbSName);
            }
        }

        sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p.zName), (ushort)(0));
    }

    if ((db.init.busy) != 0)
    {
        Table pOld;
        Schema pSchema = p.pSchema;
        pOld = sqlite3HashInsert(&amp;pSchema.tblHash, p.zName, p);
        if ((pOld) != null)
        {
            sqlite3OomFault(db);
            return;
        }

        pParse.pNewTable = null;
        db.mDbFlags |= (uint)(0x0001);
        if ((CRuntime.strcmp(p.zName, "sqlite_sequence")) == (0))
        {
            p.pSchema.pSeqTab = p;
        }
    }

    if ((pSelect == null) &amp;&amp; (((p).eTabType) == (0)))
    {
        if ((pCons-&gt;z) == (null))
        {
            pCons = pEnd;
        }

        p.u.tab.addColOffset = (int)(13 + (int)(pCons-&gt;z - pParse.sNameToken.z));
    }
}</function>
  <function>public static void sqlite3EndTransaction(Parse pParse, int eType)
{
    Vdbe v;
    int isRollback = 0;
    isRollback = (int)((eType) == (12) ? 1 : 0);
    if ((sqlite3AuthCheck(pParse, (int)(22), (isRollback) != 0 ? "ROLLBACK" : "COMMIT", null, null)) != 0)
    {
        return;
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) != null)
    {
        sqlite3VdbeAddOp2(v, (int)(1), (int)(1), (int)(isRollback));
    }
}</function>
  <function>public static void sqlite3Error(sqlite3 db, int err_code)
{
    db.errCode = (int)(err_code);
    if (((err_code) != 0) || ((db.pErr) != null))
    {
        sqlite3ErrorFinish(db, (int)(err_code));
    }
    else
    {
        db.errByteOffset = (int)(-1);
    }
}</function>
  <function>public static void sqlite3ErrorClear(sqlite3 db)
{
    db.errCode = (int)(0);
    db.errByteOffset = (int)(-1);
    if ((db.pErr) != null)
        sqlite3ValueSetNull(db.pErr);
}</function>
  <function>public static void sqlite3ErrorFinish(sqlite3 db, int err_code)
{
    if ((db.pErr) != null)
        sqlite3ValueSetNull(db.pErr);
    sqlite3SystemError(db, (int)(err_code));
}</function>
  <function>public static void sqlite3ErrorIfNotEmpty(Parse pParse, sbyte* zDb, sbyte* zTab, sbyte* zErr)
{
    sqlite3NestedParse(pParse, "SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"", zErr, zDb, zTab);
}</function>
  <function>public static void sqlite3ErrorMsg(Parse pParse, sbyte* zFormat)
{
    sbyte* zMsg;
    sbyte* ap;
    sqlite3 db = pParse.db;
    db.errByteOffset = (int)(-2);
    (__va_start(&amp;ap, zFormat));
    zMsg = sqlite3VMPrintf(db, zFormat, ap);
    ((void)(ap = null));
    if ((db.errByteOffset) &lt; (-1))
        db.errByteOffset = (int)(-1);
    if ((db.suppressErr) != 0)
    {
        sqlite3DbFree(db, zMsg);
        if ((db.mallocFailed) != 0)
        {
            pParse.nErr++;
            pParse.rc = (int)(7);
        }
    }
    else
    {
        pParse.nErr++;
        sqlite3DbFree(db, pParse.zErrMsg);
        pParse.zErrMsg = zMsg;
        pParse.rc = (int)(1);
        pParse.pWith = null;
    }
}</function>
  <function>public static int sqlite3ErrorToParser(sqlite3 db, int errCode)
{
    Parse pParse;
    if (((db) == (null)) || ((pParse = db.pParse) == (null)))
        return (int)(errCode);
    pParse.rc = (int)(errCode);
    pParse.nErr++;
    return (int)(errCode);
}</function>
  <function>public static void sqlite3ErrorWithMsg(sqlite3 db, int err_code, sbyte* zFormat)
{
    db.errCode = (int)(err_code);
    sqlite3SystemError(db, (int)(err_code));
    if ((zFormat) == (null))
    {
        sqlite3Error(db, (int)(err_code));
    }
    else if (((db.pErr) != null) || ((db.pErr = sqlite3ValueNew(db)) != null))
    {
        sbyte* z;
        sbyte* ap;
        (__va_start(&amp;ap, zFormat));
        z = sqlite3VMPrintf(db, zFormat, ap);
        ((void)(ap = null));
        sqlite3ValueSetStr(db.pErr, (int)(-1), z, (byte)(1), ((Void(Void * ))(sqlite3OomFault)));
    }
}</function>
  <function>public static sbyte* sqlite3ErrStr(int rc)
{
    sbyte* zErr = "unknown error";
    switch (rc)
    {
        case (4 | (2 &lt;&lt; 8)):
        {
            zErr = "abort due to ROLLBACK";
            break;
        }

        case 100:
        {
            zErr = "another row available";
            break;
        }

        case 101:
        {
            zErr = "no more rows available";
            break;
        }

        default:
        {
            rc &amp;= (int)(0xff);
            if ((((rc) &gt;= (0)) &amp;&amp; ((rc) &lt; ((int)(29 * sizeof(sbyte) / sizeof(sbyte*))))) &amp;&amp; (sqlite3ErrStr_aMsg[rc] != null))
            {
                zErr = sqlite3ErrStr_aMsg[rc];
            }

            break;
        }
    }

    return zErr;
}</function>
  <function>public static ExprList sqlite3ExpandReturning(Parse pParse, ExprList pList, Table pTab)
{
    ExprList pNew = null;
    sqlite3 db = pParse.db;
    int i = 0;
    for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
    {
        Expr pOldExpr = pList.a[i].pExpr;
        if (((pOldExpr) == (null)))
            continue;
        if ((isAsteriskTerm(pParse, pOldExpr)) != 0)
        {
            int jj = 0;
            for (jj = (int)(0); (jj) &lt; (pTab.nCol); jj++)
            {
                Expr pNewExpr;
                if ((((pTab.aCol + jj)-&gt;colFlags &amp; 0x0002) != 0))
                    continue;
                pNewExpr = sqlite3Expr(db, (int)(59), pTab.aCol[jj].zCnName);
                pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
                if (db.mallocFailed == 0)
                {
                    ExprList_item* pItem = &amp;pNew.a[pNew.nExpr - 1];
                    pItem-&gt;zEName = sqlite3DbStrDup(db, pTab.aCol[jj].zCnName);
                    pItem-&gt;eEName = (uint)(0);
                }
            }
        }
        else
        {
            Expr pNewExpr = sqlite3ExprDup(db, pOldExpr, (int)(0));
            pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
            if ((db.mallocFailed == 0) &amp;&amp; (pList.a[i].zEName != null))
            {
                ExprList_item* pItem = &amp;pNew.a[pNew.nExpr - 1];
                pItem-&gt;zEName = sqlite3DbStrDup(db, pList.a[i].zEName);
                pItem-&gt;eEName = (uint)(pList.a[i].eEName);
            }
        }
    }

    return pNew;
}</function>
  <function>public static int sqlite3ExpandSubquery(Parse pParse, SrcItem pFrom)
{
    Select pSel = pFrom.pSelect;
    Table pTab;
    pFrom.pTab = pTab = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(Table)));
    if ((pTab) == (null))
        return (int)(7);
    pTab.nTabRef = (uint)(1);
    if ((pFrom.zAlias) != null)
    {
        pTab.zName = sqlite3DbStrDup(pParse.db, pFrom.zAlias);
    }
    else
    {
        pTab.zName = sqlite3MPrintf(pParse.db, "subquery_%u", (uint)(pSel.selId));
    }

    while ((pSel.pPrior) != null)
    {
        pSel = pSel.pPrior;
    }

    sqlite3ColumnsFromExprList(pParse, pSel.pEList, &amp;pTab.nCol, &amp;pTab.aCol);
    pTab.iPKey = (short)(-1);
    pTab.nRowLogEst = (short)(200);
    pTab.tabFlags |= (uint)(0x00004000 | 0x00000200);
    return (int)((pParse.nErr) != 0 ? 1 : 0);
}</function>
  <function>public static void sqlite3ExpirePreparedStatements(sqlite3 db, int iCode)
{
    Vdbe p;
    for (p = db.pVdbe; p; p = p.pNext)
    {
        p.expired = (uint)(iCode + 1);
    }
}</function>
  <function>public static Expr sqlite3Expr(sqlite3 db, int op, sbyte* zToken)
{
    Token x = new Token();
    x.z = zToken;
    x.n = (uint)(sqlite3Strlen30(zToken));
    return sqlite3ExprAlloc(db, (int)(op), &amp;x, (int)(0));
}</function>
  <function>public static Expr sqlite3ExprAddCollateString(Parse pParse, Expr pExpr, sbyte* zC)
{
    Token s = new Token();
    sqlite3TokenInit(&amp;s, zC);
    return sqlite3ExprAddCollateToken(pParse, pExpr, &amp;s, (int)(0));
}</function>
  <function>public static Expr sqlite3ExprAddCollateToken(Parse pParse, Expr pExpr, Token* pCollName, int dequote)
{
    if ((pCollName-&gt;n) &gt; (0))
    {
        Expr pNew = sqlite3ExprAlloc(pParse.db, (int)(113), pCollName, (int)(dequote));
        if ((pNew) != null)
        {
            pNew.pLeft = pExpr;
            pNew.flags |= (uint)(0x000100 | 0x001000);
            pExpr = pNew;
        }
    }

    return pExpr;
}</function>
  <function>public static sbyte sqlite3ExprAffinity(Expr pExpr)
{
    int op = 0;
    while ((((pExpr).flags &amp; (0x001000 | 0x020000)) != 0))
    {
        pExpr = pExpr.pLeft;
    }

    op = (int)(pExpr.op);
    if ((op) == (176))
        op = (int)(pExpr.op2);
    if (((op) == (167)) || ((op) == (169)))
    {
        if ((pExpr.y.pTab) != null)
        {
            return (sbyte)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
        }
    }

    if ((op) == (138))
    {
        return (sbyte)(sqlite3ExprAffinity(pExpr.x.pSelect.pEList.a[0].pExpr));
    }

    if ((op) == (36))
    {
        return (sbyte)(sqlite3AffinityType(pExpr.u.zToken, null));
    }

    if ((op) == (178))
    {
        return (sbyte)(sqlite3ExprAffinity(pExpr.pLeft.x.pSelect.pEList.a[pExpr.iColumn].pExpr));
    }

    if ((op) == (177))
    {
        return (sbyte)(sqlite3ExprAffinity(pExpr.x.pList.a[0].pExpr));
    }

    return (sbyte)(pExpr.affExpr);
}</function>
  <function>public static Expr sqlite3ExprAlloc(sqlite3 db, int op, Token* pToken, int dequote)
{
    Expr pNew;
    int nExtra = (int)(0);
    int iValue = (int)(0);
    if ((pToken) != null)
    {
        if (((op != 155) || ((pToken-&gt;z) == (null))) || ((sqlite3GetInt32(pToken-&gt;z, &amp;iValue)) == (0)))
        {
            nExtra = (int)(pToken-&gt;n + 1);
        }
    }

    pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Expr) + nExtra));
    if ((pNew) != null)
    {
        CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(Expr)));
        pNew.op = ((byte)(op));
        pNew.iAgg = (short)(-1);
        if ((pToken) != null)
        {
            if ((nExtra) == (0))
            {
                pNew.flags |= (uint)(0x000400 | 0x800000 | ((iValue) != 0 ? 0x10000000 : 0x20000000));
                pNew.u.iValue = (int)(iValue);
            }
            else
            {
                pNew.u.zToken = (sbyte*)(pNew[1]);
                if ((pToken-&gt;n) != 0)
                    CRuntime.memcpy(pNew.u.zToken, pToken-&gt;z, (ulong)(pToken-&gt;n));
                pNew.u.zToken[pToken-&gt;n] = (sbyte)(0);
                if (((dequote) != 0) &amp;&amp; ((sqlite3CtypeMap[(byte)(pNew.u.zToken[0])] &amp; 0x80) != 0))
                {
                    sqlite3DequoteExpr(pNew);
                }
            }
        }

        pNew.nHeight = (int)(1);
    }

    return pNew;
}</function>
  <function>public static void sqlite3ExprAnalyzeAggList(NameContext pNC, ExprList pList)
{
    ExprList_item* pItem;
    int i = 0;
    if ((pList) != null)
    {
        for (pItem = pList.a, i = (int)(0); (i) &lt; (pList.nExpr); i++, pItem++)
        {
            sqlite3ExprAnalyzeAggregates(pNC, pItem-&gt;pExpr);
        }
    }
}</function>
  <function>public static void sqlite3ExprAnalyzeAggregates(NameContext pNC, Expr pExpr)
{
    Walker w = new Walker();
    w.xExprCallback = analyzeAggregate;
    w.xSelectCallback = sqlite3WalkerDepthIncrease;
    w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
    w.walkerDepth = (int)(0);
    w.u.pNC = pNC;
    w.pParse = null;
    sqlite3WalkExpr(w, pExpr);
}</function>
  <function>public static Expr sqlite3ExprAnd(Parse pParse, Expr pLeft, Expr pRight)
{
    sqlite3 db = pParse.db;
    if ((pLeft) == (null))
    {
        return pRight;
    }
    else if ((pRight) == (null))
    {
        return pLeft;
    }
    else if (((((pLeft).flags &amp; (0x000001 | 0x20000000)) == (0x20000000)) || (((pRight).flags &amp; (0x000001 | 0x20000000)) == (0x20000000))) &amp;&amp; (!((pParse.eParseMode) &gt;= (2))))
    {
        sqlite3ExprDeferredDelete(pParse, pLeft);
        sqlite3ExprDeferredDelete(pParse, pRight);
        return sqlite3Expr(db, (int)(155), "0");
    }
    else
    {
        return sqlite3PExpr(pParse, (int)(44), pLeft, pRight);
    }
}</function>
  <function>public static void sqlite3ExprAssignVarNumber(Parse pParse, Expr pExpr, uint n)
{
    sqlite3 db = pParse.db;
    sbyte* z;
    short x = 0;
    if ((pExpr) == (null))
        return;
    z = pExpr.u.zToken;
    if ((z[1]) == (0))
    {
        x = (short)(++pParse.nVar);
    }
    else
    {
        int doAdd = (int)(0);
        if ((z[0]) == (63))
        {
            long i = 0;
            int bOk = 0;
            if ((n) == (2))
            {
                i = (long)(z[1] - 48);
                bOk = (int)(1);
            }
            else
            {
                bOk = (int)((0) == (sqlite3Atoi64(&amp;z[1], &amp;i, (int)(n - 1), (byte)(1))) ? 1 : 0);
            }

            if ((((bOk) == (0)) || ((i) &lt; (1))) || ((i) &gt; (db.aLimit[9])))
            {
                sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", (int)(db.aLimit[9]));
                sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
                return;
            }

            x = ((short)(i));
            if ((x) &gt; (pParse.nVar))
            {
                pParse.nVar = (short)((int)(x));
                doAdd = (int)(1);
            }
            else if ((sqlite3VListNumToName(pParse.pVList, (int)(x))) == (null))
            {
                doAdd = (int)(1);
            }
        }
        else
        {
            x = ((short)(sqlite3VListNameToNum(pParse.pVList, z, (int)(n))));
            if ((x) == (0))
            {
                x = (short)(++pParse.nVar);
                doAdd = (int)(1);
            }
        }

        if ((doAdd) != 0)
        {
            pParse.pVList = sqlite3VListAdd(db, pParse.pVList, z, (int)(n), (int)(x));
        }
    }

    pExpr.iColumn = (short)(x);
    if ((x) &gt; (db.aLimit[9]))
    {
        sqlite3ErrorMsg(pParse, "too many SQL variables");
        sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
    }
}</function>
  <function>public static void sqlite3ExprAttachSubtrees(sqlite3 db, Expr pRoot, Expr pLeft, Expr pRight)
{
    if ((pRoot) == (null))
    {
        sqlite3ExprDelete(db, pLeft);
        sqlite3ExprDelete(db, pRight);
    }
    else
    {
        if ((pRight) != null)
        {
            pRoot.pRight = pRight;
            pRoot.flags |= (uint)((0x000100 | 0x200000 | 0x000004) &amp; pRight.flags);
        }

        if ((pLeft) != null)
        {
            pRoot.pLeft = pLeft;
            pRoot.flags |= (uint)((0x000100 | 0x200000 | 0x000004) &amp; pLeft.flags);
        }

        exprSetHeight(pRoot);
    }
}</function>
  <function>public static int sqlite3ExprCanBeNull(Expr p)
{
    byte op = 0;
    while (((p.op) == (174)) || ((p.op) == (173)))
    {
        p = p.pLeft;
    }

    op = (byte)(p.op);
    if ((op) == (176))
        op = (byte)(p.op2);
    switch (op)
    {
        case 155:
        case 117:
        case 153:
        case 154:
            return (int)(0);
        case 167:
            ;
            return (((((p).flags &amp; (0x100000)) != 0) || ((p.y.pTab) == (null))) || ((((p.iColumn) &gt;= (0)) &amp;&amp; (p.y.pTab.aCol != null)) &amp;&amp; ((p.y.pTab.aCol[p.iColumn].notNull) == (0))) ? 1 : 0);
        default:
            return (int)(1);
    }
}</function>
  <function>public static int sqlite3ExprCheckHeight(Parse pParse, int nHeight)
{
    int rc = (int)(0);
    int mxHeight = (int)(pParse.db.aLimit[3]);
    if ((nHeight) &gt; (mxHeight))
    {
        sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", (int)(mxHeight));
        rc = (int)(1);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3ExprCheckIN(Parse pParse, Expr pIn)
{
    int nVector = (int)(sqlite3ExprVectorSize(pIn.pLeft));
    if ((((pIn).flags &amp; 0x000800) != 0) &amp;&amp; (pParse.db.mallocFailed == 0))
    {
        if (nVector != pIn.x.pSelect.pEList.nExpr)
        {
            sqlite3SubselectError(pParse, (int)(pIn.x.pSelect.pEList.nExpr), (int)(nVector));
            return (int)(1);
        }
    }
    else if (nVector != 1)
    {
        sqlite3VectorErrorMsg(pParse, pIn.pLeft);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3ExprCode(Parse pParse, Expr pExpr, int target)
{
    int inReg = 0;
    if ((pParse.pVdbe) == (null))
        return;
    inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(target)));
    if (inReg != target)
    {
        byte op = 0;
        if (((pExpr) != null) &amp;&amp; (((pExpr).flags &amp; (0x200000)) != 0))
        {
            op = (byte)(79);
        }
        else
        {
            op = (byte)(80);
        }

        sqlite3VdbeAddOp2(pParse.pVdbe, (int)(op), (int)(inReg), (int)(target));
    }
}</function>
  <function>public static void sqlite3ExprCodeCopy(Parse pParse, Expr pExpr, int target)
{
    sqlite3 db = pParse.db;
    pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
    if (db.mallocFailed == 0)
        sqlite3ExprCode(pParse, pExpr, (int)(target));
    sqlite3ExprDelete(db, pExpr);
}</function>
  <function>public static int sqlite3ExprCodeExprList(Parse pParse, ExprList pList, int target, int srcReg, byte flags)
{
    ExprList_item* pItem;
    int i = 0; int  j  =  0 ;  int  n  =  0 ; 
    byte copyOp = (byte)((flags &amp; 0x01) ? 79 : 80);
    Vdbe v = pParse.pVdbe;
    n = (int)(pList.nExpr);
    if (((pParse).okConstFactor) == 0)
        flags &amp;= (byte)(~0x02);
    for (pItem = pList.a, i = (int)(0); (i) &lt; (n); i++, pItem++)
    {
        Expr pExpr = pItem-&gt;pExpr;
        if (((flags &amp; 0x04) != 0) &amp;&amp; ((j = (int)(pItem-&gt;u.x.iOrderByCol)) &gt; (0)))
        {
            if ((flags &amp; 0x08) != 0)
            {
                i--;
                n--;
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(copyOp), (int)(j + srcReg - 1), (int)(target + i));
            }
        }
        else if (((flags &amp; 0x02) != 0) &amp;&amp; ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
        {
            sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(target + i));
        }
        else
        {
            int inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(target + i)));
            if (inReg != target + i)
            {
                VdbeOp* pOp;
                if ((((((copyOp) == (79)) &amp;&amp; (((pOp = sqlite3VdbeGetOp(v, (int)(-1)))-&gt;opcode) == (79))) &amp;&amp; ((pOp-&gt;p1 + pOp-&gt;p3 + 1) == (inReg))) &amp;&amp; ((pOp-&gt;p2 + pOp-&gt;p3 + 1) == (target + i))) &amp;&amp; ((pOp-&gt;p5) == (0)))
                {
                    pOp-&gt;p3++;
                }
                else
                {
                    sqlite3VdbeAddOp2(v, (int)(copyOp), (int)(inReg), (int)(target + i));
                }
            }
        }
    }

    return (int)(n);
}</function>
  <function>public static void sqlite3ExprCodeFactorable(Parse pParse, Expr pExpr, int target)
{
    if (((pParse.okConstFactor) != 0) &amp;&amp; ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
    {
        sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(target));
    }
    else
    {
        sqlite3ExprCodeCopy(pParse, pExpr, (int)(target));
    }
}</function>
  <function>public static void sqlite3ExprCodeGeneratedColumn(Parse pParse, Table pTab, Column* pCol, int regOut)
{
    int iAddr = 0;
    Vdbe v = pParse.pVdbe;
    if ((pParse.iSelfTab) &gt; (0))
    {
        iAddr = (int)(sqlite3VdbeAddOp3(v, (int)(22), (int)(pParse.iSelfTab - 1), (int)(0), (int)(regOut)));
    }
    else
    {
        iAddr = (int)(0);
    }

    sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), (int)(regOut));
    if ((pCol-&gt;affinity) &gt;= (0x42))
    {
        sqlite3VdbeAddOp4(v, (int)(95), (int)(regOut), (int)(1), (int)(0), &amp;pCol-&gt;affinity, (int)(1));
    }

    if ((iAddr) != 0)
        sqlite3VdbeJumpHere(v, (int)(iAddr));
}</function>
  <function>public static int sqlite3ExprCodeGetColumn(Parse pParse, Table pTab, int iColumn, int iTable, int iReg, byte p5)
{
    sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pTab, (int)(iTable), (int)(iColumn), (int)(iReg));
    if ((p5) != 0)
    {
        VdbeOp* pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(-1));
        if ((pOp-&gt;opcode) == (93))
            pOp-&gt;p5 = (ushort)(p5);
    }

    return (int)(iReg);
}</function>
  <function>public static void sqlite3ExprCodeGetColumnOfTable(Vdbe v, Table pTab, int iTabCur, int iCol, int regOut)
{
    Column* pCol;
    if ((pTab) == (null))
    {
        sqlite3VdbeAddOp3(v, (int)(93), (int)(iTabCur), (int)(iCol), (int)(regOut));
        return;
    }

    if (((iCol) &lt; (0)) || ((iCol) == (pTab.iPKey)))
    {
        sqlite3VdbeAddOp2(v, (int)(134), (int)(iTabCur), (int)(regOut));
    }
    else
    {
        int op = 0;
        int x = 0;
        if ((((pTab).eTabType) == (1)))
        {
            op = (int)(174);
            x = (int)(iCol);
        }
        else if (((pCol = &amp;pTab.aCol[iCol])-&gt;colFlags &amp; 0x0020) != 0)
        {
            Parse pParse = sqlite3VdbeParser(v);
            if ((pCol-&gt;colFlags &amp; 0x0100) != 0)
            {
                sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol-&gt;zCnName);
            }
            else
            {
                int savedSelfTab = (int)(pParse.iSelfTab);
                pCol-&gt;colFlags |= (ushort)(0x0100);
                pParse.iSelfTab = (int)(iTabCur + 1);
                sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(regOut));
                pParse.iSelfTab = (int)(savedSelfTab);
                pCol-&gt;colFlags &amp;= (ushort)(~0x0100);
            }

            return;
        }
        else if (!(((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            x = (int)(sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), (short)(iCol)));
            op = (int)(93);
        }
        else
        {
            x = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)));
            op = (int)(93);
        }

        sqlite3VdbeAddOp3(v, (int)(op), (int)(iTabCur), (int)(x), (int)(regOut));
        sqlite3ColumnDefault(v, pTab, (int)(iCol), (int)(regOut));
    }
}</function>
  <function>public static void sqlite3ExprCodeIN(Parse pParse, Expr pExpr, int destIfFalse, int destIfNull)
{
    int rRhsHasNull = (int)(0);
    int eType = 0;
    int rLhs = 0;
    int rLhsOrig = 0;
    Vdbe v;
    int* aiMap = null;
    sbyte* zAff = null;
    int nVector = 0;
    int iDummy = 0;
    Expr pLeft;
    int i = 0;
    int destStep2 = 0;
    int destStep6 = (int)(0);
    int addrTruthOp = 0;
    int destNotNull = 0;
    int addrTop = 0;
    int iTab = (int)(0);
    byte okConstFactor = (byte)(pParse.okConstFactor);
    pLeft = pExpr.pLeft;
    if ((sqlite3ExprCheckIN(pParse, pExpr)) != 0)
        return;
    zAff = exprINAffinity(pParse, pExpr);
    nVector = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
    aiMap = (int*)(sqlite3DbMallocZero(pParse.db, (ulong)(nVector * (sizeof(int) + sizeof(char)) + 1)));
    if ((pParse.db.mallocFailed) != 0)
        goto sqlite3ExprCodeIN_oom_error;
    v = pParse.pVdbe;
    eType = (int)(sqlite3FindInIndex(pParse, pExpr, (uint)(0x0002 | 0x0001), (destIfFalse) == (destIfNull) ? null : &amp;rRhsHasNull, aiMap, &amp;iTab));
    pParse.okConstFactor = (byte)(0);
    rLhsOrig = (int)(exprCodeVector(pParse, pLeft, &amp;iDummy));
    pParse.okConstFactor = (byte)(okConstFactor);
    for (i = (int)(0); ((i) &lt; (nVector)) &amp;&amp; ((aiMap[i]) == (i)); i++)
    {
    }

    if ((i) == (nVector))
    {
        rLhs = (int)(rLhsOrig);
    }
    else
    {
        rLhs = (int)(sqlite3GetTempRange(pParse, (int)(nVector)));
        for (i = (int)(0); (i) &lt; (nVector); i++)
        {
            sqlite3VdbeAddOp3(v, (int)(79), (int)(rLhsOrig + i), (int)(rLhs + aiMap[i]), (int)(0));
        }
    }

    if ((eType) == (5))
    {
        ExprList pList;
        CollSeq pColl;
        int labelOk = (int)(sqlite3VdbeMakeLabel(pParse));
        int r2 = 0;
        int regToFree = 0;
        int regCkNull = (int)(0);
        int ii = 0;
        pList = pExpr.x.pList;
        pColl = sqlite3ExprCollSeq(pParse, pExpr.pLeft);
        if (destIfNull != destIfFalse)
        {
            regCkNull = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp3(v, (int)(102), (int)(rLhs), (int)(rLhs), (int)(regCkNull));
        }

        for (ii = (int)(0); (ii) &lt; (pList.nExpr); ii++)
        {
            r2 = (int)(sqlite3ExprCodeTemp(pParse, pList.a[ii].pExpr, &amp;regToFree));
            if (((regCkNull) != 0) &amp;&amp; ((sqlite3ExprCanBeNull(pList.a[ii].pExpr)) != 0))
            {
                sqlite3VdbeAddOp3(v, (int)(102), (int)(regCkNull), (int)(r2), (int)(regCkNull));
            }

            sqlite3ReleaseTempReg(pParse, (int)(regToFree));
            if (((ii) &lt; (pList.nExpr - 1)) || (destIfNull != destIfFalse))
            {
                int op = (int)(rLhs != r2 ? 53 : 51);
                sqlite3VdbeAddOp4(v, (int)(op), (int)(rLhs), (int)(labelOk), (int)(r2), (void*)(pColl), (int)(-2));
                sqlite3VdbeChangeP5(v, (ushort)(zAff[0]));
            }
            else
            {
                int op = (int)(rLhs != r2 ? 52 : 50);
                sqlite3VdbeAddOp4(v, (int)(op), (int)(rLhs), (int)(destIfFalse), (int)(r2), (void*)(pColl), (int)(-2));
                sqlite3VdbeChangeP5(v, (ushort)(zAff[0] | 0x10));
            }
        }

        if ((regCkNull) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(50), (int)(regCkNull), (int)(destIfNull));
            sqlite3VdbeGoto(v, (int)(destIfFalse));
        }

        sqlite3VdbeResolveLabel(v, (int)(labelOk));
        sqlite3ReleaseTempReg(pParse, (int)(regCkNull));
        goto sqlite3ExprCodeIN_finished;
    }

    if ((destIfNull) == (destIfFalse))
    {
        destStep2 = (int)(destIfFalse);
    }
    else
    {
        destStep2 = (int)(destStep6 = (int)(sqlite3VdbeMakeLabel(pParse)));
    }

    for (i = (int)(0); (i) &lt; (nVector); i++)
    {
        Expr p = sqlite3VectorFieldSubexpr(pExpr.pLeft, (int)(i));
        if ((pParse.nErr) != 0)
            goto sqlite3ExprCodeIN_oom_error;
        if ((sqlite3ExprCanBeNull(p)) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(50), (int)(rLhs + i), (int)(destStep2));
        }
    }

    if ((eType) == (1))
    {
        sqlite3VdbeAddOp3(v, (int)(32), (int)(iTab), (int)(destIfFalse), (int)(rLhs));
        addrTruthOp = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
    }
    else
    {
        sqlite3VdbeAddOp4(v, (int)(95), (int)(rLhs), (int)(nVector), (int)(0), zAff, (int)(nVector));
        if ((destIfFalse) == (destIfNull))
        {
            sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iTab), (int)(destIfFalse), (int)(rLhs), (int)(nVector));
            goto sqlite3ExprCodeIN_finished;
        }

        addrTruthOp = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iTab), (int)(0), (int)(rLhs), (int)(nVector)));
    }

    if (((rRhsHasNull) != 0) &amp;&amp; ((nVector) == (1)))
    {
        sqlite3VdbeAddOp2(v, (int)(51), (int)(rRhsHasNull), (int)(destIfFalse));
    }

    if ((destIfFalse) == (destIfNull))
        sqlite3VdbeGoto(v, (int)(destIfFalse));
    if ((destStep6) != 0)
        sqlite3VdbeResolveLabel(v, (int)(destStep6));
    addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iTab), (int)(destIfFalse)));
    if ((nVector) &gt; (1))
    {
        destNotNull = (int)(sqlite3VdbeMakeLabel(pParse));
    }
    else
    {
        destNotNull = (int)(destIfFalse);
    }

    for (i = (int)(0); (i) &lt; (nVector); i++)
    {
        Expr p;
        CollSeq pColl;
        int r3 = (int)(sqlite3GetTempReg(pParse));
        p = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
        pColl = sqlite3ExprCollSeq(pParse, p);
        sqlite3VdbeAddOp3(v, (int)(93), (int)(iTab), (int)(i), (int)(r3));
        sqlite3VdbeAddOp4(v, (int)(52), (int)(rLhs + i), (int)(destNotNull), (int)(r3), (void*)(pColl), (int)(-2));
        sqlite3ReleaseTempReg(pParse, (int)(r3));
    }

    sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(destIfNull));
    if ((nVector) &gt; (1))
    {
        sqlite3VdbeResolveLabel(v, (int)(destNotNull));
        sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addrTop + 1));
        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(destIfFalse));
    }

    sqlite3VdbeJumpHere(v, (int)(addrTruthOp));
    sqlite3ExprCodeIN_finished:
        ; if  ( rLhs != rLhsOrig ) sqlite3ReleaseTempReg ( pParse ,  ( int ) ( rLhs ) ) ; 
    sqlite3ExprCodeIN_oom_error:
        ; sqlite3DbFree ( pParse . db ,  aiMap ) ; 
    sqlite3DbFree(pParse.db, zAff);
}</function>
  <function>public static void sqlite3ExprCodeLoadIndexColumn(Parse pParse, Index pIdx, int iTabCur, int iIdxCol, int regOut)
{
    short iTabCol = (short)(pIdx.aiColumn[iIdxCol]);
    if ((iTabCol) == (-2))
    {
        pParse.iSelfTab = (int)(iTabCur + 1);
        sqlite3ExprCodeCopy(pParse, pIdx.aColExpr.a[iIdxCol].pExpr, (int)(regOut));
        pParse.iSelfTab = (int)(0);
    }
    else
    {
        sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pIdx.pTable, (int)(iTabCur), (int)(iTabCol), (int)(regOut));
    }
}</function>
  <function>public static void sqlite3ExprCodeMove(Parse pParse, int iFrom, int iTo, int nReg)
{
    sqlite3VdbeAddOp3(pParse.pVdbe, (int)(78), (int)(iFrom), (int)(iTo), (int)(nReg));
}</function>
  <function>public static int sqlite3ExprCodeRunJustOnce(Parse pParse, Expr pExpr, int regDest)
{
    ExprList p;
    p = pParse.pConstExpr;
    if (((regDest) &lt; (0)) &amp;&amp; ((p) != null))
    {
        ExprList_item* pItem;
        int i = 0;
        for (pItem = p.a, i = (int)(p.nExpr); (i) &gt; (0); pItem++, i--)
        {
            if (((pItem-&gt;reusable) != 0) &amp;&amp; ((sqlite3ExprCompare(null, pItem-&gt;pExpr, pExpr, (int)(-1))) == (0)))
            {
                return (int)(pItem-&gt;u.iConstExprReg);
            }
        }
    }

    pExpr = sqlite3ExprDup(pParse.db, pExpr, (int)(0));
    if ((pExpr != null) &amp;&amp; (((pExpr).flags &amp; (0x000004)) != 0))
    {
        Vdbe v = pParse.pVdbe;
        int addr = 0;
        addr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
        pParse.okConstFactor = (byte)(0);
        if (pParse.db.mallocFailed == 0)
        {
            if ((regDest) &lt; (0))
                regDest = (int)(++pParse.nMem);
            sqlite3ExprCode(pParse, pExpr, (int)(regDest));
        }

        pParse.okConstFactor = (byte)(1);
        sqlite3ExprDelete(pParse.db, pExpr);
        sqlite3VdbeJumpHere(v, (int)(addr));
    }
    else
    {
        p = sqlite3ExprListAppend(pParse, p, pExpr);
        if ((p) != null)
        {
            ExprList_item* pItem = &amp;p.a[p.nExpr - 1];
            pItem-&gt;reusable = (uint)((regDest) &lt; (0));
            if ((regDest) &lt; (0))
                regDest = (int)(++pParse.nMem);
            pItem-&gt;u.iConstExprReg = (int)(regDest);
        }

        pParse.pConstExpr = p;
    }

    return (int)(regDest);
}</function>
  <function>public static int sqlite3ExprCodeTarget(Parse pParse, Expr pExpr, int target)
{
    Vdbe v = pParse.pVdbe;
    int op = 0;
    int inReg = (int)(target);
    int regFree1 = (int)(0);
    int regFree2 = (int)(0);
    int r1 = 0; int  r2  =  0 ; 
    Expr tempX = new Expr();
    int p5 = (int)(0);
    expr_code_doover:
        ; if  ( ( pExpr ) == ( null ) ) { op  =  ( int ) ( 121 ) ;  } else  { op  =  ( int ) ( pExpr . op ) ;  }
    switch (op)
    {
        case 169:
        {
            AggInfo pAggInfo = pExpr.pAggInfo;
            AggInfo_col pCol;
            pCol = pAggInfo.aCol[pExpr.iAgg];
            if (pAggInfo.directMode == 0)
            {
                return (int)(pCol.iMem);
            }
            else if ((pAggInfo.useSortingIdx) != 0)
            {
                Table pTab = pCol.pTab;
                sqlite3VdbeAddOp3(v, (int)(93), (int)(pAggInfo.sortingIdxPTab), (int)(pCol.iSorterColumn), (int)(target));
                if ((pCol.iColumn) &lt; (0))
                {
                }
                else
                {
                    if ((pTab.aCol[pCol.iColumn].affinity) == (0x45))
                    {
                        sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
                    }
                }

                return (int)(target);
            }
        }

        case 167:
        {
            int iTab = (int)(pExpr.iTable);
            int iReg = 0;
            if ((((pExpr).flags &amp; (0x000008)) != 0))
            {
                int aff = 0;
                iReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
                if ((pExpr.y.pTab) != null)
                {
                    aff = (int)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
                }
                else
                {
                    aff = (int)(pExpr.affExpr);
                }

                if ((aff) &gt; (0x41))
                {
                    sqlite3VdbeAddOp4(v, (int)(95), (int)(iReg), (int)(1), (int)(0), &amp;sqlite3ExprCodeTarget_zAff[(aff - 66) * 2], (int)(-1));
                }

                return (int)(iReg);
            }

            if ((iTab) &lt; (0))
            {
                if ((pParse.iSelfTab) &lt; (0))
                {
                    Column* pCol;
                    Table pTab;
                    int iSrc = 0;
                    int iCol = (int)(pExpr.iColumn);
                    pTab = pExpr.y.pTab;
                    if ((iCol) &lt; (0))
                    {
                        return (int)(-1 - pParse.iSelfTab);
                    }

                    pCol = pTab.aCol + iCol;
                    iSrc = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)) - pParse.iSelfTab);
                    if ((pCol-&gt;colFlags &amp; 0x0060) != 0)
                    {
                        if ((pCol-&gt;colFlags &amp; 0x0100) != 0)
                        {
                            sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol-&gt;zCnName);
                            return (int)(0);
                        }

                        pCol-&gt;colFlags |= (ushort)(0x0100);
                        if ((pCol-&gt;colFlags &amp; 0x0080) != 0)
                        {
                            sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(iSrc));
                        }

                        pCol-&gt;colFlags &amp;= (ushort)(~(0x0100 | 0x0080));
                        return (int)(iSrc);
                    }
                    else if ((pCol-&gt;affinity) == (0x45))
                    {
                        sqlite3VdbeAddOp2(v, (int)(80), (int)(iSrc), (int)(target));
                        sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
                        return (int)(target);
                    }
                    else
                    {
                        return (int)(iSrc);
                    }
                }
                else
                {
                    iTab = (int)(pParse.iSelfTab - 1);
                }
            }

            iReg = (int)(sqlite3ExprCodeGetColumn(pParse, pExpr.y.pTab, (int)(pExpr.iColumn), (int)(iTab), (int)(target), (byte)(pExpr.op2)));
            if (((pExpr.y.pTab) == (null)) &amp;&amp; ((pExpr.affExpr) == (0x45)))
            {
                sqlite3VdbeAddOp1(v, (int)(86), (int)(iReg));
            }

            return (int)(iReg);
        }

        case 155:
        {
            codeInteger(pParse, pExpr, (int)(0), (int)(target));
            return (int)(target);
        }

        case 170:
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprTruthValue(pExpr)), (int)(target));
            return (int)(target);
        }

        case 153:
        {
            codeReal(v, pExpr.u.zToken, (int)(0), (int)(target));
            return (int)(target);
        }

        case 117:
        {
            sqlite3VdbeLoadString(v, (int)(target), pExpr.u.zToken);
            return (int)(target);
        }

        default:
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
            return (int)(target);
        }

        case 154:
        {
            int n = 0;
            sbyte* z;
            sbyte* zBlob;
            z = &amp;pExpr.u.zToken[2];
            n = (int)(sqlite3Strlen30(z) - 1);
            zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, (int)(n));
            sqlite3VdbeAddOp4(v, (int)(76), (int)(n / 2), (int)(target), (int)(0), zBlob, (int)(-7));
            return (int)(target);
        }

        case 156:
        {
            sqlite3VdbeAddOp2(v, (int)(77), (int)(pExpr.iColumn), (int)(target));
            if (pExpr.u.zToken[1] != 0)
            {
                sbyte* z = sqlite3VListNumToName(pParse.pVList, (int)(pExpr.iColumn));
                pParse.pVList[0] = (int)(0);
                sqlite3VdbeAppendP4(v, z, (int)(-1));
            }

            return (int)(target);
        }

        case 176:
        {
            return (int)(pExpr.iTable);
        }

        case 36:
        {
            inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
            if (inReg != target)
            {
                sqlite3VdbeAddOp2(v, (int)(80), (int)(inReg), (int)(target));
                inReg = (int)(target);
            }

            sqlite3VdbeAddOp2(v, (int)(87), (int)(target), (int)(sqlite3AffinityType(pExpr.u.zToken, null)));
            return (int)(inReg);
        }

        case 45:
        case 171:
            op = (int)(((op) == (45)) ? 53 : 52);
            p5 = (int)(0x80);
        case 56:
        case 55:
        case 54:
        case 57:
        case 52:
        case 53:
        {
            Expr pLeft = pExpr.pLeft;
            if ((sqlite3ExprIsVector(pLeft)) != 0)
            {
                codeVectorCompare(pParse, pExpr, (int)(target), (byte)(op), (byte)(p5));
            }
            else
            {
                r1 = (int)(sqlite3ExprCodeTemp(pParse, pLeft, &amp;regFree1));
                r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &amp;regFree2));
                sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(inReg));
                codeCompare(pParse, pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(p5), (int)(((pExpr).flags &amp; (0x000200)) != 0));
                if ((p5) == (0x80))
                {
                    sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(inReg));
                }
                else
                {
                    sqlite3VdbeAddOp3(v, (int)(91), (int)(r1), (int)(inReg), (int)(r2));
                }
            }

            break;
        }

        case 44:
        case 43:
        case 106:
        case 108:
        case 107:
        case 110:
        case 102:
        case 103:
        case 109:
        case 104:
        case 105:
        case 111:
        {
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &amp;regFree2));
            sqlite3VdbeAddOp3(v, (int)(op), (int)(r2), (int)(r1), (int)(target));
            break;
        }

        case 173:
        {
            Expr pLeft = pExpr.pLeft;
            if ((pLeft.op) == (155))
            {
                codeInteger(pParse, pLeft, (int)(1), (int)(target));
                return (int)(target);
            }
            else if ((pLeft.op) == (153))
            {
                codeReal(v, pLeft.u.zToken, (int)(1), (int)(target));
                return (int)(target);
            }
            else
            {
                tempX.op = (byte)(155);
                tempX.flags = (uint)(0x000400 | 0x004000);
                tempX.u.iValue = (int)(0);
                r1 = (int)(sqlite3ExprCodeTemp(pParse, tempX, &amp;regFree1));
                r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree2));
                sqlite3VdbeAddOp3(v, (int)(107), (int)(r2), (int)(r1), (int)(target));
            }

            break;
        }

        case 114:
        case 19:
        {
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(inReg));
            break;
        }

        case 175:
        {
            int isTrue = 0;
            int bNormal = 0;
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
            bNormal = (int)((pExpr.op2) == (45) ? 1 : 0);
            sqlite3VdbeAddOp4Int(v, (int)(90), (int)(r1), (int)(inReg), (int)(!isTrue), (int)(isTrue ^ bNormal));
            break;
        }

        case 50:
        case 51:
        {
            int addr = 0;
            sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(target));
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            addr = (int)(sqlite3VdbeAddOp1(v, (int)(op), (int)(r1)));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(target));
            sqlite3VdbeJumpHere(v, (int)(addr));
            break;
        }

        case 168:
        {
            AggInfo pInfo = pExpr.pAggInfo;
            if ((((pInfo) == (null)) || ((pExpr.iAgg) &lt; (0))) || ((pExpr.iAgg) &gt;= (pInfo.nFunc)))
            {
                sqlite3ErrorMsg(pParse, "misuse of aggregate: %#T()", pExpr);
            }
            else
            {
                return (int)(pInfo.aFunc[pExpr.iAgg].iMem);
            }

            break;
        }

        case 172:
        {
            ExprList pFarg;
            int nFarg = 0;
            FuncDef pDef;
            sbyte* zId;
            uint constMask = (uint)(0);
            int i = 0;
            sqlite3 db = pParse.db;
            byte enc = (byte)((db).enc);
            CollSeq pColl = null;
            if ((((pExpr).flags &amp; (0x1000000)) != 0))
            {
                return (int)(pExpr.y.pWin.regResult);
            }

            if ((((pParse).okConstFactor) != 0) &amp;&amp; ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
            {
                return (int)(sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(-1)));
            }

            pFarg = pExpr.x.pList;
            nFarg = (int)(pFarg ? pFarg.nExpr : 0);
            zId = pExpr.u.zToken;
            pDef = sqlite3FindFunction(db, zId, (int)(nFarg), (byte)(enc), (byte)(0));
            if (((pDef) == (null)) || (pDef.xFinalize != null))
            {
                sqlite3ErrorMsg(pParse, "unknown function: %#T()", pExpr);
                break;
            }

            if ((pDef.funcFlags &amp; 0x00400000) != 0)
            {
                return (int)(exprCodeInlineFunction(pParse, pFarg, ((int)((long)(pDef.pUserData))), (int)(target)));
            }
            else if ((pDef.funcFlags &amp; (0x00080000 | 0x00200000)) != 0)
            {
                sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
            }

            for (i = (int)(0); (i) &lt; (nFarg); i++)
            {
                if (((i) &lt; (32)) &amp;&amp; ((sqlite3ExprIsConstant(pFarg.a[i].pExpr)) != 0))
                {
                    constMask |= (uint)(((uint)(1)) &lt;&lt; (i));
                }

                if (((pDef.funcFlags &amp; 0x0020) != 0) &amp;&amp; (pColl == null))
                {
                    pColl = sqlite3ExprCollSeq(pParse, pFarg.a[i].pExpr);
                }
            }

            if ((pFarg) != null)
            {
                if ((constMask) != 0)
                {
                    r1 = (int)(pParse.nMem + 1);
                    pParse.nMem += (int)(nFarg);
                }
                else
                {
                    r1 = (int)(sqlite3GetTempRange(pParse, (int)(nFarg)));
                }

                if ((pDef.funcFlags &amp; (0x0040 | 0x0080)) != 0)
                {
                    byte exprOp = 0;
                    exprOp = (byte)(pFarg.a[0].pExpr.op);
                    if (((exprOp) == (167)) || ((exprOp) == (169)))
                    {
                        pFarg.a[0].pExpr.op2 = (byte)(pDef.funcFlags &amp; (0x40 | 0x80));
                    }
                }

                sqlite3ExprCodeExprList(pParse, pFarg, (int)(r1), (int)(0), (byte)(0x01 | 0x02));
            }
            else
            {
                r1 = (int)(0);
            }

            if (((nFarg) &gt;= (2)) &amp;&amp; (((pExpr).flags &amp; (0x000080)) != 0))
            {
                pDef = sqlite3VtabOverloadFunction(db, pDef, (int)(nFarg), pFarg.a[1].pExpr);
            }
            else if ((nFarg) &gt; (0))
            {
                pDef = sqlite3VtabOverloadFunction(db, pDef, (int)(nFarg), pFarg.a[0].pExpr);
            }

            if ((pDef.funcFlags &amp; 0x0020) != 0)
            {
                if (pColl == null)
                    pColl = db.pDfltColl;
                sqlite3VdbeAddOp4(v, (int)(84), (int)(0), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
            }

            {
                sqlite3VdbeAddFunctionCall(pParse, (int)(constMask), (int)(r1), (int)(target), (int)(nFarg), pDef, (int)(pExpr.op2));
            }

            if ((nFarg) != 0)
            {
                if ((constMask) == (0))
                {
                    sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(nFarg));
                }
                else
                {
                }
            }

            return (int)(target);
        }

        case 20:
        case 138:
        {
            int nCol = 0;
            if ((pParse.db.mallocFailed) != 0)
            {
                return (int)(0);
            }
            else if ((((op) == (138)) &amp;&amp; ((((pExpr).flags &amp; 0x000800) != 0) != 0)) &amp;&amp; ((nCol = (int)(pExpr.x.pSelect.pEList.nExpr)) != 1))
            {
                sqlite3SubselectError(pParse, (int)(nCol), (int)(1));
            }
            else
            {
                return (int)(sqlite3CodeSubselect(pParse, pExpr));
            }

            break;
        }

        case 178:
        {
            int n = 0;
            if ((pExpr.pLeft.iTable) == (0))
            {
                pExpr.pLeft.iTable = (int)(sqlite3CodeSubselect(pParse, pExpr.pLeft));
            }

            n = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
            if (pExpr.iTable != n)
            {
                sqlite3ErrorMsg(pParse, "%d columns assigned %d values", (int)(pExpr.iTable), (int)(n));
            }

            return (int)(pExpr.pLeft.iTable + pExpr.iColumn);
        }

        case 49:
        {
            int destIfFalse = (int)(sqlite3VdbeMakeLabel(pParse));
            int destIfNull = (int)(sqlite3VdbeMakeLabel(pParse));
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
            sqlite3ExprCodeIN(pParse, pExpr, (int)(destIfFalse), (int)(destIfNull));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(target));
            sqlite3VdbeResolveLabel(v, (int)(destIfFalse));
            sqlite3VdbeAddOp2(v, (int)(85), (int)(target), (int)(0));
            sqlite3VdbeResolveLabel(v, (int)(destIfNull));
            return (int)(target);
        }

        case 48:
        {
            exprCodeBetween(pParse, pExpr, (int)(target), null, (int)(0));
            return (int)(target);
        }

        case 181:
        case 113:
        case 174:
        {
            pExpr = pExpr.pLeft;
            goto expr_code_doover;
        }

        case 77:
        {
            Table pTab;
            int iCol = 0;
            int p1 = 0;
            pTab = pExpr.y.pTab;
            iCol = (int)(pExpr.iColumn);
            p1 = (int)(pExpr.iTable * (pTab.nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, (short)(iCol)));
            sqlite3VdbeAddOp2(v, (int)(156), (int)(p1), (int)(target));
            if (((iCol) &gt;= (0)) &amp;&amp; ((pTab.aCol[iCol].affinity) == (0x45)))
            {
                sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
            }

            break;
        }

        case 177:
        {
            sqlite3ErrorMsg(pParse, "row value misused");
            break;
        }

        case 179:
        {
            int addrINR = 0;
            byte okConstFactor = (byte)(pParse.okConstFactor);
            addrINR = (int)(sqlite3VdbeAddOp1(v, (int)(22), (int)(pExpr.iTable)));
            pParse.okConstFactor = (byte)(0);
            inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
            pParse.okConstFactor = (byte)(okConstFactor);
            sqlite3VdbeJumpHere(v, (int)(addrINR));
            sqlite3VdbeChangeP3(v, (int)(addrINR), (int)(inReg));
            break;
        }

        case 157:
        {
            int endLabel = 0;
            int nextCase = 0;
            int nExpr = 0;
            int i = 0;
            ExprList pEList;
            ExprList_item* aListelem;
            Expr opCompare = new Expr();
            Expr pX;
            Expr pTest = null;
            Expr pDel = null;
            sqlite3 db = pParse.db;
            pEList = pExpr.x.pList;
            aListelem = pEList.a;
            nExpr = (int)(pEList.nExpr);
            endLabel = (int)(sqlite3VdbeMakeLabel(pParse));
            if ((pX = pExpr.pLeft) != null)
            {
                pDel = sqlite3ExprDup(db, pX, (int)(0));
                if ((db.mallocFailed) != 0)
                {
                    sqlite3ExprDelete(db, pDel);
                    break;
                }

                exprToRegister(pDel, (int)(exprCodeVector(pParse, pDel, &amp;regFree1)));
                CRuntime.memset(opCompare, (int)(0), (ulong)(sizeof(Expr)));
                opCompare.op = (byte)(53);
                opCompare.pLeft = pDel;
                pTest = opCompare;
                regFree1 = (int)(0);
            }

            for (i = (int)(0); (i) &lt; (nExpr - 1); i = (int)(i + 2))
            {
                if ((pX) != null)
                {
                    opCompare.pRight = aListelem[i].pExpr;
                }
                else
                {
                    pTest = aListelem[i].pExpr;
                }

                nextCase = (int)(sqlite3VdbeMakeLabel(pParse));
                sqlite3ExprIfFalse(pParse, pTest, (int)(nextCase), (int)(0x10));
                sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, (int)(target));
                sqlite3VdbeGoto(v, (int)(endLabel));
                sqlite3VdbeResolveLabel(v, (int)(nextCase));
            }

            if ((nExpr &amp; 1) != 0)
            {
                sqlite3ExprCode(pParse, pEList.a[nExpr - 1].pExpr, (int)(target));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
            }

            sqlite3ExprDelete(db, pDel);
            setDoNotMergeFlagOnCopy(v);
            sqlite3VdbeResolveLabel(v, (int)(endLabel));
            break;
        }

        case 71:
        {
            if ((pParse.pTriggerTab == null) &amp;&amp; (pParse.nested == 0))
            {
                sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program");
                return (int)(0);
            }

            if ((pExpr.affExpr) == (2))
            {
                sqlite3MayAbort(pParse);
            }

            if ((pExpr.affExpr) == (4))
            {
                sqlite3VdbeAddOp4(v, (int)(70), (int)(0), (int)(4), (int)(0), pExpr.u.zToken, (int)(0));
            }
            else
            {
                sqlite3HaltConstraint(pParse, (int)(pParse.pTriggerTab ? (19 | (7 &lt;&lt; 8)) : 1), (int)(pExpr.affExpr), pExpr.u.zToken, (sbyte)(0), (byte)(0));
            }

            break;
        }
    }

    sqlite3ReleaseTempReg(pParse, (int)(regFree1));
    sqlite3ReleaseTempReg(pParse, (int)(regFree2));
    return (int)(inReg);
}</function>
  <function>public static int sqlite3ExprCodeTemp(Parse pParse, Expr pExpr, int* pReg)
{
    int r2 = 0;
    pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
    if ((((((pParse).okConstFactor) != 0) &amp;&amp; (pExpr != null)) &amp;&amp; (pExpr.op != 176)) &amp;&amp; ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
    {
        *pReg = (int)(0);
        r2 = (int)(sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(-1)));
    }
    else
    {
        int r1 = (int)(sqlite3GetTempReg(pParse));
        r2 = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(r1)));
        if ((r2) == (r1))
        {
            *pReg = (int)(r1);
        }
        else
        {
            sqlite3ReleaseTempReg(pParse, (int)(r1));
            *pReg = (int)(0);
        }
    }

    return (int)(r2);
}</function>
  <function>public static CollSeq sqlite3ExprCollSeq(Parse pParse, Expr pExpr)
{
    sqlite3 db = pParse.db;
    CollSeq pColl = null;
    Expr p = pExpr;
    while ((p) != null)
    {
        int op = (int)(p.op);
        if ((op) == (176))
            op = (int)(p.op2);
        if ((((op) == (169)) || ((op) == (167))) || ((op) == (77)))
        {
            if (p.y.pTab != null)
            {
                int j = (int)(p.iColumn);
                if ((j) &gt;= (0))
                {
                    sbyte* zColl = sqlite3ColumnColl(&amp;p.y.pTab.aCol[j]);
                    pColl = sqlite3FindCollSeq(db, (byte)((db).enc), zColl, (int)(0));
                }

                break;
            }
        }

        if (((op) == (36)) || ((op) == (174)))
        {
            p = p.pLeft;
            continue;
        }

        if ((op) == (177))
        {
            p = p.x.pList.a[0].pExpr;
            continue;
        }

        if ((op) == (113))
        {
            pColl = sqlite3GetCollSeq(pParse, (byte)((db).enc), null, p.u.zToken);
            break;
        }

        if ((p.flags &amp; 0x000100) != 0)
        {
            if (((p.pLeft) != null) &amp;&amp; ((p.pLeft.flags &amp; 0x000100) != 0))
            {
                p = p.pLeft;
            }
            else
            {
                Expr pNext = p.pRight;
                if ((p.x.pList != null) &amp;&amp; (db.mallocFailed == 0))
                {
                    int i = 0;
                    for (i = (int)(0); ((i) &lt; (p.x.pList.nExpr)); i++)
                    {
                        if ((((p.x.pList.a[i].pExpr).flags &amp; (0x000100)) != 0))
                        {
                            pNext = p.x.pList.a[i].pExpr;
                            break;
                        }
                    }
                }

                p = pNext;
            }
        }
        else
        {
            break;
        }
    }

    if ((sqlite3CheckCollSeq(pParse, pColl)) != 0)
    {
        pColl = null;
    }

    return pColl;
}</function>
  <function>public static int sqlite3ExprCollSeqMatch(Parse pParse, Expr pE1, Expr pE2)
{
    CollSeq pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
    CollSeq pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
    return ((sqlite3StrICmp(pColl1.zName, pColl2.zName)) == (0) ? 1 : 0);
}</function>
  <function>public static ulong sqlite3ExprColUsed(Expr pExpr)
{
    int n = 0;
    Table pExTab;
    n = (int)(pExpr.iColumn);
    pExTab = pExpr.y.pTab;
    if (((pExTab.tabFlags &amp; 0x00000060) != 0) &amp;&amp; ((pExTab.aCol[n].colFlags &amp; 0x0060) != 0))
    {
        return (ulong)((pExTab.nCol) &gt;= ((int)(sizeof(ulong) * 8)) ? ((ulong)(-1)) : (((ulong)(1)) &lt;&lt; (pExTab.nCol)) - 1);
    }
    else
    {
        if ((n) &gt;= ((int)(sizeof(ulong) * 8)))
            n = (int)(((int)(sizeof(ulong) * 8)) - 1);
        return (ulong)(((ulong)(1)) &lt;&lt; n);
    }
}</function>
  <function>public static int sqlite3ExprCompare(Parse pParse, Expr pA, Expr pB, int iTab)
{
    uint combinedFlags = 0;
    if (((pA) == (null)) || ((pB) == (null)))
    {
        return (int)((pB) == (pA) ? 0 : 2);
    }

    if ((((pParse) != null) &amp;&amp; ((pA.op) == (156))) &amp;&amp; ((exprCompareVariable(pParse, pA, pB)) != 0))
    {
        return (int)(0);
    }

    combinedFlags = (uint)(pA.flags | pB.flags);
    if ((combinedFlags &amp; 0x000400) != 0)
    {
        if (((pA.flags &amp; pB.flags &amp; 0x000400) != 0) &amp;&amp; ((pA.u.iValue) == (pB.u.iValue)))
        {
            return (int)(0);
        }

        return (int)(2);
    }

    if ((pA.op != pB.op) || ((pA.op) == (71)))
    {
        if (((pA.op) == (113)) &amp;&amp; ((sqlite3ExprCompare(pParse, pA.pLeft, pB, (int)(iTab))) &lt; (2)))
        {
            return (int)(1);
        }

        if (((pB.op) == (113)) &amp;&amp; ((sqlite3ExprCompare(pParse, pA, pB.pLeft, (int)(iTab))) &lt; (2)))
        {
            return (int)(1);
        }

        return (int)(2);
    }

    if ((pA.u.zToken) != null)
    {
        if (((pA.op) == (172)) || ((pA.op) == (168)))
        {
            if (sqlite3StrICmp(pA.u.zToken, pB.u.zToken) != 0)
                return (int)(2);
            if ((((pA).flags &amp; (0x1000000)) != 0) != (((pB).flags &amp; (0x1000000)) != 0))
            {
                return (int)(2);
            }

            if ((((pA).flags &amp; (0x1000000)) != 0))
            {
                if (sqlite3WindowCompare(pParse, pA.y.pWin, pB.y.pWin, (int)(1)) != 0)
                {
                    return (int)(2);
                }
            }
        }
        else if ((pA.op) == (121))
        {
            return (int)(0);
        }
        else if ((pA.op) == (113))
        {
            if (sqlite3_stricmp(pA.u.zToken, pB.u.zToken) != 0)
                return (int)(2);
        }
        else if ((((pB.u.zToken != null) &amp;&amp; (pA.op != 167)) &amp;&amp; (pA.op != 169)) &amp;&amp; (CRuntime.strcmp(pA.u.zToken, pB.u.zToken) != 0))
        {
            return (int)(2);
        }
    }

    if ((pA.flags &amp; (0x000002 | 0x000200)) != (pB.flags &amp; (0x000002 | 0x000200)))
        return (int)(2);
    if (((combinedFlags &amp; 0x004000) == (0)))
    {
        if ((combinedFlags &amp; 0x000800) != 0)
            return (int)(2);
        if (((combinedFlags &amp; 0x000008) == (0)) &amp;&amp; ((sqlite3ExprCompare(pParse, pA.pLeft, pB.pLeft, (int)(iTab))) != 0))
            return (int)(2);
        if ((sqlite3ExprCompare(pParse, pA.pRight, pB.pRight, (int)(iTab))) != 0)
            return (int)(2);
        if ((sqlite3ExprListCompare(pA.x.pList, pB.x.pList, (int)(iTab))) != 0)
            return (int)(2);
        if (((pA.op != 117) &amp;&amp; (pA.op != 170)) &amp;&amp; ((combinedFlags &amp; 0x002000) == (0)))
        {
            if (pA.iColumn != pB.iColumn)
                return (int)(2);
            if ((pA.op2 != pB.op2) &amp;&amp; ((pA.op) == (175)))
                return (int)(2);
            if (((pA.op != 49) &amp;&amp; (pA.iTable != pB.iTable)) &amp;&amp; (pA.iTable != iTab))
            {
                return (int)(2);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static CollSeq sqlite3ExprCompareCollSeq(Parse pParse, Expr p)
{
    if ((((p).flags &amp; (0x000200)) != 0))
    {
        return sqlite3BinaryCompareCollSeq(pParse, p.pRight, p.pLeft);
    }
    else
    {
        return sqlite3BinaryCompareCollSeq(pParse, p.pLeft, p.pRight);
    }
}</function>
  <function>public static int sqlite3ExprCompareSkip(Expr pA, Expr pB, int iTab)
{
    return (int)(sqlite3ExprCompare(null, sqlite3ExprSkipCollateAndLikely(pA), sqlite3ExprSkipCollateAndLikely(pB), (int)(iTab)));
}</function>
  <function>public static int sqlite3ExprCoveredByIndex(Expr pExpr, int iCur, Index pIdx)
{
    Walker w = new Walker();
    IdxCover xcov = new IdxCover();
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    xcov.iCur = (int)(iCur);
    xcov.pIdx = pIdx;
    w.xExprCallback = exprIdxCover;
    w.u.pIdxCover = xcov;
    sqlite3WalkExpr(w, pExpr);
    return (int)(!w.eCode);
}</function>
  <function>public static void sqlite3ExprDeferredDelete(Parse pParse, Expr pExpr)
{
    pParse.pConstExpr = sqlite3ExprListAppend(pParse, pParse.pConstExpr, pExpr);
}</function>
  <function>public static void sqlite3ExprDelete(sqlite3 db, Expr p)
{
    if ((p) != null)
        sqlite3ExprDeleteNN(db, p);
}</function>
  <function>public static void sqlite3ExprDeleteNN(sqlite3 db, Expr p)
{
    if (!(((p).flags &amp; (0x004000 | 0x800000)) != 0))
    {
        if (((p.pLeft) != null) &amp;&amp; (p.op != 178))
            sqlite3ExprDeleteNN(db, p.pLeft);
        if ((p.pRight) != null)
        {
            sqlite3ExprDeleteNN(db, p.pRight);
        }
        else if ((((p).flags &amp; 0x000800) != 0))
        {
            sqlite3SelectDelete(db, p.x.pSelect);
        }
        else
        {
            sqlite3ExprListDelete(db, p.x.pList);
            if ((((p).flags &amp; (0x1000000)) != 0))
            {
                sqlite3WindowDelete(db, p.y.pWin);
            }
        }
    }

    if ((((p).flags &amp; (0x010000)) != 0))
    {
        sqlite3DbFree(db, p.u.zToken);
    }

    if (!(((p).flags &amp; (0x8000000)) != 0))
    {
        sqlite3DbFreeNN(db, p);
    }
}</function>
  <function>public static Expr sqlite3ExprDup(sqlite3 db, Expr p, int flags)
{
    return p ? exprDup(db, p, (int)(flags), null) : null;
}</function>
  <function>public static Expr sqlite3ExprForVectorField(Parse pParse, Expr pVector, int iField, int nField)
{
    Expr pRet;
    if ((pVector.op) == (138))
    {
        pRet = sqlite3PExpr(pParse, (int)(178), null, null);
        if ((pRet) != null)
        {
            pRet.iTable = (int)(nField);
            pRet.iColumn = (short)(iField);
            pRet.pLeft = pVector;
        }
    }
    else
    {
        if ((pVector.op) == (177))
        {
            Expr ppVector;
            ppVector = pVector.x.pList.a[iField].pExpr;
            pVector = ppVector;
            if (((pParse.eParseMode) &gt;= (2)))
            {
                ppVector = null;
                return pVector;
            }
        }

        pRet = sqlite3ExprDup(pParse.db, pVector, (int)(0));
    }

    return pRet;
}</function>
  <function>public static Expr sqlite3ExprFunction(Parse pParse, ExprList pList, Token* pToken, int eDistinct)
{
    Expr pNew;
    sqlite3 db = pParse.db;
    pNew = sqlite3ExprAlloc(db, (int)(172), pToken, (int)(1));
    if ((pNew) == (null))
    {
        sqlite3ExprListDelete(db, pList);
        return null;
    }

    pNew.w.iOfst = ((int)(pToken-&gt;z - pParse.zTail));
    if ((((pList) != null) &amp;&amp; ((pList.nExpr) &gt; (pParse.db.aLimit[6]))) &amp;&amp; (pParse.nested == 0))
    {
        sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
    }

    pNew.x.pList = pList;
    (pNew).flags |= (uint)(0x000004);
    sqlite3ExprSetHeightAndFlags(pParse, pNew);
    if ((eDistinct) == (0x0000001))
        (pNew).flags |= (uint)(0x000002);
    return pNew;
}</function>
  <function>public static void sqlite3ExprFunctionUsable(Parse pParse, Expr pExpr, FuncDef pDef)
{
    if ((((pExpr).flags &amp; (0x40000000)) != 0))
    {
        if (((pDef.funcFlags &amp; 0x00080000) != 0) || ((pParse.db.flags &amp; 0x00000080) == (0)))
        {
            sqlite3ErrorMsg(pParse, "unsafe use of %#T()", pExpr);
        }
    }
}</function>
  <function>public static int sqlite3ExprIdToTrueFalse(Expr pExpr)
{
    uint v = 0;
    if ((!(((pExpr).flags &amp; (0x4000000 | 0x000400)) != 0)) &amp;&amp; ((v = (uint)(sqlite3IsTrueOrFalse(pExpr.u.zToken))) != 0))
    {
        pExpr.op = (byte)(170);
        (pExpr).flags |= (uint)(v);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3ExprIfFalse(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
{
    Vdbe v = pParse.pVdbe;
    int op = (int)(0);
    int regFree1 = (int)(0);
    int regFree2 = (int)(0);
    int r1 = 0; int  r2  =  0 ; 
    if (((v) == (null)))
        return;
    if ((pExpr) == (null))
        return;
    op = (int)(((pExpr.op + (50 &amp; 1)) ^ 1) - (50 &amp; 1));
    switch (pExpr.op)
    {
        case 44:
        case 43:
        {
            Expr pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
            if (pAlt != pExpr)
            {
                sqlite3ExprIfFalse(pParse, pAlt, (int)(dest), (int)(jumpIfNull));
            }
            else if ((pExpr.op) == (44))
            {
                sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
                sqlite3ExprIfFalse(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
            }
            else
            {
                int d2 = (int)(sqlite3VdbeMakeLabel(pParse));
                sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(d2), (int)(jumpIfNull ^ 0x10));
                sqlite3ExprIfFalse(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
                sqlite3VdbeResolveLabel(v, (int)(d2));
            }

            break;
        }

        case 19:
        {
            sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
            break;
        }

        case 175:
        {
            int isNot = 0;
            int isTrue = 0;
            isNot = (int)((pExpr.op2) == (171) ? 1 : 0);
            isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
            if (isTrue ^ isNot)
            {
                sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0 : 0x10));
            }
            else
            {
                sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0 : 0x10));
            }

            break;
        }

        case 45:
        case 171:
            ;
            op = (int)(((pExpr.op) == (45)) ? 52 : 53);
            jumpIfNull = (int)(0x80);
        case 56:
        case 55:
        case 54:
        case 57:
        case 52:
        case 53:
        {
            if ((sqlite3ExprIsVector(pExpr.pLeft)) != 0)
                goto default_expr;
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &amp;regFree2));
            codeCompare(pParse, pExpr.pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(dest), (int)(jumpIfNull), (int)(((pExpr).flags &amp; (0x000200)) != 0));
            break;
        }

        case 50:
        case 51:
        {
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(dest));
            break;
        }

        case 48:
        {
            exprCodeBetween(pParse, pExpr, (int)(dest), sqlite3ExprIfFalse, (int)(jumpIfNull));
            break;
        }

        case 49:
        {
            if ((jumpIfNull) != 0)
            {
                sqlite3ExprCodeIN(pParse, pExpr, (int)(dest), (int)(dest));
            }
            else
            {
                int destIfNull = (int)(sqlite3VdbeMakeLabel(pParse));
                sqlite3ExprCodeIN(pParse, pExpr, (int)(dest), (int)(destIfNull));
                sqlite3VdbeResolveLabel(v, (int)(destIfNull));
            }

            break;
        }

        default:
        {
            default_expr:
                ;
            if ((((pExpr).flags &amp; (0x000001 | 0x20000000)) == (0x20000000)))
            {
                sqlite3VdbeGoto(v, (int)(dest));
            }
            else if ((((pExpr).flags &amp; (0x000001 | 0x10000000)) == (0x10000000)))
            {
            }
            else
            {
                r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr, &amp;regFree1));
                sqlite3VdbeAddOp3(v, (int)(20), (int)(r1), (int)(dest), (int)(jumpIfNull != 0));
            }

            break;
        }
    }

    sqlite3ReleaseTempReg(pParse, (int)(regFree1));
    sqlite3ReleaseTempReg(pParse, (int)(regFree2));
}</function>
  <function>public static void sqlite3ExprIfFalseDup(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
{
    sqlite3 db = pParse.db;
    Expr pCopy = sqlite3ExprDup(db, pExpr, (int)(0));
    if ((db.mallocFailed) == (0))
    {
        sqlite3ExprIfFalse(pParse, pCopy, (int)(dest), (int)(jumpIfNull));
    }

    sqlite3ExprDelete(db, pCopy);
}</function>
  <function>public static void sqlite3ExprIfTrue(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
{
    Vdbe v = pParse.pVdbe;
    int op = (int)(0);
    int regFree1 = (int)(0);
    int regFree2 = (int)(0);
    int r1 = 0; int  r2  =  0 ; 
    if (((v) == (null)))
        return;
    if (((pExpr) == (null)))
        return;
    op = (int)(pExpr.op);
    switch (op)
    {
        case 44:
        case 43:
        {
            Expr pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
            if (pAlt != pExpr)
            {
                sqlite3ExprIfTrue(pParse, pAlt, (int)(dest), (int)(jumpIfNull));
            }
            else if ((op) == (44))
            {
                int d2 = (int)(sqlite3VdbeMakeLabel(pParse));
                sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(d2), (int)(jumpIfNull ^ 0x10));
                sqlite3ExprIfTrue(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
                sqlite3VdbeResolveLabel(v, (int)(d2));
            }
            else
            {
                sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
                sqlite3ExprIfTrue(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
            }

            break;
        }

        case 19:
        {
            sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
            break;
        }

        case 175:
        {
            int isNot = 0;
            int isTrue = 0;
            isNot = (int)((pExpr.op2) == (171) ? 1 : 0);
            isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
            if (isTrue ^ isNot)
            {
                sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0x10 : 0));
            }
            else
            {
                sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0x10 : 0));
            }

            break;
        }

        case 45:
        case 171:
            ;
            op = (int)(((op) == (45)) ? 53 : 52);
            jumpIfNull = (int)(0x80);
        case 56:
        case 55:
        case 54:
        case 57:
        case 52:
        case 53:
        {
            if ((sqlite3ExprIsVector(pExpr.pLeft)) != 0)
                goto default_expr;
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &amp;regFree2));
            codeCompare(pParse, pExpr.pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(dest), (int)(jumpIfNull), (int)(((pExpr).flags &amp; (0x000200)) != 0));
            break;
        }

        case 50:
        case 51:
        {
            r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &amp;regFree1));
            sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(dest));
            break;
        }

        case 48:
        {
            exprCodeBetween(pParse, pExpr, (int)(dest), sqlite3ExprIfTrue, (int)(jumpIfNull));
            break;
        }

        case 49:
        {
            int destIfFalse = (int)(sqlite3VdbeMakeLabel(pParse));
            int destIfNull = (int)((jumpIfNull) != 0 ? dest : destIfFalse);
            sqlite3ExprCodeIN(pParse, pExpr, (int)(destIfFalse), (int)(destIfNull));
            sqlite3VdbeGoto(v, (int)(dest));
            sqlite3VdbeResolveLabel(v, (int)(destIfFalse));
            break;
        }

        default:
        {
            default_expr:
                ;
            if ((((pExpr).flags &amp; (0x000001 | 0x10000000)) == (0x10000000)))
            {
                sqlite3VdbeGoto(v, (int)(dest));
            }
            else if ((((pExpr).flags &amp; (0x000001 | 0x20000000)) == (0x20000000)))
            {
            }
            else
            {
                r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr, &amp;regFree1));
                sqlite3VdbeAddOp3(v, (int)(18), (int)(r1), (int)(dest), (int)(jumpIfNull != 0));
            }

            break;
        }
    }

    sqlite3ReleaseTempReg(pParse, (int)(regFree1));
    sqlite3ReleaseTempReg(pParse, (int)(regFree2));
}</function>
  <function>public static int sqlite3ExprImpliesExpr(Parse pParse, Expr pE1, Expr pE2, int iTab)
{
    if ((sqlite3ExprCompare(pParse, pE1, pE2, (int)(iTab))) == (0))
    {
        return (int)(1);
    }

    if (((pE2.op) == (43)) &amp;&amp; (((sqlite3ExprImpliesExpr(pParse, pE1, pE2.pLeft, (int)(iTab))) != 0) || ((sqlite3ExprImpliesExpr(pParse, pE1, pE2.pRight, (int)(iTab))) != 0)))
    {
        return (int)(1);
    }

    if (((pE2.op) == (51)) &amp;&amp; ((exprImpliesNotNull(pParse, pE1, pE2.pLeft, (int)(iTab), (int)(0))) != 0))
    {
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3ExprImpliesNonNullRow(Expr p, int iTab)
{
    Walker w = new Walker();
    p = sqlite3ExprSkipCollateAndLikely(p);
    if ((p) == (null))
        return (int)(0);
    if ((p.op) == (51))
    {
        p = p.pLeft;
    }
    else
    {
        while ((p.op) == (44))
        {
            if ((sqlite3ExprImpliesNonNullRow(p.pLeft, (int)(iTab))) != 0)
                return (int)(1);
            p = p.pRight;
        }
    }

    w.xExprCallback = impliesNotNullRow;
    w.xSelectCallback = null;
    w.xSelectCallback2 = null;
    w.eCode = (ushort)(0);
    w.u.iCur = (int)(iTab);
    sqlite3WalkExpr(w, p);
    return (int)(w.eCode);
}</function>
  <function>public static int sqlite3ExprIsConstant(Expr p)
{
    return (int)(exprIsConst(p, (int)(1), (int)(0)));
}</function>
  <function>public static int sqlite3ExprIsConstantNotJoin(Expr p)
{
    return (int)(exprIsConst(p, (int)(2), (int)(0)));
}</function>
  <function>public static int sqlite3ExprIsConstantOrFunction(Expr p, byte isInit)
{
    return (int)(exprIsConst(p, (int)(4 + isInit), (int)(0)));
}</function>
  <function>public static int sqlite3ExprIsConstantOrGroupBy(Parse pParse, Expr p, ExprList pGroupBy)
{
    Walker w = new Walker();
    w.eCode = (ushort)(1);
    w.xExprCallback = exprNodeIsConstantOrGroupBy;
    w.xSelectCallback = null;
    w.u.pGroupBy = pGroupBy;
    w.pParse = pParse;
    sqlite3WalkExpr(w, p);
    return (int)(w.eCode);
}</function>
  <function>public static int sqlite3ExprIsInteger(Expr p, int* pValue)
{
    int rc = (int)(0);
    if (((p) == (null)))
        return (int)(0);
    if ((p.flags &amp; 0x000400) != 0)
    {
        *pValue = (int)(p.u.iValue);
        return (int)(1);
    }

    switch (p.op)
    {
        case 174:
        {
            rc = (int)(sqlite3ExprIsInteger(p.pLeft, pValue));
            break;
        }

        case 173:
        {
            int v = (int)(0);
            if ((sqlite3ExprIsInteger(p.pLeft, &amp;v)) != 0)
            {
                *pValue = (int)(-v);
                rc = (int)(1);
            }

            break;
        }

        default:
            break;
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3ExprIsTableConstant(Expr p, int iCur)
{
    return (int)(exprIsConst(p, (int)(3), (int)(iCur)));
}</function>
  <function>public static int sqlite3ExprIsVector(Expr pExpr)
{
    return ((sqlite3ExprVectorSize(pExpr)) &gt; (1) ? 1 : 0);
}</function>
  <function>public static ExprList sqlite3ExprListAppend(Parse pParse, ExprList pList, Expr pExpr)
{
    ExprList_item* pItem;
    if ((pList) == (null))
    {
        return sqlite3ExprListAppendNew(pParse.db, pExpr);
    }

    if ((pList.nAlloc) &lt; (pList.nExpr + 1))
    {
        return sqlite3ExprListAppendGrow(pParse.db, pList, pExpr);
    }

    pItem = &amp;pList.a[pList.nExpr++];
    *pItem = (ExprList_item)(zeroItem);
    pItem-&gt;pExpr = pExpr;
    return pList;
}</function>
  <function>public static ExprList sqlite3ExprListAppendGrow(sqlite3 db, ExprList pList, Expr pExpr)
{
    ExprList_item* pItem;
    ExprList pNew;
    pList.nAlloc *= (int)(2);
    pNew = sqlite3DbRealloc(db, pList, (ulong)(sizeof(ExprList) + (pList.nAlloc - 1) * sizeof(ExprList_item)));
    if ((pNew) == (null))
    {
        sqlite3ExprListDelete(db, pList);
        sqlite3ExprDelete(db, pExpr);
        return null;
    }
    else
    {
        pList = pNew;
    }

    pItem = &amp;pList.a[pList.nExpr++];
    *pItem = (ExprList_item)(zeroItem);
    pItem-&gt;pExpr = pExpr;
    return pList;
}</function>
  <function>public static ExprList sqlite3ExprListAppendNew(sqlite3 db, Expr pExpr)
{
    ExprList_item* pItem;
    ExprList pList;
    pList = sqlite3DbMallocRawNN(db, (ulong)(sizeof(ExprList) + sizeof(ExprList_item) * 4));
    if ((pList) == (null))
    {
        sqlite3ExprDelete(db, pExpr);
        return null;
    }

    pList.nAlloc = (int)(4);
    pList.nExpr = (int)(1);
    pItem = &amp;pList.a[0];
    *pItem = (ExprList_item)(zeroItem);
    pItem-&gt;pExpr = pExpr;
    return pList;
}</function>
  <function>public static ExprList sqlite3ExprListAppendVector(Parse pParse, ExprList pList, IdList* pColumns, Expr pExpr)
{
    sqlite3 db = pParse.db;
    int n = 0;
    int i = 0;
    int iFirst = (int)(pList ? pList.nExpr : 0);
    if (((pColumns) == (null)))
        goto vector_append_error;
    if ((pExpr) == (null))
        goto vector_append_error;
    if ((pExpr.op != 138) &amp;&amp; (pColumns-&gt;nId != (n = (int)(sqlite3ExprVectorSize(pExpr)))))
    {
        sqlite3ErrorMsg(pParse, "%d columns assigned %d values", (int)(pColumns-&gt;nId), (int)(n));
        goto vector_append_error;
    }

    for (i = (int)(0); (i) &lt; (pColumns-&gt;nId); i++)
    {
        Expr pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, (int)(i), (int)(pColumns-&gt;nId));
        if ((pSubExpr) == (null))
            continue;
        pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
        if ((pList) != null)
        {
            pList.a[pList.nExpr - 1].zEName = pColumns-&gt;a[i].zName;
            pColumns-&gt;a[i].zName = null;
        }
    }

    if (((db.mallocFailed == 0) &amp;&amp; ((pExpr.op) == (138))) &amp;&amp; (pList != null))
    {
        Expr pFirst = pList.a[iFirst].pExpr;
        pFirst.pRight = pExpr;
        pExpr = null;
        pFirst.iTable = (int)(pColumns-&gt;nId);
    }

    vector_append_error:
        ; sqlite3ExprUnmapAndDelete ( pParse ,  pExpr ) ; 
    sqlite3IdListDelete(db, pColumns);
    return pList;
}</function>
  <function>public static void sqlite3ExprListCheckLength(Parse pParse, ExprList pEList, sbyte* zObject)
{
    int mx = (int)(pParse.db.aLimit[2]);
    if (((pEList) != null) &amp;&amp; ((pEList.nExpr) &gt; (mx)))
    {
        sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
    }
}</function>
  <function>public static int sqlite3ExprListCompare(ExprList pA, ExprList pB, int iTab)
{
    int i = 0;
    if (((pA) == (null)) &amp;&amp; ((pB) == (null)))
        return (int)(0);
    if (((pA) == (null)) || ((pB) == (null)))
        return (int)(1);
    if (pA.nExpr != pB.nExpr)
        return (int)(1);
    for (i = (int)(0); (i) &lt; (pA.nExpr); i++)
    {
        int res = 0;
        Expr pExprA = pA.a[i].pExpr;
        Expr pExprB = pB.a[i].pExpr;
        if (pA.a[i].sortFlags != pB.a[i].sortFlags)
            return (int)(1);
        if ((res = (int)(sqlite3ExprCompare(null, pExprA, pExprB, (int)(iTab)))))
            return (int)(res);
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3ExprListDelete(sqlite3 db, ExprList pList)
{
    if ((pList) != null)
        exprListDeleteNN(db, pList);
}</function>
  <function>public static ExprList sqlite3ExprListDup(sqlite3 db, ExprList p, int flags)
{
    ExprList pNew;
    ExprList_item* pItem;
    ExprList_item* pOldItem;
    int i = 0;
    Expr pPriorSelectColOld = null;
    Expr pPriorSelectColNew = null;
    if ((p) == (null))
        return null;
    pNew = sqlite3DbMallocRawNN(db, (ulong)(sqlite3DbMallocSize(db, p)));
    if ((pNew) == (null))
        return null;
    pNew.nExpr = (int)(p.nExpr);
    pNew.nAlloc = (int)(p.nAlloc);
    pItem = pNew.a;
    pOldItem = p.a;
    for (i = (int)(0); (i) &lt; (p.nExpr); i++, pItem++, pOldItem++)
    {
        Expr pOldExpr = pOldItem-&gt;pExpr;
        Expr pNewExpr;
        pItem-&gt;pExpr = sqlite3ExprDup(db, pOldExpr, (int)(flags));
        if ((((pOldExpr) != null) &amp;&amp; ((pOldExpr.op) == (178))) &amp;&amp; ((pNewExpr = pItem-&gt;pExpr) != null))
        {
            if ((pNewExpr.pRight) != null)
            {
                pPriorSelectColOld = pOldExpr.pRight;
                pPriorSelectColNew = pNewExpr.pRight;
                pNewExpr.pLeft = pNewExpr.pRight;
            }
            else
            {
                if (pOldExpr.pLeft != pPriorSelectColOld)
                {
                    pPriorSelectColOld = pOldExpr.pLeft;
                    pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, (int)(flags));
                    pNewExpr.pRight = pPriorSelectColNew;
                }

                pNewExpr.pLeft = pPriorSelectColNew;
            }
        }

        pItem-&gt;zEName = sqlite3DbStrDup(db, pOldItem-&gt;zEName);
        pItem-&gt;sortFlags = (byte)(pOldItem-&gt;sortFlags);
        pItem-&gt;eEName = (uint)(pOldItem-&gt;eEName);
        pItem-&gt;done = (uint)(0);
        pItem-&gt;bNulls = (uint)(pOldItem-&gt;bNulls);
        pItem-&gt;bSorterRef = (uint)(pOldItem-&gt;bSorterRef);
        pItem-&gt;u = (union ExprList_item::(unnamed at sqlite3.c : 18260 : 5) ) ( pOldItem -&gt; u ) ;  }

    return pNew;
}</function>
  <function>public static uint sqlite3ExprListFlags(ExprList pList)
{
    int i = 0;
    uint m = (uint)(0);
    for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
    {
        Expr pExpr = pList.a[i].pExpr;
        m |= (uint)(pExpr.flags);
    }

    return (uint)(m);
}</function>
  <function>public static void sqlite3ExprListSetName(Parse pParse, ExprList pList, Token* pName, int dequote)
{
    if ((pList) != null)
    {
        ExprList_item* pItem;
        pItem = &amp;pList.a[pList.nExpr - 1];
        pItem-&gt;zEName = sqlite3DbStrNDup(pParse.db, pName-&gt;z, (ulong)(pName-&gt;n));
        if ((dequote) != 0)
        {
            sqlite3Dequote(pItem-&gt;zEName);
            if (((pParse.eParseMode) &gt;= (2)))
            {
                sqlite3RenameTokenMap(pParse, (void*)(pItem-&gt;zEName), pName);
            }
        }
    }
}</function>
  <function>public static void sqlite3ExprListSetSortOrder(ExprList p, int iSortOrder, int eNulls)
{
    ExprList_item* pItem;
    if ((p) == (null))
        return;
    pItem = &amp;p.a[p.nExpr - 1];
    if ((iSortOrder) == (-1))
    {
        iSortOrder = (int)(0);
    }

    pItem-&gt;sortFlags = ((byte)(iSortOrder));
    if (eNulls != -1)
    {
        pItem-&gt;bNulls = (uint)(1);
        if (iSortOrder != eNulls)
        {
            pItem-&gt;sortFlags |= (byte)(0x02);
        }
    }
}</function>
  <function>public static void sqlite3ExprListSetSpan(Parse pParse, ExprList pList, sbyte* zStart, sbyte* zEnd)
{
    sqlite3 db = pParse.db;
    if ((pList) != null)
    {
        ExprList_item* pItem = &amp;pList.a[pList.nExpr - 1];
        if ((pItem-&gt;zEName) == (null))
        {
            pItem-&gt;zEName = sqlite3DbSpanDup(db, zStart, zEnd);
            pItem-&gt;eEName = (uint)(1);
        }
    }
}</function>
  <function>public static Select sqlite3ExprListToValues(Parse pParse, int nElem, ExprList pEList)
{
    int ii = 0;
    Select pRet = null;
    for (ii = (int)(0); (ii) &lt; (pEList.nExpr); ii++)
    {
        Select pSel;
        Expr pExpr = pEList.a[ii].pExpr;
        int nExprElem = 0;
        if ((pExpr.op) == (177))
        {
            nExprElem = (int)(pExpr.x.pList.nExpr);
        }
        else
        {
            nExprElem = (int)(1);
        }

        if (nExprElem != nElem)
        {
            sqlite3ErrorMsg(pParse, "IN(...) element has %d term%s - expected %d", (int)(nExprElem), (nExprElem) &gt; (1) ? "s" : "", (int)(nElem));
            break;
        }

        pSel = sqlite3SelectNew(pParse, pExpr.x.pList, null, null, null, null, null, (uint)(0x0000200), null);
        pExpr.x.pList = null;
        if ((pSel) != null)
        {
            if ((pRet) != null)
            {
                pSel.op = (byte)(135);
                pSel.pPrior = pRet;
            }

            pRet = pSel;
        }
    }

    if (((pRet) != null) &amp;&amp; ((pRet.pPrior) != null))
    {
        pRet.selFlags |= (uint)(0x0000400);
    }

    sqlite3ExprListDelete(pParse.db, pEList);
    return pRet;
}</function>
  <function>public static int sqlite3ExprNeedsNoAffinityChange(Expr p, sbyte aff)
{
    byte op = 0;
    int unaryMinus = (int)(0);
    if ((aff) == (0x41))
        return (int)(1);
    while (((p.op) == (174)) || ((p.op) == (173)))
    {
        if ((p.op) == (173))
            unaryMinus = (int)(1);
        p = p.pLeft;
    }

    op = (byte)(p.op);
    if ((op) == (176))
        op = (byte)(p.op2);
    switch (op)
    {
        case 155:
        {
            return ((aff) &gt;= (0x43) ? 1 : 0);
        }

        case 153:
        {
            return ((aff) &gt;= (0x43) ? 1 : 0);
        }

        case 117:
        {
            return ((unaryMinus == 0) &amp;&amp; ((aff) == (0x42)) ? 1 : 0);
        }

        case 154:
        {
            return (int)(!unaryMinus);
        }

        case 167:
        {
            return (((aff) &gt;= (0x43)) &amp;&amp; ((p.iColumn) &lt; (0)) ? 1 : 0);
        }

        default:
        {
            return (int)(0);
        }
    }
}</function>
  <function>public static CollSeq sqlite3ExprNNCollSeq(Parse pParse, Expr pExpr)
{
    CollSeq p = sqlite3ExprCollSeq(pParse, pExpr);
    if ((p) == (null))
        p = pParse.db.pDfltColl;
    return p;
}</function>
  <function>public static int sqlite3ExprReferencesUpdatedColumn(Expr pExpr, int* aiChng, int chngRowid)
{
    Walker w = new Walker();
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    w.eCode = (ushort)(0);
    w.xExprCallback = checkConstraintExprNode;
    w.u.aiCol = aiChng;
    sqlite3WalkExpr(w, pExpr);
    if (chngRowid == 0)
    {
        w.eCode &amp;= (ushort)(~0x02);
    }

    return (int)(w.eCode != 0);
}</function>
  <function>public static void sqlite3ExprSetHeightAndFlags(Parse pParse, Expr p)
{
    if ((pParse.nErr) != 0)
        return;
    exprSetHeight(p);
    sqlite3ExprCheckHeight(pParse, (int)(p.nHeight));
}</function>
  <function>public static Expr sqlite3ExprSimplifiedAndOr(Expr pExpr)
{
    if (((pExpr.op) == (44)) || ((pExpr.op) == (43)))
    {
        Expr pRight = sqlite3ExprSimplifiedAndOr(pExpr.pRight);
        Expr pLeft = sqlite3ExprSimplifiedAndOr(pExpr.pLeft);
        if ((((pLeft).flags &amp; (0x000001 | 0x10000000)) == (0x10000000)) || (((pRight).flags &amp; (0x000001 | 0x20000000)) == (0x20000000)))
        {
            pExpr = (pExpr.op) == (44) ? pRight : pLeft;
        }
        else if ((((pRight).flags &amp; (0x000001 | 0x10000000)) == (0x10000000)) || (((pLeft).flags &amp; (0x000001 | 0x20000000)) == (0x20000000)))
        {
            pExpr = (pExpr.op) == (44) ? pLeft : pRight;
        }
    }

    return pExpr;
}</function>
  <function>public static Expr sqlite3ExprSkipCollate(Expr pExpr)
{
    while (((pExpr) != null) &amp;&amp; (((pExpr).flags &amp; (0x001000)) != 0))
    {
        pExpr = pExpr.pLeft;
    }

    return pExpr;
}</function>
  <function>public static Expr sqlite3ExprSkipCollateAndLikely(Expr pExpr)
{
    while (((pExpr) != null) &amp;&amp; (((pExpr).flags &amp; (0x001000 | 0x040000)) != 0))
    {
        if ((((pExpr).flags &amp; (0x040000)) != 0))
        {
            pExpr = pExpr.x.pList.a[0].pExpr;
        }
        else
        {
            pExpr = pExpr.pLeft;
        }
    }

    return pExpr;
}</function>
  <function>public static int sqlite3ExprTruthValue(Expr pExpr)
{
    pExpr = sqlite3ExprSkipCollate(pExpr);
    return ((pExpr.u.zToken[4]) == (0) ? 1 : 0);
}</function>
  <function>public static void sqlite3ExprUnmapAndDelete(Parse pParse, Expr p)
{
    if ((p) != null)
    {
        if (((pParse.eParseMode) &gt;= (2)))
        {
            sqlite3RenameExprUnmap(pParse, p);
        }

        sqlite3ExprDeleteNN(pParse.db, p);
    }
}</function>
  <function>public static int sqlite3ExprVectorSize(Expr pExpr)
{
    byte op = (byte)(pExpr.op);
    if ((op) == (176))
        op = (byte)(pExpr.op2);
    if ((op) == (177))
    {
        return (int)(pExpr.x.pList.nExpr);
    }
    else if ((op) == (138))
    {
        return (int)(pExpr.x.pSelect.pEList.nExpr);
    }
    else
    {
        return (int)(1);
    }
}</function>
  <function>public static int sqlite3ExprWalkNoop(Walker NotUsed, Expr NotUsed2)
{
    return (int)(0);
}</function>
  <function>public static int sqlite3FaultSim(int iTest)
{
    delegate20 xCallback = sqlite3Config.xTestCallback;
    return (int)(xCallback ? xCallback((int)(iTest)) : 0);
}</function>
  <function>public static CollSeq sqlite3FindCollSeq(sqlite3 db, byte enc, sbyte* zName, int create)
{
    CollSeq pColl;
    if ((zName) != null)
    {
        pColl = findCollSeqEntry(db, zName, (int)(create));
        if ((pColl) != null)
            pColl += enc - 1;
    }
    else
    {
        pColl = db.pDfltColl;
    }

    return pColl;
}</function>
  <function>public static int sqlite3FindDb(sqlite3 db, Token* pName)
{
    int i = 0;
    sbyte* zName;
    zName = sqlite3NameFromToken(db, pName);
    i = (int)(sqlite3FindDbName(db, zName));
    sqlite3DbFree(db, zName);
    return (int)(i);
}</function>
  <function>public static int sqlite3FindDbName(sqlite3 db, sbyte* zName)
{
    int i = (int)(-1);
    if ((zName) != null)
    {
        Db pDb;
        for (i = (int)(db.nDb - 1), pDb = db.aDb[i]; (i) &gt;= (0); i--, pDb--)
        {
            if ((0) == (sqlite3_stricmp(pDb.zDbSName, zName)))
                break;
            if (((i) == (0)) &amp;&amp; ((0) == (sqlite3_stricmp("main", zName))))
                break;
        }
    }

    return (int)(i);
}</function>
  <function>public static FuncDef sqlite3FindFunction(sqlite3 db, sbyte* zName, int nArg, byte enc, byte createFlag)
{
    FuncDef p;
    FuncDef pBest = null;
    int bestScore = (int)(0);
    int h = 0;
    int nName = 0;
    nName = (int)(sqlite3Strlen30(zName));
    p = (FuncDef)(sqlite3HashFind(&amp;db.aFunc, zName));
    while ((p) != null)
    {
        int score = (int)(matchQuality(p, (int)(nArg), (byte)(enc)));
        if ((score) &gt; (bestScore))
        {
            pBest = p;
            bestScore = (int)(score);
        }

        p = p.pNext;
    }

    if ((createFlag == 0) &amp;&amp; (((pBest) == (null)) || ((db.mDbFlags &amp; 0x0002) != 0)))
    {
        bestScore = (int)(0);
        h = (int)(((sqlite3UpperToLower[(byte)(zName[0])]) + (nName)) % 23);
        p = sqlite3FunctionSearch((int)(h), zName);
        while ((p) != null)
        {
            int score = (int)(matchQuality(p, (int)(nArg), (byte)(enc)));
            if ((score) &gt; (bestScore))
            {
                pBest = p;
                bestScore = (int)(score);
            }

            p = p.pNext;
        }
    }

    if ((((createFlag) != 0) &amp;&amp; ((bestScore) &lt; (6))) &amp;&amp; ((pBest = sqlite3DbMallocZero(db, (ulong)(sizeof(FuncDef) + nName + 1))) != null))
    {
        FuncDef pOther;
        byte* z;
        pBest.zName = (sbyte*)(pBest[1]);
        pBest.nArg = (sbyte)((ushort)(nArg));
        pBest.funcFlags = (uint)(enc);
        CRuntime.memcpy((sbyte*)(pBest[1]), zName, (ulong)(nName + 1));
        for (z = (byte*)(pBest.zName); *z; z++)
        {
            *z = (byte)(sqlite3UpperToLower[*z]);
        }

        pOther = (FuncDef)(sqlite3HashInsert(&amp;db.aFunc, pBest.zName, pBest));
        if ((pOther) == (pBest))
        {
            sqlite3DbFree(db, pBest);
            sqlite3OomFault(db);
            return null;
        }
        else
        {
            pBest.pNext = pOther;
        }
    }

    if (((pBest) != null) &amp;&amp; (((pBest.xSFunc) != null) || ((createFlag) != 0)))
    {
        return pBest;
    }

    return null;
}</function>
  <function>public static Index sqlite3FindIndex(sqlite3 db, sbyte* zName, sbyte* zDb)
{
    Index p = null;
    int i = 0;
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        int j = (int)(((i) &lt; (2)) ? i ^ 1 : i);
        Schema pSchema = db.aDb[j].pSchema;
        if (((zDb) != null) &amp;&amp; ((sqlite3DbIsNamed(db, (int)(j), zDb)) == (0)))
            continue;
        p = sqlite3HashFind(&amp;pSchema.idxHash, zName);
        if ((p) != null)
            break;
    }

    return p;
}</function>
  <function>public static int sqlite3FindInIndex(Parse pParse, Expr pX, uint inFlags, int* prRhsHasNull, int* aiMap, int* piTab)
{
    Select p;
    int eType = (int)(0);
    int iTab = (int)(pParse.nTab++);
    int mustBeUnique = 0;
    Vdbe v = sqlite3GetVdbe(pParse);
    mustBeUnique = (int)((inFlags &amp; 0x0004) != 0);
    if (((prRhsHasNull) != null) &amp;&amp; (((pX).flags &amp; 0x000800) != 0))
    {
        int i = 0;
        ExprList pEList = pX.x.pSelect.pEList;
        for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
        {
            if ((sqlite3ExprCanBeNull(pEList.a[i].pExpr)) != 0)
                break;
        }

        if ((i) == (pEList.nExpr))
        {
            prRhsHasNull = null;
        }
    }

    if (((pParse.nErr) == (0)) &amp;&amp; ((p = isCandidateForInOpt(pX)) != null))
    {
        sqlite3 db = pParse.db;
        Table pTab;
        int iDb = 0;
        ExprList pEList = p.pEList;
        int nExpr = (int)(pEList.nExpr);
        pTab = p.pSrc.a[0].pTab;
        iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
        sqlite3CodeVerifySchema(pParse, (int)(iDb));
        sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
        if (((nExpr) == (1)) &amp;&amp; ((pEList.a[0].pExpr.iColumn) &lt; (0)))
        {
            int iAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
            sqlite3OpenTable(pParse, (int)(iTab), (int)(iDb), pTab, (int)(101));
            eType = (int)(1);
            sqlite3VdbeExplain(pParse, (byte)(0), "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR", pTab.zName);
            sqlite3VdbeJumpHere(v, (int)(iAddr));
        }
        else
        {
            Index pIdx;
            int affinity_ok = (int)(1);
            int i = 0;
            for (i = (int)(0); ((i) &lt; (nExpr)) &amp;&amp; ((affinity_ok) != 0); i++)
            {
                Expr pLhs = sqlite3VectorFieldSubexpr(pX.pLeft, (int)(i));
                int iCol = (int)(pEList.a[i].pExpr.iColumn);
                sbyte idxaff = (sbyte)(sqlite3TableColumnAffinity(pTab, (int)(iCol)));
                sbyte cmpaff = (sbyte)(sqlite3CompareAffinity(pLhs, (sbyte)(idxaff)));
                switch (cmpaff)
                {
                    case 0x41:
                        break;
                    case 0x42:
                        ;
                        break;
                    default:
                        affinity_ok = (int)((idxaff) &gt;= (0x43) ? 1 : 0);
                }
            }

            if ((affinity_ok) != 0)
            {
                for (pIdx = pTab.pIndex; ((pIdx) != null) &amp;&amp; ((eType) == (0)); pIdx = pIdx.pNext)
                {
                    ulong colUsed = 0;
                    ulong mCol = 0;
                    if ((pIdx.nColumn) &lt; (nExpr))
                        continue;
                    if (pIdx.pPartIdxWhere != null)
                        continue;
                    if ((pIdx.nColumn) &gt;= (((int)(sizeof(ulong) * 8)) - 1))
                        continue;
                    if ((mustBeUnique) != 0)
                    {
                        if (((pIdx.nKeyCol) &gt; (nExpr)) || (((pIdx.nColumn) &gt; (nExpr)) &amp;&amp; (!((pIdx).onError != 0))))
                        {
                            continue;
                        }
                    }

                    colUsed = (ulong)(0);
                    for (i = (int)(0); (i) &lt; (nExpr); i++)
                    {
                        Expr pLhs = sqlite3VectorFieldSubexpr(pX.pLeft, (int)(i));
                        Expr pRhs = pEList.a[i].pExpr;
                        CollSeq pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
                        int j = 0;
                        for (j = (int)(0); (j) &lt; (nExpr); j++)
                        {
                            if (pIdx.aiColumn[j] != pRhs.iColumn)
                                continue;
                            if ((pReq != null) &amp;&amp; (sqlite3StrICmp(pReq.zName, pIdx.azColl[j]) != 0))
                            {
                                continue;
                            }

                            break;
                        }

                        if ((j) == (nExpr))
                            break;
                        mCol = (ulong)(((ulong)(1)) &lt;&lt; (j));
                        if ((mCol &amp; colUsed) != 0)
                            break;
                        colUsed |= (ulong)(mCol);
                        if ((aiMap) != null)
                            aiMap[i] = (int)(j);
                    }

                    if ((colUsed) == ((((ulong)(1)) &lt;&lt; (nExpr)) - 1))
                    {
                        int iAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
                        sqlite3VdbeExplain(pParse, (byte)(0), "USING INDEX %s FOR IN-OPERATOR", pIdx.zName);
                        sqlite3VdbeAddOp3(v, (int)(101), (int)(iTab), (int)(pIdx.tnum), (int)(iDb));
                        sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
                        eType = (int)(3 + pIdx.aSortOrder[0]);
                        if ((prRhsHasNull) != null)
                        {
                            *prRhsHasNull = (int)(++pParse.nMem);
                            if ((nExpr) == (1))
                            {
                                sqlite3SetHasNullFlag(v, (int)(iTab), (int)(*prRhsHasNull));
                            }
                        }

                        sqlite3VdbeJumpHere(v, (int)(iAddr));
                    }
                }
            }
        }
    }

    if (((((eType) == (0)) &amp;&amp; ((inFlags &amp; 0x0001) != 0)) &amp;&amp; (((pX).flags &amp; 0x000800) == (0))) &amp;&amp; ((sqlite3InRhsIsConstant(pX) == 0) || ((pX.x.pList.nExpr) &lt;= (2))))
    {
        eType = (int)(5);
    }

    if ((eType) == (0))
    {
        uint savedNQueryLoop = (uint)(pParse.nQueryLoop);
        int rMayHaveNull = (int)(0);
        eType = (int)(2);
        if ((inFlags &amp; 0x0004) != 0)
        {
            pParse.nQueryLoop = (uint)(0);
        }
        else if ((prRhsHasNull) != null)
        {
            *prRhsHasNull = (int)(rMayHaveNull = (int)(++pParse.nMem));
        }

        sqlite3CodeRhsOfIN(pParse, pX, (int)(iTab));
        if ((rMayHaveNull) != 0)
        {
            sqlite3SetHasNullFlag(v, (int)(iTab), (int)(rMayHaveNull));
        }

        pParse.nQueryLoop = (uint)(savedNQueryLoop);
    }

    if ((((aiMap) != null) &amp;&amp; (eType != 3)) &amp;&amp; (eType != 4))
    {
        int i = 0;
        int n = 0;
        n = (int)(sqlite3ExprVectorSize(pX.pLeft));
        for (i = (int)(0); (i) &lt; (n); i++)
        {
            aiMap[i] = (int)(i);
        }
    }

    *piTab = (int)(iTab);
    return (int)(eType);
}</function>
  <function>public static Table sqlite3FindTable(sqlite3 db, sbyte* zName, sbyte* zDatabase)
{
    Table p = null;
    int i = 0;
    if ((zDatabase) != null)
    {
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            if ((sqlite3StrICmp(zDatabase, db.aDb[i].zDbSName)) == (0))
                break;
        }

        if ((i) &gt;= (db.nDb))
        {
            if ((sqlite3StrICmp(zDatabase, "main")) == (0))
            {
                i = (int)(0);
            }
            else
            {
                return null;
            }
        }

        p = sqlite3HashFind(&amp;db.aDb[i].pSchema.tblHash, zName);
        if (((p) == (null)) &amp;&amp; ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0)))
        {
            if ((i) == (1))
            {
                if ((((sqlite3StrICmp(zName + 7, &amp;"sqlite_temp_schema"[7])) == (0)) || ((sqlite3StrICmp(zName + 7, &amp;"sqlite_schema"[7])) == (0))) || ((sqlite3StrICmp(zName + 7, &amp;"sqlite_master"[7])) == (0)))
                {
                    p = sqlite3HashFind(&amp;db.aDb[1].pSchema.tblHash, "sqlite_temp_master");
                }
            }
            else
            {
                if ((sqlite3StrICmp(zName + 7, &amp;"sqlite_schema"[7])) == (0))
                {
                    p = sqlite3HashFind(&amp;db.aDb[i].pSchema.tblHash, "sqlite_master");
                }
            }
        }
    }
    else
    {
        p = sqlite3HashFind(&amp;db.aDb[1].pSchema.tblHash, zName);
        if ((p) != null)
            return p;
        p = sqlite3HashFind(&amp;db.aDb[0].pSchema.tblHash, zName);
        if ((p) != null)
            return p;
        for (i = (int)(2); (i) &lt; (db.nDb); i++)
        {
            p = sqlite3HashFind(&amp;db.aDb[i].pSchema.tblHash, zName);
            if ((p) != null)
                break;
        }

        if (((p) == (null)) &amp;&amp; ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0)))
        {
            if ((sqlite3StrICmp(zName + 7, &amp;"sqlite_schema"[7])) == (0))
            {
                p = sqlite3HashFind(&amp;db.aDb[0].pSchema.tblHash, "sqlite_master");
            }
            else if ((sqlite3StrICmp(zName + 7, &amp;"sqlite_temp_schema"[7])) == (0))
            {
                p = sqlite3HashFind(&amp;db.aDb[1].pSchema.tblHash, "sqlite_temp_master");
            }
        }
    }

    return p;
}</function>
  <function>public static void sqlite3FinishCoding(Parse pParse)
{
    sqlite3 db;
    Vdbe v;
    db = pParse.db;
    if ((pParse.nested) != 0)
        return;
    if ((pParse.nErr) != 0)
    {
        if ((db.mallocFailed) != 0)
            pParse.rc = (int)(7);
        return;
    }

    v = pParse.pVdbe;
    if ((v) == (null))
    {
        if ((db.init.busy) != 0)
        {
            pParse.rc = (int)(101);
            return;
        }

        v = sqlite3GetVdbe(pParse);
        if ((v) == (null))
            pParse.rc = (int)(1);
    }

    if ((v) != null)
    {
        if ((pParse.bReturning) != 0)
        {
            Returning pReturning = pParse.u1.pReturning;
            int addrRewind = 0;
            int i = 0;
            int reg = 0;
            if (((pReturning.nRetCol) == (0)))
            {
            }
            else
            {
                sqlite3VdbeAddOp0(v, (int)(82));
                addrRewind = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(pReturning.iRetCur)));
                reg = (int)(pReturning.iRetReg);
                for (i = (int)(0); (i) &lt; (pReturning.nRetCol); i++)
                {
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(pReturning.iRetCur), (int)(i), (int)(reg + i));
                }

                sqlite3VdbeAddOp2(v, (int)(83), (int)(reg), (int)(i));
                sqlite3VdbeAddOp2(v, (int)(5), (int)(pReturning.iRetCur), (int)(addrRewind + 1));
                sqlite3VdbeJumpHere(v, (int)(addrRewind));
            }
        }

        sqlite3VdbeAddOp0(v, (int)(70));
        if (((db.mallocFailed) == (0)) &amp;&amp; (((pParse.cookieMask) != 0) || ((pParse.pConstExpr) != null)))
        {
            int iDb = 0;
            int i = 0;
            sqlite3VdbeJumpHere(v, (int)(0));
            for (iDb = (int)(0); (iDb) &lt; (db.nDb); iDb++)
            {
                Schema pSchema;
                if ((((pParse.cookieMask) &amp; (((uint)(1)) &lt;&lt; (iDb))) != 0) == (0))
                    continue;
                sqlite3VdbeUsesBtree(v, (int)(iDb));
                pSchema = db.aDb[iDb].pSchema;
                sqlite3VdbeAddOp4Int(v, (int)(2), (int)(iDb), (int)(((pParse.writeMask) &amp; (((uint)(1)) &lt;&lt; (iDb))) != 0), (int)(pSchema.schema_cookie), (int)(pSchema.iGeneration));
                if ((db.init.busy) == (0))
                    sqlite3VdbeChangeP5(v, (ushort)(1));
            }

            for (i = (int)(0); (i) &lt; (pParse.nVtabLock); i++)
            {
                sbyte* vtab = (sbyte*)(sqlite3GetVTable(db, pParse.apVtabLock[i]));
                sqlite3VdbeAddOp4(v, (int)(169), (int)(0), (int)(0), (int)(0), vtab, (int)(-12));
            }

            pParse.nVtabLock = (int)(0);
            codeTableLocks(pParse);
            sqlite3AutoincrementBegin(pParse);
            if ((pParse.pConstExpr) != null)
            {
                ExprList pEL = pParse.pConstExpr;
                pParse.okConstFactor = (byte)(0);
                for (i = (int)(0); (i) &lt; (pEL.nExpr); i++)
                {
                    int iReg = (int)(pEL.a[i].u.iConstExprReg);
                    if ((iReg) &gt; (0))
                    {
                        sqlite3ExprCode(pParse, pEL.a[i].pExpr, (int)(iReg));
                    }
                }
            }

            if ((pParse.bReturning) != 0)
            {
                Returning pRet = pParse.u1.pReturning;
                if (((pRet.nRetCol) == (0)))
                {
                }
                else
                {
                    sqlite3VdbeAddOp2(v, (int)(116), (int)(pRet.iRetCur), (int)(pRet.nRetCol));
                }
            }

            sqlite3VdbeGoto(v, (int)(1));
        }
    }

    if ((pParse.nErr) == (0))
    {
        sqlite3VdbeMakeReady(v, pParse);
        pParse.rc = (int)(101);
    }
    else
    {
        pParse.rc = (int)(1);
    }
}</function>
  <function>public static void sqlite3FinishTrigger(Parse pParse, TriggerStep pStepList, Token* pAll)
{
    Trigger pTrig = pParse.pNewTrigger;
    sbyte* zName;
    sqlite3 db = pParse.db;
    DbFixer sFix = new DbFixer();
    int iDb = 0;
    Token nameToken = new Token();
    pParse.pNewTrigger = null;
    if (((pParse.nErr) != 0) || (pTrig == null))
        goto triggerfinish_cleanup;
    zName = pTrig.zName;
    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTrig.pSchema));
    pTrig.step_list = pStepList;
    while ((pStepList) != null)
    {
        pStepList.pTrig = pTrig;
        pStepList = pStepList.pNext;
    }

    sqlite3TokenInit(&amp;nameToken, pTrig.zName);
    sqlite3FixInit(sFix, pParse, (int)(iDb), "trigger", &amp;nameToken);
    if (((sqlite3FixTriggerStep(sFix, pTrig.step_list)) != 0) || ((sqlite3FixExpr(sFix, pTrig.pWhen)) != 0))
    {
        goto triggerfinish_cleanup;
    }

    if (((pParse.eParseMode) &gt;= (2)))
    {
        pParse.pNewTrigger = pTrig;
        pTrig = null;
    }
    else if (db.init.busy == 0)
    {
        Vdbe v;
        sbyte* z;
        v = sqlite3GetVdbe(pParse);
        if ((v) == (null))
            goto triggerfinish_cleanup;
        sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
        z = sqlite3DbStrNDup(db, pAll-&gt;z, (ulong)(pAll-&gt;n));
        sqlite3NestedParse(pParse, "INSERT INTO %Q.sqlite_master VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')", db.aDb[iDb].zDbSName, zName, pTrig.table, z);
        sqlite3DbFree(db, z);
        sqlite3ChangeCookie(pParse, (int)(iDb));
        sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName), (ushort)(0));
    }

    if ((db.init.busy) != 0)
    {
        Trigger pLink = pTrig;
        Hash* pHash = &amp;db.aDb[iDb].pSchema.trigHash;
        pTrig = sqlite3HashInsert(pHash, zName, pTrig);
        if ((pTrig) != null)
        {
            sqlite3OomFault(db);
        }
        else if ((pLink.pSchema) == (pLink.pTabSchema))
        {
            Table pTab;
            pTab = sqlite3HashFind(&amp;pLink.pTabSchema.tblHash, pLink.table);
            pLink.pNext = pTab.pTrigger;
            pTab.pTrigger = pLink;
        }
    }

    triggerfinish_cleanup:
        ; sqlite3DeleteTrigger ( db ,  pTrig ) ; 
    sqlite3DeleteTriggerStep(db, pStepList);
}</function>
  <function>public static int sqlite3FixExpr(DbFixer pFix, Expr pExpr)
{
    return (int)(sqlite3WalkExpr(pFix.w, pExpr));
}</function>
  <function>public static void sqlite3FixInit(DbFixer pFix, Parse pParse, int iDb, sbyte* zType, Token* pName)
{
    sqlite3 db = pParse.db;
    pFix.pParse = pParse;
    pFix.zDb = db.aDb[iDb].zDbSName;
    pFix.pSchema = db.aDb[iDb].pSchema;
    pFix.zType = zType;
    pFix.pName = pName;
    pFix.bTemp = (byte)((iDb) == (1));
    pFix.w.pParse = pParse;
    pFix.w.xExprCallback = fixExprCb;
    pFix.w.xSelectCallback = fixSelectCb;
    pFix.w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;
    pFix.w.walkerDepth = (int)(0);
    pFix.w.eCode = (ushort)(0);
    pFix.w.u.pFix = pFix;
}</function>
  <function>public static int sqlite3FixSelect(DbFixer pFix, Select pSelect)
{
    return (int)(sqlite3WalkSelect(pFix.w, pSelect));
}</function>
  <function>public static int sqlite3FixSrcList(DbFixer pFix, SrcList pList)
{
    int res = (int)(0);
    if ((pList) != null)
    {
        Select s = new Select();
        CRuntime.memset(s, (int)(0), (ulong)(sizeof(Select)));
        s.pSrc = pList;
        res = (int)(sqlite3WalkSelect(pFix.w, s));
    }

    return (int)(res);
}</function>
  <function>public static int sqlite3FixTriggerStep(DbFixer pFix, TriggerStep pStep)
{
    while ((pStep) != null)
    {
        if (((((sqlite3WalkSelect(pFix.w, pStep.pSelect)) != 0) || ((sqlite3WalkExpr(pFix.w, pStep.pWhere)) != 0)) || ((sqlite3WalkExprList(pFix.w, pStep.pExprList)) != 0)) || ((sqlite3FixSrcList(pFix, pStep.pFrom)) != 0))
        {
            return (int)(1);
        }

        {
            Upsert pUp;
            for (pUp = pStep.pUpsert; pUp; pUp = pUp.pNextUpsert)
            {
                if (((((sqlite3WalkExprList(pFix.w, pUp.pUpsertTarget)) != 0) || ((sqlite3WalkExpr(pFix.w, pUp.pUpsertTargetWhere)) != 0)) || ((sqlite3WalkExprList(pFix.w, pUp.pUpsertSet)) != 0)) || ((sqlite3WalkExpr(pFix.w, pUp.pUpsertWhere)) != 0))
                {
                    return (int)(1);
                }
            }
        }

        pStep = pStep.pNext;
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3FkActions(Parse pParse, Table pTab, ExprList pChanges, int regOld, int* aChange, int bChngRowid)
{
    if ((pParse.db.flags &amp; 0x00004000) != 0)
    {
        FKey pFKey;
        for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey.pNextTo)
        {
            if (((aChange) == (null)) || ((fkParentIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) != 0))
            {
                Trigger pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
                if ((pAct) != null)
                {
                    sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, (int)(regOld), (int)(2), (int)(0));
                }
            }
        }
    }
}</function>
  <function>public static void sqlite3FkCheck(Parse pParse, Table pTab, int regOld, int regNew, int* aChange, int bChngRowid)
{
    sqlite3 db = pParse.db;
    FKey pFKey;
    int iDb = 0;
    sbyte* zDb;
    int isIgnoreErrors = (int)(pParse.disableTriggers);
    if ((db.flags &amp; 0x00004000) == (0))
        return;
    if (!(((pTab).eTabType) == (0)))
        return;
    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    zDb = db.aDb[iDb].zDbSName;
    for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
    {
        Table pTo;
        Index pIdx = null;
        int* aiFree = null;
        int* aiCol;
        int iCol = 0;
        int i = 0;
        int bIgnore = (int)(0);
        if ((((aChange) != null) &amp;&amp; (sqlite3_stricmp(pTab.zName, pFKey.zTo) != 0)) &amp;&amp; ((fkChildIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) == (0)))
        {
            continue;
        }

        if ((pParse.disableTriggers) != 0)
        {
            pTo = sqlite3FindTable(db, pFKey.zTo, zDb);
        }
        else
        {
            pTo = sqlite3LocateTable(pParse, (uint)(0), pFKey.zTo, zDb);
        }

        if ((pTo == null) || ((sqlite3FkLocateIndex(pParse, pTo, pFKey, pIdx, &amp;aiFree)) != 0))
        {
            if ((isIgnoreErrors == 0) || ((db.mallocFailed) != 0))
                return;
            if ((pTo) == (null))
            {
                Vdbe v = sqlite3GetVdbe(pParse);
                int iJump = (int)(sqlite3VdbeCurrentAddr(v) + pFKey.nCol + 1);
                for (i = (int)(0); (i) &lt; (pFKey.nCol); i++)
                {
                    int iFromCol = 0;
                    int iReg = 0;
                    iFromCol = (int)(pFKey.aCol[i].iFrom);
                    iReg = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(iFromCol)) + regOld + 1);
                    sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(iJump));
                }

                sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(-1));
            }

            continue;
        }

        if ((aiFree) != null)
        {
            aiCol = aiFree;
        }
        else
        {
            iCol = (int)(pFKey.aCol[0].iFrom);
            aiCol = &amp;iCol;
        }

        for (i = (int)(0); (i) &lt; (pFKey.nCol); i++)
        {
            if ((aiCol[i]) == (pTab.iPKey))
            {
                aiCol[i] = (int)(-1);
            }

            if ((db.xAuth) != null)
            {
                int rcauth = 0;
                sbyte* zCol = pTo.aCol[pIdx ? pIdx.aiColumn[i] : pTo.iPKey].zCnName;
                rcauth = (int)(sqlite3AuthReadCol(pParse, pTo.zName, zCol, (int)(iDb)));
                bIgnore = (int)((rcauth) == (2) ? 1 : 0);
            }
        }

        sqlite3TableLock(pParse, (int)(iDb), (uint)(pTo.tnum), (byte)(0), pTo.zName);
        pParse.nTab++;
        if (regOld != 0)
        {
            fkLookupParent(pParse, (int)(iDb), pTo, pIdx, pFKey, aiCol, (int)(regOld), (int)(-1), (int)(bIgnore));
        }

        if ((regNew != 0) &amp;&amp; (isSetNullAction(pParse, pFKey) == 0))
        {
            fkLookupParent(pParse, (int)(iDb), pTo, pIdx, pFKey, aiCol, (int)(regNew), (int)(+1), (int)(bIgnore));
        }

        sqlite3DbFree(db, aiFree);
    }

    for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey.pNextTo)
    {
        Index pIdx = null;
        SrcList pSrc;
        int* aiCol = null;
        if (((aChange) != null) &amp;&amp; ((fkParentIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) == (0)))
        {
            continue;
        }

        if ((((pFKey.isDeferred == 0) &amp;&amp; ((db.flags &amp; 0x00080000) == 0)) &amp;&amp; (pParse.pToplevel == null)) &amp;&amp; (pParse.isMultiWrite == 0))
        {
            continue;
        }

        if ((sqlite3FkLocateIndex(pParse, pTab, pFKey, pIdx, &amp;aiCol)) != 0)
        {
            if ((isIgnoreErrors == 0) || ((db.mallocFailed) != 0))
                return;
            continue;
        }

        pSrc = sqlite3SrcListAppend(pParse, null, null, null);
        if ((pSrc) != null)
        {
            SrcItem pItem = pSrc.a;
            pItem.pTab = pFKey.pFrom;
            pItem.zName = pFKey.pFrom.zName;
            pItem.pTab.nTabRef++;
            pItem.iCursor = (int)(pParse.nTab++);
            if (regNew != 0)
            {
                fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, (int)(regNew), (int)(-1));
            }

            if (regOld != 0)
            {
                int eAction = (int)(pFKey.aAction[aChange != null ]);
                fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, (int)(regOld), (int)(1));
                if (((pFKey.isDeferred == 0) &amp;&amp; (eAction != 10)) &amp;&amp; (eAction != 8))
                {
                    sqlite3MayAbort(pParse);
                }
            }

            pItem.zName = null;
            sqlite3SrcListDelete(db, pSrc);
        }

        sqlite3DbFree(db, aiCol);
    }
}</function>
  <function>public static void sqlite3FkClearTriggerCache(sqlite3 db, int iDb)
{
    HashElem* k;
    Hash* pHash = &amp;db.aDb[iDb].pSchema.tblHash;
    for (k = ((pHash)-&gt;first); k; k = ((k)-&gt;next))
    {
        Table pTab = ((k)-&gt;data);
        FKey pFKey;
        if (!(((pTab).eTabType) == (0)))
            continue;
        for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
        {
            fkTriggerDelete(db, pFKey.apTrigger[0]);
            pFKey.apTrigger[0] = null;
            fkTriggerDelete(db, pFKey.apTrigger[1]);
            pFKey.apTrigger[1] = null;
        }
    }
}</function>
  <function>public static void sqlite3FkDelete(sqlite3 db, Table pTab)
{
    FKey pFKey;
    FKey pNext;
    for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pNext)
    {
        if ((db == null) || ((db.pnBytesFreed) == (null)))
        {
            if ((pFKey.pPrevTo) != null)
            {
                pFKey.pPrevTo.pNextTo = pFKey.pNextTo;
            }
            else
            {
                void* p = (void*)(pFKey.pNextTo);
                sbyte* z = (p ? pFKey.pNextTo.zTo : pFKey.zTo);
                sqlite3HashInsert(&amp;pTab.pSchema.fkeyHash, z, p);
            }

            if ((pFKey.pNextTo) != null)
            {
                pFKey.pNextTo.pPrevTo = pFKey.pPrevTo;
            }
        }

        fkTriggerDelete(db, pFKey.apTrigger[0]);
        fkTriggerDelete(db, pFKey.apTrigger[1]);
        pNext = pFKey.pNextFrom;
        sqlite3DbFree(db, pFKey);
    }
}</function>
  <function>public static void sqlite3FkDropTable(Parse pParse, SrcList pName, Table pTab)
{
    sqlite3 db = pParse.db;
    if (((db.flags &amp; 0x00004000) != 0) &amp;&amp; (((pTab).eTabType) == (0)))
    {
        int iSkip = (int)(0);
        Vdbe v = sqlite3GetVdbe(pParse);
        if ((sqlite3FkReferences(pTab)) == (null))
        {
            FKey p;
            for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
            {
                if (((p.isDeferred) != 0) || ((db.flags &amp; 0x00080000) != 0))
                    break;
            }

            if (p == null)
                return;
            iSkip = (int)(sqlite3VdbeMakeLabel(pParse));
            sqlite3VdbeAddOp2(v, (int)(48), (int)(1), (int)(iSkip));
        }

        pParse.disableTriggers = (byte)(1);
        sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, (int)(0)), null, null, null);
        pParse.disableTriggers = (byte)(0);
        if ((db.flags &amp; 0x00080000) == (0))
        {
            sqlite3VdbeAddOp2(v, (int)(48), (int)(0), (int)(sqlite3VdbeCurrentAddr(v) + 2));
            sqlite3HaltConstraint(pParse, (int)(19 | (3 &lt;&lt; 8)), (int)(2), null, (sbyte)(-1), (byte)(4));
        }

        if ((iSkip) != 0)
        {
            sqlite3VdbeResolveLabel(v, (int)(iSkip));
        }
    }
}</function>
  <function>public static int sqlite3FkLocateIndex(Parse pParse, Table pParent, FKey pFKey, Index ppIdx, int** paiCol)
{
    Index pIdx = null;
    int* aiCol = null;
    int nCol = (int)(pFKey.nCol);
    sbyte* zKey = pFKey.aCol[0].zCol;
    if ((nCol) == (1))
    {
        if ((pParent.iPKey) &gt;= (0))
        {
            if (zKey == null)
                return (int)(0);
            if (sqlite3StrICmp(pParent.aCol[pParent.iPKey].zCnName, zKey) == 0)
            {
                return (int)(0);
            }
        }
    }
    else if ((paiCol) != null)
    {
        aiCol = (int*)(sqlite3DbMallocRawNN(pParse.db, (ulong)(nCol * sizeof(int))));
        if (aiCol == null)
            return (int)(1);
        *paiCol = aiCol;
    }

    for (pIdx = pParent.pIndex; pIdx; pIdx = pIdx.pNext)
    {
        if ((((pIdx.nKeyCol) == (nCol)) &amp;&amp; ((pIdx).onError != 0)) &amp;&amp; ((pIdx.pPartIdxWhere) == (null)))
        {
            if ((zKey) == (null))
            {
                if ((((pIdx).idxType) == (2)))
                {
                    if ((aiCol) != null)
                    {
                        int i = 0;
                        for (i = (int)(0); (i) &lt; (nCol); i++)
                        {
                            aiCol[i] = (int)(pFKey.aCol[i].iFrom);
                        }
                    }

                    break;
                }
            }
            else
            {
                int i = 0;
                int j = 0;
                for (i = (int)(0); (i) &lt; (nCol); i++)
                {
                    short iCol = (short)(pIdx.aiColumn[i]);
                    sbyte* zDfltColl;
                    sbyte* zIdxCol;
                    if ((iCol) &lt; (0))
                        break;
                    zDfltColl = sqlite3ColumnColl(&amp;pParent.aCol[iCol]);
                    if (zDfltColl == null)
                        zDfltColl = sqlite3StrBINARY;
                    if ((sqlite3StrICmp(pIdx.azColl[i], zDfltColl)) != 0)
                        break;
                    zIdxCol = pParent.aCol[iCol].zCnName;
                    for (j = (int)(0); (j) &lt; (nCol); j++)
                    {
                        if ((sqlite3StrICmp(pFKey.aCol[j].zCol, zIdxCol)) == (0))
                        {
                            if ((aiCol) != null)
                                aiCol[i] = (int)(pFKey.aCol[j].iFrom);
                            break;
                        }
                    }

                    if ((j) == (nCol))
                        break;
                }

                if ((i) == (nCol))
                    break;
            }
        }
    }

    if (pIdx == null)
    {
        if (pParse.disableTriggers == 0)
        {
            sqlite3ErrorMsg(pParse, "foreign key mismatch - \"%w\" referencing \"%w\"", pFKey.pFrom.zName, pFKey.zTo);
        }

        sqlite3DbFree(pParse.db, aiCol);
        return (int)(1);
    }

    ppIdx = pIdx;
    return (int)(0);
}</function>
  <function>public static uint sqlite3FkOldmask(Parse pParse, Table pTab)
{
    uint mask = (uint)(0);
    if (((pParse.db.flags &amp; 0x00004000) != 0) &amp;&amp; (((pTab).eTabType) == (0)))
    {
        FKey p;
        int i = 0;
        for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
        {
            for (i = (int)(0); (i) &lt; (p.nCol); i++)
            {
                mask |= (uint)(((p.aCol[i].iFrom) &gt; (31)) ? 0xffffffff : ((uint)(1) &lt;&lt; (p.aCol[i].iFrom)));
            }
        }

        for (p = sqlite3FkReferences(pTab); p; p = p.pNextTo)
        {
            Index pIdx = null;
            sqlite3FkLocateIndex(pParse, pTab, p, pIdx, null);
            if ((pIdx) != null)
            {
                for (i = (int)(0); (i) &lt; (pIdx.nKeyCol); i++)
                {
                    mask |= (uint)(((pIdx.aiColumn[i]) &gt; (31)) ? 0xffffffff : ((uint)(1) &lt;&lt; (pIdx.aiColumn[i])));
                }
            }
        }
    }

    return (uint)(mask);
}</function>
  <function>public static FKey sqlite3FkReferences(Table pTab)
{
    return (FKey)(sqlite3HashFind(&amp;pTab.pSchema.fkeyHash, pTab.zName));
}</function>
  <function>public static int sqlite3FkRequired(Parse pParse, Table pTab, int* aChange, int chngRowid)
{
    int eRet = (int)(1);
    int bHaveFK = (int)(0);
    if (((pParse.db.flags &amp; 0x00004000) != 0) &amp;&amp; (((pTab).eTabType) == (0)))
    {
        if (aChange == null)
        {
            bHaveFK = (int)(((sqlite3FkReferences(pTab)) != null) || ((pTab.u.tab.pFKey) != null) ? 1 : 0);
        }
        else
        {
            FKey p;
            for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
            {
                if ((fkChildIsModified(pTab, p, aChange, (int)(chngRowid))) != 0)
                {
                    if ((0) == (sqlite3_stricmp(pTab.zName, p.zTo)))
                        eRet = (int)(2);
                    bHaveFK = (int)(1);
                }
            }

            for (p = sqlite3FkReferences(pTab); p; p = p.pNextTo)
            {
                if ((fkParentIsModified(pTab, p, aChange, (int)(chngRowid))) != 0)
                {
                    if (p.aAction[1] != 0)
                        return (int)(2);
                    bHaveFK = (int)(1);
                }
            }
        }
    }

    return (int)((bHaveFK) != 0 ? eRet : 0);
}</function>
  <function>public static void sqlite3ForceNotReadOnly(Parse pParse)
{
    int iReg = (int)(++pParse.nMem);
    Vdbe v = sqlite3GetVdbe(pParse);
    if ((v) != null)
    {
        sqlite3VdbeAddOp3(v, (int)(7), (int)(0), (int)(iReg), (int)(-1));
        sqlite3VdbeUsesBtree(v, (int)(0));
    }
}</function>
  <function>public static void sqlite3FreeIndex(sqlite3 db, Index p)
{
    sqlite3DeleteIndexSamples(db, p);
    sqlite3ExprDelete(db, p.pPartIdxWhere);
    sqlite3ExprListDelete(db, p.aColExpr);
    sqlite3DbFree(db, p.zColAff);
    if ((p.isResized) != 0)
        sqlite3DbFree(db, (void*)(p.azColl));
    sqlite3DbFree(db, p);
}</function>
  <function>public static FuncDef sqlite3FunctionSearch(int h, sbyte* zFunc)
{
    FuncDef p;
    for (p = sqlite3BuiltinFunctions.a[h]; p; p = p.u.pHash)
    {
        if ((sqlite3StrICmp(p.zName, zFunc)) == (0))
        {
            return p;
        }
    }

    return null;
}</function>
  <function>public static void sqlite3GenerateColumnNames(Parse pParse, Select pSelect)
{
    Vdbe v = pParse.pVdbe;
    int i = 0;
    Table pTab;
    SrcList pTabList;
    ExprList pEList;
    sqlite3 db = pParse.db;
    int fullName = 0;
    int srcName = 0;
    if ((pParse.explain) != 0)
    {
        return;
    }

    if ((pParse.colNamesSet) != 0)
        return;
    while ((pSelect.pPrior) != null)
    {
        pSelect = pSelect.pPrior;
    }

    pTabList = pSelect.pSrc;
    pEList = pSelect.pEList;
    pParse.colNamesSet = (byte)(1);
    fullName = (int)((db.flags &amp; 0x00000004) != 0);
    srcName = (int)(((db.flags &amp; 0x00000040) != 0) || ((fullName) != 0) ? 1 : 0);
    sqlite3VdbeSetNumCols(v, (int)(pEList.nExpr));
    for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
    {
        Expr p = pEList.a[i].pExpr;
        if (((pEList.a[i].zEName) != null) &amp;&amp; ((pEList.a[i].eEName) == (0)))
        {
            sbyte* zName = pEList.a[i].zEName;
            sqlite3VdbeSetColName(v, (int)(i), (int)(0), zName, ((Void(Void * ))(-1)));
        }
        else if (((srcName) != 0) &amp;&amp; ((p.op) == (167)))
        {
            sbyte* zCol;
            int iCol = (int)(p.iColumn);
            pTab = p.y.pTab;
            if ((iCol) &lt; (0))
                iCol = (int)(pTab.iPKey);
            if ((iCol) &lt; (0))
            {
                zCol = "rowid";
            }
            else
            {
                zCol = pTab.aCol[iCol].zCnName;
            }

            if ((fullName) != 0)
            {
                sbyte* zName = null;
                zName = sqlite3MPrintf(db, "%s.%s", pTab.zName, zCol);
                sqlite3VdbeSetColName(v, (int)(i), (int)(0), zName, ((Void(Void * ))(sqlite3OomFault)));
            }
            else
            {
                sqlite3VdbeSetColName(v, (int)(i), (int)(0), zCol, ((Void(Void * ))(-1)));
            }
        }
        else
        {
            sbyte* z = pEList.a[i].zEName;
            z = (z) == (null) ? sqlite3MPrintf(db, "column%d", (int)(i + 1)) : sqlite3DbStrDup(db, z);
            sqlite3VdbeSetColName(v, (int)(i), (int)(0), z, ((Void(Void * ))(sqlite3OomFault)));
        }
    }

    generateColumnTypes(pParse, pTabList, pEList);
}</function>
  <function>public static void sqlite3GenerateConstraintChecks(Parse pParse, Table pTab, int* aRegIdx, int iDataCur, int iIdxCur, int regNewData, int regOldData, byte pkChng, byte overrideError, int ignoreDest, int* pbMayReplace, int* aiChng, Upsert pUpsert)
{
    Vdbe v;
    Index pIdx;
    Index pPk = null;
    sqlite3 db;
    int i = 0;
    int ix = 0;
    int nCol = 0;
    int onError = 0;
    int seenReplace = (int)(0);
    int nPkField = 0;
    Upsert pUpsertClause = null;
    byte isUpdate = 0;
    byte bAffinityDone = (byte)(0);
    int upsertIpkReturn = (int)(0);
    int upsertIpkDelay = (int)(0);
    int ipkTop = (int)(0);
    int ipkBottom = (int)(0);
    int regTrigCnt = 0;
    int addrRecheck = (int)(0);
    int lblRecheckOk = (int)(0);
    Trigger pTrigger;
    int nReplaceTrig = (int)(0);
    IndexIterator sIdxIter = new IndexIterator();
    isUpdate = (byte)(regOldData != 0);
    db = pParse.db;
    v = pParse.pVdbe;
    nCol = (int)(pTab.nCol);
    if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
    {
        pPk = null;
        nPkField = (int)(1);
    }
    else
    {
        pPk = sqlite3PrimaryKeyIndex(pTab);
        nPkField = (int)(pPk.nKeyCol);
    }

    if ((pTab.tabFlags &amp; 0x00000800) != 0)
    {
        int b2ndPass = (int)(0);
        int nSeenReplace = (int)(0);
        int nGenerated = (int)(0);
        while ((1) != 0)
        {
            for (i = (int)(0); (i) &lt; (nCol); i++)
            {
                int iReg = 0;
                Column* pCol = &amp;pTab.aCol[i];
                int isGenerated = 0;
                onError = (int)(pCol-&gt;notNull);
                if ((onError) == (0))
                    continue;
                if ((i) == (pTab.iPKey))
                {
                    continue;
                }

                isGenerated = (int)(pCol-&gt;colFlags &amp; 0x0060);
                if (((isGenerated) != 0) &amp;&amp; (b2ndPass == 0))
                {
                    nGenerated++;
                    continue;
                }

                if ((((aiChng) != null) &amp;&amp; ((aiChng[i]) &lt; (0))) &amp;&amp; (isGenerated == 0))
                {
                    continue;
                }

                if (overrideError != 11)
                {
                    onError = (int)(overrideError);
                }
                else if ((onError) == (11))
                {
                    onError = (int)(2);
                }

                if ((onError) == (5))
                {
                    if (((b2ndPass) != 0) || ((pCol-&gt;iDflt) == (0)))
                    {
                        onError = (int)(2);
                    }
                    else
                    {
                    }
                }
                else if (((b2ndPass) != 0) &amp;&amp; (isGenerated == 0))
                {
                    continue;
                }

                iReg = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + regNewData + 1);
                switch (onError)
                {
                    case 5:
                    {
                        int addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(iReg)));
                        nSeenReplace++;
                        sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), (int)(iReg));
                        sqlite3VdbeJumpHere(v, (int)(addr1));
                        break;
                    }

                    case 2:
                        sqlite3MayAbort(pParse);
                    case 1:
                    case 3:
                    {
                        sbyte* zMsg = sqlite3MPrintf(db, "%s.%s", pTab.zName, pCol-&gt;zCnName);
                        sqlite3VdbeAddOp3(v, (int)(69), (int)(19 | (5 &lt;&lt; 8)), (int)(onError), (int)(iReg));
                        sqlite3VdbeAppendP4(v, zMsg, (int)(-7));
                        sqlite3VdbeChangeP5(v, (ushort)(1));
                        break;
                    }

                    default:
                    {
                        sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(ignoreDest));
                        break;
                    }
                }
            }

            if (((nGenerated) == (0)) &amp;&amp; ((nSeenReplace) == (0)))
            {
                break;
            }

            if ((b2ndPass) != 0)
                break;
            b2ndPass = (int)(1);
            if (((nSeenReplace) &gt; (0)) &amp;&amp; ((pTab.tabFlags &amp; 0x00000060) != 0))
            {
                sqlite3ComputeGeneratedColumns(pParse, (int)(regNewData + 1), pTab);
            }
        }
    }

    if (((pTab.pCheck) != null) &amp;&amp; ((db.flags &amp; 0x00000200) == (0)))
    {
        ExprList pCheck = pTab.pCheck;
        pParse.iSelfTab = (int)(-(regNewData + 1));
        onError = (int)(overrideError != 11 ? overrideError : 2);
        for (i = (int)(0); (i) &lt; (pCheck.nExpr); i++)
        {
            int allOk = 0;
            Expr pCopy;
            Expr pExpr = pCheck.a[i].pExpr;
            if (((aiChng) != null) &amp;&amp; (sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, (int)(pkChng)) == 0))
            {
                continue;
            }

            if ((bAffinityDone) == (0))
            {
                sqlite3TableAffinity(v, pTab, (int)(regNewData + 1));
                bAffinityDone = (byte)(1);
            }

            allOk = (int)(sqlite3VdbeMakeLabel(pParse));
            pCopy = sqlite3ExprDup(db, pExpr, (int)(0));
            if (db.mallocFailed == 0)
            {
                sqlite3ExprIfTrue(pParse, pCopy, (int)(allOk), (int)(0x10));
            }

            sqlite3ExprDelete(db, pCopy);
            if ((onError) == (4))
            {
                sqlite3VdbeGoto(v, (int)(ignoreDest));
            }
            else
            {
                sbyte* zName = pCheck.a[i].zEName;
                if ((onError) == (5))
                    onError = (int)(2);
                sqlite3HaltConstraint(pParse, (int)(19 | (1 &lt;&lt; 8)), (int)(onError), zName, (sbyte)(0), (byte)(3));
            }

            sqlite3VdbeResolveLabel(v, (int)(allOk));
        }

        pParse.iSelfTab = (int)(0);
    }

    sIdxIter.eType = (int)(0);
    sIdxIter.i = (int)(0);
    sIdxIter.u.ax.aIdx = null;
    sIdxIter.u.lx.pIdx = pTab.pIndex;
    if ((pUpsert) != null)
    {
        if ((pUpsert.pUpsertTarget) == (null))
        {
            if ((pUpsert.isDoUpdate) == (0))
            {
                overrideError = (byte)(4);
                pUpsert = null;
            }
            else
            {
                overrideError = (byte)(6);
            }
        }
        else if (pTab.pIndex != null)
        {
            int nIdx = 0;
            int jj = 0;
            ulong nByte = 0;
            Upsert pTerm;
            byte* bUsed;
            for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
            {
            }

            sIdxIter.eType = (int)(1);
            sIdxIter.u.ax.nIdx = (int)(nIdx);
            nByte = (ulong)((sizeof(IndexListTerm) + 1) * nIdx + nIdx);
            sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, (ulong)(nByte));
            if ((sIdxIter.u.ax.aIdx) == (null))
                return;
            bUsed = (byte*)(sIdxIter.u.ax.aIdx[nIdx]);
            pUpsert.pToFree = sIdxIter.u.ax.aIdx;
            for (i = (int)(0), pTerm = pUpsert; pTerm; pTerm = pTerm.pNextUpsert)
            {
                if ((pTerm.pUpsertTarget) == (null))
                    break;
                if ((pTerm.pUpsertIdx) == (null))
                    continue;
                jj = (int)(0);
                pIdx = pTab.pIndex;
                while ((pIdx != null) &amp;&amp; (pIdx != pTerm.pUpsertIdx))
                {
                    pIdx = pIdx.pNext;
                    jj++;
                }

                if ((bUsed[jj]) != 0)
                    continue;
                bUsed[jj] = (byte)(1);
                sIdxIter.u.ax.aIdx[i].p = pIdx;
                sIdxIter.u.ax.aIdx[i].ix = (int)(jj);
                i++;
            }

            for (jj = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, jj++)
            {
                if ((bUsed[jj]) != 0)
                    continue;
                sIdxIter.u.ax.aIdx[i].p = pIdx;
                sIdxIter.u.ax.aIdx[i].ix = (int)(jj);
                i++;
            }
        }
    }

    if ((db.flags &amp; (0x00002000 | 0x00004000)) == (0))
    {
        pTrigger = null;
        regTrigCnt = (int)(0);
    }
    else
    {
        if ((db.flags &amp; 0x00002000) != 0)
        {
            pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(128), null, null);
            regTrigCnt = (int)((pTrigger != null) || ((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) ? 1 : 0);
        }
        else
        {
            pTrigger = null;
            regTrigCnt = (int)(sqlite3FkRequired(pParse, pTab, null, (int)(0)));
        }

        if ((regTrigCnt) != 0)
        {
            regTrigCnt = (int)(++pParse.nMem);
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regTrigCnt));
            lblRecheckOk = (int)(sqlite3VdbeMakeLabel(pParse));
            addrRecheck = (int)(lblRecheckOk);
        }
    }

    if (((pkChng) != 0) &amp;&amp; ((pPk) == (null)))
    {
        int addrRowidOk = (int)(sqlite3VdbeMakeLabel(pParse));
        onError = (int)(pTab.keyConf);
        if (overrideError != 11)
        {
            onError = (int)(overrideError);
        }
        else if ((onError) == (11))
        {
            onError = (int)(2);
        }

        if ((pUpsert) != null)
        {
            pUpsertClause = sqlite3UpsertOfIndex(pUpsert, null);
            if (pUpsertClause != null)
            {
                if ((pUpsertClause.isDoUpdate) == (0))
                {
                    onError = (int)(4);
                }
                else
                {
                    onError = (int)(6);
                }
            }

            if (pUpsertClause != pUpsert)
            {
                upsertIpkDelay = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
            }
        }

        if (((((onError) == (5)) &amp;&amp; (onError != overrideError)) &amp;&amp; ((pTab.pIndex) != null)) &amp;&amp; (upsertIpkDelay == 0))
        {
            ipkTop = (int)(sqlite3VdbeAddOp0(v, (int)(11)) + 1);
        }

        if ((isUpdate) != 0)
        {
            sqlite3VdbeAddOp3(v, (int)(53), (int)(regNewData), (int)(addrRowidOk), (int)(regOldData));
            sqlite3VdbeChangeP5(v, (ushort)(0x90));
        }

        sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(addrRowidOk), (int)(regNewData));
        switch (onError)
        {
            default:
            {
                onError = (int)(2);
            }

            case 1:
            case 2:
            case 3:
            {
                sqlite3RowidConstraint(pParse, (int)(onError), pTab);
                break;
            }

            case 5:
            {
                if ((regTrigCnt) != 0)
                {
                    sqlite3MultiWrite(pParse);
                    sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(regNewData), (short)(1), (byte)(0), (byte)(5), (byte)(1), (int)(-1));
                    sqlite3VdbeAddOp2(v, (int)(85), (int)(regTrigCnt), (int)(1));
                    nReplaceTrig++;
                }
                else
                {
                    if ((pTab.pIndex) != null)
                    {
                        sqlite3MultiWrite(pParse);
                        sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), null, (int)(-1));
                    }
                }

                seenReplace = (int)(1);
                break;
            }

            case 6:
            {
                sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, null, (int)(iDataCur));
            }

            case 4:
            {
                sqlite3VdbeGoto(v, (int)(ignoreDest));
                break;
            }
        }

        sqlite3VdbeResolveLabel(v, (int)(addrRowidOk));
        if (((pUpsert) != null) &amp;&amp; (pUpsertClause != pUpsert))
        {
            upsertIpkReturn = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
        }
        else if ((ipkTop) != 0)
        {
            ipkBottom = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
            sqlite3VdbeJumpHere(v, (int)(ipkTop - 1));
        }
    }

    for (pIdx = indexIteratorFirst(&amp;sIdxIter, &amp;ix); pIdx; pIdx = indexIteratorNext(&amp;sIdxIter, &amp;ix))
    {
        int regIdx = 0;
        int regR = 0;
        int iThisCur = 0;
        int addrUniqueOk = 0;
        int addrConflictCk = 0;
        if ((aRegIdx[ix]) == (0))
            continue;
        if ((pUpsert) != null)
        {
            pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);
            if (((upsertIpkDelay) != 0) &amp;&amp; ((pUpsertClause) == (pUpsert)))
            {
                sqlite3VdbeJumpHere(v, (int)(upsertIpkDelay));
            }
        }

        addrUniqueOk = (int)(sqlite3VdbeMakeLabel(pParse));
        if ((bAffinityDone) == (0))
        {
            sqlite3TableAffinity(v, pTab, (int)(regNewData + 1));
            bAffinityDone = (byte)(1);
        }

        iThisCur = (int)(iIdxCur + ix);
        if ((pIdx.pPartIdxWhere) != null)
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(aRegIdx[ix]));
            pParse.iSelfTab = (int)(-(regNewData + 1));
            sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, (int)(addrUniqueOk), (int)(0x10));
            pParse.iSelfTab = (int)(0);
        }

        regIdx = (int)(aRegIdx[ix] + 1);
        for (i = (int)(0); (i) &lt; (pIdx.nColumn); i++)
        {
            int iField = (int)(pIdx.aiColumn[i]);
            int x = 0;
            if ((iField) == (-2))
            {
                pParse.iSelfTab = (int)(-(regNewData + 1));
                sqlite3ExprCodeCopy(pParse, pIdx.aColExpr.a[i].pExpr, (int)(regIdx + i));
                pParse.iSelfTab = (int)(0);
            }
            else if (((iField) == (-1)) || ((iField) == (pTab.iPKey)))
            {
                x = (int)(regNewData);
                sqlite3VdbeAddOp2(v, (int)(81), (int)(x), (int)(regIdx + i));
            }
            else
            {
                x = (int)(sqlite3TableColumnToStorage(pTab, (short)(iField)) + regNewData + 1);
                sqlite3VdbeAddOp2(v, (int)(80), (int)(x), (int)(regIdx + i));
            }
        }

        sqlite3VdbeAddOp3(v, (int)(96), (int)(regIdx), (int)(pIdx.nColumn), (int)(aRegIdx[ix]));
        if ((((isUpdate) != 0) &amp;&amp; ((pPk) == (pIdx))) &amp;&amp; ((pkChng) == (0)))
        {
            sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
            continue;
        }

        onError = (int)(pIdx.onError);
        if ((onError) == (0))
        {
            sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
            continue;
        }

        if (overrideError != 11)
        {
            onError = (int)(overrideError);
        }
        else if ((onError) == (11))
        {
            onError = (int)(2);
        }

        if ((pUpsertClause) != null)
        {
            if ((pUpsertClause.isDoUpdate) == (0))
            {
                onError = (int)(4);
            }
            else
            {
                onError = (int)(6);
            }
        }

        if (((((((ix) == (0)) &amp;&amp; ((pIdx.pNext) == (null))) &amp;&amp; ((pPk) == (pIdx))) &amp;&amp; ((onError) == (5))) &amp;&amp; (((0) == (db.flags &amp; 0x00002000)) || ((null) == (sqlite3TriggersExist(pParse, pTab, (int)(128), null, null))))) &amp;&amp; (((0) == (db.flags &amp; 0x00004000)) || (((null) == (pTab.u.tab.pFKey)) &amp;&amp; ((null) == (sqlite3FkReferences(pTab))))))
        {
            sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
            continue;
        }

        addrConflictCk = (int)(sqlite3VdbeAddOp4Int(v, (int)(29), (int)(iThisCur), (int)(addrUniqueOk), (int)(regIdx), (int)(pIdx.nKeyCol)));
        regR = (int)((pIdx) == (pPk) ? regIdx : sqlite3GetTempRange(pParse, (int)(nPkField)));
        if (((isUpdate) != 0) || ((onError) == (5)))
        {
            if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
            {
                sqlite3VdbeAddOp2(v, (int)(141), (int)(iThisCur), (int)(regR));
                if ((isUpdate) != 0)
                {
                    sqlite3VdbeAddOp3(v, (int)(53), (int)(regR), (int)(addrUniqueOk), (int)(regOldData));
                    sqlite3VdbeChangeP5(v, (ushort)(0x90));
                }
            }
            else
            {
                int x = 0;
                if (pIdx != pPk)
                {
                    for (i = (int)(0); (i) &lt; (pPk.nKeyCol); i++)
                    {
                        x = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[i])));
                        sqlite3VdbeAddOp3(v, (int)(93), (int)(iThisCur), (int)(x), (int)(regR + i));
                    }
                }

                if ((isUpdate) != 0)
                {
                    int addrJump = (int)(sqlite3VdbeCurrentAddr(v) + pPk.nKeyCol);
                    int op = (int)(52);
                    int regCmp = (int)((((pIdx).idxType) == (2)) ? regIdx : regR);
                    for (i = (int)(0); (i) &lt; (pPk.nKeyCol); i++)
                    {
                        sbyte* p4 = (sbyte*)(sqlite3LocateCollSeq(pParse, pPk.azColl[i]));
                        x = (int)(pPk.aiColumn[i]);
                        if ((i) == (pPk.nKeyCol - 1))
                        {
                            addrJump = (int)(addrUniqueOk);
                            op = (int)(53);
                        }

                        x = (int)(sqlite3TableColumnToStorage(pTab, (short)(x)));
                        sqlite3VdbeAddOp4(v, (int)(op), (int)(regOldData + 1 + x), (int)(addrJump), (int)(regCmp + i), p4, (int)(-2));
                        sqlite3VdbeChangeP5(v, (ushort)(0x90));
                    }
                }
            }
        }

        switch (onError)
        {
            case 1:
            case 2:
            case 3:
            {
                sqlite3UniqueConstraint(pParse, (int)(onError), pIdx);
                break;
            }

            case 6:
            {
                sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, (int)(iIdxCur + ix));
            }

            case 4:
            {
                sqlite3VdbeGoto(v, (int)(ignoreDest));
                break;
            }

            default:
            {
                int nConflictCk = 0;
                nConflictCk = (int)(sqlite3VdbeCurrentAddr(v) - addrConflictCk);
                if ((regTrigCnt) != 0)
                {
                    sqlite3MultiWrite(pParse);
                    nReplaceTrig++;
                }

                if (((pTrigger) != null) &amp;&amp; ((isUpdate) != 0))
                {
                    sqlite3VdbeAddOp1(v, (int)(166), (int)(iDataCur));
                }

                sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(regR), (short)(nPkField), (byte)(0), (byte)(5), (byte)((pIdx) == (pPk) ? 1 : 0), (int)(iThisCur));
                if (((pTrigger) != null) &amp;&amp; ((isUpdate) != 0))
                {
                    sqlite3VdbeAddOp1(v, (int)(167), (int)(iDataCur));
                }

                if ((regTrigCnt) != 0)
                {
                    int addrBypass = 0;
                    sqlite3VdbeAddOp2(v, (int)(85), (int)(regTrigCnt), (int)(1));
                    addrBypass = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
                    sqlite3VdbeResolveLabel(v, (int)(lblRecheckOk));
                    lblRecheckOk = (int)(sqlite3VdbeMakeLabel(pParse));
                    if ((pIdx.pPartIdxWhere) != null)
                    {
                        sqlite3VdbeAddOp2(v, (int)(50), (int)(regIdx - 1), (int)(lblRecheckOk));
                    }

                    while ((nConflictCk) &gt; (0))
                    {
                        VdbeOp x = new VdbeOp();
                        x = (VdbeOp)(*sqlite3VdbeGetOp(v, (int)(addrConflictCk)));
                        if (x.opcode != 141)
                        {
                            int p2 = 0;
                            sbyte* zP4;
                            if ((sqlite3OpcodeProperty[x.opcode] &amp; 0x01) != 0)
                            {
                                p2 = (int)(lblRecheckOk);
                            }
                            else
                            {
                                p2 = (int)(x.p2);
                            }

                            zP4 = (x.p4type) == (-3) ? ((void*)((long)(x.p4.i))) : x.p4.z;
                            sqlite3VdbeAddOp4(v, (int)(x.opcode), (int)(x.p1), (int)(p2), (int)(x.p3), zP4, (int)(x.p4type));
                            sqlite3VdbeChangeP5(v, (ushort)(x.p5));
                        }

                        nConflictCk--;
                        addrConflictCk++;
                    }

                    sqlite3UniqueConstraint(pParse, (int)(2), pIdx);
                    sqlite3VdbeJumpHere(v, (int)(addrBypass));
                }

                seenReplace = (int)(1);
                break;
            }
        }

        sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
        if (regR != regIdx)
            sqlite3ReleaseTempRange(pParse, (int)(regR), (int)(nPkField));
        if ((((pUpsertClause) != null) &amp;&amp; ((upsertIpkReturn) != 0)) &amp;&amp; ((sqlite3UpsertNextIsIPK(pUpsertClause)) != 0))
        {
            sqlite3VdbeGoto(v, (int)(upsertIpkDelay + 1));
            sqlite3VdbeJumpHere(v, (int)(upsertIpkReturn));
            upsertIpkReturn = (int)(0);
        }
    }

    if ((ipkTop) != 0)
    {
        sqlite3VdbeGoto(v, (int)(ipkTop));
        sqlite3VdbeJumpHere(v, (int)(ipkBottom));
    }

    if ((nReplaceTrig) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(20), (int)(regTrigCnt), (int)(lblRecheckOk));
        if (pPk == null)
        {
            if ((isUpdate) != 0)
            {
                sqlite3VdbeAddOp3(v, (int)(53), (int)(regNewData), (int)(addrRecheck), (int)(regOldData));
                sqlite3VdbeChangeP5(v, (ushort)(0x90));
            }

            sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(addrRecheck), (int)(regNewData));
            sqlite3RowidConstraint(pParse, (int)(2), pTab);
        }
        else
        {
            sqlite3VdbeGoto(v, (int)(addrRecheck));
        }

        sqlite3VdbeResolveLabel(v, (int)(lblRecheckOk));
    }

    if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
    {
        int regRec = (int)(aRegIdx[ix]);
        sqlite3VdbeAddOp3(v, (int)(96), (int)(regNewData + 1), (int)(pTab.nNVCol), (int)(regRec));
        if (bAffinityDone == 0)
        {
            sqlite3TableAffinity(v, pTab, (int)(0));
        }
    }

    *pbMayReplace = (int)(seenReplace);
}</function>
  <function>public static int sqlite3GenerateIndexKey(Parse pParse, Index pIdx, int iDataCur, int regOut, int prefixOnly, int* piPartIdxLabel, Index pPrior, int regPrior)
{
    Vdbe v = pParse.pVdbe;
    int j = 0;
    int regBase = 0;
    int nCol = 0;
    if ((piPartIdxLabel) != null)
    {
        if ((pIdx.pPartIdxWhere) != null)
        {
            *piPartIdxLabel = (int)(sqlite3VdbeMakeLabel(pParse));
            pParse.iSelfTab = (int)(iDataCur + 1);
            sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, (int)(*piPartIdxLabel), (int)(0x10));
            pParse.iSelfTab = (int)(0);
            pPrior = null;
        }
        else
        {
            *piPartIdxLabel = (int)(0);
        }
    }

    nCol = (int)((((prefixOnly) != 0) &amp;&amp; ((pIdx.uniqNotNull) != 0)) ? pIdx.nKeyCol : pIdx.nColumn);
    regBase = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
    if (((pPrior) != null) &amp;&amp; ((regBase != regPrior) || ((pPrior.pPartIdxWhere) != null)))
        pPrior = null;
    for (j = (int)(0); (j) &lt; (nCol); j++)
    {
        if ((((pPrior) != null) &amp;&amp; ((pPrior.aiColumn[j]) == (pIdx.aiColumn[j]))) &amp;&amp; (pPrior.aiColumn[j] != (-2)))
        {
            continue;
        }

        sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, (int)(iDataCur), (int)(j), (int)(regBase + j));
        if ((pIdx.aiColumn[j]) &gt;= (0))
        {
            sqlite3VdbeDeletePriorOpcode(v, (byte)(86));
        }
    }

    if ((regOut) != 0)
    {
        sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase), (int)(nCol), (int)(regOut));
    }

    sqlite3ReleaseTempRange(pParse, (int)(regBase), (int)(nCol));
    return (int)(regBase);
}</function>
  <function>public static void sqlite3GenerateRowDelete(Parse pParse, Table pTab, Trigger pTrigger, int iDataCur, int iIdxCur, int iPk, short nPk, byte count, byte onconf, byte eMode, int iIdxNoSeek)
{
    Vdbe v = pParse.pVdbe;
    int iOld = (int)(0);
    int iLabel = 0;
    byte opSeek = 0;
    iLabel = (int)(sqlite3VdbeMakeLabel(pParse));
    opSeek = (byte)((((pTab).tabFlags &amp; 0x00000080) == (0)) ? 33 : 30);
    if ((eMode) == (0))
    {
        sqlite3VdbeAddOp4Int(v, (int)(opSeek), (int)(iDataCur), (int)(iLabel), (int)(iPk), (int)(nPk));
    }

    if (((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) || ((pTrigger) != null))
    {
        uint mask = 0;
        int iCol = 0;
        int addrStart = 0;
        mask = (uint)(sqlite3TriggerColmask(pParse, pTrigger, null, (int)(0), (int)(1 | 2), pTab, (int)(onconf)));
        mask |= (uint)(sqlite3FkOldmask(pParse, pTab));
        iOld = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(1 + pTab.nCol);
        sqlite3VdbeAddOp2(v, (int)(79), (int)(iPk), (int)(iOld));
        for (iCol = (int)(0); (iCol) &lt; (pTab.nCol); iCol++)
        {
            if (((mask) == (0xffffffff)) || (((iCol) &lt;= (31)) &amp;&amp; ((mask &amp; (((uint)(1)) &lt;&lt; (iCol))) != 0)))
            {
                int kk = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)));
                sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(iCol), (int)(iOld + kk + 1));
            }
        }

        addrStart = (int)(sqlite3VdbeCurrentAddr(v));
        sqlite3CodeRowTrigger(pParse, pTrigger, (int)(128), null, (int)(1), pTab, (int)(iOld), (int)(onconf), (int)(iLabel));
        if ((addrStart) &lt; (sqlite3VdbeCurrentAddr(v)))
        {
            sqlite3VdbeAddOp4Int(v, (int)(opSeek), (int)(iDataCur), (int)(iLabel), (int)(iPk), (int)(nPk));
            iIdxNoSeek = (int)(-1);
        }

        sqlite3FkCheck(pParse, pTab, (int)(iOld), (int)(0), null, (int)(0));
    }

    if (!(((pTab).eTabType) == (2)))
    {
        byte p5 = (byte)(0);
        sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), null, (int)(iIdxNoSeek));
        sqlite3VdbeAddOp2(v, (int)(129), (int)(iDataCur), (int)((count) != 0 ? 0x01 : 0));
        if (((pParse.nested) == (0)) || ((0) == (sqlite3_stricmp(pTab.zName, "sqlite_stat1"))))
        {
            sqlite3VdbeAppendP4(v, (sbyte*)(pTab), (int)(-6));
        }

        if (eMode != 0)
        {
            sqlite3VdbeChangeP5(v, (ushort)(0x04));
        }

        if (((iIdxNoSeek) &gt;= (0)) &amp;&amp; (iIdxNoSeek != iDataCur))
        {
            sqlite3VdbeAddOp1(v, (int)(129), (int)(iIdxNoSeek));
        }

        if ((eMode) == (2))
            p5 |= (byte)(0x02);
        sqlite3VdbeChangeP5(v, (ushort)(p5));
    }

    sqlite3FkActions(pParse, pTab, null, (int)(iOld), null, (int)(0));
    sqlite3CodeRowTrigger(pParse, pTrigger, (int)(128), null, (int)(2), pTab, (int)(iOld), (int)(onconf), (int)(iLabel));
    sqlite3VdbeResolveLabel(v, (int)(iLabel));
}</function>
  <function>public static void sqlite3GenerateRowIndexDelete(Parse pParse, Table pTab, int iDataCur, int iIdxCur, int* aRegIdx, int iIdxNoSeek)
{
    int i = 0;
    int r1 = (int)(-1);
    int iPartIdxLabel = 0;
    Index pIdx;
    Index pPrior = null;
    Vdbe v;
    Index pPk;
    v = pParse.pVdbe;
    pPk = (((pTab).tabFlags &amp; 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
    for (i = (int)(0), pIdx = pTab.pIndex; pIdx; i++, pIdx = pIdx.pNext)
    {
        if ((aRegIdx != null) &amp;&amp; ((aRegIdx[i]) == (0)))
            continue;
        if ((pIdx) == (pPk))
            continue;
        if ((iIdxCur + i) == (iIdxNoSeek))
            continue;
        r1 = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(iDataCur), (int)(0), (int)(1), &amp;iPartIdxLabel, pPrior, (int)(r1)));
        sqlite3VdbeAddOp3(v, (int)(139), (int)(iIdxCur + i), (int)(r1), (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol : pIdx.nColumn));
        sqlite3VdbeChangeP5(v, (ushort)(1));
        sqlite3ResolvePartIdxLabel(pParse, (int)(iPartIdxLabel));
        pPrior = pIdx;
    }
}</function>
  <function>public static uint sqlite3Get4byte(byte* p)
{
    uint x = 0;
    CRuntime.memcpy(&amp;x, p, (ulong)(4));
    return (uint)(_byteswap_ulong((uint)(x)));
}</function>
  <function>public static byte sqlite3GetBoolean(sbyte* z, byte dflt)
{
    return (byte)(getSafetyLevel(z, (int)(1), (byte)(dflt)) != 0);
}</function>
  <function>public static CollSeq sqlite3GetCollSeq(Parse pParse, byte enc, CollSeq pColl, sbyte* zName)
{
    CollSeq p;
    sqlite3 db = pParse.db;
    p = pColl;
    if (p == null)
    {
        p = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(0));
    }

    if ((p == null) || (p.xCmp == null))
    {
        callCollNeeded(db, (int)(enc), zName);
        p = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(0));
    }

    if ((((p) != null) &amp;&amp; (p.xCmp == null)) &amp;&amp; ((synthCollSeq(db, p)) != 0))
    {
        p = null;
    }

    if ((p) == (null))
    {
        sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
        pParse.rc = (int)(1 | (1 &lt;&lt; 8));
    }

    return p;
}</function>
  <function>public static CollSeq sqlite3GetFuncCollSeq(sqlite3_context context)
{
    VdbeOp* pOp;
    pOp = &amp;context.pVdbe.aOp[context.iOp - 1];
    return pOp-&gt;p4.pColl;
}</function>
  <function>public static int sqlite3GetInt32(sbyte* zNum, int* pValue)
{
    long v = (long)(0);
    int i = 0; int  c  =  0 ; 
    int neg = (int)(0);
    if ((zNum[0]) == (45))
    {
        neg = (int)(1);
        zNum++;
    }
    else if ((zNum[0]) == (43))
    {
        zNum++;
    }
    else if ((((zNum[0]) == (48)) &amp;&amp; (((zNum[1]) == (120)) || ((zNum[1]) == (88)))) &amp;&amp; ((sqlite3CtypeMap[(byte)(zNum[2])] &amp; 0x08) != 0))
    {
        uint u = (uint)(0);
        zNum += 2;
        while ((zNum[0]) == (48))
        {
            zNum++;
        }

        for (i = (int)(0); ((sqlite3CtypeMap[(byte)(zNum[i])] &amp; 0x08) != 0) &amp;&amp; ((i) &lt; (8)); i++)
        {
            u = (uint)(u * 16 + sqlite3HexToInt((int)(zNum[i])));
        }

        if (((u &amp; 0x80000000) == (0)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zNum[i])] &amp; 0x08) == (0)))
        {
            CRuntime.memcpy(pValue, &amp;u, (ulong)(4));
            return (int)(1);
        }
        else
        {
            return (int)(0);
        }
    }

    if ((sqlite3CtypeMap[(byte)(zNum[0])] &amp; 0x04) == 0)
        return (int)(0);
    while ((zNum[0]) == (48))
    {
        zNum++;
    }

    for (i = (int)(0); (((i) &lt; (11)) &amp;&amp; ((c = (int)(zNum[i] - 48)) &gt;= (0))) &amp;&amp; ((c) &lt;= (9)); i++)
    {
        v = (long)(v * 10 + c);
    }

    if ((i) &gt; (10))
    {
        return (int)(0);
    }

    if ((v - neg) &gt; (2147483647))
    {
        return (int)(0);
    }

    if ((neg) != 0)
    {
        v = (long)(-v);
    }

    *pValue = ((int)(v));
    return (int)(1);
}</function>
  <function>public static int sqlite3GetTempRange(Parse pParse, int nReg)
{
    int i = 0; int  n  =  0 ; 
    if ((nReg) == (1))
        return (int)(sqlite3GetTempReg(pParse));
    i = (int)(pParse.iRangeReg);
    n = (int)(pParse.nRangeReg);
    if ((nReg) &lt;= (n))
    {
        pParse.iRangeReg += (int)(nReg);
        pParse.nRangeReg -= (int)(nReg);
    }
    else
    {
        i = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nReg);
    }

    return (int)(i);
}</function>
  <function>public static int sqlite3GetTempReg(Parse pParse)
{
    if ((pParse.nTempReg) == (0))
    {
        return (int)(++pParse.nMem);
    }

    return (int)(pParse.aTempReg[--pParse.nTempReg]);
}</function>
  <function>public static int sqlite3GetToken(byte* z, int* tokenType)
{
    int i = 0; int  c  =  0 ; 
    switch (aiClass[*z])
    {
        case 7:
        {
            for (i = (int)(1); (sqlite3CtypeMap[(z[i])] &amp; 0x01); i++)
            {
            }

            *tokenType = (int)(183);
            return (int)(i);
        }

        case 11:
        {
            if ((z[1]) == (45))
            {
                for (i = (int)(2); ((c = (int)(z[i])) != 0) &amp;&amp; (c != 10); i++)
                {
                }

                *tokenType = (int)(183);
                return (int)(i);
            }
            else if ((z[1]) == (62))
            {
                *tokenType = (int)(112);
                return (int)(2 + ((z[2]) == (62)));
            }

            *tokenType = (int)(107);
            return (int)(1);
        }

        case 17:
        {
            *tokenType = (int)(22);
            return (int)(1);
        }

        case 18:
        {
            *tokenType = (int)(23);
            return (int)(1);
        }

        case 19:
        {
            *tokenType = (int)(1);
            return (int)(1);
        }

        case 20:
        {
            *tokenType = (int)(106);
            return (int)(1);
        }

        case 21:
        {
            *tokenType = (int)(108);
            return (int)(1);
        }

        case 16:
        {
            if ((z[1] != 42) || ((z[2]) == (0)))
            {
                *tokenType = (int)(109);
                return (int)(1);
            }

            for (i = (int)(3), c = (int)(z[2]); ((c != 42) || (z[i] != 47)) &amp;&amp; ((c = (int)(z[i])) != 0); i++)
            {
            }

            if ((c) != 0)
                i++;
            *tokenType = (int)(183);
            return (int)(i);
        }

        case 22:
        {
            *tokenType = (int)(110);
            return (int)(1);
        }

        case 14:
        {
            *tokenType = (int)(53);
            return (int)(1 + ((z[1]) == (61)));
        }

        case 12:
        {
            if ((c = (int)(z[1])) == (61))
            {
                *tokenType = (int)(55);
                return (int)(2);
            }
            else if ((c) == (62))
            {
                *tokenType = (int)(52);
                return (int)(2);
            }
            else if ((c) == (60))
            {
                *tokenType = (int)(104);
                return (int)(2);
            }
            else
            {
                *tokenType = (int)(56);
                return (int)(1);
            }
        }

        case 13:
        {
            if ((c = (int)(z[1])) == (61))
            {
                *tokenType = (int)(57);
                return (int)(2);
            }
            else if ((c) == (62))
            {
                *tokenType = (int)(105);
                return (int)(2);
            }
            else
            {
                *tokenType = (int)(54);
                return (int)(1);
            }
        }

        case 15:
        {
            if (z[1] != 61)
            {
                *tokenType = (int)(184);
                return (int)(1);
            }
            else
            {
                *tokenType = (int)(52);
                return (int)(2);
            }
        }

        case 10:
        {
            if (z[1] != 124)
            {
                *tokenType = (int)(103);
                return (int)(1);
            }
            else
            {
                *tokenType = (int)(111);
                return (int)(2);
            }
        }

        case 23:
        {
            *tokenType = (int)(25);
            return (int)(1);
        }

        case 24:
        {
            *tokenType = (int)(102);
            return (int)(1);
        }

        case 25:
        {
            *tokenType = (int)(114);
            return (int)(1);
        }

        case 8:
        {
            int delim = (int)(z[0]);
            for (i = (int)(1); (c = (int)(z[i])) != 0; i++)
            {
                if ((c) == (delim))
                {
                    if ((z[i + 1]) == (delim))
                    {
                        i++;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            if ((c) == (39))
            {
                *tokenType = (int)(117);
                return (int)(i + 1);
            }
            else if (c != 0)
            {
                *tokenType = (int)(59);
                return (int)(i + 1);
            }
            else
            {
                *tokenType = (int)(184);
                return (int)(i);
            }
        }

        case 26:
        {
            if ((sqlite3CtypeMap[(z[1])] &amp; 0x04) == 0)
            {
                *tokenType = (int)(141);
                return (int)(1);
            }
        }

        case 3:
        {
            *tokenType = (int)(155);
            if ((((z[0]) == (48)) &amp;&amp; (((z[1]) == (120)) || ((z[1]) == (88)))) &amp;&amp; ((sqlite3CtypeMap[(z[2])] &amp; 0x08) != 0))
            {
                for (i = (int)(3); (sqlite3CtypeMap[(z[i])] &amp; 0x08); i++)
                {
                }

                return (int)(i);
            }

            for (i = (int)(0); (sqlite3CtypeMap[(z[i])] &amp; 0x04); i++)
            {
            }

            if ((z[i]) == (46))
            {
                i++;
                while ((sqlite3CtypeMap[(z[i])] &amp; 0x04) != 0)
                {
                    i++;
                }

                *tokenType = (int)(153);
            }

            if ((((z[i]) == (101)) || ((z[i]) == (69))) &amp;&amp; (((sqlite3CtypeMap[(z[i + 1])] &amp; 0x04) != 0) || ((((z[i + 1]) == (43)) || ((z[i + 1]) == (45))) &amp;&amp; ((sqlite3CtypeMap[(z[i + 2])] &amp; 0x04) != 0))))
            {
                i += (int)(2);
                while ((sqlite3CtypeMap[(z[i])] &amp; 0x04) != 0)
                {
                    i++;
                }

                *tokenType = (int)(153);
            }

            while (((sqlite3CtypeMap[z[i]] &amp; 0x46) != 0))
            {
                *tokenType = (int)(184);
                i++;
            }

            return (int)(i);
        }

        case 9:
        {
            for (i = (int)(1), c = (int)(z[0]); (c != 93) &amp;&amp; ((c = (int)(z[i])) != 0); i++)
            {
            }

            *tokenType = (int)((c) == (93) ? 59 : 184);
            return (int)(i);
        }

        case 6:
        {
            *tokenType = (int)(156);
            for (i = (int)(1); (sqlite3CtypeMap[(z[i])] &amp; 0x04); i++)
            {
            }

            return (int)(i);
        }

        case 4:
        case 5:
        {
            int n = (int)(0);
            *tokenType = (int)(156);
            for (i = (int)(1); (c = (int)(z[i])) != 0; i++)
            {
                if (((sqlite3CtypeMap[(byte)(c)] &amp; 0x46) != 0))
                {
                    n++;
                }
                else if (((c) == (40)) &amp;&amp; ((n) &gt; (0)))
                {
                    do
                    {
                        i++;
                    }
                    while ((((c = (int)(z[i])) != 0) &amp;&amp; ((sqlite3CtypeMap[(byte)(c)] &amp; 0x01) == 0)) &amp;&amp; (c != 41));
                    if ((c) == (41))
                    {
                        i++;
                    }
                    else
                    {
                        *tokenType = (int)(184);
                    }

                    break;
                }
                else if (((c) == (58)) &amp;&amp; ((z[i + 1]) == (58)))
                {
                    i++;
                }
                else
                {
                    break;
                }
            }

            if ((n) == (0))
                *tokenType = (int)(184);
            return (int)(i);
        }

        case 1:
        {
            for (i = (int)(1); (aiClass[z[i]]) &lt;= (2); i++)
            {
            }

            if (((sqlite3CtypeMap[z[i]] &amp; 0x46) != 0))
            {
                i++;
                break;
            }

            *tokenType = (int)(59);
            return (int)(keywordCode((sbyte*)(z), (int)(i), tokenType));
        }

        case 0:
        {
            if ((z[1]) == (39))
            {
                *tokenType = (int)(154);
                for (i = (int)(2); (sqlite3CtypeMap[(z[i])] &amp; 0x08); i++)
                {
                }

                if ((z[i] != 39) || (i % 2))
                {
                    *tokenType = (int)(184);
                    while (((z[i]) != 0) &amp;&amp; (z[i] != 39))
                    {
                        i++;
                    }
                }

                if ((z[i]) != 0)
                    i++;
                return (int)(i);
            }
        }

        case 2:
        case 27:
        {
            i = (int)(1);
            break;
        }

        case 30:
        {
            if (((z[1]) == (0xbb)) &amp;&amp; ((z[2]) == (0xbf)))
            {
                *tokenType = (int)(183);
                return (int)(3);
            }

            i = (int)(1);
            break;
        }

        case 29:
        {
            *tokenType = (int)(184);
            return (int)(0);
        }

        default:
        {
            *tokenType = (int)(184);
            return (int)(1);
        }
    }

    while (((sqlite3CtypeMap[z[i]] &amp; 0x46) != 0))
    {
        i++;
    }

    *tokenType = (int)(59);
    return (int)(i);
}</function>
  <function>public static int sqlite3GetUInt32(sbyte* z, uint* pI)
{
    ulong v = (ulong)(0);
    int i = 0;
    for (i = (int)(0); (sqlite3CtypeMap[(byte)(z[i])] &amp; 0x04); i++)
    {
        v = (ulong)(v * 10 + z[i] - 48);
        if ((v) &gt; (4294967296L L ) ) { * pI  =  ( uint ) ( 0 ) ;  return  ( int ) ( 0 ) ;  } }

    if (((i) == (0)) || (z[i] != 0))
    {
        *pI = (uint)(0);
        return (int)(0);
    }

    *pI = ((uint)(v));
    return (int)(1);
}</function>
  <function>public static byte sqlite3GetVarint(byte* p, ulong* v)
{
    uint a = 0; uint  b  =  0 ;  uint  s  =  0 ; 
    if ((((sbyte*)(p))[0]) &gt;= (0))
    {
        *v = (ulong)(*p);
        return (byte)(1);
    }

    if ((((sbyte*)(p))[1]) &gt;= (0))
    {
        *v = (ulong)(((uint)(p[0] &amp; 0x7f) &lt;&lt; 7) | p[1]);
        return (byte)(2);
    }

    a = (uint)(((uint)(p[0])) &lt;&lt; 14);
    b = (uint)(p[1]);
    p += 2;
    a |= (uint)(*p);
    if ((a &amp; 0x80) == 0)
    {
        a &amp;= (uint)(0x001fc07f);
        b &amp;= (uint)(0x7f);
        b = (uint)(b &lt;&lt; 7);
        a |= (uint)(b);
        *v = (ulong)(a);
        return (byte)(3);
    }

    a &amp;= (uint)(0x001fc07f);
    p++;
    b = (uint)(b &lt;&lt; 14);
    b |= (uint)(*p);
    if ((b &amp; 0x80) == 0)
    {
        b &amp;= (uint)(0x001fc07f);
        a = (uint)(a &lt;&lt; 7);
        a |= (uint)(b);
        *v = (ulong)(a);
        return (byte)(4);
    }

    b &amp;= (uint)(0x001fc07f);
    s = (uint)(a);
    p++;
    a = (uint)(a &lt;&lt; 14);
    a |= (uint)(*p);
    if ((a &amp; 0x80) == 0)
    {
        b = (uint)(b &lt;&lt; 7);
        a |= (uint)(b);
        s = (uint)(s &gt;&gt; 18);
        *v = (ulong)(((ulong)(s)) &lt;&lt; 32 | a);
        return (byte)(5);
    }

    s = (uint)(s &lt;&lt; 7);
    s |= (uint)(b);
    p++;
    b = (uint)(b &lt;&lt; 14);
    b |= (uint)(*p);
    if ((b &amp; 0x80) == 0)
    {
        a &amp;= (uint)(0x001fc07f);
        a = (uint)(a &lt;&lt; 7);
        a |= (uint)(b);
        s = (uint)(s &gt;&gt; 18);
        *v = (ulong)(((ulong)(s)) &lt;&lt; 32 | a);
        return (byte)(6);
    }

    p++;
    a = (uint)(a &lt;&lt; 14);
    a |= (uint)(*p);
    if ((a &amp; 0x80) == 0)
    {
        a &amp;= (uint)(0xf01fc07f);
        b &amp;= (uint)(0x001fc07f);
        b = (uint)(b &lt;&lt; 7);
        a |= (uint)(b);
        s = (uint)(s &gt;&gt; 11);
        *v = (ulong)(((ulong)(s)) &lt;&lt; 32 | a);
        return (byte)(7);
    }

    a &amp;= (uint)(0x001fc07f);
    p++;
    b = (uint)(b &lt;&lt; 14);
    b |= (uint)(*p);
    if ((b &amp; 0x80) == 0)
    {
        b &amp;= (uint)(0xf01fc07f);
        a = (uint)(a &lt;&lt; 7);
        a |= (uint)(b);
        s = (uint)(s &gt;&gt; 4);
        *v = (ulong)(((ulong)(s)) &lt;&lt; 32 | a);
        return (byte)(8);
    }

    p++;
    a = (uint)(a &lt;&lt; 15);
    a |= (uint)(*p);
    b &amp;= (uint)(0x001fc07f);
    b = (uint)(b &lt;&lt; 8);
    a |= (uint)(b);
    s = (uint)(s &lt;&lt; 4);
    b = (uint)(p[-4]);
    b &amp;= (uint)(0x7f);
    b = (uint)(b &gt;&gt; 3);
    s |= (uint)(b);
    *v = (ulong)(((ulong)(s)) &lt;&lt; 32 | a);
    return (byte)(9);
}</function>
  <function>public static byte sqlite3GetVarint32(byte* p, uint* v)
{
    uint a = 0; uint  b  =  0 ; 
    a = (uint)(*p);
    p++;
    b = (uint)(*p);
    if ((b &amp; 0x80) == 0)
    {
        a &amp;= (uint)(0x7f);
        a = (uint)(a &lt;&lt; 7);
        *v = (uint)(a | b);
        return (byte)(2);
    }

    p++;
    a = (uint)(a &lt;&lt; 14);
    a |= (uint)(*p);
    if ((a &amp; 0x80) == 0)
    {
        a &amp;= (uint)((0x7f &lt;&lt; 14) | (0x7f));
        b &amp;= (uint)(0x7f);
        b = (uint)(b &lt;&lt; 7);
        *v = (uint)(a | b);
        return (byte)(3);
    }

    {
        ulong v64 = 0;
        byte n = 0;
        n = (byte)(sqlite3GetVarint(p - 2, &amp;v64));
        if ((v64 &amp; ((((ulong)(1)) &lt;&lt; 32) - 1)) != v64)
        {
            *v = (uint)(0xffffffff);
        }
        else
        {
            *v = ((uint)(v64));
        }

        return (byte)(n);
    }
}</function>
  <function>public static Vdbe sqlite3GetVdbe(Parse pParse)
{
    if ((pParse.pVdbe) != null)
    {
        return pParse.pVdbe;
    }

    if (((pParse.pToplevel) == (null)) &amp;&amp; (((pParse.db).dbOptFlags &amp; (0x00000008)) == (0)))
    {
        pParse.okConstFactor = (byte)(1);
    }

    return sqlite3VdbeCreate(pParse);
}</function>
  <function>public static VTable sqlite3GetVTable(sqlite3 db, Table pTab)
{
    VTable pVtab;
    for (pVtab = pTab.u.vtab.p; ((pVtab) != null) &amp;&amp; (pVtab.db != db); pVtab = pVtab.pNext)
    {
    }

    return pVtab;
}</function>
  <function>public static void sqlite3HaltConstraint(Parse pParse, int errCode, int onError, sbyte* p4, sbyte p4type, byte p5Errmsg)
{
    Vdbe v;
    v = sqlite3GetVdbe(pParse);
    if ((onError) == (2))
    {
        sqlite3MayAbort(pParse);
    }

    sqlite3VdbeAddOp4(v, (int)(70), (int)(errCode), (int)(onError), (int)(0), p4, (int)(p4type));
    sqlite3VdbeChangeP5(v, (ushort)(p5Errmsg));
}</function>
  <function>public static int sqlite3HasExplicitNulls(Parse pParse, ExprList pList)
{
    if ((pList) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
        {
            if ((pList.a[i].bNulls) != 0)
            {
                byte sf = (byte)(pList.a[i].sortFlags);
                sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s", (((sf) == (0)) || ((sf) == (3))) ? "FIRST" : "LAST");
                return (int)(1);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3HashClear(Hash* pH)
{
    HashElem* elem;
    elem = pH-&gt;first;
    pH-&gt;first = null;
    sqlite3_free(pH-&gt;ht);
    pH-&gt;ht = null;
    pH-&gt;htsize = (uint)(0);
    while ((elem) != null)
    {
        HashElem* next_elem = elem-&gt;next;
        sqlite3_free(elem);
        elem = next_elem;
    }

    pH-&gt;count = (uint)(0);
}</function>
  <function>public static void* sqlite3HashFind(Hash* pH, sbyte* pKey)
{
    return findElementWithHash(pH, pKey, null)-&gt;data;
}</function>
  <function>public static void sqlite3HashInit(Hash* pNew)
{
    pNew-&gt;first = null;
    pNew-&gt;count = (uint)(0);
    pNew-&gt;htsize = (uint)(0);
    pNew-&gt;ht = null;
}</function>
  <function>public static void* sqlite3HashInsert(Hash* pH, sbyte* pKey, void* data)
{
    uint h = 0;
    HashElem* elem;
    HashElem* new_elem;
    elem = findElementWithHash(pH, pKey, &amp;h);
    if ((elem-&gt;data) != null)
    {
        void* old_data = elem-&gt;data;
        if ((data) == (null))
        {
            removeElementGivenHash(pH, elem, (uint)(h));
        }
        else
        {
            elem-&gt;data = data;
            elem-&gt;pKey = pKey;
        }

        return old_data;
    }

    if ((data) == (null))
        return null;
    new_elem = (HashElem*)(sqlite3Malloc((ulong)(sizeof(HashElem))));
    if ((new_elem) == (null))
        return data;
    new_elem-&gt;pKey = pKey;
    new_elem-&gt;data = data;
    pH-&gt;count++;
    if (((pH-&gt;count) &gt;= (10)) &amp;&amp; ((pH-&gt;count) &gt; (2 * pH-&gt;htsize)))
    {
        if ((rehash(pH, (uint)(pH-&gt;count * 2))) != 0)
        {
            h = (uint)(strHash(pKey) % pH-&gt;htsize);
        }
    }

    insertElement(pH, pH-&gt;ht ? &amp;pH-&gt;ht[h] : null, new_elem);
    return null;
}</function>
  <function>public static int sqlite3HeaderSizeBtree()
{
    return (int)(((sizeof(MemPage)) + 7) &amp; ~7);
}</function>
  <function>public static int sqlite3HeaderSizePcache()
{
    return (int)(((sizeof(PgHdr)) + 7) &amp; ~7);
}</function>
  <function>public static int sqlite3HeaderSizePcache1()
{
    return (int)(((sizeof(PgHdr1)) + 7) &amp; ~7);
}</function>
  <function>public static int sqlite3HeapNearlyFull()
{
    return (int)(0);
}</function>
  <function>public static void* sqlite3HexToBlob(sqlite3 db, sbyte* z, int n)
{
    sbyte* zBlob;
    int i = 0;
    zBlob = (sbyte*)(sqlite3DbMallocRawNN(db, (ulong)(n / 2 + 1)));
    n--;
    if ((zBlob) != null)
    {
        for (i = (int)(0); (i) &lt; (n); i += (int)(2))
        {
            zBlob[i / 2] = (sbyte)((sqlite3HexToInt((int)(z[i])) &lt;&lt; 4) | sqlite3HexToInt((int)(z[i + 1])));
        }

        zBlob[i / 2] = (sbyte)(0);
    }

    return zBlob;
}</function>
  <function>public static byte sqlite3HexToInt(int h)
{
    h += (int)(9 * (1 &amp; (h &gt;&gt; 6)));
    return (byte)(h &amp; 0xf);
}</function>
  <function>public static IdList* sqlite3IdListAppend(Parse pParse, IdList* pList, Token* pToken)
{
    sqlite3 db = pParse.db;
    int i = 0;
    if ((pList) == (null))
    {
        pList = sqlite3DbMallocZero(db, (ulong)(sizeof(IdList)));
        if ((pList) == (null))
            return null;
    }

    pList-&gt;a = sqlite3ArrayAllocate(db, pList-&gt;a, (int)(sizeof(IdList_item)), &amp;pList-&gt;nId, &amp;i);
    if ((i) &lt; (0))
    {
        sqlite3IdListDelete(db, pList);
        return null;
    }

    pList-&gt;a[i].zName = sqlite3NameFromToken(db, pToken);
    if (((pParse.eParseMode) &gt;= (2)) &amp;&amp; ((pList-&gt;a[i].zName) != null))
    {
        sqlite3RenameTokenMap(pParse, (void*)(pList-&gt;a[i].zName), pToken);
    }

    return pList;
}</function>
  <function>public static void sqlite3IdListDelete(sqlite3 db, IdList* pList)
{
    int i = 0;
    if ((pList) == (null))
        return;
    for (i = (int)(0); (i) &lt; (pList-&gt;nId); i++)
    {
        sqlite3DbFree(db, pList-&gt;a[i].zName);
    }

    sqlite3DbFree(db, pList-&gt;a);
    sqlite3DbFreeNN(db, pList);
}</function>
  <function>public static IdList* sqlite3IdListDup(sqlite3 db, IdList* p)
{
    IdList* pNew;
    int i = 0;
    if ((p) == (null))
        return null;
    pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(IdList)));
    if ((pNew) == (null))
        return null;
    pNew-&gt;nId = (int)(p-&gt;nId);
    pNew-&gt;a = sqlite3DbMallocRawNN(db, (ulong)(p-&gt;nId * sizeof(IdList_item)));
    if ((pNew-&gt;a) == (null))
    {
        sqlite3DbFreeNN(db, pNew);
        return null;
    }

    for (i = (int)(0); (i) &lt; (p-&gt;nId); i++)
    {
        IdList_item* pNewItem = &amp;pNew-&gt;a[i];
        IdList_item* pOldItem = &amp;p-&gt;a[i];
        pNewItem-&gt;zName = sqlite3DbStrDup(db, pOldItem-&gt;zName);
        pNewItem-&gt;idx = (int)(pOldItem-&gt;idx);
    }

    return pNew;
}</function>
  <function>public static int sqlite3IdListIndex(IdList* pList, sbyte* zName)
{
    int i = 0;
    if ((pList) == (null))
        return (int)(-1);
    for (i = (int)(0); (i) &lt; (pList-&gt;nId); i++)
    {
        if ((sqlite3StrICmp(pList-&gt;a[i].zName, zName)) == (0))
            return (int)(i);
    }

    return (int)(-1);
}</function>
  <function>public static int sqlite3IndexAffinityOk(Expr pExpr, sbyte idx_affinity)
{
    sbyte aff = (sbyte)(comparisonAffinity(pExpr));
    if ((aff) &lt; (0x42))
    {
        return (int)(1);
    }

    if ((aff) == (0x42))
    {
        return ((idx_affinity) == (0x42) ? 1 : 0);
    }

    return (((idx_affinity) &gt;= (0x43)) ? 1 : 0);
}</function>
  <function>public static sbyte* sqlite3IndexAffinityStr(sqlite3 db, Index pIdx)
{
    if (pIdx.zColAff == null)
    {
        int n = 0;
        Table pTab = pIdx.pTable;
        pIdx.zColAff = (sbyte*)(sqlite3DbMallocRaw(null, (ulong)(pIdx.nColumn + 1)));
        if (pIdx.zColAff == null)
        {
            sqlite3OomFault(db);
            return null;
        }

        for (n = (int)(0); (n) &lt; (pIdx.nColumn); n++)
        {
            short x = (short)(pIdx.aiColumn[n]);
            sbyte aff = 0;
            if ((x) &gt;= (0))
            {
                aff = (sbyte)(pTab.aCol[x].affinity);
            }
            else if ((x) == (-1))
            {
                aff = (sbyte)(0x44);
            }
            else
            {
                aff = (sbyte)(sqlite3ExprAffinity(pIdx.aColExpr.a[n].pExpr));
            }

            if ((aff) &lt; (0x41))
                aff = (sbyte)(0x41);
            if ((aff) &gt; (0x43))
                aff = (sbyte)(0x43);
            pIdx.zColAff[n] = (sbyte)(aff);
        }

        pIdx.zColAff[n] = (sbyte)(0);
    }

    return pIdx.zColAff;
}</function>
  <function>public static int sqlite3IndexedByLookup(Parse pParse, SrcItem pFrom)
{
    Table pTab = pFrom.pTab;
    sbyte* zIndexedBy = pFrom.u1.zIndexedBy;
    Index pIdx;
    for (pIdx = pTab.pIndex; ((pIdx) != null) &amp;&amp; ((sqlite3StrICmp(pIdx.zName, zIndexedBy)) != 0); pIdx = pIdx.pNext)
    {
    }

    if (pIdx == null)
    {
        sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, (int)(0));
        pParse.checkSchema = (byte)(1);
        return (int)(1);
    }

    pFrom.u2.pIBIndex = pIdx;
    return (int)(0);
}</function>
  <function>public static int sqlite3IndexHasDuplicateRootPage(Index pIndex)
{
    Index p;
    for (p = pIndex.pTable.pIndex; p; p = p.pNext)
    {
        if (((p.tnum) == (pIndex.tnum)) &amp;&amp; (p != pIndex))
            return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3Init(sqlite3 db, sbyte** pzErrMsg)
{
    int i = 0; int  rc  =  0 ; 
    int commit_internal = (int)(!(db.mDbFlags &amp; 0x0001));
    ((db).enc) = (byte)((db).aDb[0].pSchema.enc);
    if (!(((db).aDb[0].pSchema.schemaFlags &amp; (0x0001)) == (0x0001)))
    {
        rc = (int)(sqlite3InitOne(db, (int)(0), pzErrMsg, (uint)(0)));
        if ((rc) != 0)
            return (int)(rc);
    }

    for (i = (int)(db.nDb - 1); (i) &gt; (0); i--)
    {
        if (!(((db).aDb[i].pSchema.schemaFlags &amp; (0x0001)) == (0x0001)))
        {
            rc = (int)(sqlite3InitOne(db, (int)(i), pzErrMsg, (uint)(0)));
            if ((rc) != 0)
                return (int)(rc);
        }
    }

    if ((commit_internal) != 0)
    {
        sqlite3CommitInternalChanges(db);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3InitCallback(void* pInit, int argc, sbyte** argv, sbyte** NotUsed)
{
    InitData pData = (InitData)(pInit);
    sqlite3 db = pData.db;
    int iDb = (int)(pData.iDb);
    db.mDbFlags |= (uint)(0x0040);
    if ((argv) == (null))
        return (int)(0);
    pData.nInitRow++;
    if ((db.mallocFailed) != 0)
    {
        corruptSchema(pData, argv, null);
        return (int)(1);
    }

    if ((argv[3]) == (null))
    {
        corruptSchema(pData, argv, null);
    }
    else if ((((argv[4]) != null) &amp;&amp; ((99) == (sqlite3UpperToLower[(byte)(argv[4][0])]))) &amp;&amp; ((114) == (sqlite3UpperToLower[(byte)(argv[4][1])])))
    {
        int rc = 0;
        byte saved_iDb = (byte)(db.init.iDb);
        sqlite3_stmt* pStmt;
        db.init.iDb = (byte)(iDb);
        if (((sqlite3GetUInt32(argv[3], &amp;db.init.newTnum)) == (0)) || (((db.init.newTnum) &gt; (pData.mxPage)) &amp;&amp; ((pData.mxPage) &gt; (0))))
        {
            if ((sqlite3Config.bExtraSchemaChecks) != 0)
            {
                corruptSchema(pData, argv, "invalid rootpage");
            }
        }

        db.init.orphanTrigger = (uint)(0);
        db.init.azInit = argv;
        pStmt = null;
        sqlite3Prepare(db, argv[4], (int)(-1), (uint)(0), null, &amp;pStmt, null);
        rc = (int)(db.errCode);
        db.init.iDb = (byte)(saved_iDb);
        if (0 != rc)
        {
            if ((db.init.orphanTrigger) != 0)
            {
            }
            else
            {
                if ((rc) &gt; (pData.rc))
                    pData.rc = (int)(rc);
                if ((rc) == (7))
                {
                    sqlite3OomFault(db);
                }
                else if ((rc != 9) &amp;&amp; ((rc &amp; 0xFF) != 6))
                {
                    corruptSchema(pData, argv, sqlite3_errmsg(db));
                }
            }
        }

        db.init.azInit = sqlite3StdType;
        sqlite3_finalize(pStmt);
    }
    else if (((argv[1]) == (null)) || ((argv[4] != null) &amp;&amp; (argv[4][0] != 0)))
    {
        corruptSchema(pData, argv, null);
    }
    else
    {
        Index pIndex;
        pIndex = sqlite3FindIndex(db, argv[1], db.aDb[iDb].zDbSName);
        if ((pIndex) == (null))
        {
            corruptSchema(pData, argv, "orphan index");
        }
        else if (((((sqlite3GetUInt32(argv[3], &amp;pIndex.tnum)) == (0)) || ((pIndex.tnum) &lt; (2))) || ((pIndex.tnum) &gt; (pData.mxPage))) || ((sqlite3IndexHasDuplicateRootPage(pIndex)) != 0))
        {
            if ((sqlite3Config.bExtraSchemaChecks) != 0)
            {
                corruptSchema(pData, argv, "invalid rootpage");
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3InitOne(sqlite3 db, int iDb, sbyte** pzErrMsg, uint mFlags)
{
    int rc = 0;
    int i = 0;
    int size = 0;
    Db pDb;
    sbyte** azArg = stackalloc sbyte[6];
    int* meta = stackalloc int[5];
    InitData initData = new InitData();
    sbyte* zSchemaTabName;
    int openedTransaction = (int)(0);
    int mask = (int)((db.mDbFlags &amp; 0x0040) | ~0x0040);
    db.init.busy = (byte)(1);
    azArg[0] = "table";
    azArg[1] = zSchemaTabName = (((!0) != 0) &amp;&amp; ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
    azArg[2] = azArg[1];
    azArg[3] = "1";
    azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)";
    azArg[5] = null;
    initData.db = db;
    initData.iDb = (int)(iDb);
    initData.rc = (int)(0);
    initData.pzErrMsg = pzErrMsg;
    initData.mInitFlags = (uint)(mFlags);
    initData.nInitRow = (uint)(0);
    initData.mxPage = (uint)(0);
    sqlite3InitCallback(initData, (int)(5), azArg, null);
    db.mDbFlags &amp;= (uint)(mask);
    if ((initData.rc) != 0)
    {
        rc = (int)(initData.rc);
        goto error_out;
    }

    pDb = db.aDb[iDb];
    if ((pDb.pBt) == (null))
    {
        (db).aDb[1].pSchema.schemaFlags |= (ushort)(0x0001);
        rc = (int)(0);
        goto error_out;
    }

    sqlite3BtreeEnter(pDb.pBt);
    if ((sqlite3BtreeTxnState(pDb.pBt)) == (0))
    {
        rc = (int)(sqlite3BtreeBeginTrans(pDb.pBt, (int)(0), null));
        if (rc != 0)
        {
            sqlite3SetString(pzErrMsg, db, sqlite3ErrStr((int)(rc)));
            goto initone_error_out;
        }

        openedTransaction = (int)(1);
    }

    for (i = (int)(0); (i) &lt; ((int)(5 * sizeof(int) / sizeof(int))); i++)
    {
        sqlite3BtreeGetMeta(pDb.pBt, (int)(i + 1), (uint*)(&amp;meta[i]));
    }

    if ((db.flags &amp; 0x02000000) != 0)
    {
        CRuntime.memset(meta, (int)(0), (ulong)(5 * sizeof(int)));
    }

    pDb.pSchema.schema_cookie = (int)(meta[1 - 1]);
    if ((meta[5 - 1]) != 0)
    {
        if (((iDb) == (0)) &amp;&amp; ((db.mDbFlags &amp; 0x0040) == (0)))
        {
            byte encoding = 0;
            encoding = (byte)((byte)(meta[5 - 1]) &amp; 3);
            if ((encoding) == (0))
                encoding = (byte)(1);
            sqlite3SetTextEncoding(db, (byte)(encoding));
        }
        else
        {
            if ((meta[5 - 1] &amp; 3) != ((db).enc))
            {
                sqlite3SetString(pzErrMsg, db, "attached databases must use the same text encoding as main database");
                rc = (int)(1);
                goto initone_error_out;
            }
        }
    }

    pDb.pSchema.enc = (byte)((db).enc);
    if ((pDb.pSchema.cache_size) == (0))
    {
        size = (int)(sqlite3AbsInt32((int)(meta[3 - 1])));
        if ((size) == (0))
        {
            size = (int)(-2000);
        }

        pDb.pSchema.cache_size = (int)(size);
        sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
    }

    pDb.pSchema.file_format = ((byte)(meta[2 - 1]));
    if ((pDb.pSchema.file_format) == (0))
    {
        pDb.pSchema.file_format = (byte)(1);
    }

    if ((pDb.pSchema.file_format) &gt; (4))
    {
        sqlite3SetString(pzErrMsg, db, "unsupported file format");
        rc = (int)(1);
        goto initone_error_out;
    }

    if (((iDb) == (0)) &amp;&amp; ((meta[2 - 1]) &gt;= (4)))
    {
        db.flags &amp;= (ulong)(~(ulong)(0x00000002));
    }

    initData.mxPage = (uint)(sqlite3BtreeLastPage(pDb.pBt));
    {
        sbyte* zSql;
        zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\".%s ORDER BY rowid", db.aDb[iDb].zDbSName, zSchemaTabName);
        {
            delegate67 xAuth;
            xAuth = db.xAuth;
            db.xAuth = null;
            rc = (int)(sqlite3_exec(db, zSql, sqlite3InitCallback, initData, null));
            db.xAuth = xAuth;
        }

        if ((rc) == (0))
            rc = (int)(initData.rc);
        sqlite3DbFree(db, zSql);
        if ((rc) == (0))
        {
            sqlite3AnalysisLoad(db, (int)(iDb));
        }
    }

    if ((db.mallocFailed) != 0)
    {
        rc = (int)(7);
        sqlite3ResetAllSchemasOfConnection(db);
        pDb = db.aDb[iDb];
    }
    else if (((rc) == (0)) || (((db.flags &amp; 0x08000000) != 0) &amp;&amp; (rc != 7)))
    {
        (db).aDb[iDb].pSchema.schemaFlags |= (ushort)(0x0001);
        rc = (int)(0);
    }

    initone_error_out:
        ; if  ( ( openedTransaction ) != 0 ) { sqlite3BtreeCommit ( pDb . pBt ) ;  }
    sqlite3BtreeLeave(pDb.pBt);
    error_out:
        ; if  ( ( rc ) != 0 ) { if  ( ( ( rc ) == ( 7 ) ) || ( ( rc ) == ( 10 | ( 12 &lt;&lt; 8 ) ) ) ) { sqlite3OomFault ( db ) ;  } sqlite3ResetOneSchema ( db ,  ( int ) ( iDb ) ) ;  }
    db.init.busy = (byte)(0);
    return (int)(rc);
}</function>
  <function>public static int sqlite3InRhsIsConstant(Expr pIn)
{
    Expr pLHS;
    int res = 0;
    pLHS = pIn.pLeft;
    pIn.pLeft = null;
    res = (int)(sqlite3ExprIsConstant(pIn));
    pIn.pLeft = pLHS;
    return (int)(res);
}</function>
  <function>public static void sqlite3Insert(Parse pParse, SrcList pTabList, Select pSelect, IdList* pColumn, int onError, Upsert pUpsert)
{
    sqlite3 db;
    Table pTab;
    int i = 0; int  j  =  0 ; 
    Vdbe v;
    Index pIdx;
    int nColumn = 0;
    int nHidden = (int)(0);
    int iDataCur = (int)(0);
    int iIdxCur = (int)(0);
    int ipkColumn = (int)(-1);
    int endOfLoop = 0;
    int srcTab = (int)(0);
    int addrInsTop = (int)(0);
    int addrCont = (int)(0);
    SelectDest dest = new SelectDest();
    int iDb = 0;
    byte useTempTable = (byte)(0);
    byte appendFlag = (byte)(0);
    byte withoutRowid = 0;
    byte bIdListInOrder = 0;
    ExprList pList = null;
    int iRegStore = 0;
    int regFromSelect = (int)(0);
    int regAutoinc = (int)(0);
    int regRowCount = (int)(0);
    int regIns = 0;
    int regRowid = 0;
    int regData = 0;
    int* aRegIdx = null;
    int isView = 0;
    Trigger pTrigger;
    int tmask = 0;
    db = pParse.db;
    if ((pParse.nErr) != 0)
    {
        goto insert_cleanup;
    }

    dest.iSDParm = (int)(0);
    if ((((pSelect) != null) &amp;&amp; ((pSelect.selFlags &amp; 0x0000200) != 0)) &amp;&amp; ((pSelect.pPrior) == (null)))
    {
        pList = pSelect.pEList;
        pSelect.pEList = null;
        sqlite3SelectDelete(db, pSelect);
        pSelect = null;
    }

    pTab = sqlite3SrcListLookup(pParse, pTabList);
    if ((pTab) == (null))
    {
        goto insert_cleanup;
    }

    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    if ((sqlite3AuthCheck(pParse, (int)(18), pTab.zName, null, db.aDb[iDb].zDbSName)) != 0)
    {
        goto insert_cleanup;
    }

    withoutRowid = (byte)(!(((pTab).tabFlags &amp; 0x00000080) == (0)));
    pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(127), null, &amp;tmask);
    isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
    if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
    {
        goto insert_cleanup;
    }

    if ((sqlite3IsReadOnly(pParse, pTab, (int)(tmask))) != 0)
    {
        goto insert_cleanup;
    }

    v = sqlite3GetVdbe(pParse);
    if ((v) == (null))
        goto insert_cleanup;
    if ((pParse.nested) == (0))
        sqlite3VdbeCountChanges(v);
    sqlite3BeginWriteOperation(pParse, (((pSelect) != null) || ((pTrigger) != null) ? 1 : 0), (int)(iDb));
    if (((((pColumn) == (null)) &amp;&amp; (pSelect != null)) &amp;&amp; ((pTrigger) == (null))) &amp;&amp; ((xferOptimization(pParse, pTab, pSelect, (int)(onError), (int)(iDb))) != 0))
    {
        goto insert_end;
    }

    regAutoinc = (int)(autoIncBegin(pParse, (int)(iDb), pTab));
    regRowid = (int)(regIns = (int)(pParse.nMem + 1));
    pParse.nMem += (int)(pTab.nCol + 1);
    if ((((pTab).eTabType) == (1)))
    {
        regRowid++;
        pParse.nMem++;
    }

    regData = (int)(regRowid + 1);
    bIdListInOrder = (byte)((pTab.tabFlags &amp; (0x00000400 | 0x00000040)) == (0));
    if ((pColumn) != null)
    {
        for (i = (int)(0); (i) &lt; (pColumn-&gt;nId); i++)
        {
            pColumn-&gt;a[i].idx = (int)(-1);
        }

        for (i = (int)(0); (i) &lt; (pColumn-&gt;nId); i++)
        {
            for (j = (int)(0); (j) &lt; (pTab.nCol); j++)
            {
                if ((sqlite3StrICmp(pColumn-&gt;a[i].zName, pTab.aCol[j].zCnName)) == (0))
                {
                    pColumn-&gt;a[i].idx = (int)(j);
                    if (i != j)
                        bIdListInOrder = (byte)(0);
                    if ((j) == (pTab.iPKey))
                    {
                        ipkColumn = (int)(i);
                    }

                    if ((pTab.aCol[j].colFlags &amp; (0x0040 | 0x0020)) != 0)
                    {
                        sqlite3ErrorMsg(pParse, "cannot INSERT into generated column \"%s\"", pTab.aCol[j].zCnName);
                        goto insert_cleanup;
                    }

                    break;
                }
            }

            if ((j) &gt;= (pTab.nCol))
            {
                if (((sqlite3IsRowid(pColumn-&gt;a[i].zName)) != 0) &amp;&amp; (withoutRowid == 0))
                {
                    ipkColumn = (int)(i);
                    bIdListInOrder = (byte)(0);
                }
                else
                {
                    sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList.a, pColumn-&gt;a[i].zName);
                    pParse.checkSchema = (byte)(1);
                    goto insert_cleanup;
                }
            }
        }
    }

    if ((pSelect) != null)
    {
        int regYield = 0;
        int addrTop = 0;
        int rc = 0;
        regYield = (int)(++pParse.nMem);
        addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
        sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(addrTop));
        sqlite3SelectDestInit(dest, (int)(13), (int)(regYield));
        dest.iSdst = (int)((bIdListInOrder) != 0 ? regData : 0);
        dest.nSdst = (int)(pTab.nCol);
        rc = (int)(sqlite3Select(pParse, pSelect, dest));
        regFromSelect = (int)(dest.iSdst);
        if (((rc) != 0) || ((pParse.nErr) != 0))
            goto insert_cleanup;
        sqlite3VdbeEndCoroutine(v, (int)(regYield));
        sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
        nColumn = (int)(pSelect.pEList.nExpr);
        if (((pTrigger) != null) || ((readsTable(pParse, (int)(iDb), pTab)) != 0))
        {
            useTempTable = (byte)(1);
        }

        if ((useTempTable) != 0)
        {
            int regRec = 0;
            int regTempRowid = 0;
            int addrL = 0;
            srcTab = (int)(pParse.nTab++);
            regRec = (int)(sqlite3GetTempReg(pParse));
            regTempRowid = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp2(v, (int)(116), (int)(srcTab), (int)(nColumn));
            addrL = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm)));
            sqlite3VdbeAddOp3(v, (int)(96), (int)(regFromSelect), (int)(nColumn), (int)(regRec));
            sqlite3VdbeAddOp2(v, (int)(126), (int)(srcTab), (int)(regTempRowid));
            sqlite3VdbeAddOp3(v, (int)(127), (int)(srcTab), (int)(regRec), (int)(regTempRowid));
            sqlite3VdbeGoto(v, (int)(addrL));
            sqlite3VdbeJumpHere(v, (int)(addrL));
            sqlite3ReleaseTempReg(pParse, (int)(regRec));
            sqlite3ReleaseTempReg(pParse, (int)(regTempRowid));
        }
    }
    else
    {
        NameContext sNC = new NameContext();
        CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
        sNC.pParse = pParse;
        srcTab = (int)(-1);
        if ((pList) != null)
        {
            nColumn = (int)(pList.nExpr);
            if ((sqlite3ResolveExprListNames(sNC, pList)) != 0)
            {
                goto insert_cleanup;
            }
        }
        else
        {
            nColumn = (int)(0);
        }
    }

    if (((pColumn) == (null)) &amp;&amp; ((nColumn) &gt; (0)))
    {
        ipkColumn = (int)(pTab.iPKey);
        if (((ipkColumn) &gt;= (0)) &amp;&amp; ((pTab.tabFlags &amp; 0x00000060) != 0))
        {
            for (i = (int)(ipkColumn - 1); (i) &gt;= (0); i--)
            {
                if ((pTab.aCol[i].colFlags &amp; 0x0060) != 0)
                {
                    ipkColumn--;
                }
            }
        }

        if ((pTab.tabFlags &amp; (0x00000060 | 0x00000002)) != 0)
        {
            for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
            {
                if ((pTab.aCol[i].colFlags &amp; 0x0062) != 0)
                    nHidden++;
            }
        }

        if (nColumn != (pTab.nCol - nHidden))
        {
            sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied", pTabList.a, (int)(pTab.nCol - nHidden), (int)(nColumn));
            goto insert_cleanup;
        }
    }

    if ((pColumn != null) &amp;&amp; (nColumn != pColumn-&gt;nId))
    {
        sqlite3ErrorMsg(pParse, "%d values for %d columns", (int)(nColumn), (int)(pColumn-&gt;nId));
        goto insert_cleanup;
    }

    if (((((db.flags &amp; ((ulong)(0x00001) &lt;&lt; 32)) != 0) &amp;&amp; (pParse.nested == 0)) &amp;&amp; (pParse.pTriggerTab == null)) &amp;&amp; (pParse.bReturning == 0))
    {
        regRowCount = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regRowCount));
    }

    if (isView == 0)
    {
        int nIdx = 0;
        nIdx = (int)(sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0), (int)(-1), null, &amp;iDataCur, &amp;iIdxCur));
        aRegIdx = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (nIdx + 2)));
        if ((aRegIdx) == (null))
        {
            goto insert_cleanup;
        }

        for (i = (int)(0), pIdx = pTab.pIndex; (i) &lt; (nIdx); pIdx = pIdx.pNext, i++)
        {
            aRegIdx[i] = (int)(++pParse.nMem);
            pParse.nMem += (int)(pIdx.nColumn);
        }

        aRegIdx[i] = (int)(++pParse.nMem);
    }

    if ((pUpsert) != null)
    {
        Upsert pNx;
        if ((((pTab).eTabType) == (1)))
        {
            sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"", pTab.zName);
            goto insert_cleanup;
        }

        if ((((pTab).eTabType) == (2)))
        {
            sqlite3ErrorMsg(pParse, "cannot UPSERT a view");
            goto insert_cleanup;
        }

        if ((sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget)) != 0)
        {
            goto insert_cleanup;
        }

        pTabList.a[0].iCursor = (int)(iDataCur);
        pNx = pUpsert;
        do
        {
            pNx.pUpsertSrc = pTabList;
            pNx.regData = (int)(regData);
            pNx.iDataCur = (int)(iDataCur);
            pNx.iIdxCur = (int)(iIdxCur);
            if ((pNx.pUpsertTarget) != null)
            {
                if ((sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx)) != 0)
                {
                    goto insert_cleanup;
                }
            }

            pNx = pNx.pNextUpsert;
        }
        while (pNx != null);
    }

    if ((useTempTable) != 0)
    {
        addrInsTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(srcTab)));
        addrCont = (int)(sqlite3VdbeCurrentAddr(v));
    }
    else if ((pSelect) != null)
    {
        addrInsTop = (int)(addrCont = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm))));
        if ((ipkColumn) &gt;= (0))
        {
            sqlite3VdbeAddOp2(v, (int)(79), (int)(regFromSelect + ipkColumn), (int)(regRowid));
        }
    }

    nHidden = (int)(0);
    iRegStore = (int)(regData);
    for (i = (int)(0); (i) &lt; (pTab.nCol); i++, iRegStore++)
    {
        int k = 0;
        uint colFlags = 0;
        if ((i) == (pTab.iPKey))
        {
            sqlite3VdbeAddOp1(v, (int)(75), (int)(iRegStore));
            continue;
        }

        if (((colFlags = (uint)(pTab.aCol[i].colFlags)) &amp; 0x0062) != 0)
        {
            nHidden++;
            if ((colFlags &amp; 0x0020) != 0)
            {
                iRegStore--;
                continue;
            }
            else if ((colFlags &amp; 0x0040) != 0)
            {
                if ((tmask &amp; 1) != 0)
                {
                    sqlite3VdbeAddOp1(v, (int)(75), (int)(iRegStore));
                }

                continue;
            }
            else if ((pColumn) == (null))
            {
                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &amp;pTab.aCol[i]), (int)(iRegStore));
                continue;
            }
        }

        if ((pColumn) != null)
        {
            for (j = (int)(0); ((j) &lt; (pColumn-&gt;nId)) &amp;&amp; (pColumn-&gt;a[j].idx != i); j++)
            {
            }

            if ((j) &gt;= (pColumn-&gt;nId))
            {
                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &amp;pTab.aCol[i]), (int)(iRegStore));
                continue;
            }

            k = (int)(j);
        }
        else if ((nColumn) == (0))
        {
            sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &amp;pTab.aCol[i]), (int)(iRegStore));
            continue;
        }
        else
        {
            k = (int)(i - nHidden);
        }

        if ((useTempTable) != 0)
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(k), (int)(iRegStore));
        }
        else if ((pSelect) != null)
        {
            if (regFromSelect != regData)
            {
                sqlite3VdbeAddOp2(v, (int)(80), (int)(regFromSelect + k), (int)(iRegStore));
            }
        }
        else
        {
            sqlite3ExprCode(pParse, pList.a[k].pExpr, (int)(iRegStore));
        }
    }

    endOfLoop = (int)(sqlite3VdbeMakeLabel(pParse));
    if ((tmask &amp; 1) != 0)
    {
        int regCols = (int)(sqlite3GetTempRange(pParse, (int)(pTab.nCol + 1)));
        if ((ipkColumn) &lt; (0))
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(-1), (int)(regCols));
        }
        else
        {
            int addr1 = 0;
            if ((useTempTable) != 0)
            {
                sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(ipkColumn), (int)(regCols));
            }
            else
            {
                sqlite3ExprCode(pParse, pList.a[ipkColumn].pExpr, (int)(regCols));
            }

            addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(regCols)));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(-1), (int)(regCols));
            sqlite3VdbeJumpHere(v, (int)(addr1));
            sqlite3VdbeAddOp1(v, (int)(15), (int)(regCols));
        }

        sqlite3VdbeAddOp3(v, (int)(79), (int)(regRowid + 1), (int)(regCols + 1), (int)(pTab.nNVCol - 1));
        if ((pTab.tabFlags &amp; 0x00000060) != 0)
        {
            sqlite3ComputeGeneratedColumns(pParse, (int)(regCols + 1), pTab);
        }

        if (isView == 0)
        {
            sqlite3TableAffinity(v, pTab, (int)(regCols + 1));
        }

        sqlite3CodeRowTrigger(pParse, pTrigger, (int)(127), null, (int)(1), pTab, (int)(regCols - pTab.nCol - 1), (int)(onError), (int)(endOfLoop));
        sqlite3ReleaseTempRange(pParse, (int)(regCols), (int)(pTab.nCol + 1));
    }

    if (isView == 0)
    {
        if ((((pTab).eTabType) == (1)))
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regIns));
        }

        if ((ipkColumn) &gt;= (0))
        {
            if ((useTempTable) != 0)
            {
                sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(ipkColumn), (int)(regRowid));
            }
            else if ((pSelect) != null)
            {
            }
            else
            {
                Expr pIpk = pList.a[ipkColumn].pExpr;
                if (((pIpk.op) == (121)) &amp;&amp; (!(((pTab).eTabType) == (1))))
                {
                    sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
                    appendFlag = (byte)(1);
                }
                else
                {
                    sqlite3ExprCode(pParse, pList.a[ipkColumn].pExpr, (int)(regRowid));
                }
            }

            if (appendFlag == 0)
            {
                int addr1 = 0;
                if (!(((pTab).eTabType) == (1)))
                {
                    addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(regRowid)));
                    sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
                    sqlite3VdbeJumpHere(v, (int)(addr1));
                }
                else
                {
                    addr1 = (int)(sqlite3VdbeCurrentAddr(v));
                    sqlite3VdbeAddOp2(v, (int)(50), (int)(regRowid), (int)(addr1 + 2));
                }

                sqlite3VdbeAddOp1(v, (int)(15), (int)(regRowid));
            }
        }
        else if ((((pTab).eTabType) == (1)) || ((withoutRowid) != 0))
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regRowid));
        }
        else
        {
            sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
            appendFlag = (byte)(1);
        }

        autoIncStep(pParse, (int)(regAutoinc), (int)(regRowid));
        if ((pTab.tabFlags &amp; 0x00000060) != 0)
        {
            sqlite3ComputeGeneratedColumns(pParse, (int)(regRowid + 1), pTab);
        }

        if ((((pTab).eTabType) == (1)))
        {
            sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
            sqlite3VtabMakeWritable(pParse, pTab);
            sqlite3VdbeAddOp4(v, (int)(10), (int)(1), (int)(pTab.nCol + 2), (int)(regIns), pVTab, (int)(-12));
            sqlite3VdbeChangeP5(v, (ushort)((onError) == (11) ? 2 : onError));
            sqlite3MayAbort(pParse);
        }
        else
        {
            int isReplace = (int)(0);
            int bUseSeek = 0;
            sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, (int)(iDataCur), (int)(iIdxCur), (int)(regIns), (int)(0), (byte)((ipkColumn) &gt;= (0)), (byte)(onError), (int)(endOfLoop), &amp;isReplace, null, pUpsert);
            sqlite3FkCheck(pParse, pTab, (int)(0), (int)(regIns), null, (int)(0));
            bUseSeek = (int)(((isReplace) == (0)) || (sqlite3VdbeHasSubProgram(v) == 0) ? 1 : 0);
            sqlite3CompleteInsertion(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), (int)(regIns), aRegIdx, (int)(0), (int)(appendFlag), (int)(bUseSeek));
        }
    }

    if ((regRowCount) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(85), (int)(regRowCount), (int)(1));
    }

    if ((pTrigger) != null)
    {
        sqlite3CodeRowTrigger(pParse, pTrigger, (int)(127), null, (int)(2), pTab, (int)(regData - 2 - pTab.nCol), (int)(onError), (int)(endOfLoop));
    }

    sqlite3VdbeResolveLabel(v, (int)(endOfLoop));
    if ((useTempTable) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(5), (int)(srcTab), (int)(addrCont));
        sqlite3VdbeJumpHere(v, (int)(addrInsTop));
        sqlite3VdbeAddOp1(v, (int)(121), (int)(srcTab));
    }
    else if ((pSelect) != null)
    {
        sqlite3VdbeGoto(v, (int)(addrCont));
        sqlite3VdbeJumpHere(v, (int)(addrInsTop));
    }

    insert_end:
        ; if  ( ( ( pParse . nested ) == ( 0 ) ) &amp;&amp; ( ( pParse . pTriggerTab ) == ( null ) ) ) { sqlite3AutoincrementEnd ( pParse ) ;  }
    if ((regRowCount) != 0)
    {
        sqlite3CodeChangeCount(v, (int)(regRowCount), "rows inserted");
    }

    insert_cleanup:
        ; sqlite3SrcListDelete ( db ,  pTabList ) ; 
    sqlite3ExprListDelete(db, pList);
    sqlite3UpsertDelete(db, pUpsert);
    sqlite3SelectDelete(db, pSelect);
    sqlite3IdListDelete(db, pColumn);
    sqlite3DbFree(db, aRegIdx);
}</function>
  <function>public static void sqlite3InsertBuiltinFuncs(FuncDef aDef, int nDef)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (nDef); i++)
    {
        FuncDef pOther;
        sbyte* zName = aDef[i].zName;
        int nName = (int)(sqlite3Strlen30(zName));
        int h = (int)(((zName[0]) + (nName)) % 23);
        pOther = sqlite3FunctionSearch((int)(h), zName);
        if ((pOther) != null)
        {
            aDef[i].pNext = pOther.pNext;
            pOther.pNext = aDef[i];
        }
        else
        {
            aDef[i].pNext = null;
            aDef[i].u.pHash = sqlite3BuiltinFunctions.a[h];
            sqlite3BuiltinFunctions.a[h] = aDef[i];
        }
    }
}</function>
  <function>public static void sqlite3Int64ToText(long v, sbyte* zOut)
{
    int i = 0;
    ulong x = 0;
    sbyte* zTemp = stackalloc sbyte[22];
    if ((v) &lt; (0))
    {
        x = (ulong)(((v) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)))) ? ((ulong)(1)) &lt;&lt; 63 : (ulong)(-v));
    }
    else
    {
        x = (ulong)(v);
    }

    i = (int)(22 * sizeof(sbyte) - 2);
    zTemp[22 * sizeof(sbyte) - 1] = (sbyte)(0);
    do
    {
        zTemp[i--] = (sbyte)((x % 10) + 48);
        x = (ulong)(x / 10);
    }
    while ((x) != 0);
    if ((v) &lt; (0))
        zTemp[i--] = (sbyte)(45);
    CRuntime.memcpy(zOut, &amp;zTemp[i + 1], (ulong)(22 * sizeof(sbyte) - 1 - i));
}</function>
  <function>public static int sqlite3IntFloatCompare(long i, double r)
{
    if ((sizeof(LONGDOUBLE_TYPE)) &gt; (8))
    {
        double x = (double)(i);
        if ((x) &lt; (r))
            return (int)(-1);
        if ((x) &gt; (r))
            return (int)(+1);
        return (int)(0);
    }
    else
    {
        long y = 0;
        double s = 0;
        if ((r) &lt; (-9223372036854775808.0))
            return (int)(+1);
        if ((r) &gt;= (9223372036854775808.0))
            return (int)(-1);
        y = ((long)(r));
        if ((i) &lt; (y))
            return (int)(-1);
        if ((i) &gt; (y))
            return (int)(+1);
        s = ((double)(i));
        if ((s) &lt; (r))
            return (int)(-1);
        if ((s) &gt; (r))
            return (int)(+1);
        return (int)(0);
    }
}</function>
  <function>public static void sqlite3InvalidFunction(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    sbyte* zName = (sbyte*)(sqlite3_user_data(context));
    sbyte* zErr;
    zErr = sqlite3_mprintf("unable to use function %s in the requested context", zName);
    sqlite3_result_error(context, zErr, (int)(-1));
    sqlite3_free(zErr);
}</function>
  <function>public static int sqlite3InvokeBusyHandler(BusyHandler p)
{
    int rc = 0;
    if (((p.xBusyHandler) == (null)) || ((p.nBusy) &lt; (0)))
        return (int)(0);
    rc = (int)(p.xBusyHandler(p.pBusyArg, (int)(p.nBusy)));
    if ((rc) == (0))
    {
        p.nBusy = (int)(-1);
    }
    else
    {
        p.nBusy++;
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3IsBinary(CollSeq p)
{
    return (((p) == (null)) || ((p.xCmp) == (binCollFunc)) ? 1 : 0);
}</function>
  <function>public static int sqlite3IsIdChar(byte c)
{
    return (int)((sqlite3CtypeMap[c] &amp; 0x46) != 0);
}</function>
  <function>public static int sqlite3IsLikeFunction(sqlite3 db, Expr pExpr, int* pIsNocase, sbyte* aWc)
{
    FuncDef pDef;
    int nExpr = 0;
    if (pExpr.x.pList == null)
    {
        return (int)(0);
    }

    nExpr = (int)(pExpr.x.pList.nExpr);
    pDef = sqlite3FindFunction(db, pExpr.u.zToken, (int)(nExpr), (byte)(1), (byte)(0));
    if (((pDef) == (null)) || ((pDef.funcFlags &amp; 0x0004) == (0)))
    {
        return (int)(0);
    }

    CRuntime.memcpy(aWc, pDef.pUserData, (ulong)(3));
    if ((nExpr) &lt; (3))
    {
        aWc[3] = (sbyte)(0);
    }
    else
    {
        Expr pEscape = pExpr.x.pList.a[2].pExpr;
        sbyte* zEscape;
        if (pEscape.op != 117)
            return (int)(0);
        zEscape = pEscape.u.zToken;
        if (((zEscape[0]) == (0)) || (zEscape[1] != 0))
            return (int)(0);
        if ((zEscape[0]) == (aWc[0]))
            return (int)(0);
        if ((zEscape[0]) == (aWc[1]))
            return (int)(0);
        aWc[3] = (sbyte)(zEscape[0]);
    }

    *pIsNocase = (int)((pDef.funcFlags &amp; 0x0008) == (0) ? 1 : 0);
    return (int)(1);
}</function>
  <function>public static int sqlite3IsNaN(double x)
{
    int rc = 0;
    ulong y = 0;
    CRuntime.memcpy(&amp;y, &amp;x, (ulong)(sizeof(ulong)));
    rc = (int)((((y) &amp; (((ulong)(0x7ff)) &lt;&lt; 52)) == (((ulong)(0x7ff)) &lt;&lt; 52)) &amp;&amp; (((y) &amp; ((((ulong)(1)) &lt;&lt; 52) - 1)) != 0) ? 1 : 0);
    return (int)(rc);
}</function>
  <function>public static int sqlite3IsReadOnly(Parse pParse, Table pTab, int viewOk)
{
    if ((tabIsReadOnly(pParse, pTab)) != 0)
    {
        sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab.zName);
        return (int)(1);
    }

    if ((viewOk == 0) &amp;&amp; (((pTab).eTabType) == (2)))
    {
        sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", pTab.zName);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3IsRowid(sbyte* z)
{
    if ((sqlite3StrICmp(z, "_ROWID_")) == (0))
        return (int)(1);
    if ((sqlite3StrICmp(z, "ROWID")) == (0))
        return (int)(1);
    if ((sqlite3StrICmp(z, "OID")) == (0))
        return (int)(1);
    return (int)(0);
}</function>
  <function>public static int sqlite3IsShadowTableOf(sqlite3 db, Table pTab, sbyte* zName)
{
    int nName = 0;
    Module pMod;
    if (!(((pTab).eTabType) == (1)))
        return (int)(0);
    nName = (int)(sqlite3Strlen30(pTab.zName));
    if (sqlite3_strnicmp(zName, pTab.zName, (int)(nName)) != 0)
        return (int)(0);
    if (zName[nName] != 95)
        return (int)(0);
    pMod = (Module)(sqlite3HashFind(&amp;db.aModule, pTab.u.vtab.azArg[0]));
    if ((pMod) == (null))
        return (int)(0);
    if ((pMod.pModule.iVersion) &lt; (3))
        return (int)(0);
    if ((pMod.pModule.xShadowName) == (null))
        return (int)(0);
    return (int)(pMod.pModule.xShadowName(zName + nName + 1));
}</function>
  <function>public static uint sqlite3IsTrueOrFalse(sbyte* zIn)
{
    if ((sqlite3StrICmp(zIn, "true")) == (0))
        return (uint)(0x10000000);
    if ((sqlite3StrICmp(zIn, "false")) == (0))
        return (uint)(0x20000000);
    return (uint)(0);
}</function>
  <function>public static int sqlite3JoinType(Parse pParse, Token* pA, Token* pB, Token* pC)
{
    int jointype = (int)(0);
    Token** apAll = stackalloc Token[3];
    Token* p;
    int i = 0; int  j  =  0 ; 
    apAll[0] = pA;
    apAll[1] = pB;
    apAll[2] = pC;
    for (i = (int)(0); ((i) &lt; (3)) &amp;&amp; ((apAll[i]) != null); i++)
    {
        p = apAll[i];
        for (j = (int)(0); (j) &lt; ((int)(7 * sizeof(aKeywordType) / sizeof(aKeywordType))); j++)
        {
            if (((p-&gt;n) == (sqlite3JoinType_aKeyword[j].nChar)) &amp;&amp; ((sqlite3_strnicmp(p-&gt;z, &amp;sqlite3JoinType_zKeyText[sqlite3JoinType_aKeyword[j].i], (int)(p-&gt;n))) == (0)))
            {
                jointype |= (int)(sqlite3JoinType_aKeyword[j].code);
                break;
            }
        }

        if ((j) &gt;= ((int)(7 * sizeof(aKeywordType) / sizeof(aKeywordType))))
        {
            jointype |= (int)(0x0040);
            break;
        }
    }

    if (((jointype &amp; (0x0001 | 0x0020)) == (0x0001 | 0x0020)) || ((jointype &amp; 0x0040) != 0))
    {
        sbyte* zSp = " ";
        if ((pC) == (null))
        {
            zSp++;
        }

        sqlite3ErrorMsg(pParse, "unknown or unsupported join type: %T %T%s%T", pA, pB, zSp, pC);
        jointype = (int)(0x0001);
    }
    else if (((jointype &amp; 0x0020) != 0) &amp;&amp; ((jointype &amp; (0x0008 | 0x0010)) != 0x0008))
    {
        sqlite3ErrorMsg(pParse, "RIGHT and FULL OUTER JOINs are not currently supported");
        jointype = (int)(0x0001);
    }

    return (int)(jointype);
}</function>
  <function>public static int sqlite3JournalIsInMemory(sqlite3_file p)
{
    return ((p.pMethods) == (MemJournalMethods) ? 1 : 0);
}</function>
  <function>public static sbyte* sqlite3JournalModename(int eMode)
{
    if ((eMode) == ((int)(6 * sizeof(sbyte) / sizeof(sbyte*))))
        return null;
    return sqlite3JournalModename_azModeName[eMode];
}</function>
  <function>public static int sqlite3JournalOpen(sqlite3_vfs pVfs, sbyte* zName, sqlite3_file pJfd, int flags, int nSpill)
{
    MemJournal p = (MemJournal)(pJfd);
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemJournal)));
    if ((nSpill) == (0))
    {
        return (int)(sqlite3OsOpen(pVfs, zName, pJfd, (int)(flags), null));
    }

    if ((nSpill) &gt; (0))
    {
        p.nChunkSize = (int)(nSpill);
    }
    else
    {
        p.nChunkSize = (int)(8 + 1024 - sizeof(FileChunk));
    }

    pJfd.pMethods = MemJournalMethods;
    p.nSpill = (int)(nSpill);
    p.flags = (int)(flags);
    p.zJournal = zName;
    p.pVfs = pVfs;
    return (int)(0);
}</function>
  <function>public static int sqlite3JournalSize(sqlite3_vfs pVfs)
{
    return (int)((pVfs.szOsFile) &gt; ((int)(sizeof(MemJournal))) ? (pVfs.szOsFile) : ((int)(sizeof(MemJournal))));
}</function>
  <function>public static int sqlite3JsonTableFunctions(sqlite3 db)
{
    int rc = (int)(0);
    uint i = 0;
    for (i = (uint)(0); ((i) &lt; (2 * sizeof(aModType) / sizeof(aModType))) &amp;&amp; ((rc) == (0)); i++)
    {
        rc = (int)(sqlite3_create_module(db, sqlite3JsonTableFunctions_aMod[i].zName, sqlite3JsonTableFunctions_aMod[i].pModule, null));
    }

    return (int)(rc);
}</function>
  <function>public static KeyInfo sqlite3KeyInfoAlloc(sqlite3 db, int N, int X)
{
    int nExtra = (int)((N + X) * (sizeof(CollSeq) + 1) - sizeof(CollSeq));
    KeyInfo p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(KeyInfo) + nExtra));
    if ((p) != null)
    {
        p.aSortFlags = (byte*)(p.aColl[N + X]);
        p.nKeyField = ((ushort)(N));
        p.nAllField = ((ushort)(N + X));
        p.enc = (byte)((db).enc);
        p.db = db;
        p.nRef = (uint)(1);
        CRuntime.memset(p[1], (int)(0), (ulong)(nExtra));
    }
    else
    {
        return (KeyInfo)(sqlite3OomFault(db));
    }

    return p;
}</function>
  <function>public static KeyInfo sqlite3KeyInfoFromExprList(Parse pParse, ExprList pList, int iStart, int nExtra)
{
    int nExpr = 0;
    KeyInfo pInfo;
    ExprList_item* pItem;
    sqlite3 db = pParse.db;
    int i = 0;
    nExpr = (int)(pList.nExpr);
    pInfo = sqlite3KeyInfoAlloc(db, (int)(nExpr - iStart), (int)(nExtra + 1));
    if ((pInfo) != null)
    {
        for (i = (int)(iStart), pItem = pList.a + iStart; (i) &lt; (nExpr); i++, pItem++)
        {
            pInfo.aColl[i - iStart] = sqlite3ExprNNCollSeq(pParse, pItem-&gt;pExpr);
            pInfo.aSortFlags[i - iStart] = (byte)(pItem-&gt;sortFlags);
        }
    }

    return pInfo;
}</function>
  <function>public static KeyInfo sqlite3KeyInfoOfIndex(Parse pParse, Index pIdx)
{
    int i = 0;
    int nCol = (int)(pIdx.nColumn);
    int nKey = (int)(pIdx.nKeyCol);
    KeyInfo pKey;
    if ((pParse.nErr) != 0)
        return null;
    if ((pIdx.uniqNotNull) != 0)
    {
        pKey = sqlite3KeyInfoAlloc(pParse.db, (int)(nKey), (int)(nCol - nKey));
    }
    else
    {
        pKey = sqlite3KeyInfoAlloc(pParse.db, (int)(nCol), (int)(0));
    }

    if ((pKey) != null)
    {
        for (i = (int)(0); (i) &lt; (nCol); i++)
        {
            sbyte* zColl = pIdx.azColl[i];
            pKey.aColl[i] = (zColl) == (sqlite3StrBINARY) ? null : sqlite3LocateCollSeq(pParse, zColl);
            pKey.aSortFlags[i] = (byte)(pIdx.aSortOrder[i]);
        }

        if ((pParse.nErr) != 0)
        {
            if ((pIdx.bNoQuery) == (0))
            {
                pIdx.bNoQuery = (uint)(1);
                pParse.rc = (int)(1 | (2 &lt;&lt; 8));
            }

            sqlite3KeyInfoUnref(pKey);
            pKey = null;
        }
    }

    return pKey;
}</function>
  <function>public static KeyInfo sqlite3KeyInfoRef(KeyInfo p)
{
    if ((p) != null)
    {
        p.nRef++;
    }

    return p;
}</function>
  <function>public static void sqlite3KeyInfoUnref(KeyInfo p)
{
    if ((p) != null)
    {
        p.nRef--;
        if ((p.nRef) == (0))
            sqlite3DbFreeNN(p.db, p);
    }
}</function>
  <function>public static int sqlite3KeywordCode(byte* z, int n)
{
    int id = (int)(59);
    keywordCode((sbyte*)(z), (int)(n), &amp;id);
    return (int)(id);
}</function>
  <function>public static void sqlite3LeaveMutexAndCloseZombie(sqlite3 db)
{
    HashElem* i;
    int j = 0;
    if ((db.eOpenState != 0xa7) || ((connectionIsBusy(db)) != 0))
    {
        sqlite3_mutex_leave(db.mutex);
        return;
    }

    sqlite3RollbackAll(db, (int)(0));
    sqlite3CloseSavepoints(db);
    for (j = (int)(0); (j) &lt; (db.nDb); j++)
    {
        Db pDb = db.aDb[j];
        if ((pDb.pBt) != null)
        {
            sqlite3BtreeClose(pDb.pBt);
            pDb.pBt = null;
            if (j != 1)
            {
                pDb.pSchema = null;
            }
        }
    }

    if ((db.aDb[1].pSchema) != null)
    {
        sqlite3SchemaClear(db.aDb[1].pSchema);
    }

    sqlite3VtabUnlockList(db);
    sqlite3CollapseDatabaseArray(db);
    for (i = ((&amp;db.aFunc)-&gt;first); i; i = ((i)-&gt;next))
    {
        FuncDef pNext;
        FuncDef p;
        p = ((i)-&gt;data);
        do
        {
            functionDestroy(db, p);
            pNext = p.pNext;
            sqlite3DbFree(db, p);
            p = pNext;
        }
        while ((p) != null);
    }

    sqlite3HashClear(&amp;db.aFunc);
    for (i = ((&amp;db.aCollSeq)-&gt;first); i; i = ((i)-&gt;next))
    {
        CollSeq pColl = (CollSeq)((i)-&gt;data);
        for (j = (int)(0); (j) &lt; (3); j++)
        {
            if ((pColl[j].xDel) != null)
            {
                pColl[j].xDel(pColl[j].pUser);
            }
        }

        sqlite3DbFree(db, pColl);
    }

    sqlite3HashClear(&amp;db.aCollSeq);
    for (i = ((&amp;db.aModule)-&gt;first); i; i = ((i)-&gt;next))
    {
        Module pMod = (Module)((i)-&gt;data);
        sqlite3VtabEponymousTableClear(db, pMod);
        sqlite3VtabModuleUnref(db, pMod);
    }

    sqlite3HashClear(&amp;db.aModule);
    sqlite3Error(db, (int)(0));
    sqlite3ValueFree(db.pErr);
    sqlite3CloseExtensions(db);
    db.eOpenState = (byte)(0xd5);
    sqlite3DbFree(db, db.aDb[1].pSchema);
    if ((db.xAutovacDestr) != null)
    {
        db.xAutovacDestr(db.pAutovacPagesArg);
    }

    sqlite3_mutex_leave(db.mutex);
    db.eOpenState = (byte)(0xce);
    sqlite3_mutex_free(db.mutex);
    if ((db.lookaside.bMalloced) != 0)
    {
        sqlite3_free(db.lookaside.pStart);
    }

    sqlite3_free(db);
}</function>
  <function>public static int sqlite3LoadExtension(sqlite3 db, sbyte* zFile, sbyte* zProc, sbyte** pzErrMsg)
{
    sqlite3_vfs pVfs = db.pVfs;
    void* handle;
    delegate88 xInit;
    sbyte* zErrmsg = null;
    sbyte* zEntry;
    sbyte* zAltEntry = null;
    void** aHandle;
    ulong nMsg = (ulong)(CRuntime.strlen(zFile));
    int ii = 0;
    int rc = 0;
    if ((pzErrMsg) != null)
        *pzErrMsg = null;
    if ((db.flags &amp; 0x00010000) == (0))
    {
        if ((pzErrMsg) != null)
        {
            *pzErrMsg = sqlite3_mprintf("not authorized");
        }

        return (int)(1);
    }

    zEntry = (zProc) != 0 ? zProc : "sqlite3_extension_init";
    if ((nMsg) &gt; (260))
        goto extension_not_found;
    handle = sqlite3OsDlOpen(pVfs, zFile);
    for (ii = (int)(0); ((ii) &lt; ((int)(1 * sizeof(sbyte) / sizeof(sbyte*)))) &amp;&amp; ((handle) == (null)); ii++)
    {
        sbyte* zAltFile = sqlite3_mprintf("%s.%s", zFile, sqlite3LoadExtension_azEndings[ii]);
        if ((zAltFile) == (null))
            return (int)(7);
        handle = sqlite3OsDlOpen(pVfs, zAltFile);
        sqlite3_free(zAltFile);
    }

    if ((handle) == (null))
        goto extension_not_found;
    xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3OsDlSym(pVfs, handle, zEntry));
    if (((xInit) == (null)) &amp;&amp; ((zProc) == (null)))
    {
        int iFile = 0;
        int iEntry = 0;
        int c = 0;
        int ncFile = (int)(sqlite3Strlen30(zFile));
        zAltEntry = sqlite3_malloc64((ulong)(ncFile + 30));
        if ((zAltEntry) == (null))
        {
            sqlite3OsDlClose(pVfs, handle);
            return (int)(7);
        }

        CRuntime.memcpy(zAltEntry, "sqlite3_", (ulong)(8));
        for (iFile = (int)(ncFile - 1); ((iFile) &gt;= (0)) &amp;&amp; (!(((zFile[iFile]) == (47)) || ((zFile[iFile]) == (92)))); iFile--)
        {
        }

        iFile++;
        if ((sqlite3_strnicmp(zFile + iFile, "lib", (int)(3))) == (0))
            iFile += (int)(3);
        for (iEntry = (int)(8); ((c = (int)(zFile[iFile])) != 0) &amp;&amp; (c != 46); iFile++)
        {
            if ((sqlite3CtypeMap[(byte)(c)] &amp; 0x02) != 0)
            {
                zAltEntry[iEntry++] = ((sbyte)(sqlite3UpperToLower[(uint)(c)]));
            }
        }

        CRuntime.memcpy(zAltEntry + iEntry, "_init", (ulong)(6));
        zEntry = zAltEntry;
        xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3OsDlSym(pVfs, handle, zEntry));
    }

    if ((xInit) == (null))
    {
        if ((pzErrMsg) != null)
        {
            nMsg += (ulong)(CRuntime.strlen(zEntry) + 300);
            *pzErrMsg = zErrmsg = sqlite3_malloc64((ulong)(nMsg));
            if ((zErrmsg) != null)
            {
                sqlite3_snprintf((int)(nMsg), zErrmsg, "no entry point [%s] in shared library [%s]", zEntry, zFile);
                sqlite3OsDlError(pVfs, (int)(nMsg - 1), zErrmsg);
            }
        }

        sqlite3OsDlClose(pVfs, handle);
        sqlite3_free(zAltEntry);
        return (int)(1);
    }

    sqlite3_free(zAltEntry);
    rc = (int)(xInit(db, &amp;zErrmsg, sqlite3Apis));
    if ((rc) != 0)
    {
        if ((rc) == (0 | (1 &lt;&lt; 8)))
            return (int)(0);
        if ((pzErrMsg) != null)
        {
            *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
        }

        sqlite3_free(zErrmsg);
        sqlite3OsDlClose(pVfs, handle);
        return (int)(1);
    }

    aHandle = sqlite3DbMallocZero(db, (ulong)(sizeof(void*) * (db.nExtension + 1)));
    if ((aHandle) == (null))
    {
        return (int)(7);
    }

    if ((db.nExtension) &gt; (0))
    {
        CRuntime.memcpy(aHandle, db.aExtension, (ulong)(sizeof(void*) * db.nExtension));
    }

    sqlite3DbFree(db, db.aExtension);
    db.aExtension = aHandle;
    db.aExtension[db.nExtension++] = handle;
    return (int)(0);
    extension_not_found:
        ; if  ( ( pzErrMsg ) != null ) { nMsg += ( ulong ) ( 300 ) ;  * pzErrMsg  =  zErrmsg  =  sqlite3_malloc64 ( ( ulong ) ( nMsg ) ) ;  if  ( ( zErrmsg ) != null ) { sqlite3_snprintf ( ( int ) ( nMsg ) ,  zErrmsg ,  "unable to open shared library [%.*s]" ,  ( int ) ( 260 ) ,  zFile ) ;  sqlite3OsDlError ( pVfs ,  ( int ) ( nMsg - 1 ) ,  zErrmsg ) ;  } }
    return (int)(1);
}</function>
  <function>public static CollSeq sqlite3LocateCollSeq(Parse pParse, sbyte* zName)
{
    sqlite3 db = pParse.db;
    byte enc = (byte)((db).enc);
    byte initbusy = (byte)(db.init.busy);
    CollSeq pColl;
    pColl = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(initbusy));
    if ((initbusy == 0) &amp;&amp; ((pColl == null) || (pColl.xCmp == null)))
    {
        pColl = sqlite3GetCollSeq(pParse, (byte)(enc), pColl, zName);
    }

    return pColl;
}</function>
  <function>public static Table sqlite3LocateTable(Parse pParse, uint flags, sbyte* zName, sbyte* zDbase)
{
    Table p;
    sqlite3 db = pParse.db;
    if (((db.mDbFlags &amp; 0x0010) == (0)) &amp;&amp; (0 != sqlite3ReadSchema(pParse)))
    {
        return null;
    }

    p = sqlite3FindTable(db, zName, zDbase);
    if ((p) == (null))
    {
        if (((pParse.disableVtab) == (0)) &amp;&amp; ((db.init.busy) == (0)))
        {
            Module pMod = (Module)(sqlite3HashFind(&amp;db.aModule, zName));
            if (((pMod) == (null)) &amp;&amp; ((sqlite3_strnicmp(zName, "pragma_", (int)(7))) == (0)))
            {
                pMod = sqlite3PragmaVtabRegister(db, zName);
            }

            if (((pMod) != null) &amp;&amp; ((sqlite3VtabEponymousTableInit(pParse, pMod)) != 0))
            {
                return pMod.pEpoTab;
            }
        }

        if ((flags &amp; 0x02) != 0)
            return null;
        pParse.checkSchema = (byte)(1);
    }
    else if ((((p).eTabType) == (1)) &amp;&amp; ((pParse.disableVtab) != 0))
    {
        p = null;
    }

    if ((p) == (null))
    {
        sbyte* zMsg = (flags &amp; 0x01) != 0 ? "no such view" : "no such table";
        if ((zDbase) != null)
        {
            sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
        }
        else
        {
            sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
        }
    }
    else
    {
    }

    return p;
}</function>
  <function>public static Table sqlite3LocateTableItem(Parse pParse, uint flags, SrcItem p)
{
    sbyte* zDb;
    if ((p.pSchema) != null)
    {
        int iDb = (int)(sqlite3SchemaToIndex(pParse.db, p.pSchema));
        zDb = pParse.db.aDb[iDb].zDbSName;
    }
    else
    {
        zDb = p.zDatabase;
    }

    return sqlite3LocateTable(pParse, (uint)(flags), p.zName, zDb);
}</function>
  <function>public static int sqlite3LockAndPrepare(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, Vdbe pOld, sqlite3_stmt** ppStmt, sbyte** pzTail)
{
    int rc = 0;
    int cnt = (int)(0);
    *ppStmt = null;
    if ((sqlite3SafetyCheckOk(db) == 0) || ((zSql) == (null)))
    {
        return (int)(sqlite3MisuseError((int)(134001)));
    }

    sqlite3_mutex_enter(db.mutex);
    sqlite3BtreeEnterAll(db);
    do
    {
        rc = (int)(sqlite3Prepare(db, zSql, (int)(nBytes), (uint)(prepFlags), pOld, ppStmt, pzTail));
        if (((rc) == (0)) || ((db.mallocFailed) != 0))
            break;
    }
    while (((rc) == (1 | (2 &lt;&lt; 8))) || (((rc) == (17)) &amp;&amp; ((sqlite3ResetOneSchema(db, (int)(-1)), cnt++) == (0))));
    sqlite3BtreeLeaveAll(db);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    db.busyHandler.nBusy = (int)(0);
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static short sqlite3LogEst(ulong x)
{
    short y = (short)(40);
    if ((x) &lt; (8))
    {
        if ((x) &lt; (2))
            return (short)(0);
        while ((x) &lt; (8))
        {
            y -= (short)(10);
            x &lt;&lt;= 1;
        }
    }
    else
    {
        while ((x) &gt; (255))
        {
            y += (short)(40);
            x &gt;&gt;= 4;
        }

        while ((x) &gt; (15))
        {
            y += (short)(10);
            x &gt;&gt;= 1;
        }
    }

    return (short)(sqlite3LogEst_a[x &amp; 7] + y - 10);
}</function>
  <function>public static short sqlite3LogEstAdd(short a, short b)
{
    if ((a) &gt;= (b))
    {
        if ((a) &gt; (b + 49))
            return (short)(a);
        if ((a) &gt; (b + 31))
            return (short)(a + 1);
        return (short)(a + sqlite3LogEstAdd_x[a - b]);
    }
    else
    {
        if ((b) &gt; (a + 49))
            return (short)(b);
        if ((b) &gt; (a + 31))
            return (short)(b + 1);
        return (short)(b + sqlite3LogEstAdd_x[b - a]);
    }
}</function>
  <function>public static short sqlite3LogEstFromDouble(double x)
{
    ulong a = 0;
    short e = 0;
    if ((x) &lt;= (1))
        return (short)(0);
    if ((x) &lt;= (2000000000))
        return (short)(sqlite3LogEst((ulong)(x)));
    CRuntime.memcpy(&amp;a, &amp;x, (ulong)(8));
    e = (short)((a &gt;&gt; 52) - 1022);
    return (short)(e * 10);
}</function>
  <function>public static ulong sqlite3LogEstToInt(short x)
{
    ulong n = 0;
    n = (ulong)(x % 10);
    x /= (short)(10);
    if ((n) &gt;= (5))
        n -= (ulong)(2);
    else if ((n) &gt;= (1))
        n -= (ulong)(1);
    if ((x) &gt; (60))
        return (ulong)(0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32));
    return (ulong)((x) &gt;= (3) ? (n + 8) &lt;&lt; (x - 3) : (n + 8) &gt;&gt; (3 - x));
}</function>
  <function>public static int sqlite3LookasideUsed(sqlite3 db, int* pHighwater)
{
    uint nInit = (uint)(countLookasideSlots(db.lookaside.pInit));
    uint nFree = (uint)(countLookasideSlots(db.lookaside.pFree));
    nInit += (uint)(countLookasideSlots(db.lookaside.pSmallInit));
    nFree += (uint)(countLookasideSlots(db.lookaside.pSmallFree));
    if ((pHighwater) != null)
        *pHighwater = (int)(db.lookaside.nSlot - nInit);
    return (int)(db.lookaside.nSlot - (nInit + nFree));
}</function>
  <function>public static void* sqlite3Malloc(ulong n)
{
    void* p;
    if (((n) == (0)) || ((n) &gt;= (0x7fffff00)))
    {
        p = null;
    }
    else if ((sqlite3Config.bMemstat) != 0)
    {
        sqlite3_mutex_enter(mem0.mutex);
        mallocWithAlarm((int)(n), &amp;p);
        sqlite3_mutex_leave(mem0.mutex);
    }
    else
    {
        p = sqlite3Config.m.xMalloc((int)(n));
    }

    return p;
}</function>
  <function>public static void sqlite3MallocAlarm(int nByte)
{
    if ((mem0.alarmThreshold) &lt;= (0))
        return;
    sqlite3_mutex_leave(mem0.mutex);
    sqlite3_release_memory((int)(nByte));
    sqlite3_mutex_enter(mem0.mutex);
}</function>
  <function>public static void sqlite3MallocEnd()
{
    if ((sqlite3Config.m.xShutdown) != null)
    {
        sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData);
    }

    CRuntime.memset(&amp;mem0, (int)(0), (ulong)(sizeof(Mem0Global)));
}</function>
  <function>public static int sqlite3MallocInit()
{
    int rc = 0;
    if ((sqlite3Config.m.xMalloc) == (null))
    {
        sqlite3MemSetDefault();
    }

    mem0.mutex = sqlite3MutexAlloc((int)(3));
    if ((((sqlite3Config.pPage) == (null)) || ((sqlite3Config.szPage) &lt; (512))) || ((sqlite3Config.nPage) &lt;= (0)))
    {
        sqlite3Config.pPage = null;
        sqlite3Config.szPage = (int)(0);
    }

    rc = (int)(sqlite3Config.m.xInit(sqlite3Config.m.pAppData));
    if (rc != 0)
        CRuntime.memset(&amp;mem0, (int)(0), (ulong)(sizeof(Mem0Global)));
    return (int)(rc);
}</function>
  <function>public static sqlite3_mutex* sqlite3MallocMutex()
{
    return mem0.mutex;
}</function>
  <function>public static int sqlite3MallocSize(void* p)
{
    return (int)(sqlite3Config.m.xSize(p));
}</function>
  <function>public static void* sqlite3MallocZero(ulong n)
{
    void* p = sqlite3Malloc((ulong)(n));
    if ((p) != null)
    {
        CRuntime.memset(p, (int)(0), (ulong)(n));
    }

    return p;
}</function>
  <function>public static void sqlite3MarkAllShadowTablesOf(sqlite3 db, Table pTab)
{
    int nName = 0;
    Module pMod;
    HashElem* k;
    pMod = (Module)(sqlite3HashFind(&amp;db.aModule, pTab.u.vtab.azArg[0]));
    if ((pMod) == (null))
        return;
    if (((pMod.pModule) == (null)))
        return;
    if ((pMod.pModule.iVersion) &lt; (3))
        return;
    if ((pMod.pModule.xShadowName) == (null))
        return;
    nName = (int)(sqlite3Strlen30(pTab.zName));
    for (k = ((&amp;pTab.pSchema.tblHash)-&gt;first); k; k = ((k)-&gt;next))
    {
        Table pOther = ((k)-&gt;data);
        if (!(((pOther).eTabType) == (0)))
            continue;
        if ((pOther.tabFlags &amp; 0x00001000) != 0)
            continue;
        if ((((sqlite3_strnicmp(pOther.zName, pTab.zName, (int)(nName))) == (0)) &amp;&amp; ((pOther.zName[nName]) == (95))) &amp;&amp; ((pMod.pModule.xShadowName(pOther.zName + nName + 1)) != 0))
        {
            pOther.tabFlags |= (uint)(0x00001000);
        }
    }
}</function>
  <function>public static int sqlite3MatchEName(ExprList_item* pItem, sbyte* zCol, sbyte* zTab, sbyte* zDb)
{
    int n = 0;
    sbyte* zSpan;
    if (pItem-&gt;eEName != 2)
        return (int)(0);
    zSpan = pItem-&gt;zEName;
    for (n = (int)(0); ((zSpan[n]) != 0) &amp;&amp; (zSpan[n] != 46); n++)
    {
    }

    if (((zDb) != null) &amp;&amp; ((sqlite3_strnicmp(zSpan, zDb, (int)(n)) != 0) || (zDb[n] != 0)))
    {
        return (int)(0);
    }

    zSpan += n + 1;
    for (n = (int)(0); ((zSpan[n]) != 0) &amp;&amp; (zSpan[n] != 46); n++)
    {
    }

    if (((zTab) != null) &amp;&amp; ((sqlite3_strnicmp(zSpan, zTab, (int)(n)) != 0) || (zTab[n] != 0)))
    {
        return (int)(0);
    }

    zSpan += n + 1;
    if (((zCol) != null) &amp;&amp; (sqlite3StrICmp(zSpan, zCol) != 0))
    {
        return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static void sqlite3MaterializeView(Parse pParse, Table pView, Expr pWhere, ExprList pOrderBy, Expr pLimit, int iCur)
{
    SelectDest dest = new SelectDest();
    Select pSel;
    SrcList pFrom;
    sqlite3 db = pParse.db;
    int iDb = (int)(sqlite3SchemaToIndex(db, pView.pSchema));
    pWhere = sqlite3ExprDup(db, pWhere, (int)(0));
    pFrom = sqlite3SrcListAppend(pParse, null, null, null);
    if ((pFrom) != null)
    {
        pFrom.a[0].zName = sqlite3DbStrDup(db, pView.zName);
        pFrom.a[0].zDatabase = sqlite3DbStrDup(db, db.aDb[iDb].zDbSName);
    }

    pSel = sqlite3SelectNew(pParse, null, pFrom, pWhere, null, null, pOrderBy, (uint)(0x0020000), pLimit);
    sqlite3SelectDestInit(dest, (int)(12), (int)(iCur));
    sqlite3Select(pParse, pSel, dest);
    sqlite3SelectDelete(db, pSel);
}</function>
  <function>public static void sqlite3MayAbort(Parse pParse)
{
    Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    pToplevel.mayAbort = (byte)(1);
}</function>
  <function>public static int sqlite3MemCompare(sqlite3_value pMem1, sqlite3_value pMem2, CollSeq pColl)
{
    int f1 = 0; int  f2  =  0 ; 
    int combined_flags = 0;
    f1 = (int)(pMem1.flags);
    f2 = (int)(pMem2.flags);
    combined_flags = (int)(f1 | f2);
    if ((combined_flags &amp; 0x0001) != 0)
    {
        return (int)((f2 &amp; 0x0001) - (f1 &amp; 0x0001));
    }

    if ((combined_flags &amp; (0x0004 | 0x0008 | 0x0020)) != 0)
    {
        if ((f1 &amp; f2 &amp; (0x0004 | 0x0020)) != 0)
        {
            if ((pMem1.u.i) &lt; (pMem2.u.i))
                return (int)(-1);
            if ((pMem1.u.i) &gt; (pMem2.u.i))
                return (int)(+1);
            return (int)(0);
        }

        if ((f1 &amp; f2 &amp; 0x0008) != 0)
        {
            if ((pMem1.u.r) &lt; (pMem2.u.r))
                return (int)(-1);
            if ((pMem1.u.r) &gt; (pMem2.u.r))
                return (int)(+1);
            return (int)(0);
        }

        if ((f1 &amp; (0x0004 | 0x0020)) != 0)
        {
            if ((f2 &amp; 0x0008) != 0)
            {
                return (int)(sqlite3IntFloatCompare((long)(pMem1.u.i), (double)(pMem2.u.r)));
            }
            else if ((f2 &amp; (0x0004 | 0x0020)) != 0)
            {
                if ((pMem1.u.i) &lt; (pMem2.u.i))
                    return (int)(-1);
                if ((pMem1.u.i) &gt; (pMem2.u.i))
                    return (int)(+1);
                return (int)(0);
            }
            else
            {
                return (int)(-1);
            }
        }

        if ((f1 &amp; 0x0008) != 0)
        {
            if ((f2 &amp; (0x0004 | 0x0020)) != 0)
            {
                return (int)(-sqlite3IntFloatCompare((long)(pMem2.u.i), (double)(pMem1.u.r)));
            }
            else
            {
                return (int)(-1);
            }
        }

        return (int)(+1);
    }

    if ((combined_flags &amp; 0x0002) != 0)
    {
        if ((f1 &amp; 0x0002) == (0))
        {
            return (int)(1);
        }

        if ((f2 &amp; 0x0002) == (0))
        {
            return (int)(-1);
        }

        if ((pColl) != null)
        {
            return (int)(vdbeCompareMemString(pMem1, pMem2, pColl, null));
        }
    }

    return (int)(sqlite3BlobCompare(pMem1, pMem2));
}</function>
  <function>public static int sqlite3MemdbInit()
{
    sqlite3_vfs pLower = sqlite3_vfs_find(null);
    uint sz = 0;
    if (((pLower) == (null)))
        return (int)(1);
    sz = (uint)(pLower.szOsFile);
    memdb_vfs.pAppData = pLower;
    if ((sz) &lt; (sizeof(MemFile)))
        sz = (uint)(sizeof(MemFile));
    memdb_vfs.szOsFile = (int)(sz);
    return (int)(sqlite3_vfs_register(memdb_vfs, (int)(0)));
}</function>
  <function>public static void sqlite3MemFree(void* pPrior)
{
    CRuntime.free(pPrior);
}</function>
  <function>public static int sqlite3MemInit(void* NotUsed)
{
    return (int)(0);
}</function>
  <function>public static void sqlite3MemJournalOpen(sqlite3_file pJfd)
{
    sqlite3JournalOpen(null, null, pJfd, (int)(0), (int)(-1));
}</function>
  <function>public static void* sqlite3MemMalloc(int nByte)
{
    void* p;
    p = CRuntime.malloc((ulong)(nByte));
    if ((p) == (null))
    {
        sqlite3_log((int)(7), "failed to allocate %u bytes of memory", (int)(nByte));
    }

    return p;
}</function>
  <function>public static void sqlite3MemoryBarrier()
{
    _ReadWriteBarrier();
}</function>
  <function>public static void* sqlite3MemRealloc(void* pPrior, int nByte)
{
    void* p = CRuntime.realloc((pPrior), (ulong)(nByte));
    if ((p) == (null))
    {
        sqlite3_log((int)(7), "failed memory resize %u to %u bytes", (ulong)(_msize(pPrior)), (int)(nByte));
    }

    return p;
}</function>
  <function>public static int sqlite3MemRoundup(int n)
{
    return (int)(((n) + 7) &amp; ~7);
}</function>
  <function>public static void sqlite3MemSetDefault()
{
    sqlite3_config((int)(4), sqlite3MemSetDefault_defaultMethods);
}</function>
  <function>public static void sqlite3MemShutdown(void* NotUsed)
{
    return;
}</function>
  <function>public static int sqlite3MemSize(void* pPrior)
{
    return (int)(_msize(pPrior));
}</function>
  <function>public static int sqlite3MisuseError(int lineno)
{
    return (int)(sqlite3ReportError((int)(21), (int)(lineno), "misuse"));
}</function>
  <function>public static sbyte* sqlite3MPrintf(sqlite3 db, sbyte* zFormat)
{
    sbyte* ap;
    sbyte* z;
    (__va_start(&amp;ap, zFormat));
    z = sqlite3VMPrintf(db, zFormat, ap);
    ((void)(ap = null));
    return z;
}</function>
  <function>public static int sqlite3MulInt64(long* pA, long iB)
{
    long iA = (long)(*pA);
    if ((iB) &gt; (0))
    {
        if ((iA) &gt; ((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) / iB))
            return (int)(1);
        if ((iA) &lt; ((((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))) / iB))
            return (int)(1);
    }
    else if ((iB) &lt; (0))
    {
        if ((iA) &gt; (0))
        {
            if ((iB) &lt; ((((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))) / iA))
                return (int)(1);
        }
        else if ((iA) &lt; (0))
        {
            if ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))
                return (int)(1);
            if ((iA) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))
                return (int)(1);
            if ((-iA) &gt; ((0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)) / -iB))
                return (int)(1);
        }
    }

    *pA = (long)(iA * iB);
    return (int)(0);
}</function>
  <function>public static void sqlite3MultiWrite(Parse pParse)
{
    Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    pToplevel.isMultiWrite = (byte)(1);
}</function>
  <function>public static sqlite3_mutex* sqlite3MutexAlloc(int id)
{
    if (sqlite3Config.bCoreMutex == 0)
    {
        return null;
    }

    return sqlite3Config.mutex.xMutexAlloc((int)(id));
}</function>
  <function>public static int sqlite3MutexEnd()
{
    int rc = (int)(0);
    if ((sqlite3Config.mutex.xMutexEnd) != null)
    {
        rc = (int)(sqlite3Config.mutex.xMutexEnd());
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3MutexInit()
{
    int rc = (int)(0);
    if (sqlite3Config.mutex.xMutexAlloc == null)
    {
        sqlite3_mutex_methods pFrom;
        sqlite3_mutex_methods pTo = sqlite3Config.mutex;
        if ((sqlite3Config.bCoreMutex) != 0)
        {
            pFrom = sqlite3DefaultMutex();
        }
        else
        {
            pFrom = sqlite3NoopMutex();
        }

        pTo.xMutexInit = pFrom.xMutexInit;
        pTo.xMutexEnd = pFrom.xMutexEnd;
        pTo.xMutexFree = pFrom.xMutexFree;
        pTo.xMutexEnter = pFrom.xMutexEnter;
        pTo.xMutexTry = pFrom.xMutexTry;
        pTo.xMutexLeave = pFrom.xMutexLeave;
        pTo.xMutexHeld = pFrom.xMutexHeld;
        pTo.xMutexNotheld = pFrom.xMutexNotheld;
        sqlite3MemoryBarrier();
        pTo.xMutexAlloc = pFrom.xMutexAlloc;
    }

    rc = (int)(sqlite3Config.mutex.xMutexInit());
    sqlite3MemoryBarrier();
    return (int)(rc);
}</function>
  <function>public static sbyte* sqlite3NameFromToken(sqlite3 db, Token* pName)
{
    sbyte* zName;
    if ((pName) != null)
    {
        zName = sqlite3DbStrNDup(db, pName-&gt;z, (ulong)(pName-&gt;n));
        sqlite3Dequote(zName);
    }
    else
    {
        zName = null;
    }

    return zName;
}</function>
  <function>public static void sqlite3NestedParse(Parse pParse, sbyte* zFormat)
{
    sbyte* ap;
    sbyte* zSql;
    sqlite3 db = pParse.db;
    uint savedDbFlags = (uint)(db.mDbFlags);
    char[(sizeof(Parse) - ((size_t) &amp; (((Parse*)0)-&gt;sLastToken)))] saveBuf = (char[(sizeof(Parse) - ((size_t) &amp; (((Parse*)0)-&gt;sLastToken)))])(sizeof(Parse) - ((ulong)(&amp;((0).sLastToken))));
    if ((pParse.nErr) != 0)
        return;
    (__va_start(&amp;ap, zFormat));
    zSql = sqlite3VMPrintf(db, zFormat, ap);
    ((void)(ap = null));
    if ((zSql) == (null))
    {
        if (db.mallocFailed == 0)
            pParse.rc = (int)(18);
        pParse.nErr++;
        return;
    }

    pParse.nested++;
    CRuntime.memcpy(saveBuf, (((sbyte*)(pParse)) + ((ulong)(&amp;((0).sLastToken)))), (ulong)(sizeof(Parse) - ((ulong)(&amp;((0).sLastToken)))));
    CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&amp;((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&amp;((0).sLastToken)))));
    db.mDbFlags |= (uint)(0x0002);
    sqlite3RunParser(pParse, zSql);
    sqlite3DbFree(db, pParse.zErrMsg);
    pParse.zErrMsg = null;
    db.mDbFlags = (uint)(savedDbFlags);
    sqlite3DbFree(db, zSql);
    CRuntime.memcpy((((sbyte*)(pParse)) + ((ulong)(&amp;((0).sLastToken)))), saveBuf, (ulong)(sizeof(Parse) - ((ulong)(&amp;((0).sLastToken)))));
    pParse.nested--;
}</function>
  <function>public static void sqlite3NoopDestructor(void* p)
{
}</function>
  <function>public static sqlite3_mutex_methods sqlite3NoopMutex()
{
    return sqlite3NoopMutex_sMutex;
}</function>
  <function>public static int sqlite3NotPureFunc(sqlite3_context pCtx)
{
    VdbeOp* pOp;
    pOp = pCtx.pVdbe.aOp + pCtx.iOp;
    if ((pOp-&gt;opcode) == (65))
    {
        sbyte* zContext;
        sbyte* zMsg;
        if ((pOp-&gt;p5 &amp; 0x000004) != 0)
        {
            zContext = "a CHECK constraint";
        }
        else if ((pOp-&gt;p5 &amp; 0x000008) != 0)
        {
            zContext = "a generated column";
        }
        else
        {
            zContext = "an index";
        }

        zMsg = sqlite3_mprintf("non-deterministic use of %s() in %s", pCtx.pFunc.zName, zContext);
        sqlite3_result_error(pCtx, zMsg, (int)(-1));
        sqlite3_free(zMsg);
        return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static void sqlite3OomClear(sqlite3 db)
{
    if (((db.mallocFailed) != 0) &amp;&amp; ((db.nVdbeExec) == (0)))
    {
        db.mallocFailed = (byte)(0);
        (0);
        db.lookaside.bDisable--;
        db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
    }
}</function>
  <function>public static void* sqlite3OomFault(sqlite3 db)
{
    if (((db.mallocFailed) == (0)) &amp;&amp; ((db.bBenignMalloc) == (0)))
    {
        db.mallocFailed = (byte)(1);
        if ((db.nVdbeExec) &gt; (0))
        {
            (1);
        }

        db.lookaside.bDisable++;
        db.lookaside.sz = (ushort)(0);
        if ((db.pParse) != null)
        {
            sqlite3ErrorMsg(db.pParse, "out of memory");
            db.pParse.rc = (int)(7);
        }
    }

    return null;
}</function>
  <function>public static sbyte* sqlite3OpcodeName(int i)
{
    return sqlite3OpcodeName_azName[i];
}</function>
  <function>public static void sqlite3OpenSchemaTable(Parse p, int iDb)
{
    Vdbe v = sqlite3GetVdbe(p);
    sqlite3TableLock(p, (int)(iDb), (uint)(1), (byte)(1), "sqlite_master");
    sqlite3VdbeAddOp4Int(v, (int)(112), (int)(0), (int)(1), (int)(iDb), (int)(5));
    if ((p.nTab) == (0))
    {
        p.nTab = (int)(1);
    }
}</function>
  <function>public static void sqlite3OpenTable(Parse pParse, int iCur, int iDb, Table pTab, int opcode)
{
    Vdbe v;
    v = pParse.pVdbe;
    sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(((opcode) == (112)) ? 1 : 0), pTab.zName);
    if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
    {
        sqlite3VdbeAddOp4Int(v, (int)(opcode), (int)(iCur), (int)(pTab.tnum), (int)(iDb), (int)(pTab.nNVCol));
    }
    else
    {
        Index pPk = sqlite3PrimaryKeyIndex(pTab);
        sqlite3VdbeAddOp3(v, (int)(opcode), (int)(iCur), (int)(pPk.tnum), (int)(iDb));
        sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
}</function>
  <function>public static int sqlite3OpenTableAndIndices(Parse pParse, Table pTab, int op, byte p5, int iBase, byte* aToOpen, int* piDataCur, int* piIdxCur)
{
    int i = 0;
    int iDb = 0;
    int iDataCur = 0;
    Index pIdx;
    Vdbe v;
    if ((((pTab).eTabType) == (1)))
    {
        *piDataCur = (int)(*piIdxCur = (int)(-999));
        return (int)(0);
    }

    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
    v = pParse.pVdbe;
    if ((iBase) &lt; (0))
        iBase = (int)(pParse.nTab);
    iDataCur = (int)(iBase++);
    if ((piDataCur) != null)
        *piDataCur = (int)(iDataCur);
    if ((((pTab).tabFlags &amp; 0x00000080) == (0)) &amp;&amp; (((aToOpen) == (null)) || ((aToOpen[0]) != 0)))
    {
        sqlite3OpenTable(pParse, (int)(iDataCur), (int)(iDb), pTab, (int)(op));
    }
    else
    {
        sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)((op) == (112)), pTab.zName);
    }

    if ((piIdxCur) != null)
        *piIdxCur = (int)(iBase);
    for (i = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, i++)
    {
        int iIdxCur = (int)(iBase++);
        if ((((pIdx).idxType) == (2)) &amp;&amp; (!(((pTab).tabFlags &amp; 0x00000080) == (0))))
        {
            if ((piDataCur) != null)
                *piDataCur = (int)(iIdxCur);
            p5 = (byte)(0);
        }

        if (((aToOpen) == (null)) || ((aToOpen[i + 1]) != 0))
        {
            sqlite3VdbeAddOp3(v, (int)(op), (int)(iIdxCur), (int)(pIdx.tnum), (int)(iDb));
            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
            sqlite3VdbeChangeP5(v, (ushort)(p5));
        }
    }

    if ((iBase) &gt; (pParse.nTab))
        pParse.nTab = (int)(iBase);
    return (int)(i);
}</function>
  <function>public static int sqlite3OpenTempDatabase(Parse pParse)
{
    sqlite3 db = pParse.db;
    if (((db.aDb[1].pBt) == (null)) &amp;&amp; (pParse.explain == 0))
    {
        int rc = 0;
        Btree pBt;
        rc = (int)(sqlite3BtreeOpen(db.pVfs, null, db, pBt, (int)(0), (int)(sqlite3OpenTempDatabase_flags)));
        if (rc != 0)
        {
            sqlite3ErrorMsg(pParse, "unable to open a temporary database file for storing temporary tables");
            pParse.rc = (int)(rc);
            return (int)(1);
        }

        db.aDb[1].pBt = pBt;
        if ((7) == (sqlite3BtreeSetPageSize(pBt, (int)(db.nextPagesize), (int)(0), (int)(0))))
        {
            sqlite3OomFault(db);
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3OsAccess(sqlite3_vfs pVfs, sbyte* zPath, int flags, int* pResOut)
{
    return (int)(pVfs.xAccess(pVfs, zPath, (int)(flags), pResOut));
}</function>
  <function>public static int sqlite3OsCheckReservedLock(sqlite3_file id, int* pResOut)
{
    return (int)(id.pMethods.xCheckReservedLock(id, pResOut));
}</function>
  <function>public static void sqlite3OsClose(sqlite3_file pId)
{
    if ((pId.pMethods) != null)
    {
        pId.pMethods.xClose(pId);
        pId.pMethods = null;
    }
}</function>
  <function>public static void sqlite3OsCloseFree(sqlite3_file pFile)
{
    sqlite3OsClose(pFile);
    sqlite3_free(pFile);
}</function>
  <function>public static int sqlite3OsCurrentTimeInt64(sqlite3_vfs pVfs, long* pTimeOut)
{
    int rc = 0;
    if (((pVfs.iVersion) &gt;= (2)) &amp;&amp; ((pVfs.xCurrentTimeInt64) != null))
    {
        rc = (int)(pVfs.xCurrentTimeInt64(pVfs, pTimeOut));
    }
    else
    {
        double r = 0;
        rc = (int)(pVfs.xCurrentTime(pVfs, &amp;r));
        *pTimeOut = ((long)(r * 86400000.0));
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3OsDelete(sqlite3_vfs pVfs, sbyte* zPath, int dirSync)
{
    return (int)(pVfs.xDelete != null ? pVfs.xDelete(pVfs, zPath, (int)(dirSync)) : 0);
}</function>
  <function>public static int sqlite3OsDeviceCharacteristics(sqlite3_file id)
{
    if (((id.pMethods) == (null)))
        return (int)(0);
    return (int)(id.pMethods.xDeviceCharacteristics(id));
}</function>
  <function>public static void sqlite3OsDlClose(sqlite3_vfs pVfs, void* pHandle)
{
    pVfs.xDlClose(pVfs, pHandle);
}</function>
  <function>public static void sqlite3OsDlError(sqlite3_vfs pVfs, int nByte, sbyte* zBufOut)
{
    pVfs.xDlError(pVfs, (int)(nByte), zBufOut);
}</function>
  <function>public static void* sqlite3OsDlOpen(sqlite3_vfs pVfs, sbyte* zPath)
{
    return pVfs.xDlOpen(pVfs, zPath);
}</function>
  <function>public static Void ( )sqlite3OsDlSym(sqlite3_vfs pVfs, void* pHdle, sbyte* zSym)
{
    return pVfs.xDlSym(pVfs, pHdle, zSym);
}</function>
  <function>public static int sqlite3OsFetch(sqlite3_file id, long iOff, int iAmt, void** pp)
{
    return (int)(id.pMethods.xFetch(id, (long)(iOff), (int)(iAmt), pp));
}</function>
  <function>public static int sqlite3OsFileControl(sqlite3_file id, int op, void* pArg)
{
    if ((id.pMethods) == (null))
        return (int)(12);
    return (int)(id.pMethods.xFileControl(id, (int)(op), pArg));
}</function>
  <function>public static void sqlite3OsFileControlHint(sqlite3_file id, int op, void* pArg)
{
    if ((id.pMethods) != null)
        (void)(id.pMethods.xFileControl(id, (int)(op), pArg));
}</function>
  <function>public static int sqlite3OsFileSize(sqlite3_file id, long* pSize)
{
    return (int)(id.pMethods.xFileSize(id, pSize));
}</function>
  <function>public static int sqlite3OsFullPathname(sqlite3_vfs pVfs, sbyte* zPath, int nPathOut, sbyte* zPathOut)
{
    zPathOut[0] = (sbyte)(0);
    return (int)(pVfs.xFullPathname(pVfs, zPath, (int)(nPathOut), zPathOut));
}</function>
  <function>public static int sqlite3OsGetLastError(sqlite3_vfs pVfs)
{
    return (int)(pVfs.xGetLastError ? pVfs.xGetLastError(pVfs, (int)(0), null) : 0);
}</function>
  <function>public static int sqlite3OsInit()
{
    void* p = sqlite3_malloc((int)(10));
    if ((p) == (null))
        return (int)(7);
    sqlite3_free(p);
    return (int)(sqlite3_os_init());
}</function>
  <function>public static int sqlite3OsLock(sqlite3_file id, int lockType)
{
    return (int)(id.pMethods.xLock(id, (int)(lockType)));
}</function>
  <function>public static int sqlite3OsOpen(sqlite3_vfs pVfs, sbyte* zPath, sqlite3_file pFile, int flags, int* pFlagsOut)
{
    int rc = 0;
    rc = (int)(pVfs.xOpen(pVfs, zPath, pFile, (int)(flags &amp; 0x1087f7f), pFlagsOut));
    return (int)(rc);
}</function>
  <function>public static int sqlite3OsOpenMalloc(sqlite3_vfs pVfs, sbyte* zFile, sqlite3_file ppFile, int flags, int* pOutFlags)
{
    int rc = 0;
    sqlite3_file pFile;
    pFile = (sqlite3_file)(sqlite3MallocZero((ulong)(pVfs.szOsFile)));
    if ((pFile) != null)
    {
        rc = (int)(sqlite3OsOpen(pVfs, zFile, pFile, (int)(flags), pOutFlags));
        if (rc != 0)
        {
            sqlite3_free(pFile);
            ppFile = null;
        }
        else
        {
            ppFile = pFile;
        }
    }
    else
    {
        ppFile = null;
        rc = (int)(7);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3OsRandomness(sqlite3_vfs pVfs, int nByte, sbyte* zBufOut)
{
    if ((sqlite3Config.iPrngSeed) != 0)
    {
        CRuntime.memset(zBufOut, (int)(0), (ulong)(nByte));
        if (((nByte) &gt; ((int)(sizeof(unsigned)))))
            nByte = (int)(sizeof(unsignedint));
        CRuntime.memcpy(zBufOut, &amp;sqlite3Config.iPrngSeed, (ulong)(nByte));
        return (int)(0);
    }
    else
    {
        return (int)(pVfs.xRandomness(pVfs, (int)(nByte), zBufOut));
    }
}</function>
  <function>public static int sqlite3OsRead(sqlite3_file id, void* pBuf, int amt, long offset)
{
    return (int)(id.pMethods.xRead(id, pBuf, (int)(amt), (long)(offset)));
}</function>
  <function>public static int sqlite3OsSectorSize(sqlite3_file id)
{
    delegate0 xSectorSize = id.pMethods.xSectorSize;
    return (int)(xSectorSize ? xSectorSize(id) : 4096);
}</function>
  <function>public static void sqlite3OsShmBarrier(sqlite3_file id)
{
    id.pMethods.xShmBarrier(id);
}</function>
  <function>public static int sqlite3OsShmLock(sqlite3_file id, int offset, int n, int flags)
{
    return (int)(id.pMethods.xShmLock(id, (int)(offset), (int)(n), (int)(flags)));
}</function>
  <function>public static int sqlite3OsShmMap(sqlite3_file id, int iPage, int pgsz, int bExtend, void** pp)
{
    return (int)(id.pMethods.xShmMap(id, (int)(iPage), (int)(pgsz), (int)(bExtend), pp));
}</function>
  <function>public static int sqlite3OsShmUnmap(sqlite3_file id, int deleteFlag)
{
    return (int)(id.pMethods.xShmUnmap(id, (int)(deleteFlag)));
}</function>
  <function>public static int sqlite3OsSleep(sqlite3_vfs pVfs, int nMicro)
{
    return (int)(pVfs.xSleep(pVfs, (int)(nMicro)));
}</function>
  <function>public static int sqlite3OsSync(sqlite3_file id, int flags)
{
    return (int)((flags) != 0 ? id.pMethods.xSync(id, (int)(flags)) : 0);
}</function>
  <function>public static int sqlite3OsTruncate(sqlite3_file id, long size)
{
    return (int)(id.pMethods.xTruncate(id, (long)(size)));
}</function>
  <function>public static int sqlite3OsUnfetch(sqlite3_file id, long iOff, void* p)
{
    return (int)(id.pMethods.xUnfetch(id, (long)(iOff), p));
}</function>
  <function>public static int sqlite3OsUnlock(sqlite3_file id, int lockType)
{
    return (int)(id.pMethods.xUnlock(id, (int)(lockType)));
}</function>
  <function>public static int sqlite3OsWrite(sqlite3_file id, void* pBuf, int amt, long offset)
{
    return (int)(id.pMethods.xWrite(id, pBuf, (int)(amt), (long)(offset)));
}</function>
  <function>public static void sqlite3PageFree(void* p)
{
    pcache1Free(p);
}</function>
  <function>public static void* sqlite3PageMalloc(int sz)
{
    return pcache1Alloc((int)(sz));
}</function>
  <function>public static sqlite3_backup sqlite3PagerBackupPtr(Pager pPager)
{
    return pPager.pBackup;
}</function>
  <function>public static int sqlite3PagerBegin(Pager pPager, int exFlag, int subjInMemory)
{
    int rc = (int)(0);
    if ((pPager.errCode) != 0)
        return (int)(pPager.errCode);
    pPager.subjInMemory = ((byte)(subjInMemory));
    if ((pPager.eState) == (1))
    {
        if (((pPager).pWal != null))
        {
            if (((pPager.exclusiveMode) != 0) &amp;&amp; ((sqlite3WalExclusiveMode(pPager.pWal, (int)(-1))) != 0))
            {
                rc = (int)(pagerLockDb(pPager, (int)(4)));
                if (rc != 0)
                {
                    return (int)(rc);
                }

                (void)(sqlite3WalExclusiveMode(pPager.pWal, (int)(1)));
            }

            rc = (int)(sqlite3WalBeginWriteTransaction(pPager.pWal));
        }
        else
        {
            rc = (int)(pagerLockDb(pPager, (int)(2)));
            if (((rc) == (0)) &amp;&amp; ((exFlag) != 0))
            {
                rc = (int)(pager_wait_on_lock(pPager, (int)(4)));
            }
        }

        if ((rc) == (0))
        {
            pPager.eState = (byte)(2);
            pPager.dbHintSize = (uint)(pPager.dbSize);
            pPager.dbFileSize = (uint)(pPager.dbSize);
            pPager.dbOrigSize = (uint)(pPager.dbSize);
            pPager.journalOff = (long)(0);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3PagerCacheStat(Pager pPager, int eStat, int reset, int* pnVal)
{
    eStat -= (int)(7);
    *pnVal += (int)(pPager.aStat[eStat]);
    if ((reset) != 0)
    {
        pPager.aStat[eStat] = (int)(0);
    }
}</function>
  <function>public static int sqlite3PagerCheckpoint(Pager pPager, sqlite3 db, int eMode, int* pnLog, int* pnCkpt)
{
    int rc = (int)(0);
    if (((pPager.pWal) == (null)) &amp;&amp; ((pPager.journalMode) == (5)))
    {
        sqlite3_exec(db, "PRAGMA table_list", null, null, null);
    }

    if ((pPager.pWal) != null)
    {
        rc = (int)(sqlite3WalCheckpoint(pPager.pWal, db, (int)(eMode), ((eMode) == (0) ? null : pPager.xBusyHandler), pPager.pBusyHandlerArg, (int)(pPager.walSyncFlags), (int)(pPager.pageSize), (byte*)(pPager.pTmpSpace), pnLog, pnCkpt));
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3PagerClearCache(Pager pPager)
{
    if ((pPager.tempFile) == (0))
        pager_reset(pPager);
}</function>
  <function>public static int sqlite3PagerClose(Pager pPager, sqlite3 db)
{
    byte* pTmp = (byte*)(pPager.pTmpSpace);
    sqlite3BeginBenignMalloc();
    pagerFreeMapHdrs(pPager);
    pPager.exclusiveMode = (byte)(0);
    {
        byte* a = null;
        if ((((db) != null) &amp;&amp; ((0) == (db.flags &amp; 0x00000800))) &amp;&amp; ((0) == (databaseIsUnmoved(pPager))))
        {
            a = pTmp;
        }

        sqlite3WalClose(pPager.pWal, db, (int)(pPager.walSyncFlags), (int)(pPager.pageSize), a);
        pPager.pWal = null;
    }

    pager_reset(pPager);
    if ((pPager.memDb) != 0)
    {
        pager_unlock(pPager);
    }
    else
    {
        if (((pPager.jfd).pMethods != null))
        {
            pager_error(pPager, (int)(pagerSyncHotJournal(pPager)));
        }

        pagerUnlockAndRollback(pPager);
    }

    sqlite3EndBenignMalloc();
    sqlite3OsClose(pPager.jfd);
    sqlite3OsClose(pPager.fd);
    sqlite3PageFree(pTmp);
    sqlite3PcacheClose(pPager.pPCache);
    sqlite3_free(pPager);
    return (int)(0);
}</function>
  <function>public static int sqlite3PagerCloseWal(Pager pPager, sqlite3 db)
{
    int rc = (int)(0);
    if (pPager.pWal == null)
    {
        int logexists = (int)(0);
        rc = (int)(pagerLockDb(pPager, (int)(1)));
        if ((rc) == (0))
        {
            rc = (int)(sqlite3OsAccess(pPager.pVfs, pPager.zWal, (int)(0), &amp;logexists));
        }

        if (((rc) == (0)) &amp;&amp; ((logexists) != 0))
        {
            rc = (int)(pagerOpenWal(pPager));
        }
    }

    if (((rc) == (0)) &amp;&amp; ((pPager.pWal) != null))
    {
        rc = (int)(pagerExclusiveLock(pPager));
        if ((rc) == (0))
        {
            rc = (int)(sqlite3WalClose(pPager.pWal, db, (int)(pPager.walSyncFlags), (int)(pPager.pageSize), (byte*)(pPager.pTmpSpace)));
            pPager.pWal = null;
            pagerFixMaplimit(pPager);
            if (((rc) != 0) &amp;&amp; (pPager.exclusiveMode == 0))
                pagerUnlockDb(pPager, (int)(1));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3PagerCommitPhaseOne(Pager pPager, sbyte* zSuper, int noSync)
{
    int rc = (int)(0);
    if ((pPager.errCode) != 0)
        return (int)(pPager.errCode);
    if ((sqlite3FaultSim((int)(400))) != 0)
        return (int)(10);
    if ((pPager.eState) &lt; (3))
        return (int)(0);
    if ((0) == (pagerFlushOnCommit(pPager, (int)(1))))
    {
        sqlite3BackupRestart(pPager.pBackup);
    }
    else
    {
        PgHdr pList;
        if (((pPager).pWal != null))
        {
            PgHdr pPageOne = null;
            pList = sqlite3PcacheDirtyList(pPager.pPCache);
            if ((pList) == (null))
            {
                rc = (int)(sqlite3PagerGet(pPager, (uint)(1), pPageOne, (int)(0)));
                pList = pPageOne;
                pList.pDirty = null;
            }

            if ((pList) != null)
            {
                rc = (int)(pagerWalFrames(pPager, pList, (uint)(pPager.dbSize), (int)(1)));
            }

            sqlite3PagerUnref(pPageOne);
            if ((rc) == (0))
            {
                sqlite3PcacheCleanAll(pPager.pPCache);
            }
        }
        else
        {
            rc = (int)(pager_incr_changecounter(pPager, (int)(0)));
            if (rc != 0)
                goto commit_phase_one_exit;
            rc = (int)(writeSuperJournal(pPager, zSuper));
            if (rc != 0)
                goto commit_phase_one_exit;
            rc = (int)(syncJournal(pPager, (int)(0)));
            if (rc != 0)
                goto commit_phase_one_exit;
            pList = sqlite3PcacheDirtyList(pPager.pPCache);
            if ((0) == (0))
            {
                rc = (int)(pager_write_pagelist(pPager, pList));
            }

            if (rc != 0)
            {
                goto commit_phase_one_exit;
            }

            sqlite3PcacheCleanAll(pPager.pPCache);
            if ((pPager.dbSize) &gt; (pPager.dbFileSize))
            {
                uint nNew = (uint)(pPager.dbSize - ((pPager.dbSize) == ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1))));
                rc = (int)(pager_truncate(pPager, (uint)(nNew)));
                if (rc != 0)
                    goto commit_phase_one_exit;
            }

            if (noSync == 0)
            {
                rc = (int)(sqlite3PagerSync(pPager, zSuper));
            }
        }
    }

    commit_phase_one_exit:
        ; if  ( ( ( rc ) == ( 0 ) ) &amp;&amp; ( ! ( ( pPager ) . pWal != null ) ) ) { pPager . eState  =  ( byte ) ( 5 ) ;  }
    return (int)(rc);
}</function>
  <function>public static int sqlite3PagerCommitPhaseTwo(Pager pPager)
{
    int rc = (int)(0);
    if ((pPager.errCode) != 0)
        return (int)(pPager.errCode);
    pPager.iDataVersion++;
    if ((((pPager.eState) == (2)) &amp;&amp; ((pPager.exclusiveMode) != 0)) &amp;&amp; ((pPager.journalMode) == (1)))
    {
        pPager.eState = (byte)(1);
        return (int)(0);
    }

    rc = (int)(pager_end_transaction(pPager, (int)(pPager.setSuper), (int)(1)));
    return (int)(pager_error(pPager, (int)(rc)));
}</function>
  <function>public static uint sqlite3PagerDataVersion(Pager pPager)
{
    return (uint)(pPager.iDataVersion);
}</function>
  <function>public static void sqlite3PagerDontWrite(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    if (((pPager.tempFile == 0) &amp;&amp; ((pPg.flags &amp; 0x002) != 0)) &amp;&amp; ((pPager.nSavepoint) == (0)))
    {
        pPg.flags |= (ushort)(0x010);
        pPg.flags &amp;= (ushort)(~0x004);
    }
}</function>
  <function>public static int sqlite3PagerExclusiveLock(Pager pPager)
{
    int rc = (int)(pPager.errCode);
    if ((rc) == (0))
    {
        if ((0) == ((pPager).pWal != null))
        {
            rc = (int)(pager_wait_on_lock(pPager, (int)(4)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static sqlite3_file sqlite3PagerFile(Pager pPager)
{
    return pPager.fd;
}</function>
  <function>public static sbyte* sqlite3PagerFilename(Pager pPager, int nullIfMemDb)
{
    return (((nullIfMemDb) != 0) &amp;&amp; ((pPager.memDb) != 0)) ? &amp;sqlite3PagerFilename_zFake[4] : pPager.zFilename;
}</function>
  <function>public static int sqlite3PagerFlush(Pager pPager)
{
    int rc = (int)(pPager.errCode);
    if (pPager.memDb == 0)
    {
        PgHdr pList = sqlite3PcacheDirtyList(pPager.pPCache);
        while (((rc) == (0)) &amp;&amp; ((pList) != null))
        {
            PgHdr pNext = pList.pDirty;
            if ((pList.nRef) == (0))
            {
                rc = (int)(pagerStress((void*)(pPager), pList));
            }

            pList = pNext;
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3PagerGet(Pager pPager, uint pgno, PgHdr ppPage, int flags)
{
    return (int)(pPager.xGet(pPager, (uint)(pgno), ppPage, (int)(flags)));
}</function>
  <function>public static void* sqlite3PagerGetData(PgHdr pPg)
{
    return pPg.pData;
}</function>
  <function>public static void* sqlite3PagerGetExtra(PgHdr pPg)
{
    return pPg.pExtra;
}</function>
  <function>public static int sqlite3PagerGetJournalMode(Pager pPager)
{
    return (int)(pPager.journalMode);
}</function>
  <function>public static int sqlite3PagerIsMemdb(Pager pPager)
{
    return (((pPager.tempFile) != 0) || ((pPager.memVfs) != 0) ? 1 : 0);
}</function>
  <function>public static byte sqlite3PagerIsreadonly(Pager pPager)
{
    return (byte)(pPager.readOnly);
}</function>
  <function>public static sbyte* sqlite3PagerJournalname(Pager pPager)
{
    return pPager.zJournal;
}</function>
  <function>public static long sqlite3PagerJournalSizeLimit(Pager pPager, long iLimit)
{
    if ((iLimit) &gt;= (-1))
    {
        pPager.journalSizeLimit = (long)(iLimit);
        sqlite3WalLimit(pPager.pWal, (long)(iLimit));
    }

    return (long)(pPager.journalSizeLimit);
}</function>
  <function>public static sqlite3_file sqlite3PagerJrnlFile(Pager pPager)
{
    return pPager.pWal ? sqlite3WalFile(pPager.pWal) : pPager.jfd;
}</function>
  <function>public static int sqlite3PagerLockingMode(Pager pPager, int eMode)
{
    if ((((eMode) &gt;= (0)) &amp;&amp; (pPager.tempFile == 0)) &amp;&amp; (sqlite3WalHeapMemory(pPager.pWal) == 0))
    {
        pPager.exclusiveMode = ((byte)(eMode));
    }

    return (int)(pPager.exclusiveMode);
}</function>
  <function>public static PgHdr sqlite3PagerLookup(Pager pPager, uint pgno)
{
    sqlite3_pcache_page* pPage;
    pPage = sqlite3PcacheFetch(pPager.pPCache, (uint)(pgno), (int)(0));
    if ((pPage) == (null))
        return null;
    return sqlite3PcacheFetchFinish(pPager.pPCache, (uint)(pgno), pPage);
}</function>
  <function>public static uint sqlite3PagerMaxPageCount(Pager pPager, uint mxPage)
{
    if ((mxPage) &gt; (0))
    {
        pPager.mxPgno = (uint)(mxPage);
    }

    return (uint)(pPager.mxPgno);
}</function>
  <function>public static int sqlite3PagerMemUsed(Pager pPager)
{
    int perPageSize = (int)(pPager.pageSize + pPager.nExtra + (int)(sizeof(PgHdr) + 5 * sizeof(void*)));
    return (int)(perPageSize * sqlite3PcachePagecount(pPager.pPCache) + sqlite3MallocSize(pPager) + pPager.pageSize);
}</function>
  <function>public static int sqlite3PagerMovepage(Pager pPager, PgHdr pPg, uint pgno, int isCommit)
{
    PgHdr pPgOld;
    uint needSyncPgno = (uint)(0);
    int rc = 0;
    uint origPgno = 0;
    if ((pPager.tempFile) != 0)
    {
        rc = (int)(sqlite3PagerWrite(pPg));
        if ((rc) != 0)
            return (int)(rc);
    }

    if (((pPg.flags &amp; 0x002) != 0) &amp;&amp; (0 != (rc = (int)(subjournalPageIfRequired(pPg)))))
    {
        return (int)(rc);
    }

    if (((pPg.flags &amp; 0x008) != 0) &amp;&amp; (isCommit == 0))
    {
        needSyncPgno = (uint)(pPg.pgno);
    }

    pPg.flags &amp;= (ushort)(~0x008);
    pPgOld = sqlite3PagerLookup(pPager, (uint)(pgno));
    if ((pPgOld) != null)
    {
        if (((pPgOld.nRef) &gt; (1)))
        {
            sqlite3PagerUnrefNotNull(pPgOld);
            return (int)(sqlite3CorruptError((int)(60367)));
        }

        pPg.flags |= (ushort)(pPgOld.flags &amp; 0x008);
        if ((pPager.tempFile) != 0)
        {
            sqlite3PcacheMove(pPgOld, (uint)(pPager.dbSize + 1));
        }
        else
        {
            sqlite3PcacheDrop(pPgOld);
        }
    }

    origPgno = (uint)(pPg.pgno);
    sqlite3PcacheMove(pPg, (uint)(pgno));
    sqlite3PcacheMakeDirty(pPg);
    if (((pPager.tempFile) != 0) &amp;&amp; ((pPgOld) != null))
    {
        sqlite3PcacheMove(pPgOld, (uint)(origPgno));
        sqlite3PagerUnrefNotNull(pPgOld);
    }

    if ((needSyncPgno) != 0)
    {
        PgHdr pPgHdr;
        rc = (int)(sqlite3PagerGet(pPager, (uint)(needSyncPgno), pPgHdr, (int)(0)));
        if (rc != 0)
        {
            if ((needSyncPgno) &lt;= (pPager.dbOrigSize))
            {
                sqlite3BitvecClear(pPager.pInJournal, (uint)(needSyncPgno), pPager.pTmpSpace);
            }

            return (int)(rc);
        }

        pPgHdr.flags |= (ushort)(0x008);
        sqlite3PcacheMakeDirty(pPgHdr);
        sqlite3PagerUnrefNotNull(pPgHdr);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3PagerOkToChangeJournalMode(Pager pPager)
{
    if ((pPager.eState) &gt;= (3))
        return (int)(0);
    if ((((pPager.jfd).pMethods != null) &amp;&amp; ((pPager.journalOff) &gt; (0))))
        return (int)(0);
    return (int)(1);
}</function>
  <function>public static int sqlite3PagerOpen(sqlite3_vfs pVfs, Pager ppPager, sbyte* zFilename, int nExtra, int flags, int vfsFlags, delegate76 xReinit)
{
    byte* pPtr;
    Pager pPager = null;
    int rc = (int)(0);
    int tempFile = (int)(0);
    int memDb = (int)(0);
    int memJM = (int)(0);
    int readOnly = (int)(0);
    int journalFileSize = 0;
    sbyte* zPathname = null;
    int nPathname = (int)(0);
    int useJournal = (int)((flags &amp; 0x0001) == (0) ? 1 : 0);
    int pcacheSize = (int)(sqlite3PcacheSize());
    uint szPageDflt = (uint)(4096);
    sbyte* zUri = null;
    int nUriByte = (int)(1);
    int nUri = (int)(0);
    journalFileSize = (int)(((sqlite3JournalSize(pVfs)) + 7) &amp; ~7);
    ppPager = null;
    if ((flags &amp; 0x0002) != 0)
    {
        memDb = (int)(1);
        if (((zFilename) != null) &amp;&amp; ((zFilename[0]) != 0))
        {
            zPathname = sqlite3DbStrDup(null, zFilename);
            if ((zPathname) == (null))
                return (int)(7);
            nPathname = (int)(sqlite3Strlen30(zPathname));
            zFilename = null;
        }
    }

    if (((zFilename) != null) &amp;&amp; ((zFilename[0]) != 0))
    {
        sbyte* z;
        nPathname = (int)(pVfs.mxPathname + 1);
        zPathname = sqlite3DbMallocRaw(null, (ulong)(nPathname * 2));
        if ((zPathname) == (null))
        {
            return (int)(7);
        }

        zPathname[0] = (sbyte)(0);
        rc = (int)(sqlite3OsFullPathname(pVfs, zFilename, (int)(nPathname), zPathname));
        if (rc != 0)
        {
            if ((rc) == (0 | (2 &lt;&lt; 8)))
            {
                if ((vfsFlags &amp; 0x01000000) != 0)
                {
                    rc = (int)(14 | (6 &lt;&lt; 8));
                }
                else
                {
                    rc = (int)(0);
                }
            }
        }

        nPathname = (int)(sqlite3Strlen30(zPathname));
        z = zUri = &amp;zFilename[sqlite3Strlen30(zFilename) + 1];
        while ((*z) != 0)
        {
            z += CRuntime.strlen(z) + 1;
            z += CRuntime.strlen(z) + 1;
            nUri++;
        }

        nUriByte = ((int)(&amp;z[1] - zUri));
        if (((rc) == (0)) &amp;&amp; ((nPathname + 8) &gt; (pVfs.mxPathname)))
        {
            rc = (int)(sqlite3CantopenError((int)(57974)));
        }

        if (rc != 0)
        {
            sqlite3DbFree(null, zPathname);
            return (int)(rc);
        }
    }

    pPtr = (byte*)(sqlite3MallocZero((ulong)((((sizeof(Pager)) + 7) &amp; ~7) + (((pcacheSize) + 7) &amp; ~7) + (((pVfs.szOsFile) + 7) &amp; ~7) + journalFileSize * 2 + sizeof(Pager) + 4 + nPathname + 1 + nUriByte + nPathname + 8 + 1 + nPathname + 4 + 1 + 3)));
    if (pPtr == null)
    {
        sqlite3DbFree(null, zPathname);
        return (int)(7);
    }

    pPager = (Pager)(pPtr);
    pPtr += (((sizeof(Pager)) + 7) &amp; ~7);
    pPager.pPCache = (PCache)(pPtr);
    pPtr += (((pcacheSize) + 7) &amp; ~7);
    pPager.fd = (sqlite3_file)(pPtr);
    pPtr += (((pVfs.szOsFile) + 7) &amp; ~7);
    pPager.sjfd = (sqlite3_file)(pPtr);
    pPtr += journalFileSize;
    pPager.jfd = (sqlite3_file)(pPtr);
    pPtr += journalFileSize;
    CRuntime.memcpy(pPtr, pPager, (ulong)(sizeof(Pager)));
    pPtr += sizeof(Pager);
    pPtr += 4;
    pPager.zFilename = (sbyte*)(pPtr);
    if ((nPathname) &gt; (0))
    {
        CRuntime.memcpy(pPtr, zPathname, (ulong)(nPathname));
        pPtr += nPathname + 1;
        if ((zUri) != null)
        {
            CRuntime.memcpy(pPtr, zUri, (ulong)(nUriByte));
            pPtr += nUriByte;
        }
        else
        {
            pPtr++;
        }
    }

    if ((nPathname) &gt; (0))
    {
        pPager.zJournal = (sbyte*)(pPtr);
        CRuntime.memcpy(pPtr, zPathname, (ulong)(nPathname));
        pPtr += nPathname;
        CRuntime.memcpy(pPtr, "-journal", (ulong)(8));
        pPtr += 8 + 1;
    }
    else
    {
        pPager.zJournal = null;
    }

    if ((nPathname) &gt; (0))
    {
        pPager.zWal = (sbyte*)(pPtr);
        CRuntime.memcpy(pPtr, zPathname, (ulong)(nPathname));
        pPtr += nPathname;
        CRuntime.memcpy(pPtr, "-wal", (ulong)(4));
        pPtr += 4 + 1;
    }
    else
    {
        pPager.zWal = null;
    }

    (void)(pPtr);
    if ((nPathname) != 0)
        sqlite3DbFree(null, zPathname);
    pPager.pVfs = pVfs;
    pPager.vfsFlags = (uint)(vfsFlags);
    if (((zFilename) != null) &amp;&amp; ((zFilename[0]) != 0))
    {
        int fout = (int)(0);
        rc = (int)(sqlite3OsOpen(pVfs, pPager.zFilename, pPager.fd, (int)(vfsFlags), &amp;fout));
        pPager.memVfs = (byte)(memJM = (int)((fout &amp; 0x00000080) != 0));
        readOnly = (int)((fout &amp; 0x00000001) != 0);
        if ((rc) == (0))
        {
            int iDc = (int)(sqlite3OsDeviceCharacteristics(pPager.fd));
            if (readOnly == 0)
            {
                setSectorSize(pPager);
                if ((szPageDflt) &lt; (pPager.sectorSize))
                {
                    if ((pPager.sectorSize) &gt; (8192))
                    {
                        szPageDflt = (uint)(8192);
                    }
                    else
                    {
                        szPageDflt = (uint)(pPager.sectorSize);
                    }
                }
            }

            pPager.noLock = (byte)(sqlite3_uri_boolean(pPager.zFilename, "nolock", (int)(0)));
            if (((iDc &amp; 0x00002000) != 0) || ((sqlite3_uri_boolean(pPager.zFilename, "immutable", (int)(0))) != 0))
            {
                vfsFlags |= (int)(0x00000001);
                goto act_like_temp_file;
            }
        }
    }
    else
    {
        act_like_temp_file:
            ;
        tempFile = (int)(1);
        pPager.eState = (byte)(1);
        pPager.eLock = (byte)(4);
        pPager.noLock = (byte)(1);
        readOnly = (int)(vfsFlags &amp; 0x00000001);
    }

    if ((rc) == (0))
    {
        rc = (int)(sqlite3PagerSetPagesize(pPager, &amp;szPageDflt, (int)(-1)));
    }

    if ((rc) == (0))
    {
        nExtra = (int)(((nExtra) + 7) &amp; ~7);
        rc = (int)(sqlite3PcacheOpen((int)(szPageDflt), (int)(nExtra), (int)(!memDb), (!memDb) != 0 ? pagerStress : null, (void*)(pPager), pPager.pPCache));
    }

    if (rc != 0)
    {
        sqlite3OsClose(pPager.fd);
        sqlite3PageFree(pPager.pTmpSpace);
        sqlite3_free(pPager);
        return (int)(rc);
    }

    pPager.useJournal = ((byte)(useJournal));
    pPager.mxPgno = (uint)(1073741823);
    pPager.tempFile = ((byte)(tempFile));
    pPager.exclusiveMode = ((byte)(tempFile));
    pPager.changeCountDone = (byte)(pPager.tempFile);
    pPager.memDb = ((byte)(memDb));
    pPager.readOnly = ((byte)(readOnly));
    pPager.noSync = (byte)(pPager.tempFile);
    if ((pPager.noSync) != 0)
    {
    }
    else
    {
        pPager.fullSync = (byte)(1);
        pPager.extraSync = (byte)(0);
        pPager.syncFlags = (byte)(0x00002);
        pPager.walSyncFlags = (byte)(0x00002 | (0x00002 &lt;&lt; 2));
    }

    pPager.nExtra = ((ushort)(nExtra));
    pPager.journalSizeLimit = (long)(-1);
    setSectorSize(pPager);
    if (useJournal == 0)
    {
        pPager.journalMode = (byte)(2);
    }
    else if (((memDb) != 0) || ((memJM) != 0))
    {
        pPager.journalMode = (byte)(4);
    }

    pPager.xReiniter = xReinit;
    setGetterMethod(pPager);
    ppPager = pPager;
    return (int)(0);
}</function>
  <function>public static int sqlite3PagerOpenSavepoint(Pager pPager, int nSavepoint)
{
    if (((nSavepoint) &gt; (pPager.nSavepoint)) &amp;&amp; ((pPager.useJournal) != 0))
    {
        return (int)(pagerOpenSavepoint(pPager, (int)(nSavepoint)));
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static int sqlite3PagerOpenWal(Pager pPager, int* pbOpen)
{
    int rc = (int)(0);
    if ((pPager.tempFile == 0) &amp;&amp; (pPager.pWal == null))
    {
        if (sqlite3PagerWalSupported(pPager) == 0)
            return (int)(14);
        sqlite3OsClose(pPager.jfd);
        rc = (int)(pagerOpenWal(pPager));
        if ((rc) == (0))
        {
            pPager.journalMode = (byte)(5);
            pPager.eState = (byte)(0);
        }
    }
    else
    {
        *pbOpen = (int)(1);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3PagerPagecount(Pager pPager, int* pnPage)
{
    *pnPage = ((int)(pPager.dbSize));
}</function>
  <function>public static int sqlite3PagerPageRefcount(PgHdr pPage)
{
    return (int)(sqlite3PcachePageRefcount(pPage));
}</function>
  <function>public static int sqlite3PagerReadFileheader(Pager pPager, int N, byte* pDest)
{
    int rc = (int)(0);
    CRuntime.memset(pDest, (int)(0), (ulong)(N));
    if (((pPager.fd).pMethods != null))
    {
        rc = (int)(sqlite3OsRead(pPager.fd, pDest, (int)(N), (long)(0)));
        if ((rc) == (10 | (2 &lt;&lt; 8)))
        {
            rc = (int)(0);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3PagerRef(PgHdr pPg)
{
    sqlite3PcacheRef(pPg);
}</function>
  <function>public static void sqlite3PagerRekey(PgHdr pPg, uint iNew, ushort flags)
{
    pPg.flags = (ushort)(flags);
    sqlite3PcacheMove(pPg, (uint)(iNew));
}</function>
  <function>public static int sqlite3PagerRollback(Pager pPager)
{
    int rc = (int)(0);
    if ((pPager.eState) == (6))
        return (int)(pPager.errCode);
    if ((pPager.eState) &lt;= (1))
        return (int)(0);
    if (((pPager).pWal != null))
    {
        int rc2 = 0;
        rc = (int)(sqlite3PagerSavepoint(pPager, (int)(2), (int)(-1)));
        rc2 = (int)(pager_end_transaction(pPager, (int)(pPager.setSuper), (int)(0)));
        if ((rc) == (0))
            rc = (int)(rc2);
    }
    else if ((!((pPager.jfd).pMethods != null)) || ((pPager.eState) == (2)))
    {
        int eState = (int)(pPager.eState);
        rc = (int)(pager_end_transaction(pPager, (int)(0), (int)(0)));
        if ((pPager.memDb == 0) &amp;&amp; ((eState) &gt; (2)))
        {
            pPager.errCode = (int)(4);
            pPager.eState = (byte)(6);
            setGetterMethod(pPager);
            return (int)(rc);
        }
    }
    else
    {
        rc = (int)(pager_playback(pPager, (int)(0)));
    }

    return (int)(pager_error(pPager, (int)(rc)));
}</function>
  <function>public static int sqlite3PagerSavepoint(Pager pPager, int op, int iSavepoint)
{
    int rc = (int)(pPager.errCode);
    if (((rc) == (0)) &amp;&amp; ((iSavepoint) &lt; (pPager.nSavepoint)))
    {
        int ii = 0;
        int nNew = 0;
        nNew = (int)(iSavepoint + (((op) == (1)) ? 0 : 1));
        for (ii = (int)(nNew); (ii) &lt; (pPager.nSavepoint); ii++)
        {
            sqlite3BitvecDestroy(pPager.aSavepoint[ii].pInSavepoint);
        }

        pPager.nSavepoint = (int)(nNew);
        if ((op) == (1))
        {
            PagerSavepoint* pRel = &amp;pPager.aSavepoint[nNew];
            if (((pRel-&gt;bTruncateOnRelease) != 0) &amp;&amp; ((pPager.sjfd).pMethods != null))
            {
                if ((sqlite3JournalIsInMemory(pPager.sjfd)) != 0)
                {
                    long sz = (long)((pPager.pageSize + 4) * (long)(pRel-&gt;iSubRec));
                    rc = (int)(sqlite3OsTruncate(pPager.sjfd, (long)(sz)));
                }

                pPager.nSubRec = (uint)(pRel-&gt;iSubRec);
            }
        }
        else if (((pPager).pWal != null) || ((pPager.jfd).pMethods != null))
        {
            PagerSavepoint* pSavepoint = ((nNew) == (0)) ? null : &amp;pPager.aSavepoint[nNew - 1];
            rc = (int)(pagerPlaybackSavepoint(pPager, pSavepoint));
        }
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3PagerSetBusyHandler(Pager pPager, delegate19 xBusyHandler, void* pBusyHandlerArg)
{
    void** ap;
    pPager.xBusyHandler = xBusyHandler;
    pPager.pBusyHandlerArg = pBusyHandlerArg;
    ap = (void**)(&amp;pPager.xBusyHandler);
    sqlite3OsFileControlHint(pPager.fd, (int)(15), (void*)(ap));
}</function>
  <function>public static void sqlite3PagerSetCachesize(Pager pPager, int mxPage)
{
    sqlite3PcacheSetCachesize(pPager.pPCache, (int)(mxPage));
}</function>
  <function>public static void sqlite3PagerSetFlags(Pager pPager, uint pgFlags)
{
    uint level = (uint)(pgFlags &amp; 0x07);
    if ((pPager.tempFile) != 0)
    {
        pPager.noSync = (byte)(1);
        pPager.fullSync = (byte)(0);
        pPager.extraSync = (byte)(0);
    }
    else
    {
        pPager.noSync = (byte)((level) == (0x01) ? 1 : 0);
        pPager.fullSync = (byte)((level) &gt;= (0x03) ? 1 : 0);
        pPager.extraSync = (byte)((level) == (0x04) ? 1 : 0);
    }

    if ((pPager.noSync) != 0)
    {
        pPager.syncFlags = (byte)(0);
    }
    else if ((pgFlags &amp; 0x08) != 0)
    {
        pPager.syncFlags = (byte)(0x00003);
    }
    else
    {
        pPager.syncFlags = (byte)(0x00002);
    }

    pPager.walSyncFlags = (byte)(pPager.syncFlags &lt;&lt; 2);
    if ((pPager.fullSync) != 0)
    {
        pPager.walSyncFlags |= (byte)(pPager.syncFlags);
    }

    if (((pgFlags &amp; 0x10) != 0) &amp;&amp; (pPager.noSync == 0))
    {
        pPager.walSyncFlags |= (byte)(0x00003 &lt;&lt; 2);
    }

    if ((pgFlags &amp; 0x20) != 0)
    {
        pPager.doNotSpill &amp;= (byte)(~0x01);
    }
    else
    {
        pPager.doNotSpill |= (byte)(0x01);
    }
}</function>
  <function>public static int sqlite3PagerSetJournalMode(Pager pPager, int eMode)
{
    byte eOld = (byte)(pPager.journalMode);
    if ((pPager.memDb) != 0)
    {
        if ((eMode != 4) &amp;&amp; (eMode != 2))
        {
            eMode = (int)(eOld);
        }
    }

    if (eMode != eOld)
    {
        pPager.journalMode = ((byte)(eMode));
        if (((pPager.exclusiveMode == 0) &amp;&amp; ((eOld &amp; 5) == (1))) &amp;&amp; ((eMode &amp; 1) == (0)))
        {
            sqlite3OsClose(pPager.jfd);
            if ((pPager.eLock) &gt;= (2))
            {
                sqlite3OsDelete(pPager.pVfs, pPager.zJournal, (int)(0));
            }
            else
            {
                int rc = (int)(0);
                int state = (int)(pPager.eState);
                if ((state) == (0))
                {
                    rc = (int)(sqlite3PagerSharedLock(pPager));
                }

                if ((pPager.eState) == (1))
                {
                    rc = (int)(pagerLockDb(pPager, (int)(2)));
                }

                if ((rc) == (0))
                {
                    sqlite3OsDelete(pPager.pVfs, pPager.zJournal, (int)(0));
                }

                if (((rc) == (0)) &amp;&amp; ((state) == (1)))
                {
                    pagerUnlockDb(pPager, (int)(1));
                }
                else if ((state) == (0))
                {
                    pager_unlock(pPager);
                }
            }
        }
        else if ((eMode) == (2))
        {
            sqlite3OsClose(pPager.jfd);
        }
    }

    return (int)(pPager.journalMode);
}</function>
  <function>public static void sqlite3PagerSetMmapLimit(Pager pPager, long szMmap)
{
    pPager.szMmap = (long)(szMmap);
    pagerFixMaplimit(pPager);
}</function>
  <function>public static int sqlite3PagerSetPagesize(Pager pPager, uint* pPageSize, int nReserve)
{
    int rc = (int)(0);
    uint pageSize = (uint)(*pPageSize);
    if ((((((pPager.memDb) == (0)) || ((pPager.dbSize) == (0))) &amp;&amp; ((sqlite3PcacheRefCount(pPager.pPCache)) == (0))) &amp;&amp; ((pageSize) != 0)) &amp;&amp; (pageSize != (uint)(pPager.pageSize)))
    {
        sbyte* pNew = null;
        long nByte = (long)(0);
        if (((pPager.eState) &gt; (0)) &amp;&amp; ((pPager.fd).pMethods != null))
        {
            rc = (int)(sqlite3OsFileSize(pPager.fd, &amp;nByte));
        }

        if ((rc) == (0))
        {
            pNew = (sbyte*)(sqlite3PageMalloc((int)(pageSize + 8)));
            if (pNew == null)
            {
                rc = (int)(7);
            }
            else
            {
                CRuntime.memset(pNew + pageSize, (int)(0), (ulong)(8));
            }
        }

        if ((rc) == (0))
        {
            pager_reset(pPager);
            rc = (int)(sqlite3PcacheSetPageSize(pPager.pPCache, (int)(pageSize)));
        }

        if ((rc) == (0))
        {
            sqlite3PageFree(pPager.pTmpSpace);
            pPager.pTmpSpace = pNew;
            pPager.dbSize = ((uint)((nByte + pageSize - 1) / pageSize));
            pPager.pageSize = (long)(pageSize);
        }
        else
        {
            sqlite3PageFree(pNew);
        }
    }

    *pPageSize = (uint)(pPager.pageSize);
    if ((rc) == (0))
    {
        if ((nReserve) &lt; (0))
            nReserve = (int)(pPager.nReserve);
        pPager.nReserve = ((short)(nReserve));
        pagerFixMaplimit(pPager);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3PagerSetSpillsize(Pager pPager, int mxPage)
{
    return (int)(sqlite3PcacheSetSpillsize(pPager.pPCache, (int)(mxPage)));
}</function>
  <function>public static int sqlite3PagerSharedLock(Pager pPager)
{
    int rc = (int)(0);
    if ((!((pPager).pWal != null)) &amp;&amp; ((pPager.eState) == (0)))
    {
        int bHotJournal = (int)(1);
        rc = (int)(pager_wait_on_lock(pPager, (int)(1)));
        if (rc != 0)
        {
            goto failed;
        }

        if ((pPager.eLock) &lt;= (1))
        {
            rc = (int)(hasHotJournal(pPager, &amp;bHotJournal));
        }

        if (rc != 0)
        {
            goto failed;
        }

        if ((bHotJournal) != 0)
        {
            if ((pPager.readOnly) != 0)
            {
                rc = (int)(8 | (3 &lt;&lt; 8));
                goto failed;
            }

            rc = (int)(pagerLockDb(pPager, (int)(4)));
            if (rc != 0)
            {
                goto failed;
            }

            if ((!((pPager.jfd).pMethods != null)) &amp;&amp; (pPager.journalMode != 2))
            {
                sqlite3_vfs pVfs = pPager.pVfs;
                int bExists = 0;
                rc = (int)(sqlite3OsAccess(pVfs, pPager.zJournal, (int)(0), &amp;bExists));
                if (((rc) == (0)) &amp;&amp; ((bExists) != 0))
                {
                    int fout = (int)(0);
                    int f = (int)(0x00000002 | 0x00000800);
                    rc = (int)(sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, (int)(f), &amp;fout));
                    if (((rc) == (0)) &amp;&amp; ((fout &amp; 0x00000001) != 0))
                    {
                        rc = (int)(sqlite3CantopenError((int)(58504)));
                        sqlite3OsClose(pPager.jfd);
                    }
                }
            }

            if (((pPager.jfd).pMethods != null))
            {
                rc = (int)(pagerSyncHotJournal(pPager));
                if ((rc) == (0))
                {
                    rc = (int)(pager_playback(pPager, (int)(!pPager.tempFile)));
                    pPager.eState = (byte)(0);
                }
            }
            else if (pPager.exclusiveMode == 0)
            {
                pagerUnlockDb(pPager, (int)(1));
            }

            if (rc != 0)
            {
                pager_error(pPager, (int)(rc));
                goto failed;
            }
        }

        if ((pPager.tempFile == 0) &amp;&amp; ((pPager.hasHeldSharedLock) != 0))
        {
            sbyte* dbFileVers = stackalloc sbyte[16];
            rc = (int)(sqlite3OsRead(pPager.fd, &amp;dbFileVers, (int)(16 * sizeof(sbyte)), (long)(24)));
            if (rc != 0)
            {
                if (rc != (10 | (2 &lt;&lt; 8)))
                {
                    goto failed;
                }

                CRuntime.memset(dbFileVers, (int)(0), (ulong)(16 * sizeof(sbyte)));
            }

            if (memcmp(pPager.dbFileVers, dbFileVers, (ulong)(16 * sizeof(sbyte))) != 0)
            {
                pager_reset(pPager);
                if (((pPager).bUseFetch) != 0)
                {
                    sqlite3OsUnfetch(pPager.fd, (long)(0), null);
                }
            }
        }

        rc = (int)(pagerOpenWalIfPresent(pPager));
    }

    if (((pPager).pWal != null))
    {
        rc = (int)(pagerBeginReadTransaction(pPager));
    }

    if ((((pPager.tempFile) == (0)) &amp;&amp; ((pPager.eState) == (0))) &amp;&amp; ((rc) == (0)))
    {
        rc = (int)(pagerPagecount(pPager, &amp;pPager.dbSize));
    }

    failed:
        ; if  ( rc != 0 ) { pager_unlock ( pPager ) ;  } else  { pPager . eState  =  ( byte ) ( 1 ) ;  pPager . hasHeldSharedLock  =  ( byte ) ( 1 ) ;  }
    return (int)(rc);
}</function>
  <function>public static void sqlite3PagerShrink(Pager pPager)
{
    sqlite3PcacheShrink(pPager.pPCache);
}</function>
  <function>public static int sqlite3PagerSync(Pager pPager, sbyte* zSuper)
{
    int rc = (int)(0);
    void* pArg = (void*)(zSuper);
    rc = (int)(sqlite3OsFileControl(pPager.fd, (int)(21), pArg));
    if ((rc) == (12))
        rc = (int)(0);
    if (((rc) == (0)) &amp;&amp; (pPager.noSync == 0))
    {
        rc = (int)(sqlite3OsSync(pPager.fd, (int)(pPager.syncFlags)));
    }

    return (int)(rc);
}</function>
  <function>public static void* sqlite3PagerTempSpace(Pager pPager)
{
    return pPager.pTmpSpace;
}</function>
  <function>public static void sqlite3PagerTruncateImage(Pager pPager, uint nPage)
{
    pPager.dbSize = (uint)(nPage);
}</function>
  <function>public static void sqlite3PagerUnref(PgHdr pPg)
{
    if ((pPg) != null)
        sqlite3PagerUnrefNotNull(pPg);
}</function>
  <function>public static void sqlite3PagerUnrefNotNull(PgHdr pPg)
{
    if ((pPg.flags &amp; 0x020) != 0)
    {
        pagerReleaseMapPage(pPg);
    }
    else
    {
        sqlite3PcacheRelease(pPg);
    }
}</function>
  <function>public static void sqlite3PagerUnrefPageOne(PgHdr pPg)
{
    Pager pPager;
    pPager = pPg.pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
}</function>
  <function>public static sqlite3_vfs sqlite3PagerVfs(Pager pPager)
{
    return pPager.pVfs;
}</function>
  <function>public static int sqlite3PagerWalCallback(Pager pPager)
{
    return (int)(sqlite3WalCallback(pPager.pWal));
}</function>
  <function>public static int sqlite3PagerWalSupported(Pager pPager)
{
    sqlite3_io_methods pMethods = pPager.fd.pMethods;
    if ((pPager.noLock) != 0)
        return (int)(0);
    return (((pPager.exclusiveMode) != 0) || (((pMethods.iVersion) &gt;= (2)) &amp;&amp; ((pMethods.xShmMap) != null)) ? 1 : 0);
}</function>
  <function>public static int sqlite3PagerWrite(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    if (((pPg.flags &amp; 0x004) != 0) &amp;&amp; ((pPager.dbSize) &gt;= (pPg.pgno)))
    {
        if ((pPager.nSavepoint) != 0)
            return (int)(subjournalPageIfRequired(pPg));
        return (int)(0);
    }
    else if ((pPager.errCode) != 0)
    {
        return (int)(pPager.errCode);
    }
    else if ((pPager.sectorSize) &gt; ((uint)(pPager.pageSize)))
    {
        return (int)(pagerWriteLargeSector(pPg));
    }
    else
    {
        return (int)(pager_write(pPg));
    }
}</function>
  <function>public static void sqlite3ParseObjectInit(Parse pParse, sqlite3 db)
{
    CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&amp;((0).zErrMsg)))), (int)(0), (ulong)(((ulong)(&amp;((0).aTempReg))) - ((ulong)(&amp;((0).zErrMsg)))));
    CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&amp;((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&amp;((0).sLastToken)))));
    pParse.pOuterParse = db.pParse;
    db.pParse = pParse;
    pParse.db = db;
    if ((db.mallocFailed) != 0)
        sqlite3ErrorMsg(pParse, "out of memory");
}</function>
  <function>public static void sqlite3ParseObjectReset(Parse pParse)
{
    sqlite3 db = pParse.db;
    sqlite3DbFree(db, pParse.aTableLock);
    while ((pParse.pCleanup) != null)
    {
        ParseCleanup pCleanup = pParse.pCleanup;
        pParse.pCleanup = pCleanup.pNext;
        pCleanup.xCleanup(db, pCleanup.pPtr);
        sqlite3DbFreeNN(db, pCleanup);
    }

    sqlite3DbFree(db, pParse.aLabel);
    if ((pParse.pConstExpr) != null)
    {
        sqlite3ExprListDelete(db, pParse.pConstExpr);
    }

    db.lookaside.bDisable -= (uint)(pParse.disableLookaside);
    db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
    db.pParse = pParse.pOuterParse;
    pParse.db = null;
    pParse.disableLookaside = (byte)(0);
}</function>
  <function>public static void sqlite3Parser(void* yyp, int yymajor, Token yyminor)
{
    YYMINORTYPE yyminorunion = new YYMINORTYPE();
    ushort yyact = 0;
    yyParser yypParser = (yyParser)(yyp);
    Parse pParse = yypParser.pParse;
    yyact = (ushort)(yypParser.yytos-&gt;stateno);
    while ((1) != 0)
    {
        yyact = (ushort)(yy_find_shift_action((ushort)(yymajor), (ushort)(yyact)));
        if ((yyact) &gt;= (1236))
        {
            uint yyruleno = (uint)(yyact - 1236);
            if ((yyRuleInfoNRhs[yyruleno]) == (0))
            {
                if ((yypParser.yytos) &gt;= (yypParser.yystackEnd))
                {
                    yyStackOverflow(yypParser);
                    break;
                }
            }

            yyact = (ushort)(yy_reduce(yypParser, (uint)(yyruleno), (int)(yymajor), (Token)(yyminor), pParse));
        }
        else if ((yyact) &lt;= (1232))
        {
            yy_shift(yypParser, (ushort)(yyact), (ushort)(yymajor), (Token)(yyminor));
            break;
        }
        else if ((yyact) == (1234))
        {
            yypParser.yytos--;
            yy_accept(yypParser);
            return;
        }
        else
        {
            yyminorunion.yy0 = (Token)(yyminor);
            yy_syntax_error(yypParser, (int)(yymajor), (Token)(yyminor));
            yy_destructor(yypParser, (ushort)(yymajor), &amp;yyminorunion);
            break;
        }
    }

    return;
}</function>
  <function>public static void* sqlite3ParserAddCleanup(Parse pParse, delegate71 xCleanup, void* pPtr)
{
    ParseCleanup pCleanup = sqlite3DbMallocRaw(pParse.db, (ulong)(sizeof(ParseCleanup)));
    if ((pCleanup) != null)
    {
        pCleanup.pNext = pParse.pCleanup;
        pParse.pCleanup = pCleanup;
        pCleanup.pPtr = pPtr;
        pCleanup.xCleanup = xCleanup;
    }
    else
    {
        xCleanup(pParse.db, pPtr);
        pPtr = null;
    }

    return pPtr;
}</function>
  <function>public static int sqlite3ParserFallback(int iToken)
{
    return (int)(yyFallback[iToken]);
}</function>
  <function>public static void sqlite3ParserFinalize(void* p)
{
    yyParser pParser = (yyParser)(p);
    while ((pParser.yytos) &gt; (pParser.yystack))
    {
        yy_pop_parser_stack(pParser);
    }
}</function>
  <function>public static void sqlite3ParserInit(void* yypRawParser, Parse pParse)
{
    yyParser yypParser = (yyParser)(yypRawParser);
    yypParser.pParse = pParse;
    yypParser.yytos = yypParser.yystack;
    yypParser.yystack[0].stateno = (ushort)(0);
    yypParser.yystack[0].major = (ushort)(0);
    yypParser.yystackEnd = &amp;yypParser.yystack[100 - 1];
}</function>
  <function>public static int sqlite3ParseUri(sbyte* zDefaultVfs, sbyte* zUri, uint* pFlags, sqlite3_vfs ppVfs, sbyte** pzFile, sbyte** pzErrMsg)
{
    int rc = (int)(0);
    uint flags = (uint)(*pFlags);
    sbyte* zVfs = zDefaultVfs;
    sbyte* zFile;
    sbyte c = 0;
    int nUri = (int)(sqlite3Strlen30(zUri));
    if (((((flags &amp; 0x00000040) != 0) || ((sqlite3Config.bOpenUri) != 0)) &amp;&amp; ((nUri) &gt;= (5))) &amp;&amp; ((memcmp(zUri, "file:", (ulong)(5))) == (0)))
    {
        sbyte* zOpt;
        int eState = 0;
        int iIn = 0;
        int iOut = (int)(0);
        ulong nByte = (ulong)(nUri + 8);
        flags |= (uint)(0x00000040);
        for (iIn = (int)(0); (iIn) &lt; (nUri); iIn++)
        {
            nByte += (ulong)((zUri[iIn]) == (38));
        }

        zFile = sqlite3_malloc64((ulong)(nByte));
        if (zFile == null)
            return (int)(7);
        CRuntime.memset(zFile, (int)(0), (ulong)(4));
        zFile += 4;
        iIn = (int)(5);
        if (((zUri[5]) == (47)) &amp;&amp; ((zUri[6]) == (47)))
        {
            iIn = (int)(7);
            while (((zUri[iIn]) != 0) &amp;&amp; (zUri[iIn] != 47))
            {
                iIn++;
            }

            if ((iIn != 7) &amp;&amp; ((iIn != 16) || ((memcmp("localhost", &amp;zUri[7], (ulong)(9))) != 0)))
            {
                *pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s", (int)(iIn - 7), &amp;zUri[7]);
                rc = (int)(1);
                goto parse_uri_out;
            }
        }

        eState = (int)(0);
        while (((c = (sbyte)(zUri[iIn])) != 0) &amp;&amp; (c != 35))
        {
            iIn++;
            if ((((c) == (37)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zUri[iIn])] &amp; 0x08) != 0)) &amp;&amp; ((sqlite3CtypeMap[(byte)(zUri[iIn + 1])] &amp; 0x08) != 0))
            {
                int octet = (int)(sqlite3HexToInt((int)(zUri[iIn++])) &lt;&lt; 4);
                octet += (int)(sqlite3HexToInt((int)(zUri[iIn++])));
                if ((octet) == (0))
                {
                    while ((((((c = (sbyte)(zUri[iIn])) != 0) &amp;&amp; (c != 35)) &amp;&amp; ((eState != 0) || (c != 63))) &amp;&amp; ((eState != 1) || ((c != 61) &amp;&amp; (c != 38)))) &amp;&amp; ((eState != 2) || (c != 38)))
                    {
                        iIn++;
                    }

                    continue;
                }

                c = (sbyte)(octet);
            }
            else if (((eState) == (1)) &amp;&amp; (((c) == (38)) || ((c) == (61))))
            {
                if ((zFile[iOut - 1]) == (0))
                {
                    while ((((zUri[iIn]) != 0) &amp;&amp; (zUri[iIn] != 35)) &amp;&amp; (zUri[iIn - 1] != 38))
                    {
                        iIn++;
                    }

                    continue;
                }

                if ((c) == (38))
                {
                    zFile[iOut++] = (sbyte)(0);
                }
                else
                {
                    eState = (int)(2);
                }

                c = (sbyte)(0);
            }
            else if ((((eState) == (0)) &amp;&amp; ((c) == (63))) || (((eState) == (2)) &amp;&amp; ((c) == (38))))
            {
                c = (sbyte)(0);
                eState = (int)(1);
            }

            zFile[iOut++] = (sbyte)(c);
        }

        if ((eState) == (1))
            zFile[iOut++] = (sbyte)(0);
        CRuntime.memset(zFile + iOut, (int)(0), (ulong)(4));
        zOpt = &amp;zFile[sqlite3Strlen30(zFile) + 1];
        while ((zOpt[0]) != 0)
        {
            int nOpt = (int)(sqlite3Strlen30(zOpt));
            sbyte* zVal = &amp;zOpt[nOpt + 1];
            int nVal = (int)(sqlite3Strlen30(zVal));
            if (((nOpt) == (3)) &amp;&amp; ((memcmp("vfs", zOpt, (ulong)(3))) == (0)))
            {
                zVfs = zVal;
            }
            else
            {
                OpenMode* aMode = null;
                sbyte* zModeType = null;
                int mask = (int)(0);
                int limit = (int)(0);
                if (((nOpt) == (5)) &amp;&amp; ((memcmp("cache", zOpt, (ulong)(5))) == (0)))
                {
                    mask = (int)(0x00020000 | 0x00040000);
                    aMode = sqlite3ParseUri_aCacheMode;
                    limit = (int)(mask);
                    zModeType = "cache";
                }

                if (((nOpt) == (4)) &amp;&amp; ((memcmp("mode", zOpt, (ulong)(4))) == (0)))
                {
                    mask = (int)(0x00000001 | 0x00000002 | 0x00000004 | 0x00000080);
                    aMode = sqlite3ParseUri_aOpenMode;
                    limit = (int)(mask &amp; flags);
                    zModeType = "access";
                }

                if ((aMode) != null)
                {
                    int i = 0;
                    int mode = (int)(0);
                    for (i = (int)(0); aMode[i].z; i++)
                    {
                        sbyte* z = aMode[i].z;
                        if (((nVal) == (sqlite3Strlen30(z))) &amp;&amp; ((0) == (memcmp(zVal, z, (ulong)(nVal)))))
                        {
                            mode = (int)(aMode[i].mode);
                            break;
                        }
                    }

                    if ((mode) == (0))
                    {
                        *pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
                        rc = (int)(1);
                        goto parse_uri_out;
                    }

                    if ((mode &amp; ~0x00000080) &gt; (limit))
                    {
                        *pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s", zModeType, zVal);
                        rc = (int)(3);
                        goto parse_uri_out;
                    }

                    flags = (uint)((flags &amp; ~mask) | mode);
                }
            }

            zOpt = &amp;zVal[nVal + 1];
        }
    }
    else
    {
        zFile = sqlite3_malloc64((ulong)(nUri + 8));
        if (zFile == null)
            return (int)(7);
        CRuntime.memset(zFile, (int)(0), (ulong)(4));
        zFile += 4;
        if ((nUri) != 0)
        {
            CRuntime.memcpy(zFile, zUri, (ulong)(nUri));
        }

        CRuntime.memset(zFile + nUri, (int)(0), (ulong)(4));
        flags &amp;= (uint)(~0x00000040);
    }

    ppVfs = sqlite3_vfs_find(zVfs);
    if ((ppVfs) == (null))
    {
        *pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
        rc = (int)(1);
    }

    parse_uri_out:
        ; if  ( rc != 0 ) { sqlite3_free_filename ( zFile ) ;  zFile  =  null ;  }
    *pFlags = (uint)(flags);
    *pzFile = zFile;
    return (int)(rc);
}</function>
  <function>public static sqlite3_mutex* sqlite3Pcache1Mutex()
{
    return (pcache1_g).mutex;
}</function>
  <function>public static void sqlite3PCacheBufferSetup(void* pBuf, int sz, int n)
{
    if (((pcache1_g).isInit) != 0)
    {
        PgFreeslot* p;
        if ((pBuf) == (null))
            sz = (int)(n = (int)(0));
        if ((n) == (0))
            sz = (int)(0);
        sz = (int)((sz) &amp; ~7);
        (pcache1_g).szSlot = (int)(sz);
        (pcache1_g).nSlot = (int)((pcache1_g).nFreeSlot = (int)(n));
        (pcache1_g).nReserve = (int)((n) &gt; (90) ? 10 : (n / 10 + 1));
        (pcache1_g).pStart = pBuf;
        (pcache1_g).pFree = null;
        (pcache1_g).bUnderPressure = (int)(0);
        while ((n--) != 0)
        {
            p = (PgFreeslot*)(pBuf);
            p-&gt;pNext = (pcache1_g).pFree;
            (pcache1_g).pFree = p;
            pBuf = (void*)(&amp;((sbyte*)(pBuf))[sz]);
        }

        (pcache1_g).pEnd = pBuf;
    }
}</function>
  <function>public static void sqlite3PcacheCleanAll(PCache pCache)
{
    PgHdr p;
    while ((p = pCache.pDirty) != null)
    {
        sqlite3PcacheMakeClean(p);
    }
}</function>
  <function>public static void sqlite3PcacheClear(PCache pCache)
{
    sqlite3PcacheTruncate(pCache, (uint)(0));
}</function>
  <function>public static void sqlite3PcacheClearSyncFlags(PCache pCache)
{
    PgHdr p;
    for (p = pCache.pDirty; p; p = p.pDirtyNext)
    {
        p.flags &amp;= (ushort)(~0x008);
    }

    pCache.pSynced = pCache.pDirtyTail;
}</function>
  <function>public static void sqlite3PcacheClearWritable(PCache pCache)
{
    PgHdr p;
    for (p = pCache.pDirty; p; p = p.pDirtyNext)
    {
        p.flags &amp;= (ushort)(~(0x008 | 0x004));
    }

    pCache.pSynced = pCache.pDirtyTail;
}</function>
  <function>public static void sqlite3PcacheClose(PCache pCache)
{
    sqlite3Config.pcache2.xDestroy(pCache.pCache);
}</function>
  <function>public static PgHdr sqlite3PcacheDirtyList(PCache pCache)
{
    PgHdr p;
    for (p = pCache.pDirty; p; p = p.pDirtyNext)
    {
        p.pDirty = p.pDirtyNext;
    }

    return pcacheSortDirtyList(pCache.pDirty);
}</function>
  <function>public static void sqlite3PcacheDrop(PgHdr p)
{
    if ((p.flags &amp; 0x002) != 0)
    {
        pcacheManageDirtyList(p, (byte)(1));
    }

    p.pCache.nRefSum--;
    sqlite3Config.pcache2.xUnpin(p.pCache.pCache, p.pPage, (int)(1));
}</function>
  <function>public static sqlite3_pcache_page* sqlite3PcacheFetch(PCache pCache, uint pgno, int createFlag)
{
    int eCreate = 0;
    sqlite3_pcache_page* pRes;
    eCreate = (int)(createFlag &amp; pCache.eCreate);
    pRes = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(pgno), (int)(eCreate));
    return pRes;
}</function>
  <function>public static PgHdr sqlite3PcacheFetchFinish(PCache pCache, uint pgno, sqlite3_pcache_page* pPage)
{
    PgHdr pPgHdr;
    pPgHdr = (PgHdr)(pPage-&gt;pExtra);
    if (pPgHdr.pPage == null)
    {
        return pcacheFetchFinishWithInit(pCache, (uint)(pgno), pPage);
    }

    pCache.nRefSum++;
    pPgHdr.nRef++;
    return pPgHdr;
}</function>
  <function>public static int sqlite3PcacheFetchStress(PCache pCache, uint pgno, sqlite3_pcache_page** ppPage)
{
    PgHdr pPg;
    if ((pCache.eCreate) == (2))
        return (int)(0);
    if ((sqlite3PcachePagecount(pCache)) &gt; (pCache.szSpill))
    {
        for (pPg = pCache.pSynced; ((pPg) != null) &amp;&amp; (((pPg.nRef) != 0) || ((pPg.flags &amp; 0x008) != 0)); pPg = pPg.pDirtyPrev)
        {
        }

        pCache.pSynced = pPg;
        if (pPg == null)
        {
            for (pPg = pCache.pDirtyTail; ((pPg) != null) &amp;&amp; ((pPg.nRef) != 0); pPg = pPg.pDirtyPrev)
            {
            }
        }

        if ((pPg) != null)
        {
            int rc = 0;
            rc = (int)(pCache.xStress(pCache.pStress, pPg));
            if ((rc != 0) &amp;&amp; (rc != 5))
            {
                return (int)(rc);
            }
        }
    }

    *ppPage = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(pgno), (int)(2));
    return (int)((*ppPage) == (null) ? 7 : 0);
}</function>
  <function>public static int sqlite3PcacheInitialize()
{
    if ((sqlite3Config.pcache2.xInit) == (null))
    {
        sqlite3PCacheSetDefault();
    }

    return (int)(sqlite3Config.pcache2.xInit(sqlite3Config.pcache2.pArg));
}</function>
  <function>public static void sqlite3PcacheMakeClean(PgHdr p)
{
    pcacheManageDirtyList(p, (byte)(1));
    p.flags &amp;= (ushort)(~(0x002 | 0x008 | 0x004));
    p.flags |= (ushort)(0x001);
    if ((p.nRef) == (0))
    {
        pcacheUnpin(p);
    }
}</function>
  <function>public static void sqlite3PcacheMakeDirty(PgHdr p)
{
    if ((p.flags &amp; (0x001 | 0x010)) != 0)
    {
        p.flags &amp;= (ushort)(~0x010);
        if ((p.flags &amp; 0x001) != 0)
        {
            p.flags ^= (ushort)(0x002 | 0x001);
            pcacheManageDirtyList(p, (byte)(2));
        }
    }
}</function>
  <function>public static void sqlite3PcacheMove(PgHdr p, uint newPgno)
{
    PCache pCache = p.pCache;
    sqlite3Config.pcache2.xRekey(pCache.pCache, p.pPage, (uint)(p.pgno), (uint)(newPgno));
    p.pgno = (uint)(newPgno);
    if (((p.flags &amp; 0x002) != 0) &amp;&amp; ((p.flags &amp; 0x008) != 0))
    {
        pcacheManageDirtyList(p, (byte)(3));
    }
}</function>
  <function>public static int sqlite3PcacheOpen(int szPage, int szExtra, int bPurgeable, delegate59 xStress, void* pStress, PCache p)
{
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(PCache)));
    p.szPage = (int)(1);
    p.szExtra = (int)(szExtra);
    p.bPurgeable = (byte)(bPurgeable);
    p.eCreate = (byte)(2);
    p.xStress = xStress;
    p.pStress = pStress;
    p.szCache = (int)(100);
    p.szSpill = (int)(1);
    return (int)(sqlite3PcacheSetPageSize(p, (int)(szPage)));
}</function>
  <function>public static int sqlite3PcachePagecount(PCache pCache)
{
    return (int)(sqlite3Config.pcache2.xPagecount(pCache.pCache));
}</function>
  <function>public static int sqlite3PcachePageRefcount(PgHdr p)
{
    return (int)(p.nRef);
}</function>
  <function>public static int sqlite3PCachePercentDirty(PCache pCache)
{
    PgHdr pDirty;
    int nDirty = (int)(0);
    int nCache = (int)(numberOfCachePages(pCache));
    for (pDirty = pCache.pDirty; pDirty; pDirty = pDirty.pDirtyNext)
    {
        nDirty++;
    }

    return (int)((nCache) != 0 ? (int)(((long)(nDirty) * 100) / nCache) : 0);
}</function>
  <function>public static void sqlite3PcacheRef(PgHdr p)
{
    p.nRef++;
    p.pCache.nRefSum++;
}</function>
  <function>public static int sqlite3PcacheRefCount(PCache pCache)
{
    return (int)(pCache.nRefSum);
}</function>
  <function>public static void sqlite3PcacheRelease(PgHdr p)
{
    p.pCache.nRefSum--;
    if ((--p.nRef) == (0))
    {
        if ((p.flags &amp; 0x001) != 0)
        {
            pcacheUnpin(p);
        }
        else
        {
            pcacheManageDirtyList(p, (byte)(3));
        }
    }
}</function>
  <function>public static void sqlite3PcacheSetCachesize(PCache pCache, int mxPage)
{
    pCache.szCache = (int)(mxPage);
    sqlite3Config.pcache2.xCachesize(pCache.pCache, (int)(numberOfCachePages(pCache)));
}</function>
  <function>public static void sqlite3PCacheSetDefault()
{
    sqlite3_config((int)(18), sqlite3PCacheSetDefault_defaultMethods);
}</function>
  <function>public static int sqlite3PcacheSetPageSize(PCache pCache, int szPage)
{
    if ((pCache.szPage) != 0)
    {
        sqlite3_pcache* pNew;
        pNew = sqlite3Config.pcache2.xCreate((int)(szPage), (int)(pCache.szExtra + (((sizeof(PgHdr)) + 7) &amp; ~7)), (int)(pCache.bPurgeable));
        if ((pNew) == (null))
            return (int)(7);
        sqlite3Config.pcache2.xCachesize(pNew, (int)(numberOfCachePages(pCache)));
        if ((pCache.pCache) != null)
        {
            sqlite3Config.pcache2.xDestroy(pCache.pCache);
        }

        pCache.pCache = pNew;
        pCache.szPage = (int)(szPage);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3PcacheSetSpillsize(PCache p, int mxPage)
{
    int res = 0;
    if ((mxPage) != 0)
    {
        if ((mxPage) &lt; (0))
        {
            mxPage = ((int)((-1024 * (long)(mxPage)) / (p.szPage + p.szExtra)));
        }

        p.szSpill = (int)(mxPage);
    }

    res = (int)(numberOfCachePages(p));
    if ((res) &lt; (p.szSpill))
        res = (int)(p.szSpill);
    return (int)(res);
}</function>
  <function>public static void sqlite3PcacheShrink(PCache pCache)
{
    sqlite3Config.pcache2.xShrink(pCache.pCache);
}</function>
  <function>public static void sqlite3PcacheShutdown()
{
    if ((sqlite3Config.pcache2.xShutdown) != null)
    {
        sqlite3Config.pcache2.xShutdown(sqlite3Config.pcache2.pArg);
    }
}</function>
  <function>public static int sqlite3PcacheSize()
{
    return (int)(sizeof(PCache));
}</function>
  <function>public static void sqlite3PcacheTruncate(PCache pCache, uint pgno)
{
    if ((pCache.pCache) != null)
    {
        PgHdr p;
        PgHdr pNext;
        for (p = pCache.pDirty; p; p = pNext)
        {
            pNext = p.pDirtyNext;
            if ((p.pgno) &gt; (pgno))
            {
                sqlite3PcacheMakeClean(p);
            }
        }

        if (((pgno) == (0)) &amp;&amp; ((pCache.nRefSum) != 0))
        {
            sqlite3_pcache_page* pPage1;
            pPage1 = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(1), (int)(0));
            if ((pPage1) != null)
            {
                CRuntime.memset(pPage1-&gt;pBuf, (int)(0), (ulong)(pCache.szPage));
                pgno = (uint)(1);
            }
        }

        sqlite3Config.pcache2.xTruncate(pCache.pCache, (uint)(pgno + 1));
    }
}</function>
  <function>public static Expr sqlite3PExpr(Parse pParse, int op, Expr pLeft, Expr pRight)
{
    Expr p;
    p = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Expr)));
    if ((p) != null)
    {
        CRuntime.memset(p, (int)(0), (ulong)(sizeof(Expr)));
        p.op = (byte)(op &amp; 0xff);
        p.iAgg = (short)(-1);
        sqlite3ExprAttachSubtrees(pParse.db, p, pLeft, pRight);
        sqlite3ExprCheckHeight(pParse, (int)(p.nHeight));
    }
    else
    {
        sqlite3ExprDelete(pParse.db, pLeft);
        sqlite3ExprDelete(pParse.db, pRight);
    }

    return p;
}</function>
  <function>public static void sqlite3PExprAddSelect(Parse pParse, Expr pExpr, Select pSelect)
{
    if ((pExpr) != null)
    {
        pExpr.x.pSelect = pSelect;
        (pExpr).flags |= (uint)(0x000800 | 0x200000);
        sqlite3ExprSetHeightAndFlags(pParse, pExpr);
    }
    else
    {
        sqlite3SelectDelete(pParse.db, pSelect);
    }
}</function>
  <function>public static double sqlite3Pow10(int E)
{
    double r = (double)(1.0);
    int i = 0;
    for (i = (int)(0); E != 0; i++, E &gt;&gt;= 1)
    {
        if ((E &amp; 1) != 0)
            r *= (double)(sqlite3Pow10_x[i]);
    }

    return (double)(r);
}</function>
  <function>public static void sqlite3Pragma(Parse pParse, Token* pId1, Token* pId2, Token* pValue, int minusFlag)
{
    sbyte* zLeft = null;
    sbyte* zRight = null;
    sbyte* zDb = null;
    Token* pId;
    sbyte** aFcntl = stackalloc sbyte[4];
    int iDb = 0;
    int rc = 0;
    sqlite3 db = pParse.db;
    Db pDb;
    Vdbe v = sqlite3GetVdbe(pParse);
    PragmaName* pPragma;
    if ((v) == (null))
        return;
    sqlite3VdbeRunOnlyOnce(v);
    pParse.nMem = (int)(2);
    iDb = (int)(sqlite3TwoPartName(pParse, pId1, pId2, &amp;pId));
    if ((iDb) &lt; (0))
        return;
    pDb = db.aDb[iDb];
    if (((iDb) == (1)) &amp;&amp; ((sqlite3OpenTempDatabase(pParse)) != 0))
    {
        return;
    }

    zLeft = sqlite3NameFromToken(db, pId);
    if (zLeft == null)
        return;
    if ((minusFlag) != 0)
    {
        zRight = sqlite3MPrintf(db, "-%T", pValue);
    }
    else
    {
        zRight = sqlite3NameFromToken(db, pValue);
    }

    zDb = (pId2-&gt;n) &gt; (0) ? pDb.zDbSName : null;
    if ((sqlite3AuthCheck(pParse, (int)(19), zLeft, zRight, zDb)) != 0)
    {
        goto pragma_out;
    }

    aFcntl[0] = null;
    aFcntl[1] = zLeft;
    aFcntl[2] = zRight;
    aFcntl[3] = null;
    db.busyHandler.nBusy = (int)(0);
    rc = (int)(sqlite3_file_control(db, zDb, (int)(14), (void*)(aFcntl)));
    if ((rc) == (0))
    {
        sqlite3VdbeSetNumCols(v, (int)(1));
        sqlite3VdbeSetColName(v, (int)(0), (int)(0), aFcntl[0], ((Void(Void * ))(-1)));
        returnSingleText(v, aFcntl[0]);
        sqlite3_free(aFcntl[0]);
        goto pragma_out;
    }

    if (rc != 12)
    {
        if ((aFcntl[0]) != null)
        {
            sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
            sqlite3_free(aFcntl[0]);
        }

        pParse.nErr++;
        pParse.rc = (int)(rc);
        goto pragma_out;
    }

    pPragma = pragmaLocate(zLeft);
    if ((pPragma) == (null))
    {
        goto pragma_out;
    }

    if ((pPragma-&gt;mPragFlg &amp; 0x01) != 0)
    {
        if ((sqlite3ReadSchema(pParse)) != 0)
            goto pragma_out;
    }

    if (((pPragma-&gt;mPragFlg &amp; 0x02) == (0)) &amp;&amp; (((pPragma-&gt;mPragFlg &amp; 0x04) == (0)) || ((zRight) == (null))))
    {
        setPragmaResultColumnNames(v, pPragma);
    }

    switch (pPragma-&gt;ePragTyp)
    {
        case 13:
        {
            VdbeOp* aOp;
            sqlite3VdbeUsesBtree(v, (int)(iDb));
            if (zRight == null)
            {
                pParse.nMem += (int)(2);
                aOp = sqlite3VdbeAddOpList(v, ((int)(9 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_getCacheSize, (int)(sqlite3Pragma_iLn));
                if ((0) != 0)
                    break;
                aOp[0].p1 = (int)(iDb);
                aOp[1].p1 = (int)(iDb);
                aOp[6].p1 = (int)(-2000);
            }
            else
            {
                int size = (int)(sqlite3AbsInt32((int)(sqlite3Atoi(zRight))));
                sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
                sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(3), (int)(size));
                pDb.pSchema.cache_size = (int)(size);
                sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
            }

            break;
        }

        case 31:
        {
            Btree pBt = pDb.pBt;
            if (zRight == null)
            {
                int size = (int)((pBt) ? sqlite3BtreeGetPageSize(pBt) : 0);
                returnSingleInt(v, (long)(size));
            }
            else
            {
                db.nextPagesize = (int)(sqlite3Atoi(zRight));
                if ((7) == (sqlite3BtreeSetPageSize(pBt, (int)(db.nextPagesize), (int)(0), (int)(0))))
                {
                    sqlite3OomFault(db);
                }
            }

            break;
        }

        case 33:
        {
            Btree pBt = pDb.pBt;
            int b = (int)(-1);
            if ((zRight) != null)
            {
                if ((sqlite3_stricmp(zRight, "fast")) == (0))
                {
                    b = (int)(2);
                }
                else
                {
                    b = (int)(sqlite3GetBoolean(zRight, (byte)(0)));
                }
            }

            if (((pId2-&gt;n) == (0)) &amp;&amp; ((b) &gt;= (0)))
            {
                int ii = 0;
                for (ii = (int)(0); (ii) &lt; (db.nDb); ii++)
                {
                    sqlite3BtreeSecureDelete(db.aDb[ii].pBt, (int)(b));
                }
            }

            b = (int)(sqlite3BtreeSecureDelete(pBt, (int)(b)));
            returnSingleInt(v, (long)(b));
            break;
        }

        case 27:
        {
            int iReg = 0;
            long x = (long)(0);
            sqlite3CodeVerifySchema(pParse, (int)(iDb));
            iReg = (int)(++pParse.nMem);
            if ((sqlite3UpperToLower[(byte)(zLeft[0])]) == (112))
            {
                sqlite3VdbeAddOp2(v, (int)(176), (int)(iDb), (int)(iReg));
            }
            else
            {
                if (((zRight) != null) &amp;&amp; ((sqlite3DecOrHexToI64(zRight, &amp;x)) == (0)))
                {
                    if ((x) &lt; (0))
                        x = (long)(0);
                    else if ((x) &gt; (0xfffffffe))
                        x = (long)(0xfffffffe);
                }
                else
                {
                    x = (long)(0);
                }

                sqlite3VdbeAddOp3(v, (int)(177), (int)(iDb), (int)(iReg), (int)(x));
            }

            sqlite3VdbeAddOp2(v, (int)(83), (int)(iReg), (int)(1));
            break;
        }

        case 26:
        {
            sbyte* zRet = "normal";
            int eMode = (int)(getLockingMode(zRight));
            if (((pId2-&gt;n) == (0)) &amp;&amp; ((eMode) == (-1)))
            {
                eMode = (int)(db.dfltLockMode);
            }
            else
            {
                Pager pPager;
                if ((pId2-&gt;n) == (0))
                {
                    int ii = 0;
                    for (ii = (int)(2); (ii) &lt; (db.nDb); ii++)
                    {
                        pPager = sqlite3BtreePager(db.aDb[ii].pBt);
                        sqlite3PagerLockingMode(pPager, (int)(eMode));
                    }

                    db.dfltLockMode = ((byte)(eMode));
                }

                pPager = sqlite3BtreePager(pDb.pBt);
                eMode = (int)(sqlite3PagerLockingMode(pPager, (int)(eMode)));
            }

            if ((eMode) == (1))
            {
                zRet = "exclusive";
            }

            returnSingleText(v, zRet);
            break;
        }

        case 23:
        {
            int eMode = 0;
            int ii = 0;
            if ((zRight) == (null))
            {
                eMode = (int)(-1);
            }
            else
            {
                sbyte* zMode;
                int n = (int)(sqlite3Strlen30(zRight));
                for (eMode = (int)(0); (zMode = sqlite3JournalModename((int)(eMode))) != null; eMode++)
                {
                    if ((sqlite3_strnicmp(zRight, zMode, (int)(n))) == (0))
                        break;
                }

                if (zMode == null)
                {
                    eMode = (int)(-1);
                }

                if (((eMode) == (2)) &amp;&amp; ((db.flags &amp; 0x10000000) != 0))
                {
                    eMode = (int)(-1);
                }
            }

            if (((eMode) == (-1)) &amp;&amp; ((pId2-&gt;n) == (0)))
            {
                iDb = (int)(0);
                pId2-&gt;n = (uint)(1);
            }

            for (ii = (int)(db.nDb - 1); (ii) &gt;= (0); ii--)
            {
                if (((db.aDb[ii].pBt) != null) &amp;&amp; (((ii) == (iDb)) || ((pId2-&gt;n) == (0))))
                {
                    sqlite3VdbeUsesBtree(v, (int)(ii));
                    sqlite3VdbeAddOp3(v, (int)(7), (int)(ii), (int)(1), (int)(eMode));
                }
            }

            sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
            break;
        }

        case 24:
        {
            Pager pPager = sqlite3BtreePager(pDb.pBt);
            long iLimit = (long)(-2);
            if ((zRight) != null)
            {
                sqlite3DecOrHexToI64(zRight, &amp;iLimit);
                if ((iLimit) &lt; (-1))
                    iLimit = (long)(-1);
            }

            iLimit = (long)(sqlite3PagerJournalSizeLimit(pPager, (long)(iLimit)));
            returnSingleInt(v, (long)(iLimit));
            break;
        }

        case 3:
        {
            Btree pBt = pDb.pBt;
            if (zRight == null)
            {
                returnSingleInt(v, (long)(sqlite3BtreeGetAutoVacuum(pBt)));
            }
            else
            {
                int eAuto = (int)(getAutoVacuum(zRight));
                db.nextAutovac = (sbyte)((byte)(eAuto));
                rc = (int)(sqlite3BtreeSetAutoVacuum(pBt, (int)(eAuto)));
                if (((rc) == (0)) &amp;&amp; (((eAuto) == (1)) || ((eAuto) == (2))))
                {
                    VdbeOp* aOp;
                    int iAddr = (int)(sqlite3VdbeCurrentAddr(v));
                    aOp = sqlite3VdbeAddOpList(v, ((int)(5 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_setMeta6, (int)(sqlite3Pragma_iLn));
                    if ((0) != 0)
                        break;
                    aOp[0].p1 = (int)(iDb);
                    aOp[1].p1 = (int)(iDb);
                    aOp[2].p2 = (int)(iAddr + 4);
                    aOp[4].p1 = (int)(iDb);
                    aOp[4].p3 = (int)(eAuto - 1);
                    sqlite3VdbeUsesBtree(v, (int)(iDb));
                }
            }

            break;
        }

        case 19:
        {
            int iLimit = 0;
            int addr = 0;
            if ((((zRight) == (null)) || (sqlite3GetInt32(zRight, &amp;iLimit) == 0)) || ((iLimit) &lt;= (0)))
            {
                iLimit = (int)(0x7fffffff);
            }

            sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(iLimit), (int)(1));
            addr = (int)(sqlite3VdbeAddOp1(v, (int)(61), (int)(iDb)));
            sqlite3VdbeAddOp1(v, (int)(83), (int)(1));
            sqlite3VdbeAddOp2(v, (int)(85), (int)(1), (int)(-1));
            sqlite3VdbeAddOp2(v, (int)(49), (int)(1), (int)(addr));
            sqlite3VdbeJumpHere(v, (int)(addr));
            break;
        }

        case 6:
        {
            if (zRight == null)
            {
                returnSingleInt(v, (long)(pDb.pSchema.cache_size));
            }
            else
            {
                int size = (int)(sqlite3Atoi(zRight));
                pDb.pSchema.cache_size = (int)(size);
                sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
            }

            break;
        }

        case 7:
        {
            if (zRight == null)
            {
                returnSingleInt(v, (long)((db.flags &amp; 0x00000020) == (0) ? 0 : sqlite3BtreeSetSpillSize(pDb.pBt, (int)(0))));
            }
            else
            {
                int size = (int)(1);
                if ((sqlite3GetInt32(zRight, &amp;size)) != 0)
                {
                    sqlite3BtreeSetSpillSize(pDb.pBt, (int)(size));
                }

                if ((sqlite3GetBoolean(zRight, (byte)(size != 0))) != 0)
                {
                    db.flags |= (ulong)(0x00000020);
                }
                else
                {
                    db.flags &amp;= (ulong)(~(ulong)(0x00000020));
                }

                setAllPagerFlags(db);
            }

            break;
        }

        case 28:
        {
            long sz = 0;
            if ((zRight) != null)
            {
                int ii = 0;
                sqlite3DecOrHexToI64(zRight, &amp;sz);
                if ((sz) &lt; (0))
                    sz = (long)(sqlite3Config.szMmap);
                if ((pId2-&gt;n) == (0))
                    db.szMmap = (long)(sz);
                for (ii = (int)(db.nDb - 1); (ii) &gt;= (0); ii--)
                {
                    if (((db.aDb[ii].pBt) != null) &amp;&amp; (((ii) == (iDb)) || ((pId2-&gt;n) == (0))))
                    {
                        sqlite3BtreeSetMmapLimit(db.aDb[ii].pBt, (long)(sz));
                    }
                }
            }

            sz = (long)(-1);
            rc = (int)(sqlite3_file_control(db, zDb, (int)(18), &amp;sz));
            if ((rc) == (0))
            {
                returnSingleInt(v, (long)(sz));
            }
            else if (rc != 12)
            {
                pParse.nErr++;
                pParse.rc = (int)(rc);
            }

            break;
        }

        case 39:
        {
            if (zRight == null)
            {
                returnSingleInt(v, (long)(db.temp_store));
            }
            else
            {
                changeTempStorage(pParse, zRight);
            }

            break;
        }

        case 40:
        {
            if (zRight == null)
            {
                returnSingleText(v, sqlite3_temp_directory);
            }
            else
            {
                if ((zRight[0]) != 0)
                {
                    int res = 0;
                    rc = (int)(sqlite3OsAccess(db.pVfs, zRight, (int)(1), &amp;res));
                    if ((rc != 0) || ((res) == (0)))
                    {
                        sqlite3ErrorMsg(pParse, "not a writable directory");
                        goto pragma_out;
                    }
                }

                if ((((1) == (0)) || (((1) == (1)) &amp;&amp; ((db.temp_store) &lt;= (1)))) || (((1) == (2)) &amp;&amp; ((db.temp_store) == (1))))
                {
                    invalidateTempStorage(pParse);
                }

                sqlite3_free(sqlite3_temp_directory);
                if ((zRight[0]) != 0)
                {
                    sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
                }
                else
                {
                    sqlite3_temp_directory = null;
                }
            }

            break;
        }

        case 11:
        {
            if (zRight == null)
            {
                returnSingleText(v, sqlite3_data_directory);
            }
            else
            {
                if ((zRight[0]) != 0)
                {
                    int res = 0;
                    rc = (int)(sqlite3OsAccess(db.pVfs, zRight, (int)(1), &amp;res));
                    if ((rc != 0) || ((res) == (0)))
                    {
                        sqlite3ErrorMsg(pParse, "not a writable directory");
                        goto pragma_out;
                    }
                }

                sqlite3_free(sqlite3_data_directory);
                if ((zRight[0]) != 0)
                {
                    sqlite3_data_directory = sqlite3_mprintf("%s", zRight);
                }
                else
                {
                    sqlite3_data_directory = null;
                }
            }

            break;
        }

        case 36:
        {
            if (zRight == null)
            {
                returnSingleInt(v, (long)(pDb.safety_level - 1));
            }
            else
            {
                if (db.autoCommit == 0)
                {
                    sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction");
                }
                else if (iDb != 1)
                {
                    int iLevel = (int)((getSafetyLevel(zRight, (int)(0), (byte)(1)) + 1) &amp; 0x07);
                    if ((iLevel) == (0))
                        iLevel = (int)(1);
                    pDb.safety_level = (byte)(iLevel);
                    pDb.bSyncSet = (byte)(1);
                    setAllPagerFlags(db);
                }
            }

            break;
        }

        case 4:
        {
            if ((zRight) == (null))
            {
                setPragmaResultColumnNames(v, pPragma);
                returnSingleInt(v, (long)((db.flags &amp; pPragma-&gt;iArg) != 0));
            }
            else
            {
                ulong mask = (ulong)(pPragma-&gt;iArg);
                if ((db.autoCommit) == (0))
                {
                    mask &amp;= (ulong)(~(0x00004000));
                }

                if ((sqlite3GetBoolean(zRight, (byte)(0))) != 0)
                {
                    db.flags |= (ulong)(mask);
                }
                else
                {
                    db.flags &amp;= (ulong)(~mask);
                    if ((mask) == (0x00080000))
                        db.nDeferredImmCons = (long)(0);
                    if (((mask &amp; 0x00000001) != 0) &amp;&amp; ((sqlite3_stricmp(zRight, "reset")) == (0)))
                    {
                        sqlite3ResetAllSchemasOfConnection(db);
                    }
                }

                sqlite3VdbeAddOp0(v, (int)(165));
                setAllPagerFlags(db);
            }

            break;
        }

        case 37:
            if ((zRight) != null)
            {
                Table pTab;
                sqlite3CodeVerifyNamedSchema(pParse, zDb);
                pTab = sqlite3LocateTable(pParse, (uint)(0x02), zRight, zDb);
                if ((pTab) != null)
                {
                    int i = 0;
                    int k = 0;
                    int nHidden = (int)(0);
                    Column* pCol;
                    Index pPk = sqlite3PrimaryKeyIndex(pTab);
                    pParse.nMem = (int)(7);
                    sqlite3ViewGetColumnNames(pParse, pTab);
                    for (i = (int)(0), pCol = pTab.aCol; (i) &lt; (pTab.nCol); i++, pCol++)
                    {
                        int isHidden = (int)(0);
                        Expr pColExpr;
                        if ((pCol-&gt;colFlags &amp; 0x0062) != 0)
                        {
                            if ((pPragma-&gt;iArg) == (0))
                            {
                                nHidden++;
                                continue;
                            }

                            if ((pCol-&gt;colFlags &amp; 0x0020) != 0)
                            {
                                isHidden = (int)(2);
                            }
                            else if ((pCol-&gt;colFlags &amp; 0x0040) != 0)
                            {
                                isHidden = (int)(3);
                            }
                            else
                            {
                                isHidden = (int)(1);
                            }
                        }

                        if ((pCol-&gt;colFlags &amp; 0x0001) == (0))
                        {
                            k = (int)(0);
                        }
                        else if ((pPk) == (null))
                        {
                            k = (int)(1);
                        }
                        else
                        {
                            for (k = (int)(1); ((k) &lt;= (pTab.nCol)) &amp;&amp; (pPk.aiColumn[k - 1] != i); k++)
                            {
                            }
                        }

                        pColExpr = sqlite3ColumnExpr(pTab, pCol);
                        sqlite3VdbeMultiLoad(v, (int)(1), (pPragma-&gt;iArg) != 0 ? "issisii" : "issisi", (int)(i - nHidden), pCol-&gt;zCnName, sqlite3ColumnType(pCol, ""), (int)((pCol-&gt;notNull) != 0 ? 1 : 0), (((isHidden) &gt;= (2)) || ((pColExpr) == (null))) ? null : pColExpr.u.zToken, (int)(k), (int)(isHidden));
                    }
                }
            }

            break;
        case 38:
        {
            int ii = 0;
            pParse.nMem = (int)(6);
            sqlite3CodeVerifyNamedSchema(pParse, zDb);
            for (ii = (int)(0); (ii) &lt; (db.nDb); ii++)
            {
                HashElem* k;
                Hash* pHash;
                int initNCol = 0;
                if (((zDb) != null) &amp;&amp; (sqlite3_stricmp(zDb, db.aDb[ii].zDbSName) != 0))
                    continue;
                pHash = &amp;db.aDb[ii].pSchema.tblHash;
                initNCol = (int)((pHash)-&gt;count);
                while ((initNCol--) != 0)
                {
                    for (k = ((pHash)-&gt;first); 1; k = ((k)-&gt;next))
                    {
                        Table pTab;
                        if ((k) == (null))
                        {
                            initNCol = (int)(0);
                            break;
                        }

                        pTab = ((k)-&gt;data);
                        if ((pTab.nCol) == (0))
                        {
                            sbyte* zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\"", pTab.zName);
                            if ((zSql) != null)
                            {
                                sqlite3_stmt* pDummy = null;
                                (void)(sqlite3_prepare(db, zSql, (int)(-1), &amp;pDummy, null));
                                (void)(sqlite3_finalize(pDummy));
                                sqlite3DbFree(db, zSql);
                            }

                            if ((db.mallocFailed) != 0)
                            {
                                sqlite3ErrorMsg(db.pParse, "out of memory");
                                db.pParse.rc = (int)(7);
                            }

                            pHash = &amp;db.aDb[ii].pSchema.tblHash;
                            break;
                        }
                    }
                }

                for (k = ((pHash)-&gt;first); k; k = ((k)-&gt;next))
                {
                    Table pTab = ((k)-&gt;data);
                    sbyte* zType;
                    if (((zRight) != null) &amp;&amp; (sqlite3_stricmp(zRight, pTab.zName) != 0))
                        continue;
                    if ((((pTab).eTabType) == (2)))
                    {
                        zType = "view";
                    }
                    else if ((((pTab).eTabType) == (1)))
                    {
                        zType = "virtual";
                    }
                    else if ((pTab.tabFlags &amp; 0x00001000) != 0)
                    {
                        zType = "shadow";
                    }
                    else
                    {
                        zType = "table";
                    }

                    sqlite3VdbeMultiLoad(v, (int)(1), "sssiii", db.aDb[ii].zDbSName, sqlite3PreferredTableName(pTab.zName), zType, (int)(pTab.nCol), (int)((pTab.tabFlags &amp; 0x00000080) != 0), (int)((pTab.tabFlags &amp; 0x00010000) != 0));
                }
            }
        }

            break;
        case 20:
            if ((zRight) != null)
            {
                Index pIdx;
                Table pTab;
                pIdx = sqlite3FindIndex(db, zRight, zDb);
                if ((pIdx) == (null))
                {
                    pTab = sqlite3LocateTable(pParse, (uint)(0x02), zRight, zDb);
                    if (((pTab) != null) &amp;&amp; (!(((pTab).tabFlags &amp; 0x00000080) == (0))))
                    {
                        pIdx = sqlite3PrimaryKeyIndex(pTab);
                    }
                }

                if ((pIdx) != null)
                {
                    int iIdxDb = (int)(sqlite3SchemaToIndex(db, pIdx.pSchema));
                    int i = 0;
                    int mx = 0;
                    if ((pPragma-&gt;iArg) != 0)
                    {
                        mx = (int)(pIdx.nColumn);
                        pParse.nMem = (int)(6);
                    }
                    else
                    {
                        mx = (int)(pIdx.nKeyCol);
                        pParse.nMem = (int)(3);
                    }

                    pTab = pIdx.pTable;
                    sqlite3CodeVerifySchema(pParse, (int)(iIdxDb));
                    for (i = (int)(0); (i) &lt; (mx); i++)
                    {
                        short cnum = (short)(pIdx.aiColumn[i]);
                        sqlite3VdbeMultiLoad(v, (int)(1), "iisX", (int)(i), (int)(cnum), (cnum) &lt; (0) ? null : pTab.aCol[cnum].zCnName);
                        if ((pPragma-&gt;iArg) != 0)
                        {
                            sqlite3VdbeMultiLoad(v, (int)(4), "isiX", (int)(pIdx.aSortOrder[i]), pIdx.azColl[i], ((i) &lt; (pIdx.nKeyCol) ? 1 : 0));
                        }

                        sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(pParse.nMem));
                    }
                }
            }

            break;
        case 21:
            if ((zRight) != null)
            {
                Index pIdx;
                Table pTab;
                int i = 0;
                pTab = sqlite3FindTable(db, zRight, zDb);
                if ((pTab) != null)
                {
                    int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
                    pParse.nMem = (int)(5);
                    sqlite3CodeVerifySchema(pParse, (int)(iTabDb));
                    for (pIdx = pTab.pIndex, i = (int)(0); pIdx; pIdx = pIdx.pNext, i++)
                    {
                        sbyte** azOrigin = stackalloc sbyte*[]{"c", "u", "pk"};
                        sqlite3VdbeMultiLoad(v, (int)(1), "isisi", (int)(i), pIdx.zName, (int)((pIdx).onError != 0), azOrigin[pIdx.idxType], (int)(pIdx.pPartIdxWhere != null));
                    }
                }
            }

            break;
        case 12:
        {
            int i = 0;
            pParse.nMem = (int)(3);
            for (i = (int)(0); (i) &lt; (db.nDb); i++)
            {
                if ((db.aDb[i].pBt) == (null))
                    continue;
                sqlite3VdbeMultiLoad(v, (int)(1), "iss", (int)(i), db.aDb[i].zDbSName, sqlite3BtreeGetFilename(db.aDb[i].pBt));
            }
        }

            break;
        case 9:
        {
            int i = (int)(0);
            HashElem* p;
            pParse.nMem = (int)(2);
            for (p = ((&amp;db.aCollSeq)-&gt;first); p; p = ((p)-&gt;next))
            {
                CollSeq pColl = (CollSeq)((p)-&gt;data);
                sqlite3VdbeMultiLoad(v, (int)(1), "is", (int)(i++), pColl.zName);
            }
        }

            break;
        case 17:
        {
            int i = 0;
            HashElem* j;
            FuncDef p;
            int showInternFunc = (int)((db.mDbFlags &amp; 0x0020) != 0);
            pParse.nMem = (int)(6);
            for (i = (int)(0); (i) &lt; (23); i++)
            {
                for (p = sqlite3BuiltinFunctions.a[i]; p; p = p.u.pHash)
                {
                    pragmaFunclistLine(v, p, (int)(1), (int)(showInternFunc));
                }
            }

            for (j = ((&amp;db.aFunc)-&gt;first); j; j = ((j)-&gt;next))
            {
                p = (FuncDef)((j)-&gt;data);
                pragmaFunclistLine(v, p, (int)(0), (int)(showInternFunc));
            }
        }

            break;
        case 29:
        {
            HashElem* j;
            pParse.nMem = (int)(1);
            for (j = ((&amp;db.aModule)-&gt;first); j; j = ((j)-&gt;next))
            {
                Module pMod = (Module)((j)-&gt;data);
                sqlite3VdbeMultiLoad(v, (int)(1), "s", pMod.zName);
            }
        }

            break;
        case 32:
        {
            int i = 0;
            for (i = (int)(0); (i) &lt; ((int)(67 * sizeof(PragmaName) / sizeof(PragmaName))); i++)
            {
                sqlite3VdbeMultiLoad(v, (int)(1), "s", aPragmaName[i].zName);
            }
        }

            break;
        case 16:
            if ((zRight) != null)
            {
                FKey pFK;
                Table pTab;
                pTab = sqlite3FindTable(db, zRight, zDb);
                if (((pTab) != null) &amp;&amp; (((pTab).eTabType) == (0)))
                {
                    pFK = pTab.u.tab.pFKey;
                    if ((pFK) != null)
                    {
                        int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
                        int i = (int)(0);
                        pParse.nMem = (int)(8);
                        sqlite3CodeVerifySchema(pParse, (int)(iTabDb));
                        while ((pFK) != null)
                        {
                            int j = 0;
                            for (j = (int)(0); (j) &lt; (pFK.nCol); j++)
                            {
                                sqlite3VdbeMultiLoad(v, (int)(1), "iissssss", (int)(i), (int)(j), pFK.zTo, pTab.aCol[pFK.aCol[j].iFrom].zCnName, pFK.aCol[j].zCol, actionName((byte)(pFK.aAction[1])), actionName((byte)(pFK.aAction[0])), "NONE");
                            }

                            ++i;
                            pFK = pFK.pNextFrom;
                        }
                    }
                }
            }

            break;
        case 15:
        {
            FKey pFK;
            Table pTab;
            Table pParent;
            Index pIdx;
            int i = 0;
            int j = 0;
            HashElem* k;
            int x = 0;
            int regResult = 0;
            int regKey = 0;
            int regRow = 0;
            int addrTop = 0;
            int addrOk = 0;
            int* aiCols;
            regResult = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(4);
            regKey = (int)(++pParse.nMem);
            regRow = (int)(++pParse.nMem);
            k = ((&amp;db.aDb[iDb].pSchema.tblHash)-&gt;first);
            while ((k) != null)
            {
                if ((zRight) != null)
                {
                    pTab = sqlite3LocateTable(pParse, (uint)(0), zRight, zDb);
                    k = null;
                }
                else
                {
                    pTab = (Table)((k)-&gt;data);
                    k = ((k)-&gt;next);
                }

                if ((((pTab) == (null)) || (!(((pTab).eTabType) == (0)))) || ((pTab.u.tab.pFKey) == (null)))
                    continue;
                iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
                zDb = db.aDb[iDb].zDbSName;
                sqlite3CodeVerifySchema(pParse, (int)(iDb));
                sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
                if ((pTab.nCol + regRow) &gt; (pParse.nMem))
                    pParse.nMem = (int)(pTab.nCol + regRow);
                sqlite3OpenTable(pParse, (int)(0), (int)(iDb), pTab, (int)(101));
                sqlite3VdbeLoadString(v, (int)(regResult), pTab.zName);
                for (i = (int)(1), pFK = pTab.u.tab.pFKey; pFK; i++, pFK = pFK.pNextFrom)
                {
                    pParent = sqlite3FindTable(db, pFK.zTo, zDb);
                    if ((pParent) == (null))
                        continue;
                    pIdx = null;
                    sqlite3TableLock(pParse, (int)(iDb), (uint)(pParent.tnum), (byte)(0), pParent.zName);
                    x = (int)(sqlite3FkLocateIndex(pParse, pParent, pFK, pIdx, null));
                    if ((x) == (0))
                    {
                        if ((pIdx) == (null))
                        {
                            sqlite3OpenTable(pParse, (int)(i), (int)(iDb), pParent, (int)(101));
                        }
                        else
                        {
                            sqlite3VdbeAddOp3(v, (int)(101), (int)(i), (int)(pIdx.tnum), (int)(iDb));
                            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
                        }
                    }
                    else
                    {
                        k = null;
                        break;
                    }
                }

                if ((pFK) != null)
                    break;
                if ((pParse.nTab) &lt; (i))
                    pParse.nTab = (int)(i);
                addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(0)));
                for (i = (int)(1), pFK = pTab.u.tab.pFKey; pFK; i++, pFK = pFK.pNextFrom)
                {
                    pParent = sqlite3FindTable(db, pFK.zTo, zDb);
                    pIdx = null;
                    aiCols = null;
                    if ((pParent) != null)
                    {
                        x = (int)(sqlite3FkLocateIndex(pParse, pParent, pFK, pIdx, &amp;aiCols));
                    }

                    addrOk = (int)(sqlite3VdbeMakeLabel(pParse));
                    if ((regRow + pFK.nCol) &gt; (pParse.nMem))
                        pParse.nMem = (int)(regRow + pFK.nCol);
                    for (j = (int)(0); (j) &lt; (pFK.nCol); j++)
                    {
                        int iCol = (int)((aiCols) != 0 ? aiCols[j] : pFK.aCol[j].iFrom);
                        sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(0), (int)(iCol), (int)(regRow + j));
                        sqlite3VdbeAddOp2(v, (int)(50), (int)(regRow + j), (int)(addrOk));
                    }

                    if ((pIdx) != null)
                    {
                        sqlite3VdbeAddOp4(v, (int)(96), (int)(regRow), (int)(pFK.nCol), (int)(regKey), sqlite3IndexAffinityStr(db, pIdx), (int)(pFK.nCol));
                        sqlite3VdbeAddOp4Int(v, (int)(31), (int)(i), (int)(addrOk), (int)(regKey), (int)(0));
                    }
                    else if ((pParent) != null)
                    {
                        int jmp = (int)(sqlite3VdbeCurrentAddr(v) + 2);
                        sqlite3VdbeAddOp3(v, (int)(32), (int)(i), (int)(jmp), (int)(regRow));
                        sqlite3VdbeGoto(v, (int)(addrOk));
                    }

                    if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
                    {
                        sqlite3VdbeAddOp2(v, (int)(134), (int)(0), (int)(regResult + 1));
                    }
                    else
                    {
                        sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regResult + 1));
                    }

                    sqlite3VdbeMultiLoad(v, (int)(regResult + 2), "siX", pFK.zTo, (int)(i - 1));
                    sqlite3VdbeAddOp2(v, (int)(83), (int)(regResult), (int)(4));
                    sqlite3VdbeResolveLabel(v, (int)(addrOk));
                    sqlite3DbFree(db, aiCols);
                }

                sqlite3VdbeAddOp2(v, (int)(5), (int)(0), (int)(addrTop + 1));
                sqlite3VdbeJumpHere(v, (int)(addrTop));
            }
        }

            break;
        case 8:
        {
            if ((zRight) != null)
            {
                sqlite3RegisterLikeFunctions(db, (int)(sqlite3GetBoolean(zRight, (byte)(0))));
            }
        }

            break;
        case 22:
        {
            int i = 0;
            int j = 0;
            int addr = 0;
            int mxErr = 0;
            Table pObjTab = null;
            int isQuick = (int)(((sqlite3UpperToLower[(byte)(zLeft[0])]) == (113)) ? 1 : 0);
            if ((pId2-&gt;z) == (null))
                iDb = (int)(-1);
            pParse.nMem = (int)(6);
            mxErr = (int)(100);
            if ((zRight) != null)
            {
                if ((sqlite3GetInt32(zRight, &amp;mxErr)) != 0)
                {
                    if ((mxErr) &lt;= (0))
                    {
                        mxErr = (int)(100);
                    }
                }
                else
                {
                    pObjTab = sqlite3LocateTable(pParse, (uint)(0), zRight, (iDb) &gt;= (0) ? db.aDb[iDb].zDbSName : null);
                }
            }

            sqlite3VdbeAddOp2(v, (int)(71), (int)(mxErr - 1), (int)(1));
            for (i = (int)(0); (i) &lt; (db.nDb); i++)
            {
                HashElem* x;
                Hash* pTbls;
                int* aRoot;
                int cnt = (int)(0);
                int mxIdx = (int)(0);
                if (((0) != 0) &amp;&amp; ((i) == (1)))
                    continue;
                if (((iDb) &gt;= (0)) &amp;&amp; (i != iDb))
                    continue;
                sqlite3CodeVerifySchema(pParse, (int)(i));
                pTbls = &amp;db.aDb[i].pSchema.tblHash;
                for (cnt = (int)(0), x = ((pTbls)-&gt;first); x; x = ((x)-&gt;next))
                {
                    Table pTab = ((x)-&gt;data);
                    Index pIdx;
                    int nIdx = 0;
                    if (((pObjTab) != null) &amp;&amp; (pObjTab != pTab))
                        continue;
                    if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
                        cnt++;
                    for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
                    {
                        cnt++;
                    }

                    if ((nIdx) &gt; (mxIdx))
                        mxIdx = (int)(nIdx);
                }

                if ((cnt) == (0))
                    continue;
                if ((pObjTab) != null)
                    cnt++;
                aRoot = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (cnt + 1)));
                if ((aRoot) == (null))
                    break;
                cnt = (int)(0);
                if ((pObjTab) != null)
                    aRoot[++cnt] = (int)(0);
                for (x = ((pTbls)-&gt;first); x; x = ((x)-&gt;next))
                {
                    Table pTab = ((x)-&gt;data);
                    Index pIdx;
                    if (((pObjTab) != null) &amp;&amp; (pObjTab != pTab))
                        continue;
                    if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
                        aRoot[++cnt] = (int)(pTab.tnum);
                    for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
                    {
                        aRoot[++cnt] = (int)(pIdx.tnum);
                    }
                }

                aRoot[0] = (int)(cnt);
                pParse.nMem = (int)((pParse.nMem) &gt; (8 + mxIdx) ? (pParse.nMem) : (8 + mxIdx));
                sqlite3ClearTempRegCache(pParse);
                sqlite3VdbeAddOp4(v, (int)(154), (int)(2), (int)(cnt), (int)(1), (sbyte*)(aRoot), (int)(-15));
                sqlite3VdbeChangeP5(v, (ushort)((byte)(i)));
                addr = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(2)));
                sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), sqlite3MPrintf(db, "*** in database %s ***\n", db.aDb[i].zDbSName), (int)(-7));
                sqlite3VdbeAddOp3(v, (int)(111), (int)(2), (int)(3), (int)(3));
                integrityCheckResultRow(v);
                sqlite3VdbeJumpHere(v, (int)(addr));
                for (x = ((pTbls)-&gt;first); x; x = ((x)-&gt;next))
                {
                    Table pTab = ((x)-&gt;data);
                    Index pIdx;
                    Index pPk;
                    Index pPrior = null;
                    int loopTop = 0;
                    int iDataCur = 0;
                    int iIdxCur = 0;
                    int r1 = (int)(-1);
                    int bStrict = 0;
                    if (!(((pTab).eTabType) == (0)))
                        continue;
                    if (((pObjTab) != null) &amp;&amp; (pObjTab != pTab))
                        continue;
                    pPk = (((pTab).tabFlags &amp; 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
                    sqlite3OpenTableAndIndices(pParse, pTab, (int)(101), (byte)(0), (int)(1), null, &amp;iDataCur, &amp;iIdxCur);
                    sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(7));
                    for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
                    {
                        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(8 + j));
                    }

                    sqlite3VdbeAddOp2(v, (int)(38), (int)(iDataCur), (int)(0));
                    loopTop = (int)(sqlite3VdbeAddOp2(v, (int)(85), (int)(7), (int)(1)));
                    if (isQuick == 0)
                    {
                        sqlite3VdbeAddOp3(v, (int)(93), (int)(iDataCur), (int)(pTab.nNVCol - 1), (int)(3));
                        sqlite3VdbeChangeP5(v, (ushort)(0x80));
                    }

                    bStrict = (int)((pTab.tabFlags &amp; 0x00010000) != 0);
                    for (j = (int)(0); (j) &lt; (pTab.nCol); j++)
                    {
                        sbyte* zErr;
                        Column* pCol = pTab.aCol + j;
                        int doError = 0;
                        int jmp2 = 0;
                        if ((j) == (pTab.iPKey))
                            continue;
                        if (((pCol-&gt;notNull) == (0)) &amp;&amp; (bStrict == 0))
                            continue;
                        doError = (int)((bStrict) != 0 ? sqlite3VdbeMakeLabel(pParse) : 0);
                        sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(j), (int)(3));
                        if ((sqlite3VdbeGetOp(v, (int)(-1))-&gt;opcode) == (93))
                        {
                            sqlite3VdbeChangeP5(v, (ushort)(0x80));
                        }

                        if ((pCol-&gt;notNull) != 0)
                        {
                            jmp2 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(3)));
                            zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab.zName, pCol-&gt;zCnName);
                            sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
                            if (((bStrict) != 0) &amp;&amp; (pCol-&gt;eCType != 1))
                            {
                                sqlite3VdbeGoto(v, (int)(doError));
                            }
                            else
                            {
                                integrityCheckResultRow(v);
                            }

                            sqlite3VdbeJumpHere(v, (int)(jmp2));
                        }

                        if (((pTab.tabFlags &amp; 0x00010000) != 0) &amp;&amp; (pCol-&gt;eCType != 1))
                        {
                            jmp2 = (int)(sqlite3VdbeAddOp3(v, (int)(21), (int)(3), (int)(0), (int)(sqlite3StdTypeMap[pCol-&gt;eCType - 1])));
                            zErr = sqlite3MPrintf(db, "non-%s value in %s.%s", sqlite3StdType[pCol-&gt;eCType - 1], pTab.zName, pTab.aCol[j].zCnName);
                            sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
                            sqlite3VdbeResolveLabel(v, (int)(doError));
                            integrityCheckResultRow(v);
                            sqlite3VdbeJumpHere(v, (int)(jmp2));
                        }
                    }

                    if (((pTab.pCheck) != null) &amp;&amp; ((db.flags &amp; 0x00000200) == (0)))
                    {
                        ExprList pCheck = sqlite3ExprListDup(db, pTab.pCheck, (int)(0));
                        if ((db.mallocFailed) == (0))
                        {
                            int addrCkFault = (int)(sqlite3VdbeMakeLabel(pParse));
                            int addrCkOk = (int)(sqlite3VdbeMakeLabel(pParse));
                            sbyte* zErr;
                            int k = 0;
                            pParse.iSelfTab = (int)(iDataCur + 1);
                            for (k = (int)(pCheck.nExpr - 1); (k) &gt; (0); k--)
                            {
                                sqlite3ExprIfFalse(pParse, pCheck.a[k].pExpr, (int)(addrCkFault), (int)(0));
                            }

                            sqlite3ExprIfTrue(pParse, pCheck.a[0].pExpr, (int)(addrCkOk), (int)(0x10));
                            sqlite3VdbeResolveLabel(v, (int)(addrCkFault));
                            pParse.iSelfTab = (int)(0);
                            zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s", pTab.zName);
                            sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
                            integrityCheckResultRow(v);
                            sqlite3VdbeResolveLabel(v, (int)(addrCkOk));
                        }

                        sqlite3ExprListDelete(db, pCheck);
                    }

                    if (isQuick == 0)
                    {
                        for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
                        {
                            int jmp2 = 0;
                            int jmp3 = 0;
                            int jmp4 = 0;
                            int jmp5 = 0;
                            int ckUniq = (int)(sqlite3VdbeMakeLabel(pParse));
                            if ((pPk) == (pIdx))
                                continue;
                            r1 = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(iDataCur), (int)(0), (int)(0), &amp;jmp3, pPrior, (int)(r1)));
                            pPrior = pIdx;
                            sqlite3VdbeAddOp2(v, (int)(85), (int)(8 + j), (int)(1));
                            jmp2 = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iIdxCur + j), (int)(ckUniq), (int)(r1), (int)(pIdx.nColumn)));
                            sqlite3VdbeLoadString(v, (int)(3), "row ");
                            sqlite3VdbeAddOp3(v, (int)(111), (int)(7), (int)(3), (int)(3));
                            sqlite3VdbeLoadString(v, (int)(4), " missing from index ");
                            sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(3), (int)(3));
                            jmp5 = (int)(sqlite3VdbeLoadString(v, (int)(4), pIdx.zName));
                            sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(3), (int)(3));
                            jmp4 = (int)(integrityCheckResultRow(v));
                            sqlite3VdbeJumpHere(v, (int)(jmp2));
                            if (((pIdx).onError != 0))
                            {
                                int uniqOk = (int)(sqlite3VdbeMakeLabel(pParse));
                                int jmp6 = 0;
                                int kk = 0;
                                for (kk = (int)(0); (kk) &lt; (pIdx.nKeyCol); kk++)
                                {
                                    int iCol = (int)(pIdx.aiColumn[kk]);
                                    if (((iCol) &gt;= (0)) &amp;&amp; ((pTab.aCol[iCol].notNull) != 0))
                                        continue;
                                    sqlite3VdbeAddOp2(v, (int)(50), (int)(r1 + kk), (int)(uniqOk));
                                }

                                jmp6 = (int)(sqlite3VdbeAddOp1(v, (int)(5), (int)(iIdxCur + j)));
                                sqlite3VdbeGoto(v, (int)(uniqOk));
                                sqlite3VdbeJumpHere(v, (int)(jmp6));
                                sqlite3VdbeAddOp4Int(v, (int)(40), (int)(iIdxCur + j), (int)(uniqOk), (int)(r1), (int)(pIdx.nKeyCol));
                                sqlite3VdbeLoadString(v, (int)(3), "non-unique entry in index ");
                                sqlite3VdbeGoto(v, (int)(jmp5));
                                sqlite3VdbeResolveLabel(v, (int)(uniqOk));
                            }

                            sqlite3VdbeJumpHere(v, (int)(jmp4));
                            sqlite3ResolvePartIdxLabel(pParse, (int)(jmp3));
                        }
                    }

                    sqlite3VdbeAddOp2(v, (int)(5), (int)(iDataCur), (int)(loopTop));
                    sqlite3VdbeJumpHere(v, (int)(loopTop - 1));
                    if (isQuick == 0)
                    {
                        sqlite3VdbeLoadString(v, (int)(2), "wrong # of entries in index ");
                        for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
                        {
                            if ((pPk) == (pIdx))
                                continue;
                            sqlite3VdbeAddOp2(v, (int)(97), (int)(iIdxCur + j), (int)(3));
                            addr = (int)(sqlite3VdbeAddOp3(v, (int)(53), (int)(8 + j), (int)(0), (int)(3)));
                            sqlite3VdbeChangeP5(v, (ushort)(0x90));
                            sqlite3VdbeLoadString(v, (int)(4), pIdx.zName);
                            sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(2), (int)(3));
                            integrityCheckResultRow(v);
                            sqlite3VdbeJumpHere(v, (int)(addr));
                        }
                    }
                }
            }

            {
                VdbeOp* aOp;
                aOp = sqlite3VdbeAddOpList(v, ((int)(7 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_endCode, (int)(sqlite3Pragma_iLn));
                if ((aOp) != null)
                {
                    aOp[0].p2 = (int)(1 - mxErr);
                    aOp[2].p4type = (sbyte)(-1);
                    aOp[2].p4.z = "ok";
                    aOp[5].p4type = (sbyte)(-1);
                    aOp[5].p4.z = sqlite3ErrStr((int)(11));
                }

                sqlite3VdbeChangeP3(v, (int)(0), (int)(sqlite3VdbeCurrentAddr(v) - 2));
            }
        }

            break;
        case 14:
        {
            EncName* pEnc;
            if (zRight == null)
            {
                if ((sqlite3ReadSchema(pParse)) != 0)
                    goto pragma_out;
                returnSingleText(v, sqlite3Pragma_encnames[((pParse.db).enc)].zName);
            }
            else
            {
                if ((db.mDbFlags &amp; 0x0040) == (0))
                {
                    for (pEnc = &amp;sqlite3Pragma_encnames[0]; pEnc-&gt;zName; pEnc++)
                    {
                        if ((0) == (sqlite3StrICmp(zRight, pEnc-&gt;zName)))
                        {
                            byte enc = (byte)((pEnc-&gt;enc) != 0 ? pEnc-&gt;enc : 2);
                            ((db).aDb[0].pSchema.enc) = (byte)(enc);
                            sqlite3SetTextEncoding(db, (byte)(enc));
                            break;
                        }
                    }

                    if (pEnc-&gt;zName == null)
                    {
                        sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
                    }
                }
            }
        }

            break;
        case 2:
        {
            int iCookie = (int)(pPragma-&gt;iArg);
            sqlite3VdbeUsesBtree(v, (int)(iDb));
            if (((zRight) != null) &amp;&amp; ((pPragma-&gt;mPragFlg &amp; 0x08) == (0)))
            {
                VdbeOp* aOp;
                aOp = sqlite3VdbeAddOpList(v, ((int)(2 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_setCookie, (int)(0));
                if ((0) != 0)
                    break;
                aOp[0].p1 = (int)(iDb);
                aOp[1].p1 = (int)(iDb);
                aOp[1].p2 = (int)(iCookie);
                aOp[1].p3 = (int)(sqlite3Atoi(zRight));
                aOp[1].p5 = (ushort)(1);
            }
            else
            {
                VdbeOp* aOp;
                aOp = sqlite3VdbeAddOpList(v, ((int)(3 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_readCookie, (int)(0));
                if ((0) != 0)
                    break;
                aOp[0].p1 = (int)(iDb);
                aOp[1].p1 = (int)(iDb);
                aOp[1].p3 = (int)(iCookie);
                sqlite3VdbeReusable(v);
            }
        }

            break;
        case 10:
        {
            int i = (int)(0);
            sbyte* zOpt;
            pParse.nMem = (int)(1);
            while ((zOpt = sqlite3_compileoption_get((int)(i++))) != null)
            {
                sqlite3VdbeLoadString(v, (int)(1), zOpt);
                sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
            }

            sqlite3VdbeReusable(v);
        }

            break;
        case 43:
        {
            int iBt = (int)((pId2-&gt;z) != 0 ? iDb : (10 + 2));
            int eMode = (int)(0);
            if ((zRight) != null)
            {
                if ((sqlite3StrICmp(zRight, "full")) == (0))
                {
                    eMode = (int)(1);
                }
                else if ((sqlite3StrICmp(zRight, "restart")) == (0))
                {
                    eMode = (int)(2);
                }
                else if ((sqlite3StrICmp(zRight, "truncate")) == (0))
                {
                    eMode = (int)(3);
                }
            }

            pParse.nMem = (int)(3);
            sqlite3VdbeAddOp3(v, (int)(6), (int)(iBt), (int)(eMode), (int)(1));
            sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(3));
        }

            break;
        case 42:
        {
            if ((zRight) != null)
            {
                sqlite3_wal_autocheckpoint(db, (int)(sqlite3Atoi(zRight)));
            }

            returnSingleInt(v, (long)((db.xWalCallback) == (sqlite3WalDefaultHook) ? ((int)((long)(db.pWalArg))) : 0));
        }

            break;
        case 34:
        {
            sqlite3_db_release_memory(db);
            break;
        }

        case 30:
        {
            int iDbLast = 0;
            int iTabCur = 0;
            HashElem* k;
            Schema pSchema;
            Table pTab;
            Index pIdx;
            short szThreshold = 0;
            sbyte* zSubSql;
            uint opMask = 0;
            if ((zRight) != null)
            {
                opMask = ((uint)(sqlite3Atoi(zRight)));
                if ((opMask &amp; 0x02) == (0))
                    break;
            }
            else
            {
                opMask = (uint)(0xfffe);
            }

            iTabCur = (int)(pParse.nTab++);
            for (iDbLast = (int)((zDb) != 0 ? iDb : db.nDb - 1); (iDb) &lt;= (iDbLast); iDb++)
            {
                if ((iDb) == (1))
                    continue;
                sqlite3CodeVerifySchema(pParse, (int)(iDb));
                pSchema = db.aDb[iDb].pSchema;
                for (k = ((&amp;pSchema.tblHash)-&gt;first); k; k = ((k)-&gt;next))
                {
                    pTab = (Table)((k)-&gt;data);
                    if ((pTab.tabFlags &amp; 0x00000100) == (0))
                        continue;
                    szThreshold = (short)(pTab.nRowLogEst + 46);
                    for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
                    {
                        if (pIdx.hasStat1 == 0)
                        {
                            szThreshold = (short)(0);
                            break;
                        }
                    }

                    if ((szThreshold) != 0)
                    {
                        sqlite3OpenTable(pParse, (int)(iTabCur), (int)(iDb), pTab, (int)(101));
                        sqlite3VdbeAddOp3(v, (int)(35), (int)(iTabCur), (int)(sqlite3VdbeCurrentAddr(v) + 2 + (opMask &amp; 1)), (int)(szThreshold));
                    }

                    zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"", db.aDb[iDb].zDbSName, pTab.zName);
                    if ((opMask &amp; 0x01) != 0)
                    {
                        int r1 = (int)(sqlite3GetTempReg(pParse));
                        sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(r1), (int)(0), zSubSql, (int)(-7));
                        sqlite3VdbeAddOp2(v, (int)(83), (int)(r1), (int)(1));
                    }
                    else
                    {
                        sqlite3VdbeAddOp4(v, (int)(147), (int)(0), (int)(0), (int)(0), zSubSql, (int)(-7));
                    }
                }
            }

            sqlite3VdbeAddOp0(v, (int)(165));
            break;
        }

        default:
        {
            if ((zRight) != null)
            {
                sqlite3_busy_timeout(db, (int)(sqlite3Atoi(zRight)));
            }

            returnSingleInt(v, (long)(db.busyTimeout));
            break;
        }

        case 35:
        {
            long N = 0;
            if (((zRight) != null) &amp;&amp; ((sqlite3DecOrHexToI64(zRight, &amp;N)) == (0)))
            {
                sqlite3_soft_heap_limit64((long)(N));
            }

            returnSingleInt(v, (long)(sqlite3_soft_heap_limit64((long)(-1))));
            break;
        }

        case 18:
        {
            long N = 0;
            if (((zRight) != null) &amp;&amp; ((sqlite3DecOrHexToI64(zRight, &amp;N)) == (0)))
            {
                long iPrior = (long)(sqlite3_hard_heap_limit64((long)(-1)));
                if (((N) &gt; (0)) &amp;&amp; (((iPrior) == (0)) || ((iPrior) &gt; (N))))
                    sqlite3_hard_heap_limit64((long)(N));
            }

            returnSingleInt(v, (long)(sqlite3_hard_heap_limit64((long)(-1))));
            break;
        }

        case 41:
        {
            long N = 0;
            if ((((zRight) != null) &amp;&amp; ((sqlite3DecOrHexToI64(zRight, &amp;N)) == (0))) &amp;&amp; ((N) &gt;= (0)))
            {
                sqlite3_limit(db, (int)(11), (int)(N &amp; 0x7fffffff));
            }

            returnSingleInt(v, (long)(sqlite3_limit(db, (int)(11), (int)(-1))));
            break;
        }

        case 1:
        {
            long N = 0;
            if ((((zRight) != null) &amp;&amp; ((sqlite3DecOrHexToI64(zRight, &amp;N)) == (0))) &amp;&amp; ((N) &gt;= (0)))
            {
                db.nAnalysisLimit = ((int)(N &amp; 0x7fffffff));
            }

            returnSingleInt(v, (long)(db.nAnalysisLimit));
            break;
        }
    }

    if (((pPragma-&gt;mPragFlg &amp; 0x04) != 0) &amp;&amp; ((zRight) != null))
    {
    }

    pragma_out:
        ; sqlite3DbFree ( db ,  zLeft ) ; 
    sqlite3DbFree(db, zRight);
}</function>
  <function>public static Module sqlite3PragmaVtabRegister(sqlite3 db, sbyte* zName)
{
    PragmaName* pName;
    pName = pragmaLocate(zName + 7);
    if ((pName) == (null))
        return null;
    if ((pName-&gt;mPragFlg &amp; (0x10 | 0x20)) == (0))
        return null;
    return sqlite3VtabCreateModule(db, zName, pragmaVtabModule, (void*)(pName), null);
}</function>
  <function>public static sbyte* sqlite3PreferredTableName(sbyte* zName)
{
    if ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0))
    {
        if ((sqlite3StrICmp(zName + 7, &amp;"sqlite_master"[7])) == (0))
        {
            return "sqlite_schema";
        }

        if ((sqlite3StrICmp(zName + 7, &amp;"sqlite_temp_master"[7])) == (0))
        {
            return "sqlite_temp_schema";
        }
    }

    return zName;
}</function>
  <function>public static int sqlite3Prepare(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, Vdbe pReprepare, sqlite3_stmt** ppStmt, sbyte** pzTail)
{
    int rc = (int)(0);
    int i = 0;
    Parse sParse = new Parse();
    CRuntime.memset((((sbyte*)(sParse)) + ((ulong)(&amp;((0).zErrMsg)))), (int)(0), (ulong)(((ulong)(&amp;((0).aTempReg))) - ((ulong)(&amp;((0).zErrMsg)))));
    CRuntime.memset((((sbyte*)(sParse)) + ((ulong)(&amp;((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&amp;((0).sLastToken)))));
    sParse.pOuterParse = db.pParse;
    db.pParse = sParse;
    sParse.db = db;
    sParse.pReprepare = pReprepare;
    if ((db.mallocFailed) != 0)
        sqlite3ErrorMsg(sParse, "out of memory");
    if ((prepFlags &amp; 0x01) != 0)
    {
        sParse.disableLookaside++;
        db.lookaside.bDisable++;
        db.lookaside.sz = (ushort)(0);
    }

    sParse.disableVtab = (byte)((prepFlags &amp; 0x04) != 0);
    if (db.noSharedCache == 0)
    {
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            Btree pBt = db.aDb[i].pBt;
            if ((pBt) != null)
            {
                rc = (int)(sqlite3BtreeSchemaLocked(pBt));
                if ((rc) != 0)
                {
                    sbyte* zDb = db.aDb[i].zDbSName;
                    sqlite3ErrorWithMsg(db, (int)(rc), "database schema is locked: %s", zDb);
                    goto end_prepare;
                }
            }
        }
    }

    sqlite3VtabUnlockList(db);
    if (((nBytes) &gt;= (0)) &amp;&amp; (((nBytes) == (0)) || (zSql[nBytes - 1] != 0)))
    {
        sbyte* zSqlCopy;
        int mxLen = (int)(db.aLimit[1]);
        if ((nBytes) &gt; (mxLen))
        {
            sqlite3ErrorWithMsg(db, (int)(18), "statement too long");
            rc = (int)(sqlite3ApiExit(db, (int)(18)));
            goto end_prepare;
        }

        zSqlCopy = sqlite3DbStrNDup(db, zSql, (ulong)(nBytes));
        if ((zSqlCopy) != null)
        {
            sqlite3RunParser(sParse, zSqlCopy);
            sParse.zTail = &amp;zSql[sParse.zTail - zSqlCopy];
            sqlite3DbFree(db, zSqlCopy);
        }
        else
        {
            sParse.zTail = &amp;zSql[nBytes];
        }
    }
    else
    {
        sqlite3RunParser(sParse, zSql);
    }

    if ((pzTail) != null)
    {
        *pzTail = sParse.zTail;
    }

    if ((db.init.busy) == (0))
    {
        sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail - zSql), (byte)(prepFlags));
    }

    if ((db.mallocFailed) != 0)
    {
        sParse.rc = (int)(7);
        sParse.checkSchema = (byte)(0);
    }

    if ((sParse.rc != 0) &amp;&amp; (sParse.rc != 101))
    {
        if (((sParse.checkSchema) != 0) &amp;&amp; ((db.init.busy) == (0)))
        {
            schemaIsValid(sParse);
        }

        if ((sParse.pVdbe) != null)
        {
            sqlite3VdbeFinalize(sParse.pVdbe);
        }

        rc = (int)(sParse.rc);
        if ((sParse.zErrMsg) != null)
        {
            sqlite3ErrorWithMsg(db, (int)(rc), "%s", sParse.zErrMsg);
            sqlite3DbFree(db, sParse.zErrMsg);
        }
        else
        {
            sqlite3Error(db, (int)(rc));
        }
    }
    else
    {
        *ppStmt = (sqlite3_stmt*)(sParse.pVdbe);
        rc = (int)(0);
        sqlite3ErrorClear(db);
    }

    while ((sParse.pTriggerPrg) != null)
    {
        TriggerPrg pT = sParse.pTriggerPrg;
        sParse.pTriggerPrg = pT.pNext;
        sqlite3DbFree(db, pT);
    }

    end_prepare:
        ; sqlite3ParseObjectReset ( sParse ) ; 
    return (int)(rc);
}</function>
  <function>public static int sqlite3Prepare16(sqlite3 db, void* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, void** pzTail)
{
    sbyte* zSql8;
    sbyte* zTail8 = null;
    int rc = (int)(0);
    *ppStmt = null;
    if ((sqlite3SafetyCheckOk(db) == 0) || ((zSql) == (null)))
    {
        return (int)(sqlite3MisuseError((int)(134149)));
    }

    if ((nBytes) &gt;= (0))
    {
        int sz = 0;
        sbyte* z = (sbyte*)(zSql);
        for (sz = (int)(0); ((sz) &lt; (nBytes)) &amp;&amp; ((z[sz] != 0) || (z[sz + 1] != 0)); sz += (int)(2))
        {
        }

        nBytes = (int)(sz);
    }

    sqlite3_mutex_enter(db.mutex);
    zSql8 = sqlite3Utf16to8(db, zSql, (int)(nBytes), (byte)(2));
    if ((zSql8) != null)
    {
        rc = (int)(sqlite3LockAndPrepare(db, zSql8, (int)(-1), (uint)(prepFlags), null, ppStmt, &amp;zTail8));
    }

    if (((zTail8) != null) &amp;&amp; ((pzTail) != null))
    {
        int chars_parsed = (int)(sqlite3Utf8CharLen(zSql8, (int)(zTail8 - zSql8)));
        *pzTail = (byte*)(zSql) + sqlite3Utf16ByteLen(zSql, (int)(chars_parsed));
    }

    sqlite3DbFree(db, zSql8);
    rc = (int)(sqlite3ApiExit(db, (int)(rc)));
    sqlite3_mutex_leave(db.mutex);
    return (int)(rc);
}</function>
  <function>public static Index sqlite3PrimaryKeyIndex(Table pTab)
{
    Index p;
    for (p = pTab.pIndex; ((p) != null) &amp;&amp; (!(((p).idxType) == (2))); p = p.pNext)
    {
    }

    return p;
}</function>
  <function>public static void sqlite3PrngRestoreState()
{
    CRuntime.memcpy(&amp;sqlite3Prng, &amp;sqlite3SavedPrng, (ulong)(sizeof(sqlite3PrngType)));
}</function>
  <function>public static void sqlite3PrngSaveState()
{
    CRuntime.memcpy(&amp;sqlite3SavedPrng, &amp;sqlite3Prng, (ulong)(sizeof(sqlite3PrngType)));
}</function>
  <function>public static void sqlite3Put4byte(byte* p, uint v)
{
    uint x = (uint)(_byteswap_ulong((uint)(v)));
    CRuntime.memcpy(p, &amp;x, (ulong)(4));
}</function>
  <function>public static int sqlite3PutVarint(byte* p, ulong v)
{
    if ((v) &lt;= (0x7f))
    {
        p[0] = (byte)(v &amp; 0x7f);
        return (int)(1);
    }

    if ((v) &lt;= (0x3fff))
    {
        p[0] = (byte)(((v &gt;&gt; 7) &amp; 0x7f) | 0x80);
        p[1] = (byte)(v &amp; 0x7f);
        return (int)(2);
    }

    return (int)(putVarint64(p, (ulong)(v)));
}</function>
  <function>public static void sqlite3QuoteValue(sqlite3_str pStr, sqlite3_value pValue)
{
    switch (sqlite3_value_type(pValue))
    {
        case 2:
        {
            double r1 = 0;
            double r2 = 0;
            sbyte* zVal;
            r1 = (double)(sqlite3_value_double(pValue));
            sqlite3_str_appendf(pStr, "%!.15g", (double)(r1));
            zVal = sqlite3_str_value(pStr);
            if ((zVal) != null)
            {
                sqlite3AtoF(zVal, &amp;r2, (int)(pStr.nChar), (byte)(1));
                if (r1 != r2)
                {
                    sqlite3_str_reset(pStr);
                    sqlite3_str_appendf(pStr, "%!.20e", (double)(r1));
                }
            }

            break;
        }

        case 1:
        {
            sqlite3_str_appendf(pStr, "%lld", (long)(sqlite3_value_int64(pValue)));
            break;
        }

        case 4:
        {
            sbyte* zBlob = sqlite3_value_blob(pValue);
            int nBlob = (int)(sqlite3_value_bytes(pValue));
            sqlite3StrAccumEnlarge(pStr, (int)(nBlob * 2 + 4));
            if ((pStr.accError) == (0))
            {
                sbyte* zText = pStr.zText;
                int i = 0;
                for (i = (int)(0); (i) &lt; (nBlob); i++)
                {
                    zText[(i * 2) + 2] = (sbyte)(hexdigits[(zBlob[i] &gt;&gt; 4) &amp; 0x0F]);
                    zText[(i * 2) + 3] = (sbyte)(hexdigits[(zBlob[i]) &amp; 0x0F]);
                }

                zText[(nBlob * 2) + 2] = (sbyte)(39);
                zText[(nBlob * 2) + 3] = (sbyte)(0);
                zText[0] = (sbyte)(88);
                zText[1] = (sbyte)(39);
                pStr.nChar = (uint)(nBlob * 2 + 3);
            }

            break;
        }

        case 3:
        {
            byte* zArg = sqlite3_value_text(pValue);
            sqlite3_str_appendf(pStr, "%Q", zArg);
            break;
        }

        default:
        {
            sqlite3_str_append(pStr, "NULL", (int)(4));
            break;
        }
    }
}</function>
  <function>public static int sqlite3ReadOnlyShadowTables(sqlite3 db)
{
    if (((((db.flags &amp; 0x10000000) != 0) &amp;&amp; ((db.pVtabCtx) == (null))) &amp;&amp; ((db.nVdbeExec) == (0))) &amp;&amp; (!((((db).nVTrans) &gt; (0)) &amp;&amp; (((db).aVTrans) == (null)))))
    {
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3ReadSchema(Parse pParse)
{
    int rc = (int)(0);
    sqlite3 db = pParse.db;
    if (db.init.busy == 0)
    {
        rc = (int)(sqlite3Init(db, &amp;pParse.zErrMsg));
        if (rc != 0)
        {
            pParse.rc = (int)(rc);
            pParse.nErr++;
        }
        else if ((db.noSharedCache) != 0)
        {
            db.mDbFlags |= (uint)(0x0010);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void* sqlite3Realloc(void* pOld, ulong nBytes)
{
    int nOld = 0; int  nNew  =  0 ;  int  nDiff  =  0 ; 
    void* pNew;
    if ((pOld) == (null))
    {
        return sqlite3Malloc((ulong)(nBytes));
    }

    if ((nBytes) == (0))
    {
        sqlite3_free(pOld);
        return null;
    }

    if ((nBytes) &gt;= (0x7fffff00))
    {
        return null;
    }

    nOld = (int)(sqlite3MallocSize(pOld));
    nNew = (int)(sqlite3Config.m.xRoundup((int)(nBytes)));
    if ((nOld) == (nNew))
    {
        pNew = pOld;
    }
    else if ((sqlite3Config.bMemstat) != 0)
    {
        long nUsed = 0;
        sqlite3_mutex_enter(mem0.mutex);
        sqlite3StatusHighwater((int)(5), (int)(nBytes));
        nDiff = (int)(nNew - nOld);
        if (((nDiff) &gt; (0)) &amp;&amp; ((nUsed = (long)(sqlite3StatusValue((int)(0)))) &gt;= (mem0.alarmThreshold - nDiff)))
        {
            sqlite3MallocAlarm((int)(nDiff));
            if (((mem0.hardLimit) &gt; (0)) &amp;&amp; ((nUsed) &gt;= (mem0.hardLimit - nDiff)))
            {
                sqlite3_mutex_leave(mem0.mutex);
                return null;
            }
        }

        pNew = sqlite3Config.m.xRealloc(pOld, (int)(nNew));
        if ((pNew) != null)
        {
            nNew = (int)(sqlite3MallocSize(pNew));
            sqlite3StatusUp((int)(0), (int)(nNew - nOld));
        }

        sqlite3_mutex_leave(mem0.mutex);
    }
    else
    {
        pNew = sqlite3Config.m.xRealloc(pOld, (int)(nNew));
    }

    return pNew;
}</function>
  <function>public static int sqlite3RealSameAsInt(double r1, long i)
{
    double r2 = (double)(i);
    return (((r1) == (0.0)) || ((((memcmp(&amp;r1, &amp;r2, (ulong)(sizeof(double)))) == (0)) &amp;&amp; ((i) &gt;= (-2251799813685248L  L ) ) ) &amp;&amp; ( ( i ) &lt; ( 2251799813685248L  L ) ) ) ? 1 :  0 ) ; 
}</function>
  <function>public static void sqlite3RecordErrorByteOffset(sqlite3 db, sbyte* z)
{
    Parse pParse;
    sbyte* zText;
    sbyte* zEnd;
    if (((db) == (null)))
        return;
    if (db.errByteOffset != (-2))
        return;
    pParse = db.pParse;
    if (((pParse) == (null)))
        return;
    zText = pParse.zTail;
    if (((zText) == (null)))
        return;
    zEnd = &amp;zText[CRuntime.strlen(zText)];
    if (((((ulong)(z)) &gt;= ((ulong)(zText))) &amp;&amp; (((ulong)(z)) &lt; ((ulong)(zEnd)))))
    {
        db.errByteOffset = ((int)(z - zText));
    }
}</function>
  <function>public static void sqlite3RecordErrorOffsetOfExpr(sqlite3 db, Expr pExpr)
{
    while (((pExpr) != null) &amp;&amp; ((((pExpr).flags &amp; (0x000001)) != 0) || ((pExpr.w.iOfst) &lt;= (0))))
    {
        pExpr = pExpr.pLeft;
    }

    if ((pExpr) == (null))
        return;
    db.errByteOffset = (int)(pExpr.w.iOfst);
}</function>
  <function>public static int sqlite3ReferencesSrcList(Parse pParse, Expr pExpr, SrcList pSrcList)
{
    Walker w = new Walker();
    RefSrcList x = new RefSrcList();
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    CRuntime.memset(x, (int)(0), (ulong)(sizeof(RefSrcList)));
    w.xExprCallback = exprRefToSrcList;
    w.xSelectCallback = selectRefEnter;
    w.xSelectCallback2 = selectRefLeave;
    w.u.pRefSrcList = x;
    x.db = pParse.db;
    x.pRef = pSrcList;
    sqlite3WalkExprList(w, pExpr.x.pList);
    if ((((pExpr).flags &amp; (0x1000000)) != 0))
    {
        sqlite3WalkExpr(w, pExpr.y.pWin.pFilter);
    }

    sqlite3DbFree(pParse.db, x.aiExclude);
    if ((w.eCode &amp; 0x01) != 0)
    {
        return (int)(1);
    }
    else if ((w.eCode) != 0)
    {
        return (int)(0);
    }
    else
    {
        return (int)(-1);
    }
}</function>
  <function>public static void sqlite3RefillIndex(Parse pParse, Index pIndex, int memRootPage)
{
    Table pTab = pIndex.pTable;
    int iTab = (int)(pParse.nTab++);
    int iIdx = (int)(pParse.nTab++);
    int iSorter = 0;
    int addr1 = 0;
    int addr2 = 0;
    uint tnum = 0;
    int iPartIdxLabel = 0;
    Vdbe v;
    KeyInfo pKey;
    int regRecord = 0;
    sqlite3 db = pParse.db;
    int iDb = (int)(sqlite3SchemaToIndex(db, pIndex.pSchema));
    if ((sqlite3AuthCheck(pParse, (int)(27), pIndex.zName, null, db.aDb[iDb].zDbSName)) != 0)
    {
        return;
    }

    sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(1), pTab.zName);
    v = sqlite3GetVdbe(pParse);
    if ((v) == (null))
        return;
    if ((memRootPage) &gt;= (0))
    {
        tnum = ((uint)(memRootPage));
    }
    else
    {
        tnum = (uint)(pIndex.tnum);
    }

    pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);
    iSorter = (int)(pParse.nTab++);
    sqlite3VdbeAddOp4(v, (int)(118), (int)(iSorter), (int)(0), (int)(pIndex.nKeyCol), (sbyte*)(sqlite3KeyInfoRef(pKey)), (int)(-9));
    sqlite3OpenTable(pParse, (int)(iTab), (int)(iDb), pTab, (int)(101));
    addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iTab), (int)(0)));
    regRecord = (int)(sqlite3GetTempReg(pParse));
    sqlite3MultiWrite(pParse);
    sqlite3GenerateIndexKey(pParse, pIndex, (int)(iTab), (int)(regRecord), (int)(0), &amp;iPartIdxLabel, null, (int)(0));
    sqlite3VdbeAddOp2(v, (int)(138), (int)(iSorter), (int)(regRecord));
    sqlite3ResolvePartIdxLabel(pParse, (int)(iPartIdxLabel));
    sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addr1 + 1));
    sqlite3VdbeJumpHere(v, (int)(addr1));
    if ((memRootPage) &lt; (0))
        sqlite3VdbeAddOp2(v, (int)(144), (int)(tnum), (int)(iDb));
    sqlite3VdbeAddOp4(v, (int)(112), (int)(iIdx), (int)(tnum), (int)(iDb), (sbyte*)(pKey), (int)(-9));
    sqlite3VdbeChangeP5(v, (ushort)(0x01 | (((memRootPage) &gt;= (0)) ? 0x10 : 0)));
    addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(36), (int)(iSorter), (int)(0)));
    if (((pIndex).onError != 0))
    {
        int j2 = (int)(sqlite3VdbeGoto(v, (int)(1)));
        addr2 = (int)(sqlite3VdbeCurrentAddr(v));
        sqlite3VdbeAddOp4Int(v, (int)(131), (int)(iSorter), (int)(j2), (int)(regRecord), (int)(pIndex.nKeyCol));
        sqlite3UniqueConstraint(pParse, (int)(2), pIndex);
        sqlite3VdbeJumpHere(v, (int)(j2));
    }
    else
    {
        sqlite3MayAbort(pParse);
        addr2 = (int)(sqlite3VdbeCurrentAddr(v));
    }

    sqlite3VdbeAddOp3(v, (int)(132), (int)(iSorter), (int)(regRecord), (int)(iIdx));
    if (pIndex.bAscKeyBug == 0)
    {
        sqlite3VdbeAddOp1(v, (int)(136), (int)(iIdx));
    }

    sqlite3VdbeAddOp2(v, (int)(137), (int)(iIdx), (int)(regRecord));
    sqlite3VdbeChangeP5(v, (ushort)(0x10));
    sqlite3ReleaseTempReg(pParse, (int)(regRecord));
    sqlite3VdbeAddOp2(v, (int)(3), (int)(iSorter), (int)(addr2));
    sqlite3VdbeJumpHere(v, (int)(addr1));
    sqlite3VdbeAddOp1(v, (int)(121), (int)(iTab));
    sqlite3VdbeAddOp1(v, (int)(121), (int)(iIdx));
    sqlite3VdbeAddOp1(v, (int)(121), (int)(iSorter));
}</function>
  <function>public static void sqlite3RegisterBuiltinFunctions()
{
    sqlite3AlterFunctions();
    sqlite3WindowFunctions();
    sqlite3RegisterDateTimeFunctions();
    sqlite3RegisterJsonFunctions();
    sqlite3InsertBuiltinFuncs(sqlite3RegisterBuiltinFunctions_aBuiltinFunc, ((int)(69 * sizeof(FuncDef) / sizeof(FuncDef))));
}</function>
  <function>public static void sqlite3RegisterDateTimeFunctions()
{
    sqlite3InsertBuiltinFuncs(sqlite3RegisterDateTimeFunctions_aDateTimeFuncs, ((int)(9 * sizeof(FuncDef) / sizeof(FuncDef))));
}</function>
  <function>public static void sqlite3RegisterJsonFunctions()
{
    sqlite3InsertBuiltinFuncs(sqlite3RegisterJsonFunctions_aJsonFunc, ((int)(19 * sizeof(FuncDef) / sizeof(FuncDef))));
}</function>
  <function>public static void sqlite3RegisterLikeFunctions(sqlite3 db, int caseSensitive)
{
    compareInfo* pInfo;
    int flags = 0;
    if ((caseSensitive) != 0)
    {
        pInfo = &amp;likeInfoAlt;
        flags = (int)(0x0004 | 0x0008);
    }
    else
    {
        pInfo = &amp;likeInfoNorm;
        flags = (int)(0x0004);
    }

    sqlite3CreateFunc(db, "like", (int)(2), (int)(1), pInfo, likeFunc, null, null, null, null, null);
    sqlite3CreateFunc(db, "like", (int)(3), (int)(1), pInfo, likeFunc, null, null, null, null, null);
    sqlite3FindFunction(db, "like", (int)(2), (byte)(1), (byte)(0)).funcFlags |= (uint)(flags);
    sqlite3FindFunction(db, "like", (int)(3), (byte)(1), (byte)(0)).funcFlags |= (uint)(flags);
}</function>
  <function>public static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 db)
{
    int rc = (int)(sqlite3_overload_function(db, "MATCH", (int)(2)));
    if ((rc) == (7))
    {
        sqlite3OomFault(db);
    }
}</function>
  <function>public static void sqlite3Reindex(Parse pParse, Token* pName1, Token* pName2)
{
    CollSeq pColl;
    sbyte* z;
    sbyte* zDb;
    Table pTab;
    Index pIndex;
    int iDb = 0;
    sqlite3 db = pParse.db;
    Token* pObjName;
    if (0 != sqlite3ReadSchema(pParse))
    {
        return;
    }

    if ((pName1) == (null))
    {
        reindexDatabases(pParse, null);
        return;
    }
    else if (((pName2) == (null)) || ((pName2-&gt;z) == (null)))
    {
        sbyte* zColl;
        zColl = sqlite3NameFromToken(pParse.db, pName1);
        if (zColl == null)
            return;
        pColl = sqlite3FindCollSeq(db, (byte)((db).enc), zColl, (int)(0));
        if ((pColl) != null)
        {
            reindexDatabases(pParse, zColl);
            sqlite3DbFree(db, zColl);
            return;
        }

        sqlite3DbFree(db, zColl);
    }

    iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &amp;pObjName));
    if ((iDb) &lt; (0))
        return;
    z = sqlite3NameFromToken(db, pObjName);
    if ((z) == (null))
        return;
    zDb = db.aDb[iDb].zDbSName;
    pTab = sqlite3FindTable(db, z, zDb);
    if ((pTab) != null)
    {
        reindexTable(pParse, pTab, null);
        sqlite3DbFree(db, z);
        return;
    }

    pIndex = sqlite3FindIndex(db, z, zDb);
    sqlite3DbFree(db, z);
    if ((pIndex) != null)
    {
        sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
        sqlite3RefillIndex(pParse, pIndex, (int)(-1));
        return;
    }

    sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
}</function>
  <function>public static void sqlite3ReleaseTempRange(Parse pParse, int iReg, int nReg)
{
    if ((nReg) == (1))
    {
        sqlite3ReleaseTempReg(pParse, (int)(iReg));
        return;
    }

    if ((nReg) &gt; (pParse.nRangeReg))
    {
        pParse.nRangeReg = (int)(nReg);
        pParse.iRangeReg = (int)(iReg);
    }
}</function>
  <function>public static void sqlite3ReleaseTempReg(Parse pParse, int iReg)
{
    if ((iReg) != 0)
    {
        if ((pParse.nTempReg) &lt; ((int)(8 * sizeof(int) / sizeof(int))))
        {
            pParse.aTempReg[pParse.nTempReg++] = (int)(iReg);
        }
    }
}</function>
  <function>public static void sqlite3RenameExprlistUnmap(Parse pParse, ExprList pEList)
{
    if ((pEList) != null)
    {
        int i = 0;
        Walker sWalker = new Walker();
        CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
        sWalker.pParse = pParse;
        sWalker.xExprCallback = renameUnmapExprCb;
        sqlite3WalkExprList(sWalker, pEList);
        for (i = (int)(0); (i) &lt; (pEList.nExpr); i++)
        {
            if (((pEList.a[i].eEName) == (0)))
            {
                sqlite3RenameTokenRemap(pParse, null, (void*)(pEList.a[i].zEName));
            }
        }
    }
}</function>
  <function>public static void sqlite3RenameExprUnmap(Parse pParse, Expr pExpr)
{
    byte eMode = (byte)(pParse.eParseMode);
    Walker sWalker = new Walker();
    CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
    sWalker.pParse = pParse;
    sWalker.xExprCallback = renameUnmapExprCb;
    sWalker.xSelectCallback = renameUnmapSelectCb;
    pParse.eParseMode = (byte)(3);
    sqlite3WalkExpr(sWalker, pExpr);
    pParse.eParseMode = (byte)(eMode);
}</function>
  <function>public static void* sqlite3RenameTokenMap(Parse pParse, void* pPtr, Token* pToken)
{
    RenameToken* pNew;
    if ((pParse.eParseMode != 3))
    {
        pNew = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(RenameToken)));
        if ((pNew) != null)
        {
            pNew-&gt;p = pPtr;
            pNew-&gt;t = (Token)(*pToken);
            pNew-&gt;pNext = pParse.pRename;
            pParse.pRename = pNew;
        }
    }

    return pPtr;
}</function>
  <function>public static void sqlite3RenameTokenRemap(Parse pParse, void* pTo, void* pFrom)
{
    RenameToken* p;
    for (p = pParse.pRename; p; p = p-&gt;pNext)
    {
        if ((p-&gt;p) == (pFrom))
        {
            p-&gt;p = pTo;
            break;
        }
    }
}</function>
  <function>public static int sqlite3ReportError(int iErr, int lineno, sbyte* zType)
{
    sqlite3_log((int)(iErr), "%s at line %d of [%.10s]", zType, (int)(lineno), 20 + sqlite3_sourceid());
    return (int)(iErr);
}</function>
  <function>public static int sqlite3Reprepare(Vdbe p)
{
    int rc = 0;
    sqlite3_stmt* pNew;
    sbyte* zSql;
    sqlite3 db;
    byte prepFlags = 0;
    zSql = sqlite3_sql((sqlite3_stmt*)(p));
    db = sqlite3VdbeDb(p);
    prepFlags = (byte)(sqlite3VdbePrepareFlags(p));
    rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(-1), (uint)(prepFlags), p, &amp;pNew, null));
    if ((rc) != 0)
    {
        if ((rc) == (7))
        {
            sqlite3OomFault(db);
        }

        return (int)(rc);
    }
    else
    {
    }

    sqlite3VdbeSwap((Vdbe)(pNew), p);
    sqlite3TransferBindings(pNew, (sqlite3_stmt*)(p));
    sqlite3VdbeResetStepResult((Vdbe)(pNew));
    sqlite3VdbeFinalize((Vdbe)(pNew));
    return (int)(0);
}</function>
  <function>public static void sqlite3ResetAllSchemasOfConnection(sqlite3 db)
{
    int i = 0;
    sqlite3BtreeEnterAll(db);
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        Db pDb = db.aDb[i];
        if ((pDb.pSchema) != null)
        {
            if ((db.nSchemaLock) == (0))
            {
                sqlite3SchemaClear(pDb.pSchema);
            }
            else
            {
                (db).aDb[i].pSchema.schemaFlags |= (ushort)(0x0008);
            }
        }
    }

    db.mDbFlags &amp;= (uint)(~(0x0001 | 0x0010));
    sqlite3VtabUnlockList(db);
    sqlite3BtreeLeaveAll(db);
    if ((db.nSchemaLock) == (0))
    {
        sqlite3CollapseDatabaseArray(db);
    }
}</function>
  <function>public static void sqlite3ResetOneSchema(sqlite3 db, int iDb)
{
    int i = 0;
    if ((iDb) &gt;= (0))
    {
        (db).aDb[iDb].pSchema.schemaFlags |= (ushort)(0x0008);
        (db).aDb[1].pSchema.schemaFlags |= (ushort)(0x0008);
        db.mDbFlags &amp;= (uint)(~0x0010);
    }

    if ((db.nSchemaLock) == (0))
    {
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            if ((((db).aDb[i].pSchema.schemaFlags &amp; (0x0008)) == (0x0008)))
            {
                sqlite3SchemaClear(db.aDb[i].pSchema);
            }
        }
    }
}</function>
  <function>public static int sqlite3ResolveExprListNames(NameContext pNC, ExprList pList)
{
    int i = 0;
    int savedHasAgg = (int)(0);
    Walker w = new Walker();
    if ((pList) == (null))
        return (int)(0);
    w.pParse = pNC.pParse;
    w.xExprCallback = resolveExprStep;
    w.xSelectCallback = resolveSelectStep;
    w.xSelectCallback2 = null;
    w.u.pNC = pNC;
    savedHasAgg = (int)(pNC.ncFlags &amp; (0x000010 | 0x001000 | 0x008000 | 0x8000000));
    pNC.ncFlags &amp;= (int)(~(0x000010 | 0x001000 | 0x008000 | 0x8000000));
    for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
    {
        Expr pExpr = pList.a[i].pExpr;
        if ((pExpr) == (null))
            continue;
        w.pParse.nHeight += (int)(pExpr.nHeight);
        if ((sqlite3ExprCheckHeight(w.pParse, (int)(w.pParse.nHeight))) != 0)
        {
            return (int)(2);
        }

        sqlite3WalkExpr(w, pExpr);
        w.pParse.nHeight -= (int)(pExpr.nHeight);
        if ((pNC.ncFlags &amp; (0x000010 | 0x001000 | 0x008000 | 0x8000000)) != 0)
        {
            (pExpr).flags |= (uint)(pNC.ncFlags &amp; (0x000010 | 0x008000));
            savedHasAgg |= (int)(pNC.ncFlags &amp; (0x000010 | 0x001000 | 0x008000 | 0x8000000));
            pNC.ncFlags &amp;= (int)(~(0x000010 | 0x001000 | 0x008000 | 0x8000000));
        }

        if ((w.pParse.nErr) &gt; (0))
            return (int)(2);
    }

    pNC.ncFlags |= (int)(savedHasAgg);
    return (int)(0);
}</function>
  <function>public static int sqlite3ResolveExprNames(NameContext pNC, Expr pExpr)
{
    int savedHasAgg = 0;
    Walker w = new Walker();
    if ((pExpr) == (null))
        return (int)(0);
    savedHasAgg = (int)(pNC.ncFlags &amp; (0x000010 | 0x001000 | 0x008000 | 0x8000000));
    pNC.ncFlags &amp;= (int)(~(0x000010 | 0x001000 | 0x008000 | 0x8000000));
    w.pParse = pNC.pParse;
    w.xExprCallback = resolveExprStep;
    w.xSelectCallback = (pNC.ncFlags &amp; 0x080000) ? null : resolveSelectStep;
    w.xSelectCallback2 = null;
    w.u.pNC = pNC;
    w.pParse.nHeight += (int)(pExpr.nHeight);
    if ((sqlite3ExprCheckHeight(w.pParse, (int)(w.pParse.nHeight))) != 0)
    {
        return (int)(1);
    }

    sqlite3WalkExpr(w, pExpr);
    w.pParse.nHeight -= (int)(pExpr.nHeight);
    (pExpr).flags |= (uint)(pNC.ncFlags &amp; (0x000010 | 0x008000));
    pNC.ncFlags |= (int)(savedHasAgg);
    return (((pNC.nNcErr) &gt; (0)) || ((w.pParse.nErr) &gt; (0)) ? 1 : 0);
}</function>
  <function>public static int sqlite3ResolveOrderGroupBy(Parse pParse, Select pSelect, ExprList pOrderBy, sbyte* zType)
{
    int i = 0;
    sqlite3 db = pParse.db;
    ExprList pEList;
    ExprList_item* pItem;
    if ((((pOrderBy) == (null)) || ((pParse.db.mallocFailed) != 0)) || ((pParse.eParseMode) &gt;= (2)))
        return (int)(0);
    if ((pOrderBy.nExpr) &gt; (db.aLimit[2]))
    {
        sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
        return (int)(1);
    }

    pEList = pSelect.pEList;
    for (i = (int)(0), pItem = pOrderBy.a; (i) &lt; (pOrderBy.nExpr); i++, pItem++)
    {
        if ((pItem-&gt;u.x.iOrderByCol) != 0)
        {
            if ((pItem-&gt;u.x.iOrderByCol) &gt; (pEList.nExpr))
            {
                resolveOutOfRangeError(pParse, zType, (int)(i + 1), (int)(pEList.nExpr), null);
                return (int)(1);
            }

            resolveAlias(pParse, pEList, (int)(pItem-&gt;u.x.iOrderByCol - 1), pItem-&gt;pExpr, (int)(0));
        }
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3ResolvePartIdxLabel(Parse pParse, int iLabel)
{
    if ((iLabel) != 0)
    {
        sqlite3VdbeResolveLabel(pParse.pVdbe, (int)(iLabel));
    }
}</function>
  <function>public static void sqlite3ResolveSelectNames(Parse pParse, Select p, NameContext pOuterNC)
{
    Walker w = new Walker();
    w.xExprCallback = resolveExprStep;
    w.xSelectCallback = resolveSelectStep;
    w.xSelectCallback2 = null;
    w.pParse = pParse;
    w.u.pNC = pOuterNC;
    sqlite3WalkSelect(w, p);
}</function>
  <function>public static int sqlite3ResolveSelfReference(Parse pParse, Table pTab, int type, Expr pExpr, ExprList pList)
{
    SrcList sSrc = new SrcList();
    NameContext sNC = new NameContext();
    int rc = 0;
    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    CRuntime.memset(sSrc, (int)(0), (ulong)(sizeof(SrcList)));
    if ((pTab) != null)
    {
        sSrc.nSrc = (int)(1);
        sSrc.a[0].zName = pTab.zName;
        sSrc.a[0].pTab = pTab;
        sSrc.a[0].iCursor = (int)(-1);
        if (pTab.pSchema != pParse.db.aDb[1].pSchema)
        {
            type |= (int)(0x040000);
        }
    }

    sNC.pParse = pParse;
    sNC.pSrcList = sSrc;
    sNC.ncFlags = (int)(type | 0x010000);
    if ((rc = (int)(sqlite3ResolveExprNames(sNC, pExpr))) != 0)
        return (int)(rc);
    if ((pList) != null)
        rc = (int)(sqlite3ResolveExprListNames(sNC, pList));
    return (int)(rc);
}</function>
  <function>public static void sqlite3ResultIntReal(sqlite3_context pCtx)
{
    if ((pCtx.pOut.flags &amp; 0x0004) != 0)
    {
        pCtx.pOut.flags &amp;= (ushort)(~0x0004);
        pCtx.pOut.flags |= (ushort)(0x0020);
    }
}</function>
  <function>public static Table sqlite3ResultSetOfSelect(Parse pParse, Select pSelect, sbyte aff)
{
    Table pTab;
    sqlite3 db = pParse.db;
    ulong savedFlags = 0;
    savedFlags = (ulong)(db.flags);
    db.flags &amp;= (ulong)(~(ulong)(0x00000004));
    db.flags |= (ulong)(0x00000040);
    sqlite3SelectPrep(pParse, pSelect, null);
    db.flags = (ulong)(savedFlags);
    if ((pParse.nErr) != 0)
        return null;
    while ((pSelect.pPrior) != null)
    {
        pSelect = pSelect.pPrior;
    }

    pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
    if ((pTab) == (null))
    {
        return null;
    }

    pTab.nTabRef = (uint)(1);
    pTab.zName = null;
    pTab.nRowLogEst = (short)(200);
    sqlite3ColumnsFromExprList(pParse, pSelect.pEList, &amp;pTab.nCol, &amp;pTab.aCol);
    sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, (sbyte)(aff));
    pTab.iPKey = (short)(-1);
    if ((db.mallocFailed) != 0)
    {
        sqlite3DeleteTable(db, pTab);
        return null;
    }

    return pTab;
}</function>
  <function>public static void sqlite3ResultStrAccum(sqlite3_context pCtx, sqlite3_str p)
{
    if ((p.accError) != 0)
    {
        sqlite3_result_error_code(pCtx, (int)(p.accError));
        sqlite3_str_reset(p);
    }
    else if ((((p).printfFlags &amp; 0x04) != 0))
    {
        sqlite3_result_text(pCtx, p.zText, (int)(p.nChar), ((Void(Void * ))(sqlite3OomFault)));
    }
    else
    {
        sqlite3_result_text(pCtx, "", (int)(0), null);
        sqlite3_str_reset(p);
    }
}</function>
  <function>public static void sqlite3RollbackAll(sqlite3 db, int tripCode)
{
    int i = 0;
    int inTrans = (int)(0);
    int schemaChange = 0;
    sqlite3BeginBenignMalloc();
    sqlite3BtreeEnterAll(db);
    schemaChange = (int)(((db.mDbFlags &amp; 0x0001) != 0) &amp;&amp; ((db.init.busy) == (0)) ? 1 : 0);
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        Btree p = db.aDb[i].pBt;
        if ((p) != null)
        {
            if ((sqlite3BtreeTxnState(p)) == (2))
            {
                inTrans = (int)(1);
            }

            sqlite3BtreeRollback(p, (int)(tripCode), (int)(!schemaChange));
        }
    }

    sqlite3VtabRollback(db);
    sqlite3EndBenignMalloc();
    if ((schemaChange) != 0)
    {
        sqlite3ExpirePreparedStatements(db, (int)(0));
        sqlite3ResetAllSchemasOfConnection(db);
    }

    sqlite3BtreeLeaveAll(db);
    db.nDeferredCons = (long)(0);
    db.nDeferredImmCons = (long)(0);
    db.flags &amp;= (ulong)(~(0x00080000 | ((ulong)(0x00002) &lt;&lt; 32)));
    if (((db.xRollbackCallback) != null) &amp;&amp; (((inTrans) != 0) || (db.autoCommit == 0)))
    {
        db.xRollbackCallback(db.pRollbackArg);
    }
}</function>
  <function>public static void sqlite3RootPageMoved(sqlite3 db, int iDb, uint iFrom, uint iTo)
{
    HashElem* pElem;
    Hash* pHash;
    Db pDb;
    pDb = db.aDb[iDb];
    pHash = &amp;pDb.pSchema.tblHash;
    for (pElem = ((pHash)-&gt;first); pElem; pElem = ((pElem)-&gt;next))
    {
        Table pTab = ((pElem)-&gt;data);
        if ((pTab.tnum) == (iFrom))
        {
            pTab.tnum = (uint)(iTo);
        }
    }

    pHash = &amp;pDb.pSchema.idxHash;
    for (pElem = ((pHash)-&gt;first); pElem; pElem = ((pElem)-&gt;next))
    {
        Index pIdx = ((pElem)-&gt;data);
        if ((pIdx.tnum) == (iFrom))
        {
            pIdx.tnum = (uint)(iTo);
        }
    }
}</function>
  <function>public static void sqlite3RowidConstraint(Parse pParse, int onError, Table pTab)
{
    sbyte* zMsg;
    int rc = 0;
    if ((pTab.iPKey) &gt;= (0))
    {
        zMsg = sqlite3MPrintf(pParse.db, "%s.%s", pTab.zName, pTab.aCol[pTab.iPKey].zCnName);
        rc = (int)(19 | (6 &lt;&lt; 8));
    }
    else
    {
        zMsg = sqlite3MPrintf(pParse.db, "%s.rowid", pTab.zName);
        rc = (int)(19 | (10 &lt;&lt; 8));
    }

    sqlite3HaltConstraint(pParse, (int)(rc), (int)(onError), zMsg, (sbyte)(-7), (byte)(2));
}</function>
  <function>public static void sqlite3RowSetClear(void* pArg)
{
    RowSet p = (RowSet)(pArg);
    RowSetChunk pChunk; RowSetChunk  pNextChunk ; 
    for (pChunk = p.pChunk; pChunk; pChunk = pNextChunk)
    {
        pNextChunk = pChunk.pNextChunk;
        sqlite3DbFree(p.db, pChunk);
    }

    p.pChunk = null;
    p.nFresh = (ushort)(0);
    p.pEntry = null;
    p.pLast = null;
    p.pForest = null;
    p.rsFlags = (ushort)(0x01);
}</function>
  <function>public static void sqlite3RowSetDelete(void* pArg)
{
    sqlite3RowSetClear(pArg);
    sqlite3DbFree(((RowSet)(pArg)).db, pArg);
}</function>
  <function>public static RowSet sqlite3RowSetInit(sqlite3 db)
{
    RowSet p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(RowSet)));
    if ((p) != null)
    {
        int N = (int)(sqlite3DbMallocSize(db, p));
        p.pChunk = null;
        p.db = db;
        p.pEntry = null;
        p.pLast = null;
        p.pForest = null;
        p.pFresh = (RowSetEntry*)((((sizeof(RowSet)) + 7) &amp; ~7) + (sbyte*)(p));
        p.nFresh = ((ushort)((N - (((sizeof(RowSet)) + 7) &amp; ~7)) / sizeof(RowSetEntry)));
        p.rsFlags = (ushort)(0x01);
        p.iBatch = (int)(0);
    }

    return p;
}</function>
  <function>public static void sqlite3RowSetInsert(RowSet p, long rowid)
{
    RowSetEntry* pEntry;
    RowSetEntry* pLast;
    pEntry = rowSetEntryAlloc(p);
    if ((pEntry) == (null))
        return;
    pEntry-&gt;v = (long)(rowid);
    pEntry-&gt;pRight = null;
    pLast = p.pLast;
    if ((pLast) != null)
    {
        if ((rowid) &lt;= (pLast-&gt;v))
        {
            p.rsFlags &amp;= (ushort)(~0x01);
        }

        pLast-&gt;pRight = pEntry;
    }
    else
    {
        p.pEntry = pEntry;
    }

    p.pLast = pEntry;
}</function>
  <function>public static int sqlite3RowSetNext(RowSet p, long* pRowid)
{
    if ((p.rsFlags &amp; 0x02) == (0))
    {
        if ((p.rsFlags &amp; 0x01) == (0))
        {
            p.pEntry = rowSetEntrySort(p.pEntry);
        }

        p.rsFlags |= (ushort)(0x01 | 0x02);
    }

    if ((p.pEntry) != null)
    {
        *pRowid = (long)(p.pEntry-&gt;v);
        p.pEntry = p.pEntry-&gt;pRight;
        if ((p.pEntry) == (null))
        {
            sqlite3RowSetClear(p);
        }

        return (int)(1);
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static int sqlite3RowSetTest(RowSet pRowSet, int iBatch, long iRowid)
{
    RowSetEntry* p; RowSetEntry * pTree ; 
    if (iBatch != pRowSet.iBatch)
    {
        p = pRowSet.pEntry;
        if ((p) != null)
        {
            RowSetEntry** ppPrevTree = &amp;pRowSet.pForest;
            if ((pRowSet.rsFlags &amp; 0x01) == (0))
            {
                p = rowSetEntrySort(p);
            }

            for (pTree = pRowSet.pForest; pTree; pTree = pTree-&gt;pRight)
            {
                ppPrevTree = &amp;pTree-&gt;pRight;
                if ((pTree-&gt;pLeft) == (null))
                {
                    pTree-&gt;pLeft = rowSetListToTree(p);
                    break;
                }
                else
                {
                    RowSetEntry* pAux;
                    RowSetEntry* pTail;
                    rowSetTreeToList(pTree-&gt;pLeft, &amp;pAux, &amp;pTail);
                    pTree-&gt;pLeft = null;
                    p = rowSetEntryMerge(pAux, p);
                }
            }

            if ((pTree) == (null))
            {
                *ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);
                if ((pTree) != null)
                {
                    pTree-&gt;v = (long)(0);
                    pTree-&gt;pRight = null;
                    pTree-&gt;pLeft = rowSetListToTree(p);
                }
            }

            pRowSet.pEntry = null;
            pRowSet.pLast = null;
            pRowSet.rsFlags |= (ushort)(0x01);
        }

        pRowSet.iBatch = (int)(iBatch);
    }

    for (pTree = pRowSet.pForest; pTree; pTree = pTree-&gt;pRight)
    {
        p = pTree-&gt;pLeft;
        while ((p) != null)
        {
            if ((p-&gt;v) &lt; (iRowid))
            {
                p = p-&gt;pRight;
            }
            else if ((p-&gt;v) &gt; (iRowid))
            {
                p = p-&gt;pLeft;
            }
            else
            {
                return (int)(1);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3RunParser(Parse pParse, sbyte* zSql)
{
    int nErr = (int)(0);
    void* pEngine;
    int n = (int)(0);
    int tokenType = 0;
    int lastTokenParsed = (int)(-1);
    sqlite3 db = pParse.db;
    int mxSqlLen = 0;
    Parse pParentParse = null;
    yyParser sEngine = new yyParser();
    mxSqlLen = (int)(db.aLimit[1]);
    if ((db.nVdbeActive) == (0))
    {
        (0);
    }

    pParse.rc = (int)(0);
    pParse.zTail = zSql;
    pEngine = sEngine;
    sqlite3ParserInit(pEngine, pParse);
    pParentParse = db.pParse;
    db.pParse = pParse;
    while ((1) != 0)
    {
        n = (int)(sqlite3GetToken((byte*)(zSql), &amp;tokenType));
        mxSqlLen -= (int)(n);
        if ((mxSqlLen) &lt; (0))
        {
            pParse.rc = (int)(18);
            break;
        }

        if ((tokenType) &gt;= (164))
        {
            if ((0) != 0)
            {
                pParse.rc = (int)(9);
                pParse.nErr++;
                break;
            }

            if ((tokenType) == (183))
            {
                zSql += n;
                continue;
            }

            if ((zSql[0]) == (0))
            {
                if ((lastTokenParsed) == (1))
                {
                    tokenType = (int)(0);
                }
                else if ((lastTokenParsed) == (0))
                {
                    break;
                }
                else
                {
                    tokenType = (int)(1);
                }

                n = (int)(0);
            }
            else if ((tokenType) == (164))
            {
                tokenType = (int)(analyzeWindowKeyword((byte*)(&amp;zSql[6])));
            }
            else if ((tokenType) == (165))
            {
                tokenType = (int)(analyzeOverKeyword((byte*)(&amp;zSql[4]), (int)(lastTokenParsed)));
            }
            else if ((tokenType) == (166))
            {
                tokenType = (int)(analyzeFilterKeyword((byte*)(&amp;zSql[6]), (int)(lastTokenParsed)));
            }
            else
            {
                Token x = new Token();
                x.z = zSql;
                x.n = (uint)(n);
                sqlite3ErrorMsg(pParse, "unrecognized token: \"%T\"", &amp;x);
                break;
            }
        }

        pParse.sLastToken.z = zSql;
        pParse.sLastToken.n = (uint)(n);
        sqlite3Parser(pEngine, (int)(tokenType), (Token)(pParse.sLastToken));
        lastTokenParsed = (int)(tokenType);
        zSql += n;
        if (pParse.rc != 0)
            break;
    }

    sqlite3ParserFinalize(pEngine);
    if ((db.mallocFailed) != 0)
    {
        pParse.rc = (int)(7);
    }

    if (((pParse.zErrMsg) != null) || ((pParse.rc != 0) &amp;&amp; (pParse.rc != 101)))
    {
        if ((pParse.zErrMsg) == (null))
        {
            pParse.zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr((int)(pParse.rc)));
        }

        sqlite3_log((int)(pParse.rc), "%s in \"%s\"", pParse.zErrMsg, pParse.zTail);
        nErr++;
    }

    pParse.zTail = zSql;
    sqlite3_free(pParse.apVtabLock);
    if (((pParse.pNewTable) != null) &amp;&amp; (!(pParse.eParseMode != 0)))
    {
        sqlite3DeleteTable(db, pParse.pNewTable);
    }

    if (((pParse.pNewTrigger) != null) &amp;&amp; (!((pParse.eParseMode) &gt;= (2))))
    {
        sqlite3DeleteTrigger(db, pParse.pNewTrigger);
    }

    sqlite3DbFree(db, pParse.pVList);
    db.pParse = pParentParse;
    return (int)(nErr);
}</function>
  <function>public static int sqlite3RunVacuum(sbyte** pzErrMsg, sqlite3 db, int iDb, sqlite3_value pOut)
{
    int rc = (int)(0);
    Btree pMain;
    Btree pTemp;
    uint saved_mDbFlags = 0;
    ulong saved_flags = 0;
    long saved_nChange = 0;
    long saved_nTotalChange = 0;
    uint saved_openFlags = 0;
    byte saved_mTrace = 0;
    Db pDb = null;
    int isMemDb = 0;
    int nRes = 0;
    int nDb = 0;
    sbyte* zDbMain;
    sbyte* zOut;
    if (db.autoCommit == 0)
    {
        sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
        return (int)(1);
    }

    if ((db.nVdbeActive) &gt; (1))
    {
        sqlite3SetString(pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
        return (int)(1);
    }

    saved_openFlags = (uint)(db.openFlags);
    if ((pOut) != null)
    {
        if (sqlite3_value_type(pOut) != 3)
        {
            sqlite3SetString(pzErrMsg, db, "non-text filename");
            return (int)(1);
        }

        zOut = (sbyte*)(sqlite3_value_text(pOut));
        db.openFlags &amp;= (uint)(~0x00000001);
        db.openFlags |= (uint)(0x00000004 | 0x00000002);
    }
    else
    {
        zOut = "";
    }

    saved_flags = (ulong)(db.flags);
    saved_mDbFlags = (uint)(db.mDbFlags);
    saved_nChange = (long)(db.nChange);
    saved_nTotalChange = (long)(db.nTotalChange);
    saved_mTrace = (byte)(db.mTrace);
    db.flags |= (ulong)(0x00000001 | 0x00000200);
    db.mDbFlags |= (uint)(0x0002 | 0x0004);
    db.flags &amp;= (ulong)(~(0x00004000 | 0x00001000 | 0x10000000 | ((ulong)(0x00001) &lt;&lt; 32)));
    db.mTrace = (byte)(0);
    zDbMain = db.aDb[iDb].zDbSName;
    pMain = db.aDb[iDb].pBt;
    isMemDb = (int)(sqlite3PagerIsMemdb(sqlite3BtreePager(pMain)));
    nDb = (int)(db.nDb);
    rc = (int)(execSqlF(db, pzErrMsg, "ATTACH %Q AS vacuum_db", zOut));
    db.openFlags = (uint)(saved_openFlags);
    if (rc != 0)
        goto end_of_vacuum;
    pDb = db.aDb[nDb];
    pTemp = pDb.pBt;
    if ((pOut) != null)
    {
        sqlite3_file id = sqlite3PagerFile(sqlite3BtreePager(pTemp));
        long sz = (long)(0);
        if ((id.pMethods != null) &amp;&amp; ((sqlite3OsFileSize(id, &amp;sz) != 0) || ((sz) &gt; (0))))
        {
            rc = (int)(1);
            sqlite3SetString(pzErrMsg, db, "output file already exists");
            goto end_of_vacuum;
        }

        db.mDbFlags |= (uint)(0x0008);
    }

    nRes = (int)(sqlite3BtreeGetRequestedReserve(pMain));
    sqlite3BtreeSetCacheSize(pTemp, (int)(db.aDb[iDb].pSchema.cache_size));
    sqlite3BtreeSetSpillSize(pTemp, (int)(sqlite3BtreeSetSpillSize(pMain, (int)(0))));
    sqlite3BtreeSetPagerFlags(pTemp, (uint)(0x01 | 0x20));
    rc = (int)(execSql(db, pzErrMsg, "BEGIN"));
    if (rc != 0)
        goto end_of_vacuum;
    rc = (int)(sqlite3BtreeBeginTrans(pMain, (int)((pOut) == (null) ? 2 : 0), null));
    if (rc != 0)
        goto end_of_vacuum;
    if (((sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))) == (5)) &amp;&amp; ((pOut) == (null)))
    {
        db.nextPagesize = (int)(0);
    }

    if ((((sqlite3BtreeSetPageSize(pTemp, (int)(sqlite3BtreeGetPageSize(pMain)), (int)(nRes), (int)(0))) != 0) || ((isMemDb == 0) &amp;&amp; ((sqlite3BtreeSetPageSize(pTemp, (int)(db.nextPagesize), (int)(nRes), (int)(0))) != 0))) || ((db.mallocFailed) != 0))
    {
        rc = (int)(7);
        goto end_of_vacuum;
    }

    sqlite3BtreeSetAutoVacuum(pTemp, (int)((db.nextAutovac) &gt;= (0) ? db.nextAutovac : sqlite3BtreeGetAutoVacuum(pMain)));
    db.init.iDb = (byte)(nDb);
    rc = (int)(execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_schema WHERE type='table'AND name&lt;&gt;'sqlite_sequence' AND coalesce(rootpage,1)&gt;0", zDbMain));
    if (rc != 0)
        goto end_of_vacuum;
    rc = (int)(execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_schema WHERE type='index'", zDbMain));
    if (rc != 0)
        goto end_of_vacuum;
    db.init.iDb = (byte)(0);
    rc = (int)(execSqlF(db, pzErrMsg, "SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM\"%w\".'||quote(name)FROM vacuum_db.sqlite_schema WHERE type='table'AND coalesce(rootpage,1)&gt;0", zDbMain));
    db.mDbFlags &amp;= (uint)(~0x0004);
    if (rc != 0)
        goto end_of_vacuum;
    rc = (int)(execSqlF(db, pzErrMsg, "INSERT INTO vacuum_db.sqlite_schema SELECT*FROM \"%w\".sqlite_schema WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)", zDbMain));
    if ((rc) != 0)
        goto end_of_vacuum;
    {
        uint meta = 0;
        int i = 0;
        for (i = (int)(0); (i) &lt; ((int)(10 * sizeof(byte) / sizeof(byte))); i += (int)(2))
        {
            sqlite3BtreeGetMeta(pMain, (int)(sqlite3RunVacuum_aCopy[i]), &amp;meta);
            rc = (int)(sqlite3BtreeUpdateMeta(pTemp, (int)(sqlite3RunVacuum_aCopy[i]), (uint)(meta + sqlite3RunVacuum_aCopy[i + 1])));
            if ((rc != 0))
                goto end_of_vacuum;
        }

        if ((pOut) == (null))
        {
            rc = (int)(sqlite3BtreeCopyFile(pMain, pTemp));
        }

        if (rc != 0)
            goto end_of_vacuum;
        rc = (int)(sqlite3BtreeCommit(pTemp));
        if (rc != 0)
            goto end_of_vacuum;
        if ((pOut) == (null))
        {
            sqlite3BtreeSetAutoVacuum(pMain, (int)(sqlite3BtreeGetAutoVacuum(pTemp)));
        }
    }

    if ((pOut) == (null))
    {
        rc = (int)(sqlite3BtreeSetPageSize(pMain, (int)(sqlite3BtreeGetPageSize(pTemp)), (int)(nRes), (int)(1)));
    }

    end_of_vacuum:
        ; db . init . iDb  =  ( byte ) ( 0 ) ; 
    db.mDbFlags = (uint)(saved_mDbFlags);
    db.flags = (ulong)(saved_flags);
    db.nChange = (long)(saved_nChange);
    db.nTotalChange = (long)(saved_nTotalChange);
    db.mTrace = (byte)(saved_mTrace);
    sqlite3BtreeSetPageSize(pMain, (int)(-1), (int)(0), (int)(1));
    db.autoCommit = (byte)(1);
    if ((pDb) != null)
    {
        sqlite3BtreeClose(pDb.pBt);
        pDb.pBt = null;
        pDb.pSchema = null;
    }

    sqlite3ResetAllSchemasOfConnection(db);
    return (int)(rc);
}</function>
  <function>public static int sqlite3SafetyCheckOk(sqlite3 db)
{
    byte eOpenState = 0;
    if ((db) == (null))
    {
        logBadConnection("NULL");
        return (int)(0);
    }

    eOpenState = (byte)(db.eOpenState);
    if (eOpenState != 0x76)
    {
        if ((sqlite3SafetyCheckSickOrOk(db)) != 0)
        {
            logBadConnection("unopened");
        }

        return (int)(0);
    }
    else
    {
        return (int)(1);
    }
}</function>
  <function>public static int sqlite3SafetyCheckSickOrOk(sqlite3 db)
{
    byte eOpenState = 0;
    eOpenState = (byte)(db.eOpenState);
    if (((eOpenState != 0xba) &amp;&amp; (eOpenState != 0x76)) &amp;&amp; (eOpenState != 0x6d))
    {
        logBadConnection("invalid");
        return (int)(0);
    }
    else
    {
        return (int)(1);
    }
}</function>
  <function>public static void sqlite3Savepoint(Parse pParse, int op, Token* pName)
{
    sbyte* zName = sqlite3NameFromToken(pParse.db, pName);
    if ((zName) != null)
    {
        Vdbe v = sqlite3GetVdbe(pParse);
        if ((v == null) || ((sqlite3AuthCheck(pParse, (int)(32), sqlite3Savepoint_az[op], zName, null)) != 0))
        {
            sqlite3DbFree(pParse.db, zName);
            return;
        }

        sqlite3VdbeAddOp4(v, (int)(0), (int)(op), (int)(0), (int)(0), zName, (int)(-7));
    }
}</function>
  <function>public static void sqlite3SchemaClear(void* p)
{
    Hash temp1 = new Hash();
    Hash temp2 = new Hash();
    HashElem* pElem;
    Schema pSchema = (Schema)(p);
    temp1 = (Hash)(pSchema.tblHash);
    temp2 = (Hash)(pSchema.trigHash);
    sqlite3HashInit(&amp;pSchema.trigHash);
    sqlite3HashClear(&amp;pSchema.idxHash);
    for (pElem = ((&amp;temp2)-&gt;first); pElem; pElem = ((pElem)-&gt;next))
    {
        sqlite3DeleteTrigger(null, (Trigger)((pElem)-&gt;data));
    }

    sqlite3HashClear(&amp;temp2);
    sqlite3HashInit(&amp;pSchema.tblHash);
    for (pElem = ((&amp;temp1)-&gt;first); pElem; pElem = ((pElem)-&gt;next))
    {
        Table pTab = ((pElem)-&gt;data);
        sqlite3DeleteTable(null, pTab);
    }

    sqlite3HashClear(&amp;temp1);
    sqlite3HashClear(&amp;pSchema.fkeyHash);
    pSchema.pSeqTab = null;
    if ((pSchema.schemaFlags &amp; 0x0001) != 0)
    {
        pSchema.iGeneration++;
    }

    pSchema.schemaFlags &amp;= (ushort)(~(0x0001 | 0x0008));
}</function>
  <function>public static Schema sqlite3SchemaGet(sqlite3 db, Btree pBt)
{
    Schema p;
    if ((pBt) != null)
    {
        p = (Schema)(sqlite3BtreeSchema(pBt, (int)(sizeof(Schema)), sqlite3SchemaClear));
    }
    else
    {
        p = (Schema)(sqlite3DbMallocZero(null, (ulong)(sizeof(Schema))));
    }

    if (p == null)
    {
        sqlite3OomFault(db);
    }
    else if ((0) == (p.file_format))
    {
        sqlite3HashInit(&amp;p.tblHash);
        sqlite3HashInit(&amp;p.idxHash);
        sqlite3HashInit(&amp;p.trigHash);
        sqlite3HashInit(&amp;p.fkeyHash);
        p.enc = (byte)(1);
    }

    return p;
}</function>
  <function>public static int sqlite3SchemaToIndex(sqlite3 db, Schema pSchema)
{
    int i = (int)(-32768);
    if ((pSchema) != null)
    {
        for (i = (int)(0); 1; i++)
        {
            if ((db.aDb[i].pSchema) == (pSchema))
            {
                break;
            }
        }
    }

    return (int)(i);
}</function>
  <function>public static int sqlite3SectorSize(sqlite3_file pFile)
{
    int iRet = (int)(sqlite3OsSectorSize(pFile));
    if ((iRet) &lt; (32))
    {
        iRet = (int)(512);
    }
    else if ((iRet) &gt; (0x10000))
    {
        iRet = (int)(0x10000);
    }

    return (int)(iRet);
}</function>
  <function>public static int sqlite3Select(Parse pParse, Select p, SelectDest pDest)
{
    int i = 0; int  j  =  0 ; 
    WhereInfo pWInfo;
    Vdbe v;
    int isAgg = 0;
    ExprList pEList = null;
    SrcList pTabList;
    Expr pWhere;
    ExprList pGroupBy;
    Expr pHaving;
    AggInfo pAggInfo = null;
    int rc = (int)(1);
    DistinctCtx sDistinct = new DistinctCtx();
    SortCtx sSort = new SortCtx();
    int iEnd = 0;
    sqlite3 db;
    ExprList pMinMaxOrderBy = null;
    byte minMaxFlag = 0;
    db = pParse.db;
    v = sqlite3GetVdbe(pParse);
    if (((p) == (null)) || ((pParse.nErr) != 0))
    {
        return (int)(1);
    }

    if ((sqlite3AuthCheck(pParse, (int)(21), null, null, null)) != 0)
        return (int)(1);
    if (((pDest.eDest) &lt;= (6)))
    {
        if ((p.pOrderBy) != null)
        {
            sqlite3ParserAddCleanup(pParse, sqlite3ExprListDelete, p.pOrderBy);
            p.pOrderBy = null;
        }

        p.selFlags &amp;= (uint)(~0x0000001);
        p.selFlags |= (uint)(0x0400000);
    }

    sqlite3SelectPrep(pParse, p, null);
    if ((pParse.nErr) != 0)
    {
        goto select_end;
    }

    if ((p.selFlags &amp; 0x0800000) != 0)
    {
        SrcItem p0 = p.pSrc.a[0];
        for (i = (int)(1); (i) &lt; (p.pSrc.nSrc); i++)
        {
            SrcItem p1 = p.pSrc.a[i];
            if (((p0.pTab) == (p1.pTab)) &amp;&amp; ((0) == (sqlite3_stricmp(p0.zAlias, p1.zAlias))))
            {
                sqlite3ErrorMsg(pParse, "target object/alias may not appear in FROM clause: %s", (p0.zAlias) != 0 ? p0.zAlias : p0.pTab.zName);
                goto select_end;
            }
        }

        p.selFlags &amp;= (uint)(~0x0800000);
    }

    if ((pDest.eDest) == (9))
    {
        sqlite3GenerateColumnNames(pParse, p);
    }

    if ((sqlite3WindowRewrite(pParse, p)) != 0)
    {
        goto select_end;
    }

    pTabList = p.pSrc;
    isAgg = (int)((p.selFlags &amp; 0x0000008) != 0);
    CRuntime.memset(sSort, (int)(0), (ulong)(sizeof(SortCtx)));
    sSort.pOrderBy = p.pOrderBy;
    for (i = (int)(0); (p.pPrior == null) &amp;&amp; ((i) &lt; (pTabList.nSrc)); i++)
    {
        SrcItem pItem = pTabList.a[i];
        Select pSub = pItem.pSelect;
        Table pTab = pItem.pTab;
        if ((((pItem.fg.jointype &amp; 0x0008) != 0) &amp;&amp; ((sqlite3ExprImpliesNonNullRow(p.pWhere, (int)(pItem.iCursor))) != 0)) &amp;&amp; (((db).dbOptFlags &amp; (0x00002000)) == (0)))
        {
            pItem.fg.jointype &amp;= (byte)(~(0x0008 | 0x0020));
            unsetJoinExpr(p.pWhere, (int)(pItem.iCursor));
        }

        if ((pSub) == (null))
            continue;
        if (pTab.nCol != pSub.pEList.nExpr)
        {
            sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d", (int)(pTab.nCol), pTab.zName, (int)(pSub.pEList.nExpr));
            goto select_end;
        }

        if ((pSub.selFlags &amp; 0x0000008) != 0)
            continue;
        if ((((((pSub.pOrderBy != null) &amp;&amp; ((p.pOrderBy != null) || ((pTabList.nSrc) &gt; (1)))) &amp;&amp; ((pSub.pLimit) == (null))) &amp;&amp; ((pSub.selFlags &amp; 0x8000000) == (0))) &amp;&amp; ((p.selFlags &amp; 0x8000000) == (0))) &amp;&amp; (((db).dbOptFlags &amp; (0x00040000)) == (0)))
        {
            sqlite3ExprListDelete(db, pSub.pOrderBy);
            pSub.pOrderBy = null;
        }

        if ((((pSub.pOrderBy != null) &amp;&amp; ((i) == (0))) &amp;&amp; ((p.selFlags &amp; 0x0040000) != 0)) &amp;&amp; (((pTabList.nSrc) == (1)) || ((pTabList.a[1].fg.jointype &amp; (0x0008 | 0x0002)) != 0)))
        {
            continue;
        }

        if ((flattenSubquery(pParse, p, (int)(i), (int)(isAgg))) != 0)
        {
            if ((pParse.nErr) != 0)
                goto select_end;
            i = (int)(-1);
        }

        pTabList = p.pSrc;
        if ((db.mallocFailed) != 0)
            goto select_end;
        if (!((pDest.eDest) &lt;= (8)))
        {
            sSort.pOrderBy = p.pOrderBy;
        }
    }

    if ((p.pPrior) != null)
    {
        rc = (int)(multiSelect(pParse, p, pDest));
        if ((p.pNext) == (null))
            sqlite3VdbeExplainPop(pParse);
        return (int)(rc);
    }

    if ((((p.pWhere != null) &amp;&amp; ((p.pWhere.op) == (44))) &amp;&amp; (((db).dbOptFlags &amp; (0x00008000)) == (0))) &amp;&amp; ((propagateConstants(pParse, p)) != 0))
    {
    }
    else
    {
    }

    for (i = (int)(0); (i) &lt; (pTabList.nSrc); i++)
    {
        SrcItem pItem = pTabList.a[i];
        SrcItem pPrior;
        SelectDest dest = new SelectDest();
        Select pSub;
        sbyte* zSavedAuthContext;
        if (((pItem.colUsed) == (0)) &amp;&amp; (pItem.zName != null))
        {
            sqlite3AuthCheck(pParse, (int)(20), pItem.zName, "", pItem.zDatabase);
        }

        pSub = pItem.pSelect;
        if ((pSub) == (null))
            continue;
        pParse.nHeight += (int)(sqlite3SelectExprHeight(p));
        if (((((db).dbOptFlags &amp; (0x00001000)) == (0)) &amp;&amp; (((pItem.fg.isCte) == (0)) || ((pItem.u2.pCteUse-&gt;eM10d != 0) &amp;&amp; ((pItem.u2.pCteUse-&gt;nUse) &lt; (2))))) &amp;&amp; ((pushDownWhereTerms(pParse, pSub, p.pWhere, (int)(pItem.iCursor), (int)((pItem.fg.jointype &amp; 0x0020) != 0))) != 0))
        {
        }
        else
        {
        }

        zSavedAuthContext = pParse.zAuthContext;
        pParse.zAuthContext = pItem.zName;
        if ((((i) == (0)) &amp;&amp; (((pTabList.nSrc) == (1)) || ((pTabList.a[1].fg.jointype &amp; (0x0008 | 0x0002)) != 0))) &amp;&amp; (((pItem.fg.isCte) == (0)) || (pItem.u2.pCteUse-&gt;eM10d != 0)))
        {
            int addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
            pItem.regReturn = (int)(++pParse.nMem);
            sqlite3VdbeAddOp3(v, (int)(13), (int)(pItem.regReturn), (int)(0), (int)(addrTop));
            pItem.addrFillSub = (int)(addrTop);
            sqlite3SelectDestInit(dest, (int)(13), (int)(pItem.regReturn));
            sqlite3VdbeExplain(pParse, (byte)(1), "CO-ROUTINE %!S", pItem);
            sqlite3Select(pParse, pSub, dest);
            pItem.pTab.nRowLogEst = (short)(pSub.nSelectRow);
            pItem.fg.viaCoroutine = (uint)(1);
            pItem.regResult = (int)(dest.iSdst);
            sqlite3VdbeEndCoroutine(v, (int)(pItem.regReturn));
            sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
            sqlite3ClearTempRegCache(pParse);
        }
        else if (((pItem.fg.isCte) != 0) &amp;&amp; ((pItem.u2.pCteUse-&gt;addrM9e) &gt; (0)))
        {
            CteUse* pCteUse = pItem.u2.pCteUse;
            sqlite3VdbeAddOp2(v, (int)(12), (int)(pCteUse-&gt;regRtn), (int)(pCteUse-&gt;addrM9e));
            if (pItem.iCursor != pCteUse-&gt;iCur)
            {
                sqlite3VdbeAddOp2(v, (int)(113), (int)(pItem.iCursor), (int)(pCteUse-&gt;iCur));
            }

            pSub.nSelectRow = (short)(pCteUse-&gt;nRowEst);
        }
        else if ((pPrior = isSelfJoinView(pTabList, pItem)) != null)
        {
            if ((pPrior.addrFillSub) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(12), (int)(pPrior.regReturn), (int)(pPrior.addrFillSub));
            }

            sqlite3VdbeAddOp2(v, (int)(113), (int)(pItem.iCursor), (int)(pPrior.iCursor));
            pSub.nSelectRow = (short)(pPrior.pSelect.nSelectRow);
        }
        else
        {
            int topAddr = 0;
            int onceAddr = (int)(0);
            int retAddr = 0;
            pItem.regReturn = (int)(++pParse.nMem);
            topAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pItem.regReturn)));
            pItem.addrFillSub = (int)(topAddr + 1);
            if ((pItem.fg.isCorrelated) == (0))
            {
                onceAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
            }
            else
            {
            }

            sqlite3SelectDestInit(dest, (int)(12), (int)(pItem.iCursor));
            sqlite3VdbeExplain(pParse, (byte)(1), "MATERIALIZE %!S", pItem);
            sqlite3Select(pParse, pSub, dest);
            pItem.pTab.nRowLogEst = (short)(pSub.nSelectRow);
            if ((onceAddr) != 0)
                sqlite3VdbeJumpHere(v, (int)(onceAddr));
            retAddr = (int)(sqlite3VdbeAddOp1(v, (int)(67), (int)(pItem.regReturn)));
            sqlite3VdbeChangeP1(v, (int)(topAddr), (int)(retAddr));
            sqlite3ClearTempRegCache(pParse);
            if (((pItem.fg.isCte) != 0) &amp;&amp; ((pItem.fg.isCorrelated) == (0)))
            {
                CteUse* pCteUse = pItem.u2.pCteUse;
                pCteUse-&gt;addrM9e = (int)(pItem.addrFillSub);
                pCteUse-&gt;regRtn = (int)(pItem.regReturn);
                pCteUse-&gt;iCur = (int)(pItem.iCursor);
                pCteUse-&gt;nRowEst = (short)(pSub.nSelectRow);
            }
        }

        if ((db.mallocFailed) != 0)
            goto select_end;
        pParse.nHeight -= (int)(sqlite3SelectExprHeight(p));
        pParse.zAuthContext = zSavedAuthContext;
    }

    pEList = p.pEList;
    pWhere = p.pWhere;
    pGroupBy = p.pGroupBy;
    pHaving = p.pHaving;
    sDistinct.isTnct = (byte)((p.selFlags &amp; 0x0000001) != 0);
    if ((((p.selFlags &amp; (0x0000001 | 0x0000008)) == (0x0000001)) &amp;&amp; ((sqlite3ExprListCompare(sSort.pOrderBy, pEList, (int)(-1))) == (0))) &amp;&amp; ((p.pWin) == (null)))
    {
        p.selFlags &amp;= (uint)(~0x0000001);
        pGroupBy = p.pGroupBy = sqlite3ExprListDup(db, pEList, (int)(0));
        p.selFlags |= (uint)(0x0000008);
    }

    if ((sSort.pOrderBy) != null)
    {
        KeyInfo pKeyInfo;
        pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, (int)(0), (int)(pEList.nExpr));
        sSort.iECursor = (int)(pParse.nTab++);
        sSort.addrSortIndex = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(sSort.iECursor), (int)(sSort.pOrderBy.nExpr + 1 + pEList.nExpr), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
    }
    else
    {
        sSort.addrSortIndex = (int)(-1);
    }

    if ((pDest.eDest) == (12))
    {
        sqlite3VdbeAddOp2(v, (int)(116), (int)(pDest.iSDParm), (int)(pEList.nExpr));
    }

    iEnd = (int)(sqlite3VdbeMakeLabel(pParse));
    if ((p.selFlags &amp; 0x0004000) == (0))
    {
        p.nSelectRow = (short)(320);
    }

    computeLimitRegisters(pParse, p, (int)(iEnd));
    if (((p.iLimit) == (0)) &amp;&amp; ((sSort.addrSortIndex) &gt;= (0)))
    {
        sqlite3VdbeChangeOpcode(v, (int)(sSort.addrSortIndex), (byte)(118));
        sSort.sortFlags |= (byte)(0x01);
    }

    if ((p.selFlags &amp; 0x0000001) != 0)
    {
        sDistinct.tabTnct = (int)(pParse.nTab++);
        sDistinct.addrTnct = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(sDistinct.tabTnct), (int)(0), (int)(0), (sbyte*)(sqlite3KeyInfoFromExprList(pParse, p.pEList, (int)(0), (int)(0))), (int)(-9)));
        sqlite3VdbeChangeP5(v, (ushort)(8));
        sDistinct.eTnctType = (byte)(3);
    }
    else
    {
        sDistinct.eTnctType = (byte)(0);
    }

    if ((isAgg == 0) &amp;&amp; ((pGroupBy) == (null)))
    {
        ushort wctrlFlags = (ushort)(((sDistinct.isTnct) != 0 ? 0x0100 : 0) | (p.selFlags &amp; 0x0004000));
        Window pWin = p.pWin;
        if ((pWin) != null)
        {
            sqlite3WindowCodeInit(pParse, p);
        }

        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p.pEList, p, (ushort)(wctrlFlags), (int)(p.nSelectRow));
        if ((pWInfo) == (null))
            goto select_end;
        if ((sqlite3WhereOutputRowCount(pWInfo)) &lt; (p.nSelectRow))
        {
            p.nSelectRow = (short)(sqlite3WhereOutputRowCount(pWInfo));
        }

        if (((sDistinct.isTnct) != 0) &amp;&amp; ((sqlite3WhereIsDistinct(pWInfo)) != 0))
        {
            sDistinct.eTnctType = (byte)(sqlite3WhereIsDistinct(pWInfo));
        }

        if ((sSort.pOrderBy) != null)
        {
            sSort.nOBSat = (int)(sqlite3WhereIsOrdered(pWInfo));
            sSort.labelOBLopt = (int)(sqlite3WhereOrderByLimitOptLabel(pWInfo));
            if ((sSort.nOBSat) == (sSort.pOrderBy.nExpr))
            {
                sSort.pOrderBy = null;
            }
        }

        if (((sSort.addrSortIndex) &gt;= (0)) &amp;&amp; ((sSort.pOrderBy) == (null)))
        {
            sqlite3VdbeChangeToNoop(v, (int)(sSort.addrSortIndex));
        }

        if ((pWin) != null)
        {
            int addrGosub = (int)(sqlite3VdbeMakeLabel(pParse));
            int iCont = (int)(sqlite3VdbeMakeLabel(pParse));
            int iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
            int regGosub = (int)(++pParse.nMem);
            sqlite3WindowCodeStep(pParse, p, pWInfo, (int)(regGosub), (int)(addrGosub));
            sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(iBreak));
            sqlite3VdbeResolveLabel(v, (int)(addrGosub));
            sSort.labelOBLopt = (int)(0);
            selectInnerLoop(pParse, p, (int)(-1), sSort, &amp;sDistinct, pDest, (int)(iCont), (int)(iBreak));
            sqlite3VdbeResolveLabel(v, (int)(iCont));
            sqlite3VdbeAddOp1(v, (int)(67), (int)(regGosub));
            sqlite3VdbeResolveLabel(v, (int)(iBreak));
        }
        else
        {
            selectInnerLoop(pParse, p, (int)(-1), sSort, &amp;sDistinct, pDest, (int)(sqlite3WhereContinueLabel(pWInfo)), (int)(sqlite3WhereBreakLabel(pWInfo)));
            sqlite3WhereEnd(pWInfo);
        }
    }
    else
    {
        NameContext sNC = new NameContext();
        int iAMem = 0;
        int iBMem = 0;
        int iUseFlag = 0;
        int iAbortFlag = 0;
        int groupBySort = 0;
        int addrEnd = 0;
        int sortPTab = (int)(0);
        int sortOut = (int)(0);
        int orderByGrp = (int)(0);
        if ((pGroupBy) != null)
        {
            int k = 0;
            ExprList_item* pItem;
            for (k = (int)(p.pEList.nExpr), pItem = p.pEList.a; (k) &gt; (0); k--, pItem++)
            {
                pItem-&gt;u.x.iAlias = (ushort)(0);
            }

            for (k = (int)(pGroupBy.nExpr), pItem = pGroupBy.a; (k) &gt; (0); k--, pItem++)
            {
                pItem-&gt;u.x.iAlias = (ushort)(0);
            }

            if ((p.nSelectRow) &gt; (66))
                p.nSelectRow = (short)(66);
            if (((sSort.pOrderBy) != null) &amp;&amp; ((pGroupBy.nExpr) == (sSort.pOrderBy.nExpr)))
            {
                int ii = 0;
                for (ii = (int)(0); (ii) &lt; (pGroupBy.nExpr); ii++)
                {
                    byte sortFlags = (byte)(sSort.pOrderBy.a[ii].sortFlags &amp; 0x01);
                    pGroupBy.a[ii].sortFlags = (byte)(sortFlags);
                }

                if ((sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, (int)(-1))) == (0))
                {
                    orderByGrp = (int)(1);
                }
            }
        }
        else
        {
            p.nSelectRow = (short)(0);
        }

        addrEnd = (int)(sqlite3VdbeMakeLabel(pParse));
        pAggInfo = sqlite3DbMallocZero(db, (ulong)(sizeof(AggInfo)));
        if ((pAggInfo) != null)
        {
            sqlite3ParserAddCleanup(pParse, agginfoFree, pAggInfo);
        }

        if ((db.mallocFailed) != 0)
        {
            goto select_end;
        }

        pAggInfo.selId = (uint)(p.selId);
        CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
        sNC.pParse = pParse;
        sNC.pSrcList = pTabList;
        sNC.uNC.pAggInfo = pAggInfo;
        pAggInfo.mnReg = (int)(pParse.nMem + 1);
        pAggInfo.nSortingColumn = (int)(pGroupBy ? pGroupBy.nExpr : 0);
        pAggInfo.pGroupBy = pGroupBy;
        sqlite3ExprAnalyzeAggList(sNC, pEList);
        sqlite3ExprAnalyzeAggList(sNC, sSort.pOrderBy);
        if ((pHaving) != null)
        {
            if ((pGroupBy) != null)
            {
                havingToWhere(pParse, p);
                pWhere = p.pWhere;
            }

            sqlite3ExprAnalyzeAggregates(sNC, pHaving);
        }

        pAggInfo.nAccumulator = (int)(pAggInfo.nColumn);
        if ((((p.pGroupBy) == (null)) &amp;&amp; ((p.pHaving) == (null))) &amp;&amp; ((pAggInfo.nFunc) == (1)))
        {
            minMaxFlag = (byte)(minMaxQuery(db, pAggInfo.aFunc[0].pFExpr, pMinMaxOrderBy));
        }
        else
        {
            minMaxFlag = (byte)(0x0000);
        }

        for (i = (int)(0); (i) &lt; (pAggInfo.nFunc); i++)
        {
            Expr pExpr = pAggInfo.aFunc[i].pFExpr;
            sNC.ncFlags |= (int)(0x020000);
            sqlite3ExprAnalyzeAggList(sNC, pExpr.x.pList);
            if ((((pExpr).flags &amp; (0x1000000)) != 0))
            {
                sqlite3ExprAnalyzeAggregates(sNC, pExpr.y.pWin.pFilter);
            }

            sNC.ncFlags &amp;= (int)(~0x020000);
        }

        pAggInfo.mxReg = (int)(pParse.nMem);
        if ((db.mallocFailed) != 0)
            goto select_end;
        if ((pGroupBy) != null)
        {
            KeyInfo pKeyInfo;
            int addr1 = 0;
            int addrOutputRow = 0;
            int regOutputRow = 0;
            int addrSetAbort = 0;
            int addrTopOfLoop = 0;
            int addrSortingIdx = 0;
            int addrReset = 0;
            int regReset = 0;
            ExprList pDistinct = null;
            ushort distFlag = (ushort)(0);
            int eDist = (int)(0);
            if ((((((pAggInfo.nFunc) == (1)) &amp;&amp; ((pAggInfo.aFunc[0].iDistinct) &gt;= (0))) &amp;&amp; (pAggInfo.aFunc[0].pFExpr != null)) &amp;&amp; ((((pAggInfo.aFunc[0].pFExpr).flags &amp; 0x000800) == (0)) != 0)) &amp;&amp; (pAggInfo.aFunc[0].pFExpr.x.pList != null))
            {
                Expr pExpr = pAggInfo.aFunc[0].pFExpr.x.pList.a[0].pExpr;
                pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
                pDistinct = sqlite3ExprListDup(db, pGroupBy, (int)(0));
                pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);
                distFlag = (ushort)(pDistinct ? (0x0100 | 0x0400) : 0);
            }

            pAggInfo.sortingIdx = (int)(pParse.nTab++);
            pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, (int)(0), (int)(pAggInfo.nColumn));
            addrSortingIdx = (int)(sqlite3VdbeAddOp4(v, (int)(118), (int)(pAggInfo.sortingIdx), (int)(pAggInfo.nSortingColumn), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
            iUseFlag = (int)(++pParse.nMem);
            iAbortFlag = (int)(++pParse.nMem);
            regOutputRow = (int)(++pParse.nMem);
            addrOutputRow = (int)(sqlite3VdbeMakeLabel(pParse));
            regReset = (int)(++pParse.nMem);
            addrReset = (int)(sqlite3VdbeMakeLabel(pParse));
            iAMem = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(pGroupBy.nExpr);
            iBMem = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(pGroupBy.nExpr);
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(iAbortFlag));
            sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(iAMem), (int)(iAMem + pGroupBy.nExpr - 1));
            sqlite3VdbeAddOp2(v, (int)(12), (int)(regReset), (int)(addrReset));
            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, null, (ushort)(0x0040 | ((orderByGrp) != 0 ? 0x0200 : 0) | distFlag), (int)(0));
            if ((pWInfo) == (null))
            {
                sqlite3ExprListDelete(db, pDistinct);
                goto select_end;
            }

            eDist = (int)(sqlite3WhereIsDistinct(pWInfo));
            if ((sqlite3WhereIsOrdered(pWInfo)) == (pGroupBy.nExpr))
            {
                groupBySort = (int)(0);
            }
            else
            {
                int regBase = 0;
                int regRecord = 0;
                int nCol = 0;
                int nGroupBy = 0;
                explainTempTable(pParse, (((sDistinct.isTnct) != 0) &amp;&amp; ((p.selFlags &amp; 0x0000001) == (0))) ? "DISTINCT" : "GROUP BY");
                groupBySort = (int)(1);
                nGroupBy = (int)(pGroupBy.nExpr);
                nCol = (int)(nGroupBy);
                j = (int)(nGroupBy);
                for (i = (int)(0); (i) &lt; (pAggInfo.nColumn); i++)
                {
                    if ((pAggInfo.aCol[i].iSorterColumn) &gt;= (j))
                    {
                        nCol++;
                        j++;
                    }
                }

                regBase = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
                sqlite3ExprCodeExprList(pParse, pGroupBy, (int)(regBase), (int)(0), (byte)(0));
                j = (int)(nGroupBy);
                for (i = (int)(0); (i) &lt; (pAggInfo.nColumn); i++)
                {
                    AggInfo_col pCol = pAggInfo.aCol[i];
                    if ((pCol.iSorterColumn) &gt;= (j))
                    {
                        int r1 = (int)(j + regBase);
                        sqlite3ExprCodeGetColumnOfTable(v, pCol.pTab, (int)(pCol.iTable), (int)(pCol.iColumn), (int)(r1));
                        j++;
                    }
                }

                regRecord = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase), (int)(nCol), (int)(regRecord));
                sqlite3VdbeAddOp2(v, (int)(138), (int)(pAggInfo.sortingIdx), (int)(regRecord));
                sqlite3ReleaseTempReg(pParse, (int)(regRecord));
                sqlite3ReleaseTempRange(pParse, (int)(regBase), (int)(nCol));
                sqlite3WhereEnd(pWInfo);
                pAggInfo.sortingIdxPTab = (int)(sortPTab = (int)(pParse.nTab++));
                sortOut = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp3(v, (int)(120), (int)(sortPTab), (int)(sortOut), (int)(nCol));
                sqlite3VdbeAddOp2(v, (int)(36), (int)(pAggInfo.sortingIdx), (int)(addrEnd));
                pAggInfo.useSortingIdx = (byte)(1);
            }

            if ((((orderByGrp) != 0) &amp;&amp; (((db).dbOptFlags &amp; (0x00000004)) == (0))) &amp;&amp; (((groupBySort) != 0) || ((sqlite3WhereIsSorted(pWInfo)) != 0)))
            {
                sSort.pOrderBy = null;
                sqlite3VdbeChangeToNoop(v, (int)(sSort.addrSortIndex));
            }

            addrTopOfLoop = (int)(sqlite3VdbeCurrentAddr(v));
            if ((groupBySort) != 0)
            {
                sqlite3VdbeAddOp3(v, (int)(132), (int)(pAggInfo.sortingIdx), (int)(sortOut), (int)(sortPTab));
            }

            for (j = (int)(0); (j) &lt; (pGroupBy.nExpr); j++)
            {
                if ((groupBySort) != 0)
                {
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(sortPTab), (int)(j), (int)(iBMem + j));
                }
                else
                {
                    pAggInfo.directMode = (byte)(1);
                    sqlite3ExprCode(pParse, pGroupBy.a[j].pExpr, (int)(iBMem + j));
                }
            }

            sqlite3VdbeAddOp4(v, (int)(89), (int)(iAMem), (int)(iBMem), (int)(pGroupBy.nExpr), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9));
            addr1 = (int)(sqlite3VdbeCurrentAddr(v));
            sqlite3VdbeAddOp3(v, (int)(16), (int)(addr1 + 1), (int)(0), (int)(addr1 + 1));
            sqlite3ExprCodeMove(pParse, (int)(iBMem), (int)(iAMem), (int)(pGroupBy.nExpr));
            sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutputRow), (int)(addrOutputRow));
            sqlite3VdbeAddOp2(v, (int)(49), (int)(iAbortFlag), (int)(addrEnd));
            sqlite3VdbeAddOp2(v, (int)(12), (int)(regReset), (int)(addrReset));
            sqlite3VdbeJumpHere(v, (int)(addr1));
            updateAccumulator(pParse, (int)(iUseFlag), pAggInfo, (int)(eDist));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iUseFlag));
            if ((groupBySort) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(3), (int)(pAggInfo.sortingIdx), (int)(addrTopOfLoop));
            }
            else
            {
                sqlite3WhereEnd(pWInfo);
                sqlite3VdbeChangeToNoop(v, (int)(addrSortingIdx));
            }

            sqlite3ExprListDelete(db, pDistinct);
            sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutputRow), (int)(addrOutputRow));
            sqlite3VdbeGoto(v, (int)(addrEnd));
            addrSetAbort = (int)(sqlite3VdbeCurrentAddr(v));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iAbortFlag));
            sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
            sqlite3VdbeResolveLabel(v, (int)(addrOutputRow));
            addrOutputRow = (int)(sqlite3VdbeCurrentAddr(v));
            sqlite3VdbeAddOp2(v, (int)(49), (int)(iUseFlag), (int)(addrOutputRow + 2));
            sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
            finalizeAggFunctions(pParse, pAggInfo);
            sqlite3ExprIfFalse(pParse, pHaving, (int)(addrOutputRow + 1), (int)(0x10));
            selectInnerLoop(pParse, p, (int)(-1), sSort, &amp;sDistinct, pDest, (int)(addrOutputRow + 1), (int)(addrSetAbort));
            sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
            sqlite3VdbeResolveLabel(v, (int)(addrReset));
            resetAccumulator(pParse, pAggInfo);
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(iUseFlag));
            sqlite3VdbeAddOp1(v, (int)(67), (int)(regReset));
            if (eDist != 0)
            {
                AggInfo_func pF = pAggInfo.aFunc[0];
                fixDistinctOpenEph(pParse, (int)(eDist), (int)(pF.iDistinct), (int)(pF.iDistAddr));
            }
        }
        else
        {
            Table pTab;
            if ((pTab = isSimpleCount(p, pAggInfo)) != null)
            {
                int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
                int iCsr = (int)(pParse.nTab++);
                Index pIdx;
                KeyInfo pKeyInfo = null;
                Index pBest = null;
                uint iRoot = (uint)(pTab.tnum);
                sqlite3CodeVerifySchema(pParse, (int)(iDb));
                sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
                if (!(((pTab).tabFlags &amp; 0x00000080) == (0)))
                    pBest = sqlite3PrimaryKeyIndex(pTab);
                if (p.pSrc.a[0].fg.notIndexed == 0)
                {
                    for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
                    {
                        if (((((pIdx.bUnordered) == (0)) &amp;&amp; ((pIdx.szIdxRow) &lt; (pTab.szTabRow))) &amp;&amp; ((pIdx.pPartIdxWhere) == (null))) &amp;&amp; ((pBest == null) || ((pIdx.szIdxRow) &lt; (pBest.szIdxRow))))
                        {
                            pBest = pIdx;
                        }
                    }
                }

                if ((pBest) != null)
                {
                    iRoot = (uint)(pBest.tnum);
                    pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
                }

                sqlite3VdbeAddOp4Int(v, (int)(101), (int)(iCsr), (int)(iRoot), (int)(iDb), (int)(1));
                if ((pKeyInfo) != null)
                {
                    sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pKeyInfo), (int)(-9));
                }

                sqlite3VdbeAddOp2(v, (int)(97), (int)(iCsr), (int)(pAggInfo.aFunc[0].iMem));
                sqlite3VdbeAddOp1(v, (int)(121), (int)(iCsr));
                explainSimpleCount(pParse, pTab, pBest);
            }
            else
            {
                int regAcc = (int)(0);
                ExprList pDistinct = null;
                ushort distFlag = (ushort)(0);
                int eDist = 0;
                if ((pAggInfo.nAccumulator) != 0)
                {
                    for (i = (int)(0); (i) &lt; (pAggInfo.nFunc); i++)
                    {
                        if ((((pAggInfo.aFunc[i].pFExpr).flags &amp; (0x1000000)) != 0))
                        {
                            continue;
                        }

                        if ((pAggInfo.aFunc[i].pFunc.funcFlags &amp; 0x0020) != 0)
                        {
                            break;
                        }
                    }

                    if ((i) == (pAggInfo.nFunc))
                    {
                        regAcc = (int)(++pParse.nMem);
                        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regAcc));
                    }
                }
                else if (((pAggInfo.nFunc) == (1)) &amp;&amp; ((pAggInfo.aFunc[0].iDistinct) &gt;= (0)))
                {
                    pDistinct = pAggInfo.aFunc[0].pFExpr.x.pList;
                    distFlag = (ushort)(pDistinct ? (0x0100 | 0x0400) : 0);
                }

                resetAccumulator(pParse, pAggInfo);
                pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, null, (ushort)(minMaxFlag | distFlag), (int)(0));
                if ((pWInfo) == (null))
                {
                    goto select_end;
                }

                eDist = (int)(sqlite3WhereIsDistinct(pWInfo));
                updateAccumulator(pParse, (int)(regAcc), pAggInfo, (int)(eDist));
                if (eDist != 0)
                {
                    AggInfo_func pF = pAggInfo.aFunc[0];
                    fixDistinctOpenEph(pParse, (int)(eDist), (int)(pF.iDistinct), (int)(pF.iDistAddr));
                }

                if ((regAcc) != 0)
                    sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regAcc));
                if ((minMaxFlag) != 0)
                {
                    sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);
                }

                sqlite3WhereEnd(pWInfo);
                finalizeAggFunctions(pParse, pAggInfo);
            }

            sSort.pOrderBy = null;
            sqlite3ExprIfFalse(pParse, pHaving, (int)(addrEnd), (int)(0x10));
            selectInnerLoop(pParse, p, (int)(-1), null, null, pDest, (int)(addrEnd), (int)(addrEnd));
        }

        sqlite3VdbeResolveLabel(v, (int)(addrEnd));
    }

    if ((sDistinct.eTnctType) == (3))
    {
        explainTempTable(pParse, "DISTINCT");
    }

    if ((sSort.pOrderBy) != null)
    {
        explainTempTable(pParse, (sSort.nOBSat) &gt; (0) ? "RIGHT PART OF ORDER BY" : "ORDER BY");
        generateSortTail(pParse, p, sSort, (int)(pEList.nExpr), pDest);
    }

    sqlite3VdbeResolveLabel(v, (int)(iEnd));
    rc = (int)((pParse.nErr) &gt; (0) ? 1 : 0);
    select_end:
        ;
    sqlite3ExprListDelete(db, pMinMaxOrderBy);
    sqlite3VdbeExplainPop(pParse);
    return (int)(rc);
}</function>
  <function>public static void sqlite3SelectAddColumnTypeAndCollation(Parse pParse, Table pTab, Select pSelect, sbyte aff)
{
    sqlite3 db = pParse.db;
    NameContext sNC = new NameContext();
    Column* pCol;
    CollSeq pColl;
    int i = 0;
    Expr p;
    ExprList_item* a;
    if ((db.mallocFailed) != 0)
        return;
    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    sNC.pSrcList = pSelect.pSrc;
    a = pSelect.pEList.a;
    for (i = (int)(0), pCol = pTab.aCol; (i) &lt; (pTab.nCol); i++, pCol++)
    {
        sbyte* zType;
        long n = 0;
        long m = 0;
        pTab.tabFlags |= (uint)(pCol-&gt;colFlags &amp; 0x0062);
        p = a[i].pExpr;
        zType = columnTypeImpl(sNC, p);
        pCol-&gt;affinity = (sbyte)(sqlite3ExprAffinity(p));
        if ((zType) != null)
        {
            m = (long)(sqlite3Strlen30(zType));
            n = (long)(sqlite3Strlen30(pCol-&gt;zCnName));
            pCol-&gt;zCnName = sqlite3DbReallocOrFree(db, pCol-&gt;zCnName, (ulong)(n + m + 2));
            if ((pCol-&gt;zCnName) != null)
            {
                CRuntime.memcpy(&amp;pCol-&gt;zCnName[n + 1], zType, (ulong)(m + 1));
                pCol-&gt;colFlags |= (ushort)(0x0004);
            }
            else
            {
                pCol-&gt;colFlags &amp;= (ushort)(~(0x0004 | 0x0200));
            }
        }

        if ((pCol-&gt;affinity) &lt;= (0x40))
            pCol-&gt;affinity = (sbyte)(aff);
        pColl = sqlite3ExprCollSeq(pParse, p);
        if ((pColl) != null)
        {
            sqlite3ColumnSetColl(db, pCol, pColl.zName);
        }
    }

    pTab.szTabRow = (short)(1);
}</function>
  <function>public static void sqlite3SelectAddTypeInfo(Parse pParse, Select pSelect)
{
    Walker w = new Walker();
    w.xSelectCallback = sqlite3SelectWalkNoop;
    w.xSelectCallback2 = selectAddSubqueryTypeInfo;
    w.xExprCallback = sqlite3ExprWalkNoop;
    w.pParse = pParse;
    sqlite3WalkSelect(w, pSelect);
}</function>
  <function>public static void sqlite3SelectDelete(sqlite3 db, Select p)
{
    if ((p) != null)
        clearSelect(db, p, (int)(1));
}</function>
  <function>public static void sqlite3SelectDestInit(SelectDest pDest, int eDest, int iParm)
{
    pDest.eDest = ((byte)(eDest));
    pDest.iSDParm = (int)(iParm);
    pDest.iSDParm2 = (int)(0);
    pDest.zAffSdst = null;
    pDest.iSdst = (int)(0);
    pDest.nSdst = (int)(0);
}</function>
  <function>public static Select sqlite3SelectDup(sqlite3 db, Select pDup, int flags)
{
    Select pRet = null;
    Select pNext = null;
    Select pp = pRet;
    Select p;
    for (p = pDup; p; p = p.pPrior)
    {
        Select pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Select)));
        if ((pNew) == (null))
            break;
        pNew.pEList = sqlite3ExprListDup(db, p.pEList, (int)(flags));
        pNew.pSrc = sqlite3SrcListDup(db, p.pSrc, (int)(flags));
        pNew.pWhere = sqlite3ExprDup(db, p.pWhere, (int)(flags));
        pNew.pGroupBy = sqlite3ExprListDup(db, p.pGroupBy, (int)(flags));
        pNew.pHaving = sqlite3ExprDup(db, p.pHaving, (int)(flags));
        pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, (int)(flags));
        pNew.op = (byte)(p.op);
        pNew.pNext = pNext;
        pNew.pPrior = null;
        pNew.pLimit = sqlite3ExprDup(db, p.pLimit, (int)(flags));
        pNew.iLimit = (int)(0);
        pNew.iOffset = (int)(0);
        pNew.selFlags = (uint)(p.selFlags &amp; ~0x0000020);
        pNew.addrOpenEphm[0] = (int)(-1);
        pNew.addrOpenEphm[1] = (int)(-1);
        pNew.nSelectRow = (short)(p.nSelectRow);
        pNew.pWith = sqlite3WithDup(db, p.pWith);
        pNew.pWin = null;
        pNew.pWinDefn = sqlite3WindowListDup(db, p.pWinDefn);
        if (((p.pWin) != null) &amp;&amp; ((db.mallocFailed) == (0)))
            gatherSelectWindows(pNew);
        pNew.selId = (uint)(p.selId);
        if ((db.mallocFailed) != 0)
        {
            pNew.pNext = null;
            sqlite3SelectDelete(db, pNew);
            break;
        }

        pp = pNew;
        pp = pNew.pPrior;
        pNext = pNew;
    }

    return pRet;
}</function>
  <function>public static void sqlite3SelectExpand(Parse pParse, Select pSelect)
{
    Walker w = new Walker();
    w.xExprCallback = sqlite3ExprWalkNoop;
    w.pParse = pParse;
    if ((pParse.hasCompound) != 0)
    {
        w.xSelectCallback = convertCompoundSelectToSubquery;
        w.xSelectCallback2 = null;
        sqlite3WalkSelect(w, pSelect);
    }

    w.xSelectCallback = selectExpander;
    w.xSelectCallback2 = sqlite3SelectPopWith;
    w.eCode = (ushort)(0);
    sqlite3WalkSelect(w, pSelect);
}</function>
  <function>public static int sqlite3SelectExprHeight(Select p)
{
    int nHeight = (int)(0);
    heightOfSelect(p, &amp;nHeight);
    return (int)(nHeight);
}</function>
  <function>public static Select sqlite3SelectNew(Parse pParse, ExprList pEList, SrcList pSrc, Expr pWhere, ExprList pGroupBy, Expr pHaving, ExprList pOrderBy, uint selFlags, Expr pLimit)
{
    Select pNew; Select  pAllocated ; 
    Select standin = new Select();
    pAllocated = pNew = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Select)));
    if ((pNew) == (null))
    {
        pNew = standin;
    }

    if ((pEList) == (null))
    {
        pEList = sqlite3ExprListAppend(pParse, null, sqlite3Expr(pParse.db, (int)(180), null));
    }

    pNew.pEList = pEList;
    pNew.op = (byte)(138);
    pNew.selFlags = (uint)(selFlags);
    pNew.iLimit = (int)(0);
    pNew.iOffset = (int)(0);
    pNew.selId = (uint)(++pParse.nSelect);
    pNew.addrOpenEphm[0] = (int)(-1);
    pNew.addrOpenEphm[1] = (int)(-1);
    pNew.nSelectRow = (short)(0);
    if ((pSrc) == (null))
        pSrc = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(SrcList)));
    pNew.pSrc = pSrc;
    pNew.pWhere = pWhere;
    pNew.pGroupBy = pGroupBy;
    pNew.pHaving = pHaving;
    pNew.pOrderBy = pOrderBy;
    pNew.pPrior = null;
    pNew.pNext = null;
    pNew.pLimit = pLimit;
    pNew.pWith = null;
    pNew.pWin = null;
    pNew.pWinDefn = null;
    if ((pParse.db.mallocFailed) != 0)
    {
        clearSelect(pParse.db, pNew, (int)(pNew != standin));
        pAllocated = null;
    }
    else
    {
    }

    return pAllocated;
}</function>
  <function>public static sbyte* sqlite3SelectOpName(int id)
{
    sbyte* z;
    switch (id)
    {
        case 135:
            z = "UNION ALL";
            break;
        case 137:
            z = "INTERSECT";
            break;
        case 136:
            z = "EXCEPT";
            break;
        default:
            z = "UNION";
            break;
    }

    return z;
}</function>
  <function>public static void sqlite3SelectPopWith(Walker pWalker, Select p)
{
    Parse pParse = pWalker.pParse;
    if (((pParse.pWith) != null) &amp;&amp; ((p.pPrior) == (null)))
    {
        With pWith = findRightmost(p).pWith;
        if (pWith != null)
        {
            pParse.pWith = pWith.pOuter;
        }
    }
}</function>
  <function>public static void sqlite3SelectPrep(Parse pParse, Select p, NameContext pOuterNC)
{
    if ((pParse.db.mallocFailed) != 0)
        return;
    if ((p.selFlags &amp; 0x0000080) != 0)
        return;
    sqlite3SelectExpand(pParse, p);
    if ((pParse.nErr) != 0)
        return;
    sqlite3ResolveSelectNames(pParse, p, pOuterNC);
    if ((pParse.nErr) != 0)
        return;
    sqlite3SelectAddTypeInfo(pParse, p);
}</function>
  <function>public static int sqlite3SelectWalkFail(Walker pWalker, Select NotUsed)
{
    pWalker.eCode = (ushort)(0);
    return (int)(2);
}</function>
  <function>public static int sqlite3SelectWalkNoop(Walker NotUsed, Select NotUsed2)
{
    return (int)(0);
}</function>
  <function>public static void sqlite3SelectWrongNumTermsError(Parse pParse, Select p)
{
    if ((p.selFlags &amp; 0x0000200) != 0)
    {
        sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
    }
    else
    {
        sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s do not have the same number of result columns", sqlite3SelectOpName((int)(p.op)));
    }
}</function>
  <function>public static void sqlite3SetHasNullFlag(Vdbe v, int iCur, int regHasNull)
{
    int addr1 = 0;
    sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regHasNull));
    addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
    sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(0), (int)(regHasNull));
    sqlite3VdbeChangeP5(v, (ushort)(0x80));
    sqlite3VdbeJumpHere(v, (int)(addr1));
}</function>
  <function>public static void sqlite3SetJoinExpr(Expr p, int iTable)
{
    while ((p) != null)
    {
        (p).flags |= (uint)(0x000001);
        p.w.iRightJoinTable = (int)(iTable);
        if ((p.op) == (172))
        {
            if ((p.x.pList) != null)
            {
                int i = 0;
                for (i = (int)(0); (i) &lt; (p.x.pList.nExpr); i++)
                {
                    sqlite3SetJoinExpr(p.x.pList.a[i].pExpr, (int)(iTable));
                }
            }
        }

        sqlite3SetJoinExpr(p.pLeft, (int)(iTable));
        p = p.pRight;
    }
}</function>
  <function>public static void sqlite3SetString(sbyte** pz, sqlite3 db, sbyte* zNew)
{
    sqlite3DbFree(db, *pz);
    *pz = sqlite3DbStrDup(db, zNew);
}</function>
  <function>public static void sqlite3SetTextEncoding(sqlite3 db, byte enc)
{
    db.enc = (byte)(enc);
    db.pDfltColl = sqlite3FindCollSeq(db, (byte)(enc), sqlite3StrBINARY, (int)(0));
}</function>
  <function>public static int sqlite3ShadowTableName(sqlite3 db, sbyte* zName)
{
    sbyte* zTail;
    Table pTab;
    zTail = strrchr(zName, (int)(95));
    if ((zTail) == (null))
        return (int)(0);
    *zTail = (sbyte)(0);
    pTab = sqlite3FindTable(db, zName, null);
    *zTail = (sbyte)(95);
    if ((pTab) == (null))
        return (int)(0);
    if (!(((pTab).eTabType) == (1)))
        return (int)(0);
    return (int)(sqlite3IsShadowTableOf(db, pTab, zName));
}</function>
  <function>public static void sqlite3SkipAccumulatorLoad(sqlite3_context context)
{
    context.isError = (int)(-1);
    context.skipFlag = (byte)(1);
}</function>
  <function>public static SrcList sqlite3SrcListAppend(Parse pParse, SrcList pList, Token* pTable, Token* pDatabase)
{
    SrcItem pItem;
    sqlite3 db;
    db = pParse.db;
    if ((pList) == (null))
    {
        pList = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(SrcList)));
        if ((pList) == (null))
            return null;
        pList.nAlloc = (uint)(1);
        pList.nSrc = (int)(1);
        CRuntime.memset(pList.a[0], (int)(0), (ulong)(sizeof(SrcItem)));
        pList.a[0].iCursor = (int)(-1);
    }
    else
    {
        SrcList pNew = sqlite3SrcListEnlarge(pParse, pList, (int)(1), (int)(pList.nSrc));
        if ((pNew) == (null))
        {
            sqlite3SrcListDelete(db, pList);
            return null;
        }
        else
        {
            pList = pNew;
        }
    }

    pItem = pList.a[pList.nSrc - 1];
    if (((pDatabase) != null) &amp;&amp; ((pDatabase-&gt;z) == (null)))
    {
        pDatabase = null;
    }

    if ((pDatabase) != null)
    {
        pItem.zName = sqlite3NameFromToken(db, pDatabase);
        pItem.zDatabase = sqlite3NameFromToken(db, pTable);
    }
    else
    {
        pItem.zName = sqlite3NameFromToken(db, pTable);
        pItem.zDatabase = null;
    }

    return pList;
}</function>
  <function>public static SrcList sqlite3SrcListAppendFromTerm(Parse pParse, SrcList p, Token* pTable, Token* pDatabase, Token* pAlias, Select pSubquery, Expr pOn, IdList* pUsing)
{
    SrcItem pItem;
    sqlite3 db = pParse.db;
    if ((p == null) &amp;&amp; (((pOn) != null) || ((pUsing) != null)))
    {
        sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s", (pOn ? "ON" : "USING"));
        goto append_from_error;
    }

    p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);
    if ((p) == (null))
    {
        goto append_from_error;
    }

    pItem = p.a[p.nSrc - 1];
    if (((pParse.eParseMode) &gt;= (2)) &amp;&amp; ((pItem.zName) != null))
    {
        Token* pToken = (((pDatabase) != null) &amp;&amp; ((pDatabase-&gt;z) != null)) ? pDatabase : pTable;
        sqlite3RenameTokenMap(pParse, pItem.zName, pToken);
    }

    if ((pAlias-&gt;n) != 0)
    {
        pItem.zAlias = sqlite3NameFromToken(db, pAlias);
    }

    pItem.pSelect = pSubquery;
    pItem.pOn = pOn;
    pItem.pUsing = pUsing;
    return p;
    append_from_error:
        ;
    sqlite3ExprDelete(db, pOn);
    sqlite3IdListDelete(db, pUsing);
    sqlite3SelectDelete(db, pSubquery);
    return null;
}</function>
  <function>public static SrcList sqlite3SrcListAppendList(Parse pParse, SrcList p1, SrcList p2)
{
    if ((p2) != null)
    {
        SrcList pNew = sqlite3SrcListEnlarge(pParse, p1, (int)(p2.nSrc), (int)(1));
        if ((pNew) == (null))
        {
            sqlite3SrcListDelete(pParse.db, p2);
        }
        else
        {
            p1 = pNew;
            CRuntime.memcpy(p1.a[1], p2.a, (ulong)(p2.nSrc * sizeof(SrcItem)));
            sqlite3DbFree(pParse.db, p2);
        }
    }

    return p1;
}</function>
  <function>public static void sqlite3SrcListAssignCursors(Parse pParse, SrcList pList)
{
    int i = 0;
    SrcItem pItem;
    if ((pList) != null)
    {
        for (i = (int)(0), pItem = pList.a; (i) &lt; (pList.nSrc); i++, pItem++)
        {
            if ((pItem.iCursor) &gt;= (0))
                continue;
            pItem.iCursor = (int)(pParse.nTab++);
            if ((pItem.pSelect) != null)
            {
                sqlite3SrcListAssignCursors(pParse, pItem.pSelect.pSrc);
            }
        }
    }
}</function>
  <function>public static void sqlite3SrcListDelete(sqlite3 db, SrcList pList)
{
    int i = 0;
    SrcItem pItem;
    if ((pList) == (null))
        return;
    for (pItem = pList.a, i = (int)(0); (i) &lt; (pList.nSrc); i++, pItem++)
    {
        if ((pItem.zDatabase) != null)
            sqlite3DbFreeNN(db, pItem.zDatabase);
        sqlite3DbFree(db, pItem.zName);
        if ((pItem.zAlias) != null)
            sqlite3DbFreeNN(db, pItem.zAlias);
        if ((pItem.fg.isIndexedBy) != 0)
            sqlite3DbFree(db, pItem.u1.zIndexedBy);
        if ((pItem.fg.isTabFunc) != 0)
            sqlite3ExprListDelete(db, pItem.u1.pFuncArg);
        sqlite3DeleteTable(db, pItem.pTab);
        if ((pItem.pSelect) != null)
            sqlite3SelectDelete(db, pItem.pSelect);
        if ((pItem.pOn) != null)
            sqlite3ExprDelete(db, pItem.pOn);
        if ((pItem.pUsing) != null)
            sqlite3IdListDelete(db, pItem.pUsing);
    }

    sqlite3DbFreeNN(db, pList);
}</function>
  <function>public static SrcList sqlite3SrcListDup(sqlite3 db, SrcList p, int flags)
{
    SrcList pNew;
    int i = 0;
    int nByte = 0;
    if ((p) == (null))
        return null;
    nByte = (int)(sizeof(SrcList) + ((p.nSrc) &gt; (0) ? sizeof(SrcItem) * (p.nSrc - 1) : 0));
    pNew = sqlite3DbMallocRawNN(db, (ulong)(nByte));
    if ((pNew) == (null))
        return null;
    pNew.nSrc = (int)(pNew.nAlloc = (uint)(p.nSrc));
    for (i = (int)(0); (i) &lt; (p.nSrc); i++)
    {
        SrcItem pNewItem = pNew.a[i];
        SrcItem pOldItem = p.a[i];
        Table pTab;
        pNewItem.pSchema = pOldItem.pSchema;
        pNewItem.zDatabase = sqlite3DbStrDup(db, pOldItem.zDatabase);
        pNewItem.zName = sqlite3DbStrDup(db, pOldItem.zName);
        pNewItem.zAlias = sqlite3DbStrDup(db, pOldItem.zAlias);
        pNewItem.fg = (SrcItem::(unnamed at sqlite3.c : 18322 : 3))(pOldItem.fg);
        pNewItem.iCursor = (int)(pOldItem.iCursor);
        pNewItem.addrFillSub = (int)(pOldItem.addrFillSub);
        pNewItem.regReturn = (int)(pOldItem.regReturn);
        if ((pNewItem.fg.isIndexedBy) != 0)
        {
            pNewItem.u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem.u1.zIndexedBy);
        }

        pNewItem.u2 = (union SrcItem::(unnamed at sqlite3.c : 18342 : 3) ) ( pOldItem . u2 ) ;  if  ( ( pNewItem . fg . isCte ) != 0 ) { pNewItem . u2 . pCteUse -&gt; nUse ++ ;  } if  ( ( pNewItem . fg . isTabFunc ) != 0 ) { pNewItem . u1 . pFuncArg  =  sqlite3ExprListDup ( db ,  pOldItem . u1 . pFuncArg ,  ( int ) ( flags ) ) ;  } pTab  =  pNewItem . pTab  =  pOldItem . pTab ;  if  ( ( pTab ) != null ) { pTab . nTabRef ++ ;  } pNewItem . pSelect  =  sqlite3SelectDup ( db ,  pOldItem . pSelect ,  ( int ) ( flags ) ) ;  pNewItem . pOn  =  sqlite3ExprDup ( db ,  pOldItem . pOn ,  ( int ) ( flags ) ) ;  pNewItem . pUsing  =  sqlite3IdListDup ( db ,  pOldItem . pUsing ) ;  pNewItem . colUsed  =  ( ulong ) ( pOldItem . colUsed ) ;  }

    return pNew;
}</function>
  <function>public static SrcList sqlite3SrcListEnlarge(Parse pParse, SrcList pSrc, int nExtra, int iStart)
{
    int i = 0;
    if (((uint)(pSrc.nSrc) + nExtra) &gt; (pSrc.nAlloc))
    {
        SrcList pNew;
        long nAlloc = (long)(2 * (long)(pSrc.nSrc) + nExtra);
        sqlite3 db = pParse.db;
        if ((pSrc.nSrc + nExtra) &gt;= (200))
        {
            sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d", (int)(200));
            return null;
        }

        if ((nAlloc) &gt; (200))
            nAlloc = (long)(200);
        pNew = sqlite3DbRealloc(db, pSrc, (ulong)(sizeof(SrcList) + (nAlloc - 1) * sizeof(SrcItem)));
        if ((pNew) == (null))
        {
            return null;
        }

        pSrc = pNew;
        pSrc.nAlloc = (uint)(nAlloc);
    }

    for (i = (int)(pSrc.nSrc - 1); (i) &gt;= (iStart); i--)
    {
        pSrc.a[i + nExtra] = (SrcItem)(pSrc.a[i]);
    }

    pSrc.nSrc += (int)(nExtra);
    CRuntime.memset(pSrc.a[iStart], (int)(0), (ulong)(sizeof(SrcItem) * nExtra));
    for (i = (int)(iStart); (i) &lt; (iStart + nExtra); i++)
    {
        pSrc.a[i].iCursor = (int)(-1);
    }

    return pSrc;
}</function>
  <function>public static void sqlite3SrcListFuncArgs(Parse pParse, SrcList p, ExprList pList)
{
    if ((p) != null)
    {
        SrcItem pItem = p.a[p.nSrc - 1];
        pItem.u1.pFuncArg = pList;
        pItem.fg.isTabFunc = (uint)(1);
    }
    else
    {
        sqlite3ExprListDelete(pParse.db, pList);
    }
}</function>
  <function>public static void sqlite3SrcListIndexedBy(Parse pParse, SrcList p, Token* pIndexedBy)
{
    if (((p) != null) &amp;&amp; ((pIndexedBy-&gt;n) &gt; (0)))
    {
        SrcItem pItem;
        pItem = p.a[p.nSrc - 1];
        if (((pIndexedBy-&gt;n) == (1)) &amp;&amp; (pIndexedBy-&gt;z == null))
        {
            pItem.fg.notIndexed = (uint)(1);
        }
        else
        {
            pItem.u1.zIndexedBy = sqlite3NameFromToken(pParse.db, pIndexedBy);
            pItem.fg.isIndexedBy = (uint)(1);
        }
    }
}</function>
  <function>public static Table sqlite3SrcListLookup(Parse pParse, SrcList pSrc)
{
    SrcItem pItem = pSrc.a;
    Table pTab;
    pTab = sqlite3LocateTableItem(pParse, (uint)(0), pItem);
    sqlite3DeleteTable(pParse.db, pItem.pTab);
    pItem.pTab = pTab;
    if ((pTab) != null)
    {
        pTab.nTabRef++;
        if (((pItem.fg.isIndexedBy) != 0) &amp;&amp; ((sqlite3IndexedByLookup(pParse, pItem)) != 0))
        {
            pTab = null;
        }
    }

    return pTab;
}</function>
  <function>public static void sqlite3SrcListShiftJoinType(SrcList p)
{
    if ((p) != null)
    {
        int i = 0;
        for (i = (int)(p.nSrc - 1); (i) &gt; (0); i--)
        {
            p.a[i].fg.jointype = (byte)(p.a[i - 1].fg.jointype);
        }

        p.a[0].fg.jointype = (byte)(0);
    }
}</function>
  <function>public static void sqlite3StartTable(Parse pParse, Token* pName1, Token* pName2, int isTemp, int isView, int isVirtual, int noErr)
{
    Table pTable;
    sbyte* zName = null;
    sqlite3 db = pParse.db;
    Vdbe v;
    int iDb = 0;
    Token* pName;
    if (((db.init.busy) != 0) &amp;&amp; ((db.init.newTnum) == (1)))
    {
        iDb = (int)(db.init.iDb);
        zName = sqlite3DbStrDup(db, (((!0) != 0) &amp;&amp; ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"));
        pName = pName1;
    }
    else
    {
        iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &amp;pName));
        if ((iDb) &lt; (0))
            return;
        if ((((0 == 0) &amp;&amp; ((isTemp) != 0)) &amp;&amp; ((pName2-&gt;n) &gt; (0))) &amp;&amp; (iDb != 1))
        {
            sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
            return;
        }

        if ((0 == 0) &amp;&amp; ((isTemp) != 0))
            iDb = (int)(1);
        zName = sqlite3NameFromToken(db, pName);
        if (((pParse.eParseMode) &gt;= (2)))
        {
            sqlite3RenameTokenMap(pParse, (void*)(zName), pName);
        }
    }

    pParse.sNameToken = (Token)(*pName);
    if ((zName) == (null))
        return;
    if ((sqlite3CheckObjectName(pParse, zName, (isView) != 0 ? "view" : "table", zName)) != 0)
    {
        goto begin_table_error;
    }

    if ((db.init.iDb) == (1))
        isTemp = (int)(1);
    {
        sbyte* zDb = db.aDb[iDb].zDbSName;
        if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) &amp;&amp; ((isTemp) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
        {
            goto begin_table_error;
        }

        if ((isVirtual == 0) &amp;&amp; ((sqlite3AuthCheck(pParse, (int)(sqlite3StartTable_aCode[isTemp + 2 * isView]), zName, null, zDb)) != 0))
        {
            goto begin_table_error;
        }
    }

    if (!(pParse.eParseMode != 0))
    {
        sbyte* zDb = db.aDb[iDb].zDbSName;
        if (0 != sqlite3ReadSchema(pParse))
        {
            goto begin_table_error;
        }

        pTable = sqlite3FindTable(db, zName, zDb);
        if ((pTable) != null)
        {
            if (noErr == 0)
            {
                sqlite3ErrorMsg(pParse, "%s %T already exists", ((((pTable).eTabType) == (2)) ? "view" : "table"), pName);
            }
            else
            {
                sqlite3CodeVerifySchema(pParse, (int)(iDb));
                sqlite3ForceNotReadOnly(pParse);
            }

            goto begin_table_error;
        }

        if (sqlite3FindIndex(db, zName, zDb) != null)
        {
            sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
            goto begin_table_error;
        }
    }

    pTable = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
    if ((pTable) == (null))
    {
        pParse.rc = (int)(7);
        pParse.nErr++;
        goto begin_table_error;
    }

    pTable.zName = zName;
    pTable.iPKey = (short)(-1);
    pTable.pSchema = db.aDb[iDb].pSchema;
    pTable.nTabRef = (uint)(1);
    pTable.nRowLogEst = (short)(200);
    pParse.pNewTable = pTable;
    if ((db.init.busy == 0) &amp;&amp; ((v = sqlite3GetVdbe(pParse)) != null))
    {
        int addr1 = 0;
        int fileFormat = 0;
        int reg1 = 0;
        int reg2 = 0;
        int reg3 = 0;
        sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
        if ((isVirtual) != 0)
        {
            sqlite3VdbeAddOp0(v, (int)(169));
        }

        reg1 = (int)(pParse.regRowid = (int)(++pParse.nMem));
        reg2 = (int)(pParse.regRoot = (int)(++pParse.nMem));
        reg3 = (int)(++pParse.nMem);
        sqlite3VdbeAddOp3(v, (int)(98), (int)(iDb), (int)(reg3), (int)(2));
        sqlite3VdbeUsesBtree(v, (int)(iDb));
        addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(reg3)));
        fileFormat = (int)((db.flags &amp; 0x00000002) != 0 ? 1 : 4);
        sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(2), (int)(fileFormat));
        sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(5), (int)((db).enc));
        sqlite3VdbeJumpHere(v, (int)(addr1));
        if (((isView) != 0) || ((isVirtual) != 0))
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(reg2));
        }
        else
        {
            pParse.u1.addrCrTab = (int)(sqlite3VdbeAddOp3(v, (int)(146), (int)(iDb), (int)(reg2), (int)(1)));
        }

        sqlite3OpenSchemaTable(pParse, (int)(iDb));
        sqlite3VdbeAddOp2(v, (int)(126), (int)(0), (int)(reg1));
        sqlite3VdbeAddOp4(v, (int)(76), (int)(6), (int)(reg3), (int)(0), sqlite3StartTable_nullRow, (int)(-1));
        sqlite3VdbeAddOp3(v, (int)(127), (int)(0), (int)(reg3), (int)(reg1));
        sqlite3VdbeChangeP5(v, (ushort)(0x08));
        sqlite3VdbeAddOp0(v, (int)(121));
    }

    return;
    begin_table_error:
        ; pParse . checkSchema  =  ( byte ) ( 1 ) ; 
    sqlite3DbFree(db, zName);
    return;
}</function>
  <function>public static void sqlite3StatusDown(int op, int N)
{
    sqlite3Stat.nowValue[op] -= (long)(N);
}</function>
  <function>public static void sqlite3StatusHighwater(int op, int X)
{
    long newValue = 0;
    newValue = ((long)(X));
    if ((newValue) &gt; (sqlite3Stat.mxValue[op]))
    {
        sqlite3Stat.mxValue[op] = (long)(newValue);
    }
}</function>
  <function>public static void sqlite3StatusUp(int op, int N)
{
    sqlite3Stat.nowValue[op] += (long)(N);
    if ((sqlite3Stat.nowValue[op]) &gt; (sqlite3Stat.mxValue[op]))
    {
        sqlite3Stat.mxValue[op] = (long)(sqlite3Stat.nowValue[op]);
    }
}</function>
  <function>public static long sqlite3StatusValue(int op)
{
    return (long)(sqlite3Stat.nowValue[op]);
}</function>
  <function>public static int sqlite3Step(Vdbe p)
{
    sqlite3 db;
    int rc = 0;
    if (p.iVdbeMagic != 0x2df20da3)
    {
        sqlite3_reset((sqlite3_stmt*)(p));
    }

    db = p.db;
    if ((db.mallocFailed) != 0)
    {
        p.rc = (int)(7);
        return (int)(7);
    }

    if (((p.pc) &lt; (0)) &amp;&amp; ((p.expired) != 0))
    {
        p.rc = (int)(17);
        rc = (int)(1);
        if ((p.prepFlags &amp; 0x80) != 0)
        {
            rc = (int)(sqlite3VdbeTransferError(p));
        }

        goto end_of_step;
    }

    if ((p.pc) &lt; (0))
    {
        if ((db.nVdbeActive) == (0))
        {
            (0);
        }

        if ((((db.mTrace &amp; (0x02 | 0x80)) != 0) &amp;&amp; (db.init.busy == 0)) &amp;&amp; ((p.zSql) != null))
        {
            sqlite3OsCurrentTimeInt64(db.pVfs, &amp;p.startTime);
        }
        else
        {
        }

        db.nVdbeActive++;
        if ((p.readOnly) == (0))
            db.nVdbeWrite++;
        if ((p.bIsReader) != 0)
            db.nVdbeRead++;
        p.pc = (int)(0);
    }

    if ((p.explain) != 0)
    {
        rc = (int)(sqlite3VdbeList(p));
    }
    else
    {
        db.nVdbeExec++;
        rc = (int)(sqlite3VdbeExec(p));
        db.nVdbeExec--;
    }

    if (rc != 100)
    {
        if (((p).startTime) &gt; (0))
        {
            invokeProfileCallback(db, p);
        }

        if (((rc) == (101)) &amp;&amp; ((db.autoCommit) != 0))
        {
            p.rc = (int)(doWalCallbacks(db));
            if (p.rc != 0)
            {
                rc = (int)(1);
            }
        }
        else if ((rc != 101) &amp;&amp; ((p.prepFlags &amp; 0x80) != 0))
        {
            rc = (int)(sqlite3VdbeTransferError(p));
        }
    }

    db.errCode = (int)(rc);
    if ((7) == (sqlite3ApiExit(p.db, (int)(p.rc))))
    {
        p.rc = (int)(7);
        if ((p.prepFlags &amp; 0x80) != 0)
            rc = (int)(p.rc);
    }

    end_of_step:
        ;
    return (int)(rc &amp; db.errMask);
}</function>
  <function>public static long sqlite3StmtCurrentTime(sqlite3_context p)
{
    int rc = 0;
    long* piTime = &amp;p.pVdbe.iCurrentTime;
    if ((*piTime) == (0))
    {
        rc = (int)(sqlite3OsCurrentTimeInt64(p.pOut.db.pVfs, piTime));
        if ((rc) != 0)
            *piTime = (long)(0);
    }

    return (long)(*piTime);
}</function>
  <function>public static short sqlite3StorageColumnToTable(Table pTab, short iCol)
{
    if ((pTab.tabFlags &amp; 0x00000020) != 0)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt;= (iCol); i++)
        {
            if ((pTab.aCol[i].colFlags &amp; 0x0020) != 0)
                iCol++;
        }
    }

    return (short)(iCol);
}</function>
  <function>public static int sqlite3StrAccumEnlarge(sqlite3_str p, int N)
{
    sbyte* zNew;
    if ((p.accError) != 0)
    {
        return (int)(0);
    }

    if ((p.mxAlloc) == (0))
    {
        sqlite3StrAccumSetError(p, (byte)(18));
        return (int)(p.nAlloc - p.nChar - 1);
    }
    else
    {
        sbyte* zOld = (((p).printfFlags &amp; 0x04) != 0) ? p.zText : null;
        long szNew = (long)(p.nChar);
        szNew += (long)((long)(N) + 1);
        if ((szNew + p.nChar) &lt;= (p.mxAlloc))
        {
            szNew += (long)(p.nChar);
        }

        if ((szNew) &gt; (p.mxAlloc))
        {
            sqlite3_str_reset(p);
            sqlite3StrAccumSetError(p, (byte)(18));
            return (int)(0);
        }
        else
        {
            p.nAlloc = (uint)((int)(szNew));
        }

        if ((p.db) != null)
        {
            zNew = sqlite3DbRealloc(p.db, zOld, (ulong)(p.nAlloc));
        }
        else
        {
            zNew = sqlite3Realloc(zOld, (ulong)(p.nAlloc));
        }

        if ((zNew) != null)
        {
            if ((!(((p).printfFlags &amp; 0x04) != 0)) &amp;&amp; ((p.nChar) &gt; (0)))
                CRuntime.memcpy(zNew, p.zText, (ulong)(p.nChar));
            p.zText = zNew;
            p.nAlloc = (uint)(sqlite3DbMallocSize(p.db, zNew));
            p.printfFlags |= (byte)(0x04);
        }
        else
        {
            sqlite3_str_reset(p);
            sqlite3StrAccumSetError(p, (byte)(7));
            return (int)(0);
        }
    }

    return (int)(N);
}</function>
  <function>public static sbyte* sqlite3StrAccumFinish(sqlite3_str p)
{
    if ((p.zText) != null)
    {
        p.zText[p.nChar] = (sbyte)(0);
        if (((p.mxAlloc) &gt; (0)) &amp;&amp; (!(((p).printfFlags &amp; 0x04) != 0)))
        {
            return strAccumFinishRealloc(p);
        }
    }

    return p.zText;
}</function>
  <function>public static void sqlite3StrAccumInit(sqlite3_str p, sqlite3 db, sbyte* zBase, int n, int mx)
{
    p.zText = zBase;
    p.db = db;
    p.nAlloc = (uint)(n);
    p.mxAlloc = (uint)(mx);
    p.nChar = (uint)(0);
    p.accError = (byte)(0);
    p.printfFlags = (byte)(0);
}</function>
  <function>public static void sqlite3StrAccumSetError(sqlite3_str p, byte eError)
{
    p.accError = (byte)(eError);
    if ((p.mxAlloc) != 0)
        sqlite3_str_reset(p);
    if ((eError) == (18))
        sqlite3ErrorToParser(p.db, (int)(eError));
}</function>
  <function>public static int sqlite3StrICmp(sbyte* zLeft, sbyte* zRight)
{
    byte* a; byte  * b ; 
    int c = 0; int  x  =  0 ; 
    a = (byte*)(zLeft);
    b = (byte*)(zRight);
    for (;;)
    {
        c = (int)(*a);
        x = (int)(*b);
        if ((c) == (x))
        {
            if ((c) == (0))
                break;
        }
        else
        {
            c = (int)((int)(sqlite3UpperToLower[c]) - (int)(sqlite3UpperToLower[x]));
            if ((c) != 0)
                break;
        }

        a++;
        b++;
    }

    return (int)(c);
}</function>
  <function>public static byte sqlite3StrIHash(sbyte* z)
{
    byte h = (byte)(0);
    if ((z) == (null))
        return (byte)(0);
    while ((z[0]) != 0)
    {
        h += (byte)(sqlite3UpperToLower[(byte)(z[0])]);
        z++;
    }

    return (byte)(h);
}</function>
  <function>public static void sqlite3StringToId(Expr p)
{
    if ((p.op) == (117))
    {
        p.op = (byte)(59);
    }
    else if (((p.op) == (113)) &amp;&amp; ((p.pLeft.op) == (117)))
    {
        p.pLeft.op = (byte)(59);
    }
}</function>
  <function>public static int sqlite3Strlen30(sbyte* z)
{
    if ((z) == (null))
        return (int)(0);
    return (int)(0x3fffffff &amp; (int)(CRuntime.strlen(z)));
}</function>
  <function>public static int sqlite3SubInt64(long* pA, long iB)
{
    if ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))
    {
        if ((*pA) &gt;= (0))
            return (int)(1);
        *pA -= (long)(iB);
        return (int)(0);
    }
    else
    {
        return (int)(sqlite3AddInt64(pA, (long)(-iB)));
    }
}</function>
  <function>public static void sqlite3SubselectError(Parse pParse, int nActual, int nExpect)
{
    if ((pParse.nErr) == (0))
    {
        sbyte* zFmt = "sub-select returns %d columns - expected %d";
        sqlite3ErrorMsg(pParse, zFmt, (int)(nActual), (int)(nExpect));
    }
}</function>
  <function>public static void sqlite3SystemError(sqlite3 db, int rc)
{
    if ((rc) == (10 | (12 &lt;&lt; 8)))
        return;
    rc &amp;= (int)(0xff);
    if (((rc) == (14)) || ((rc) == (10)))
    {
        db.iSysErrno = (int)(sqlite3OsGetLastError(db.pVfs));
    }
}</function>
  <function>public static void sqlite3TableAffinity(Vdbe v, Table pTab, int iReg)
{
    int i = 0; int  j  =  0 ; 
    sbyte* zColAff;
    if ((pTab.tabFlags &amp; 0x00010000) != 0)
    {
        if ((iReg) == (0))
        {
            VdbeOp* pPrev;
            sqlite3VdbeAppendP4(v, pTab, (int)(-6));
            pPrev = sqlite3VdbeGetOp(v, (int)(-1));
            pPrev-&gt;opcode = (byte)(94);
            sqlite3VdbeAddOp3(v, (int)(96), (int)(pPrev-&gt;p1), (int)(pPrev-&gt;p2), (int)(pPrev-&gt;p3));
        }
        else
        {
            sqlite3VdbeAddOp2(v, (int)(94), (int)(iReg), (int)(pTab.nNVCol));
            sqlite3VdbeAppendP4(v, pTab, (int)(-6));
        }

        return;
    }

    zColAff = pTab.zColAff;
    if ((zColAff) == (null))
    {
        sqlite3 db = sqlite3VdbeDb(v);
        zColAff = (sbyte*)(sqlite3DbMallocRaw(null, (ulong)(pTab.nCol + 1)));
        if (zColAff == null)
        {
            sqlite3OomFault(db);
            return;
        }

        for (i = (int)(j = (int)(0)); (i) &lt; (pTab.nCol); i++)
        {
            if ((pTab.aCol[i].colFlags &amp; 0x0020) == (0))
            {
                zColAff[j++] = (sbyte)(pTab.aCol[i].affinity);
            }
        }

        do
        {
            zColAff[j--] = (sbyte)(0);
        }
        while (((j) &gt;= (0)) &amp;&amp; ((zColAff[j]) &lt;= (0x41)));
        pTab.zColAff = zColAff;
    }

    i = (int)(CRuntime.strlen(zColAff) &amp; 0x3fffffff);
    if ((i) != 0)
    {
        if ((iReg) != 0)
        {
            sqlite3VdbeAddOp4(v, (int)(95), (int)(iReg), (int)(i), (int)(0), zColAff, (int)(i));
        }
        else
        {
            sqlite3VdbeChangeP4(v, (int)(-1), zColAff, (int)(i));
        }
    }
}</function>
  <function>public static sbyte sqlite3TableColumnAffinity(Table pTab, int iCol)
{
    if (((iCol) &lt; (0)) || ((iCol) &gt;= (pTab.nCol)))
        return (sbyte)(0x44);
    return (sbyte)(pTab.aCol[iCol].affinity);
}</function>
  <function>public static short sqlite3TableColumnToIndex(Index pIdx, short iCol)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (pIdx.nColumn); i++)
    {
        if ((iCol) == (pIdx.aiColumn[i]))
            return (short)(i);
    }

    return (short)(-1);
}</function>
  <function>public static short sqlite3TableColumnToStorage(Table pTab, short iCol)
{
    int i = 0;
    short n = 0;
    if (((pTab.tabFlags &amp; 0x00000020) == (0)) || ((iCol) &lt; (0)))
        return (short)(iCol);
    for (i = (int)(0), n = (short)(0); (i) &lt; (iCol); i++)
    {
        if ((pTab.aCol[i].colFlags &amp; 0x0020) == (0))
            n++;
    }

    if ((pTab.aCol[i].colFlags &amp; 0x0020) != 0)
    {
        return (short)(pTab.nNVCol + i - n);
    }
    else
    {
        return (short)(n);
    }
}</function>
  <function>public static void sqlite3TableLock(Parse pParse, int iDb, uint iTab, byte isWriteLock, sbyte* zName)
{
    if ((iDb) == (1))
        return;
    if (sqlite3BtreeSharable(pParse.db.aDb[iDb].pBt) == 0)
        return;
    lockTable(pParse, (int)(iDb), (uint)(iTab), (byte)(isWriteLock), zName);
}</function>
  <function>public static int sqlite3TempInMemory(sqlite3 db)
{
    return (((db.temp_store) == (2)) ? 1 : 0);
}</function>
  <function>public static int sqlite3TestExtInit(sqlite3 db)
{
    (void)(db);
    return (int)(sqlite3FaultSim((int)(500)));
}</function>
  <function>public static int sqlite3ThreadCreate(SQLiteThread ppThread, delegate75 xTask, void* pIn)
{
    SQLiteThread p;
    ppThread = null;
    p = sqlite3Malloc((ulong)(sizeof(SQLiteThread)));
    if ((p) == (null))
        return (int)(7);
    if (((sqlite3Config.bCoreMutex) == (0)) || ((sqlite3FaultSim((int)(200))) != 0))
    {
        CRuntime.memset(p, (int)(0), (ulong)(sizeof(SQLiteThread)));
    }
    else
    {
        p.xTask = xTask;
        p.pIn = pIn;
        p.tid = (void*)(_beginthreadex(null, (uint)(0), sqlite3ThreadProc, p, (uint)(0), &amp;p.id));
        if ((p.tid) == (null))
        {
            CRuntime.memset(p, (int)(0), (ulong)(sizeof(SQLiteThread)));
        }
    }

    if ((p.xTask) == (null))
    {
        p.id = (uint)(GetCurrentThreadId());
        p.pResult = xTask(pIn);
    }

    ppThread = p;
    return (int)(0);
}</function>
  <function>public static int sqlite3ThreadJoin(SQLiteThread p, void** ppOut)
{
    uint rc = 0;
    int bRc = 0;
    if (((p) == (null)))
        return (int)(7);
    if ((p.xTask) == (null))
    {
        rc = (uint)(((uint)(0x00000000L)) + 0);
    }
    else
    {
        rc = (uint)(sqlite3Win32Wait(p.tid));
        bRc = (int)(CloseHandle(p.tid));
    }

    if ((rc) == (((uint)(0x00000000L)) + 0))
        *ppOut = p.pResult;
    sqlite3_free(p);
    return (int)(((rc) == (((uint)(0x00000000L)) + 0)) ? 0 : 1);
}</function>
  <function>public static uint sqlite3ThreadProc(void* pArg)
{
    SQLiteThread p = (SQLiteThread)(pArg);
    p.pResult = p.xTask(p.pIn);
    _endthreadex((uint)(0));
    return (uint)(0);
}</function>
  <function>public static void sqlite3TokenInit(Token* p, sbyte* z)
{
    p-&gt;z = z;
    p-&gt;n = (uint)(sqlite3Strlen30(z));
}</function>
  <function>public static int sqlite3TransferBindings(sqlite3_stmt* pFromStmt, sqlite3_stmt* pToStmt)
{
    Vdbe pFrom = (Vdbe)(pFromStmt);
    Vdbe pTo = (Vdbe)(pToStmt);
    int i = 0;
    sqlite3_mutex_enter(pTo.db.mutex);
    for (i = (int)(0); (i) &lt; (pFrom.nVar); i++)
    {
        sqlite3VdbeMemMove(pTo.aVar[i], pFrom.aVar[i]);
    }

    sqlite3_mutex_leave(pTo.db.mutex);
    return (int)(0);
}</function>
  <function>public static uint sqlite3TriggerColmask(Parse pParse, Trigger pTrigger, ExprList pChanges, int isNew, int tr_tm, Table pTab, int orconf)
{
    int op = (int)(pChanges ? 129 : 128);
    uint mask = (uint)(0);
    Trigger p;
    for (p = pTrigger; p; p = p.pNext)
    {
        if ((((p.op) == (op)) &amp;&amp; ((tr_tm &amp; p.tr_tm) != 0)) &amp;&amp; ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
        {
            if ((p.bReturning) != 0)
            {
                mask = (uint)(0xffffffff);
            }
            else
            {
                TriggerPrg pPrg;
                pPrg = getRowTrigger(pParse, p, pTab, (int)(orconf));
                if ((pPrg) != null)
                {
                    mask |= (uint)(pPrg.aColmask[isNew]);
                }
            }
        }
    }

    return (uint)(mask);
}</function>
  <function>public static TriggerStep sqlite3TriggerDeleteStep(Parse pParse, Token* pTableName, Expr pWhere, sbyte* zStart, sbyte* zEnd)
{
    sqlite3 db = pParse.db;
    TriggerStep pTriggerStep;
    pTriggerStep = triggerStepAllocate(pParse, (byte)(128), pTableName, zStart, zEnd);
    if ((pTriggerStep) != null)
    {
        if (((pParse.eParseMode) &gt;= (2)))
        {
            pTriggerStep.pWhere = pWhere;
            pWhere = null;
        }
        else
        {
            pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001));
        }

        pTriggerStep.orconf = (byte)(11);
    }

    sqlite3ExprDelete(db, pWhere);
    return pTriggerStep;
}</function>
  <function>public static TriggerStep sqlite3TriggerInsertStep(Parse pParse, Token* pTableName, IdList* pColumn, Select pSelect, byte orconf, Upsert pUpsert, sbyte* zStart, sbyte* zEnd)
{
    sqlite3 db = pParse.db;
    TriggerStep pTriggerStep;
    pTriggerStep = triggerStepAllocate(pParse, (byte)(127), pTableName, zStart, zEnd);
    if ((pTriggerStep) != null)
    {
        if (((pParse.eParseMode) &gt;= (2)))
        {
            pTriggerStep.pSelect = pSelect;
            pSelect = null;
        }
        else
        {
            pTriggerStep.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001));
        }

        pTriggerStep.pIdList = pColumn;
        pTriggerStep.pUpsert = pUpsert;
        pTriggerStep.orconf = (byte)(orconf);
        if ((pUpsert) != null)
        {
            sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget);
        }
    }
    else
    {
        sqlite3IdListDelete(db, pColumn);
        sqlite3UpsertDelete(db, pUpsert);
    }

    sqlite3SelectDelete(db, pSelect);
    return pTriggerStep;
}</function>
  <function>public static Trigger sqlite3TriggerList(Parse pParse, Table pTab)
{
    Schema pTmpSchema;
    Trigger pList;
    HashElem* p;
    if ((pParse.disableTriggers) != 0)
    {
        return null;
    }

    pTmpSchema = pParse.db.aDb[1].pSchema;
    p = ((&amp;pTmpSchema.trigHash)-&gt;first);
    pList = pTab.pTrigger;
    while ((p) != null)
    {
        Trigger pTrig = (Trigger)((p)-&gt;data);
        if (((((pTrig.pTabSchema) == (pTab.pSchema)) &amp;&amp; ((pTrig.table) != null)) &amp;&amp; ((0) == (sqlite3StrICmp(pTrig.table, pTab.zName)))) &amp;&amp; (pTrig.pTabSchema != pTmpSchema))
        {
            pTrig.pNext = pList;
            pList = pTrig;
        }
        else if (((pTrig.op) == (150)) &amp;&amp; ((pParse.db.pVtabCtx) == (null)))
        {
            pTrig.table = pTab.zName;
            pTrig.pTabSchema = pTab.pSchema;
            pTrig.pNext = pList;
            pList = pTrig;
        }

        p = ((p)-&gt;next);
    }

    return pList;
}</function>
  <function>public static TriggerStep sqlite3TriggerSelectStep(sqlite3 db, Select pSelect, sbyte* zStart, sbyte* zEnd)
{
    TriggerStep pTriggerStep = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerStep)));
    if ((pTriggerStep) == (null))
    {
        sqlite3SelectDelete(db, pSelect);
        return null;
    }

    pTriggerStep.op = (byte)(138);
    pTriggerStep.pSelect = pSelect;
    pTriggerStep.orconf = (byte)(11);
    pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd);
    return pTriggerStep;
}</function>
  <function>public static Trigger sqlite3TriggersExist(Parse pParse, Table pTab, int op, ExprList pChanges, int* pMask)
{
    int mask = (int)(0);
    Trigger pList = null;
    Trigger p;
    pList = sqlite3TriggerList(pParse, pTab);
    if (pList != null)
    {
        p = pList;
        if (((pParse.db.flags &amp; 0x00040000) == (0)) &amp;&amp; (pTab.pTrigger != null))
        {
            if ((pList) == (pTab.pTrigger))
            {
                pList = null;
                goto exit_triggers_exist;
            }

            while (((p.pNext) != null) &amp;&amp; (p.pNext != pTab.pTrigger))
            {
                p = p.pNext;
            }

            p.pNext = null;
            p = pList;
        }

        do
        {
            if (((p.op) == (op)) &amp;&amp; ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
            {
                mask |= (int)(p.tr_tm);
            }
            else if ((p.op) == (150))
            {
                p.op = (byte)(op);
                if ((((pTab).eTabType) == (1)))
                {
                    if (op != 127)
                    {
                        sqlite3ErrorMsg(pParse, "%s RETURNING is not available on virtual tables", (op) == (128) ? "DELETE" : "UPDATE");
                    }

                    p.tr_tm = (byte)(1);
                }
                else
                {
                    p.tr_tm = (byte)(2);
                }

                mask |= (int)(p.tr_tm);
            }
            else if (((((p.bReturning) != 0) &amp;&amp; ((p.op) == (127))) &amp;&amp; ((op) == (129))) &amp;&amp; (((pParse).pToplevel) == (null)))
            {
                mask |= (int)(p.tr_tm);
            }

            p = p.pNext;
        }
        while ((p) != null);
    }

    exit_triggers_exist:
        ; if  ( ( pMask ) != null ) { * pMask  =  ( int ) ( mask ) ;  }
    return ((mask) != 0 ? pList : null);
}</function>
  <function>public static SrcList sqlite3TriggerStepSrc(Parse pParse, TriggerStep pStep)
{
    sqlite3 db = pParse.db;
    SrcList pSrc;
    sbyte* zName = sqlite3DbStrDup(db, pStep.zTarget);
    pSrc = sqlite3SrcListAppend(pParse, null, null, null);
    if ((pSrc) != null)
    {
        Schema pSchema = pStep.pTrig.pSchema;
        pSrc.a[0].zName = zName;
        if (pSchema != db.aDb[1].pSchema)
        {
            pSrc.a[0].pSchema = pSchema;
        }

        if ((pStep.pFrom) != null)
        {
            SrcList pDup = sqlite3SrcListDup(db, pStep.pFrom, (int)(0));
            pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);
        }
    }
    else
    {
        sqlite3DbFree(db, zName);
    }

    return pSrc;
}</function>
  <function>public static TriggerStep sqlite3TriggerUpdateStep(Parse pParse, Token* pTableName, SrcList pFrom, ExprList pEList, Expr pWhere, byte orconf, sbyte* zStart, sbyte* zEnd)
{
    sqlite3 db = pParse.db;
    TriggerStep pTriggerStep;
    pTriggerStep = triggerStepAllocate(pParse, (byte)(129), pTableName, zStart, zEnd);
    if ((pTriggerStep) != null)
    {
        if (((pParse.eParseMode) &gt;= (2)))
        {
            pTriggerStep.pExprList = pEList;
            pTriggerStep.pWhere = pWhere;
            pTriggerStep.pFrom = pFrom;
            pEList = null;
            pWhere = null;
            pFrom = null;
        }
        else
        {
            pTriggerStep.pExprList = sqlite3ExprListDup(db, pEList, (int)(0x0001));
            pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001));
            pTriggerStep.pFrom = sqlite3SrcListDup(db, pFrom, (int)(0x0001));
        }

        pTriggerStep.orconf = (byte)(orconf);
    }

    sqlite3ExprListDelete(db, pEList);
    sqlite3ExprDelete(db, pWhere);
    sqlite3SrcListDelete(db, pFrom);
    return pTriggerStep;
}</function>
  <function>public static int sqlite3TwoPartName(Parse pParse, Token* pName1, Token* pName2, Token** pUnqual)
{
    int iDb = 0;
    sqlite3 db = pParse.db;
    if ((pName2-&gt;n) &gt; (0))
    {
        if ((db.init.busy) != 0)
        {
            sqlite3ErrorMsg(pParse, "corrupt database");
            return (int)(-1);
        }

        *pUnqual = pName2;
        iDb = (int)(sqlite3FindDb(db, pName1));
        if ((iDb) &lt; (0))
        {
            sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
            return (int)(-1);
        }
    }
    else
    {
        iDb = (int)(db.init.iDb);
        *pUnqual = pName1;
    }

    return (int)(iDb);
}</function>
  <function>public static void sqlite3UniqueConstraint(Parse pParse, int onError, Index pIdx)
{
    sbyte* zErr;
    int j = 0;
    sqlite3_str errMsg = new sqlite3_str();
    Table pTab = pIdx.pTable;
    sqlite3StrAccumInit(errMsg, pParse.db, null, (int)(0), (int)(pParse.db.aLimit[0]));
    if ((pIdx.aColExpr) != null)
    {
        sqlite3_str_appendf(errMsg, "index '%q'", pIdx.zName);
    }
    else
    {
        for (j = (int)(0); (j) &lt; (pIdx.nKeyCol); j++)
        {
            sbyte* zCol;
            zCol = pTab.aCol[pIdx.aiColumn[j]].zCnName;
            if ((j) != 0)
                sqlite3_str_append(errMsg, ", ", (int)(2));
            sqlite3_str_appendall(errMsg, pTab.zName);
            sqlite3_str_append(errMsg, ".", (int)(1));
            sqlite3_str_appendall(errMsg, zCol);
        }
    }

    zErr = sqlite3StrAccumFinish(errMsg);
    sqlite3HaltConstraint(pParse, (int)((((pIdx).idxType) == (2)) ? (19 | (6 &lt;&lt; 8)) : (19 | (8 &lt;&lt; 8))), (int)(onError), zErr, (sbyte)(-7), (byte)(2));
}</function>
  <function>public static void sqlite3UnlinkAndDeleteIndex(sqlite3 db, int iDb, sbyte* zIdxName)
{
    Index pIndex;
    Hash* pHash;
    pHash = &amp;db.aDb[iDb].pSchema.idxHash;
    pIndex = sqlite3HashInsert(pHash, zIdxName, null);
    if ((pIndex) != null)
    {
        if ((pIndex.pTable.pIndex) == (pIndex))
        {
            pIndex.pTable.pIndex = pIndex.pNext;
        }
        else
        {
            Index p;
            p = pIndex.pTable.pIndex;
            while (((p) != null) &amp;&amp; (p.pNext != pIndex))
            {
                p = p.pNext;
            }

            if ((((p) != null) &amp;&amp; ((p.pNext) == (pIndex))))
            {
                p.pNext = pIndex.pNext;
            }
        }

        sqlite3FreeIndex(db, pIndex);
    }

    db.mDbFlags |= (uint)(0x0001);
}</function>
  <function>public static void sqlite3UnlinkAndDeleteTable(sqlite3 db, int iDb, sbyte* zTabName)
{
    Table p;
    Db pDb;
    pDb = db.aDb[iDb];
    p = sqlite3HashInsert(&amp;pDb.pSchema.tblHash, zTabName, null);
    sqlite3DeleteTable(db, p);
    db.mDbFlags |= (uint)(0x0001);
}</function>
  <function>public static void sqlite3UnlinkAndDeleteTrigger(sqlite3 db, int iDb, sbyte* zName)
{
    Trigger pTrigger;
    Hash* pHash;
    pHash = &amp;(db.aDb[iDb].pSchema.trigHash);
    pTrigger = sqlite3HashInsert(pHash, zName, null);
    if ((pTrigger) != null)
    {
        if ((pTrigger.pSchema) == (pTrigger.pTabSchema))
        {
            Table pTab = tableOfTrigger(pTrigger);
            if ((pTab) != null)
            {
                Trigger pp;
                for (pp = pTab.pTrigger; pp; pp = ((pp).pNext))
                {
                    if ((pp) == (pTrigger))
                    {
                        pp = (pp).pNext;
                        break;
                    }
                }
            }
        }

        sqlite3DeleteTrigger(db, pTrigger);
        db.mDbFlags |= (uint)(0x0001);
    }
}</function>
  <function>public static void sqlite3Update(Parse pParse, SrcList pTabList, ExprList pChanges, Expr pWhere, int onError, ExprList pOrderBy, Expr pLimit, Upsert pUpsert)
{
    int i = 0; int  j  =  0 ;  int  k  =  0 ; 
    Table pTab;
    int addrTop = (int)(0);
    WhereInfo pWInfo = null;
    Vdbe v;
    Index pIdx;
    Index pPk;
    int nIdx = 0;
    int nAllIdx = 0;
    int iBaseCur = 0;
    int iDataCur = 0;
    int iIdxCur = 0;
    sqlite3 db;
    int* aRegIdx = null;
    int* aXRef = null;
    byte* aToOpen;
    byte chngPk = 0;
    byte chngRowid = 0;
    byte chngKey = 0;
    Expr pRowidExpr = null;
    int iRowidExpr = (int)(-1);
    AuthContext sContext = new AuthContext();
    NameContext sNC = new NameContext();
    int iDb = 0;
    int eOnePass = 0;
    int hasFK = 0;
    int labelBreak = 0;
    int labelContinue = 0;
    int flags = 0;
    int isView = 0;
    Trigger pTrigger;
    int tmask = 0;
    int newmask = 0;
    int iEph = (int)(0);
    int nKey = (int)(0);
    int* aiCurOnePass = stackalloc int[2];
    int addrOpen = (int)(0);
    int iPk = (int)(0);
    short nPk = (short)(0);
    int bReplace = (int)(0);
    int bFinishSeek = (int)(1);
    int nChangeFrom = (int)(0);
    int regRowCount = (int)(0);
    int regOldRowid = (int)(0);
    int regNewRowid = (int)(0);
    int regNew = (int)(0);
    int regOld = (int)(0);
    int regRowSet = (int)(0);
    int regKey = (int)(0);
    CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(AuthContext)));
    db = pParse.db;
    if ((pParse.nErr) != 0)
    {
        goto update_cleanup;
    }

    pTab = sqlite3SrcListLookup(pParse, pTabList);
    if ((pTab) == (null))
        goto update_cleanup;
    iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
    pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(129), pChanges, &amp;tmask);
    isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
    nChangeFrom = (int)(((pTabList.nSrc) &gt; (1)) ? pChanges.nExpr : 0);
    if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
    {
        goto update_cleanup;
    }

    if ((sqlite3IsReadOnly(pParse, pTab, (int)(tmask))) != 0)
    {
        goto update_cleanup;
    }

    iBaseCur = (int)(iDataCur = (int)(pParse.nTab++));
    iIdxCur = (int)(iDataCur + 1);
    pPk = (((pTab).tabFlags &amp; 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
    for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
    {
        if ((pPk) == (pIdx))
        {
            iDataCur = (int)(pParse.nTab);
        }

        pParse.nTab++;
    }

    if ((pUpsert) != null)
    {
        iDataCur = (int)(pUpsert.iDataCur);
        iIdxCur = (int)(pUpsert.iIdxCur);
        pParse.nTab = (int)(iBaseCur);
    }

    pTabList.a[0].iCursor = (int)(iDataCur);
    aXRef = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (pTab.nCol + nIdx + 1) + nIdx + 2));
    if ((aXRef) == (null))
        goto update_cleanup;
    aRegIdx = aXRef + pTab.nCol;
    aToOpen = (byte*)(aRegIdx + nIdx + 1);
    CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
    aToOpen[nIdx + 1] = (byte)(0);
    for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
    {
        aXRef[i] = (int)(-1);
    }

    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    sNC.uNC.pUpsert = pUpsert;
    sNC.ncFlags = (int)(0x000200);
    v = sqlite3GetVdbe(pParse);
    if ((v) == (null))
        goto update_cleanup;
    chngRowid = (byte)(chngPk = (byte)(0));
    for (i = (int)(0); (i) &lt; (pChanges.nExpr); i++)
    {
        byte hCol = (byte)(sqlite3StrIHash(pChanges.a[i].zEName));
        if (((nChangeFrom) == (0)) &amp;&amp; ((sqlite3ResolveExprNames(sNC, pChanges.a[i].pExpr)) != 0))
        {
            goto update_cleanup;
        }

        for (j = (int)(0); (j) &lt; (pTab.nCol); j++)
        {
            if (((pTab.aCol[j].hName) == (hCol)) &amp;&amp; ((sqlite3StrICmp(pTab.aCol[j].zCnName, pChanges.a[i].zEName)) == (0)))
            {
                if ((j) == (pTab.iPKey))
                {
                    chngRowid = (byte)(1);
                    pRowidExpr = pChanges.a[i].pExpr;
                    iRowidExpr = (int)(i);
                }
                else if (((pPk) != null) &amp;&amp; ((pTab.aCol[j].colFlags &amp; 0x0001) != 0))
                {
                    chngPk = (byte)(1);
                }
                else if ((pTab.aCol[j].colFlags &amp; 0x0060) != 0)
                {
                    sqlite3ErrorMsg(pParse, "cannot UPDATE generated column \"%s\"", pTab.aCol[j].zCnName);
                    goto update_cleanup;
                }

                aXRef[j] = (int)(i);
                break;
            }
        }

        if ((j) &gt;= (pTab.nCol))
        {
            if (((pPk) == (null)) &amp;&amp; ((sqlite3IsRowid(pChanges.a[i].zEName)) != 0))
            {
                j = (int)(-1);
                chngRowid = (byte)(1);
                pRowidExpr = pChanges.a[i].pExpr;
                iRowidExpr = (int)(i);
            }
            else
            {
                sqlite3ErrorMsg(pParse, "no such column: %s", pChanges.a[i].zEName);
                pParse.checkSchema = (byte)(1);
                goto update_cleanup;
            }
        }

        {
            int rc = 0;
            rc = (int)(sqlite3AuthCheck(pParse, (int)(23), pTab.zName, (j) &lt; (0) ? "ROWID" : pTab.aCol[j].zCnName, db.aDb[iDb].zDbSName));
            if ((rc) == (1))
            {
                goto update_cleanup;
            }
            else if ((rc) == (2))
            {
                aXRef[j] = (int)(-1);
            }
        }
    }

    chngKey = (byte)(chngRowid + chngPk);
    if ((pTab.tabFlags &amp; 0x00000060) != 0)
    {
        int bProgress = 0;
        do
        {
            bProgress = (int)(0);
            for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
            {
                if ((aXRef[i]) &gt;= (0))
                    continue;
                if ((pTab.aCol[i].colFlags &amp; 0x0060) == (0))
                    continue;
                if ((sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &amp;pTab.aCol[i]), aXRef, (int)(chngRowid))) != 0)
                {
                    aXRef[i] = (int)(99999);
                    bProgress = (int)(1);
                }
            }
        }
        while ((bProgress) != 0);
    }

    pTabList.a[0].colUsed = (ulong)((((pTab).eTabType) == (1)) ? ((ulong)(-1)) : 0);
    hasFK = (int)(sqlite3FkRequired(pParse, pTab, aXRef, (int)(chngKey)));
    if ((onError) == (5))
        bReplace = (int)(1);
    for (nAllIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nAllIdx++)
    {
        int reg = 0;
        if (((((chngKey) != 0) || ((hasFK) &gt; (1))) || ((pIdx) == (pPk))) || ((indexWhereClauseMightChange(pIdx, aXRef, (int)(chngRowid))) != 0))
        {
            reg = (int)(++pParse.nMem);
            pParse.nMem += (int)(pIdx.nColumn);
        }
        else
        {
            reg = (int)(0);
            for (i = (int)(0); (i) &lt; (pIdx.nKeyCol); i++)
            {
                if ((indexColumnIsBeingUpdated(pIdx, (int)(i), aXRef, (int)(chngRowid))) != 0)
                {
                    reg = (int)(++pParse.nMem);
                    pParse.nMem += (int)(pIdx.nColumn);
                    if (((onError) == (11)) &amp;&amp; ((pIdx.onError) == (5)))
                    {
                        bReplace = (int)(1);
                    }

                    break;
                }
            }
        }

        if ((reg) == (0))
            aToOpen[nAllIdx + 1] = (byte)(0);
        aRegIdx[nAllIdx] = (int)(reg);
    }

    aRegIdx[nAllIdx] = (int)(++pParse.nMem);
    if ((bReplace) != 0)
    {
        CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
    }

    if ((pParse.nested) == (0))
        sqlite3VdbeCountChanges(v);
    sqlite3BeginWriteOperation(pParse, (((pTrigger) != null) || ((hasFK) != 0) ? 1 : 0), (int)(iDb));
    if (!(((pTab).eTabType) == (1)))
    {
        regRowSet = (int)(aRegIdx[nAllIdx]);
        regOldRowid = (int)(regNewRowid = (int)(++pParse.nMem));
        if ((((chngPk) != 0) || ((pTrigger) != null)) || ((hasFK) != 0))
        {
            regOld = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(pTab.nCol);
        }

        if ((((chngKey) != 0) || ((pTrigger) != null)) || ((hasFK) != 0))
        {
            regNewRowid = (int)(++pParse.nMem);
        }

        regNew = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(pTab.nCol);
    }

    if ((isView) != 0)
    {
        sqlite3AuthContextPush(pParse, sContext, pTab.zName);
    }

    if (((nChangeFrom) == (0)) &amp;&amp; ((isView) != 0))
    {
        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, (int)(iDataCur));
        pOrderBy = null;
        pLimit = null;
    }

    if (((nChangeFrom) == (0)) &amp;&amp; ((sqlite3ResolveExprNames(sNC, pWhere)) != 0))
    {
        goto update_cleanup;
    }

    if ((((pTab).eTabType) == (1)))
    {
        updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, (int)(onError));
        goto update_cleanup;
    }

    labelContinue = (int)(labelBreak = (int)(sqlite3VdbeMakeLabel(pParse)));
    if ((((((db.flags &amp; ((ulong)(0x00001) &lt;&lt; 32)) != 0) &amp;&amp; (pParse.pTriggerTab == null)) &amp;&amp; (pParse.nested == 0)) &amp;&amp; (pParse.bReturning == 0)) &amp;&amp; ((pUpsert) == (null)))
    {
        regRowCount = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regRowCount));
    }

    if (((nChangeFrom) == (0)) &amp;&amp; (((pTab).tabFlags &amp; 0x00000080) == (0)))
    {
        sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(regRowSet), (int)(regOldRowid));
        iEph = (int)(pParse.nTab++);
        addrOpen = (int)(sqlite3VdbeAddOp3(v, (int)(116), (int)(iEph), (int)(0), (int)(regRowSet)));
    }
    else
    {
        nPk = (short)(pPk ? pPk.nKeyCol : 0);
        iPk = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nPk);
        pParse.nMem += (int)(nChangeFrom);
        regKey = (int)(++pParse.nMem);
        if ((pUpsert) == (null))
        {
            int nEphCol = (int)(nPk + nChangeFrom + ((isView) != 0 ? pTab.nCol : 0));
            iEph = (int)(pParse.nTab++);
            if ((pPk) != null)
                sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(iPk), (int)(iPk + nPk - 1));
            addrOpen = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iEph), (int)(nEphCol)));
            if ((pPk) != null)
            {
                KeyInfo pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);
                if ((pKeyInfo) != null)
                {
                    pKeyInfo.nAllField = (ushort)(nEphCol);
                    sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
                }
            }

            if ((nChangeFrom) != 0)
            {
                updateFromSelect(pParse, (int)(iEph), pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit);
                if ((isView) != 0)
                    iDataCur = (int)(iEph);
            }
        }
    }

    if ((nChangeFrom) != 0)
    {
        sqlite3MultiWrite(pParse);
        eOnePass = (int)(0);
        nKey = (int)(nPk);
        regKey = (int)(iPk);
    }
    else
    {
        if ((pUpsert) != null)
        {
            pWInfo = null;
            eOnePass = (int)(1);
            sqlite3ExprIfFalse(pParse, pWhere, (int)(labelBreak), (int)(0x10));
            bFinishSeek = (int)(0);
        }
        else
        {
            flags = (int)(0x0004);
            if (((((pParse.nested == 0) &amp;&amp; (pTrigger == null)) &amp;&amp; (hasFK == 0)) &amp;&amp; (chngKey == 0)) &amp;&amp; (bReplace == 0))
            {
                flags |= (int)(0x0008);
            }

            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, null, null, null, (ushort)(flags), (int)(iIdxCur));
            if ((pWInfo) == (null))
                goto update_cleanup;
            eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aiCurOnePass));
            bFinishSeek = (int)(sqlite3WhereUsesDeferredSeek(pWInfo));
            if (eOnePass != 1)
            {
                sqlite3MultiWrite(pParse);
                if ((eOnePass) == (2))
                {
                    int iCur = (int)(aiCurOnePass[1]);
                    if ((((iCur) &gt;= (0)) &amp;&amp; (iCur != iDataCur)) &amp;&amp; ((aToOpen[iCur - iBaseCur]) != 0))
                    {
                        eOnePass = (int)(0);
                    }
                }
            }
        }

        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            sqlite3VdbeAddOp2(v, (int)(134), (int)(iDataCur), (int)(regOldRowid));
            if ((eOnePass) == (0))
            {
                aRegIdx[nAllIdx] = (int)(++pParse.nMem);
                sqlite3VdbeAddOp3(v, (int)(127), (int)(iEph), (int)(regRowSet), (int)(regOldRowid));
            }
            else
            {
                if ((addrOpen) != 0)
                    sqlite3VdbeChangeToNoop(v, (int)(addrOpen));
            }
        }
        else
        {
            for (i = (int)(0); (i) &lt; (nPk); i++)
            {
                sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(pPk.aiColumn[i]), (int)(iPk + i));
            }

            if ((eOnePass) != 0)
            {
                if ((addrOpen) != 0)
                    sqlite3VdbeChangeToNoop(v, (int)(addrOpen));
                nKey = (int)(nPk);
                regKey = (int)(iPk);
            }
            else
            {
                sqlite3VdbeAddOp4(v, (int)(96), (int)(iPk), (int)(nPk), (int)(regKey), sqlite3IndexAffinityStr(db, pPk), (int)(nPk));
                sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iEph), (int)(regKey), (int)(iPk), (int)(nPk));
            }
        }
    }

    if ((pUpsert) == (null))
    {
        if (((nChangeFrom) == (0)) &amp;&amp; (eOnePass != 2))
        {
            sqlite3WhereEnd(pWInfo);
        }

        if (isView == 0)
        {
            int addrOnce = (int)(0);
            if (eOnePass != 0)
            {
                if ((aiCurOnePass[0]) &gt;= (0))
                    aToOpen[aiCurOnePass[0] - iBaseCur] = (byte)(0);
                if ((aiCurOnePass[1]) &gt;= (0))
                    aToOpen[aiCurOnePass[1] - iBaseCur] = (byte)(0);
            }

            if (((eOnePass) == (2)) &amp;&amp; ((nIdx - ((aiCurOnePass[1]) &gt;= (0))) &gt; (0)))
            {
                addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
            }

            sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0), (int)(iBaseCur), aToOpen, null, null);
            if ((addrOnce) != 0)
            {
                sqlite3VdbeJumpHereOrPopInst(v, (int)(addrOnce));
            }
        }

        if (eOnePass != 0)
        {
            if ((aiCurOnePass[0] != iDataCur) &amp;&amp; (aiCurOnePass[1] != iDataCur))
            {
                sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelBreak), (int)(regKey), (int)(nKey));
            }

            if (eOnePass != 1)
            {
                labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
            }

            sqlite3VdbeAddOp2(v, (int)(50), (int)(pPk ? regKey : regOldRowid), (int)(labelBreak));
        }
        else if (((pPk) != null) || ((nChangeFrom) != 0))
        {
            labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
            sqlite3VdbeAddOp2(v, (int)(38), (int)(iEph), (int)(labelBreak));
            addrTop = (int)(sqlite3VdbeCurrentAddr(v));
            if ((nChangeFrom) != 0)
            {
                if (isView == 0)
                {
                    if ((pPk) != null)
                    {
                        for (i = (int)(0); (i) &lt; (nPk); i++)
                        {
                            sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(i), (int)(iPk + i));
                        }

                        sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(iPk), (int)(nPk));
                    }
                    else
                    {
                        sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(regOldRowid));
                        sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
                    }
                }
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(133), (int)(iEph), (int)(regKey));
                sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(0));
            }
        }
        else
        {
            sqlite3VdbeAddOp2(v, (int)(38), (int)(iEph), (int)(labelBreak));
            labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
            addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(regOldRowid)));
            sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
        }
    }

    if ((chngRowid) != 0)
    {
        if ((nChangeFrom) == (0))
        {
            sqlite3ExprCode(pParse, pRowidExpr, (int)(regNewRowid));
        }
        else
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(iRowidExpr), (int)(regNewRowid));
        }

        sqlite3VdbeAddOp1(v, (int)(15), (int)(regNewRowid));
    }

    if ((((chngPk) != 0) || ((hasFK) != 0)) || ((pTrigger) != null))
    {
        uint oldmask = (uint)((hasFK) != 0 ? sqlite3FkOldmask(pParse, pTab) : 0);
        oldmask |= (uint)(sqlite3TriggerColmask(pParse, pTrigger, pChanges, (int)(0), (int)(1 | 2), pTab, (int)(onError)));
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            uint colFlags = (uint)(pTab.aCol[i].colFlags);
            k = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + regOld);
            if ((((oldmask) == (0xffffffff)) || (((i) &lt; (32)) &amp;&amp; ((oldmask &amp; (((uint)(1)) &lt;&lt; (i))) != 0))) || ((colFlags &amp; 0x0001) != 0))
            {
                sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
            }
        }

        if (((chngRowid) == (0)) &amp;&amp; ((pPk) == (null)))
        {
            sqlite3VdbeAddOp2(v, (int)(79), (int)(regOldRowid), (int)(regNewRowid));
        }
    }

    newmask = (int)(sqlite3TriggerColmask(pParse, pTrigger, pChanges, (int)(1), (int)(1), pTab, (int)(onError)));
    for (i = (int)(0), k = (int)(regNew); (i) &lt; (pTab.nCol); i++, k++)
    {
        if ((i) == (pTab.iPKey))
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
        }
        else if ((pTab.aCol[i].colFlags &amp; 0x0060) != 0)
        {
            if ((pTab.aCol[i].colFlags &amp; 0x0020) != 0)
                k--;
        }
        else
        {
            j = (int)(aXRef[i]);
            if ((j) &gt;= (0))
            {
                if ((nChangeFrom) != 0)
                {
                    int nOff = (int)((isView) != 0 ? pTab.nCol : nPk);
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(nOff + j), (int)(k));
                }
                else
                {
                    sqlite3ExprCode(pParse, pChanges.a[j].pExpr, (int)(k));
                }
            }
            else if ((((0) == (tmask &amp; 1)) || ((i) &gt; (31))) || ((newmask &amp; (((uint)(1)) &lt;&lt; (i))) != 0))
            {
                sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
                bFinishSeek = (int)(0);
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
            }
        }
    }

    if ((pTab.tabFlags &amp; 0x00000060) != 0)
    {
        sqlite3ComputeGeneratedColumns(pParse, (int)(regNew), pTab);
    }

    if ((tmask &amp; 1) != 0)
    {
        sqlite3TableAffinity(v, pTab, (int)(regNew));
        sqlite3CodeRowTrigger(pParse, pTrigger, (int)(129), pChanges, (int)(1), pTab, (int)(regOldRowid), (int)(onError), (int)(labelContinue));
        if (isView == 0)
        {
            if ((pPk) != null)
            {
                sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(nKey));
            }
            else
            {
                sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
            }

            for (i = (int)(0), k = (int)(regNew); (i) &lt; (pTab.nCol); i++, k++)
            {
                if ((pTab.aCol[i].colFlags &amp; 0x0060) != 0)
                {
                    if ((pTab.aCol[i].colFlags &amp; 0x0020) != 0)
                        k--;
                }
                else if (((aXRef[i]) &lt; (0)) &amp;&amp; (i != pTab.iPKey))
                {
                    sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
                }
            }

            if ((pTab.tabFlags &amp; 0x00000060) != 0)
            {
                sqlite3ComputeGeneratedColumns(pParse, (int)(regNew), pTab);
            }
        }
    }

    if (isView == 0)
    {
        sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, (int)(iDataCur), (int)(iIdxCur), (int)(regNewRowid), (int)(regOldRowid), (byte)(chngKey), (byte)(onError), (int)(labelContinue), &amp;bReplace, aXRef, null);
        if (((bReplace) != 0) || ((chngKey) != 0))
        {
            if ((pPk) != null)
            {
                sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(nKey));
            }
            else
            {
                sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
            }
        }

        if ((hasFK) != 0)
        {
            sqlite3FkCheck(pParse, pTab, (int)(regOldRowid), (int)(0), aXRef, (int)(chngKey));
        }

        sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), aRegIdx, (int)(-1));
        if ((bFinishSeek) != 0)
        {
            sqlite3VdbeAddOp1(v, (int)(142), (int)(iDataCur));
        }

        if (((hasFK) &gt; (1)) || ((chngKey) != 0))
        {
            sqlite3VdbeAddOp2(v, (int)(129), (int)(iDataCur), (int)(0));
        }

        if ((hasFK) != 0)
        {
            sqlite3FkCheck(pParse, pTab, (int)(0), (int)(regNewRowid), aXRef, (int)(chngKey));
        }

        sqlite3CompleteInsertion(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), (int)(regNewRowid), aRegIdx, (int)(0x04 | ((eOnePass) == (2) ? 0x02 : 0)), (int)(0), (int)(0));
        if ((hasFK) != 0)
        {
            sqlite3FkActions(pParse, pTab, pChanges, (int)(regOldRowid), aXRef, (int)(chngKey));
        }
    }

    if ((regRowCount) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(85), (int)(regRowCount), (int)(1));
    }

    sqlite3CodeRowTrigger(pParse, pTrigger, (int)(129), pChanges, (int)(2), pTab, (int)(regOldRowid), (int)(onError), (int)(labelContinue));
    if ((eOnePass) == (1))
    {
    }
    else if ((eOnePass) == (2))
    {
        sqlite3VdbeResolveLabel(v, (int)(labelContinue));
        sqlite3WhereEnd(pWInfo);
    }
    else
    {
        sqlite3VdbeResolveLabel(v, (int)(labelContinue));
        sqlite3VdbeAddOp2(v, (int)(5), (int)(iEph), (int)(addrTop));
    }

    sqlite3VdbeResolveLabel(v, (int)(labelBreak));
    if ((((pParse.nested) == (0)) &amp;&amp; ((pParse.pTriggerTab) == (null))) &amp;&amp; ((pUpsert) == (null)))
    {
        sqlite3AutoincrementEnd(pParse);
    }

    if ((regRowCount) != 0)
    {
        sqlite3CodeChangeCount(v, (int)(regRowCount), "rows updated");
    }

    update_cleanup:
        ; sqlite3AuthContextPop ( sContext ) ; 
    sqlite3DbFree(db, aXRef);
    sqlite3SrcListDelete(db, pTabList);
    sqlite3ExprListDelete(db, pChanges);
    sqlite3ExprDelete(db, pWhere);
    return;
}</function>
  <function>public static int sqlite3UpsertAnalyzeTarget(Parse pParse, SrcList pTabList, Upsert pUpsert)
{
    Table pTab;
    int rc = 0;
    int iCursor = 0;
    Index pIdx;
    ExprList pTarget;
    Expr pTerm;
    NameContext sNC = new NameContext();
    var sCol = new Expr[2]; sCol [ 0 ]  =  new  Expr ( ) ;  sCol [ 1 ]  =  new  Expr ( ) ; 
    int nClause = (int)(0);
    CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    for (; ((pUpsert) != null) &amp;&amp; ((pUpsert.pUpsertTarget) != null); pUpsert = pUpsert.pNextUpsert, nClause++)
    {
        rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsert.pUpsertTarget));
        if ((rc) != 0)
            return (int)(rc);
        rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertTargetWhere));
        if ((rc) != 0)
            return (int)(rc);
        pTab = pTabList.a[0].pTab;
        pTarget = pUpsert.pUpsertTarget;
        iCursor = (int)(pTabList.a[0].iCursor);
        if ((((((pTab).tabFlags &amp; 0x00000080) == (0)) &amp;&amp; ((pTarget.nExpr) == (1))) &amp;&amp; (((pTerm = pTarget.a[0].pExpr).op) == (167))) &amp;&amp; ((pTerm.iColumn) == (-1)))
        {
            continue;
        }

        CRuntime.memset(sCol, (int)(0), (ulong)(2 * sizeof(Expr)));
        sCol[0].op = (byte)(113);
        sCol[0].pLeft = sCol[1];
        sCol[1].op = (byte)(167);
        sCol[1].iTable = (int)(pTabList.a[0].iCursor);
        for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            int ii = 0;
            int jj = 0;
            int nn = 0;
            if (!((pIdx).onError != 0))
                continue;
            if (pTarget.nExpr != pIdx.nKeyCol)
                continue;
            if ((pIdx.pPartIdxWhere) != null)
            {
                if ((pUpsert.pUpsertTargetWhere) == (null))
                    continue;
                if (sqlite3ExprCompare(pParse, pUpsert.pUpsertTargetWhere, pIdx.pPartIdxWhere, (int)(iCursor)) != 0)
                {
                    continue;
                }
            }

            nn = (int)(pIdx.nKeyCol);
            for (ii = (int)(0); (ii) &lt; (nn); ii++)
            {
                Expr pExpr;
                sCol[0].u.zToken = pIdx.azColl[ii];
                if ((pIdx.aiColumn[ii]) == (-2))
                {
                    pExpr = pIdx.aColExpr.a[ii].pExpr;
                    if (pExpr.op != 113)
                    {
                        sCol[0].pLeft = pExpr;
                        pExpr = sCol[0];
                    }
                }
                else
                {
                    sCol[0].pLeft = sCol[1];
                    sCol[1].iColumn = (short)(pIdx.aiColumn[ii]);
                    pExpr = sCol[0];
                }

                for (jj = (int)(0); (jj) &lt; (nn); jj++)
                {
                    if ((sqlite3ExprCompare(pParse, pTarget.a[jj].pExpr, pExpr, (int)(iCursor))) &lt; (2))
                    {
                        break;
                    }
                }

                if ((jj) &gt;= (nn))
                {
                    break;
                }
            }

            if ((ii) &lt; (nn))
            {
                continue;
            }

            pUpsert.pUpsertIdx = pIdx;
            break;
        }

        if ((pUpsert.pUpsertIdx) == (null))
        {
            sbyte* zWhich = stackalloc sbyte[16];
            if (((nClause) == (0)) &amp;&amp; ((pUpsert.pNextUpsert) == (null)))
            {
                zWhich[0] = (sbyte)(0);
            }
            else
            {
                sqlite3_snprintf((int)(16 * sizeof(sbyte)), zWhich, "%r ", (int)(nClause + 1));
            }

            sqlite3ErrorMsg(pParse, "%sON CONFLICT clause does not match any PRIMARY KEY or UNIQUE constraint", zWhich);
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3UpsertDelete(sqlite3 db, Upsert p)
{
    if ((p) != null)
        upsertDelete(db, p);
}</function>
  <function>public static void sqlite3UpsertDoUpdate(Parse pParse, Upsert pUpsert, Table pTab, Index pIdx, int iCur)
{
    Vdbe v = pParse.pVdbe;
    sqlite3 db = pParse.db;
    SrcList pSrc;
    int iDataCur = 0;
    int i = 0;
    Upsert pTop = pUpsert;
    iDataCur = (int)(pUpsert.iDataCur);
    pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);
    if (((pIdx) != null) &amp;&amp; (iCur != iDataCur))
    {
        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            int regRowid = (int)(sqlite3GetTempReg(pParse));
            sqlite3VdbeAddOp2(v, (int)(141), (int)(iCur), (int)(regRowid));
            sqlite3VdbeAddOp3(v, (int)(32), (int)(iDataCur), (int)(0), (int)(regRowid));
            sqlite3ReleaseTempReg(pParse, (int)(regRowid));
        }
        else
        {
            Index pPk = sqlite3PrimaryKeyIndex(pTab);
            int nPk = (int)(pPk.nKeyCol);
            int iPk = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(nPk);
            for (i = (int)(0); (i) &lt; (nPk); i++)
            {
                int k = 0;
                k = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[i])));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(k), (int)(iPk + i));
            }

            i = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iDataCur), (int)(0), (int)(iPk), (int)(nPk)));
            sqlite3VdbeAddOp4(v, (int)(70), (int)(11), (int)(2), (int)(0), "corrupt database", (int)(-1));
            sqlite3MayAbort(pParse);
            sqlite3VdbeJumpHere(v, (int)(i));
        }
    }

    pSrc = sqlite3SrcListDup(db, pTop.pUpsertSrc, (int)(0));
    for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
    {
        if ((pTab.aCol[i].affinity) == (0x45))
        {
            sqlite3VdbeAddOp1(v, (int)(86), (int)(pTop.regData + i));
        }
    }

    sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db, pUpsert.pUpsertSet, (int)(0)), sqlite3ExprDup(db, pUpsert.pUpsertWhere, (int)(0)), (int)(2), null, null, pUpsert);
}</function>
  <function>public static Upsert sqlite3UpsertDup(sqlite3 db, Upsert p)
{
    if ((p) == (null))
        return null;
    return sqlite3UpsertNew(db, sqlite3ExprListDup(db, p.pUpsertTarget, (int)(0)), sqlite3ExprDup(db, p.pUpsertTargetWhere, (int)(0)), sqlite3ExprListDup(db, p.pUpsertSet, (int)(0)), sqlite3ExprDup(db, p.pUpsertWhere, (int)(0)), sqlite3UpsertDup(db, p.pNextUpsert));
}</function>
  <function>public static Upsert sqlite3UpsertNew(sqlite3 db, ExprList pTarget, Expr pTargetWhere, ExprList pSet, Expr pWhere, Upsert pNext)
{
    Upsert pNew;
    pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Upsert)));
    if ((pNew) == (null))
    {
        sqlite3ExprListDelete(db, pTarget);
        sqlite3ExprDelete(db, pTargetWhere);
        sqlite3ExprListDelete(db, pSet);
        sqlite3ExprDelete(db, pWhere);
        sqlite3UpsertDelete(db, pNext);
        return null;
    }
    else
    {
        pNew.pUpsertTarget = pTarget;
        pNew.pUpsertTargetWhere = pTargetWhere;
        pNew.pUpsertSet = pSet;
        pNew.pUpsertWhere = pWhere;
        pNew.isDoUpdate = (byte)(pSet != null);
        pNew.pNextUpsert = pNext;
    }

    return pNew;
}</function>
  <function>public static int sqlite3UpsertNextIsIPK(Upsert pUpsert)
{
    Upsert pNext;
    if (((pUpsert) == (null)))
        return (int)(0);
    pNext = pUpsert.pNextUpsert;
    if ((pNext) == (null))
        return (int)(1);
    if ((pNext.pUpsertTarget) == (null))
        return (int)(1);
    if ((pNext.pUpsertIdx) == (null))
        return (int)(1);
    return (int)(0);
}</function>
  <function>public static Upsert sqlite3UpsertOfIndex(Upsert pUpsert, Index pIdx)
{
    while ((((pUpsert) != null) &amp;&amp; (pUpsert.pUpsertTarget != null)) &amp;&amp; (pUpsert.pUpsertIdx != pIdx))
    {
        pUpsert = pUpsert.pNextUpsert;
    }

    return pUpsert;
}</function>
  <function>public static int sqlite3Utf16ByteLen(void* zIn, int nChar)
{
    int c = 0;
    byte* z = zIn;
    int n = (int)(0);
    if ((2) == (2))
        z++;
    while ((n) &lt; (nChar))
    {
        c = (int)(z[0]);
        z += 2;
        if (((((c) &gt;= (0xd8)) &amp;&amp; ((c) &lt; (0xdc))) &amp;&amp; ((z[0]) &gt;= (0xdc))) &amp;&amp; ((z[0]) &lt; (0xe0)))
            z += 2;
        n++;
    }

    return (int)((int)(z - (byte*)(zIn)) - ((2) == (2)));
}</function>
  <function>public static sbyte* sqlite3Utf16to8(sqlite3 db, void* z, int nByte, byte enc)
{
    sqlite3_value m = new sqlite3_value();
    CRuntime.memset(m, (int)(0), (ulong)(sizeof(sqlite3_value)));
    m.db = db;
    sqlite3VdbeMemSetStr(m, z, (long)(nByte), (byte)(enc), null);
    sqlite3VdbeChangeEncoding(m, (int)(1));
    if ((db.mallocFailed) != 0)
    {
        sqlite3VdbeMemRelease(m);
        m.z = null;
    }

    return m.z;
}</function>
  <function>public static int sqlite3Utf8CharLen(sbyte* zIn, int nByte)
{
    int r = (int)(0);
    byte* z = (byte*)(zIn);
    byte* zTerm;
    if ((nByte) &gt;= (0))
    {
        zTerm = &amp;z[nByte];
    }
    else
    {
        zTerm = (byte*)(-1);
    }

    while ((*z != 0) &amp;&amp; ((z) &lt; (zTerm)))
    {
        {
            if ((*(z++)) &gt;= (0xc0))
            {
                while ((*z &amp; 0xc0) == (0x80))
                {
                    z++;
                }
            }
        }

        r++;
    }

    return (int)(r);
}</function>
  <function>public static uint sqlite3Utf8Read(byte** pz)
{
    uint c = 0;
    c = (uint)(*((*pz)++));
    if ((c) &gt;= (0xc0))
    {
        c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
        while ((*(*pz) &amp; 0xc0) == (0x80))
        {
            c = (uint)((c &lt;&lt; 6) + (0x3f &amp; *((*pz)++)));
        }

        if ((((c) &lt; (0x80)) || ((c &amp; 0xFFFFF800) == (0xD800))) || ((c &amp; 0xFFFFFFFE) == (0xFFFE)))
        {
            c = (uint)(0xFFFD);
        }
    }

    return (uint)(c);
}</function>
  <function>public static void sqlite3Vacuum(Parse pParse, Token* pNm, Expr pInto)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    int iDb = (int)(0);
    if ((v) == (null))
        goto build_vacuum_end;
    if ((pParse.nErr) != 0)
        goto build_vacuum_end;
    if ((pNm) != null)
    {
        iDb = (int)(sqlite3TwoPartName(pParse, pNm, pNm, &amp;pNm));
        if ((iDb) &lt; (0))
            goto build_vacuum_end;
    }

    if (iDb != 1)
    {
        int iIntoReg = (int)(0);
        if (((pInto) != null) &amp;&amp; ((sqlite3ResolveSelfReference(pParse, null, (int)(0), pInto, null)) == (0)))
        {
            iIntoReg = (int)(++pParse.nMem);
            sqlite3ExprCode(pParse, pInto, (int)(iIntoReg));
        }

        sqlite3VdbeAddOp2(v, (int)(8), (int)(iDb), (int)(iIntoReg));
        sqlite3VdbeUsesBtree(v, (int)(iDb));
    }

    build_vacuum_end:
        ; sqlite3ExprDelete ( pParse . db ,  pInto ) ; 
    return;
}</function>
  <function>public static void sqlite3ValueApplyAffinity(sqlite3_value pVal, byte affinity, byte enc)
{
    applyAffinity(pVal, (sbyte)(affinity), (byte)(enc));
}</function>
  <function>public static int sqlite3ValueBytes(sqlite3_value pVal, byte enc)
{
    sqlite3_value p = pVal;
    if (((p.flags &amp; 0x0002) != 0) &amp;&amp; ((pVal.enc) == (enc)))
    {
        return (int)(p.n);
    }

    if ((p.flags &amp; 0x0010) != 0)
    {
        if ((p.flags &amp; 0x4000) != 0)
        {
            return (int)(p.n + p.u.nZero);
        }
        else
        {
            return (int)(p.n);
        }
    }

    if ((p.flags &amp; 0x0001) != 0)
        return (int)(0);
    return (int)(valueBytes(pVal, (byte)(enc)));
}</function>
  <function>public static void sqlite3ValueFree(sqlite3_value v)
{
    if (v == null)
        return;
    sqlite3VdbeMemRelease(v);
    sqlite3DbFreeNN((v).db, v);
}</function>
  <function>public static int sqlite3ValueFromExpr(sqlite3 db, Expr pExpr, byte enc, byte affinity, sqlite3_value ppVal)
{
    return (int)(pExpr ? valueFromExpr(db, pExpr, (byte)(enc), (byte)(affinity), ppVal, null) : 0);
}</function>
  <function>public static sqlite3_value sqlite3ValueNew(sqlite3 db)
{
    sqlite3_value p = sqlite3DbMallocZero(db, (ulong)(sizeof(sqlite3_value)));
    if ((p) != null)
    {
        p.flags = (ushort)(0x0001);
        p.db = db;
    }

    return p;
}</function>
  <function>public static void sqlite3ValueSetNull(sqlite3_value p)
{
    sqlite3VdbeMemSetNull(p);
}</function>
  <function>public static void sqlite3ValueSetStr(sqlite3_value v, int n, void* z, byte enc, delegate17 xDel)
{
    if ((v) != null)
        sqlite3VdbeMemSetStr(v, z, (long)(n), (byte)(enc), xDel);
}</function>
  <function>public static void* sqlite3ValueText(sqlite3_value pVal, byte enc)
{
    if (pVal == null)
        return null;
    if (((pVal.flags &amp; (0x0002 | 0x0200)) == (0x0002 | 0x0200)) &amp;&amp; ((pVal.enc) == (enc)))
    {
        return pVal.z;
    }

    if ((pVal.flags &amp; 0x0001) != 0)
    {
        return null;
    }

    return valueToText(pVal, (byte)(enc));
}</function>
  <function>public static int sqlite3VarintLen(ulong v)
{
    int i = 0;
    for (i = (int)(1); (v &gt;&gt;= 7) != 0; i++)
    {
    }

    return (int)(i);
}</function>
  <function>public static int sqlite3VdbeAddFunctionCall(Parse pParse, int p1, int p2, int p3, int nArg, FuncDef pFunc, int eCallCtx)
{
    Vdbe v = pParse.pVdbe;
    int nByte = 0;
    int addr = 0;
    sqlite3_context pCtx;
    nByte = (int)(sizeof(sqlite3_context) + (nArg - 1) * sizeof(sqlite3_value));
    pCtx = sqlite3DbMallocRawNN(pParse.db, (ulong)(nByte));
    if ((pCtx) == (null))
    {
        freeEphemeralFunction(pParse.db, pFunc);
        return (int)(0);
    }

    pCtx.pOut = null;
    pCtx.pFunc = pFunc;
    pCtx.pVdbe = null;
    pCtx.isError = (int)(0);
    pCtx.argc = (byte)(nArg);
    pCtx.iOp = (int)(sqlite3VdbeCurrentAddr(v));
    addr = (int)(sqlite3VdbeAddOp4(v, (int)((eCallCtx) != 0 ? 65 : 66), (int)(p1), (int)(p2), (int)(p3), (sbyte*)(pCtx), (int)(-16)));
    sqlite3VdbeChangeP5(v, (ushort)(eCallCtx &amp; 0x00002e));
    return (int)(addr);
}</function>
  <function>public static int sqlite3VdbeAddOp0(Vdbe p, int op)
{
    return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(0), (int)(0), (int)(0)));
}</function>
  <function>public static int sqlite3VdbeAddOp1(Vdbe p, int op, int p1)
{
    return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(0), (int)(0)));
}</function>
  <function>public static int sqlite3VdbeAddOp2(Vdbe p, int op, int p1, int p2)
{
    return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(0)));
}</function>
  <function>public static int sqlite3VdbeAddOp3(Vdbe p, int op, int p1, int p2, int p3)
{
    int i = 0;
    VdbeOp* pOp;
    i = (int)(p.nOp);
    if ((p.nOpAlloc) &lt;= (i))
    {
        return (int)(growOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
    }

    p.nOp++;
    pOp = &amp;p.aOp[i];
    pOp-&gt;opcode = ((byte)(op));
    pOp-&gt;p5 = (ushort)(0);
    pOp-&gt;p1 = (int)(p1);
    pOp-&gt;p2 = (int)(p2);
    pOp-&gt;p3 = (int)(p3);
    pOp-&gt;p4.p = null;
    pOp-&gt;p4type = (sbyte)(0);
    return (int)(i);
}</function>
  <function>public static int sqlite3VdbeAddOp4(Vdbe p, int op, int p1, int p2, int p3, sbyte* zP4, int p4type)
{
    int addr = (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
    sqlite3VdbeChangeP4(p, (int)(addr), zP4, (int)(p4type));
    return (int)(addr);
}</function>
  <function>public static int sqlite3VdbeAddOp4Dup8(Vdbe p, int op, int p1, int p2, int p3, byte* zP4, int p4type)
{
    sbyte* p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), (ulong)(8));
    if ((p4copy) != null)
        CRuntime.memcpy(p4copy, zP4, (ulong)(8));
    return (int)(sqlite3VdbeAddOp4(p, (int)(op), (int)(p1), (int)(p2), (int)(p3), p4copy, (int)(p4type)));
}</function>
  <function>public static int sqlite3VdbeAddOp4Int(Vdbe p, int op, int p1, int p2, int p3, int p4)
{
    int addr = (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
    if ((p.db.mallocFailed) == (0))
    {
        VdbeOp* pOp = &amp;p.aOp[addr];
        pOp-&gt;p4type = (sbyte)(-3);
        pOp-&gt;p4.i = (int)(p4);
    }

    return (int)(addr);
}</function>
  <function>public static VdbeOp* sqlite3VdbeAddOpList(Vdbe p, int nOp, VdbeOpList* aOp, int iLineno)
{
    int i = 0;
    VdbeOp* pOut; VdbeOp * pFirst ; 
    if (((p.nOp + nOp) &gt; (p.nOpAlloc)) &amp;&amp; ((growOpArray(p, (int)(nOp))) != 0))
    {
        return null;
    }

    pFirst = pOut = &amp;p.aOp[p.nOp];
    for (i = (int)(0); (i) &lt; (nOp); i++, aOp++, pOut++)
    {
        pOut-&gt;opcode = (byte)(aOp-&gt;opcode);
        pOut-&gt;p1 = (int)(aOp-&gt;p1);
        pOut-&gt;p2 = (int)(aOp-&gt;p2);
        if (((sqlite3OpcodeProperty[aOp-&gt;opcode] &amp; 0x01) != 0) &amp;&amp; ((aOp-&gt;p2) &gt; (0)))
        {
            pOut-&gt;p2 += (int)(p.nOp);
        }

        pOut-&gt;p3 = (int)(aOp-&gt;p3);
        pOut-&gt;p4type = (sbyte)(0);
        pOut-&gt;p4.p = null;
        pOut-&gt;p5 = (ushort)(0);
        (void)(iLineno);
    }

    p.nOp += (int)(nOp);
    return pFirst;
}</function>
  <function>public static void sqlite3VdbeAddParseSchemaOp(Vdbe p, int iDb, sbyte* zWhere, ushort p5)
{
    int j = 0;
    sqlite3VdbeAddOp4(p, (int)(148), (int)(iDb), (int)(0), (int)(0), zWhere, (int)(-7));
    sqlite3VdbeChangeP5(p, (ushort)(p5));
    for (j = (int)(0); (j) &lt; (p.db.nDb); j++)
    {
        sqlite3VdbeUsesBtree(p, (int)(j));
    }

    sqlite3MayAbort(p.pParse);
}</function>
  <function>public static UnpackedRecord sqlite3VdbeAllocUnpackedRecord(KeyInfo pKeyInfo)
{
    UnpackedRecord p;
    int nByte = 0;
    nByte = (int)((((sizeof(UnpackedRecord)) + 7) &amp; ~7) + sizeof(sqlite3_value) * (pKeyInfo.nKeyField + 1));
    p = (UnpackedRecord)(sqlite3DbMallocRaw(pKeyInfo.db, (ulong)(nByte)));
    if (p == null)
        return null;
    p.aMem = (sqlite3_value)(&amp;((sbyte*)(p))[(((sizeof(UnpackedRecord)) + 7) &amp; ~7)]);
    p.pKeyInfo = pKeyInfo;
    p.nField = (ushort)(pKeyInfo.nKeyField + 1);
    return p;
}</function>
  <function>public static void sqlite3VdbeAppendP4(Vdbe p, void* pP4, int n)
{
    VdbeOp* pOp;
    if ((p.db.mallocFailed) != 0)
    {
        freeP4(p.db, (int)(n), pP4);
    }
    else
    {
        pOp = &amp;p.aOp[p.nOp - 1];
        pOp-&gt;p4type = (sbyte)(n);
        pOp-&gt;p4.p = pP4;
    }
}</function>
  <function>public static int sqlite3VdbeBooleanValue(sqlite3_value pMem, int ifNull)
{
    if ((pMem.flags &amp; (0x0004 | 0x0020)) != 0)
        return (int)(pMem.u.i != 0);
    if ((pMem.flags &amp; 0x0001) != 0)
        return (int)(ifNull);
    return (int)(sqlite3VdbeRealValue(pMem) != 0.0);
}</function>
  <function>public static int sqlite3VdbeChangeEncoding(sqlite3_value pMem, int desiredEnc)
{
    int rc = 0;
    if (((pMem.flags &amp; 0x0002) == 0) || ((pMem.enc) == (desiredEnc)))
    {
        return (int)(0);
    }

    rc = (int)(sqlite3VdbeMemTranslate(pMem, (byte)(desiredEnc)));
    return (int)(rc);
}</function>
  <function>public static void sqlite3VdbeChangeOpcode(Vdbe p, int addr, byte iNewOpcode)
{
    sqlite3VdbeGetOp(p, (int)(addr))-&gt;opcode = (byte)(iNewOpcode);
}</function>
  <function>public static void sqlite3VdbeChangeP1(Vdbe p, int addr, int val)
{
    sqlite3VdbeGetOp(p, (int)(addr))-&gt;p1 = (int)(val);
}</function>
  <function>public static void sqlite3VdbeChangeP2(Vdbe p, int addr, int val)
{
    sqlite3VdbeGetOp(p, (int)(addr))-&gt;p2 = (int)(val);
}</function>
  <function>public static void sqlite3VdbeChangeP3(Vdbe p, int addr, int val)
{
    sqlite3VdbeGetOp(p, (int)(addr))-&gt;p3 = (int)(val);
}</function>
  <function>public static void sqlite3VdbeChangeP4(Vdbe p, int addr, sbyte* zP4, int n)
{
    VdbeOp* pOp;
    sqlite3 db;
    db = p.db;
    if ((db.mallocFailed) != 0)
    {
        if (n != (-12))
            freeP4(db, (int)(n), (void*)(*&amp;zP4));
        return;
    }

    if ((addr) &lt; (0))
    {
        addr = (int)(p.nOp - 1);
    }

    pOp = &amp;p.aOp[addr];
    if (((n) &gt;= (0)) || ((pOp-&gt;p4type) != 0))
    {
        vdbeChangeP4Full(p, pOp, zP4, (int)(n));
        return;
    }

    if ((n) == (-3))
    {
        pOp-&gt;p4.i = ((int)((long)(zP4)));
        pOp-&gt;p4type = (sbyte)(-3);
    }
    else if (zP4 != null)
    {
        pOp-&gt;p4.p = (void*)(zP4);
        pOp-&gt;p4type = ((sbyte)(n));
        if ((n) == (-12))
            sqlite3VtabLock((VTable)(zP4));
    }
}</function>
  <function>public static void sqlite3VdbeChangeP5(Vdbe p, ushort p5)
{
    if ((p.nOp) &gt; (0))
        p.aOp[p.nOp - 1].p5 = (ushort)(p5);
}</function>
  <function>public static int sqlite3VdbeChangeToNoop(Vdbe p, int addr)
{
    VdbeOp* pOp;
    if ((p.db.mallocFailed) != 0)
        return (int)(0);
    pOp = &amp;p.aOp[addr];
    freeP4(p.db, (int)(pOp-&gt;p4type), pOp-&gt;p4.p);
    pOp-&gt;p4type = (sbyte)(0);
    pOp-&gt;p4.z = null;
    pOp-&gt;opcode = (byte)(182);
    return (int)(1);
}</function>
  <function>public static int sqlite3VdbeCheckFk(Vdbe p, int deferred)
{
    sqlite3 db = p.db;
    if ((((deferred) != 0) &amp;&amp; ((db.nDeferredCons + db.nDeferredImmCons) &gt; (0))) || ((deferred == 0) &amp;&amp; ((p.nFkConstraint) &gt; (0))))
    {
        p.rc = (int)(19 | (3 &lt;&lt; 8));
        p.errorAction = (byte)(2);
        sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3VdbeClearObject(sqlite3 db, Vdbe p)
{
    SubProgram* pSub; SubProgram * pNext ; 
    releaseMemArray(p.aColName, (int)(p.nResColumn * 2));
    for (pSub = p.pProgram; pSub; pSub = pNext)
    {
        pNext = pSub-&gt;pNext;
        vdbeFreeOpArray(db, pSub-&gt;aOp, (int)(pSub-&gt;nOp));
        sqlite3DbFree(db, pSub);
    }

    if (p.iVdbeMagic != 0x16bceaa5)
    {
        releaseMemArray(p.aVar, (int)(p.nVar));
        sqlite3DbFree(db, p.pVList);
        sqlite3DbFree(db, p.pFree);
    }

    vdbeFreeOpArray(db, p.aOp, (int)(p.nOp));
    sqlite3DbFree(db, p.aColName);
    sqlite3DbFree(db, p.zSql);
}</function>
  <function>public static int sqlite3VdbeCloseStatement(Vdbe p, int eOp)
{
    if (((p.db.nStatement) != 0) &amp;&amp; ((p.iStatement) != 0))
    {
        return (int)(vdbeCloseStatement(p, (int)(eOp)));
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3VdbeCountChanges(Vdbe v)
{
    v.changeCntOn = (uint)(1);
}</function>
  <function>public static Vdbe sqlite3VdbeCreate(Parse pParse)
{
    sqlite3 db = pParse.db;
    Vdbe p;
    p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Vdbe)));
    if ((p) == (null))
        return null;
    CRuntime.memset(&amp;p.aOp, (int)(0), (ulong)(sizeof(Vdbe) - ((ulong)(&amp;((0).aOp)))));
    p.db = db;
    if ((db.pVdbe) != null)
    {
        db.pVdbe.pPrev = p;
    }

    p.pNext = db.pVdbe;
    p.pPrev = null;
    db.pVdbe = p;
    p.iVdbeMagic = (uint)(0x16bceaa5);
    p.pParse = pParse;
    pParse.pVdbe = p;
    sqlite3VdbeAddOp2(p, (int)(64), (int)(0), (int)(1));
    return p;
}</function>
  <function>public static int sqlite3VdbeCurrentAddr(Vdbe p)
{
    return (int)(p.nOp);
}</function>
  <function>public static int sqlite3VdbeCursorMoveto(VdbeCursor pp, uint* piCol)
{
    VdbeCursor p = pp;
    if ((p.deferredMoveto) != 0)
    {
        uint iMap = 0;
        if ((((p.ub.aAltMap) != null) &amp;&amp; ((iMap = (uint)(p.ub.aAltMap[1 + *piCol])) &gt; (0))) &amp;&amp; (p.nullRow == 0))
        {
            pp = p.pAltCursor;
            *piCol = (uint)(iMap - 1);
            return (int)(0);
        }

        return (int)(sqlite3VdbeFinishMoveto(p));
    }

    if ((sqlite3BtreeCursorHasMoved(p.uc.pCursor)) != 0)
    {
        return (int)(handleMovedCursor(p));
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeCursorRestore(VdbeCursor p)
{
    if ((sqlite3BtreeCursorHasMoved(p.uc.pCursor)) != 0)
    {
        return (int)(handleMovedCursor(p));
    }

    return (int)(0);
}</function>
  <function>public static sqlite3 sqlite3VdbeDb(Vdbe v)
{
    return v.db;
}</function>
  <function>public static void sqlite3VdbeDelete(Vdbe p)
{
    sqlite3 db;
    db = p.db;
    sqlite3VdbeClearObject(db, p);
    if ((p.pPrev) != null)
    {
        p.pPrev.pNext = p.pNext;
    }
    else
    {
        db.pVdbe = p.pNext;
    }

    if ((p.pNext) != null)
    {
        p.pNext.pPrev = p.pPrev;
    }

    p.iVdbeMagic = (uint)(0x5606c3c8);
    p.db = null;
    sqlite3DbFreeNN(db, p);
}</function>
  <function>public static void sqlite3VdbeDeleteAuxData(sqlite3 db, AuxData pp, int iOp, int mask)
{
    while ((pp) != null)
    {
        AuxData pAux = pp;
        if (((iOp) &lt; (0)) || ((((pAux.iAuxOp) == (iOp)) &amp;&amp; ((pAux.iAuxArg) &gt;= (0))) &amp;&amp; (((pAux.iAuxArg) &gt; (31)) || ((mask &amp; (((uint)(1)) &lt;&lt; (pAux.iAuxArg))) == 0))))
        {
            if ((pAux.xDeleteAux) != null)
            {
                pAux.xDeleteAux(pAux.pAux);
            }

            pp = pAux.pNextAux;
            sqlite3DbFree(db, pAux);
        }
        else
        {
            pp = pAux.pNextAux;
        }
    }
}</function>
  <function>public static int sqlite3VdbeDeletePriorOpcode(Vdbe p, byte op)
{
    if (((p.nOp) &gt; (0)) &amp;&amp; ((p.aOp[p.nOp - 1].opcode) == (op)))
    {
        return (int)(sqlite3VdbeChangeToNoop(p, (int)(p.nOp - 1)));
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static sbyte* sqlite3VdbeDisplayP4(sqlite3 db, VdbeOp* pOp)
{
    sbyte* zP4 = null;
    sqlite3_str x = new sqlite3_str();
    sqlite3StrAccumInit(x, null, null, (int)(0), (int)(1000000000));
    switch (pOp-&gt;p4type)
    {
        case (-9):
        {
            int j = 0;
            KeyInfo pKeyInfo = pOp-&gt;p4.pKeyInfo;
            sqlite3_str_appendf(x, "k(%d", (int)(pKeyInfo.nKeyField));
            for (j = (int)(0); (j) &lt; (pKeyInfo.nKeyField); j++)
            {
                CollSeq pColl = pKeyInfo.aColl[j];
                sbyte* zColl = pColl ? pColl.zName : "";
                if ((CRuntime.strcmp(zColl, "BINARY")) == (0))
                    zColl = "B";
                sqlite3_str_appendf(x, ",%s%s%s", (pKeyInfo.aSortFlags[j] &amp; 0x01) ? "-" : "", (pKeyInfo.aSortFlags[j] &amp; 0x02) ? "N." : "", zColl);
            }

            sqlite3_str_append(x, ")", (int)(1));
            break;
        }

        case (-2):
        {
            CollSeq pColl = pOp-&gt;p4.pColl;
            sqlite3_str_appendf(x, "%.18s-%s", pColl.zName, sqlite3VdbeDisplayP4_encnames[pColl.enc]);
            break;
        }

        case (-8):
        {
            FuncDef pDef = pOp-&gt;p4.pFunc;
            sqlite3_str_appendf(x, "%s(%d)", pDef.zName, (int)(pDef.nArg));
            break;
        }

        case (-16):
        {
            FuncDef pDef = pOp-&gt;p4.pCtx.pFunc;
            sqlite3_str_appendf(x, "%s(%d)", pDef.zName, (int)(pDef.nArg));
            break;
        }

        case (-14):
        {
            sqlite3_str_appendf(x, "%lld", (long)(*pOp-&gt;p4.pI64));
            break;
        }

        case (-3):
        {
            sqlite3_str_appendf(x, "%d", (int)(pOp-&gt;p4.i));
            break;
        }

        case (-13):
        {
            sqlite3_str_appendf(x, "%.16g", (double)(*pOp-&gt;p4.pReal));
            break;
        }

        case (-11):
        {
            sqlite3_value pMem = pOp-&gt;p4.pMem;
            if ((pMem.flags &amp; 0x0002) != 0)
            {
                zP4 = pMem.z;
            }
            else if ((pMem.flags &amp; (0x0004 | 0x0020)) != 0)
            {
                sqlite3_str_appendf(x, "%lld", (long)(pMem.u.i));
            }
            else if ((pMem.flags &amp; 0x0008) != 0)
            {
                sqlite3_str_appendf(x, "%.16g", (double)(pMem.u.r));
            }
            else if ((pMem.flags &amp; 0x0001) != 0)
            {
                zP4 = "NULL";
            }
            else
            {
                zP4 = "(blob)";
            }

            break;
        }

        case (-12):
        {
            sqlite3_vtab pVtab = pOp-&gt;p4.pVtab.pVtab;
            sqlite3_str_appendf(x, "vtab:%p", pVtab);
            break;
        }

        case (-15):
        {
            uint i = 0;
            uint* ai = pOp-&gt;p4.ai;
            uint n = (uint)(ai[0]);
            for (i = (uint)(1); (i) &lt;= (n); i++)
            {
                sqlite3_str_appendf(x, "%c%u", (int)((i) == (1) ? 91 : 44), (uint)(ai[i]));
            }

            sqlite3_str_append(x, "]", (int)(1));
            break;
        }

        case (-4):
        {
            zP4 = "program";
            break;
        }

        case (-17):
        case (-5):
        {
            break;
        }

        case (-6):
        {
            zP4 = pOp-&gt;p4.pTab.zName;
            break;
        }

        default:
        {
            zP4 = pOp-&gt;p4.z;
        }
    }

    if ((zP4) != null)
        sqlite3_str_appendall(x, zP4);
    if ((x.accError &amp; 7) != 0)
    {
        sqlite3OomFault(db);
    }

    return sqlite3StrAccumFinish(x);
}</function>
  <function>public static void sqlite3VdbeEndCoroutine(Vdbe v, int regYield)
{
    sqlite3VdbeAddOp1(v, (int)(68), (int)(regYield));
    v.pParse.nTempReg = (byte)(0);
    v.pParse.nRangeReg = (int)(0);
}</function>
  <function>public static void sqlite3VdbeEnter(Vdbe p)
{
    int i = 0;
    sqlite3 db;
    Db aDb;
    int nDb = 0;
    if ((p.lockMask) == (0))
        return;
    db = p.db;
    aDb = db.aDb;
    nDb = (int)(db.nDb);
    for (i = (int)(0); (i) &lt; (nDb); i++)
    {
        if (((i != 1) &amp;&amp; (((p.lockMask) &amp; (((uint)(1)) &lt;&lt; (i))) != 0)) &amp;&amp; (aDb[i].pBt != null))
        {
            sqlite3BtreeEnter(aDb[i].pBt);
        }
    }
}</function>
  <function>public static void sqlite3VdbeError(Vdbe p, sbyte* zFormat)
{
    sbyte* ap;
    sqlite3DbFree(p.db, p.zErrMsg);
    (__va_start(&amp;ap, zFormat));
    p.zErrMsg = sqlite3VMPrintf(p.db, zFormat, ap);
    ((void)(ap = null));
}</function>
  <function>public static int sqlite3VdbeExec(Vdbe p)
{
    VdbeOp* aOp = p.aOp;
    VdbeOp* pOp = aOp;
    int rc = (int)(0);
    sqlite3 db = p.db;
    byte resetSchemaOnFault = (byte)(0);
    byte encoding = (byte)((db).enc);
    int iCompare = (int)(0);
    ulong nVmStep = (ulong)(0);
    ulong nProgressLimit = 0;
    sqlite3_value aMem = p.aMem;
    sqlite3_value pIn1 = null;
    sqlite3_value pIn2 = null;
    sqlite3_value pIn3 = null;
    sqlite3_value pOut = null;
    sqlite3VdbeEnter(p);
    if ((db.xProgress) != null)
    {
        uint iPrior = (uint)(p.aCounter[4]);
        nProgressLimit = (ulong)(db.nProgressOps - (iPrior % db.nProgressOps));
    }
    else
    {
        nProgressLimit = (ulong)(0xffffffff | (((ulong)(0xffffffff)) &lt;&lt; 32));
    }

    if ((p.rc) == (7))
    {
        goto no_mem;
    }

    p.rc = (int)(0);
    p.iCurrentTime = (long)(0);
    p.pResultSet = null;
    db.busyHandler.nBusy = (int)(0);
    if ((0) != 0)
        goto abort_due_to_interrupt;
    for (pOp = &amp;aOp[p.pc]; 1; pOp++)
    {
        nVmStep++;
        switch (pOp-&gt;opcode)
        {
            case 11:
            {
                jump_to_p2_and_check_for_interrupt:
                    ;
                pOp = &amp;aOp[pOp-&gt;p2 - 1];
                check_for_interrupt:
                    ;
                if ((0) != 0)
                    goto abort_due_to_interrupt;
                while (((nVmStep) &gt;= (nProgressLimit)) &amp;&amp; (db.xProgress != null))
                {
                    nProgressLimit += (ulong)(db.nProgressOps);
                    if ((db.xProgress(db.pProgressArg)) != 0)
                    {
                        nProgressLimit = (ulong)(0xffffffff | (((ulong)(0xffffffff)) &lt;&lt; 32));
                        rc = (int)(9);
                        goto abort_due_to_error;
                    }
                }

                break;
            }

            case 12:
            {
                pIn1 = aMem[pOp-&gt;p1];
                pIn1.flags = (ushort)(0x0004);
                pIn1.u.i = (long)((int)(pOp - aOp));
                jump_to_p2:
                    ;
                pOp = &amp;aOp[pOp-&gt;p2 - 1];
                break;
            }

            case 67:
            {
                pIn1 = aMem[pOp-&gt;p1];
                pOp = &amp;aOp[pIn1.u.i];
                pIn1.flags = (ushort)(0x0080);
                break;
            }

            case 13:
            {
                pOut = aMem[pOp-&gt;p1];
                pOut.u.i = (long)(pOp-&gt;p3 - 1);
                pOut.flags = (ushort)(0x0004);
                if ((pOp-&gt;p2) != 0)
                    goto jump_to_p2;
                break;
            }

            case 68:
            {
                VdbeOp* pCaller;
                pIn1 = aMem[pOp-&gt;p1];
                pCaller = &amp;aOp[pIn1.u.i];
                pOp = &amp;aOp[pCaller-&gt;p2 - 1];
                pIn1.flags = (ushort)(0x0080);
                break;
            }

            case 14:
            {
                int pcDest = 0;
                pIn1 = aMem[pOp-&gt;p1];
                pIn1.flags = (ushort)(0x0004);
                pcDest = ((int)(pIn1.u.i));
                pIn1.u.i = (long)((int)(pOp - aOp));
                pOp = &amp;aOp[pcDest];
                break;
            }

            case 69:
            {
                pIn3 = aMem[pOp-&gt;p3];
                if ((pIn3.flags &amp; 0x0001) == (0))
                    break;
            }

            case 70:
            {
                VdbeFrame pFrame;
                int pcx = 0;
                pcx = ((int)(pOp - aOp));
                if (((pOp-&gt;p1) == (0)) &amp;&amp; ((p.pFrame) != null))
                {
                    pFrame = p.pFrame;
                    p.pFrame = pFrame.pParent;
                    p.nFrame--;
                    sqlite3VdbeSetChanges(db, (long)(p.nChange));
                    pcx = (int)(sqlite3VdbeFrameRestore(pFrame));
                    if ((pOp-&gt;p2) == (4))
                    {
                        pcx = (int)(p.aOp[pcx].p2 - 1);
                    }

                    aOp = p.aOp;
                    aMem = p.aMem;
                    pOp = &amp;aOp[pcx];
                    break;
                }

                p.rc = (int)(pOp-&gt;p1);
                p.errorAction = ((byte)(pOp-&gt;p2));
                p.pc = (int)(pcx);
                if ((p.rc) != 0)
                {
                    if ((pOp-&gt;p5) != 0)
                    {
                        sqlite3VdbeError(p, "%s constraint failed", sqlite3VdbeExec_azType[pOp-&gt;p5 - 1]);
                        if ((pOp-&gt;p4.z) != null)
                        {
                            p.zErrMsg = sqlite3MPrintf(db, "%z: %s", p.zErrMsg, pOp-&gt;p4.z);
                        }
                    }
                    else
                    {
                        sqlite3VdbeError(p, "%s", pOp-&gt;p4.z);
                    }

                    sqlite3_log((int)(pOp-&gt;p1), "abort at %d in [%s]: %s", (int)(pcx), p.zSql, p.zErrMsg);
                }

                rc = (int)(sqlite3VdbeHalt(p));
                if ((rc) == (5))
                {
                    p.rc = (int)(5);
                }
                else
                {
                    rc = (int)((p.rc) != 0 ? 1 : 101);
                }

                goto vdbe_return;
            }

            case 71:
            {
                pOut = out2Prerelease(p, pOp);
                pOut.u.i = (long)(pOp-&gt;p1);
                break;
            }

            case 72:
            {
                pOut = out2Prerelease(p, pOp);
                pOut.u.i = (long)(*pOp-&gt;p4.pI64);
                break;
            }

            case 153:
            {
                pOut = out2Prerelease(p, pOp);
                pOut.flags = (ushort)(0x0008);
                pOut.u.r = (double)(*pOp-&gt;p4.pReal);
                break;
            }

            case 117:
            {
                pOut = out2Prerelease(p, pOp);
                pOp-&gt;p1 = (int)(sqlite3Strlen30(pOp-&gt;p4.z));
                if (encoding != 1)
                {
                    rc = (int)(sqlite3VdbeMemSetStr(pOut, pOp-&gt;p4.z, (long)(-1), (byte)(1), null));
                    if ((rc) != 0)
                        goto too_big;
                    if (0 != sqlite3VdbeChangeEncoding(pOut, (int)(encoding)))
                        goto no_mem;
                    pOut.szMalloc = (int)(0);
                    pOut.flags |= (ushort)(0x0800);
                    if ((pOp-&gt;p4type) == (-7))
                    {
                        sqlite3DbFree(db, pOp-&gt;p4.z);
                    }

                    pOp-&gt;p4type = (sbyte)(-7);
                    pOp-&gt;p4.z = pOut.z;
                    pOp-&gt;p1 = (int)(pOut.n);
                }

                if ((pOp-&gt;p1) &gt; (db.aLimit[0]))
                {
                    goto too_big;
                }

                pOp-&gt;opcode = (byte)(73);
            }

            case 73:
            {
                pOut = out2Prerelease(p, pOp);
                pOut.flags = (ushort)(0x0002 | 0x0800 | 0x0200);
                pOut.z = pOp-&gt;p4.z;
                pOut.n = (int)(pOp-&gt;p1);
                pOut.enc = (byte)(encoding);
                if ((pOp-&gt;p3) &gt; (0))
                {
                    pIn3 = aMem[pOp-&gt;p3];
                    if ((pIn3.u.i) == (pOp-&gt;p5))
                        pOut.flags = (ushort)(0x0010 | 0x0800 | 0x0200);
                }

                break;
            }

            case 74:
            {
                int cnt = 0;
                ushort nullFlag = 0;
                pOut = out2Prerelease(p, pOp);
                cnt = (int)(pOp-&gt;p3 - pOp-&gt;p2);
                pOut.flags = (ushort)(nullFlag = (ushort)((pOp-&gt;p1) != 0 ? (0x0001 | 0x0100) : 0x0001));
                pOut.n = (int)(0);
                while ((cnt) &gt; (0))
                {
                    pOut++;
                    sqlite3VdbeMemSetNull(pOut);
                    pOut.flags = (ushort)(nullFlag);
                    pOut.n = (int)(0);
                    cnt--;
                }

                break;
            }

            case 75:
            {
                pOut = aMem[pOp-&gt;p1];
                pOut.flags = (ushort)((pOut.flags &amp; ~(0x0080 | 0x003f)) | 0x0001);
                break;
            }

            case 76:
            {
                pOut = out2Prerelease(p, pOp);
                if ((pOp-&gt;p4.z) == (null))
                {
                    sqlite3VdbeMemSetZeroBlob(pOut, (int)(pOp-&gt;p1));
                    if ((sqlite3VdbeMemExpandBlob(pOut)) != 0)
                        goto no_mem;
                }
                else
                {
                    sqlite3VdbeMemSetStr(pOut, pOp-&gt;p4.z, (long)(pOp-&gt;p1), (byte)(0), null);
                }

                pOut.enc = (byte)(encoding);
                break;
            }

            case 77:
            {
                sqlite3_value pVar;
                pVar = p.aVar[pOp-&gt;p1 - 1];
                if ((sqlite3VdbeMemTooBig(pVar)) != 0)
                {
                    goto too_big;
                }

                pOut = aMem[pOp-&gt;p2];
                if ((((pOut).flags &amp; (0x2000 | 0x0400)) != 0))
                    sqlite3VdbeMemSetNull(pOut);
                CRuntime.memcpy(pOut, pVar, ((ulong)(&amp;((0).zMalloc))));
                pOut.flags &amp;= (ushort)(~(0x0400 | 0x1000));
                pOut.flags |= (ushort)(0x0800 | 0x0040);
                break;
            }

            case 78:
            {
                int n = 0;
                int p1 = 0;
                int p2 = 0;
                n = (int)(pOp-&gt;p3);
                p1 = (int)(pOp-&gt;p1);
                p2 = (int)(pOp-&gt;p2);
                pIn1 = aMem[p1];
                pOut = aMem[p2];
                do
                {
                    sqlite3VdbeMemMove(pOut, pIn1);
                    if ((((pOut).flags &amp; 0x1000) != 0) &amp;&amp; ((sqlite3VdbeMemMakeWriteable(pOut)) != 0))
                    {
                        goto no_mem;
                    }

                    pIn1++;
                    pOut++;
                }
                while ((--n) != 0);
                break;
            }

            case 79:
            {
                int n = 0;
                n = (int)(pOp-&gt;p3);
                pIn1 = aMem[pOp-&gt;p1];
                pOut = aMem[pOp-&gt;p2];
                while ((1) != 0)
                {
                    sqlite3VdbeMemShallowCopy(pOut, pIn1, (int)(0x1000));
                    if ((((pOut).flags &amp; 0x1000) != 0) &amp;&amp; ((sqlite3VdbeMemMakeWriteable(pOut)) != 0))
                    {
                        goto no_mem;
                    }

                    if ((n--) == (0))
                        break;
                    pOut++;
                    pIn1++;
                }

                break;
            }

            case 80:
            {
                pIn1 = aMem[pOp-&gt;p1];
                pOut = aMem[pOp-&gt;p2];
                sqlite3VdbeMemShallowCopy(pOut, pIn1, (int)(0x1000));
                break;
            }

            case 81:
            {
                pIn1 = aMem[pOp-&gt;p1];
                pOut = aMem[pOp-&gt;p2];
                sqlite3VdbeMemSetInt64(pOut, (long)(pIn1.u.i));
                break;
            }

            case 82:
            {
                if ((rc = (int)(sqlite3VdbeCheckFk(p, (int)(0)))) != 0)
                {
                    goto abort_due_to_error;
                }

                break;
            }

            case 83:
            {
                sqlite3_value pMem;
                int i = 0;
                p.cacheCtr = (uint)((p.cacheCtr + 2) | 1);
                pMem = p.pResultSet = aMem[pOp-&gt;p1];
                for (i = (int)(0); (i) &lt; (pOp-&gt;p2); i++)
                {
                    if ((((pMem[i]).flags &amp; 0x1000) != 0) &amp;&amp; ((sqlite3VdbeMemMakeWriteable(pMem[i])) != 0))
                    {
                        goto no_mem;
                    }

                    sqlite3VdbeMemNulTerminate(pMem[i]);
                }

                if ((db.mallocFailed) != 0)
                    goto no_mem;
                if ((db.mTrace &amp; 0x04) != 0)
                {
                    db.trace.xV2((uint)(0x04), db.pTraceArg, p, null);
                }

                p.pc = (int)((int)(pOp - aOp) + 1);
                rc = (int)(100);
                goto vdbe_return;
            }

            case 111:
            {
                long nByte = 0;
                ushort flags1 = 0;
                ushort flags2 = 0;
                pIn1 = aMem[pOp-&gt;p1];
                pIn2 = aMem[pOp-&gt;p2];
                pOut = aMem[pOp-&gt;p3];
                flags1 = (ushort)(pIn1.flags);
                if (((flags1 | pIn2.flags) &amp; 0x0001) != 0)
                {
                    sqlite3VdbeMemSetNull(pOut);
                    break;
                }

                if ((flags1 &amp; (0x0002 | 0x0010)) == (0))
                {
                    if ((sqlite3VdbeMemStringify(pIn1, (byte)(encoding), (byte)(0))) != 0)
                        goto no_mem;
                    flags1 = (ushort)(pIn1.flags &amp; ~0x0002);
                }
                else if ((flags1 &amp; 0x4000) != 0)
                {
                    if ((sqlite3VdbeMemExpandBlob(pIn1)) != 0)
                        goto no_mem;
                    flags1 = (ushort)(pIn1.flags &amp; ~0x0002);
                }

                flags2 = (ushort)(pIn2.flags);
                if ((flags2 &amp; (0x0002 | 0x0010)) == (0))
                {
                    if ((sqlite3VdbeMemStringify(pIn2, (byte)(encoding), (byte)(0))) != 0)
                        goto no_mem;
                    flags2 = (ushort)(pIn2.flags &amp; ~0x0002);
                }
                else if ((flags2 &amp; 0x4000) != 0)
                {
                    if ((sqlite3VdbeMemExpandBlob(pIn2)) != 0)
                        goto no_mem;
                    flags2 = (ushort)(pIn2.flags &amp; ~0x0002);
                }

                nByte = (long)(pIn1.n + pIn2.n);
                if ((nByte) &gt; (db.aLimit[0]))
                {
                    goto too_big;
                }

                if ((sqlite3VdbeMemGrow(pOut, (int)((int)(nByte) + 3), ((pOut) == (pIn2) ? 1 : 0))) != 0)
                {
                    goto no_mem;
                }

                ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0002));
                if (pOut != pIn2)
                {
                    CRuntime.memcpy(pOut.z, pIn2.z, (ulong)(pIn2.n));
                    pIn2.flags = (ushort)(flags2);
                }

                CRuntime.memcpy(&amp;pOut.z[pIn2.n], pIn1.z, (ulong)(pIn1.n));
                pIn1.flags = (ushort)(flags1);
                pOut.z[nByte] = (sbyte)(0);
                pOut.z[nByte + 1] = (sbyte)(0);
                pOut.z[nByte + 2] = (sbyte)(0);
                pOut.flags |= (ushort)(0x0200);
                pOut.n = ((int)(nByte));
                pOut.enc = (byte)(encoding);
                break;
            }

            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            {
                ushort flags = 0;
                ushort type1 = 0;
                ushort type2 = 0;
                long iA = 0;
                long iB = 0;
                double rA = 0;
                double rB = 0;
                pIn1 = aMem[pOp-&gt;p1];
                type1 = (ushort)(numericType(pIn1));
                pIn2 = aMem[pOp-&gt;p2];
                type2 = (ushort)(numericType(pIn2));
                pOut = aMem[pOp-&gt;p3];
                flags = (ushort)(pIn1.flags | pIn2.flags);
                if ((type1 &amp; type2 &amp; 0x0004) != 0)
                {
                    iA = (long)(pIn1.u.i);
                    iB = (long)(pIn2.u.i);
                    switch (pOp-&gt;opcode)
                    {
                        case 106:
                            if ((sqlite3AddInt64(&amp;iB, (long)(iA))) != 0)
                                goto fp_math;
                            break;
                        case 107:
                            if ((sqlite3SubInt64(&amp;iB, (long)(iA))) != 0)
                                goto fp_math;
                            break;
                        case 108:
                            if ((sqlite3MulInt64(&amp;iB, (long)(iA))) != 0)
                                goto fp_math;
                            break;
                        case 109:
                        {
                            if ((iA) == (0))
                                goto arithmetic_result_is_null;
                            if (((iA) == (-1)) &amp;&amp; ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32)))))
                                goto fp_math;
                            iB /= (long)(iA);
                            break;
                        }

                        default:
                        {
                            if ((iA) == (0))
                                goto arithmetic_result_is_null;
                            if ((iA) == (-1))
                                iA = (long)(1);
                            iB %= (long)(iA);
                            break;
                        }
                    }

                    pOut.u.i = (long)(iB);
                    ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
                }
                else if ((flags &amp; 0x0001) != 0)
                {
                    goto arithmetic_result_is_null;
                }
                else
                {
                    fp_math:
                        ;
                    rA = (double)(sqlite3VdbeRealValue(pIn1));
                    rB = (double)(sqlite3VdbeRealValue(pIn2));
                    switch (pOp-&gt;opcode)
                    {
                        case 106:
                            rB += (double)(rA);
                            break;
                        case 107:
                            rB -= (double)(rA);
                            break;
                        case 108:
                            rB *= (double)(rA);
                            break;
                        case 109:
                        {
                            if ((rA) == ((double)(0)))
                                goto arithmetic_result_is_null;
                            rB /= (double)(rA);
                            break;
                        }

                        default:
                        {
                            iA = (long)(sqlite3VdbeIntValue(pIn1));
                            iB = (long)(sqlite3VdbeIntValue(pIn2));
                            if ((iA) == (0))
                                goto arithmetic_result_is_null;
                            if ((iA) == (-1))
                                iA = (long)(1);
                            rB = ((double)(iB % iA));
                            break;
                        }
                    }

                    if ((sqlite3IsNaN((double)(rB))) != 0)
                    {
                        goto arithmetic_result_is_null;
                    }

                    pOut.u.r = (double)(rB);
                    ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0008));
                }

                break;
                arithmetic_result_is_null:
                    ;
                sqlite3VdbeMemSetNull(pOut);
                break;
            }

            case 84:
            {
                if ((pOp-&gt;p1) != 0)
                {
                    sqlite3VdbeMemSetInt64(aMem[pOp-&gt;p1], (long)(0));
                }

                break;
            }

            case 102:
            case 103:
            case 104:
            case 105:
            {
                long iA = 0;
                ulong uA = 0;
                long iB = 0;
                byte op = 0;
                pIn1 = aMem[pOp-&gt;p1];
                pIn2 = aMem[pOp-&gt;p2];
                pOut = aMem[pOp-&gt;p3];
                if (((pIn1.flags | pIn2.flags) &amp; 0x0001) != 0)
                {
                    sqlite3VdbeMemSetNull(pOut);
                    break;
                }

                iA = (long)(sqlite3VdbeIntValue(pIn2));
                iB = (long)(sqlite3VdbeIntValue(pIn1));
                op = (byte)(pOp-&gt;opcode);
                if ((op) == (102))
                {
                    iA &amp;= (long)(iB);
                }
                else if ((op) == (103))
                {
                    iA |= (long)(iB);
                }
                else if (iB != 0)
                {
                    if ((iB) &lt; (0))
                    {
                        op = (byte)(2 * 104 + 1 - op);
                        iB = (long)((iB) &gt; (-64) ? -iB : 64);
                    }

                    if ((iB) &gt;= (64))
                    {
                        iA = (long)((((iA) &gt;= (0)) || ((op) == (104))) ? 0 : -1);
                    }
                    else
                    {
                        CRuntime.memcpy(&amp;uA, &amp;iA, (ulong)(sizeof(ulong)));
                        if ((op) == (104))
                        {
                            uA &lt;&lt;= iB;
                        }
                        else
                        {
                            uA &gt;&gt;= iB;
                            if ((iA) &lt; (0))
                                uA |= (ulong)(((((ulong)(0xffffffff)) &lt;&lt; 32) | 0xffffffff) &lt;&lt; (64 - iB));
                        }

                        CRuntime.memcpy(&amp;iA, &amp;uA, (ulong)(sizeof(long)));
                    }
                }

                pOut.u.i = (long)(iA);
                ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
                break;
            }

            case 85:
            {
                pIn1 = aMem[pOp-&gt;p1];
                sqlite3VdbeMemIntegerify(pIn1);
                pIn1.u.i += (long)(pOp-&gt;p2);
                break;
            }

            case 15:
            {
                pIn1 = aMem[pOp-&gt;p1];
                if ((pIn1.flags &amp; 0x0004) == (0))
                {
                    applyAffinity(pIn1, (sbyte)(0x43), (byte)(encoding));
                    if ((pIn1.flags &amp; 0x0004) == (0))
                    {
                        if ((pOp-&gt;p2) == (0))
                        {
                            rc = (int)(20);
                            goto abort_due_to_error;
                        }
                        else
                        {
                            goto jump_to_p2;
                        }
                    }
                }

                ((pIn1).flags = (ushort)(((pIn1).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
                break;
            }

            case 86:
            {
                pIn1 = aMem[pOp-&gt;p1];
                if ((pIn1.flags &amp; (0x0004 | 0x0020)) != 0)
                {
                    sqlite3VdbeMemRealify(pIn1);
                }

                break;
            }

            case 87:
            {
                pIn1 = aMem[pOp-&gt;p1];
                rc = (int)(((pIn1).flags &amp; 0x4000) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);
                if ((rc) != 0)
                    goto abort_due_to_error;
                rc = (int)(sqlite3VdbeMemCast(pIn1, (byte)(pOp-&gt;p2), (byte)(encoding)));
                if ((rc) != 0)
                    goto abort_due_to_error;
                break;
            }

            case 53:
            case 52:
            case 56:
            case 55:
            case 54:
            case 57:
            {
                int res = 0;
                int res2 = 0;
                sbyte affinity = 0;
                ushort flags1 = 0;
                ushort flags3 = 0;
                pIn1 = aMem[pOp-&gt;p1];
                pIn3 = aMem[pOp-&gt;p3];
                flags1 = (ushort)(pIn1.flags);
                flags3 = (ushort)(pIn3.flags);
                if ((flags1 &amp; flags3 &amp; 0x0004) != 0)
                {
                    if ((pIn3.u.i) &gt; (pIn1.u.i))
                    {
                        iCompare = (int)(+1);
                        if ((sqlite3aGTb[pOp-&gt;opcode]) != 0)
                        {
                            goto jump_to_p2;
                        }
                    }
                    else if ((pIn3.u.i) &lt; (pIn1.u.i))
                    {
                        iCompare = (int)(-1);
                        if ((sqlite3aLTb[pOp-&gt;opcode]) != 0)
                        {
                            goto jump_to_p2;
                        }
                    }
                    else
                    {
                        iCompare = (int)(0);
                        if ((sqlite3aEQb[pOp-&gt;opcode]) != 0)
                        {
                            goto jump_to_p2;
                        }
                    }

                    break;
                }

                if (((flags1 | flags3) &amp; 0x0001) != 0)
                {
                    if ((pOp-&gt;p5 &amp; 0x80) != 0)
                    {
                        if (((flags1 &amp; flags3 &amp; 0x0001) != 0) &amp;&amp; ((flags3 &amp; 0x0100) == (0)))
                        {
                            res = (int)(0);
                        }
                        else
                        {
                            res = (int)((flags3 &amp; 0x0001) ? -1 : +1);
                        }
                    }
                    else
                    {
                        iCompare = (int)(1);
                        if ((pOp-&gt;p5 &amp; 0x10) != 0)
                        {
                            goto jump_to_p2;
                        }

                        break;
                    }
                }
                else
                {
                    affinity = (sbyte)(pOp-&gt;p5 &amp; 0x47);
                    if ((affinity) &gt;= (0x43))
                    {
                        if (((flags1 | flags3) &amp; 0x0002) != 0)
                        {
                            if ((flags1 &amp; (0x0004 | 0x0020 | 0x0008 | 0x0002)) == (0x0002))
                            {
                                applyNumericAffinity(pIn1, (int)(0));
                                flags3 = (ushort)(pIn3.flags);
                            }

                            if ((flags3 &amp; (0x0004 | 0x0020 | 0x0008 | 0x0002)) == (0x0002))
                            {
                                applyNumericAffinity(pIn3, (int)(0));
                            }
                        }
                    }
                    else if ((affinity) == (0x42))
                    {
                        if (((flags1 &amp; 0x0002) == (0)) &amp;&amp; ((flags1 &amp; (0x0004 | 0x0008 | 0x0020)) != 0))
                        {
                            sqlite3VdbeMemStringify(pIn1, (byte)(encoding), (byte)(1));
                            flags1 = (ushort)((pIn1.flags &amp; ~0xc1bf) | (flags1 &amp; 0xc1bf));
                            if ((pIn1) == (pIn3))
                                flags3 = (ushort)(flags1 | 0x0002);
                        }

                        if (((flags3 &amp; 0x0002) == (0)) &amp;&amp; ((flags3 &amp; (0x0004 | 0x0008 | 0x0020)) != 0))
                        {
                            sqlite3VdbeMemStringify(pIn3, (byte)(encoding), (byte)(1));
                            flags3 = (ushort)((pIn3.flags &amp; ~0xc1bf) | (flags3 &amp; 0xc1bf));
                        }
                    }

                    res = (int)(sqlite3MemCompare(pIn3, pIn1, pOp-&gt;p4.pColl));
                }

                if ((res) &lt; (0))
                {
                    res2 = (int)(sqlite3aLTb[pOp-&gt;opcode]);
                }
                else if ((res) == (0))
                {
                    res2 = (int)(sqlite3aEQb[pOp-&gt;opcode]);
                }
                else
                {
                    res2 = (int)(sqlite3aGTb[pOp-&gt;opcode]);
                }

                iCompare = (int)(res);
                pIn3.flags = (ushort)(flags3);
                pIn1.flags = (ushort)(flags1);
                if ((res2) != 0)
                {
                    goto jump_to_p2;
                }

                break;
            }

            case 58:
            {
                if ((iCompare) == (0))
                    goto jump_to_p2;
                break;
            }

            case 88:
            {
                break;
            }

            case 89:
            {
                int n = 0;
                int i = 0;
                int p1 = 0;
                int p2 = 0;
                KeyInfo pKeyInfo;
                uint idx = 0;
                CollSeq pColl;
                int bRev = 0;
                uint* aPermute;
                if ((pOp-&gt;p5 &amp; 0x01) == (0))
                {
                    aPermute = null;
                }
                else
                {
                    aPermute = pOp[-1].p4.ai + 1;
                }

                n = (int)(pOp-&gt;p3);
                pKeyInfo = pOp-&gt;p4.pKeyInfo;
                p1 = (int)(pOp-&gt;p1);
                p2 = (int)(pOp-&gt;p2);
                for (i = (int)(0); (i) &lt; (n); i++)
                {
                    idx = (uint)((aPermute) != 0 ? aPermute[i] : (uint)(i));
                    pColl = pKeyInfo.aColl[i];
                    bRev = (int)(pKeyInfo.aSortFlags[i] &amp; 0x01);
                    iCompare = (int)(sqlite3MemCompare(aMem[p1 + idx], aMem[p2 + idx], pColl));
                    if ((iCompare) != 0)
                    {
                        if (((pKeyInfo.aSortFlags[i] &amp; 0x02) != 0) &amp;&amp; (((aMem[p1 + idx].flags &amp; 0x0001) != 0) || ((aMem[p2 + idx].flags &amp; 0x0001) != 0)))
                        {
                            iCompare = (int)(-iCompare);
                        }

                        if ((bRev) != 0)
                            iCompare = (int)(-iCompare);
                        break;
                    }
                }

                break;
            }

            case 16:
            {
                if ((iCompare) &lt; (0))
                {
                    pOp = &amp;aOp[pOp-&gt;p1 - 1];
                }
                else if ((iCompare) == (0))
                {
                    pOp = &amp;aOp[pOp-&gt;p2 - 1];
                }
                else
                {
                    pOp = &amp;aOp[pOp-&gt;p3 - 1];
                }

                break;
            }

            case 44:
            case 43:
            {
                int v1 = 0;
                int v2 = 0;
                v1 = (int)(sqlite3VdbeBooleanValue(aMem[pOp-&gt;p1], (int)(2)));
                v2 = (int)(sqlite3VdbeBooleanValue(aMem[pOp-&gt;p2], (int)(2)));
                if ((pOp-&gt;opcode) == (44))
                {
                    v1 = (int)(sqlite3VdbeExec_and_logic[v1 * 3 + v2]);
                }
                else
                {
                    v1 = (int)(sqlite3VdbeExec_or_logic[v1 * 3 + v2]);
                }

                pOut = aMem[pOp-&gt;p3];
                if ((v1) == (2))
                {
                    ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0001));
                }
                else
                {
                    pOut.u.i = (long)(v1);
                    ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
                }

                break;
            }

            case 90:
            {
                sqlite3VdbeMemSetInt64(aMem[pOp-&gt;p2], (long)(sqlite3VdbeBooleanValue(aMem[pOp-&gt;p1], (int)(pOp-&gt;p3)) ^ pOp-&gt;p4.i));
                break;
            }

            case 19:
            {
                pIn1 = aMem[pOp-&gt;p1];
                pOut = aMem[pOp-&gt;p2];
                if ((pIn1.flags &amp; 0x0001) == (0))
                {
                    sqlite3VdbeMemSetInt64(pOut, (long)(!sqlite3VdbeBooleanValue(pIn1, (int)(0))));
                }
                else
                {
                    sqlite3VdbeMemSetNull(pOut);
                }

                break;
            }

            case 114:
            {
                pIn1 = aMem[pOp-&gt;p1];
                pOut = aMem[pOp-&gt;p2];
                sqlite3VdbeMemSetNull(pOut);
                if ((pIn1.flags &amp; 0x0001) == (0))
                {
                    pOut.flags = (ushort)(0x0004);
                    pOut.u.i = (long)(~sqlite3VdbeIntValue(pIn1));
                }

                break;
            }

            case 17:
            {
                uint iAddr = 0;
                if ((p.pFrame) != null)
                {
                    iAddr = (uint)((int)(pOp - p.aOp));
                    if ((p.pFrame.aOnce[iAddr / 8] &amp; (1 &lt;&lt; (iAddr &amp; 7))) != 0)
                    {
                        goto jump_to_p2;
                    }

                    p.pFrame.aOnce[iAddr / 8] |= (byte)(1 &lt;&lt; (iAddr &amp; 7));
                }
                else
                {
                    if ((p.aOp[0].p1) == (pOp-&gt;p1))
                    {
                        goto jump_to_p2;
                    }
                }

                pOp-&gt;p1 = (int)(p.aOp[0].p1);
                break;
            }

            case 18:
            {
                int c = 0;
                c = (int)(sqlite3VdbeBooleanValue(aMem[pOp-&gt;p1], (int)(pOp-&gt;p3)));
                if ((c) != 0)
                    goto jump_to_p2;
                break;
            }

            case 20:
            {
                int c = 0;
                c = (int)(!sqlite3VdbeBooleanValue(aMem[pOp-&gt;p1], (int)(!pOp-&gt;p3)));
                if ((c) != 0)
                    goto jump_to_p2;
                break;
            }

            case 50:
            {
                pIn1 = aMem[pOp-&gt;p1];
                if ((pIn1.flags &amp; 0x0001) != 0)
                {
                    goto jump_to_p2;
                }

                break;
            }

            case 21:
            {
                int doTheJump = 0;
                pIn1 = aMem[pOp-&gt;p1];
                doTheJump = (int)(((pIn1.flags &amp; 0x0001) != 0) || ((sqlite3_value_type(pIn1)) == (pOp-&gt;p3)) ? 1 : 0);
                if ((doTheJump) != 0)
                    goto jump_to_p2;
                break;
            }

            case 91:
            {
                if (((aMem[pOp-&gt;p1].flags &amp; 0x0001) != 0) || ((aMem[pOp-&gt;p3].flags &amp; 0x0001) != 0))
                {
                    sqlite3VdbeMemSetNull(aMem[pOp-&gt;p2]);
                }
                else
                {
                    sqlite3VdbeMemSetInt64(aMem[pOp-&gt;p2], (long)(0));
                }

                break;
            }

            case 51:
            {
                pIn1 = aMem[pOp-&gt;p1];
                if ((pIn1.flags &amp; 0x0001) == (0))
                {
                    goto jump_to_p2;
                }

                break;
            }

            case 22:
            {
                if ((p.apCsr[pOp-&gt;p1].nullRow) != 0)
                {
                    sqlite3VdbeMemSetNull(aMem[pOp-&gt;p3]);
                    goto jump_to_p2;
                }

                break;
            }

            case 93:
            {
                uint p2 = 0;
                VdbeCursor pC;
                BtCursor pCrsr;
                uint* aOffset;
                int len = 0;
                int i = 0;
                sqlite3_value pDest;
                sqlite3_value sMem = new sqlite3_value();
                byte* zData;
                byte* zHdr;
                byte* zEndHdr;
                ulong offset64 = 0;
                uint t = 0;
                sqlite3_value pReg;
                pC = p.apCsr[pOp-&gt;p1];
                p2 = ((uint)(pOp-&gt;p2));
                rc = (int)(sqlite3VdbeCursorMoveto(pC, &amp;p2));
                if ((rc) != 0)
                    goto abort_due_to_error;
                pDest = aMem[pOp-&gt;p3];
                aOffset = pC.aOffset;
                if (pC.cacheStatus != p.cacheCtr)
                {
                    if ((pC.nullRow) != 0)
                    {
                        if ((pC.eCurType) == (3))
                        {
                            pReg = aMem[pC.seekResult];
                            pC.payloadSize = (uint)(pC.szRow = (uint)(pReg.n));
                            pC.aRow = (byte*)(pReg.z);
                        }
                        else
                        {
                            sqlite3VdbeMemSetNull(pDest);
                            goto op_column_out;
                        }
                    }
                    else
                    {
                        pCrsr = pC.uc.pCursor;
                        pC.payloadSize = (uint)(sqlite3BtreePayloadSize(pCrsr));
                        pC.aRow = sqlite3BtreePayloadFetch(pCrsr, &amp;pC.szRow);
                        if ((pC.payloadSize) &gt; ((uint)(db.aLimit[0])))
                        {
                            goto too_big;
                        }
                    }

                    pC.cacheStatus = (uint)(p.cacheCtr);
                    pC.iHdrOffset = (uint)((byte)(((*(pC.aRow)) &lt; ((byte)(0x80))) ? ((aOffset[0]) = ((uint)(*(pC.aRow)))), 1 : 
                    sqlite3GetVarint32((pC.aRow), &amp;(aOffset[0])) ) ) ;  pC . nHdrParsed  =  ( ushort ) ( 0 ) ;  if  ( ( pC . szRow ) &lt; ( aOffset [ 0 ] ) ) { pC . aRow  =  null ;  pC . szRow  =  ( uint ) ( 0 ) ;  if  ( ( ( aOffset [ 0 ] ) &gt; ( 98307 ) ) || ( ( aOffset [ 0 ] ) &gt; ( pC . payloadSize ) ) ) { goto  op_column_corrupt ;  } } else  { zData  =  pC . aRow ;  goto  op_column_read_header ;  } } if  ( ( pC . nHdrParsed ) &lt;= ( p2 ) ) { if  ( ( pC . iHdrOffset ) &lt; ( aOffset [ 0 ] ) ) { if  ( ( pC . aRow ) == ( null ) ) { CRuntime . memset ( sMem ,  ( int ) ( 0 ) ,  ( ulong ) ( sizeof ( sqlite3_value ) ) ) ;  rc  =  ( int ) ( sqlite3VdbeMemFromBtreeZeroOffset ( pC . uc . pCursor ,  ( uint ) ( aOffset [ 0 ] ) ,  sMem ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  zData  =  ( byte  * ) ( sMem . z ) ;  } else  { zData  =  pC . aRow ;  } op_column_read_header :  ;  i  =  ( int ) ( pC . nHdrParsed ) ;  offset64  =  ( ulong ) ( aOffset [ i ] ) ;  zHdr  =  zData + pC . iHdrOffset ;  zEndHdr  =  zData + aOffset [ 0 ] ;  do  { if  ( ( pC . aType [ i ]  =  ( uint ) ( t  =  ( uint ) ( zHdr [ 0 ] ) ) ) &lt; ( 0x80 ) ) { zHdr ++ ;  offset64 += ( ulong ) ( sqlite3VdbeOneByteSerialTypeLen ( ( byte ) ( t ) ) ) ;  } else  { zHdr += sqlite3GetVarint32 ( zHdr ,  &amp; t ) ;  pC . aType [ i ]  =  ( uint ) ( t ) ;  offset64 += ( ulong ) ( sqlite3VdbeSerialTypeLen ( ( uint ) ( t ) ) ) ;  } aOffset [ ++ i ]  =  ( ( uint ) ( offset64 &amp; 0xffffffff ) ) ;  } while  ( ( ( ( uint ) ( i ) ) &lt;= ( p2 ) ) &amp;&amp; ( ( zHdr ) &lt; ( zEndHdr ) ) ) ;  if  ( ( ( ( zHdr ) &gt;= ( zEndHdr ) ) &amp;&amp; ( ( ( zHdr ) &gt; ( zEndHdr ) ) || ( offset64 != pC . payloadSize ) ) ) || ( ( offset64 ) &gt; ( pC . payloadSize ) ) ) { if  ( ( aOffset [ 0 ] ) == ( 0 ) ) { i  =  ( int ) ( 0 ) ;  zHdr  =  zEndHdr ;  } else  { if  ( ( pC . aRow ) == ( null ) ) sqlite3VdbeMemRelease ( sMem ) ;  goto  op_column_corrupt ;  } } pC . nHdrParsed  =  ( ushort ) ( i ) ;  pC . iHdrOffset  =  ( ( uint ) ( zHdr - zData ) ) ;  if  ( ( pC . aRow ) == ( null ) ) sqlite3VdbeMemRelease ( sMem ) ;  } else  { t  =  ( uint ) ( 0 ) ;  } if  ( ( pC . nHdrParsed ) &lt;= ( p2 ) ) { if  ( ( pOp -&gt; p4type ) == ( - 11 ) ) { sqlite3VdbeMemShallowCopy ( pDest ,  pOp -&gt; p4 . pMem ,  ( int ) ( 0x0800 ) ) ;  } else  { sqlite3VdbeMemSetNull ( pDest ) ;  } goto  op_column_out ;  } } else  { t  =  ( uint ) ( pC . aType [ p2 ] ) ;  } if  ( ( ( ( pDest ) . flags &amp; ( 0x2000 | 0x0400 ) ) != 0 ) ) { sqlite3VdbeMemSetNull ( pDest ) ;  } if  ( ( pC . szRow ) &gt;= ( aOffset [ p2 + 1 ] ) ) { zData  =  pC . aRow + aOffset [ p2 ] ;  if  ( ( t ) &lt; ( 12 ) ) { sqlite3VdbeSerialGet ( zData ,  ( uint ) ( t ) ,  pDest ) ;  } else  { pDest . n  =  ( int ) ( len  =  ( int ) ( ( t - 12 ) / 2 ) ) ;  pDest . enc  =  ( byte ) ( encoding ) ;  if  ( ( pDest . szMalloc ) &lt; ( len + 2 ) ) { pDest . flags  =  ( ushort ) ( 0x0001 ) ;  if  ( ( sqlite3VdbeMemGrow ( pDest ,  ( int ) ( len + 2 ) ,  ( int ) ( 0 ) ) ) != 0 ) goto  no_mem ;  } else  { pDest . z  =  pDest . zMalloc ;  } CRuntime . memcpy ( pDest . z ,  zData ,  ( ulong ) ( len ) ) ;  pDest . z [ len ]  =  ( sbyte ) ( 0 ) ;  pDest . z [ len + 1 ]  =  ( sbyte ) ( 0 ) ;  pDest . flags  =  ( ushort ) ( sqlite3VdbeExec_aFlag [ t &amp; 1 ] ) ;  } } else  { pDest . enc  =  ( byte ) ( encoding ) ;  if  ( ( ( ( pOp -&gt; p5 &amp; ( 0x40 | 0x80 ) ) != 0 ) &amp;&amp; ( ( ( ( t ) &gt;= ( 12 ) ) &amp;&amp; ( ( t &amp; 1 ) == ( 0 ) ) ) || ( ( pOp -&gt; p5 &amp; 0x80 ) != 0 ) ) ) || ( ( len  =  ( int ) ( sqlite3VdbeSerialTypeLen ( ( uint ) ( t ) ) ) ) == ( 0 ) ) ) { sqlite3VdbeSerialGet ( sqlite3CtypeMap ,  ( uint ) ( t ) ,  pDest ) ;  } else  { rc  =  ( int ) ( sqlite3VdbeMemFromBtree ( pC . uc . pCursor ,  ( uint ) ( aOffset [ p2 ] ) ,  ( uint ) ( len ) ,  pDest ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  sqlite3VdbeSerialGet ( ( byte  * ) ( pDest . z ) ,  ( uint ) ( t ) ,  pDest ) ;  pDest . flags &amp;= ( ushort ) ( ~ 0x1000 ) ;  } } op_column_out :  ;  break ;  op_column_corrupt :  ;  if  ( ( aOp [ 0 ] . p3 ) &gt; ( 0 ) ) { pOp  =  &amp; aOp [ aOp [ 0 ] . p3 - 1 ] ;  break ;  } else  { rc  =  ( int ) ( sqlite3CorruptError ( ( int ) ( 90330 ) ) ) ;  goto  abort_due_to_error ;  } } case  94 :  { Table  pTab ;  Column * aCol ;  int  i  =  0 ;  pTab  =  pOp -&gt; p4 . pTab ;  aCol  =  pTab . aCol ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  for  ( i  =  ( int ) ( 0 ) ;  ( i ) &lt; ( pTab . nCol ) ;  i ++ ) { if  ( ( aCol [ i ] . colFlags &amp; 0x0060 ) != 0 ) { if  ( ( aCol [ i ] . colFlags &amp; 0x0020 ) != 0 ) continue ;  if  ( ( pOp -&gt; p3 ) != 0 ) { pIn1 ++ ;  continue ;  } } applyAffinity ( pIn1 ,  ( sbyte ) ( aCol [ i ] . affinity ) ,  ( byte ) ( encoding ) ) ;  if  ( ( pIn1 . flags &amp; 0x0001 ) == ( 0 ) ) { switch  ( aCol [ i ] . eCType ) { case  2 :  { if  ( ( pIn1 . flags &amp; 0x0010 ) == ( 0 ) ) goto  vdbe_type_error ;  break ;  } case  4 :  case  3 :  { if  ( ( pIn1 . flags &amp; 0x0004 ) == ( 0 ) ) goto  vdbe_type_error ;  break ;  } case  6 :  { if  ( ( pIn1 . flags &amp; 0x0002 ) == ( 0 ) ) goto  vdbe_type_error ;  break ;  } case  5 :  { if  ( ( pIn1 . flags &amp; 0x0004 ) != 0 ) { if  ( ( ( pIn1 . u . i ) &lt;= ( 140737488355327L  L ) ) &amp;&amp; ( ( pIn1 . u . i ) &gt;= ( - 140737488355328L  L ) ) ) { pIn1 . flags |= ( ushort ) ( 0x0020 ) ;  pIn1 . flags &amp;= ( ushort ) ( ~ 0x0004 ) ;  } else  { pIn1 . u . r  =  ( ( double ) ( pIn1 . u . i ) ) ;  pIn1 . flags |= ( ushort ) ( 0x0008 ) ;  pIn1 . flags &amp;= ( ushort ) ( ~ 0x0004 ) ;  } } else  if  ( ( pIn1 . flags &amp; ( 0x0008 | 0x0020 ) ) == ( 0 ) ) { goto  vdbe_type_error ;  } break ;  } default :  { break ;  } } } pIn1 ++ ;  } break ;  vdbe_type_error :  ;  sqlite3VdbeError ( p ,  "cannot store %s value in %s column %s.%s" ,  vdbeMemTypeName ( pIn1 ) ,  sqlite3StdType [ aCol [ i ] . eCType - 1 ] ,  pTab . zName ,  aCol [ i ] . zCnName ) ;  rc  =  ( int ) ( 19 | ( 12 &lt;&lt; 8 ) ) ;  goto  abort_due_to_error ;  } case  95 :  { sbyte  * zAffinity ;  zAffinity  =  pOp -&gt; p4 . z ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  while  ( ( 1 ) != 0 ) { applyAffinity ( pIn1 ,  ( sbyte ) ( zAffinity [ 0 ] ) ,  ( byte ) ( encoding ) ) ;  if  ( ( ( zAffinity [ 0 ] ) == ( 0x45 ) ) &amp;&amp; ( ( pIn1 . flags &amp; 0x0004 ) != 0 ) ) { if  ( ( ( pIn1 . u . i ) &lt;= ( 140737488355327L  L ) ) &amp;&amp; ( ( pIn1 . u . i ) &gt;= ( - 140737488355328L  L ) ) ) { pIn1 . flags |= ( ushort ) ( 0x0020 ) ;  pIn1 . flags &amp;= ( ushort ) ( ~ 0x0004 ) ;  } else  { pIn1 . u . r  =  ( ( double ) ( pIn1 . u . i ) ) ;  pIn1 . flags |= ( ushort ) ( 0x0008 ) ;  pIn1 . flags &amp;= ( ushort ) ( ~ 0x0004 ) ;  } } zAffinity ++ ;  if  ( ( zAffinity [ 0 ] ) == ( 0 ) ) break ;  pIn1 ++ ;  } break ;  } case  96 :  { sqlite3_value  pRec ;  ulong  nData  =  0 ;  int  nHdr  =  0 ;  long  nByte  =  0 ;  long  nZero  =  0 ;  int  nVarint  =  0 ;  uint  serial_type  =  0 ;  sqlite3_value  pData0 ;  sqlite3_value  pLast ;  int  nField  =  0 ;  sbyte  * zAffinity ;  int  file_format  =  0 ;  uint  len  =  0 ;  byte  * zHdr ;  byte  * zPayload ;  nData  =  ( ulong ) ( 0 ) ;  nHdr  =  ( int ) ( 0 ) ;  nZero  =  ( long ) ( 0 ) ;  nField  =  ( int ) ( pOp -&gt; p1 ) ;  zAffinity  =  pOp -&gt; p4 . z ;  pData0  =  aMem [ nField ] ;  nField  =  ( int ) ( pOp -&gt; p2 ) ;  pLast  =  pData0 [ nField - 1 ] ;  file_format  =  ( int ) ( p . minWriteFileFormat ) ;  pOut  =  aMem [ pOp -&gt; p3 ] ;  if  ( ( zAffinity ) != null ) { pRec  =  pData0 ;  do  { applyAffinity ( pRec ,  ( sbyte ) ( zAffinity [ 0 ] ) ,  ( byte ) ( encoding ) ) ;  if  ( ( ( zAffinity [ 0 ] ) == ( 0x45 ) ) &amp;&amp; ( ( pRec . flags &amp; 0x0004 ) != 0 ) ) { pRec . flags |= ( ushort ) ( 0x0020 ) ;  pRec . flags &amp;= ( ushort ) ( ~ ( 0x0004 ) ) ;  } zAffinity ++ ;  pRec ++ ;  } while  ( ( zAffinity [ 0 ] ) != 0 ) ;  } pRec  =  pLast ;  do  { if  ( ( pRec . flags &amp; 0x0001 ) != 0 ) { if  ( ( pRec . flags &amp; 0x4000 ) != 0 ) { pRec . uTemp  =  ( uint ) ( 10 ) ;  } else  { pRec . uTemp  =  ( uint ) ( 0 ) ;  } nHdr ++ ;  } else  if  ( ( pRec . flags &amp; ( 0x0004 | 0x0020 ) ) != 0 ) { long  i  =  ( long ) ( pRec . u . i ) ;  ulong  uu  =  0 ;  if  ( ( i ) &lt; ( 0 ) ) { uu  =  ( ulong ) ( ~ i ) ;  } else  { uu  =  ( ulong ) ( i ) ;  } nHdr ++ ;  if  ( ( uu ) &lt;= ( 127 ) ) { if  ( ( ( i &amp; 1 ) == ( i ) ) &amp;&amp; ( ( file_format ) &gt;= ( 4 ) ) ) { pRec . uTemp  =  ( uint ) ( 8 + ( uint ) ( uu ) ) ;  } else  { nData ++ ;  pRec . uTemp  =  ( uint ) ( 1 ) ;  } } else  if  ( ( uu ) &lt;= ( 32767 ) ) { nData += ( ulong ) ( 2 ) ;  pRec . uTemp  =  ( uint ) ( 2 ) ;  } else  if  ( ( uu ) &lt;= ( 8388607 ) ) { nData += ( ulong ) ( 3 ) ;  pRec . uTemp  =  ( uint ) ( 3 ) ;  } else  if  ( ( uu ) &lt;= ( 2147483647 ) ) { nData += ( ulong ) ( 4 ) ;  pRec . uTemp  =  ( uint ) ( 4 ) ;  } else  if  ( ( uu ) &lt;= ( 140737488355327L  L ) ) { nData += ( ulong ) ( 6 ) ;  pRec . uTemp  =  ( uint ) ( 5 ) ;  } else  { nData += ( ulong ) ( 8 ) ;  if  ( ( pRec . flags &amp; 0x0020 ) != 0 ) { pRec . u . r  =  ( ( double ) ( pRec . u . i ) ) ;  pRec . flags &amp;= ( ushort ) ( ~ 0x0020 ) ;  pRec . flags |= ( ushort ) ( 0x0008 ) ;  pRec . uTemp  =  ( uint ) ( 7 ) ;  } else  { pRec . uTemp  =  ( uint ) ( 6 ) ;  } } } else  if  ( ( pRec . flags &amp; 0x0008 ) != 0 ) { nHdr ++ ;  nData += ( ulong ) ( 8 ) ;  pRec . uTemp  =  ( uint ) ( 7 ) ;  } else  { len  =  ( ( uint ) ( pRec . n ) ) ;  serial_type  =  ( uint ) ( ( len * 2 ) + 12 + ( ( pRec . flags &amp; 0x0002 ) != 0 ) ) ;  if  ( ( pRec . flags &amp; 0x4000 ) != 0 ) { serial_type += ( uint ) ( pRec . u . nZero * 2 ) ;  if  ( ( nData ) != 0 ) { if  ( ( sqlite3VdbeMemExpandBlob ( pRec ) ) != 0 ) goto  no_mem ;  len += ( uint ) ( pRec . u . nZero ) ;  } else  { nZero += ( long ) ( pRec . u . nZero ) ;  } } nData += ( ulong ) ( len ) ;  nHdr += ( int ) ( sqlite3VarintLen ( ( ulong ) ( serial_type ) ) ) ;  pRec . uTemp  =  ( uint ) ( serial_type ) ;  } if  ( ( pRec ) == ( pData0 ) ) break ;  pRec -- ;  } while  ( ( 1 ) != 0 ) ;  if  ( ( nHdr ) &lt;= ( 126 ) ) { nHdr += ( int ) ( 1 ) ;  } else  { nVarint  =  ( int ) ( sqlite3VarintLen ( ( ulong ) ( nHdr ) ) ) ;  nHdr += ( int ) ( nVarint ) ;  if  ( ( nVarint ) &lt; ( sqlite3VarintLen ( ( ulong ) ( nHdr ) ) ) ) nHdr ++ ;  } nByte  =  ( long ) ( nHdr + nData ) ;  if  ( ( nByte + nZero ) &lt;= ( pOut . szMalloc ) ) { pOut . z  =  pOut . zMalloc ;  } else  { if  ( ( nByte + nZero ) &gt; ( db . aLimit [ 0 ] ) ) { goto  too_big ;  } if  ( ( sqlite3VdbeMemClearAndResize ( pOut ,  ( int ) ( nByte ) ) ) != 0 ) { goto  no_mem ;  } } pOut . n  =  ( ( int ) ( nByte ) ) ;  pOut . flags  =  ( ushort ) ( 0x0010 ) ;  if  ( ( nZero ) != 0 ) { pOut . u . nZero  =  ( int ) ( nZero ) ;  pOut . flags |= ( ushort ) ( 0x4000 ) ;  } zHdr  =  ( byte  * ) ( pOut . z ) ;  zPayload  =  zHdr + nHdr ;  zHdr += ( byte ) ( ( ( ( uint ) ( nHdr ) ) &lt; ( ( uint ) ( 0x80 ) ) ) ? ( * ( zHdr )  =  ( ( byte ) ( nHdr ) ) ) ,  1 :  sqlite3PutVarint ( ( zHdr ) ,  ( ulong ) ( nHdr ) ) ) ;  pRec  =  pData0 ;  do  { serial_type  =  ( uint ) ( pRec . uTemp ) ;  zHdr += ( byte ) ( ( ( serial_type ) &lt; ( ( uint ) ( 0x80 ) ) ) ? ( * ( zHdr )  =  ( ( byte ) ( serial_type ) ) ) ,  1 :  sqlite3PutVarint ( ( zHdr ) ,  ( ulong ) ( serial_type ) ) ) ;  zPayload += sqlite3VdbeSerialPut ( zPayload ,  pRec ,  ( uint ) ( serial_type ) ) ;  } while  ( ( ++ pRec ) &lt;= ( pLast ) ) ;  break ;  } case  97 :  { long  nEntry  =  0 ;  BtCursor  pCrsr ;  pCrsr  =  p . apCsr [ pOp -&gt; p1 ] . uc . pCursor ;  if  ( ( pOp -&gt; p3 ) != 0 ) { nEntry  =  ( long ) ( sqlite3BtreeRowCountEst ( pCrsr ) ) ;  } else  { nEntry  =  ( long ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeCount ( db ,  pCrsr ,  &amp; nEntry ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . u . i  =  ( long ) ( nEntry ) ;  goto  check_for_interrupt ;  } case  0 :  { int  p1  =  0 ;  sbyte  * zName ;  int  nName  =  0 ;  Savepoint * pNew ;  Savepoint * pSavepoint ;  Savepoint * pTmp ;  int  iSavepoint  =  0 ;  int  ii  =  0 ;  p1  =  ( int ) ( pOp -&gt; p1 ) ;  zName  =  pOp -&gt; p4 . z ;  if  ( ( p1 ) == ( 0 ) ) { if  ( ( db . nVdbeWrite ) &gt; ( 0 ) ) { sqlite3VdbeError ( p ,  "cannot open savepoint - SQL statements in progress" ) ;  rc  =  ( int ) ( 5 ) ;  } else  { nName  =  ( int ) ( sqlite3Strlen30 ( zName ) ) ;  rc  =  ( int ) ( sqlite3VtabSavepoint ( db ,  ( int ) ( 0 ) ,  ( int ) ( db . nStatement + db . nSavepoint ) ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  pNew  =  sqlite3DbMallocRawNN ( db ,  ( ulong ) ( sizeof ( Savepoint ) + nName + 1 ) ) ;  if  ( ( pNew ) != null ) { pNew -&gt; zName  =  ( sbyte  * ) ( &amp; pNew [ 1 ] ) ;  CRuntime . memcpy ( pNew -&gt; zName ,  zName ,  ( ulong ) ( nName + 1 ) ) ;  if  ( ( db . autoCommit ) != 0 ) { db . autoCommit  =  ( byte ) ( 0 ) ;  db . isTransactionSavepoint  =  ( byte ) ( 1 ) ;  } else  { db . nSavepoint ++ ;  } pNew -&gt; pNext  =  db . pSavepoint ;  db . pSavepoint  =  pNew ;  pNew -&gt; nDeferredCons  =  ( long ) ( db . nDeferredCons ) ;  pNew -&gt; nDeferredImmCons  =  ( long ) ( db . nDeferredImmCons ) ;  } } } else  { iSavepoint  =  ( int ) ( 0 ) ;  for  ( pSavepoint  =  db . pSavepoint ;  ( ( pSavepoint ) != null ) &amp;&amp; ( ( sqlite3StrICmp ( pSavepoint -&gt; zName ,  zName ) ) != 0 ) ;  pSavepoint  =  pSavepoint -&gt; pNext ) { iSavepoint ++ ;  } if  ( pSavepoint == null ) { sqlite3VdbeError ( p ,  "no such savepoint: %s" ,  zName ) ;  rc  =  ( int ) ( 1 ) ;  } else  if  ( ( ( db . nVdbeWrite ) &gt; ( 0 ) ) &amp;&amp; ( ( p1 ) == ( 1 ) ) ) { sqlite3VdbeError ( p ,  "cannot release savepoint - SQL statements in progress" ) ;  rc  =  ( int ) ( 5 ) ;  } else  { int  isTransaction  =  ( int ) ( ( ( pSavepoint -&gt; pNext ) == ( null ) ) &amp;&amp; ( ( db . isTransactionSavepoint ) != 0 ) ? 1 :  0 ) ;  if  ( ( ( isTransaction ) != 0 ) &amp;&amp; ( ( p1 ) == ( 1 ) ) ) { if  ( ( rc  =  ( int ) ( sqlite3VdbeCheckFk ( p ,  ( int ) ( 1 ) ) ) ) != 0 ) { goto  vdbe_return ;  } db . autoCommit  =  ( byte ) ( 1 ) ;  if  ( ( sqlite3VdbeHalt ( p ) ) == ( 5 ) ) { p . pc  =  ( ( int ) ( pOp - aOp ) ) ;  db . autoCommit  =  ( byte ) ( 0 ) ;  p . rc  =  ( int ) ( rc  =  ( int ) ( 5 ) ) ;  goto  vdbe_return ;  } rc  =  ( int ) ( p . rc ) ;  if  ( ( rc ) != 0 ) { db . autoCommit  =  ( byte ) ( 0 ) ;  } else  { db . isTransactionSavepoint  =  ( byte ) ( 0 ) ;  } } else  { int  isSchemaChange  =  0 ;  iSavepoint  =  ( int ) ( db . nSavepoint - iSavepoint - 1 ) ;  if  ( ( p1 ) == ( 2 ) ) { isSchemaChange  =  ( int ) ( ( db . mDbFlags &amp; 0x0001 ) != 0 ) ;  for  ( ii  =  ( int ) ( 0 ) ;  ( ii ) &lt; ( db . nDb ) ;  ii ++ ) { rc  =  ( int ) ( sqlite3BtreeTripAllCursors ( db . aDb [ ii ] . pBt ,  ( int ) ( 4 | ( 2 &lt;&lt; 8 ) ) ,  ( ( isSchemaChange ) == ( 0 ) ? 1 :  0 ) ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  } } else  { isSchemaChange  =  ( int ) ( 0 ) ;  } for  ( ii  =  ( int ) ( 0 ) ;  ( ii ) &lt; ( db . nDb ) ;  ii ++ ) { rc  =  ( int ) ( sqlite3BtreeSavepoint ( db . aDb [ ii ] . pBt ,  ( int ) ( p1 ) ,  ( int ) ( iSavepoint ) ) ) ;  if  ( rc != 0 ) { goto  abort_due_to_error ;  } } if  ( ( isSchemaChange ) != 0 ) { sqlite3ExpirePreparedStatements ( db ,  ( int ) ( 0 ) ) ;  sqlite3ResetAllSchemasOfConnection ( db ) ;  db . mDbFlags |= ( uint ) ( 0x0001 ) ;  } } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  while  ( db . pSavepoint != pSavepoint ) { pTmp  =  db . pSavepoint ;  db . pSavepoint  =  pTmp -&gt; pNext ;  sqlite3DbFree ( db ,  pTmp ) ;  db . nSavepoint -- ;  } if  ( ( p1 ) == ( 1 ) ) { db . pSavepoint  =  pSavepoint -&gt; pNext ;  sqlite3DbFree ( db ,  pSavepoint ) ;  if  ( isTransaction == 0 ) { db . nSavepoint -- ;  } } else  { db . nDeferredCons  =  ( long ) ( pSavepoint -&gt; nDeferredCons ) ;  db . nDeferredImmCons  =  ( long ) ( pSavepoint -&gt; nDeferredImmCons ) ;  } if  ( ( isTransaction == 0 ) || ( ( p1 ) == ( 2 ) ) ) { rc  =  ( int ) ( sqlite3VtabSavepoint ( db ,  ( int ) ( p1 ) ,  ( int ) ( iSavepoint ) ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  } } } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  1 :  { int  desiredAutoCommit  =  0 ;  int  iRollback  =  0 ;  desiredAutoCommit  =  ( int ) ( pOp -&gt; p1 ) ;  iRollback  =  ( int ) ( pOp -&gt; p2 ) ;  if  ( desiredAutoCommit != db . autoCommit ) { if  ( ( iRollback ) != 0 ) { sqlite3RollbackAll ( db ,  ( int ) ( 4 | ( 2 &lt;&lt; 8 ) ) ) ;  db . autoCommit  =  ( byte ) ( 1 ) ;  } else  if  ( ( ( desiredAutoCommit ) != 0 ) &amp;&amp; ( ( db . nVdbeWrite ) &gt; ( 0 ) ) ) { sqlite3VdbeError ( p ,  "cannot commit transaction - SQL statements in progress" ) ;  rc  =  ( int ) ( 5 ) ;  goto  abort_due_to_error ;  } else  if  ( ( rc  =  ( int ) ( sqlite3VdbeCheckFk ( p ,  ( int ) ( 1 ) ) ) ) != 0 ) { goto  vdbe_return ;  } else  { db . autoCommit  =  ( ( byte ) ( desiredAutoCommit ) ) ;  } if  ( ( sqlite3VdbeHalt ( p ) ) == ( 5 ) ) { p . pc  =  ( ( int ) ( pOp - aOp ) ) ;  db . autoCommit  =  ( ( byte ) ( 1 - desiredAutoCommit ) ) ;  p . rc  =  ( int ) ( rc  =  ( int ) ( 5 ) ) ;  goto  vdbe_return ;  } sqlite3CloseSavepoints ( db ) ;  if  ( ( p . rc ) == ( 0 ) ) { rc  =  ( int ) ( 101 ) ;  } else  { rc  =  ( int ) ( 1 ) ;  } goto  vdbe_return ;  } else  { sqlite3VdbeError ( p ,  ( ! desiredAutoCommit ) ? "cannot start a transaction within a transaction" :  ( ( iRollback ) != 0 ? "cannot rollback - no transaction is active" :  "cannot commit - no transaction is active" ) ) ;  rc  =  ( int ) ( 1 ) ;  goto  abort_due_to_error ;  } } case  2 :  { Btree  pBt ;  int  iMeta  =  ( int ) ( 0 ) ;  if  ( ( ( pOp -&gt; p2 ) != 0 ) &amp;&amp; ( ( db . flags &amp; ( 0x00100000 | ( ( ulong ) ( 0x00002 ) &lt;&lt; 32 ) ) ) != 0 ) ) { if  ( ( db . flags &amp; 0x00100000 ) != 0 ) { rc  =  ( int ) ( 8 ) ;  } else  { rc  =  ( int ) ( 11 ) ;  } goto  abort_due_to_error ;  } pBt  =  db . aDb [ pOp -&gt; p1 ] . pBt ;  if  ( ( pBt ) != null ) { rc  =  ( int ) ( sqlite3BtreeBeginTrans ( pBt ,  ( int ) ( pOp -&gt; p2 ) ,  &amp; iMeta ) ) ;  if  ( rc != 0 ) { if  ( ( rc &amp; 0xff ) == ( 5 ) ) { p . pc  =  ( ( int ) ( pOp - aOp ) ) ;  p . rc  =  ( int ) ( rc ) ;  goto  vdbe_return ;  } goto  abort_due_to_error ;  } if  ( ( ( ( p . usesStmtJournal ) != 0 ) &amp;&amp; ( ( pOp -&gt; p2 ) != 0 ) ) &amp;&amp; ( ( ( db . autoCommit ) == ( 0 ) ) || ( ( db . nVdbeRead ) &gt; ( 1 ) ) ) ) { if  ( ( p . iStatement ) == ( 0 ) ) { db . nStatement ++ ;  p . iStatement  =  ( int ) ( db . nSavepoint + db . nStatement ) ;  } rc  =  ( int ) ( sqlite3VtabSavepoint ( db ,  ( int ) ( 0 ) ,  ( int ) ( p . iStatement - 1 ) ) ) ;  if  ( ( rc ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3BtreeBeginStmt ( pBt ,  ( int ) ( p . iStatement ) ) ) ;  } p . nStmtDefCons  =  ( long ) ( db . nDeferredCons ) ;  p . nStmtDefImmCons  =  ( long ) ( db . nDeferredImmCons ) ;  } } if  ( ( ( ( rc ) == ( 0 ) ) &amp;&amp; ( ( pOp -&gt; p5 ) != 0 ) ) &amp;&amp; ( ( iMeta != pOp -&gt; p3 ) || ( db . aDb [ pOp -&gt; p1 ] . pSchema . iGeneration != pOp -&gt; p4 . i ) ) ) { sqlite3DbFree ( db ,  p . zErrMsg ) ;  p . zErrMsg  =  sqlite3DbStrDup ( db ,  "database schema has changed" ) ;  if  ( db . aDb [ pOp -&gt; p1 ] . pSchema . schema_cookie != iMeta ) { sqlite3ResetOneSchema ( db ,  ( int ) ( pOp -&gt; p1 ) ) ;  } p . expired  =  ( uint ) ( 1 ) ;  rc  =  ( int ) ( 17 ) ;  } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  98 :  { int  iMeta  =  0 ;  int  iDb  =  0 ;  int  iCookie  =  0 ;  iDb  =  ( int ) ( pOp -&gt; p1 ) ;  iCookie  =  ( int ) ( pOp -&gt; p3 ) ;  sqlite3BtreeGetMeta ( db . aDb [ iDb ] . pBt ,  ( int ) ( iCookie ) ,  ( uint  * ) ( &amp; iMeta ) ) ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . u . i  =  ( long ) ( iMeta ) ;  break ;  } case  99 :  { Db  pDb ;  pDb  =  db . aDb [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( sqlite3BtreeUpdateMeta ( pDb . pBt ,  ( int ) ( pOp -&gt; p2 ) ,  ( uint ) ( pOp -&gt; p3 ) ) ) ;  if  ( ( pOp -&gt; p2 ) == ( 1 ) ) { pDb . pSchema . schema_cookie  =  ( int ) ( pOp -&gt; p3 - pOp -&gt; p5 ) ;  db . mDbFlags |= ( uint ) ( 0x0001 ) ;  sqlite3FkClearTriggerCache ( db ,  ( int ) ( pOp -&gt; p1 ) ) ;  } else  if  ( ( pOp -&gt; p2 ) == ( 2 ) ) { pDb . pSchema . file_format  =  ( byte ) ( pOp -&gt; p3 ) ;  } if  ( ( pOp -&gt; p1 ) == ( 1 ) ) { sqlite3ExpirePreparedStatements ( db ,  ( int ) ( 0 ) ) ;  p . expired  =  ( uint ) ( 0 ) ;  } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  100 :  { int  nField  =  0 ;  KeyInfo  pKeyInfo ;  uint  p2  =  0 ;  int  iDb  =  0 ;  int  wrFlag  =  0 ;  Btree  pX ;  VdbeCursor  pCur ;  Db  pDb ;  pCur  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( ( pCur ) != null ) &amp;&amp; ( ( pCur . pgnoRoot ) == ( ( uint ) ( pOp -&gt; p2 ) ) ) ) { sqlite3BtreeClearCursor ( pCur . uc . pCursor ) ;  goto  open_cursor_set_hints ;  } case  101 :  case  112 :  ;  if  ( ( p . expired ) == ( 1 ) ) { rc  =  ( int ) ( 4 | ( 2 &lt;&lt; 8 ) ) ;  goto  abort_due_to_error ;  } nField  =  ( int ) ( 0 ) ;  pKeyInfo  =  null ;  p2  =  ( ( uint ) ( pOp -&gt; p2 ) ) ;  iDb  =  ( int ) ( pOp -&gt; p3 ) ;  pDb  =  db . aDb [ iDb ] ;  pX  =  pDb . pBt ;  if  ( ( pOp -&gt; opcode ) == ( 112 ) ) { wrFlag  =  ( int ) ( 0x00000004 | ( pOp -&gt; p5 &amp; 0x08 ) ) ;  if  ( ( pDb . pSchema . file_format ) &lt; ( p . minWriteFileFormat ) ) { p . minWriteFileFormat  =  ( byte ) ( pDb . pSchema . file_format ) ;  } } else  { wrFlag  =  ( int ) ( 0 ) ;  } if  ( ( pOp -&gt; p5 &amp; 0x10 ) != 0 ) { pIn2  =  aMem [ p2 ] ;  sqlite3VdbeMemIntegerify ( pIn2 ) ;  p2  =  ( uint ) ( ( int ) ( pIn2 . u . i ) ) ;  } if  ( ( pOp -&gt; p4type ) == ( - 9 ) ) { pKeyInfo  =  pOp -&gt; p4 . pKeyInfo ;  nField  =  ( int ) ( pKeyInfo . nAllField ) ;  } else  if  ( ( pOp -&gt; p4type ) == ( - 3 ) ) { nField  =  ( int ) ( pOp -&gt; p4 . i ) ;  } pCur  =  allocateCursor ( p ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( nField ) ,  ( byte ) ( 0 ) ) ;  if  ( ( pCur ) == ( null ) ) goto  no_mem ;  pCur . iDb  =  ( sbyte ) ( iDb ) ;  pCur . nullRow  =  ( byte ) ( 1 ) ;  pCur . isOrdered  =  ( uint ) ( 1 ) ;  pCur . pgnoRoot  =  ( uint ) ( p2 ) ;  rc  =  ( int ) ( sqlite3BtreeCursor ( pX ,  ( uint ) ( p2 ) ,  ( int ) ( wrFlag ) ,  pKeyInfo ,  pCur . uc . pCursor ) ) ;  pCur . pKeyInfo  =  pKeyInfo ;  pCur . isTable  =  ( byte ) ( pOp -&gt; p4type != ( - 9 ) ) ;  open_cursor_set_hints :  ;  sqlite3BtreeCursorHintFlags ( pCur . uc . pCursor ,  ( uint ) ( pOp -&gt; p5 &amp; ( 0x01 | 0x02 ) ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  113 :  { VdbeCursor  pOrig ;  VdbeCursor  pCx ;  pOrig  =  p . apCsr [ pOp -&gt; p2 ] ;  pCx  =  allocateCursor ( p ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( pOrig . nField ) ,  ( byte ) ( 0 ) ) ;  if  ( ( pCx ) == ( null ) ) goto  no_mem ;  pCx . nullRow  =  ( byte ) ( 1 ) ;  pCx . isEphemeral  =  ( uint ) ( 1 ) ;  pCx . pKeyInfo  =  pOrig . pKeyInfo ;  pCx . isTable  =  ( byte ) ( pOrig . isTable ) ;  pCx . pgnoRoot  =  ( uint ) ( pOrig . pgnoRoot ) ;  pCx . isOrdered  =  ( uint ) ( pOrig . isOrdered ) ;  pCx . ub . pBtx  =  pOrig . ub . pBtx ;  pCx . hasBeenDuped  =  ( uint ) ( 1 ) ;  pOrig . hasBeenDuped  =  ( uint ) ( 1 ) ;  rc  =  ( int ) ( sqlite3BtreeCursor ( pCx . ub . pBtx ,  ( uint ) ( pCx . pgnoRoot ) ,  ( int ) ( 0x00000004 ) ,  pCx . pKeyInfo ,  pCx . uc . pCursor ) ) ;  break ;  } case  115 :  case  116 :  { VdbeCursor  pCx ;  KeyInfo  pKeyInfo ;  if  ( ( pOp -&gt; p3 ) &gt; ( 0 ) ) { aMem [ pOp -&gt; p3 ] . n  =  ( int ) ( 0 ) ;  aMem [ pOp -&gt; p3 ] . z  =  "" ;  } pCx  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( ( ( pCx ) != null ) &amp;&amp; ( pCx . hasBeenDuped == 0 ) ) &amp;&amp; ( ( pOp -&gt; p2 ) &lt;= ( pCx . nField ) ) ) { pCx . seqCount  =  ( long ) ( 0 ) ;  pCx . cacheStatus  =  ( uint ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeClearTable ( pCx . ub . pBtx ,  ( int ) ( pCx . pgnoRoot ) ,  null ) ) ;  } else  { pCx  =  allocateCursor ( p ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( pOp -&gt; p2 ) ,  ( byte ) ( 0 ) ) ;  if  ( ( pCx ) == ( null ) ) goto  no_mem ;  pCx . isEphemeral  =  ( uint ) ( 1 ) ;  rc  =  ( int ) ( sqlite3BtreeOpen ( db . pVfs ,  null ,  db ,  pCx . ub . pBtx ,  ( int ) ( 1 | 4 | pOp -&gt; p5 ) ,  ( int ) ( sqlite3VdbeExec_vfsFlags ) ) ) ;  if  ( ( rc ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3BtreeBeginTrans ( pCx . ub . pBtx ,  ( int ) ( 1 ) ,  null ) ) ;  if  ( ( rc ) == ( 0 ) ) { if  ( ( pCx . pKeyInfo  =  pKeyInfo  =  pOp -&gt; p4 . pKeyInfo ) != null ) { rc  =  ( int ) ( sqlite3BtreeCreateTable ( pCx . ub . pBtx ,  &amp; pCx . pgnoRoot ,  ( int ) ( 2 | pOp -&gt; p5 ) ) ) ;  if  ( ( rc ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3BtreeCursor ( pCx . ub . pBtx ,  ( uint ) ( pCx . pgnoRoot ) ,  ( int ) ( 0x00000004 ) ,  pKeyInfo ,  pCx . uc . pCursor ) ) ;  } pCx . isTable  =  ( byte ) ( 0 ) ;  } else  { pCx . pgnoRoot  =  ( uint ) ( 1 ) ;  rc  =  ( int ) ( sqlite3BtreeCursor ( pCx . ub . pBtx ,  ( uint ) ( 1 ) ,  ( int ) ( 0x00000004 ) ,  null ,  pCx . uc . pCursor ) ) ;  pCx . isTable  =  ( byte ) ( 1 ) ;  } } pCx . isOrdered  =  ( uint ) ( pOp -&gt; p5 != 8 ) ;  if  ( ( rc ) != 0 ) { sqlite3BtreeClose ( pCx . ub . pBtx ) ;  } } } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  pCx . nullRow  =  ( byte ) ( 1 ) ;  break ;  } case  118 :  { VdbeCursor  pCx ;  pCx  =  allocateCursor ( p ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( pOp -&gt; p2 ) ,  ( byte ) ( 1 ) ) ;  if  ( ( pCx ) == ( null ) ) goto  no_mem ;  pCx . pKeyInfo  =  pOp -&gt; p4 . pKeyInfo ;  rc  =  ( int ) ( sqlite3VdbeSorterInit ( db ,  ( int ) ( pOp -&gt; p3 ) ,  pCx ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  119 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( pC . seqCount ++ ) == ( 0 ) ) { goto  jump_to_p2 ;  } break ;  } case  120 :  { VdbeCursor  pCx ;  pCx  =  allocateCursor ( p ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( pOp -&gt; p3 ) ,  ( byte ) ( 3 ) ) ;  if  ( ( pCx ) == ( null ) ) goto  no_mem ;  pCx . nullRow  =  ( byte ) ( 1 ) ;  pCx . seekResult  =  ( int ) ( pOp -&gt; p2 ) ;  pCx . isTable  =  ( byte ) ( 1 ) ;  pCx . uc . pCursor  =  sqlite3BtreeFakeValidCursor ( ) ;  break ;  } case  121 :  { sqlite3VdbeFreeCursor ( p ,  p . apCsr [ pOp -&gt; p1 ] ) ;  p . apCsr [ pOp -&gt; p1 ]  =  null ;  break ;  } case  23 :  case  24 :  case  25 :  case  26 :  { int  res  =  0 ;  int  oc  =  0 ;  VdbeCursor  pC ;  UnpackedRecord  r  =  new  UnpackedRecord ( ) ;  int  nField  =  0 ;  long  iKey  =  0 ;  int  eqOnly  =  0 ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  oc  =  ( int ) ( pOp -&gt; opcode ) ;  eqOnly  =  ( int ) ( 0 ) ;  pC . nullRow  =  ( byte ) ( 0 ) ;  pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( pC . isTable ) != 0 ) { ushort  flags3  =  0 ;  ushort  newType  =  0 ;  pIn3  =  aMem [ pOp -&gt; p3 ] ;  flags3  =  ( ushort ) ( pIn3 . flags ) ;  if  ( ( flags3 &amp; ( 0x0004 | 0x0008 | 0x0020 | 0x0002 ) ) == ( 0x0002 ) ) { applyNumericAffinity ( pIn3 ,  ( int ) ( 0 ) ) ;  } iKey  =  ( long ) ( sqlite3VdbeIntValue ( pIn3 ) ) ;  newType  =  ( ushort ) ( pIn3 . flags ) ;  pIn3 . flags  =  ( ushort ) ( flags3 ) ;  if  ( ( newType &amp; ( 0x0004 | 0x0020 ) ) == ( 0 ) ) { int  c  =  0 ;  if  ( ( newType &amp; 0x0008 ) == ( 0 ) ) { if  ( ( ( newType &amp; 0x0001 ) != 0 ) || ( ( oc ) &gt;= ( 25 ) ) ) { goto  jump_to_p2 ;  } else  { rc  =  ( int ) ( sqlite3BtreeLast ( pC . uc . pCursor ,  &amp; res ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  goto  seek_not_found ;  } } c  =  ( int ) ( sqlite3IntFloatCompare ( ( long ) ( iKey ) ,  ( double ) ( pIn3 . u . r ) ) ) ;  if  ( ( c ) &gt; ( 0 ) ) { if  ( ( oc &amp; 0x0001 ) == ( 26 &amp; 0x0001 ) ) oc -- ;  } else  if  ( ( c ) &lt; ( 0 ) ) { if  ( ( oc &amp; 0x0001 ) == ( 23 &amp; 0x0001 ) ) oc ++ ;  } } rc  =  ( int ) ( sqlite3BtreeTableMoveto ( pC . uc . pCursor ,  ( long ) ( ( ulong ) ( iKey ) ) ,  ( int ) ( 0 ) ,  &amp; res ) ) ;  pC . movetoTarget  =  ( long ) ( iKey ) ;  if  ( rc != 0 ) { goto  abort_due_to_error ;  } } else  { if  ( ( sqlite3BtreeCursorHasHint ( pC . uc . pCursor ,  ( uint ) ( 0x00000002 ) ) ) != 0 ) { eqOnly  =  ( int ) ( 1 ) ;  } nField  =  ( int ) ( pOp -&gt; p4 . i ) ;  r . pKeyInfo  =  pC . pKeyInfo ;  r . nField  =  ( ( ushort ) ( nField ) ) ;  r . default_rc  =  ( sbyte ) ( ( 1 &amp; ( oc - 23 ) ) ? - 1 :  + 1 ) ;  r . aMem  =  aMem [ pOp -&gt; p3 ] ;  r . eqSeen  =  ( byte ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeIndexMoveto ( pC . uc . pCursor ,  r ,  &amp; res ) ) ;  if  ( rc != 0 ) { goto  abort_due_to_error ;  } if  ( ( ( eqOnly ) != 0 ) &amp;&amp; ( ( r . eqSeen ) == ( 0 ) ) ) { goto  seek_not_found ;  } } if  ( ( oc ) &gt;= ( 25 ) ) { if  ( ( ( res ) &lt; ( 0 ) ) || ( ( ( res ) == ( 0 ) ) &amp;&amp; ( ( oc ) == ( 26 ) ) ) ) { res  =  ( int ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeNext ( pC . uc . pCursor ,  ( int ) ( 0 ) ) ) ;  if  ( rc != 0 ) { if  ( ( rc ) == ( 101 ) ) { rc  =  ( int ) ( 0 ) ;  res  =  ( int ) ( 1 ) ;  } else  { goto  abort_due_to_error ;  } } } else  { res  =  ( int ) ( 0 ) ;  } } else  { if  ( ( ( res ) &gt; ( 0 ) ) || ( ( ( res ) == ( 0 ) ) &amp;&amp; ( ( oc ) == ( 23 ) ) ) ) { res  =  ( int ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreePrevious ( pC . uc . pCursor ,  ( int ) ( 0 ) ) ) ;  if  ( rc != 0 ) { if  ( ( rc ) == ( 101 ) ) { rc  =  ( int ) ( 0 ) ;  res  =  ( int ) ( 1 ) ;  } else  { goto  abort_due_to_error ;  } } } else  { res  =  ( int ) ( sqlite3BtreeEof ( pC . uc . pCursor ) ) ;  } } seek_not_found :  ;  if  ( ( res ) != 0 ) { goto  jump_to_p2 ;  } else  if  ( ( eqOnly ) != 0 ) { pOp ++ ;  } break ;  } case  123 :  { VdbeCursor  pC ;  int  res  =  0 ;  int  nStep  =  0 ;  UnpackedRecord  r  =  new  UnpackedRecord ( ) ;  pC  =  p . apCsr [ pOp [ 1 ] . p1 ] ;  if  ( sqlite3BtreeCursorIsValidNN ( pC . uc . pCursor ) == 0 ) { break ;  } nStep  =  ( int ) ( pOp -&gt; p1 ) ;  r . pKeyInfo  =  pC . pKeyInfo ;  r . nField  =  ( ( ushort ) ( pOp [ 1 ] . p4 . i ) ) ;  r . default_rc  =  ( sbyte ) ( 0 ) ;  r . aMem  =  aMem [ pOp [ 1 ] . p3 ] ;  res  =  ( int ) ( 0 ) ;  while  ( ( 1 ) != 0 ) { rc  =  ( int ) ( sqlite3VdbeIdxKeyCompare ( db ,  pC ,  r ,  &amp; res ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( res ) &gt; ( 0 ) ) { seekscan_search_fail :  ;  pOp ++ ;  goto  jump_to_p2 ;  } if  ( ( res ) == ( 0 ) ) { goto  jump_to_p2 ;  break ;  } if  ( ( nStep ) &lt;= ( 0 ) ) { break ;  } nStep -- ;  rc  =  ( int ) ( sqlite3BtreeNext ( pC . uc . pCursor ,  ( int ) ( 0 ) ) ) ;  if  ( ( rc ) != 0 ) { if  ( ( rc ) == ( 101 ) ) { rc  =  ( int ) ( 0 ) ;  goto  seekscan_search_fail ;  } else  { goto  abort_due_to_error ;  } } } break ;  } case  124 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( pC . seekHit ) &lt; ( pOp -&gt; p2 ) ) { pC . seekHit  =  ( ushort ) ( pOp -&gt; p2 ) ;  } else  if  ( ( pC . seekHit ) &gt; ( pOp -&gt; p3 ) ) { pC . seekHit  =  ( ushort ) ( pOp -&gt; p3 ) ;  } break ;  } case  27 :  { if  ( p . apCsr [ pOp -&gt; p1 ] == null ) { goto  jump_to_p2_and_check_for_interrupt ;  } break ;  } case  28 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( pC . seekHit ) &gt;= ( pOp -&gt; p4 . i ) ) break ;  } case  29 :  case  30 :  case  31 :  { int  alreadyExists  =  0 ;  int  takeJump  =  0 ;  int  ii  =  0 ;  VdbeCursor  pC ;  int  res  =  0 ;  UnpackedRecord  pFree ;  UnpackedRecord  pIdxKey ;  UnpackedRecord  r  =  new  UnpackedRecord ( ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pIn3  =  aMem [ pOp -&gt; p3 ] ;  if  ( ( pOp -&gt; p4 . i ) &gt; ( 0 ) ) { r . pKeyInfo  =  pC . pKeyInfo ;  r . nField  =  ( ( ushort ) ( pOp -&gt; p4 . i ) ) ;  r . aMem  =  pIn3 ;  pIdxKey  =  r ;  pFree  =  null ;  } else  { rc  =  ( int ) ( ( ( pIn3 ) . flags &amp; 0x4000 ) ? sqlite3VdbeMemExpandBlob ( pIn3 ) :  0 ) ;  if  ( ( rc ) != 0 ) goto  no_mem ;  pFree  =  pIdxKey  =  sqlite3VdbeAllocUnpackedRecord ( pC . pKeyInfo ) ;  if  ( ( pIdxKey ) == ( null ) ) goto  no_mem ;  sqlite3VdbeRecordUnpack ( pC . pKeyInfo ,  ( int ) ( pIn3 . n ) ,  pIn3 . z ,  pIdxKey ) ;  } pIdxKey . default_rc  =  ( sbyte ) ( 0 ) ;  takeJump  =  ( int ) ( 0 ) ;  if  ( ( pOp -&gt; opcode ) == ( 29 ) ) { for  ( ii  =  ( int ) ( 0 ) ;  ( ii ) &lt; ( pIdxKey . nField ) ;  ii ++ ) { if  ( ( pIdxKey . aMem [ ii ] . flags &amp; 0x0001 ) != 0 ) { takeJump  =  ( int ) ( 1 ) ;  break ;  } } } rc  =  ( int ) ( sqlite3BtreeIndexMoveto ( pC . uc . pCursor ,  pIdxKey ,  &amp; res ) ) ;  if  ( ( pFree ) != null ) sqlite3DbFreeNN ( db ,  pFree ) ;  if  ( rc != 0 ) { goto  abort_due_to_error ;  } pC . seekResult  =  ( int ) ( res ) ;  alreadyExists  =  ( int ) ( ( res ) == ( 0 ) ? 1 :  0 ) ;  pC . nullRow  =  ( byte ) ( 1 - alreadyExists ) ;  pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( pOp -&gt; opcode ) == ( 31 ) ) { if  ( ( alreadyExists ) != 0 ) goto  jump_to_p2 ;  } else  { if  ( ( ( takeJump ) != 0 ) || ( alreadyExists == 0 ) ) goto  jump_to_p2 ;  if  ( ( pOp -&gt; opcode ) == ( 28 ) ) pC . seekHit  =  ( ushort ) ( pOp -&gt; p4 . i ) ;  } break ;  } case  32 :  { VdbeCursor  pC ;  BtCursor  pCrsr ;  int  res  =  0 ;  ulong  iKey  =  0 ;  pIn3  =  aMem [ pOp -&gt; p3 ] ;  if  ( ( pIn3 . flags &amp; ( 0x0004 | 0x0020 ) ) == ( 0 ) ) { sqlite3_value  x  =  ( sqlite3_value ) ( pIn3 [ 0 ] ) ;  applyAffinity ( x ,  ( sbyte ) ( 0x43 ) ,  ( byte ) ( encoding ) ) ;  if  ( ( x . flags &amp; 0x0004 ) == ( 0 ) ) goto  jump_to_p2 ;  iKey  =  ( ulong ) ( x . u . i ) ;  goto  notExistsWithKey ;  } case  33 :  pIn3  =  aMem [ pOp -&gt; p3 ] ;  iKey  =  ( ulong ) ( pIn3 . u . i ) ;  notExistsWithKey :  ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pCrsr  =  pC . uc . pCursor ;  res  =  ( int ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeTableMoveto ( pCrsr ,  ( long ) ( iKey ) ,  ( int ) ( 0 ) ,  &amp; res ) ) ;  pC . movetoTarget  =  ( long ) ( iKey ) ;  pC . nullRow  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . seekResult  =  ( int ) ( res ) ;  if  ( res != 0 ) { if  ( ( pOp -&gt; p2 ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3CorruptError ( ( int ) ( 92477 ) ) ) ;  } else  { goto  jump_to_p2 ;  } } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  125 :  { pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . u . i  =  ( long ) ( p . apCsr [ pOp -&gt; p1 ] . seqCount ++ ) ;  break ;  } case  126 :  { long  v  =  0 ;  VdbeCursor  pC ;  int  res  =  0 ;  int  cnt  =  0 ;  sqlite3_value  pMem ;  VdbeFrame  pFrame ;  v  =  ( long ) ( 0 ) ;  res  =  ( int ) ( 0 ) ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  { if  ( pC . useRandomRowid == 0 ) { rc  =  ( int ) ( sqlite3BtreeLast ( pC . uc . pCursor ,  &amp; res ) ) ;  if  ( rc != 0 ) { goto  abort_due_to_error ;  } if  ( ( res ) != 0 ) { v  =  ( long ) ( 1 ) ;  } else  { v  =  ( long ) ( sqlite3BtreeIntegerKey ( pC . uc . pCursor ) ) ;  if  ( ( v ) &gt;= ( ( long ) ( ( ( ( ulong ) ( 0x7fffffff ) ) &lt;&lt; 32 ) | ( ulong ) ( 0xffffffff ) ) ) ) { pC . useRandomRowid  =  ( uint ) ( 1 ) ;  } else  { v ++ ;  } } } if  ( ( pOp -&gt; p3 ) != 0 ) { if  ( ( p . pFrame ) != null ) { for  ( pFrame  =  p . pFrame ;  pFrame . pParent ;  pFrame  =  pFrame . pParent ) { } pMem  =  pFrame . aMem [ pOp -&gt; p3 ] ;  } else  { pMem  =  aMem [ pOp -&gt; p3 ] ;  } sqlite3VdbeMemIntegerify ( pMem ) ;  if  ( ( ( pMem . u . i ) == ( ( long ) ( ( ( ( ulong ) ( 0x7fffffff ) ) &lt;&lt; 32 ) | ( ulong ) ( 0xffffffff ) ) ) ) || ( ( pC . useRandomRowid ) != 0 ) ) { rc  =  ( int ) ( 13 ) ;  goto  abort_due_to_error ;  } if  ( ( v ) &lt; ( pMem . u . i + 1 ) ) { v  =  ( long ) ( pMem . u . i + 1 ) ;  } pMem . u . i  =  ( long ) ( v ) ;  } if  ( ( pC . useRandomRowid ) != 0 ) { cnt  =  ( int ) ( 0 ) ;  do  { sqlite3_randomness ( ( int ) ( sizeof ( long ) ) ,  &amp; v ) ;  v &amp;= ( long ) ( ( long ) ( ( ( ( ulong ) ( 0x7fffffff ) ) &lt;&lt; 32 ) | ( ulong ) ( 0xffffffff ) ) &gt; &gt; 1 ) ;  v ++ ;  } while  ( ( ( ( rc  =  ( int ) ( sqlite3BtreeTableMoveto ( pC . uc . pCursor ,  ( long ) ( ( ulong ) ( v ) ) ,  ( int ) ( 0 ) ,  &amp; res ) ) ) == ( 0 ) ) &amp;&amp; ( ( res ) == ( 0 ) ) ) &amp;&amp; ( ( ++ cnt ) &lt; ( 100 ) ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( res ) == ( 0 ) ) { rc  =  ( int ) ( 13 ) ;  goto  abort_due_to_error ;  } } pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  } pOut . u . i  =  ( long ) ( v ) ;  break ;  } case  127 :  { sqlite3_value  pData ;  sqlite3_value  pKey ;  VdbeCursor  pC ;  int  seekResult  =  0 ;  sbyte  * zDb ;  Table  pTab ;  BtreePayload  x  =  new  BtreePayload ( ) ;  pData  =  aMem [ pOp -&gt; p2 ] ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pKey  =  aMem [ pOp -&gt; p3 ] ;  x . nKey  =  ( long ) ( pKey . u . i ) ;  if  ( ( ( pOp -&gt; p4type ) == ( - 6 ) ) &amp;&amp; ( ( ( db ) . xUpdateCallback ) != null ) ) { zDb  =  db . aDb [ pC . iDb ] . zDbSName ;  pTab  =  pOp -&gt; p4 . pTab ;  } else  { pTab  =  null ;  zDb  =  null ;  } if  ( ( pOp -&gt; p5 &amp; 0x01 ) != 0 ) p . nChange ++ ;  if  ( ( pOp -&gt; p5 &amp; 0x20 ) != 0 ) db . lastRowid  =  ( long ) ( x . nKey ) ;  x . pData  =  pData . z ;  x . nData  =  ( int ) ( pData . n ) ;  seekResult  =  ( int ) ( ( pOp -&gt; p5 &amp; 0x10 ) ? pC . seekResult :  0 ) ;  if  ( ( pData . flags &amp; 0x4000 ) != 0 ) { x . nZero  =  ( int ) ( pData . u . nZero ) ;  } else  { x . nZero  =  ( int ) ( 0 ) ;  } x . pKey  =  null ;  rc  =  ( int ) ( sqlite3BtreeInsert ( pC . uc . pCursor ,  x ,  ( int ) ( pOp -&gt; p5 &amp; ( 0x08 | 0x02 | 0x80 ) ) ,  ( int ) ( seekResult ) ) ) ;  pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( pTab ) != null ) { db . xUpdateCallback ( db . pUpdateArg ,  ( int ) ( ( pOp -&gt; p5 &amp; 0x04 ) ? 23 :  18 ) ,  zDb ,  pTab . zName ,  ( long ) ( x . nKey ) ) ;  } break ;  } case  128 :  { VdbeCursor  pDest ;  VdbeCursor  pSrc ;  long  iKey  =  0 ;  pDest  =  p . apCsr [ pOp -&gt; p1 ] ;  pSrc  =  p . apCsr [ pOp -&gt; p2 ] ;  iKey  =  ( long ) ( ( pOp -&gt; p3 ) != 0 ? aMem [ pOp -&gt; p3 ] . u . i :  0 ) ;  rc  =  ( int ) ( sqlite3BtreeTransferRow ( pDest . uc . pCursor ,  pSrc . uc . pCursor ,  ( long ) ( iKey ) ) ) ;  if  ( rc != 0 ) goto  abort_due_to_error ;  break ;  } case  129 :  { VdbeCursor  pC ;  sbyte  * zDb ;  Table  pTab ;  int  opflags  =  0 ;  opflags  =  ( int ) ( pOp -&gt; p2 ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( ( pOp -&gt; p4type ) == ( - 6 ) ) &amp;&amp; ( ( ( db ) . xUpdateCallback ) != null ) ) { zDb  =  db . aDb [ pC . iDb ] . zDbSName ;  pTab  =  pOp -&gt; p4 . pTab ;  if  ( ( ( pOp -&gt; p5 &amp; 0x02 ) != 0 ) &amp;&amp; ( ( pC . isTable ) != 0 ) ) { pC . movetoTarget  =  ( long ) ( sqlite3BtreeIntegerKey ( pC . uc . pCursor ) ) ;  } } else  { zDb  =  null ;  pTab  =  null ;  } rc  =  ( int ) ( sqlite3BtreeDelete ( pC . uc . pCursor ,  ( byte ) ( pOp -&gt; p5 ) ) ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  pC . seekResult  =  ( int ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( opflags &amp; 0x01 ) != 0 ) { p . nChange ++ ;  if  ( ( ( ( db . xUpdateCallback ) != null ) &amp;&amp; ( pTab != null ) ) &amp;&amp; ( ( ( pTab ) . tabFlags &amp; 0x00000080 ) == ( 0 ) ) ) { db . xUpdateCallback ( db . pUpdateArg ,  ( int ) ( 9 ) ,  zDb ,  pTab . zName ,  ( long ) ( pC . movetoTarget ) ) ;  } } break ;  } case  130 :  { sqlite3VdbeSetChanges ( db ,  ( long ) ( p . nChange ) ) ;  p . nChange  =  ( long ) ( 0 ) ;  break ;  } case  131 :  { VdbeCursor  pC ;  int  res  =  0 ;  int  nKeyCol  =  0 ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pIn3  =  aMem [ pOp -&gt; p3 ] ;  nKeyCol  =  ( int ) ( pOp -&gt; p4 . i ) ;  res  =  ( int ) ( 0 ) ;  rc  =  ( int ) ( sqlite3VdbeSorterCompare ( pC ,  pIn3 ,  ( int ) ( nKeyCol ) ,  &amp; res ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( res ) != 0 ) goto  jump_to_p2 ;  break ;  } case  132 :  { VdbeCursor  pC ;  pOut  =  aMem [ pOp -&gt; p2 ] ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( sqlite3VdbeSorterRowkey ( pC ,  pOut ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  p . apCsr [ pOp -&gt; p3 ] . cacheStatus  =  ( uint ) ( 0 ) ;  break ;  } case  133 :  { VdbeCursor  pC ;  BtCursor  pCrsr ;  uint  n  =  0 ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pCrsr  =  pC . uc . pCursor ;  n  =  ( uint ) ( sqlite3BtreePayloadSize ( pCrsr ) ) ;  if  ( ( n ) &gt; ( ( uint ) ( db . aLimit [ 0 ] ) ) ) { goto  too_big ;  } rc  =  ( int ) ( sqlite3VdbeMemFromBtreeZeroOffset ( pCrsr ,  ( uint ) ( n ) ,  pOut ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( pOp -&gt; p3 == 0 ) if  ( ( ( ( pOut ) . flags &amp; 0x1000 ) != 0 ) &amp;&amp; ( ( sqlite3VdbeMemMakeWriteable ( pOut ) ) != 0 ) ) { goto  no_mem ;  } break ;  } case  134 :  { VdbeCursor  pC ;  long  v  =  0 ;  sqlite3_vtab  pVtab ;  sqlite3_module  pModule ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( pC . nullRow ) != 0 ) { pOut . flags  =  ( ushort ) ( 0x0001 ) ;  break ;  } else  if  ( ( pC . deferredMoveto ) != 0 ) { v  =  ( long ) ( pC . movetoTarget ) ;  } else  if  ( ( pC . eCurType ) == ( 2 ) ) { pVtab  =  pC . uc . pVCur . pVtab ;  pModule  =  pVtab . pModule ;  rc  =  ( int ) ( pModule . xRowid ( pC . uc . pVCur ,  &amp; v ) ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } else  { rc  =  ( int ) ( sqlite3VdbeCursorRestore ( pC ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( pC . nullRow ) != 0 ) { pOut . flags  =  ( ushort ) ( 0x0001 ) ;  break ;  } v  =  ( long ) ( sqlite3BtreeIntegerKey ( pC . uc . pCursor ) ) ;  } pOut . u . i  =  ( long ) ( v ) ;  break ;  } case  135 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pC . nullRow  =  ( byte ) ( 1 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( pC . eCurType ) == ( 0 ) ) { sqlite3BtreeClearCursor ( pC . uc . pCursor ) ;  } break ;  } case  136 :  case  34 :  { VdbeCursor  pC ;  BtCursor  pCrsr ;  int  res  =  0 ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pCrsr  =  pC . uc . pCursor ;  res  =  ( int ) ( 0 ) ;  if  ( ( pOp -&gt; opcode ) == ( 136 ) ) { pC . seekResult  =  ( int ) ( - 1 ) ;  if  ( ( sqlite3BtreeCursorIsValidNN ( pCrsr ) ) != 0 ) { break ;  } } rc  =  ( int ) ( sqlite3BtreeLast ( pCrsr ,  &amp; res ) ) ;  pC . nullRow  =  ( ( byte ) ( res ) ) ;  pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( pOp -&gt; p2 ) &gt; ( 0 ) ) { if  ( ( res ) != 0 ) goto  jump_to_p2 ;  } break ;  } case  35 :  { VdbeCursor  pC ;  BtCursor  pCrsr ;  int  res  =  0 ;  long  sz  =  0 ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pCrsr  =  pC . uc . pCursor ;  rc  =  ( int ) ( sqlite3BtreeFirst ( pCrsr ,  &amp; res ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( res ) == ( 0 ) ) { sz  =  ( long ) ( sqlite3BtreeRowCountEst ( pCrsr ) ) ;  if  ( ( ( sz ) &gt;= ( 0 ) ) &amp;&amp; ( ( sqlite3LogEst ( ( ulong ) ( sz ) ) ) &lt; ( pOp -&gt; p3 ) ) ) res  =  ( int ) ( 1 ) ;  } if  ( ( res ) != 0 ) goto  jump_to_p2 ;  break ;  } case  36 :  case  37 :  { p . aCounter [ 2 ] ++ ;  } case  38 :  { VdbeCursor  pC ;  BtCursor  pCrsr ;  int  res  =  0 ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  res  =  ( int ) ( 1 ) ;  if  ( ( ( ( pC ) . eCurType ) == ( 1 ) ) ) { rc  =  ( int ) ( sqlite3VdbeSorterRewind ( pC ,  &amp; res ) ) ;  } else  { pCrsr  =  pC . uc . pCursor ;  rc  =  ( int ) ( sqlite3BtreeFirst ( pCrsr ,  &amp; res ) ) ;  pC . deferredMoveto  =  ( byte ) ( 0 ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  pC . nullRow  =  ( ( byte ) ( res ) ) ;  if  ( ( res ) != 0 ) goto  jump_to_p2 ;  break ;  } case  3 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( sqlite3VdbeSorterNext ( db ,  pC ) ) ;  goto  next_tail ;  case  4 :  case  5 :  ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( pOp -&gt; p4 . xAdvance ( pC . uc . pCursor ,  ( int ) ( pOp -&gt; p3 ) ) ) ;  next_tail :  ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( rc ) == ( 0 ) ) { pC . nullRow  =  ( byte ) ( 0 ) ;  p . aCounter [ pOp -&gt; p5 ] ++ ;  goto  jump_to_p2_and_check_for_interrupt ;  } if  ( rc != 101 ) goto  abort_due_to_error ;  rc  =  ( int ) ( 0 ) ;  pC . nullRow  =  ( byte ) ( 1 ) ;  goto  check_for_interrupt ;  } case  137 :  { VdbeCursor  pC ;  BtreePayload  x  =  new  BtreePayload ( ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pIn2  =  aMem [ pOp -&gt; p2 ] ;  if  ( ( pOp -&gt; p5 &amp; 0x01 ) != 0 ) p . nChange ++ ;  rc  =  ( int ) ( ( ( pIn2 ) . flags &amp; 0x4000 ) ? sqlite3VdbeMemExpandBlob ( pIn2 ) :  0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  x . nKey  =  ( long ) ( pIn2 . n ) ;  x . pKey  =  pIn2 . z ;  x . aMem  =  aMem [ pOp -&gt; p3 ] ;  x . nMem  =  ( ( ushort ) ( pOp -&gt; p4 . i ) ) ;  rc  =  ( int ) ( sqlite3BtreeInsert ( pC . uc . pCursor ,  x ,  ( int ) ( pOp -&gt; p5 &amp; ( 0x08 | 0x02 | 0x80 ) ) ,  ( int ) ( ( pOp -&gt; p5 &amp; 0x10 ) ? pC . seekResult :  0 ) ) ) ;  pC . cacheStatus  =  ( uint ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  138 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pIn2  =  aMem [ pOp -&gt; p2 ] ;  rc  =  ( int ) ( ( ( pIn2 ) . flags &amp; 0x4000 ) ? sqlite3VdbeMemExpandBlob ( pIn2 ) :  0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  rc  =  ( int ) ( sqlite3VdbeSorterWrite ( pC ,  pIn2 ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  139 :  { VdbeCursor  pC ;  BtCursor  pCrsr ;  int  res  =  0 ;  UnpackedRecord  r  =  new  UnpackedRecord ( ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pCrsr  =  pC . uc . pCursor ;  r . pKeyInfo  =  pC . pKeyInfo ;  r . nField  =  ( ( ushort ) ( pOp -&gt; p3 ) ) ;  r . default_rc  =  ( sbyte ) ( 0 ) ;  r . aMem  =  aMem [ pOp -&gt; p2 ] ;  rc  =  ( int ) ( sqlite3BtreeIndexMoveto ( pCrsr ,  r ,  &amp; res ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( ( res ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3BtreeDelete ( pCrsr ,  ( byte ) ( 0x04 ) ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } else  if  ( ( ( pOp -&gt; p5 ) != 0 ) &amp;&amp; ( sqlite3WritableSchema ( db ) == 0 ) ) { rc  =  ( int ) ( sqlite3ReportError ( ( int ) ( 11 | ( 3 &lt;&lt; 8 ) ) ,  ( int ) ( 93533 ) ,  "index corruption" ) ) ;  goto  abort_due_to_error ;  } pC . cacheStatus  =  ( uint ) ( 0 ) ;  pC . seekResult  =  ( int ) ( 0 ) ;  break ;  } case  140 :  case  141 :  { VdbeCursor  pC ;  VdbeCursor  pTabCur ;  long  rowid  =  0 ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( sqlite3VdbeCursorRestore ( pC ) ) ;  if  ( ( rc != 0 ) ) goto  abort_due_to_error ;  if  ( pC . nullRow == 0 ) { rowid  =  ( long ) ( 0 ) ;  rc  =  ( int ) ( sqlite3VdbeIdxRowid ( db ,  pC . uc . pCursor ,  &amp; rowid ) ) ;  if  ( rc != 0 ) { goto  abort_due_to_error ;  } if  ( ( pOp -&gt; opcode ) == ( 140 ) ) { pTabCur  =  p . apCsr [ pOp -&gt; p3 ] ;  pTabCur . nullRow  =  ( byte ) ( 0 ) ;  pTabCur . movetoTarget  =  ( long ) ( rowid ) ;  pTabCur . deferredMoveto  =  ( byte ) ( 1 ) ;  pTabCur . ub . aAltMap  =  pOp -&gt; p4 . ai ;  pTabCur . pAltCursor  =  pC ;  } else  { pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . u . i  =  ( long ) ( rowid ) ;  } } else  { sqlite3VdbeMemSetNull ( aMem [ pOp -&gt; p2 ] ) ;  } break ;  } case  142 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( pC . deferredMoveto ) != 0 ) { rc  =  ( int ) ( sqlite3VdbeFinishMoveto ( pC ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } break ;  } case  39 :  case  40 :  case  41 :  case  42 :  { VdbeCursor  pC ;  int  res  =  0 ;  UnpackedRecord  r  =  new  UnpackedRecord ( ) ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  r . pKeyInfo  =  pC . pKeyInfo ;  r . nField  =  ( ( ushort ) ( pOp -&gt; p4 . i ) ) ;  if  ( ( pOp -&gt; opcode ) &lt; ( 41 ) ) { r . default_rc  =  ( sbyte ) ( - 1 ) ;  } else  { r . default_rc  =  ( sbyte ) ( 0 ) ;  } r . aMem  =  aMem [ pOp -&gt; p3 ] ;  { long  nCellKey  =  ( long ) ( 0 ) ;  BtCursor  pCur ;  sqlite3_value  m  =  new  sqlite3_value ( ) ;  pCur  =  pC . uc . pCursor ;  nCellKey  =  ( long ) ( sqlite3BtreePayloadSize ( pCur ) ) ;  if  ( ( ( nCellKey ) &lt;= ( 0 ) ) || ( ( nCellKey ) &gt; ( 0x7fffffff ) ) ) { rc  =  ( int ) ( sqlite3CorruptError ( ( int ) ( 93737 ) ) ) ;  goto  abort_due_to_error ;  } sqlite3VdbeMemInit ( m ,  db ,  ( ushort ) ( 0 ) ) ;  rc  =  ( int ) ( sqlite3VdbeMemFromBtreeZeroOffset ( pCur ,  ( uint ) ( nCellKey ) ,  m ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  res  =  ( int ) ( sqlite3VdbeRecordCompareWithSkip ( ( int ) ( m . n ) ,  m . z ,  r ,  ( int ) ( 0 ) ) ) ;  sqlite3VdbeMemRelease ( m ) ;  } if  ( ( pOp -&gt; opcode &amp; 1 ) == ( 41 &amp; 1 ) ) { res  =  ( int ) ( - res ) ;  } else  { res ++ ;  } if  ( ( res ) &gt; ( 0 ) ) goto  jump_to_p2 ;  break ;  } case  143 :  { int  iMoved  =  0 ;  int  iDb  =  0 ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . flags  =  ( ushort ) ( 0x0001 ) ;  if  ( ( db . nVdbeRead ) &gt; ( db . nVDestroy + 1 ) ) { rc  =  ( int ) ( 6 ) ;  p . errorAction  =  ( byte ) ( 2 ) ;  goto  abort_due_to_error ;  } else  { iDb  =  ( int ) ( pOp -&gt; p3 ) ;  iMoved  =  ( int ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeDropTable ( db . aDb [ iDb ] . pBt ,  ( int ) ( pOp -&gt; p1 ) ,  &amp; iMoved ) ) ;  pOut . flags  =  ( ushort ) ( 0x0004 ) ;  pOut . u . i  =  ( long ) ( iMoved ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  if  ( iMoved != 0 ) { sqlite3RootPageMoved ( db ,  ( int ) ( iDb ) ,  ( uint ) ( iMoved ) ,  ( uint ) ( pOp -&gt; p1 ) ) ;  resetSchemaOnFault  =  ( byte ) ( iDb + 1 ) ;  } } break ;  } case  144 :  { long  nChange  =  0 ;  nChange  =  ( long ) ( 0 ) ;  rc  =  ( int ) ( sqlite3BtreeClearTable ( db . aDb [ pOp -&gt; p2 ] . pBt ,  ( int ) ( ( uint ) ( pOp -&gt; p1 ) ) ,  &amp; nChange ) ) ;  if  ( ( pOp -&gt; p3 ) != 0 ) { p . nChange += ( long ) ( nChange ) ;  if  ( ( pOp -&gt; p3 ) &gt; ( 0 ) ) { aMem [ pOp -&gt; p3 ] . u . i += ( long ) ( nChange ) ;  } } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  145 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( ( ( pC ) . eCurType ) == ( 1 ) ) ) { sqlite3VdbeSorterReset ( db ,  pC . uc . pSorter ) ;  } else  { rc  =  ( int ) ( sqlite3BtreeClearTableOfCursor ( pC . uc . pCursor ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } break ;  } case  146 :  { uint  pgno  =  0 ;  Db  pDb ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pgno  =  ( uint ) ( 0 ) ;  pDb  =  db . aDb [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( sqlite3BtreeCreateTable ( pDb . pBt ,  &amp; pgno ,  ( int ) ( pOp -&gt; p3 ) ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  pOut . u . i  =  ( long ) ( pgno ) ;  break ;  } case  147 :  { db . nSqlExec ++ ;  rc  =  ( int ) ( sqlite3_exec ( db ,  pOp -&gt; p4 . z ,  null ,  null ,  null ) ) ;  db . nSqlExec -- ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  148 :  { int  iDb  =  0 ;  sbyte  * zSchema ;  sbyte  * zSql ;  InitData  initData  =  new  InitData ( ) ;  iDb  =  ( int ) ( pOp -&gt; p1 ) ;  if  ( ( pOp -&gt; p4 . z ) == ( null ) ) { sqlite3SchemaClear ( db . aDb [ iDb ] . pSchema ) ;  db . mDbFlags &amp;= ( uint ) ( ~ 0x0010 ) ;  rc  =  ( int ) ( sqlite3InitOne ( db ,  ( int ) ( iDb ) ,  &amp; p . zErrMsg ,  ( uint ) ( pOp -&gt; p5 ) ) ) ;  db . mDbFlags |= ( uint ) ( 0x0001 ) ;  p . expired  =  ( uint ) ( 0 ) ;  } else  { zSchema  =  "sqlite_master" ;  initData . db  =  db ;  initData . iDb  =  ( int ) ( iDb ) ;  initData . pzErrMsg  =  &amp; p . zErrMsg ;  initData . mInitFlags  =  ( uint ) ( 0 ) ;  initData . mxPage  =  ( uint ) ( sqlite3BtreeLastPage ( db . aDb [ iDb ] . pBt ) ) ;  zSql  =  sqlite3MPrintf ( db ,  "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid" ,  db . aDb [ iDb ] . zDbSName ,  zSchema ,  pOp -&gt; p4 . z ) ;  if  ( ( zSql ) == ( null ) ) { rc  =  ( int ) ( 7 ) ;  } else  { db . init . busy  =  ( byte ) ( 1 ) ;  initData . rc  =  ( int ) ( 0 ) ;  initData . nInitRow  =  ( uint ) ( 0 ) ;  rc  =  ( int ) ( sqlite3_exec ( db ,  zSql ,  sqlite3InitCallback ,  initData ,  null ) ) ;  if  ( ( rc ) == ( 0 ) ) rc  =  ( int ) ( initData . rc ) ;  if  ( ( ( rc ) == ( 0 ) ) &amp;&amp; ( ( initData . nInitRow ) == ( 0 ) ) ) { rc  =  ( int ) ( sqlite3CorruptError ( ( int ) ( 93989 ) ) ) ;  } sqlite3DbFreeNN ( db ,  zSql ) ;  db . init . busy  =  ( byte ) ( 0 ) ;  } } if  ( ( rc ) != 0 ) { sqlite3ResetAllSchemasOfConnection ( db ) ;  if  ( ( rc ) == ( 7 ) ) { goto  no_mem ;  } goto  abort_due_to_error ;  } break ;  } case  149 :  { rc  =  ( int ) ( sqlite3AnalysisLoad ( db ,  ( int ) ( pOp -&gt; p1 ) ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  150 :  { sqlite3UnlinkAndDeleteTable ( db ,  ( int ) ( pOp -&gt; p1 ) ,  pOp -&gt; p4 . z ) ;  break ;  } case  151 :  { sqlite3UnlinkAndDeleteIndex ( db ,  ( int ) ( pOp -&gt; p1 ) ,  pOp -&gt; p4 . z ) ;  break ;  } case  152 :  { sqlite3UnlinkAndDeleteTrigger ( db ,  ( int ) ( pOp -&gt; p1 ) ,  pOp -&gt; p4 . z ) ;  break ;  } case  154 :  { int  nRoot  =  0 ;  uint  * aRoot ;  int  nErr  =  0 ;  sbyte  * z ;  sqlite3_value  pnErr ;  nRoot  =  ( int ) ( pOp -&gt; p2 ) ;  aRoot  =  pOp -&gt; p4 . ai ;  pnErr  =  aMem [ pOp -&gt; p3 ] ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  z  =  sqlite3BtreeIntegrityCheck ( db ,  db . aDb [ pOp -&gt; p5 ] . pBt ,  &amp; aRoot [ 1 ] ,  ( int ) ( nRoot ) ,  ( int ) ( ( int ) ( pnErr . u . i ) + 1 ) ,  &amp; nErr ) ;  sqlite3VdbeMemSetNull ( pIn1 ) ;  if  ( ( nErr ) == ( 0 ) ) { } else  if  ( ( z ) == ( null ) ) { goto  no_mem ;  } else  { pnErr . u . i -= ( long ) ( nErr - 1 ) ;  sqlite3VdbeMemSetStr ( pIn1 ,  z ,  ( long ) ( - 1 ) ,  ( byte ) ( 1 ) ,  sqlite3_free ) ;  } sqlite3VdbeChangeEncoding ( pIn1 ,  ( int ) ( encoding ) ) ;  goto  check_for_interrupt ;  } case  155 :  { pIn1  =  aMem [ pOp -&gt; p1 ] ;  pIn2  =  aMem [ pOp -&gt; p2 ] ;  if  ( ( pIn1 . flags &amp; 0x0010 ) == ( 0 ) ) { if  ( ( sqlite3VdbeMemSetRowSet ( pIn1 ) ) != 0 ) goto  no_mem ;  } sqlite3RowSetInsert ( ( RowSet ) ( pIn1 . z ) ,  ( long ) ( pIn2 . u . i ) ) ;  break ;  } case  45 :  { long  val  =  0 ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  if  ( ( ( pIn1 . flags &amp; 0x0010 ) == ( 0 ) ) || ( ( sqlite3RowSetNext ( ( RowSet ) ( pIn1 . z ) ,  &amp; val ) ) == ( 0 ) ) ) { sqlite3VdbeMemSetNull ( pIn1 ) ;  goto  jump_to_p2_and_check_for_interrupt ;  } else  { sqlite3VdbeMemSetInt64 ( aMem [ pOp -&gt; p3 ] ,  ( long ) ( val ) ) ;  } goto  check_for_interrupt ;  } case  46 :  { int  iSet  =  0 ;  int  exists  =  0 ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  pIn3  =  aMem [ pOp -&gt; p3 ] ;  iSet  =  ( int ) ( pOp -&gt; p4 . i ) ;  if  ( ( pIn1 . flags &amp; 0x0010 ) == ( 0 ) ) { if  ( ( sqlite3VdbeMemSetRowSet ( pIn1 ) ) != 0 ) goto  no_mem ;  } if  ( ( iSet ) != 0 ) { exists  =  ( int ) ( sqlite3RowSetTest ( ( RowSet ) ( pIn1 . z ) ,  ( int ) ( iSet ) ,  ( long ) ( pIn3 . u . i ) ) ) ;  if  ( ( exists ) != 0 ) goto  jump_to_p2 ;  } if  ( ( iSet ) &gt;= ( 0 ) ) { sqlite3RowSetInsert ( ( RowSet ) ( pIn1 . z ) ,  ( long ) ( pIn3 . u . i ) ) ;  } break ;  } case  47 :  { int  nMem  =  0 ;  int  nByte  =  0 ;  sqlite3_value  pRt ;  sqlite3_value  pMem ;  sqlite3_value  pEnd ;  VdbeFrame  pFrame ;  SubProgram * pProgram ;  void  * t ;  pProgram  =  pOp -&gt; p4 . pProgram ;  pRt  =  aMem [ pOp -&gt; p3 ] ;  if  ( ( pOp -&gt; p5 ) != 0 ) { t  =  pProgram -&gt; token ;  for  ( pFrame  =  p . pFrame ;  ( ( pFrame ) != null ) &amp;&amp; ( pFrame . token != t ) ;  pFrame  =  pFrame . pParent ) { } if  ( ( pFrame ) != null ) break ;  } if  ( ( p . nFrame ) &gt;= ( db . aLimit [ 10 ] ) ) { rc  =  ( int ) ( 1 ) ;  sqlite3VdbeError ( p ,  "too many levels of trigger recursion" ) ;  goto  abort_due_to_error ;  } if  ( ( pRt . flags &amp; 0x0010 ) == ( 0 ) ) { nMem  =  ( int ) ( pProgram -&gt; nMem + pProgram -&gt; nCsr ) ;  if  ( ( pProgram -&gt; nCsr ) == ( 0 ) ) nMem ++ ;  nByte  =  ( int ) ( ( ( ( sizeof ( VdbeFrame ) ) + 7 ) &amp; ~ 7 ) + nMem * sizeof ( sqlite3_value ) + pProgram -&gt; nCsr * sizeof ( VdbeCursor ) + ( pProgram -&gt; nOp + 7 ) / 8 ) ;  pFrame  =  sqlite3DbMallocZero ( db ,  ( ulong ) ( nByte ) ) ;  if  ( pFrame == null ) { goto  no_mem ;  } sqlite3VdbeMemRelease ( pRt ) ;  pRt . flags  =  ( ushort ) ( 0x0010 | 0x0400 ) ;  pRt . z  =  ( sbyte  * ) ( pFrame ) ;  pRt . n  =  ( int ) ( nByte ) ;  pRt . xDel  =  sqlite3VdbeFrameMemDel ;  pFrame . v  =  p ;  pFrame . nChildMem  =  ( int ) ( nMem ) ;  pFrame . nChildCsr  =  ( int ) ( pProgram -&gt; nCsr ) ;  pFrame . pc  =  ( ( int ) ( pOp - aOp ) ) ;  pFrame . aMem  =  p . aMem ;  pFrame . nMem  =  ( int ) ( p . nMem ) ;  pFrame . apCsr  =  p . apCsr ;  pFrame . nCursor  =  ( int ) ( p . nCursor ) ;  pFrame . aOp  =  p . aOp ;  pFrame . nOp  =  ( int ) ( p . nOp ) ;  pFrame . token  =  pProgram -&gt; token ;  pEnd  =  ( ( sqlite3_value ) ( &amp; ( ( byte  * ) ( pFrame ) ) [ ( ( ( sizeof ( VdbeFrame ) ) + 7 ) &amp; ~ 7 ) ] ) ) [ pFrame . nChildMem ] ;  for  ( pMem  =  ( ( sqlite3_value ) ( &amp; ( ( byte  * ) ( pFrame ) ) [ ( ( ( sizeof ( VdbeFrame ) ) + 7 ) &amp; ~ 7 ) ] ) ) ;  pMem != pEnd ;  pMem ++ ) { pMem . flags  =  ( ushort ) ( 0x0080 ) ;  pMem . db  =  db ;  } } else  { pFrame  =  ( VdbeFrame ) ( pRt . z ) ;  } p . nFrame ++ ;  pFrame . pParent  =  p . pFrame ;  pFrame . lastRowid  =  ( long ) ( db . lastRowid ) ;  pFrame . nChange  =  ( long ) ( p . nChange ) ;  pFrame . nDbChange  =  ( long ) ( p . db . nChange ) ;  pFrame . pAuxData  =  p . pAuxData ;  p . pAuxData  =  null ;  p . nChange  =  ( long ) ( 0 ) ;  p . pFrame  =  pFrame ;  p . aMem  =  aMem  =  ( ( sqlite3_value ) ( &amp; ( ( byte  * ) ( pFrame ) ) [ ( ( ( sizeof ( VdbeFrame ) ) + 7 ) &amp; ~ 7 ) ] ) ) ;  p . nMem  =  ( int ) ( pFrame . nChildMem ) ;  p . nCursor  =  ( int ) ( ( ushort ) ( pFrame . nChildCsr ) ) ;  p . apCsr  =  ( VdbeCursor ) ( aMem [ p . nMem ] ) ;  pFrame . aOnce  =  ( byte  * ) ( p . apCsr [ pProgram -&gt; nCsr ] ) ;  CRuntime . memset ( pFrame . aOnce ,  ( int ) ( 0 ) ,  ( ulong ) ( ( pProgram -&gt; nOp + 7 ) / 8 ) ) ;  p . aOp  =  aOp  =  pProgram -&gt; aOp ;  p . nOp  =  ( int ) ( pProgram -&gt; nOp ) ;  pOp  =  &amp; aOp [ - 1 ] ;  goto  check_for_interrupt ;  } case  156 :  { VdbeFrame  pFrame ;  sqlite3_value  pIn ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pFrame  =  p . pFrame ;  pIn  =  pFrame . aMem [ pOp -&gt; p1 + pFrame . aOp [ pFrame . pc ] . p1 ] ;  sqlite3VdbeMemShallowCopy ( pOut ,  pIn ,  ( int ) ( 0x1000 ) ) ;  break ;  } case  157 :  { if  ( ( db . flags &amp; 0x00080000 ) != 0 ) { db . nDeferredImmCons += ( long ) ( pOp -&gt; p2 ) ;  } else  if  ( ( pOp -&gt; p1 ) != 0 ) { db . nDeferredCons += ( long ) ( pOp -&gt; p2 ) ;  } else  { p . nFkConstraint += ( long ) ( pOp -&gt; p2 ) ;  } break ;  } case  48 :  { if  ( ( pOp -&gt; p1 ) != 0 ) { if  ( ( ( db . nDeferredCons ) == ( 0 ) ) &amp;&amp; ( ( db . nDeferredImmCons ) == ( 0 ) ) ) goto  jump_to_p2 ;  } else  { if  ( ( ( p . nFkConstraint ) == ( 0 ) ) &amp;&amp; ( ( db . nDeferredImmCons ) == ( 0 ) ) ) goto  jump_to_p2 ;  } break ;  } case  158 :  { VdbeFrame  pFrame ;  if  ( ( p . pFrame ) != null ) { for  ( pFrame  =  p . pFrame ;  pFrame . pParent ;  pFrame  =  pFrame . pParent ) { } pIn1  =  pFrame . aMem [ pOp -&gt; p1 ] ;  } else  { pIn1  =  aMem [ pOp -&gt; p1 ] ;  } sqlite3VdbeMemIntegerify ( pIn1 ) ;  pIn2  =  aMem [ pOp -&gt; p2 ] ;  sqlite3VdbeMemIntegerify ( pIn2 ) ;  if  ( ( pIn1 . u . i ) &lt; ( pIn2 . u . i ) ) { pIn1 . u . i  =  ( long ) ( pIn2 . u . i ) ;  } break ;  } case  49 :  { pIn1  =  aMem [ pOp -&gt; p1 ] ;  if  ( ( pIn1 . u . i ) &gt; ( 0 ) ) { pIn1 . u . i -= ( long ) ( pOp -&gt; p3 ) ;  goto  jump_to_p2 ;  } break ;  } case  159 :  { long  x  =  0 ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  pIn3  =  aMem [ pOp -&gt; p3 ] ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  x  =  ( long ) ( pIn1 . u . i ) ;  if  ( ( ( x ) &lt;= ( 0 ) ) || ( ( sqlite3AddInt64 ( &amp; x ,  ( long ) ( ( pIn3 . u . i ) &gt; ( 0 ) ? pIn3 . u . i :  0 ) ) ) != 0 ) ) { pOut . u . i  =  ( long ) ( - 1 ) ;  } else  { pOut . u . i  =  ( long ) ( x ) ;  } break ;  } case  59 :  { pIn1  =  aMem [ pOp -&gt; p1 ] ;  if  ( ( pIn1 . u . i ) != 0 ) { if  ( ( pIn1 . u . i ) &gt; ( 0 ) ) pIn1 . u . i -- ;  goto  jump_to_p2 ;  } break ;  } case  60 :  { pIn1  =  aMem [ pOp -&gt; p1 ] ;  if  ( ( pIn1 . u . i ) &gt; ( ( ( long ) ( - 1 ) ) - ( 0xffffffff | ( ( ( long ) ( 0x7fffffff ) ) &lt;&lt; 32 ) ) ) ) pIn1 . u . i -- ;  if  ( ( pIn1 . u . i ) == ( 0 ) ) goto  jump_to_p2 ;  break ;  } case  160 :  case  161 :  { int  n  =  0 ;  sqlite3_context  pCtx ;  n  =  ( int ) ( pOp -&gt; p5 ) ;  pCtx  =  sqlite3DbMallocRawNN ( db ,  ( ulong ) ( n * sizeof ( sqlite3_value ) + ( sizeof ( sqlite3_context ) + sizeof ( sqlite3_value ) - sizeof ( sqlite3_value ) ) ) ) ;  if  ( ( pCtx ) == ( null ) ) goto  no_mem ;  pCtx . pMem  =  null ;  pCtx . pOut  =  ( pCtx . argv [ n ] ) ;  sqlite3VdbeMemInit ( pCtx . pOut ,  db ,  ( ushort ) ( 0x0001 ) ) ;  pCtx . pFunc  =  pOp -&gt; p4 . pFunc ;  pCtx . iOp  =  ( ( int ) ( pOp - aOp ) ) ;  pCtx . pVdbe  =  p ;  pCtx . skipFlag  =  ( byte ) ( 0 ) ;  pCtx . isError  =  ( int ) ( 0 ) ;  pCtx . argc  =  ( byte ) ( n ) ;  pOp -&gt; p4type  =  ( sbyte ) ( - 16 ) ;  pOp -&gt; p4 . pCtx  =  pCtx ;  pOp -&gt; opcode  =  ( byte ) ( 162 ) ;  } case  162 :  { int  i  =  0 ;  sqlite3_context  pCtx ;  sqlite3_value  pMem ;  pCtx  =  pOp -&gt; p4 . pCtx ;  pMem  =  aMem [ pOp -&gt; p3 ] ;  if  ( pCtx . pMem != pMem ) { pCtx . pMem  =  pMem ;  for  ( i  =  ( int ) ( pCtx . argc - 1 ) ;  ( i ) &gt;= ( 0 ) ;  i -- ) { pCtx . argv [ i ]  =  aMem [ pOp -&gt; p2 + i ] ;  } } pMem . n ++ ;  if  ( ( pOp -&gt; p1 ) != 0 ) { pCtx . pFunc . xInverse ( pCtx ,  ( int ) ( pCtx . argc ) ,  pCtx . argv ) ;  } else  pCtx . pFunc . xSFunc ( pCtx ,  ( int ) ( pCtx . argc ) ,  pCtx . argv ) ;  if  ( ( pCtx . isError ) != 0 ) { if  ( ( pCtx . isError ) &gt; ( 0 ) ) { sqlite3VdbeError ( p ,  "%s" ,  sqlite3_value_text ( pCtx . pOut ) ) ;  rc  =  ( int ) ( pCtx . isError ) ;  } if  ( ( pCtx . skipFlag ) != 0 ) { i  =  ( int ) ( pOp [ - 1 ] . p1 ) ;  if  ( ( i ) != 0 ) sqlite3VdbeMemSetInt64 ( aMem [ i ] ,  ( long ) ( 1 ) ) ;  pCtx . skipFlag  =  ( byte ) ( 0 ) ;  } sqlite3VdbeMemRelease ( pCtx . pOut ) ;  pCtx . pOut . flags  =  ( ushort ) ( 0x0001 ) ;  pCtx . isError  =  ( int ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } break ;  } case  163 :  case  164 :  { sqlite3_value  pMem ;  pMem  =  aMem [ pOp -&gt; p1 ] ;  if  ( ( pOp -&gt; p3 ) != 0 ) { rc  =  ( int ) ( sqlite3VdbeMemAggValue ( pMem ,  aMem [ pOp -&gt; p3 ] ,  pOp -&gt; p4 . pFunc ) ) ;  pMem  =  aMem [ pOp -&gt; p3 ] ;  } else  { rc  =  ( int ) ( sqlite3VdbeMemFinalize ( pMem ,  pOp -&gt; p4 . pFunc ) ) ;  } if  ( ( rc ) != 0 ) { sqlite3VdbeError ( p ,  "%s" ,  sqlite3_value_text ( pMem ) ) ;  goto  abort_due_to_error ;  } sqlite3VdbeChangeEncoding ( pMem ,  ( int ) ( encoding ) ) ;  if  ( ( sqlite3VdbeMemTooBig ( pMem ) ) != 0 ) { goto  too_big ;  } break ;  } case  6 :  { int  i  =  0 ;  int  * aRes  =  stackalloc  int [ 3 ] ;  sqlite3_value  pMem ;  aRes [ 0 ]  =  ( int ) ( 0 ) ;  aRes [ 1 ]  =  ( int ) ( aRes [ 2 ]  =  ( int ) ( - 1 ) ) ;  rc  =  ( int ) ( sqlite3Checkpoint ( db ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( pOp -&gt; p2 ) ,  &amp; aRes [ 1 ] ,  &amp; aRes [ 2 ] ) ) ;  if  ( ( rc ) != 0 ) { if  ( rc != 5 ) goto  abort_due_to_error ;  rc  =  ( int ) ( 0 ) ;  aRes [ 0 ]  =  ( int ) ( 1 ) ;  } for  ( i  =  ( int ) ( 0 ) ,  pMem  =  aMem [ pOp -&gt; p3 ] ;  ( i ) &lt; ( 3 ) ;  i ++ ,  pMem ++ ) { sqlite3VdbeMemSetInt64 ( pMem ,  ( long ) ( aRes [ i ] ) ) ;  } break ;  } case  7 :  { Btree  pBt ;  Pager  pPager ;  int  eNew  =  0 ;  int  eOld  =  0 ;  sbyte  * zFilename ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  eNew  =  ( int ) ( pOp -&gt; p3 ) ;  pBt  =  db . aDb [ pOp -&gt; p1 ] . pBt ;  pPager  =  sqlite3BtreePager ( pBt ) ;  eOld  =  ( int ) ( sqlite3PagerGetJournalMode ( pPager ) ) ;  if  ( ( eNew ) == ( - 1 ) ) eNew  =  ( int ) ( eOld ) ;  if  ( sqlite3PagerOkToChangeJournalMode ( pPager ) == 0 ) eNew  =  ( int ) ( eOld ) ;  zFilename  =  sqlite3PagerFilename ( pPager ,  ( int ) ( 1 ) ) ;  if  ( ( ( eNew ) == ( 5 ) ) &amp;&amp; ( ( ( sqlite3Strlen30 ( zFilename ) ) == ( 0 ) ) || ( sqlite3PagerWalSupported ( pPager ) == 0 ) ) ) { eNew  =  ( int ) ( eOld ) ;  } if  ( ( eNew != eOld ) &amp;&amp; ( ( ( eOld ) == ( 5 ) ) || ( ( eNew ) == ( 5 ) ) ) ) { if  ( ( db . autoCommit == 0 ) || ( ( db . nVdbeRead ) &gt; ( 1 ) ) ) { rc  =  ( int ) ( 1 ) ;  sqlite3VdbeError ( p ,  "cannot change %s wal mode from within a transaction" ,  ( ( eNew ) == ( 5 ) ? "into" :  "out of" ) ) ;  goto  abort_due_to_error ;  } else  { if  ( ( eOld ) == ( 5 ) ) { rc  =  ( int ) ( sqlite3PagerCloseWal ( pPager ,  db ) ) ;  if  ( ( rc ) == ( 0 ) ) { sqlite3PagerSetJournalMode ( pPager ,  ( int ) ( eNew ) ) ;  } } else  if  ( ( eOld ) == ( 4 ) ) { sqlite3PagerSetJournalMode ( pPager ,  ( int ) ( 2 ) ) ;  } if  ( ( rc ) == ( 0 ) ) { rc  =  ( int ) ( sqlite3BtreeSetVersion ( pBt ,  ( int ) ( ( eNew ) == ( 5 ) ? 2 :  1 ) ) ) ;  } } } if  ( ( rc ) != 0 ) eNew  =  ( int ) ( eOld ) ;  eNew  =  ( int ) ( sqlite3PagerSetJournalMode ( pPager ,  ( int ) ( eNew ) ) ) ;  pOut . flags  =  ( ushort ) ( 0x0002 | 0x0800 | 0x0200 ) ;  pOut . z  =  sqlite3JournalModename ( ( int ) ( eNew ) ) ;  pOut . n  =  ( int ) ( sqlite3Strlen30 ( pOut . z ) ) ;  pOut . enc  =  ( byte ) ( 1 ) ;  sqlite3VdbeChangeEncoding ( pOut ,  ( int ) ( encoding ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  8 :  { rc  =  ( int ) ( sqlite3RunVacuum ( &amp; p . zErrMsg ,  db ,  ( int ) ( pOp -&gt; p1 ) ,  ( pOp -&gt; p2 ) != 0 ? aMem [ pOp -&gt; p2 ] :  null ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  61 :  { Btree  pBt ;  pBt  =  db . aDb [ pOp -&gt; p1 ] . pBt ;  rc  =  ( int ) ( sqlite3BtreeIncrVacuum ( pBt ) ) ;  if  ( ( rc ) != 0 ) { if  ( rc != 101 ) goto  abort_due_to_error ;  rc  =  ( int ) ( 0 ) ;  goto  jump_to_p2 ;  } break ;  } case  165 :  { if  ( pOp -&gt; p1 == 0 ) { sqlite3ExpirePreparedStatements ( db ,  ( int ) ( pOp -&gt; p2 ) ) ;  } else  { p . expired  =  ( uint ) ( pOp -&gt; p2 + 1 ) ;  } break ;  } case  166 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  sqlite3BtreeCursorPin ( pC . uc . pCursor ) ;  break ;  } case  167 :  { VdbeCursor  pC ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  sqlite3BtreeCursorUnpin ( pC . uc . pCursor ) ;  break ;  } case  168 :  { byte  isWriteLock  =  ( byte ) ( pOp -&gt; p3 ) ;  if  ( ( ( isWriteLock ) != 0 ) || ( ( 0 ) == ( db . flags &amp; 0x00000400 ) ) ) { int  p1  =  ( int ) ( pOp -&gt; p1 ) ;  rc  =  ( int ) ( sqlite3BtreeLockTable ( db . aDb [ p1 ] . pBt ,  ( int ) ( pOp -&gt; p2 ) ,  ( byte ) ( isWriteLock ) ) ) ;  if  ( ( rc ) != 0 ) { if  ( ( rc &amp; 0xFF ) == ( 6 ) ) { sbyte  * z  =  pOp -&gt; p4 . z ;  sqlite3VdbeError ( p ,  "database table is locked: %s" ,  z ) ;  } goto  abort_due_to_error ;  } } break ;  } case  169 :  { VTable  pVTab ;  pVTab  =  pOp -&gt; p4 . pVtab ;  rc  =  ( int ) ( sqlite3VtabBegin ( db ,  pVTab ) ) ;  if  ( ( pVTab ) != null ) sqlite3VtabImportErrmsg ( p ,  pVTab . pVtab ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  170 :  { sqlite3_value  sMem  =  new  sqlite3_value ( ) ;  sbyte  * zTab ;  CRuntime . memset ( sMem ,  ( int ) ( 0 ) ,  ( ulong ) ( sizeof ( sqlite3_value ) ) ) ;  sMem . db  =  db ;  rc  =  ( int ) ( sqlite3VdbeMemCopy ( sMem ,  aMem [ pOp -&gt; p2 ] ) ) ;  zTab  =  ( sbyte  * ) ( sqlite3_value_text ( sMem ) ) ;  if  ( ( zTab ) != null ) { rc  =  ( int ) ( sqlite3VtabCallCreate ( db ,  ( int ) ( pOp -&gt; p1 ) ,  zTab ,  &amp; p . zErrMsg ) ) ;  } sqlite3VdbeMemRelease ( sMem ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  171 :  { db . nVDestroy ++ ;  rc  =  ( int ) ( sqlite3VtabCallDestroy ( db ,  ( int ) ( pOp -&gt; p1 ) ,  pOp -&gt; p4 . z ) ) ;  db . nVDestroy -- ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  172 :  { VdbeCursor  pCur ;  sqlite3_vtab_cursor  pVCur ;  sqlite3_vtab  pVtab ;  sqlite3_module  pModule ;  pCur  =  null ;  pVCur  =  null ;  pVtab  =  pOp -&gt; p4 . pVtab . pVtab ;  if  ( ( ( pVtab ) == ( null ) ) || ( ( pVtab . pModule ) == ( null ) ) ) { rc  =  ( int ) ( 6 ) ;  goto  abort_due_to_error ;  } pModule  =  pVtab . pModule ;  rc  =  ( int ) ( pModule . xOpen ( pVtab ,  pVCur ) ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  pVCur . pVtab  =  pVtab ;  pCur  =  allocateCursor ( p ,  ( int ) ( pOp -&gt; p1 ) ,  ( int ) ( 0 ) ,  ( byte ) ( 2 ) ) ;  if  ( ( pCur ) != null ) { pCur . uc . pVCur  =  pVCur ;  pVtab . nRef ++ ;  } else  { pModule . xClose ( pVCur ) ;  goto  no_mem ;  } break ;  } case  173 :  { VdbeCursor  pC ;  ValueList  pRhs ;  pC  =  p . apCsr [ pOp -&gt; p1 ] ;  pRhs  =  sqlite3_malloc64 ( ( ulong ) ( sizeof ( ValueList ) ) ) ;  if  ( ( pRhs ) == ( null ) ) goto  no_mem ;  pRhs . pCsr  =  pC . uc . pCursor ;  pRhs . pOut  =  aMem [ pOp -&gt; p3 ] ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . flags  =  ( ushort ) ( 0x0001 ) ;  sqlite3VdbeMemSetPointer ( pOut ,  pRhs ,  "ValueList" ,  sqlite3_free ) ;  break ;  } case  9 :  { int  nArg  =  0 ;  int  iQuery  =  0 ;  sqlite3_module  pModule ;  sqlite3_value  pQuery ;  sqlite3_value  pArgc ;  sqlite3_vtab_cursor  pVCur ;  sqlite3_vtab  pVtab ;  VdbeCursor  pCur ;  int  res  =  0 ;  int  i  =  0 ;  sqlite3_value  apArg ;  pQuery  =  aMem [ pOp -&gt; p3 ] ;  pArgc  =  pQuery [ 1 ] ;  pCur  =  p . apCsr [ pOp -&gt; p1 ] ;  pVCur  =  pCur . uc . pVCur ;  pVtab  =  pVCur . pVtab ;  pModule  =  pVtab . pModule ;  nArg  =  ( ( int ) ( pArgc . u . i ) ) ;  iQuery  =  ( ( int ) ( pQuery . u . i ) ) ;  apArg  =  p . apArg ;  for  ( i  =  ( int ) ( 0 ) ;  ( i ) &lt; ( nArg ) ;  i ++ ) { apArg [ i ]  =  pArgc [ i + 1 ] ;  } rc  =  ( int ) ( pModule . xFilter ( pVCur ,  ( int ) ( iQuery ) ,  pOp -&gt; p4 . z ,  ( int ) ( nArg ) ,  apArg ) ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  res  =  ( int ) ( pModule . xEof ( pVCur ) ) ;  pCur . nullRow  =  ( byte ) ( 0 ) ;  if  ( ( res ) != 0 ) goto  jump_to_p2 ;  break ;  } case  174 :  { sqlite3_vtab  pVtab ;  sqlite3_module  pModule ;  sqlite3_value  pDest ;  sqlite3_context  sContext  =  new  sqlite3_context ( ) ;  VdbeCursor  pCur  =  p . apCsr [ pOp -&gt; p1 ] ;  pDest  =  aMem [ pOp -&gt; p3 ] ;  if  ( ( pCur . nullRow ) != 0 ) { sqlite3VdbeMemSetNull ( pDest ) ;  break ;  } pVtab  =  pCur . uc . pVCur . pVtab ;  pModule  =  pVtab . pModule ;  CRuntime . memset ( sContext ,  ( int ) ( 0 ) ,  ( ulong ) ( sizeof ( sqlite3_context ) ) ) ;  sContext . pOut  =  pDest ;  if  ( ( pOp -&gt; p5 &amp; 0x01 ) != 0 ) { sqlite3VdbeMemSetNull ( pDest ) ;  pDest . flags  =  ( ushort ) ( 0x0001 | 0x4000 ) ;  pDest . u . nZero  =  ( int ) ( 0 ) ;  } else  { ( ( pDest ) . flags  =  ( ushort ) ( ( ( pDest ) . flags &amp; ~ ( 0xc1bf | 0x4000 ) ) | 0x0001 ) ) ;  } rc  =  ( int ) ( pModule . xColumn ( pCur . uc . pVCur ,  sContext ,  ( int ) ( pOp -&gt; p2 ) ) ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  if  ( ( sContext . isError ) &gt; ( 0 ) ) { sqlite3VdbeError ( p ,  "%s" ,  sqlite3_value_text ( pDest ) ) ;  rc  =  ( int ) ( sContext . isError ) ;  } sqlite3VdbeChangeEncoding ( pDest ,  ( int ) ( encoding ) ) ;  if  ( ( sqlite3VdbeMemTooBig ( pDest ) ) != 0 ) { goto  too_big ;  } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  62 :  { sqlite3_vtab  pVtab ;  sqlite3_module  pModule ;  int  res  =  0 ;  VdbeCursor  pCur ;  pCur  =  p . apCsr [ pOp -&gt; p1 ] ;  if  ( ( pCur . nullRow ) != 0 ) { break ;  } pVtab  =  pCur . uc . pVCur . pVtab ;  pModule  =  pVtab . pModule ;  rc  =  ( int ) ( pModule . xNext ( pCur . uc . pVCur ) ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  res  =  ( int ) ( pModule . xEof ( pCur . uc . pVCur ) ) ;  if  ( res == 0 ) { goto  jump_to_p2_and_check_for_interrupt ;  } goto  check_for_interrupt ;  } case  175 :  { sqlite3_vtab  pVtab ;  sqlite3_value  pName ;  int  isLegacy  =  0 ;  isLegacy  =  ( int ) ( db . flags &amp; 0x04000000 ) ;  db . flags |= ( ulong ) ( 0x04000000 ) ;  pVtab  =  pOp -&gt; p4 . pVtab . pVtab ;  pName  =  aMem [ pOp -&gt; p1 ] ;  rc  =  ( int ) ( sqlite3VdbeChangeEncoding ( pName ,  ( int ) ( 1 ) ) ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  rc  =  ( int ) ( pVtab . pModule . xRename ( pVtab ,  pName . z ) ) ;  if  ( ( isLegacy ) == ( 0 ) ) db . flags &amp;= ( ulong ) ( ~ ( ulong ) ( 0x04000000 ) ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  p . expired  =  ( uint ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  break ;  } case  10 :  { sqlite3_vtab  pVtab ;  sqlite3_module  pModule ;  int  nArg  =  0 ;  int  i  =  0 ;  long  rowid  =  ( long ) ( 0 ) ;  sqlite3_value  apArg ;  sqlite3_value  pX ;  if  ( ( db . mallocFailed ) != 0 ) goto  no_mem ;  pVtab  =  pOp -&gt; p4 . pVtab . pVtab ;  if  ( ( ( pVtab ) == ( null ) ) || ( ( pVtab . pModule ) == ( null ) ) ) { rc  =  ( int ) ( 6 ) ;  goto  abort_due_to_error ;  } pModule  =  pVtab . pModule ;  nArg  =  ( int ) ( pOp -&gt; p2 ) ;  if  ( ( pModule . xUpdate ) != null ) { byte  vtabOnConflict  =  ( byte ) ( db . vtabOnConflict ) ;  apArg  =  p . apArg ;  pX  =  aMem [ pOp -&gt; p3 ] ;  for  ( i  =  ( int ) ( 0 ) ;  ( i ) &lt; ( nArg ) ;  i ++ ) { apArg [ i ]  =  pX ;  pX ++ ;  } db . vtabOnConflict  =  ( byte ) ( pOp -&gt; p5 ) ;  rc  =  ( int ) ( pModule . xUpdate ( pVtab ,  ( int ) ( nArg ) ,  apArg ,  &amp; rowid ) ) ;  db . vtabOnConflict  =  ( byte ) ( vtabOnConflict ) ;  sqlite3VtabImportErrmsg ( p ,  pVtab ) ;  if  ( ( ( rc ) == ( 0 ) ) &amp;&amp; ( ( pOp -&gt; p1 ) != 0 ) ) { db . lastRowid  =  ( long ) ( rowid ) ;  } if  ( ( ( rc &amp; 0xff ) == ( 19 ) ) &amp;&amp; ( ( pOp -&gt; p4 . pVtab . bConstraint ) != 0 ) ) { if  ( ( pOp -&gt; p5 ) == ( 4 ) ) { rc  =  ( int ) ( 0 ) ;  } else  { p . errorAction  =  ( byte ) ( ( ( pOp -&gt; p5 ) == ( 5 ) ) ? 2 :  pOp -&gt; p5 ) ;  } } else  { p . nChange ++ ;  } if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } break ;  } case  176 :  { pOut  =  out2Prerelease ( p ,  pOp ) ;  pOut . u . i  =  ( long ) ( sqlite3BtreeLastPage ( db . aDb [ pOp -&gt; p1 ] . pBt ) ) ;  break ;  } case  177 :  { uint  newMax  =  0 ;  Btree  pBt ;  pOut  =  out2Prerelease ( p ,  pOp ) ;  pBt  =  db . aDb [ pOp -&gt; p1 ] . pBt ;  newMax  =  ( uint ) ( 0 ) ;  if  ( ( pOp -&gt; p3 ) != 0 ) { newMax  =  ( uint ) ( sqlite3BtreeLastPage ( pBt ) ) ;  if  ( ( newMax ) &lt; ( ( uint ) ( pOp -&gt; p3 ) ) ) newMax  =  ( ( uint ) ( pOp -&gt; p3 ) ) ;  } pOut . u . i  =  ( long ) ( sqlite3BtreeMaxPageCount ( pBt ,  ( uint ) ( newMax ) ) ) ;  break ;  } case  65 :  case  66 :  { int  i  =  0 ;  sqlite3_context  pCtx ;  pCtx  =  pOp -&gt; p4 . pCtx ;  pOut  =  aMem [ pOp -&gt; p3 ] ;  if  ( pCtx . pOut != pOut ) { pCtx . pVdbe  =  p ;  pCtx . pOut  =  pOut ;  for  ( i  =  ( int ) ( pCtx . argc - 1 ) ;  ( i ) &gt;= ( 0 ) ;  i -- ) { pCtx . argv [ i ]  =  aMem [ pOp -&gt; p2 + i ] ;  } } ( ( pOut ) . flags  =  ( ushort ) ( ( ( pOut ) . flags &amp; ~ ( 0xc1bf | 0x4000 ) ) | 0x0001 ) ) ;  * pCtx . pFunc . xSFunc ( pCtx ,  ( int ) ( pCtx . argc ) ,  pCtx . argv ) ;  if  ( ( pCtx . isError ) != 0 ) { if  ( ( pCtx . isError ) &gt; ( 0 ) ) { sqlite3VdbeError ( p ,  "%s" ,  sqlite3_value_text ( pOut ) ) ;  rc  =  ( int ) ( pCtx . isError ) ;  } sqlite3VdbeDeleteAuxData ( db ,  p . pAuxData ,  ( int ) ( pCtx . iOp ) ,  ( int ) ( pOp -&gt; p1 ) ) ;  pCtx . isError  =  ( int ) ( 0 ) ;  if  ( ( rc ) != 0 ) goto  abort_due_to_error ;  } if  ( ( pOut . flags &amp; ( 0x0002 | 0x0010 ) ) != 0 ) { sqlite3VdbeChangeEncoding ( pOut ,  ( int ) ( encoding ) ) ;  if  ( ( sqlite3VdbeMemTooBig ( pOut ) ) != 0 ) goto  too_big ;  } break ;  } case  178 :  { ulong  h  =  0 ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  h  =  ( ulong ) ( filterHash ( aMem ,  pOp ) ) ;  h %= ( ulong ) ( pIn1 . n ) ;  pIn1 . z [ h / 8 ] |= ( sbyte ) ( 1 &lt;&lt; ( h &amp; 7 ) ) ;  break ;  } case  63 :  { ulong  h  =  0 ;  pIn1  =  aMem [ pOp -&gt; p1 ] ;  h  =  ( ulong ) ( filterHash ( aMem ,  pOp ) ) ;  h %= ( ulong ) ( pIn1 . n ) ;  if  ( ( pIn1 . z [ h / 8 ] &amp; ( 1 &lt;&lt; ( h &amp; 7 ) ) ) == ( 0 ) ) { p . aCounter [ 8 ] ++ ;  goto  jump_to_p2 ;  } else  { p . aCounter [ 7 ] ++ ;  } break ;  } case  179 :  case  64 :  { int  i  =  0 ;  sbyte  * zTrace ;  if  ( ( ( ( db . mTrace &amp; ( 0x01 | 0x40 ) ) != 0 ) &amp;&amp; ( p . doingRerun == 0 ) ) &amp;&amp; ( ( zTrace  =  ( ( pOp -&gt; p4 . z ) != 0 ? pOp -&gt; p4 . z :  p . zSql ) ) != null ) ) { if  ( ( db . mTrace &amp; 0x40 ) != 0 ) { sbyte  * z  =  sqlite3VdbeExpandSql ( p ,  zTrace ) ;  db . trace . xLegacy ( db . pTraceArg ,  z ) ;  sqlite3_free ( z ) ;  } else  if  ( ( db . nVdbeExec ) &gt; ( 1 ) ) { sbyte  * z  =  sqlite3MPrintf ( db ,  "-- %s" ,  zTrace ) ;  ( void ) ( db . trace . xV2 ( ( uint ) ( 0x01 ) ,  db . pTraceArg ,  p ,  z ) ) ;  sqlite3DbFree ( db ,  z ) ;  } else  { ( void ) ( db . trace . xV2 ( ( uint ) ( 0x01 ) ,  db . pTraceArg ,  p ,  zTrace ) ) ;  } } if  ( ( pOp -&gt; p1 ) &gt;= ( sqlite3Config . iOnceResetThreshold ) ) { if  ( ( pOp -&gt; opcode ) == ( 179 ) ) break ;  for  ( i  =  ( int ) ( 1 ) ;  ( i ) &lt; ( p . nOp ) ;  i ++ ) { if  ( ( p . aOp [ i ] . opcode ) == ( 17 ) ) p . aOp [ i ] . p1  =  ( int ) ( 0 ) ;  } pOp -&gt; p1  =  ( int ) ( 0 ) ;  } pOp -&gt; p1 ++ ;  p . aCounter [ 6 ] ++ ;  goto  jump_to_p2 ;  } default :  { break ;  } } }

    abort_due_to_error:
        ; if  ( ( db . mallocFailed ) != 0 ) { rc  =  ( int ) ( 7 ) ;  } else  if  ( ( rc ) == ( 10 | ( 33 &lt;&lt; 8 ) ) ) { rc  =  ( int ) ( sqlite3CorruptError ( ( int ) ( 95926 ) ) ) ;  }
    if (((p.zErrMsg) == (null)) &amp;&amp; (rc != (10 | (12 &lt;&lt; 8))))
    {
        sqlite3VdbeError(p, "%s", sqlite3ErrStr((int)(rc)));
    }

    p.rc = (int)(rc);
    sqlite3SystemError(db, (int)(rc));
    sqlite3_log((int)(rc), "statement aborts at %d: [%s] %s", (int)(pOp - aOp), p.zSql, p.zErrMsg);
    sqlite3VdbeHalt(p);
    if ((rc) == (10 | (12 &lt;&lt; 8)))
        sqlite3OomFault(db);
    if (((rc) == (11)) &amp;&amp; ((db.autoCommit) == (0)))
    {
        db.flags |= (ulong)((ulong)(0x00002) &lt;&lt; 32);
    }

    rc = (int)(1);
    if ((resetSchemaOnFault) &gt; (0))
    {
        sqlite3ResetOneSchema(db, (int)(resetSchemaOnFault - 1));
    }

    vdbe_return:
        ; while  ( ( ( nVmStep ) &gt;= ( nProgressLimit ) ) &amp;&amp; ( db . xProgress != null ) ) { nProgressLimit += ( ulong ) ( db . nProgressOps ) ;  if  ( ( db . xProgress ( db . pProgressArg ) ) != 0 ) { nProgressLimit  =  ( ulong ) ( 0xffffffff | ( ( ( ulong ) ( 0xffffffff ) ) &lt;&lt; 32 ) ) ;  rc  =  ( int ) ( 9 ) ;  goto  abort_due_to_error ;  } }
    p.aCounter[4] += (uint)((int)(nVmStep));
    sqlite3VdbeLeave(p);
    return (int)(rc);
    too_big:
        ; sqlite3VdbeError ( p ,  "string or blob too big" ) ; 
    rc = (int)(18);
    goto abort_due_to_error;
    no_mem:
        ; sqlite3OomFault ( db ) ; 
    sqlite3VdbeError(p, "out of memory");
    rc = (int)(7);
    goto abort_due_to_error;
    abort_due_to_interrupt:
        ;
    rc = (int)(9);
    goto abort_due_to_error;
}</function>
  <function>public static sbyte* sqlite3VdbeExpandSql(Vdbe p, sbyte* zRawSql)
{
    sqlite3 db;
    int idx = (int)(0);
    int nextIndex = (int)(1);
    int n = 0;
    int nToken = 0;
    int i = 0;
    sqlite3_value pVar;
    sqlite3_str _out_ = new sqlite3_str();
    sqlite3_value utf8 = new sqlite3_value();
    db = p.db;
    sqlite3StrAccumInit(_out_, null, null, (int)(0), (int)(db.aLimit[0]));
    if ((db.nVdbeExec) &gt; (1))
    {
        while ((*zRawSql) != 0)
        {
            sbyte* zStart = zRawSql;
            while ((*(zRawSql++) != 10) &amp;&amp; ((*zRawSql) != 0))
            {
            }

            sqlite3_str_append(_out_, "-- ", (int)(3));
            sqlite3_str_append(_out_, zStart, (int)(zRawSql - zStart));
        }
    }
    else if ((p.nVar) == (0))
    {
        sqlite3_str_append(_out_, zRawSql, (int)(sqlite3Strlen30(zRawSql)));
    }
    else
    {
        while ((zRawSql[0]) != 0)
        {
            n = (int)(findNextHostParameter(zRawSql, &amp;nToken));
            sqlite3_str_append(_out_, zRawSql, (int)(n));
            zRawSql += n;
            if ((nToken) == (0))
                break;
            if ((zRawSql[0]) == (63))
            {
                if ((nToken) &gt; (1))
                {
                    sqlite3GetInt32(&amp;zRawSql[1], &amp;idx);
                }
                else
                {
                    idx = (int)(nextIndex);
                }
            }
            else
            {
                idx = (int)(sqlite3VdbeParameterIndex(p, zRawSql, (int)(nToken)));
            }

            zRawSql += nToken;
            nextIndex = (int)((idx + 1) &gt; (nextIndex) ? (idx + 1) : (nextIndex));
            pVar = p.aVar[idx - 1];
            if ((pVar.flags &amp; 0x0001) != 0)
            {
                sqlite3_str_append(_out_, "NULL", (int)(4));
            }
            else if ((pVar.flags &amp; (0x0004 | 0x0020)) != 0)
            {
                sqlite3_str_appendf(_out_, "%lld", (long)(pVar.u.i));
            }
            else if ((pVar.flags &amp; 0x0008) != 0)
            {
                sqlite3_str_appendf(_out_, "%!.15g", (double)(pVar.u.r));
            }
            else if ((pVar.flags &amp; 0x0002) != 0)
            {
                int nOut = 0;
                byte enc = (byte)((db).enc);
                if (enc != 1)
                {
                    CRuntime.memset(utf8, (int)(0), (ulong)(sizeof(sqlite3_value)));
                    utf8.db = db;
                    sqlite3VdbeMemSetStr(utf8, pVar.z, (long)(pVar.n), (byte)(enc), null);
                    if ((7) == (sqlite3VdbeChangeEncoding(utf8, (int)(1))))
                    {
                        _out_.accError = (byte)(7);
                        _out_.nAlloc = (uint)(0);
                    }

                    pVar = utf8;
                }

                nOut = (int)(pVar.n);
                sqlite3_str_appendf(_out_, "'%.*q'", (int)(nOut), pVar.z);
                if (enc != 1)
                    sqlite3VdbeMemRelease(utf8);
            }
            else if ((pVar.flags &amp; 0x4000) != 0)
            {
                sqlite3_str_appendf(_out_, "zeroblob(%d)", (int)(pVar.u.nZero));
            }
            else
            {
                int nOut = 0;
                sqlite3_str_append(_out_, "x'", (int)(2));
                nOut = (int)(pVar.n);
                for (i = (int)(0); (i) &lt; (nOut); i++)
                {
                    sqlite3_str_appendf(_out_, "%02x", (int)(pVar.z[i] &amp; 0xff));
                }

                sqlite3_str_append(_out_, "'", (int)(1));
            }
        }
    }

    if ((_out_.accError) != 0)
        sqlite3_str_reset(_out_);
    return sqlite3StrAccumFinish(_out_);
}</function>
  <function>public static void sqlite3VdbeExplain(Parse pParse, byte bPush, sbyte* zFmt)
{
    if ((pParse.explain) == (2))
    {
        sbyte* zMsg;
        Vdbe v;
        sbyte* ap;
        int iThis = 0;
        (__va_start(&amp;ap, zFmt));
        zMsg = sqlite3VMPrintf(pParse.db, zFmt, ap);
        ((void)(ap = null));
        v = pParse.pVdbe;
        iThis = (int)(v.nOp);
        sqlite3VdbeAddOp4(v, (int)(183), (int)(iThis), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7));
        if ((bPush) != 0)
        {
            pParse.addrExplain = (int)(iThis);
        }
    }
}</function>
  <function>public static int sqlite3VdbeExplainParent(Parse pParse)
{
    VdbeOp* pOp;
    if ((pParse.addrExplain) == (0))
        return (int)(0);
    pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(pParse.addrExplain));
    return (int)(pOp-&gt;p2);
}</function>
  <function>public static void sqlite3VdbeExplainPop(Parse pParse)
{
    pParse.addrExplain = (int)(sqlite3VdbeExplainParent(pParse));
}</function>
  <function>public static int sqlite3VdbeFinalize(Vdbe p)
{
    int rc = (int)(0);
    if (((p.iVdbeMagic) == (0x2df20da3)) || ((p.iVdbeMagic) == (0x319c2973)))
    {
        rc = (int)(sqlite3VdbeReset(p));
    }

    sqlite3VdbeDelete(p);
    return (int)(rc);
}</function>
  <function>public static Int ( Int ,  Int ,  Int )sqlite3VdbeFindCompare(UnpackedRecord p)
{
    if ((p.pKeyInfo.nAllField) &lt;= (13))
    {
        int flags = (int)(p.aMem[0].flags);
        if ((p.pKeyInfo.aSortFlags[0]) != 0)
        {
            if ((p.pKeyInfo.aSortFlags[0] &amp; 0x02) != 0)
            {
                return sqlite3VdbeRecordCompare;
            }

            p.r1 = (sbyte)(1);
            p.r2 = (sbyte)(-1);
        }
        else
        {
            p.r1 = (sbyte)(-1);
            p.r2 = (sbyte)(1);
        }

        if ((flags &amp; 0x0004) != 0)
        {
            return vdbeRecordCompareInt;
        }

        if (((flags &amp; (0x0008 | 0x0020 | 0x0001 | 0x0010)) == (0)) &amp;&amp; ((p.pKeyInfo.aColl[0]) == (null)))
        {
            return vdbeRecordCompareString;
        }
    }

    return sqlite3VdbeRecordCompare;
}</function>
  <function>public static int sqlite3VdbeFinishMoveto(VdbeCursor p)
{
    int res = 0; int  rc  =  0 ; 
    rc = (int)(sqlite3BtreeTableMoveto(p.uc.pCursor, (long)(p.movetoTarget), (int)(0), &amp;res));
    if ((rc) != 0)
        return (int)(rc);
    if (res != 0)
        return (int)(sqlite3CorruptError((int)(83317)));
    p.deferredMoveto = (byte)(0);
    p.cacheStatus = (uint)(0);
    return (int)(0);
}</function>
  <function>public static void sqlite3VdbeFrameDelete(VdbeFrame p)
{
    int i = 0;
    sqlite3_value aMem = ((sqlite3_value)(&amp;((byte*)(p))[(((sizeof(VdbeFrame)) + 7) &amp; ~7)]));
    VdbeCursor apCsr = (VdbeCursor)(aMem[p.nChildMem]);
    for (i = (int)(0); (i) &lt; (p.nChildCsr); i++)
    {
        sqlite3VdbeFreeCursor(p.v, apCsr[i]);
    }

    releaseMemArray(aMem, (int)(p.nChildMem));
    sqlite3VdbeDeleteAuxData(p.v.db, p.pAuxData, (int)(-1), (int)(0));
    sqlite3DbFree(p.v.db, p);
}</function>
  <function>public static void sqlite3VdbeFrameMemDel(void* pArg)
{
    VdbeFrame pFrame = (VdbeFrame)(pArg);
    pFrame.pParent = pFrame.v.pDelFrame;
    pFrame.v.pDelFrame = pFrame;
}</function>
  <function>public static int sqlite3VdbeFrameRestore(VdbeFrame pFrame)
{
    Vdbe v = pFrame.v;
    closeCursorsInFrame(v);
    v.aOp = pFrame.aOp;
    v.nOp = (int)(pFrame.nOp);
    v.aMem = pFrame.aMem;
    v.nMem = (int)(pFrame.nMem);
    v.apCsr = pFrame.apCsr;
    v.nCursor = (int)(pFrame.nCursor);
    v.db.lastRowid = (long)(pFrame.lastRowid);
    v.nChange = (long)(pFrame.nChange);
    v.db.nChange = (long)(pFrame.nDbChange);
    sqlite3VdbeDeleteAuxData(v.db, v.pAuxData, (int)(-1), (int)(0));
    v.pAuxData = pFrame.pAuxData;
    pFrame.pAuxData = null;
    return (int)(pFrame.pc);
}</function>
  <function>public static void sqlite3VdbeFreeCursor(Vdbe p, VdbeCursor pCx)
{
    if ((pCx) == (null))
    {
        return;
    }

    switch (pCx.eCurType)
    {
        case 1:
        {
            sqlite3VdbeSorterClose(p.db, pCx);
            break;
        }

        case 0:
        {
            sqlite3BtreeCloseCursor(pCx.uc.pCursor);
            break;
        }

        case 2:
        {
            sqlite3_vtab_cursor pVCur = pCx.uc.pVCur;
            sqlite3_module pModule = pVCur.pVtab.pModule;
            pVCur.pVtab.nRef--;
            pModule.xClose(pVCur);
            break;
        }
    }
}</function>
  <function>public static sqlite3_value sqlite3VdbeGetBoundValue(Vdbe v, int iVar, byte aff)
{
    if ((v) != null)
    {
        sqlite3_value pMem = v.aVar[iVar - 1];
        if ((0) == (pMem.flags &amp; 0x0001))
        {
            sqlite3_value pRet = sqlite3ValueNew(v.db);
            if ((pRet) != null)
            {
                sqlite3VdbeMemCopy(pRet, pMem);
                sqlite3ValueApplyAffinity(pRet, (byte)(aff), (byte)(1));
            }

            return pRet;
        }
    }

    return null;
}</function>
  <function>public static VdbeOp* sqlite3VdbeGetOp(Vdbe p, int addr)
{
    if ((addr) &lt; (0))
    {
        addr = (int)(p.nOp - 1);
    }

    if ((p.db.mallocFailed) != 0)
    {
        return &amp;sqlite3VdbeGetOp_dummy;
    }
    else
    {
        return &amp;p.aOp[addr];
    }
}</function>
  <function>public static int sqlite3VdbeGoto(Vdbe p, int iDest)
{
    return (int)(sqlite3VdbeAddOp3(p, (int)(11), (int)(0), (int)(iDest), (int)(0)));
}</function>
  <function>public static int sqlite3VdbeHalt(Vdbe p)
{
    int rc = 0;
    sqlite3 db = p.db;
    if (p.iVdbeMagic != 0x2df20da3)
    {
        return (int)(0);
    }

    if ((db.mallocFailed) != 0)
    {
        p.rc = (int)(7);
    }

    closeAllCursors(p);
    if (((p.pc) &gt;= (0)) &amp;&amp; ((p.bIsReader) != 0))
    {
        int mrc = 0;
        int eStatementOp = (int)(0);
        int isSpecialError = 0;
        sqlite3VdbeEnter(p);
        if ((p.rc) != 0)
        {
            mrc = (int)(p.rc &amp; 0xff);
            isSpecialError = (int)(((((mrc) == (7)) || ((mrc) == (10))) || ((mrc) == (9))) || ((mrc) == (13)) ? 1 : 0);
        }
        else
        {
            mrc = (int)(isSpecialError = (int)(0));
        }

        if ((isSpecialError) != 0)
        {
            if ((p.readOnly == 0) || (mrc != 9))
            {
                if ((((mrc) == (7)) || ((mrc) == (13))) &amp;&amp; ((p.usesStmtJournal) != 0))
                {
                    eStatementOp = (int)(2);
                }
                else
                {
                    sqlite3RollbackAll(db, (int)(4 | (2 &lt;&lt; 8)));
                    sqlite3CloseSavepoints(db);
                    db.autoCommit = (byte)(1);
                    p.nChange = (long)(0);
                }
            }
        }

        if (((p.rc) == (0)) || (((p.errorAction) == (3)) &amp;&amp; (isSpecialError == 0)))
        {
            sqlite3VdbeCheckFk(p, (int)(0));
        }

        if (((!((((db).nVTrans) &gt; (0)) &amp;&amp; (((db).aVTrans) == (null)))) &amp;&amp; ((db.autoCommit) != 0)) &amp;&amp; ((db.nVdbeWrite) == ((p.readOnly) == (0))))
        {
            if (((p.rc) == (0)) || (((p.errorAction) == (3)) &amp;&amp; (isSpecialError == 0)))
            {
                rc = (int)(sqlite3VdbeCheckFk(p, (int)(1)));
                if (rc != 0)
                {
                    if ((p.readOnly) != 0)
                    {
                        sqlite3VdbeLeave(p);
                        return (int)(1);
                    }

                    rc = (int)(19 | (3 &lt;&lt; 8));
                }
                else if ((db.flags &amp; ((ulong)(0x00002) &lt;&lt; 32)) != 0)
                {
                    rc = (int)(11);
                    db.flags &amp;= (ulong)(~((ulong)(0x00002) &lt;&lt; 32));
                }
                else
                {
                    rc = (int)(vdbeCommit(db, p));
                }

                if (((rc) == (5)) &amp;&amp; ((p.readOnly) != 0))
                {
                    sqlite3VdbeLeave(p);
                    return (int)(5);
                }
                else if (rc != 0)
                {
                    p.rc = (int)(rc);
                    sqlite3RollbackAll(db, (int)(0));
                    p.nChange = (long)(0);
                }
                else
                {
                    db.nDeferredCons = (long)(0);
                    db.nDeferredImmCons = (long)(0);
                    db.flags &amp;= (ulong)(~(ulong)(0x00080000));
                    sqlite3CommitInternalChanges(db);
                }
            }
            else
            {
                sqlite3RollbackAll(db, (int)(0));
                p.nChange = (long)(0);
            }

            db.nStatement = (int)(0);
        }
        else if ((eStatementOp) == (0))
        {
            if (((p.rc) == (0)) || ((p.errorAction) == (3)))
            {
                eStatementOp = (int)(1);
            }
            else if ((p.errorAction) == (2))
            {
                eStatementOp = (int)(2);
            }
            else
            {
                sqlite3RollbackAll(db, (int)(4 | (2 &lt;&lt; 8)));
                sqlite3CloseSavepoints(db);
                db.autoCommit = (byte)(1);
                p.nChange = (long)(0);
            }
        }

        if ((eStatementOp) != 0)
        {
            rc = (int)(sqlite3VdbeCloseStatement(p, (int)(eStatementOp)));
            if ((rc) != 0)
            {
                if (((p.rc) == (0)) || ((p.rc &amp; 0xff) == (19)))
                {
                    p.rc = (int)(rc);
                    sqlite3DbFree(db, p.zErrMsg);
                    p.zErrMsg = null;
                }

                sqlite3RollbackAll(db, (int)(4 | (2 &lt;&lt; 8)));
                sqlite3CloseSavepoints(db);
                db.autoCommit = (byte)(1);
                p.nChange = (long)(0);
            }
        }

        if ((p.changeCntOn) != 0)
        {
            if (eStatementOp != 2)
            {
                sqlite3VdbeSetChanges(db, (long)(p.nChange));
            }
            else
            {
                sqlite3VdbeSetChanges(db, (long)(0));
            }

            p.nChange = (long)(0);
        }

        sqlite3VdbeLeave(p);
    }

    if ((p.pc) &gt;= (0))
    {
        db.nVdbeActive--;
        if (p.readOnly == 0)
            db.nVdbeWrite--;
        if ((p.bIsReader) != 0)
            db.nVdbeRead--;
    }

    p.iVdbeMagic = (uint)(0x319c2973);
    if ((db.mallocFailed) != 0)
    {
        p.rc = (int)(7);
    }

    if ((db.autoCommit) != 0)
    {
    }

    return (int)((p.rc) == (5) ? 5 : 0);
}</function>
  <function>public static int sqlite3VdbeHasSubProgram(Vdbe pVdbe)
{
    return (int)(pVdbe.pProgram != null);
}</function>
  <function>public static int sqlite3VdbeIdxKeyCompare(sqlite3 db, VdbeCursor pC, UnpackedRecord pUnpacked, int* res)
{
    long nCellKey = (long)(0);
    int rc = 0;
    BtCursor pCur;
    sqlite3_value m = new sqlite3_value();
    pCur = pC.uc.pCursor;
    nCellKey = (long)(sqlite3BtreePayloadSize(pCur));
    if (((nCellKey) &lt;= (0)) || ((nCellKey) &gt; (0x7fffffff)))
    {
        *res = (int)(0);
        return (int)(sqlite3CorruptError((int)(84809)));
    }

    sqlite3VdbeMemInit(m, db, (ushort)(0));
    rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m));
    if ((rc) != 0)
    {
        return (int)(rc);
    }

    *res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(m.n), m.z, pUnpacked, (int)(0)));
    sqlite3VdbeMemRelease(m);
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeIdxRowid(sqlite3 db, BtCursor pCur, long* rowid)
{
    long nCellKey = (long)(0);
    int rc = 0;
    uint szHdr = 0;
    uint typeRowid = 0;
    uint lenRowid = 0;
    sqlite3_value m = new sqlite3_value(); sqlite3_value  v  =  new  sqlite3_value ( ) ; 
    nCellKey = (long)(sqlite3BtreePayloadSize(pCur));
    sqlite3VdbeMemInit(m, db, (ushort)(0));
    rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m));
    if ((rc) != 0)
    {
        return (int)(rc);
    }

    szHdr = ((uint)(*((byte*)(m.z))));
    if ((szHdr) &gt;= (0x80))
        sqlite3GetVarint32(((byte*)(m.z)), &amp;(szHdr));
    if ((((szHdr) &lt; (3)) || ((szHdr) &gt; ((uint)(m.n)))))
    {
        goto idx_rowid_corruption;
    }

    typeRowid = ((uint)(*((byte*)(&amp;m.z[szHdr - 1]))));
    if ((typeRowid) &gt;= (0x80))
        sqlite3GetVarint32(((byte*)(&amp;m.z[szHdr - 1])), &amp;(typeRowid));
    if (((((typeRowid) &lt; (1)) || ((typeRowid) &gt; (9))) || ((typeRowid) == (7))))
    {
        goto idx_rowid_corruption;
    }

    lenRowid = (uint)(sqlite3SmallTypeSizes[typeRowid]);
    if ((((uint)(m.n)) &lt; (szHdr + lenRowid)))
    {
        goto idx_rowid_corruption;
    }

    sqlite3VdbeSerialGet((byte*)(&amp;m.z[m.n - lenRowid]), (uint)(typeRowid), v);
    *rowid = (long)(v.u.i);
    sqlite3VdbeMemRelease(m);
    return (int)(0);
    idx_rowid_corruption:
        ;
    sqlite3VdbeMemRelease(m);
    return (int)(sqlite3CorruptError((int)(84776)));
}</function>
  <function>public static void sqlite3VdbeIntegerAffinity(sqlite3_value pMem)
{
    long ix = 0;
    ix = (long)(doubleToInt64((double)(pMem.u.r)));
    if ((((pMem.u.r) == (ix)) &amp;&amp; ((ix) &gt; (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))) &amp;&amp; ((ix) &lt; (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))
    {
        pMem.u.i = (long)(ix);
        ((pMem).flags = (ushort)(((pMem).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
    }
}</function>
  <function>public static long sqlite3VdbeIntValue(sqlite3_value pMem)
{
    int flags = 0;
    flags = (int)(pMem.flags);
    if ((flags &amp; (0x0004 | 0x0020)) != 0)
    {
        return (long)(pMem.u.i);
    }
    else if ((flags &amp; 0x0008) != 0)
    {
        return (long)(doubleToInt64((double)(pMem.u.r)));
    }
    else if (((flags &amp; (0x0002 | 0x0010)) != 0) &amp;&amp; (pMem.z != null))
    {
        return (long)(memIntValue(pMem));
    }
    else
    {
        return (long)(0);
    }
}</function>
  <function>public static void sqlite3VdbeJumpHere(Vdbe p, int addr)
{
    sqlite3VdbeChangeP2(p, (int)(addr), (int)(p.nOp));
}</function>
  <function>public static void sqlite3VdbeJumpHereOrPopInst(Vdbe p, int addr)
{
    if ((addr) == (p.nOp - 1))
    {
        p.nOp--;
    }
    else
    {
        sqlite3VdbeChangeP2(p, (int)(addr), (int)(p.nOp));
    }
}</function>
  <function>public static void sqlite3VdbeLeave(Vdbe p)
{
    if ((p.lockMask) == (0))
        return;
    vdbeLeave(p);
}</function>
  <function>public static void sqlite3VdbeLinkSubProgram(Vdbe pVdbe, SubProgram* p)
{
    p-&gt;pNext = pVdbe.pProgram;
    pVdbe.pProgram = p;
}</function>
  <function>public static int sqlite3VdbeList(Vdbe p)
{
    sqlite3_value pSub = null;
    sqlite3 db = p.db;
    int i = 0;
    int rc = (int)(0);
    sqlite3_value pMem = p.aMem[1];
    int bListSubprogs = (int)((((p.explain) == (1)) || ((db.flags &amp; 0x01000000) != 0)) ? 1 : 0);
    VdbeOp* aOp;
    VdbeOp* pOp;
    releaseMemArray(pMem, (int)(8));
    p.pResultSet = null;
    if ((p.rc) == (7))
    {
        sqlite3OomFault(db);
        return (int)(1);
    }

    if ((bListSubprogs) != 0)
    {
        pSub = p.aMem[9];
    }
    else
    {
        pSub = null;
    }

    rc = (int)(sqlite3VdbeNextOpcode(p, pSub, ((p.explain) == (2) ? 1 : 0), &amp;p.pc, &amp;i, &amp;aOp));
    if ((rc) == (0))
    {
        pOp = aOp + i;
        if ((0) != 0)
        {
            p.rc = (int)(9);
            rc = (int)(1);
            sqlite3VdbeError(p, sqlite3ErrStr((int)(p.rc)));
        }
        else
        {
            sbyte* zP4 = sqlite3VdbeDisplayP4(db, pOp);
            if ((p.explain) == (2))
            {
                sqlite3VdbeMemSetInt64(pMem, (long)(pOp-&gt;p1));
                sqlite3VdbeMemSetInt64(pMem[1], (long)(pOp-&gt;p2));
                sqlite3VdbeMemSetInt64(pMem[2], (long)(pOp-&gt;p3));
                sqlite3VdbeMemSetStr(pMem[3], zP4, (long)(-1), (byte)(1), sqlite3_free);
                p.nResColumn = (ushort)(4);
            }
            else
            {
                sqlite3VdbeMemSetInt64(pMem[0], (long)(i));
                sqlite3VdbeMemSetStr(pMem[1], sqlite3OpcodeName((int)(pOp-&gt;opcode)), (long)(-1), (byte)(1), null);
                sqlite3VdbeMemSetInt64(pMem[2], (long)(pOp-&gt;p1));
                sqlite3VdbeMemSetInt64(pMem[3], (long)(pOp-&gt;p2));
                sqlite3VdbeMemSetInt64(pMem[4], (long)(pOp-&gt;p3));
                sqlite3VdbeMemSetInt64(pMem[6], (long)(pOp-&gt;p5));
                sqlite3VdbeMemSetNull(pMem[7]);
                sqlite3VdbeMemSetStr(pMem[5], zP4, (long)(-1), (byte)(1), sqlite3_free);
                p.nResColumn = (ushort)(8);
            }

            p.pResultSet = pMem;
            if ((db.mallocFailed) != 0)
            {
                p.rc = (int)(7);
                rc = (int)(1);
            }
            else
            {
                p.rc = (int)(0);
                rc = (int)(100);
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VdbeLoadString(Vdbe p, int iDest, sbyte* zStr)
{
    return (int)(sqlite3VdbeAddOp4(p, (int)(117), (int)(0), (int)(iDest), (int)(0), zStr, (int)(0)));
}</function>
  <function>public static int sqlite3VdbeMakeLabel(Parse pParse)
{
    return (int)(--pParse.nLabel);
}</function>
  <function>public static void sqlite3VdbeMakeReady(Vdbe p, Parse pParse)
{
    sqlite3 db;
    int nVar = 0;
    int nMem = 0;
    int nCursor = 0;
    int nArg = 0;
    int n = 0;
    ReusableSpace x = new ReusableSpace();
    p.pVList = pParse.pVList;
    pParse.pVList = null;
    db = p.db;
    nVar = (int)(pParse.nVar);
    nMem = (int)(pParse.nMem);
    nCursor = (int)(pParse.nTab);
    nArg = (int)(pParse.nMaxArg);
    nMem += (int)(nCursor);
    if (((nCursor) == (0)) &amp;&amp; ((nMem) &gt; (0)))
        nMem++;
    n = (int)(((sizeof(VdbeOp) * p.nOp) + 7) &amp; ~7);
    x.pSpace = &amp;((byte*)(p.aOp))[n];
    x.nFree = (long)((pParse.szOpAlloc - n) &amp; ~7);
    resolveP2Values(p, &amp;nArg);
    p.usesStmtJournal = (uint)((byte)(((pParse.isMultiWrite) != 0) &amp;&amp; ((pParse.mayAbort) != 0)));
    if ((pParse.explain) != 0)
    {
        int iFirst = 0;
        int mx = 0;
        int i = 0;
        if ((nMem) &lt; (10))
            nMem = (int)(10);
        p.explain = (uint)(pParse.explain);
        if ((pParse.explain) == (2))
        {
            sqlite3VdbeSetNumCols(p, (int)(4));
            iFirst = (int)(8);
            mx = (int)(12);
        }
        else
        {
            sqlite3VdbeSetNumCols(p, (int)(8));
            iFirst = (int)(0);
            mx = (int)(8);
        }

        for (i = (int)(iFirst); (i) &lt; (mx); i++)
        {
            sqlite3VdbeSetColName(p, (int)(i - iFirst), (int)(0), sqlite3VdbeMakeReady_azColName[i], null);
        }
    }

    p.expired = (uint)(0);
    x.nNeeded = (long)(0);
    p.aMem = allocSpace(&amp;x, null, (long)(nMem * sizeof(sqlite3_value)));
    p.aVar = allocSpace(&amp;x, null, (long)(nVar * sizeof(sqlite3_value)));
    p.apArg = allocSpace(&amp;x, null, (long)(nArg * sizeof(sqlite3_value)));
    p.apCsr = allocSpace(&amp;x, null, (long)(nCursor * sizeof(VdbeCursor)));
    if ((x.nNeeded) != 0)
    {
        x.pSpace = p.pFree = sqlite3DbMallocRawNN(db, (ulong)(x.nNeeded));
        x.nFree = (long)(x.nNeeded);
        if (db.mallocFailed == 0)
        {
            p.aMem = allocSpace(&amp;x, p.aMem, (long)(nMem * sizeof(sqlite3_value)));
            p.aVar = allocSpace(&amp;x, p.aVar, (long)(nVar * sizeof(sqlite3_value)));
            p.apArg = allocSpace(&amp;x, p.apArg, (long)(nArg * sizeof(sqlite3_value)));
            p.apCsr = allocSpace(&amp;x, p.apCsr, (long)(nCursor * sizeof(VdbeCursor)));
        }
    }

    if ((db.mallocFailed) != 0)
    {
        p.nVar = (short)(0);
        p.nCursor = (int)(0);
        p.nMem = (int)(0);
    }
    else
    {
        p.nCursor = (int)(nCursor);
        p.nVar = ((short)(nVar));
        initMemArray(p.aVar, (int)(nVar), db, (ushort)(0x0001));
        p.nMem = (int)(nMem);
        initMemArray(p.aMem, (int)(nMem), db, (ushort)(0x0080));
        CRuntime.memset(p.apCsr, (int)(0), (ulong)(nCursor * sizeof(VdbeCursor)));
    }

    sqlite3VdbeRewind(p);
}</function>
  <function>public static int sqlite3VdbeMemAggValue(sqlite3_value pAccum, sqlite3_value pOut, FuncDef pFunc)
{
    sqlite3_context ctx = new sqlite3_context();
    CRuntime.memset(ctx, (int)(0), (ulong)(sizeof(sqlite3_context)));
    sqlite3VdbeMemSetNull(pOut);
    ctx.pOut = pOut;
    ctx.pMem = pAccum;
    ctx.pFunc = pFunc;
    pFunc.xValue(ctx);
    return (int)(ctx.isError);
}</function>
  <function>public static int sqlite3VdbeMemCast(sqlite3_value pMem, byte aff, byte encoding)
{
    if ((pMem.flags &amp; 0x0001) != 0)
        return (int)(0);
    switch (aff)
    {
        case 0x41:
        {
            if ((pMem.flags &amp; 0x0010) == (0))
            {
                sqlite3ValueApplyAffinity(pMem, (byte)(0x42), (byte)(encoding));
                if ((pMem.flags &amp; 0x0002) != 0)
                    ((pMem).flags = (ushort)(((pMem).flags &amp; ~(0xc1bf | 0x4000)) | 0x0010));
            }
            else
            {
                pMem.flags &amp;= (ushort)(~(0xc1bf &amp; ~0x0010));
            }

            break;
        }

        case 0x43:
        {
            sqlite3VdbeMemNumerify(pMem);
            break;
        }

        case 0x44:
        {
            sqlite3VdbeMemIntegerify(pMem);
            break;
        }

        case 0x45:
        {
            sqlite3VdbeMemRealify(pMem);
            break;
        }

        default:
        {
            pMem.flags |= (ushort)((pMem.flags &amp; 0x0010) &gt;&gt; 3);
            sqlite3ValueApplyAffinity(pMem, (byte)(0x42), (byte)(encoding));
            pMem.flags &amp;= (ushort)(~(0x0004 | 0x0008 | 0x0020 | 0x0010 | 0x4000));
            return (int)(sqlite3VdbeChangeEncoding(pMem, (int)(encoding)));
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemClearAndResize(sqlite3_value pMem, int szNew)
{
    if ((pMem.szMalloc) &lt; (szNew))
    {
        return (int)(sqlite3VdbeMemGrow(pMem, (int)(szNew), (int)(0)));
    }

    pMem.z = pMem.zMalloc;
    pMem.flags &amp;= (ushort)(0x0001 | 0x0004 | 0x0008 | 0x0020);
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemCopy(sqlite3_value pTo, sqlite3_value pFrom)
{
    int rc = (int)(0);
    if ((((pTo).flags &amp; (0x2000 | 0x0400)) != 0))
        vdbeMemClearExternAndSetNull(pTo);
    CRuntime.memcpy(pTo, pFrom, ((ulong)(&amp;((0).zMalloc))));
    pTo.flags &amp;= (ushort)(~0x0400);
    if ((pTo.flags &amp; (0x0002 | 0x0010)) != 0)
    {
        if ((0) == (pFrom.flags &amp; 0x0800))
        {
            pTo.flags |= (ushort)(0x1000);
            rc = (int)(sqlite3VdbeMemMakeWriteable(pTo));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VdbeMemExpandBlob(sqlite3_value pMem)
{
    int nByte = 0;
    nByte = (int)(pMem.n + pMem.u.nZero);
    if ((nByte) &lt;= (0))
    {
        if ((pMem.flags &amp; 0x0010) == (0))
            return (int)(0);
        nByte = (int)(1);
    }

    if ((sqlite3VdbeMemGrow(pMem, (int)(nByte), (int)(1))) != 0)
    {
        return (int)(7);
    }

    CRuntime.memset(&amp;pMem.z[pMem.n], (int)(0), (ulong)(pMem.u.nZero));
    pMem.n += (int)(pMem.u.nZero);
    pMem.flags &amp;= (ushort)(~(0x4000 | 0x0200));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemFinalize(sqlite3_value pMem, FuncDef pFunc)
{
    sqlite3_context ctx = new sqlite3_context();
    sqlite3_value t = new sqlite3_value();
    CRuntime.memset(ctx, (int)(0), (ulong)(sizeof(sqlite3_context)));
    CRuntime.memset(t, (int)(0), (ulong)(sizeof(sqlite3_value)));
    t.flags = (ushort)(0x0001);
    t.db = pMem.db;
    ctx.pOut = t;
    ctx.pMem = pMem;
    ctx.pFunc = pFunc;
    pFunc.xFinalize(ctx);
    if ((pMem.szMalloc) &gt; (0))
        sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
    CRuntime.memcpy(pMem, t, (ulong)(sizeof(sqlite3_value)));
    return (int)(ctx.isError);
}</function>
  <function>public static int sqlite3VdbeMemFromBtree(BtCursor pCur, uint offset, uint amt, sqlite3_value pMem)
{
    int rc = 0;
    pMem.flags = (ushort)(0x0001);
    if ((sqlite3BtreeMaxRecordSize(pCur)) &lt; (offset + amt))
    {
        return (int)(sqlite3CorruptError((int)(79076)));
    }

    if ((0) == (rc = (int)(sqlite3VdbeMemClearAndResize(pMem, (int)(amt + 1)))))
    {
        rc = (int)(sqlite3BtreePayload(pCur, (uint)(offset), (uint)(amt), pMem.z));
        if ((rc) == (0))
        {
            pMem.z[amt] = (sbyte)(0);
            pMem.flags = (ushort)(0x0010);
            pMem.n = ((int)(amt));
        }
        else
        {
            sqlite3VdbeMemRelease(pMem);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VdbeMemFromBtreeZeroOffset(BtCursor pCur, uint amt, sqlite3_value pMem)
{
    uint available = (uint)(0);
    int rc = (int)(0);
    pMem.z = (sbyte*)(sqlite3BtreePayloadFetch(pCur, &amp;available));
    if ((amt) &lt;= (available))
    {
        pMem.flags = (ushort)(0x0010 | 0x1000);
        pMem.n = ((int)(amt));
    }
    else
    {
        rc = (int)(sqlite3VdbeMemFromBtree(pCur, (uint)(0), (uint)(amt), pMem));
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VdbeMemGrow(sqlite3_value pMem, int n, int bPreserve)
{
    if ((((pMem.szMalloc) &gt; (0)) &amp;&amp; ((bPreserve) != 0)) &amp;&amp; ((pMem.z) == (pMem.zMalloc)))
    {
        if ((pMem.db) != null)
        {
            pMem.z = pMem.zMalloc = sqlite3DbReallocOrFree(pMem.db, pMem.z, (ulong)(n));
        }
        else
        {
            pMem.zMalloc = sqlite3Realloc(pMem.z, (ulong)(n));
            if ((pMem.zMalloc) == (null))
                sqlite3_free(pMem.z);
            pMem.z = pMem.zMalloc;
        }

        bPreserve = (int)(0);
    }
    else
    {
        if ((pMem.szMalloc) &gt; (0))
            sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
        pMem.zMalloc = sqlite3DbMallocRaw(pMem.db, (ulong)(n));
    }

    if ((pMem.zMalloc) == (null))
    {
        sqlite3VdbeMemSetNull(pMem);
        pMem.z = null;
        pMem.szMalloc = (int)(0);
        return (int)(7);
    }
    else
    {
        pMem.szMalloc = (int)(sqlite3DbMallocSize(pMem.db, pMem.zMalloc));
    }

    if (((bPreserve) != 0) &amp;&amp; ((pMem.z) != null))
    {
        CRuntime.memcpy(pMem.zMalloc, pMem.z, (ulong)(pMem.n));
    }

    if ((pMem.flags &amp; 0x0400) != 0)
    {
        pMem.xDel((void*)(pMem.z));
    }

    pMem.z = pMem.zMalloc;
    pMem.flags &amp;= (ushort)(~(0x0400 | 0x1000 | 0x0800));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemHandleBom(sqlite3_value pMem)
{
    int rc = (int)(0);
    byte bom = (byte)(0);
    if ((pMem.n) &gt; (1))
    {
        byte b1 = (byte)(*(byte*)(pMem.z));
        byte b2 = (byte)(*(((byte*)(pMem.z)) + 1));
        if (((b1) == (0xFE)) &amp;&amp; ((b2) == (0xFF)))
        {
            bom = (byte)(3);
        }

        if (((b1) == (0xFF)) &amp;&amp; ((b2) == (0xFE)))
        {
            bom = (byte)(2);
        }
    }

    if ((bom) != 0)
    {
        rc = (int)(sqlite3VdbeMemMakeWriteable(pMem));
        if ((rc) == (0))
        {
            pMem.n -= (int)(2);
            CRuntime.memmove(pMem.z, &amp;pMem.z[2], (ulong)(pMem.n));
            pMem.z[pMem.n] = (sbyte)(0);
            pMem.z[pMem.n + 1] = (sbyte)(0);
            pMem.flags |= (ushort)(0x0200);
            pMem.enc = (byte)(bom);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3VdbeMemInit(sqlite3_value pMem, sqlite3 db, ushort flags)
{
    pMem.flags = (ushort)(flags);
    pMem.db = db;
    pMem.szMalloc = (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemIntegerify(sqlite3_value pMem)
{
    pMem.u.i = (long)(sqlite3VdbeIntValue(pMem));
    ((pMem).flags = (ushort)(((pMem).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemMakeWriteable(sqlite3_value pMem)
{
    if ((pMem.flags &amp; (0x0002 | 0x0010)) != 0)
    {
        if ((((pMem).flags &amp; 0x4000) ? sqlite3VdbeMemExpandBlob(pMem) : 0) != 0)
            return (int)(7);
        if (((pMem.szMalloc) == (0)) || (pMem.z != pMem.zMalloc))
        {
            int rc = (int)(vdbeMemAddTerminator(pMem));
            if ((rc) != 0)
                return (int)(rc);
        }
    }

    pMem.flags &amp;= (ushort)(~0x1000);
    return (int)(0);
}</function>
  <function>public static void sqlite3VdbeMemMove(sqlite3_value pTo, sqlite3_value pFrom)
{
    sqlite3VdbeMemRelease(pTo);
    CRuntime.memcpy(pTo, pFrom, (ulong)(sizeof(sqlite3_value)));
    pFrom.flags = (ushort)(0x0001);
    pFrom.szMalloc = (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemNulTerminate(sqlite3_value pMem)
{
    if ((pMem.flags &amp; (0x0200 | 0x0002)) != 0x0002)
    {
        return (int)(0);
    }
    else
    {
        return (int)(vdbeMemAddTerminator(pMem));
    }
}</function>
  <function>public static int sqlite3VdbeMemNumerify(sqlite3_value pMem)
{
    if ((pMem.flags &amp; (0x0004 | 0x0008 | 0x0020 | 0x0001)) == (0))
    {
        int rc = 0;
        long ix = 0;
        rc = (int)(sqlite3AtoF(pMem.z, &amp;pMem.u.r, (int)(pMem.n), (byte)(pMem.enc)));
        if (((((rc) == (0)) || ((rc) == (1))) &amp;&amp; ((sqlite3Atoi64(pMem.z, &amp;ix, (int)(pMem.n), (byte)(pMem.enc))) &lt;= (1))) || ((sqlite3RealSameAsInt((double)(pMem.u.r), (long)(ix = ((long)(pMem.u.r))))) != 0))
        {
            pMem.u.i = (long)(ix);
            ((pMem).flags = (ushort)(((pMem).flags &amp; ~(0xc1bf | 0x4000)) | 0x0004));
        }
        else
        {
            ((pMem).flags = (ushort)(((pMem).flags &amp; ~(0xc1bf | 0x4000)) | 0x0008));
        }
    }

    pMem.flags &amp;= (ushort)(~(0x0002 | 0x0010 | 0x4000));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemRealify(sqlite3_value pMem)
{
    pMem.u.r = (double)(sqlite3VdbeRealValue(pMem));
    ((pMem).flags = (ushort)(((pMem).flags &amp; ~(0xc1bf | 0x4000)) | 0x0008));
    return (int)(0);
}</function>
  <function>public static void sqlite3VdbeMemRelease(sqlite3_value p)
{
    if ((((p).flags &amp; (0x2000 | 0x0400)) != 0) || ((p.szMalloc) != 0))
    {
        vdbeMemClear(p);
    }
}</function>
  <function>public static void sqlite3VdbeMemSetDouble(sqlite3_value pMem, double val)
{
    sqlite3VdbeMemSetNull(pMem);
    if (sqlite3IsNaN((double)(val)) == 0)
    {
        pMem.u.r = (double)(val);
        pMem.flags = (ushort)(0x0008);
    }
}</function>
  <function>public static void sqlite3VdbeMemSetInt64(sqlite3_value pMem, long val)
{
    if ((((pMem).flags &amp; (0x2000 | 0x0400)) != 0))
    {
        vdbeReleaseAndSetInt64(pMem, (long)(val));
    }
    else
    {
        pMem.u.i = (long)(val);
        pMem.flags = (ushort)(0x0004);
    }
}</function>
  <function>public static void sqlite3VdbeMemSetNull(sqlite3_value pMem)
{
    if ((((pMem).flags &amp; (0x2000 | 0x0400)) != 0))
    {
        vdbeMemClearExternAndSetNull(pMem);
    }
    else
    {
        pMem.flags = (ushort)(0x0001);
    }
}</function>
  <function>public static void sqlite3VdbeMemSetPointer(sqlite3_value pMem, void* pPtr, sbyte* zPType, delegate17 xDestructor)
{
    vdbeMemClear(pMem);
    pMem.u.zPType = (zPType) != 0 ? zPType : "";
    pMem.z = pPtr;
    pMem.flags = (ushort)(0x0001 | 0x0400 | 0x8000 | 0x0200);
    pMem.eSubtype = (byte)(112);
    pMem.xDel = xDestructor ? xDestructor : sqlite3NoopDestructor;
}</function>
  <function>public static int sqlite3VdbeMemSetRowSet(sqlite3_value pMem)
{
    sqlite3 db = pMem.db;
    RowSet p;
    sqlite3VdbeMemRelease(pMem);
    p = sqlite3RowSetInit(db);
    if ((p) == (null))
        return (int)(7);
    pMem.z = (sbyte*)(p);
    pMem.flags = (ushort)(0x0010 | 0x0400);
    pMem.xDel = sqlite3RowSetDelete;
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemSetStr(sqlite3_value pMem, sbyte* z, long n, byte enc, delegate17 xDel)
{
    long nByte = (long)(n);
    int iLimit = 0;
    ushort flags = (ushort)(0);
    if (z == null)
    {
        sqlite3VdbeMemSetNull(pMem);
        return (int)(0);
    }

    if ((pMem.db) != null)
    {
        iLimit = (int)(pMem.db.aLimit[0]);
    }
    else
    {
        iLimit = (int)(1000000000);
    }

    flags = (ushort)((enc) == (0) ? 0x0010 : 0x0002);
    if ((nByte) &lt; (0))
    {
        if ((enc) == (1))
        {
            nByte = (long)(CRuntime.strlen(z));
        }
        else
        {
            for (nByte = (long)(0); ((nByte) &lt;= (iLimit)) &amp;&amp; ((z[nByte] | z[nByte + 1]) != 0); nByte += (long)(2))
            {
            }
        }

        flags |= (ushort)(0x0200);
    }

    if ((xDel) == ((Void(Void * ))(-1)))
    {
        long nAlloc = (long)(nByte);
        if ((flags &amp; 0x0200) != 0)
        {
            nAlloc += (long)((enc) == (1) ? 1 : 2);
        }

        if ((nByte) &gt; (iLimit))
        {
            return (int)(sqlite3ErrorToParser(pMem.db, (int)(18)));
        }

        if ((sqlite3VdbeMemClearAndResize(pMem, (int)((nAlloc) &gt; (32) ? (nAlloc) : (32)))) != 0)
        {
            return (int)(7);
        }

        CRuntime.memcpy(pMem.z, z, (ulong)(nAlloc));
    }
    else
    {
        sqlite3VdbeMemRelease(pMem);
        pMem.z = z;
        if ((xDel) == ((Void(Void * ))(sqlite3OomFault)))
        {
            pMem.zMalloc = pMem.z;
            pMem.szMalloc = (int)(sqlite3DbMallocSize(pMem.db, pMem.zMalloc));
        }
        else
        {
            pMem.xDel = xDel;
            flags |= (ushort)(((xDel) == null) ? 0x0800 : 0x0400);
        }
    }

    pMem.n = ((int)(nByte &amp; 0x7fffffff));
    pMem.flags = (ushort)(flags);
    if ((enc) != 0)
    {
        pMem.enc = (byte)(enc);
    }
    else
    {
        pMem.enc = (byte)((pMem.db).enc);
    }

    if (((enc) &gt; (1)) &amp;&amp; ((sqlite3VdbeMemHandleBom(pMem)) != 0))
    {
        return (int)(7);
    }

    if ((nByte) &gt; (iLimit))
    {
        return (int)(sqlite3ErrorToParser(pMem.db, (int)(18)));
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3VdbeMemSetZeroBlob(sqlite3_value pMem, int n)
{
    sqlite3VdbeMemRelease(pMem);
    pMem.flags = (ushort)(0x0010 | 0x4000);
    pMem.n = (int)(0);
    if ((n) &lt; (0))
        n = (int)(0);
    pMem.u.nZero = (int)(n);
    pMem.enc = (byte)(1);
    pMem.z = null;
}</function>
  <function>public static void sqlite3VdbeMemShallowCopy(sqlite3_value pTo, sqlite3_value pFrom, int srcType)
{
    if ((((pTo).flags &amp; (0x2000 | 0x0400)) != 0))
    {
        vdbeClrCopy(pTo, pFrom, (int)(srcType));
        return;
    }

    CRuntime.memcpy(pTo, pFrom, ((ulong)(&amp;((0).zMalloc))));
    if ((pFrom.flags &amp; 0x0800) == (0))
    {
        pTo.flags &amp;= (ushort)(~(0x0400 | 0x0800 | 0x1000));
        pTo.flags |= (ushort)(srcType);
    }
}</function>
  <function>public static int sqlite3VdbeMemStringify(sqlite3_value pMem, byte enc, byte bForce)
{
    int nByte = (int)(32);
    if ((sqlite3VdbeMemClearAndResize(pMem, (int)(nByte))) != 0)
    {
        pMem.enc = (byte)(0);
        return (int)(7);
    }

    vdbeMemRenderNum((int)(nByte), pMem.z, pMem);
    pMem.n = (int)(CRuntime.strlen(pMem.z) &amp; 0x3fffffff);
    pMem.enc = (byte)(1);
    pMem.flags |= (ushort)(0x0002 | 0x0200);
    if ((bForce) != 0)
        pMem.flags &amp;= (ushort)(~(0x0004 | 0x0008 | 0x0020));
    sqlite3VdbeChangeEncoding(pMem, (int)(enc));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemTooBig(sqlite3_value p)
{
    if ((p.flags &amp; (0x0002 | 0x0010)) != 0)
    {
        int n = (int)(p.n);
        if ((p.flags &amp; 0x4000) != 0)
        {
            n += (int)(p.u.nZero);
        }

        return ((n) &gt; (p.db.aLimit[0]) ? 1 : 0);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeMemTranslate(sqlite3_value pMem, byte desiredEnc)
{
    long len = 0;
    byte* zOut;
    byte* zIn;
    byte* zTerm;
    byte* z;
    uint c = 0;
    if ((pMem.enc != 1) &amp;&amp; (desiredEnc != 1))
    {
        byte temp = 0;
        int rc = 0;
        rc = (int)(sqlite3VdbeMemMakeWriteable(pMem));
        if (rc != 0)
        {
            return (int)(7);
        }

        zIn = (byte*)(pMem.z);
        zTerm = &amp;zIn[pMem.n &amp; ~1];
        while ((zIn) &lt; (zTerm))
        {
            temp = (byte)(*zIn);
            *zIn = (byte)(*(zIn + 1));
            zIn++;
            *zIn++ = (byte)(temp);
        }

        pMem.enc = (byte)(desiredEnc);
        goto translate_out;
    }

    if ((desiredEnc) == (1))
    {
        pMem.n &amp;= (int)(~1);
        len = (long)(2 * (long)(pMem.n) + 1);
    }
    else
    {
        len = (long)(2 * (long)(pMem.n) + 2);
    }

    zIn = (byte*)(pMem.z);
    zTerm = &amp;zIn[pMem.n];
    zOut = sqlite3DbMallocRaw(pMem.db, (ulong)(len));
    if (zOut == null)
    {
        return (int)(7);
    }

    z = zOut;
    if ((pMem.enc) == (1))
    {
        if ((desiredEnc) == (2))
        {
            while ((zIn) &lt; (zTerm))
            {
                c = (uint)(*(zIn++));
                if ((c) &gt;= (0xc0))
                {
                    c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
                    while ((zIn != zTerm) &amp;&amp; ((*zIn &amp; 0xc0) == (0x80)))
                    {
                        c = (uint)((c &lt;&lt; 6) + (0x3f &amp; *(zIn++)));
                    }

                    if ((((c) &lt; (0x80)) || ((c &amp; 0xFFFFF800) == (0xD800))) || ((c &amp; 0xFFFFFFFE) == (0xFFFE)))
                    {
                        c = (uint)(0xFFFD);
                    }
                }

                {
                    if ((c) &lt;= (0xFFFF))
                    {
                        *z++ = ((byte)(c &amp; 0x00FF));
                        *z++ = ((byte)((c &gt;&gt; 8) &amp; 0x00FF));
                    }
                    else
                    {
                        *z++ = ((byte)(((c &gt;&gt; 10) &amp; 0x003F) + (((c - 0x10000) &gt;&gt; 10) &amp; 0x00C0)));
                        *z++ = ((byte)(0x00D8 + (((c - 0x10000) &gt;&gt; 18) &amp; 0x03)));
                        *z++ = ((byte)(c &amp; 0x00FF));
                        *z++ = ((byte)(0x00DC + ((c &gt;&gt; 8) &amp; 0x03)));
                    }
                }
            }
        }
        else
        {
            while ((zIn) &lt; (zTerm))
            {
                c = (uint)(*(zIn++));
                if ((c) &gt;= (0xc0))
                {
                    c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
                    while ((zIn != zTerm) &amp;&amp; ((*zIn &amp; 0xc0) == (0x80)))
                    {
                        c = (uint)((c &lt;&lt; 6) + (0x3f &amp; *(zIn++)));
                    }

                    if ((((c) &lt; (0x80)) || ((c &amp; 0xFFFFF800) == (0xD800))) || ((c &amp; 0xFFFFFFFE) == (0xFFFE)))
                    {
                        c = (uint)(0xFFFD);
                    }
                }

                {
                    if ((c) &lt;= (0xFFFF))
                    {
                        *z++ = ((byte)((c &gt;&gt; 8) &amp; 0x00FF));
                        *z++ = ((byte)(c &amp; 0x00FF));
                    }
                    else
                    {
                        *z++ = ((byte)(0x00D8 + (((c - 0x10000) &gt;&gt; 18) &amp; 0x03)));
                        *z++ = ((byte)(((c &gt;&gt; 10) &amp; 0x003F) + (((c - 0x10000) &gt;&gt; 10) &amp; 0x00C0)));
                        *z++ = ((byte)(0x00DC + ((c &gt;&gt; 8) &amp; 0x03)));
                        *z++ = ((byte)(c &amp; 0x00FF));
                    }
                }
            }
        }

        pMem.n = ((int)(z - zOut));
        *z++ = (byte)(0);
    }
    else
    {
        if ((pMem.enc) == (2))
        {
            while ((zIn) &lt; (zTerm))
            {
                c = (uint)(*(zIn++));
                c += (uint)((*(zIn++)) &lt;&lt; 8);
                if (((c) &gt;= (0xd800)) &amp;&amp; ((c) &lt; (0xe000)))
                {
                    if ((zIn) &lt; (zTerm))
                    {
                        int c2 = (int)(*zIn++);
                        c2 += (int)((*zIn++) &lt;&lt; 8);
                        c = (uint)((c2 &amp; 0x03FF) + ((c &amp; 0x003F) &lt;&lt; 10) + (((c &amp; 0x03C0) + 0x0040) &lt;&lt; 10));
                    }
                }

                {
                    if ((c) &lt; (0x00080))
                    {
                        *z++ = ((byte)(c &amp; 0xFF));
                    }
                    else if ((c) &lt; (0x00800))
                    {
                        *z++ = (byte)(0xC0 + (byte)((c &gt;&gt; 6) &amp; 0x1F));
                        *z++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
                    }
                    else if ((c) &lt; (0x10000))
                    {
                        *z++ = (byte)(0xE0 + (byte)((c &gt;&gt; 12) &amp; 0x0F));
                        *z++ = (byte)(0x80 + (byte)((c &gt;&gt; 6) &amp; 0x3F));
                        *z++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
                    }
                    else
                    {
                        *z++ = (byte)(0xF0 + (byte)((c &gt;&gt; 18) &amp; 0x07));
                        *z++ = (byte)(0x80 + (byte)((c &gt;&gt; 12) &amp; 0x3F));
                        *z++ = (byte)(0x80 + (byte)((c &gt;&gt; 6) &amp; 0x3F));
                        *z++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
                    }
                }
            }
        }
        else
        {
            while ((zIn) &lt; (zTerm))
            {
                c = (uint)((*(zIn++)) &lt;&lt; 8);
                c += (uint)(*(zIn++));
                if (((c) &gt;= (0xd800)) &amp;&amp; ((c) &lt; (0xe000)))
                {
                    if ((zIn) &lt; (zTerm))
                    {
                        int c2 = (int)((*zIn++) &lt;&lt; 8);
                        c2 += (int)(*zIn++);
                        c = (uint)((c2 &amp; 0x03FF) + ((c &amp; 0x003F) &lt;&lt; 10) + (((c &amp; 0x03C0) + 0x0040) &lt;&lt; 10));
                    }
                }

                {
                    if ((c) &lt; (0x00080))
                    {
                        *z++ = ((byte)(c &amp; 0xFF));
                    }
                    else if ((c) &lt; (0x00800))
                    {
                        *z++ = (byte)(0xC0 + (byte)((c &gt;&gt; 6) &amp; 0x1F));
                        *z++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
                    }
                    else if ((c) &lt; (0x10000))
                    {
                        *z++ = (byte)(0xE0 + (byte)((c &gt;&gt; 12) &amp; 0x0F));
                        *z++ = (byte)(0x80 + (byte)((c &gt;&gt; 6) &amp; 0x3F));
                        *z++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
                    }
                    else
                    {
                        *z++ = (byte)(0xF0 + (byte)((c &gt;&gt; 18) &amp; 0x07));
                        *z++ = (byte)(0x80 + (byte)((c &gt;&gt; 12) &amp; 0x3F));
                        *z++ = (byte)(0x80 + (byte)((c &gt;&gt; 6) &amp; 0x3F));
                        *z++ = (byte)(0x80 + (byte)(c &amp; 0x3F));
                    }
                }
            }
        }

        pMem.n = ((int)(z - zOut));
    }

    *z = (byte)(0);
    c = (uint)(0x0002 | 0x0200 | (pMem.flags &amp; (0x003f | 0x8000)));
    sqlite3VdbeMemRelease(pMem);
    pMem.flags = (ushort)(c);
    pMem.enc = (byte)(desiredEnc);
    pMem.z = (sbyte*)(zOut);
    pMem.zMalloc = pMem.z;
    pMem.szMalloc = (int)(sqlite3DbMallocSize(pMem.db, pMem.z));
    translate_out:
        ; return  ( int ) ( 0 ) ; 
}</function>
  <function>public static void sqlite3VdbeMultiLoad(Vdbe p, int iDest, sbyte* zTypes)
{
    sbyte* ap;
    int i = 0;
    sbyte c = 0;
    (__va_start(&amp;ap, zTypes));
    for (i = (int)(0); (c = (sbyte)(zTypes[i])) != 0; i++)
    {
        if ((c) == (115))
        {
            sbyte* z = (((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
            sqlite3VdbeAddOp4(p, (int)((z) == (null) ? 74 : 117), (int)(0), (int)(iDest + i), (int)(0), z, (int)(0));
        }
        else if ((c) == (105))
        {
            sqlite3VdbeAddOp2(p, (int)(71), (int)(((() &gt; ()) || ((&amp;(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )), (int)(iDest + i));
        }
        else
        {
            goto skip_op_resultrow;
        }
    }

    sqlite3VdbeAddOp2(p, (int)(83), (int)(iDest), (int)(i));
    skip_op_resultrow:
        ; ( ( void ) ( ap  =  null ) ) ; 
}</function>
  <function>public static int sqlite3VdbeNextOpcode(Vdbe p, sqlite3_value pSub, int eMode, int* piPc, int* piAddr, VdbeOp** paOp)
{
    int nRow = 0;
    int nSub = (int)(0);
    SubProgram** apSub = null;
    int i = 0;
    int rc = (int)(0);
    VdbeOp* aOp = null;
    int iPc = 0;
    nRow = (int)(p.nOp);
    if (pSub != null)
    {
        if ((pSub.flags &amp; 0x0010) != 0)
        {
            nSub = (int)(pSub.n / sizeof(Vdbe));
            apSub = (SubProgram**)(pSub.z);
        }

        for (i = (int)(0); (i) &lt; (nSub); i++)
        {
            nRow += (int)(apSub[i]-&gt;nOp);
        }
    }

    iPc = (int)(*piPc);
    while ((1) != 0)
    {
        i = (int)(iPc++);
        if ((i) &gt;= (nRow))
        {
            p.rc = (int)(0);
            rc = (int)(101);
            break;
        }

        if ((i) &lt; (p.nOp))
        {
            aOp = p.aOp;
        }
        else
        {
            int j = 0;
            i -= (int)(p.nOp);
            for (j = (int)(0); (i) &gt;= (apSub[j]-&gt;nOp); j++)
            {
                i -= (int)(apSub[j]-&gt;nOp);
            }

            aOp = apSub[j]-&gt;aOp;
        }

        if ((pSub != null) &amp;&amp; ((aOp[i].p4type) == (-4)))
        {
            int nByte = (int)((nSub + 1) * sizeof(SubProgram));
            int j = 0;
            for (j = (int)(0); (j) &lt; (nSub); j++)
            {
                if ((apSub[j]) == (aOp[i].p4.pProgram))
                    break;
            }

            if ((j) == (nSub))
            {
                p.rc = (int)(sqlite3VdbeMemGrow(pSub, (int)(nByte), (int)(nSub != 0)));
                if (p.rc != 0)
                {
                    rc = (int)(1);
                    break;
                }

                apSub = (SubProgram**)(pSub.z);
                apSub[nSub++] = aOp[i].p4.pProgram;
                ((pSub).flags = (ushort)(((pSub).flags &amp; ~(0xc1bf | 0x4000)) | 0x0010));
                pSub.n = (int)(nSub * sizeof(SubProgram));
                nRow += (int)(aOp[i].p4.pProgram-&gt;nOp);
            }
        }

        if ((eMode) == (0))
            break;
        {
            if ((aOp[i].opcode) == (183))
                break;
            if (((aOp[i].opcode) == (64)) &amp;&amp; ((iPc) &gt; (1)))
                break;
        }
    }

    *piPc = (int)(iPc);
    *piAddr = (int)(i);
    *paOp = aOp;
    return (int)(rc);
}</function>
  <function>public static byte sqlite3VdbeOneByteSerialTypeLen(byte serial_type)
{
    return (byte)(sqlite3SmallTypeSizes[serial_type]);
}</function>
  <function>public static int sqlite3VdbeParameterIndex(Vdbe p, sbyte* zName, int nName)
{
    if (((p) == (null)) || ((zName) == (null)))
        return (int)(0);
    return (int)(sqlite3VListNameToNum(p.pVList, zName, (int)(nName)));
}</function>
  <function>public static Parse sqlite3VdbeParser(Vdbe p)
{
    return p.pParse;
}</function>
  <function>public static byte sqlite3VdbePrepareFlags(Vdbe v)
{
    return (byte)(v.prepFlags);
}</function>
  <function>public static double sqlite3VdbeRealValue(sqlite3_value pMem)
{
    if ((pMem.flags &amp; 0x0008) != 0)
    {
        return (double)(pMem.u.r);
    }
    else if ((pMem.flags &amp; (0x0004 | 0x0020)) != 0)
    {
        return (double)(pMem.u.i);
    }
    else if ((pMem.flags &amp; (0x0002 | 0x0010)) != 0)
    {
        return (double)(memRealValue(pMem));
    }
    else
    {
        return (double)(0);
    }
}</function>
  <function>public static int sqlite3VdbeRecordCompare(int nKey1, void* pKey1, UnpackedRecord pPKey2)
{
    return (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(0)));
}</function>
  <function>public static int sqlite3VdbeRecordCompareWithSkip(int nKey1, void* pKey1, UnpackedRecord pPKey2, int bSkip)
{
    uint d1 = 0;
    int i = 0;
    uint szHdr1 = 0;
    uint idx1 = 0;
    int rc = (int)(0);
    sqlite3_value pRhs = pPKey2.aMem;
    KeyInfo pKeyInfo;
    byte* aKey1 = (byte*)(pKey1);
    sqlite3_value mem1 = new sqlite3_value();
    if ((bSkip) != 0)
    {
        uint s1 = 0;
        idx1 = (uint)(1 + (byte)(((*(&amp;aKey1[1])) &lt; ((byte)(0x80))) ? ((s1) = ((uint)(*(&amp;aKey1[1])))), 1 : 
        sqlite3GetVarint32((&amp;aKey1[1]), &amp;(s1)) ) )
        ;
        szHdr1 = (uint)(aKey1[0]);
        d1 = (uint)(szHdr1 + sqlite3VdbeSerialTypeLen((uint)(s1)));
        i = (int)(1);
        pRhs++;
    }
    else
    {
        idx1 = (uint)((byte)(((*(aKey1)) &lt; ((byte)(0x80))) ? ((szHdr1) = ((uint)(*(aKey1)))), 1 : 
        sqlite3GetVarint32((aKey1), &amp;(szHdr1)) ) )
        ;
        d1 = (uint)(szHdr1);
        i = (int)(0);
    }

    if ((d1) &gt; ((uint)(nKey1)))
    {
        pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84319))));
        return (int)(0);
    }

    do
    {
        uint serial_type = 0;
        if ((pRhs.flags &amp; (0x0004 | 0x0020)) != 0)
        {
            serial_type = (uint)(aKey1[idx1]);
            if ((serial_type) &gt;= (10))
            {
                rc = (int)(+1);
            }
            else if ((serial_type) == (0))
            {
                rc = (int)(-1);
            }
            else if ((serial_type) == (7))
            {
                sqlite3VdbeSerialGet(&amp;aKey1[d1], (uint)(serial_type), mem1);
                rc = (int)(-sqlite3IntFloatCompare((long)(pRhs.u.i), (double)(mem1.u.r)));
            }
            else
            {
                long lhs = (long)(vdbeRecordDecodeInt((uint)(serial_type), &amp;aKey1[d1]));
                long rhs = (long)(pRhs.u.i);
                if ((lhs) &lt; (rhs))
                {
                    rc = (int)(-1);
                }
                else if ((lhs) &gt; (rhs))
                {
                    rc = (int)(+1);
                }
            }
        }
        else if ((pRhs.flags &amp; 0x0008) != 0)
        {
            serial_type = (uint)(aKey1[idx1]);
            if ((serial_type) &gt;= (10))
            {
                rc = (int)(+1);
            }
            else if ((serial_type) == (0))
            {
                rc = (int)(-1);
            }
            else
            {
                sqlite3VdbeSerialGet(&amp;aKey1[d1], (uint)(serial_type), mem1);
                if ((serial_type) == (7))
                {
                    if ((mem1.u.r) &lt; (pRhs.u.r))
                    {
                        rc = (int)(-1);
                    }
                    else if ((mem1.u.r) &gt; (pRhs.u.r))
                    {
                        rc = (int)(+1);
                    }
                }
                else
                {
                    rc = (int)(sqlite3IntFloatCompare((long)(mem1.u.i), (double)(pRhs.u.r)));
                }
            }
        }
        else if ((pRhs.flags &amp; 0x0002) != 0)
        {
            serial_type = ((uint)(*(&amp;aKey1[idx1])));
            if ((serial_type) &gt;= (0x80))
                sqlite3GetVarint32((&amp;aKey1[idx1]), &amp;(serial_type));
            if ((serial_type) &lt; (12))
            {
                rc = (int)(-1);
            }
            else if ((serial_type &amp; 0x01) == 0)
            {
                rc = (int)(+1);
            }
            else
            {
                mem1.n = (int)((serial_type - 12) / 2);
                if (((d1 + mem1.n) &gt; ((uint)(nKey1))) || (((pKeyInfo = pPKey2.pKeyInfo).nAllField) &lt;= (i)))
                {
                    pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84396))));
                    return (int)(0);
                }
                else if ((pKeyInfo.aColl[i]) != null)
                {
                    mem1.enc = (byte)(pKeyInfo.enc);
                    mem1.db = pKeyInfo.db;
                    mem1.flags = (ushort)(0x0002);
                    mem1.z = (sbyte*)(&amp;aKey1[d1]);
                    rc = (int)(vdbeCompareMemString(mem1, pRhs, pKeyInfo.aColl[i], &amp;pPKey2.errCode));
                }
                else
                {
                    int nCmp = (int)((mem1.n) &lt; (pRhs.n) ? (mem1.n) : (pRhs.n));
                    rc = (int)(memcmp(&amp;aKey1[d1], pRhs.z, (ulong)(nCmp)));
                    if ((rc) == (0))
                        rc = (int)(mem1.n - pRhs.n);
                }
            }
        }
        else if ((pRhs.flags &amp; 0x0010) != 0)
        {
            serial_type = ((uint)(*(&amp;aKey1[idx1])));
            if ((serial_type) &gt;= (0x80))
                sqlite3GetVarint32((&amp;aKey1[idx1]), &amp;(serial_type));
            if (((serial_type) &lt; (12)) || ((serial_type &amp; 0x01) != 0))
            {
                rc = (int)(-1);
            }
            else
            {
                int nStr = (int)((serial_type - 12) / 2);
                if ((d1 + nStr) &gt; ((uint)(nKey1)))
                {
                    pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84426))));
                    return (int)(0);
                }
                else if ((pRhs.flags &amp; 0x4000) != 0)
                {
                    if (isAllZero((sbyte*)(&amp;aKey1[d1]), (int)(nStr)) == 0)
                    {
                        rc = (int)(1);
                    }
                    else
                    {
                        rc = (int)(nStr - pRhs.u.nZero);
                    }
                }
                else
                {
                    int nCmp = (int)((nStr) &lt; (pRhs.n) ? (nStr) : (pRhs.n));
                    rc = (int)(memcmp(&amp;aKey1[d1], pRhs.z, (ulong)(nCmp)));
                    if ((rc) == (0))
                        rc = (int)(nStr - pRhs.n);
                }
            }
        }
        else
        {
            serial_type = (uint)(aKey1[idx1]);
            rc = (int)(serial_type != 0);
        }

        if (rc != 0)
        {
            int sortFlags = (int)(pPKey2.pKeyInfo.aSortFlags[i]);
            if ((sortFlags) != 0)
            {
                if (((sortFlags &amp; 0x02) == (0)) || ((sortFlags &amp; 0x01) != (((serial_type) == (0)) || ((pRhs.flags &amp; 0x0001) != 0))))
                {
                    rc = (int)(-rc);
                }
            }

            return (int)(rc);
        }

        i++;
        if ((i) == (pPKey2.nField))
            break;
        pRhs++;
        d1 += (uint)(sqlite3VdbeSerialTypeLen((uint)(serial_type)));
        idx1 += (uint)(sqlite3VarintLen((ulong)(serial_type)));
    }
    while (((idx1) &lt; (szHdr1)) &amp;&amp; ((d1) &lt;= ((uint)(nKey1))));
    pPKey2.eqSeen = (byte)(1);
    return (int)(pPKey2.default_rc);
}</function>
  <function>public static void sqlite3VdbeRecordUnpack(KeyInfo pKeyInfo, int nKey, void* pKey, UnpackedRecord p)
{
    byte* aKey = (byte*)(pKey);
    uint d = 0;
    uint idx = 0;
    ushort u = 0;
    uint szHdr = 0;
    sqlite3_value pMem = p.aMem;
    p.default_rc = (sbyte)(0);
    idx = (uint)((byte)(((*(aKey)) &lt; ((byte)(0x80))) ? ((szHdr) = ((uint)(*(aKey)))), 1 :  sqlite3GetVarint32 ( ( aKey ) ,  &amp; ( szHdr ) ) ) ) ; 
    d = (uint)(szHdr);
    u = (ushort)(0);
    while (((idx) &lt; (szHdr)) &amp;&amp; ((d) &lt;= ((uint)(nKey))))
    {
        uint serial_type = 0;
        idx += (uint)((byte)(((*(&amp;aKey[idx])) &lt; ((byte)(0x80))) ? ((serial_type) = ((uint)(*(&amp;aKey[idx])))), 1 : 
        sqlite3GetVarint32((&amp;aKey[idx]), &amp;(serial_type)) ) )
        ;
        pMem.enc = (byte)(pKeyInfo.enc);
        pMem.db = pKeyInfo.db;
        pMem.szMalloc = (int)(0);
        pMem.z = null;
        sqlite3VdbeSerialGet(&amp;aKey[d], (uint)(serial_type), pMem);
        d += (uint)(sqlite3VdbeSerialTypeLen((uint)(serial_type)));
        pMem++;
        if ((++u) &gt;= (p.nField))
            break;
    }

    if (((d) &gt; ((uint)(nKey))) &amp;&amp; ((u) != 0))
    {
        sqlite3VdbeMemSetNull(pMem - 1);
    }

    p.nField = (ushort)(u);
}</function>
  <function>public static int sqlite3VdbeReset(Vdbe p)
{
    sqlite3 db;
    db = p.db;
    sqlite3VdbeHalt(p);
    if ((p.pc) &gt;= (0))
    {
        if (((db.pErr) != null) || ((p.zErrMsg) != null))
        {
            sqlite3VdbeTransferError(p);
        }
        else
        {
            db.errCode = (int)(p.rc);
        }

        if ((p.runOnlyOnce) != 0)
            p.expired = (uint)(1);
    }
    else if (((p.rc) != 0) &amp;&amp; ((p.expired) != 0))
    {
        sqlite3ErrorWithMsg(db, (int)(p.rc), (p.zErrMsg) != 0 ? "%s" : null, p.zErrMsg);
    }

    if ((p.zErrMsg) != null)
    {
        sqlite3DbFree(db, p.zErrMsg);
        p.zErrMsg = null;
    }

    p.pResultSet = null;
    p.iVdbeMagic = (uint)(0x48fa9f76);
    return (int)(p.rc &amp; db.errMask);
}</function>
  <function>public static void sqlite3VdbeResetStepResult(Vdbe p)
{
    p.rc = (int)(0);
}</function>
  <function>public static void sqlite3VdbeResolveLabel(Vdbe v, int x)
{
    Parse p = v.pParse;
    int j = (int)(~(x));
    if ((p.nLabelAlloc + p.nLabel) &lt; (0))
    {
        resizeResolveLabel(p, v, (int)(j));
    }
    else
    {
        p.aLabel[j] = (int)(v.nOp);
    }
}</function>
  <function>public static void sqlite3VdbeReusable(Vdbe p)
{
    p.runOnlyOnce = (uint)(0);
}</function>
  <function>public static void sqlite3VdbeRewind(Vdbe p)
{
    p.iVdbeMagic = (uint)(0x2df20da3);
    p.pc = (int)(-1);
    p.rc = (int)(0);
    p.errorAction = (byte)(2);
    p.nChange = (long)(0);
    p.cacheCtr = (uint)(1);
    p.minWriteFileFormat = (byte)(255);
    p.iStatement = (int)(0);
    p.nFkConstraint = (long)(0);
}</function>
  <function>public static void sqlite3VdbeRunOnlyOnce(Vdbe p)
{
    p.runOnlyOnce = (uint)(1);
}</function>
  <function>public static void sqlite3VdbeSerialGet(byte* buf, uint serial_type, sqlite3_value pMem)
{
    switch (serial_type)
    {
        case 10:
        {
            pMem.flags = (ushort)(0x0001 | 0x4000);
            pMem.n = (int)(0);
            pMem.u.nZero = (int)(0);
            return;
        }

        case 11:
        case 0:
        {
            pMem.flags = (ushort)(0x0001);
            return;
        }

        case 1:
        {
            pMem.u.i = (long)((sbyte)((buf)[0]));
            pMem.flags = (ushort)(0x0004);
            return;
        }

        case 2:
        {
            pMem.u.i = (long)(256 * (sbyte)((buf)[0]) | (buf)[1]);
            pMem.flags = (ushort)(0x0004);
            return;
        }

        case 3:
        {
            pMem.u.i = (long)(65536 * (sbyte)((buf)[0]) | ((buf)[1] &lt;&lt; 8) | (buf)[2]);
            pMem.flags = (ushort)(0x0004);
            return;
        }

        case 4:
        {
            pMem.u.i = (long)(16777216 * (sbyte)((buf)[0]) | ((buf)[1] &lt;&lt; 16) | ((buf)[2] &lt;&lt; 8) | (buf)[3]);
            pMem.flags = (ushort)(0x0004);
            return;
        }

        case 5:
        {
            pMem.u.i = (long)((((uint)((buf + 2)[0]) &lt;&lt; 24) | ((buf + 2)[1] &lt;&lt; 16) | ((buf + 2)[2] &lt;&lt; 8) | (buf + 2)[3]) + (((long)(1)) &lt;&lt; 32) * (256 * (sbyte)((buf)[0]) | (buf)[1]));
            pMem.flags = (ushort)(0x0004);
            return;
        }

        case 6:
        case 7:
        {
            serialGet(buf, (uint)(serial_type), pMem);
            return;
        }

        case 8:
        case 9:
        {
            pMem.u.i = (long)(serial_type - 8);
            pMem.flags = (ushort)(0x0004);
            return;
        }

        default:
        {
            pMem.z = (sbyte*)(buf);
            pMem.n = (int)((serial_type - 12) / 2);
            pMem.flags = (ushort)(sqlite3VdbeSerialGet_aFlag[serial_type &amp; 1]);
            return;
        }
    }

    return;
}</function>
  <function>public static uint sqlite3VdbeSerialPut(byte* buf, sqlite3_value pMem, uint serial_type)
{
    uint len = 0;
    if (((serial_type) &lt;= (7)) &amp;&amp; ((serial_type) &gt; (0)))
    {
        ulong v = 0;
        uint i = 0;
        if ((serial_type) == (7))
        {
            CRuntime.memcpy(&amp;v, &amp;pMem.u.r, (ulong)(sizeof(ulong)));
        }
        else
        {
            v = (ulong)(pMem.u.i);
        }

        len = (uint)(i = (uint)(sqlite3SmallTypeSizes[serial_type]));
        do
        {
            buf[--i] = ((byte)(v &amp; 0xFF));
            v &gt;&gt;= 8;
        }
        while ((i) != 0);
        return (uint)(len);
    }

    if ((serial_type) &gt;= (12))
    {
        len = (uint)(pMem.n);
        if ((len) &gt; (0))
            CRuntime.memcpy(buf, pMem.z, (ulong)(len));
        return (uint)(len);
    }

    return (uint)(0);
}</function>
  <function>public static uint sqlite3VdbeSerialTypeLen(uint serial_type)
{
    if ((serial_type) &gt;= (128))
    {
        return (uint)((serial_type - 12) / 2);
    }
    else
    {
        return (uint)(sqlite3SmallTypeSizes[serial_type]);
    }
}</function>
  <function>public static void sqlite3VdbeSetChanges(sqlite3 db, long nChange)
{
    db.nChange = (long)(nChange);
    db.nTotalChange += (long)(nChange);
}</function>
  <function>public static int sqlite3VdbeSetColName(Vdbe p, int idx, int var, sbyte* zName, delegate17 xDel)
{
    int rc = 0;
    sqlite3_value pColName;
    if ((p.db.mallocFailed) != 0)
    {
        return (int)(7);
    }

    pColName = (p.aColName[idx + var * p.nResColumn]);
    rc = (int)(sqlite3VdbeMemSetStr(pColName, zName, (long)(-1), (byte)(1), xDel));
    return (int)(rc);
}</function>
  <function>public static void sqlite3VdbeSetNumCols(Vdbe p, int nResColumn)
{
    int n = 0;
    sqlite3 db = p.db;
    if ((p.nResColumn) != 0)
    {
        releaseMemArray(p.aColName, (int)(p.nResColumn * 2));
        sqlite3DbFree(db, p.aColName);
    }

    n = (int)(nResColumn * 2);
    p.nResColumn = ((ushort)(nResColumn));
    p.aColName = (sqlite3_value)(sqlite3DbMallocRawNN(db, (ulong)(sizeof(sqlite3_value) * n)));
    if ((p.aColName) == (null))
        return;
    initMemArray(p.aColName, (int)(n), db, (ushort)(0x0001));
}</function>
  <function>public static void sqlite3VdbeSetP4KeyInfo(Parse pParse, Index pIdx)
{
    Vdbe v = pParse.pVdbe;
    KeyInfo pKeyInfo;
    pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
    if ((pKeyInfo) != null)
        sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
}</function>
  <function>public static void sqlite3VdbeSetSql(Vdbe p, sbyte* z, int n, byte prepFlags)
{
    if ((p) == (null))
        return;
    p.prepFlags = (byte)(prepFlags);
    if ((prepFlags &amp; 0x80) == (0))
    {
        p.expmask = (uint)(0);
    }

    p.zSql = sqlite3DbStrNDup(p.db, z, (ulong)(n));
}</function>
  <function>public static void sqlite3VdbeSetVarmask(Vdbe v, int iVar)
{
    if ((iVar) &gt;= (32))
    {
        v.expmask |= (uint)(0x80000000);
    }
    else
    {
        v.expmask |= (uint)((uint)(1) &lt;&lt; (iVar - 1));
    }
}</function>
  <function>public static void sqlite3VdbeSorterClose(sqlite3 db, VdbeCursor pCsr)
{
    VdbeSorter pSorter;
    pSorter = pCsr.uc.pSorter;
    if ((pSorter) != null)
    {
        sqlite3VdbeSorterReset(db, pSorter);
        sqlite3_free(pSorter.list.aMemory);
        sqlite3DbFree(db, pSorter);
        pCsr.uc.pSorter = null;
    }
}</function>
  <function>public static int sqlite3VdbeSorterCompare(VdbeCursor pCsr, sqlite3_value pVal, int nKeyCol, int* pRes)
{
    VdbeSorter pSorter;
    UnpackedRecord r2;
    KeyInfo pKeyInfo;
    int i = 0;
    void* pKey;
    int nKey = 0;
    pSorter = pCsr.uc.pSorter;
    r2 = pSorter.pUnpacked;
    pKeyInfo = pCsr.pKeyInfo;
    if ((r2) == (null))
    {
        r2 = pSorter.pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
        if ((r2) == (null))
            return (int)(7);
        r2.nField = (ushort)(nKeyCol);
    }

    pKey = vdbeSorterRowkey(pSorter, &amp;nKey);
    sqlite3VdbeRecordUnpack(pKeyInfo, (int)(nKey), pKey, r2);
    for (i = (int)(0); (i) &lt; (nKeyCol); i++)
    {
        if ((r2.aMem[i].flags &amp; 0x0001) != 0)
        {
            *pRes = (int)(-1);
            return (int)(0);
        }
    }

    *pRes = (int)(sqlite3VdbeRecordCompare((int)(pVal.n), pVal.z, r2));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeSorterInit(sqlite3 db, int nField, VdbeCursor pCsr)
{
    int pgsz = 0;
    int i = 0;
    VdbeSorter pSorter;
    KeyInfo pKeyInfo;
    int szKeyInfo = 0;
    int sz = 0;
    int rc = (int)(0);
    int nWorker = 0;
    if (((sqlite3TempInMemory(db)) != 0) || ((sqlite3Config.bCoreMutex) == (0)))
    {
        nWorker = (int)(0);
    }
    else
    {
        nWorker = (int)(db.aLimit[11]);
    }

    szKeyInfo = (int)(sizeof(KeyInfo) + (pCsr.pKeyInfo.nKeyField - 1) * sizeof(CollSeq));
    sz = (int)(sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask));
    pSorter = (VdbeSorter)(sqlite3DbMallocZero(db, (ulong)(sz + szKeyInfo)));
    pCsr.uc.pSorter = pSorter;
    if ((pSorter) == (null))
    {
        rc = (int)(7);
    }
    else
    {
        Btree pBt = db.aDb[0].pBt;
        pSorter.pKeyInfo = pKeyInfo = (KeyInfo)((byte*)(pSorter) + sz);
        CRuntime.memcpy(pKeyInfo, pCsr.pKeyInfo, (ulong)(szKeyInfo));
        pKeyInfo.db = null;
        if (((nField) != 0) &amp;&amp; ((nWorker) == (0)))
        {
            pKeyInfo.nKeyField = (ushort)(nField);
        }

        sqlite3BtreeEnter(pBt);
        pSorter.pgsz = (int)(pgsz = (int)(sqlite3BtreeGetPageSize(pBt)));
        sqlite3BtreeLeave(pBt);
        pSorter.nTask = (byte)(nWorker + 1);
        pSorter.iPrev = ((byte)(nWorker - 1));
        pSorter.bUseThreads = (byte)((pSorter.nTask) &gt; (1));
        pSorter.db = db;
        for (i = (int)(0); (i) &lt; (pSorter.nTask); i++)
        {
            SortSubtask pTask = pSorter.aTask[i];
            pTask.pSorter = pSorter;
        }

        if (sqlite3TempInMemory(db) == 0)
        {
            long mxCache = 0;
            uint szPma = (uint)(sqlite3Config.szPma);
            pSorter.mnPmaSize = (int)(szPma * pgsz);
            mxCache = (long)(db.aDb[0].pSchema.cache_size);
            if ((mxCache) &lt; (0))
            {
                mxCache = (long)(mxCache * -1024);
            }
            else
            {
                mxCache = (long)(mxCache * pgsz);
            }

            mxCache = (long)((mxCache) &lt; (1 &lt;&lt; 29) ? (mxCache) : (1 &lt;&lt; 29));
            pSorter.mxPmaSize = (int)((pSorter.mnPmaSize) &gt; ((int)(mxCache)) ? (pSorter.mnPmaSize) : ((int)(mxCache)));
            if ((sqlite3Config.bSmallMalloc) == (0))
            {
                pSorter.nMemory = (int)(pgsz);
                pSorter.list.aMemory = (byte*)(sqlite3Malloc((ulong)(pgsz)));
                if (pSorter.list.aMemory == null)
                    rc = (int)(7);
            }
        }

        if ((((pKeyInfo.nAllField) &lt; (13)) &amp;&amp; (((pKeyInfo.aColl[0]) == (null)) || ((pKeyInfo.aColl[0]) == (db.pDfltColl)))) &amp;&amp; ((pKeyInfo.aSortFlags[0] &amp; 0x02) == (0)))
        {
            pSorter.typeMask = (byte)(0x01 | 0x02);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VdbeSorterNext(sqlite3 db, VdbeCursor pCsr)
{
    VdbeSorter pSorter;
    int rc = 0;
    pSorter = pCsr.uc.pSorter;
    if ((pSorter.bUsePMA) != 0)
    {
        if ((pSorter.bUseThreads) != 0)
        {
            rc = (int)(vdbePmaReaderNext(pSorter.pReader));
            if (((rc) == (0)) &amp;&amp; ((pSorter.pReader.pFd) == (null)))
                rc = (int)(101);
        }
        else
        {
            int res = (int)(0);
            rc = (int)(vdbeMergeEngineStep(pSorter.pMerger, &amp;res));
            if (((rc) == (0)) &amp;&amp; ((res) != 0))
                rc = (int)(101);
        }
    }
    else
    {
        SorterRecord* pFree = pSorter.list.pList;
        pSorter.list.pList = pFree-&gt;u.pNext;
        pFree-&gt;u.pNext = null;
        if ((pSorter.list.aMemory) == (null))
            vdbeSorterRecordFree(db, pFree);
        rc = (int)(pSorter.list.pList ? 0 : 101);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3VdbeSorterReset(sqlite3 db, VdbeSorter pSorter)
{
    int i = 0;
    (void)(vdbeSorterJoinAll(pSorter, (int)(0)));
    if ((pSorter.pReader) != null)
    {
        vdbePmaReaderClear(pSorter.pReader);
        sqlite3DbFree(db, pSorter.pReader);
        pSorter.pReader = null;
    }

    vdbeMergeEngineFree(pSorter.pMerger);
    pSorter.pMerger = null;
    for (i = (int)(0); (i) &lt; (pSorter.nTask); i++)
    {
        SortSubtask pTask = pSorter.aTask[i];
        vdbeSortSubtaskCleanup(db, pTask);
        pTask.pSorter = pSorter;
    }

    if ((pSorter.list.aMemory) == (null))
    {
        vdbeSorterRecordFree(null, pSorter.list.pList);
    }

    pSorter.list.pList = null;
    pSorter.list.szPMA = (int)(0);
    pSorter.bUsePMA = (byte)(0);
    pSorter.iMemory = (int)(0);
    pSorter.mxKeysize = (int)(0);
    sqlite3DbFree(db, pSorter.pUnpacked);
    pSorter.pUnpacked = null;
}</function>
  <function>public static int sqlite3VdbeSorterRewind(VdbeCursor pCsr, int* pbEof)
{
    VdbeSorter pSorter;
    int rc = (int)(0);
    pSorter = pCsr.uc.pSorter;
    if ((pSorter.bUsePMA) == (0))
    {
        if ((pSorter.list.pList) != null)
        {
            *pbEof = (int)(0);
            rc = (int)(vdbeSorterSort(pSorter.aTask[0], &amp;pSorter.list));
        }
        else
        {
            *pbEof = (int)(1);
        }

        return (int)(rc);
    }

    rc = (int)(vdbeSorterFlushPMA(pSorter));
    rc = (int)(vdbeSorterJoinAll(pSorter, (int)(rc)));
    if ((rc) == (0))
    {
        rc = (int)(vdbeSorterSetupMerge(pSorter));
        *pbEof = (int)(0);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VdbeSorterRowkey(VdbeCursor pCsr, sqlite3_value pOut)
{
    VdbeSorter pSorter;
    void* pKey;
    int nKey = 0;
    pSorter = pCsr.uc.pSorter;
    pKey = vdbeSorterRowkey(pSorter, &amp;nKey);
    if ((sqlite3VdbeMemClearAndResize(pOut, (int)(nKey))) != 0)
    {
        return (int)(7);
    }

    pOut.n = (int)(nKey);
    ((pOut).flags = (ushort)(((pOut).flags &amp; ~(0xc1bf | 0x4000)) | 0x0010));
    CRuntime.memcpy(pOut.z, pKey, (ulong)(nKey));
    return (int)(0);
}</function>
  <function>public static int sqlite3VdbeSorterWrite(VdbeCursor pCsr, sqlite3_value pVal)
{
    VdbeSorter pSorter;
    int rc = (int)(0);
    SorterRecord* pNew;
    int bFlush = 0;
    int nReq = 0;
    int nPMA = 0;
    int t = 0;
    pSorter = pCsr.uc.pSorter;
    t = (int)((uint)(*((byte*)(&amp;pVal.z[1]))));
    if ((t) &gt;= (0x80))
        sqlite3GetVarint32(((byte*)(&amp;pVal.z[1])), (uint*)(&amp;(t)));
    if ((((t) &gt; (0)) &amp;&amp; ((t) &lt; (10))) &amp;&amp; (t != 7))
    {
        pSorter.typeMask &amp;= (byte)(0x01);
    }
    else if (((t) &gt; (10)) &amp;&amp; ((t &amp; 0x01) != 0))
    {
        pSorter.typeMask &amp;= (byte)(0x02);
    }
    else
    {
        pSorter.typeMask = (byte)(0);
    }

    nReq = (int)(pVal.n + sizeof(SorterRecord));
    nPMA = (int)(pVal.n + sqlite3VarintLen((ulong)(pVal.n)));
    if ((pSorter.mxPmaSize) != 0)
    {
        if ((pSorter.list.aMemory) != null)
        {
            bFlush = (int)(((pSorter.iMemory) != 0) &amp;&amp; ((pSorter.iMemory + nReq) &gt; (pSorter.mxPmaSize)) ? 1 : 0);
        }
        else
        {
            bFlush = (int)(((pSorter.list.szPMA) &gt; (pSorter.mxPmaSize)) || (((pSorter.list.szPMA) &gt; (pSorter.mnPmaSize)) &amp;&amp; ((sqlite3HeapNearlyFull()) != 0)) ? 1 : 0);
        }

        if ((bFlush) != 0)
        {
            rc = (int)(vdbeSorterFlushPMA(pSorter));
            pSorter.list.szPMA = (int)(0);
            pSorter.iMemory = (int)(0);
        }
    }

    pSorter.list.szPMA += (int)(nPMA);
    if ((nPMA) &gt; (pSorter.mxKeysize))
    {
        pSorter.mxKeysize = (int)(nPMA);
    }

    if ((pSorter.list.aMemory) != null)
    {
        int nMin = (int)(pSorter.iMemory + nReq);
        if ((nMin) &gt; (pSorter.nMemory))
        {
            byte* aNew;
            long nNew = (long)(2 * (long)(pSorter.nMemory));
            int iListOff = (int)(-1);
            if ((pSorter.list.pList) != null)
            {
                iListOff = (int)((byte*)(pSorter.list.pList) - pSorter.list.aMemory);
            }

            while ((nNew) &lt; (nMin))
            {
                nNew = (long)(nNew * 2);
            }

            if ((nNew) &gt; (pSorter.mxPmaSize))
                nNew = (long)(pSorter.mxPmaSize);
            if ((nNew) &lt; (nMin))
                nNew = (long)(nMin);
            aNew = sqlite3Realloc(pSorter.list.aMemory, (ulong)(nNew));
            if (aNew == null)
                return (int)(7);
            if ((iListOff) &gt;= (0))
            {
                pSorter.list.pList = (SorterRecord*)(&amp;aNew[iListOff]);
            }

            pSorter.list.aMemory = aNew;
            pSorter.nMemory = (int)(nNew);
        }

        pNew = (SorterRecord*)(&amp;pSorter.list.aMemory[pSorter.iMemory]);
        pSorter.iMemory += (int)(((nReq) + 7) &amp; ~7);
        if ((pSorter.list.pList) != null)
        {
            pNew-&gt;u.iNext = ((int)((byte*)(pSorter.list.pList) - pSorter.list.aMemory));
        }
    }
    else
    {
        pNew = (SorterRecord*)(sqlite3Malloc((ulong)(nReq)));
        if ((pNew) == (null))
        {
            return (int)(7);
        }

        pNew-&gt;u.pNext = pSorter.list.pList;
    }

    CRuntime.memcpy(((void*)((pNew) + 1)), pVal.z, (ulong)(pVal.n));
    pNew-&gt;nVal = (int)(pVal.n);
    pSorter.list.pList = pNew;
    return (int)(rc);
}</function>
  <function>public static void sqlite3VdbeSwap(Vdbe pA, Vdbe pB)
{
    Vdbe tmp = new Vdbe(); Vdbe  pTmp ; 
    sbyte* zTmp;
    tmp = (Vdbe)(pA);
    pA = (Vdbe)(pB);
    pB = (Vdbe)(tmp);
    pTmp = pA.pNext;
    pA.pNext = pB.pNext;
    pB.pNext = pTmp;
    pTmp = pA.pPrev;
    pA.pPrev = pB.pPrev;
    pB.pPrev = pTmp;
    zTmp = pA.zSql;
    pA.zSql = pB.zSql;
    pB.zSql = zTmp;
    pB.expmask = (uint)(pA.expmask);
    pB.prepFlags = (byte)(pA.prepFlags);
    CRuntime.memcpy(pB.aCounter, pA.aCounter, (ulong)(9 * sizeof(uint)));
    pB.aCounter[5]++;
}</function>
  <function>public static VdbeOp* sqlite3VdbeTakeOpArray(Vdbe p, int* pnOp, int* pnMaxArg)
{
    VdbeOp* aOp = p.aOp;
    resolveP2Values(p, pnMaxArg);
    *pnOp = (int)(p.nOp);
    p.aOp = null;
    return aOp;
}</function>
  <function>public static int sqlite3VdbeTransferError(Vdbe p)
{
    sqlite3 db = p.db;
    int rc = (int)(p.rc);
    if ((p.zErrMsg) != null)
    {
        db.bBenignMalloc++;
        sqlite3BeginBenignMalloc();
        if ((db.pErr) == (null))
            db.pErr = sqlite3ValueNew(db);
        sqlite3ValueSetStr(db.pErr, (int)(-1), p.zErrMsg, (byte)(1), ((Void(Void * ))(-1)));
        sqlite3EndBenignMalloc();
        db.bBenignMalloc--;
    }
    else if ((db.pErr) != null)
    {
        sqlite3ValueSetNull(db.pErr);
    }

    db.errCode = (int)(rc);
    db.errByteOffset = (int)(-1);
    return (int)(rc);
}</function>
  <function>public static void sqlite3VdbeUsesBtree(Vdbe p, int i)
{
    (p.btreeMask) |= (uint)(((uint)(1)) &lt;&lt; (i));
    if ((i != 1) &amp;&amp; ((sqlite3BtreeSharable(p.db.aDb[i].pBt)) != 0))
    {
        (p.lockMask) |= (uint)(((uint)(1)) &lt;&lt; (i));
    }
}</function>
  <function>public static void sqlite3VectorErrorMsg(Parse pParse, Expr pExpr)
{
    if ((((pExpr).flags &amp; 0x000800) != 0))
    {
        sqlite3SubselectError(pParse, (int)(pExpr.x.pSelect.pEList.nExpr), (int)(1));
    }
    else
    {
        sqlite3ErrorMsg(pParse, "row value misused");
    }
}</function>
  <function>public static Expr sqlite3VectorFieldSubexpr(Expr pVector, int i)
{
    if ((sqlite3ExprIsVector(pVector)) != 0)
    {
        if (((pVector.op) == (138)) || ((pVector.op2) == (138)))
        {
            return pVector.x.pSelect.pEList.a[i].pExpr;
        }
        else
        {
            return pVector.x.pList.a[i].pExpr;
        }
    }

    return pVector;
}</function>
  <function>public static int sqlite3ViewGetColumnNames(Parse pParse, Table pTable)
{
    Table pSelTab;
    Select pSel;
    int nErr = (int)(0);
    int n = 0;
    sqlite3 db = pParse.db;
    int rc = 0;
    delegate67 xAuth;
    if ((((pTable).eTabType) == (1)))
    {
        db.nSchemaLock++;
        rc = (int)(sqlite3VtabCallConnect(pParse, pTable));
        db.nSchemaLock--;
        return (int)(rc);
    }

    if ((pTable.nCol) &gt; (0))
        return (int)(0);
    if ((pTable.nCol) &lt; (0))
    {
        sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable.zName);
        return (int)(1);
    }

    pSel = sqlite3SelectDup(db, pTable.u.view.pSelect, (int)(0));
    if ((pSel) != null)
    {
        byte eParseMode = (byte)(pParse.eParseMode);
        pParse.eParseMode = (byte)(0);
        n = (int)(pParse.nTab);
        sqlite3SrcListAssignCursors(pParse, pSel.pSrc);
        pTable.nCol = (short)(-1);
        db.lookaside.bDisable++;
        db.lookaside.sz = (ushort)(0);
        xAuth = db.xAuth;
        db.xAuth = null;
        pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, (sbyte)(0x40));
        db.xAuth = xAuth;
        pParse.nTab = (int)(n);
        if ((pSelTab) == (null))
        {
            pTable.nCol = (short)(0);
            nErr++;
        }
        else if ((pTable.pCheck) != null)
        {
            sqlite3ColumnsFromExprList(pParse, pTable.pCheck, &amp;pTable.nCol, &amp;pTable.aCol);
            if (((pParse.nErr) == (0)) &amp;&amp; ((pTable.nCol) == (pSel.pEList.nExpr)))
            {
                sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel, (sbyte)(0x40));
            }
        }
        else
        {
            pTable.nCol = (short)(pSelTab.nCol);
            pTable.aCol = pSelTab.aCol;
            pTable.tabFlags |= (uint)(pSelTab.tabFlags &amp; 0x0062);
            pSelTab.nCol = (short)(0);
            pSelTab.aCol = null;
        }

        pTable.nNVCol = (short)(pTable.nCol);
        sqlite3DeleteTable(db, pSelTab);
        sqlite3SelectDelete(db, pSel);
        db.lookaside.bDisable--;
        db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
        pParse.eParseMode = (byte)(eParseMode);
    }
    else
    {
        nErr++;
    }

    pTable.pSchema.schemaFlags |= (ushort)(0x0002);
    if ((db.mallocFailed) != 0)
    {
        sqlite3DeleteColumnNames(db, pTable);
    }

    return (int)(nErr);
}</function>
  <function>public static int* sqlite3VListAdd(sqlite3 db, int* pIn, sbyte* zName, int nName, int iVal)
{
    int nInt = 0;
    sbyte* z;
    int i = 0;
    nInt = (int)(nName / 4 + 3);
    if (((pIn) == (null)) || ((pIn[1] + nInt) &gt; (pIn[0])))
    {
        long nAlloc = (long)(((pIn) != 0 ? 2 * (long)(pIn[0]) : 10) + nInt);
        int* pOut = sqlite3DbRealloc(db, pIn, (ulong)(nAlloc * sizeof(int)));
        if ((pOut) == (null))
            return pIn;
        if ((pIn) == (null))
            pOut[1] = (int)(2);
        pIn = pOut;
        pIn[0] = (int)(nAlloc);
    }

    i = (int)(pIn[1]);
    pIn[i] = (int)(iVal);
    pIn[i + 1] = (int)(nInt);
    z = (sbyte*)(&amp;pIn[i + 2]);
    pIn[1] = (int)(i + nInt);
    CRuntime.memcpy(z, zName, (ulong)(nName));
    z[nName] = (sbyte)(0);
    return pIn;
}</function>
  <function>public static int sqlite3VListNameToNum(int* pIn, sbyte* zName, int nName)
{
    int i = 0; int  mx  =  0 ; 
    if ((pIn) == (null))
        return (int)(0);
    mx = (int)(pIn[1]);
    i = (int)(2);
    do
    {
        sbyte* z = (sbyte*)(&amp;pIn[i + 2]);
        if (((CRuntime.strncmp(z, zName, (ulong)(nName))) == (0)) &amp;&amp; ((z[nName]) == (0)))
            return (int)(pIn[i]);
        i += (int)(pIn[i + 1]);
    }
    while ((i) &lt; (mx));
    return (int)(0);
}</function>
  <function>public static sbyte* sqlite3VListNumToName(int* pIn, int iVal)
{
    int i = 0; int  mx  =  0 ; 
    if ((pIn) == (null))
        return null;
    mx = (int)(pIn[1]);
    i = (int)(2);
    do
    {
        if ((pIn[i]) == (iVal))
            return (sbyte*)(&amp;pIn[i + 2]);
        i += (int)(pIn[i + 1]);
    }
    while ((i) &lt; (mx));
    return null;
}</function>
  <function>public static sbyte* sqlite3VMPrintf(sqlite3 db, sbyte* zFormat, sbyte* ap)
{
    sbyte* z;
    sbyte* zBase = stackalloc sbyte[70];
    sqlite3_str acc = new sqlite3_str();
    sqlite3StrAccumInit(acc, db, zBase, (int)(70 * sizeof(sbyte)), (int)(db.aLimit[0]));
    acc.printfFlags = (byte)(0x01);
    sqlite3_str_vappendf(acc, zFormat, ap);
    z = sqlite3StrAccumFinish(acc);
    if ((acc.accError) == (7))
    {
        sqlite3OomFault(db);
    }

    return z;
}</function>
  <function>public static void sqlite3VtabArgExtend(Parse pParse, Token* p)
{
    Token* pArg = &amp;pParse.sArg;
    if ((pArg-&gt;z) == (null))
    {
        pArg-&gt;z = p-&gt;z;
        pArg-&gt;n = (uint)(p-&gt;n);
    }
    else
    {
        pArg-&gt;n = (uint)((int)(&amp;p-&gt;z[p-&gt;n] - pArg-&gt;z));
    }
}</function>
  <function>public static void sqlite3VtabArgInit(Parse pParse)
{
    addArgumentToVtab(pParse);
    pParse.sArg.z = null;
    pParse.sArg.n = (uint)(0);
}</function>
  <function>public static int sqlite3VtabBegin(sqlite3 db, VTable pVTab)
{
    int rc = (int)(0);
    sqlite3_module pModule;
    if (((((db).nVTrans) &gt; (0)) &amp;&amp; (((db).aVTrans) == (null))))
    {
        return (int)(6);
    }

    if (pVTab == null)
    {
        return (int)(0);
    }

    pModule = pVTab.pVtab.pModule;
    if ((pModule.xBegin) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (db.nVTrans); i++)
        {
            if ((db.aVTrans[i]) == (pVTab))
            {
                return (int)(0);
            }
        }

        rc = (int)(growVTrans(db));
        if ((rc) == (0))
        {
            rc = (int)(pModule.xBegin(pVTab.pVtab));
            if ((rc) == (0))
            {
                int iSvpt = (int)(db.nStatement + db.nSavepoint);
                addToVTrans(db, pVTab);
                if (((iSvpt) != 0) &amp;&amp; ((pModule.xSavepoint) != null))
                {
                    pVTab.iSavepoint = (int)(iSvpt);
                    rc = (int)(pModule.xSavepoint(pVTab.pVtab, (int)(iSvpt - 1)));
                }
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3VtabBeginParse(Parse pParse, Token* pName1, Token* pName2, Token* pModuleName, int ifNotExists)
{
    Table pTable;
    sqlite3 db;
    sqlite3StartTable(pParse, pName1, pName2, (int)(0), (int)(0), (int)(1), (int)(ifNotExists));
    pTable = pParse.pNewTable;
    if ((pTable) == (null))
        return;
    pTable.eTabType = (byte)(1);
    db = pParse.db;
    addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
    addModuleArgument(pParse, pTable, null);
    addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable.zName));
    pParse.sNameToken.n = (uint)((int)(&amp;pModuleName-&gt;z[pModuleName-&gt;n] - pParse.sNameToken.z));
    if ((pTable.u.vtab.azArg) != null)
    {
        int iDb = (int)(sqlite3SchemaToIndex(db, pTable.pSchema));
        sqlite3AuthCheck(pParse, (int)(29), pTable.zName, pTable.u.vtab.azArg[0], pParse.db.aDb[iDb].zDbSName);
    }
}</function>
  <function>public static int sqlite3VtabCallConnect(Parse pParse, Table pTab)
{
    sqlite3 db = pParse.db;
    sbyte* zMod;
    Module pMod;
    int rc = 0;
    if ((sqlite3GetVTable(db, pTab)) != null)
    {
        return (int)(0);
    }

    zMod = pTab.u.vtab.azArg[0];
    pMod = (Module)(sqlite3HashFind(&amp;db.aModule, zMod));
    if (pMod == null)
    {
        sbyte* zModule = pTab.u.vtab.azArg[0];
        sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
        rc = (int)(1);
    }
    else
    {
        sbyte* zErr = null;
        rc = (int)(vtabCallConstructor(db, pTab, pMod, pMod.pModule.xConnect, &amp;zErr));
        if (rc != 0)
        {
            sqlite3ErrorMsg(pParse, "%s", zErr);
            pParse.rc = (int)(rc);
        }

        sqlite3DbFree(db, zErr);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VtabCallCreate(sqlite3 db, int iDb, sbyte* zTab, sbyte** pzErr)
{
    int rc = (int)(0);
    Table pTab;
    Module pMod;
    sbyte* zMod;
    pTab = sqlite3FindTable(db, zTab, db.aDb[iDb].zDbSName);
    zMod = pTab.u.vtab.azArg[0];
    pMod = (Module)(sqlite3HashFind(&amp;db.aModule, zMod));
    if ((((pMod) == (null)) || ((pMod.pModule.xCreate) == (null))) || ((pMod.pModule.xDestroy) == (null)))
    {
        *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
        rc = (int)(1);
    }
    else
    {
        rc = (int)(vtabCallConstructor(db, pTab, pMod, pMod.pModule.xCreate, pzErr));
    }

    if (((rc) == (0)) &amp;&amp; ((sqlite3GetVTable(db, pTab)) != null))
    {
        rc = (int)(growVTrans(db));
        if ((rc) == (0))
        {
            addToVTrans(db, sqlite3GetVTable(db, pTab));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VtabCallDestroy(sqlite3 db, int iDb, sbyte* zTab)
{
    int rc = (int)(0);
    Table pTab;
    pTab = sqlite3FindTable(db, zTab, db.aDb[iDb].zDbSName);
    if (((pTab != null) &amp;&amp; ((((pTab).eTabType) == (1)) != 0)) &amp;&amp; (pTab.u.vtab.p != null))
    {
        VTable p;
        delegate23 xDestroy;
        for (p = pTab.u.vtab.p; p; p = p.pNext)
        {
            if ((p.pVtab.nRef) &gt; (0))
            {
                return (int)(6);
            }
        }

        p = vtabDisconnectAll(db, pTab);
        xDestroy = p.pMod.pModule.xDestroy;
        if ((xDestroy) == (null))
            xDestroy = p.pMod.pModule.xDisconnect;
        pTab.nTabRef++;
        rc = (int)(xDestroy(p.pVtab));
        if ((rc) == (0))
        {
            p.pVtab = null;
            pTab.u.vtab.p = null;
            sqlite3VtabUnlock(p);
        }

        sqlite3DeleteTable(db, pTab);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3VtabClear(sqlite3 db, Table p)
{
    if ((db == null) || ((db.pnBytesFreed) == (null)))
        vtabDisconnectAll(null, p);
    if ((p.u.vtab.azArg) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (p.u.vtab.nArg); i++)
        {
            if (i != 1)
                sqlite3DbFree(db, p.u.vtab.azArg[i]);
        }

        sqlite3DbFree(db, p.u.vtab.azArg);
    }
}</function>
  <function>public static int sqlite3VtabCommit(sqlite3 db)
{
    callFinaliser(db, (int)((ulong)(&amp;((0).xCommit))));
    return (int)(0);
}</function>
  <function>public static Module sqlite3VtabCreateModule(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
{
    Module pMod;
    Module pDel;
    sbyte* zCopy;
    if ((pModule) == (null))
    {
        zCopy = zName;
        pMod = null;
    }
    else
    {
        int nName = (int)(sqlite3Strlen30(zName));
        pMod = (Module)(sqlite3Malloc((ulong)(sizeof(Module) + nName + 1)));
        if ((pMod) == (null))
        {
            sqlite3OomFault(db);
            return null;
        }

        zCopy = (sbyte*)(pMod[1]);
        CRuntime.memcpy(zCopy, zName, (ulong)(nName + 1));
        pMod.zName = zCopy;
        pMod.pModule = pModule;
        pMod.pAux = pAux;
        pMod.xDestroy = xDestroy;
        pMod.pEpoTab = null;
        pMod.nRefModule = (int)(1);
    }

    pDel = (Module)(sqlite3HashInsert(&amp;db.aModule, zCopy, (void*)(pMod)));
    if ((pDel) != null)
    {
        if ((pDel) == (pMod))
        {
            sqlite3OomFault(db);
            sqlite3DbFree(db, pDel);
            pMod = null;
        }
        else
        {
            sqlite3VtabEponymousTableClear(db, pDel);
            sqlite3VtabModuleUnref(db, pDel);
        }
    }

    return pMod;
}</function>
  <function>public static void sqlite3VtabDisconnect(sqlite3 db, Table p)
{
    VTable ppVTab;
    for (ppVTab = p.u.vtab.p; ppVTab; ppVTab = (ppVTab).pNext)
    {
        if (((ppVTab).db) == (db))
        {
            VTable pVTab = ppVTab;
            ppVTab = pVTab.pNext;
            sqlite3VtabUnlock(pVTab);
            break;
        }
    }
}</function>
  <function>public static void sqlite3VtabEponymousTableClear(sqlite3 db, Module pMod)
{
    Table pTab = pMod.pEpoTab;
    if (pTab != null)
    {
        pTab.tabFlags |= (uint)(0x00004000);
        sqlite3DeleteTable(db, pTab);
        pMod.pEpoTab = null;
    }
}</function>
  <function>public static int sqlite3VtabEponymousTableInit(Parse pParse, Module pMod)
{
    sqlite3_module pModule = pMod.pModule;
    Table pTab;
    sbyte* zErr = null;
    int rc = 0;
    sqlite3 db = pParse.db;
    if ((pMod.pEpoTab) != null)
        return (int)(1);
    if ((pModule.xCreate != null) &amp;&amp; (pModule.xCreate != pModule.xConnect))
        return (int)(0);
    pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
    if ((pTab) == (null))
        return (int)(0);
    pTab.zName = sqlite3DbStrDup(db, pMod.zName);
    if ((pTab.zName) == (null))
    {
        sqlite3DbFree(db, pTab);
        return (int)(0);
    }

    pMod.pEpoTab = pTab;
    pTab.nTabRef = (uint)(1);
    pTab.eTabType = (byte)(1);
    pTab.pSchema = db.aDb[0].pSchema;
    pTab.iPKey = (short)(-1);
    pTab.tabFlags |= (uint)(0x00008000);
    addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName));
    addModuleArgument(pParse, pTab, null);
    addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName));
    rc = (int)(vtabCallConstructor(db, pTab, pMod, pModule.xConnect, &amp;zErr));
    if ((rc) != 0)
    {
        sqlite3ErrorMsg(pParse, "%s", zErr);
        sqlite3DbFree(db, zErr);
        sqlite3VtabEponymousTableClear(db, pMod);
    }

    return (int)(1);
}</function>
  <function>public static void sqlite3VtabFinishParse(Parse pParse, Token* pEnd)
{
    Table pTab = pParse.pNewTable;
    sqlite3 db = pParse.db;
    if ((pTab) == (null))
        return;
    addArgumentToVtab(pParse);
    pParse.sArg.z = null;
    if ((pTab.u.vtab.nArg) &lt; (1))
        return;
    if (db.init.busy == 0)
    {
        sbyte* zStmt;
        sbyte* zWhere;
        int iDb = 0;
        int iReg = 0;
        Vdbe v;
        sqlite3MayAbort(pParse);
        if ((pEnd) != null)
        {
            pParse.sNameToken.n = (uint)((int)(pEnd-&gt;z - pParse.sNameToken.z) + pEnd-&gt;n);
        }

        zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &amp;pParse.sNameToken);
        iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
        sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q WHERE rowid=#%d", db.aDb[iDb].zDbSName, pTab.zName, pTab.zName, zStmt, (int)(pParse.regRowid));
        v = sqlite3GetVdbe(pParse);
        sqlite3ChangeCookie(pParse, (int)(iDb));
        sqlite3VdbeAddOp0(v, (int)(165));
        zWhere = sqlite3MPrintf(db, "name=%Q AND sql=%Q", pTab.zName, zStmt);
        sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), zWhere, (ushort)(0));
        sqlite3DbFree(db, zStmt);
        iReg = (int)(++pParse.nMem);
        sqlite3VdbeLoadString(v, (int)(iReg), pTab.zName);
        sqlite3VdbeAddOp2(v, (int)(170), (int)(iDb), (int)(iReg));
    }
    else
    {
        Table pOld;
        Schema pSchema = pTab.pSchema;
        sbyte* zName = pTab.zName;
        sqlite3MarkAllShadowTablesOf(db, pTab);
        pOld = sqlite3HashInsert(&amp;pSchema.tblHash, zName, pTab);
        if ((pOld) != null)
        {
            sqlite3OomFault(db);
            return;
        }

        pParse.pNewTable = null;
    }
}</function>
  <function>public static void sqlite3VtabImportErrmsg(Vdbe p, sqlite3_vtab pVtab)
{
    if ((pVtab.zErrMsg) != null)
    {
        sqlite3 db = p.db;
        sqlite3DbFree(db, p.zErrMsg);
        p.zErrMsg = sqlite3DbStrDup(db, pVtab.zErrMsg);
        sqlite3_free(pVtab.zErrMsg);
        pVtab.zErrMsg = null;
    }
}</function>
  <function>public static void sqlite3VtabLock(VTable pVTab)
{
    pVTab.nRef++;
}</function>
  <function>public static void sqlite3VtabMakeWritable(Parse pParse, Table pTab)
{
    Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
    int i = 0; int  n  =  0 ; 
    Table apVtabLock;
    for (i = (int)(0); (i) &lt; (pToplevel.nVtabLock); i++)
    {
        if ((pTab) == (pToplevel.apVtabLock[i]))
            return;
    }

    n = (int)((pToplevel.nVtabLock + 1) * sizeof(Table));
    apVtabLock = sqlite3Realloc(pToplevel.apVtabLock, (ulong)(n));
    if ((apVtabLock) != null)
    {
        pToplevel.apVtabLock = apVtabLock;
        pToplevel.apVtabLock[pToplevel.nVtabLock++] = pTab;
    }
    else
    {
        sqlite3OomFault(pToplevel.db);
    }
}</function>
  <function>public static void sqlite3VtabModuleUnref(sqlite3 db, Module pMod)
{
    pMod.nRefModule--;
    if ((pMod.nRefModule) == (0))
    {
        if ((pMod.xDestroy) != null)
        {
            pMod.xDestroy(pMod.pAux);
        }

        sqlite3DbFree(db, pMod);
    }
}</function>
  <function>public static FuncDef sqlite3VtabOverloadFunction(sqlite3 db, FuncDef pDef, int nArg, Expr pExpr)
{
    Table pTab;
    sqlite3_vtab pVtab;
    sqlite3_module pMod;
    delegate68 xSFunc = null;
    void* pArg = null;
    FuncDef pNew;
    int rc = (int)(0);
    if (((pExpr) == (null)))
        return pDef;
    if (pExpr.op != 167)
        return pDef;
    pTab = pExpr.y.pTab;
    if ((pTab) == (null))
        return pDef;
    if (!(((pTab).eTabType) == (1)))
        return pDef;
    pVtab = sqlite3GetVTable(db, pTab).pVtab;
    pMod = pVtab.pModule;
    if ((pMod.xFindFunction) == (null))
        return pDef;
    rc = (int)(pMod.xFindFunction(pVtab, (int)(nArg), pDef.zName, &amp;xSFunc, &amp;pArg));
    if ((rc) == (0))
    {
        return pDef;
    }

    pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(FuncDef) + sqlite3Strlen30(pDef.zName) + 1));
    if ((pNew) == (null))
    {
        return pDef;
    }

    pNew = (FuncDef)(pDef);
    pNew.zName = (sbyte*)(pNew[1]);
    CRuntime.memcpy((sbyte*)(pNew[1]), pDef.zName, (ulong)(sqlite3Strlen30(pDef.zName) + 1));
    pNew.xSFunc = xSFunc;
    pNew.pUserData = pArg;
    pNew.funcFlags |= (uint)(0x0010);
    return pNew;
}</function>
  <function>public static int sqlite3VtabRollback(sqlite3 db)
{
    callFinaliser(db, (int)((ulong)(&amp;((0).xRollback))));
    return (int)(0);
}</function>
  <function>public static int sqlite3VtabSavepoint(sqlite3 db, int op, int iSavepoint)
{
    int rc = (int)(0);
    if ((db.aVTrans) != null)
    {
        int i = 0;
        for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nVTrans)); i++)
        {
            VTable pVTab = db.aVTrans[i];
            sqlite3_module pMod = pVTab.pMod.pModule;
            if (((pVTab.pVtab) != null) &amp;&amp; ((pMod.iVersion) &gt;= (2)))
            {
                delegate22 xMethod;
                sqlite3VtabLock(pVTab);
                switch (op)
                {
                    case 0:
                        xMethod = pMod.xSavepoint;
                        pVTab.iSavepoint = (int)(iSavepoint + 1);
                        break;
                    case 2:
                        xMethod = pMod.xRollbackTo;
                        break;
                    default:
                        xMethod = pMod.xRelease;
                        break;
                }

                if (((xMethod) != null) &amp;&amp; ((pVTab.iSavepoint) &gt; (iSavepoint)))
                {
                    rc = (int)(xMethod(pVTab.pVtab, (int)(iSavepoint)));
                }

                sqlite3VtabUnlock(pVTab);
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3VtabSync(sqlite3 db, Vdbe p)
{
    int i = 0;
    int rc = (int)(0);
    VTable aVTrans = db.aVTrans;
    db.aVTrans = null;
    for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nVTrans)); i++)
    {
        delegate23 x;
        sqlite3_vtab pVtab = aVTrans[i].pVtab;
        if (((pVtab) != null) &amp;&amp; ((x = pVtab.pModule.xSync) != null))
        {
            rc = (int)(x(pVtab));
            sqlite3VtabImportErrmsg(p, pVtab);
        }
    }

    db.aVTrans = aVTrans;
    return (int)(rc);
}</function>
  <function>public static void sqlite3VtabUnlock(VTable pVTab)
{
    sqlite3 db = pVTab.db;
    pVTab.nRef--;
    if ((pVTab.nRef) == (0))
    {
        sqlite3_vtab p = pVTab.pVtab;
        sqlite3VtabModuleUnref(pVTab.db, pVTab.pMod);
        if ((p) != null)
        {
            p.pModule.xDisconnect(p);
        }

        sqlite3DbFree(db, pVTab);
    }
}</function>
  <function>public static void sqlite3VtabUnlockList(sqlite3 db)
{
    VTable p = db.pDisconnect;
    if ((p) != null)
    {
        db.pDisconnect = null;
        sqlite3ExpirePreparedStatements(db, (int)(0));
        do
        {
            VTable pNext = p.pNext;
            sqlite3VtabUnlock(p);
            p = pNext;
        }
        while ((p) != null);
    }
}</function>
  <function>public static int sqlite3WalBeginReadTransaction(Wal pWal, int* pChanged)
{
    int rc = 0;
    int cnt = (int)(0);
    do
    {
        rc = (int)(walTryBeginRead(pWal, pChanged, (int)(0), (int)(++cnt)));
    }
    while ((rc) == (-1));
    return (int)(rc);
}</function>
  <function>public static int sqlite3WalBeginWriteTransaction(Wal pWal)
{
    int rc = 0;
    if ((pWal.readOnly) != 0)
    {
        return (int)(8);
    }

    rc = (int)(walLockExclusive(pWal, (int)(0), (int)(1)));
    if ((rc) != 0)
    {
        return (int)(rc);
    }

    pWal.writeLock = (byte)(1);
    if (memcmp(&amp;pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr))) != 0)
    {
        walUnlockExclusive(pWal, (int)(0), (int)(1));
        pWal.writeLock = (byte)(0);
        rc = (int)(5 | (2 &lt;&lt; 8));
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3WalCallback(Wal pWal)
{
    uint ret = (uint)(0);
    if ((pWal) != null)
    {
        ret = (uint)(pWal.iCallback);
        pWal.iCallback = (uint)(0);
    }

    return (int)(ret);
}</function>
  <function>public static int sqlite3WalCheckpoint(Wal pWal, sqlite3 db, int eMode, delegate19 xBusy, void* pBusyArg, int sync_flags, int nBuf, byte* zBuf, int* pnLog, int* pnCkpt)
{
    int rc = 0;
    int isChanged = (int)(0);
    int eMode2 = (int)(eMode);
    delegate19 xBusy2 = xBusy;
    if ((pWal.readOnly) != 0)
        return (int)(8);
    (void)(0);
    rc = (int)(walLockExclusive(pWal, (int)(1), (int)(1)));
    if ((rc) == (0))
    {
        pWal.ckptLock = (byte)(1);
        if (eMode != 0)
        {
            rc = (int)(walBusyLock(pWal, xBusy2, pBusyArg, (int)(0), (int)(1)));
            if ((rc) == (0))
            {
                pWal.writeLock = (byte)(1);
            }
            else if ((rc) == (5))
            {
                eMode2 = (int)(0);
                xBusy2 = null;
                rc = (int)(0);
            }
        }
    }

    if ((rc) == (0))
    {
        rc = (int)(walIndexReadHdr(pWal, &amp;isChanged));
        (void)(0);
        if (((isChanged) != 0) &amp;&amp; ((pWal.pDbFd.pMethods.iVersion) &gt;= (3)))
        {
            sqlite3OsUnfetch(pWal.pDbFd, (long)(0), null);
        }
    }

    if ((rc) == (0))
    {
        if (((pWal.hdr.mxFrame) != 0) &amp;&amp; (walPagesize(pWal) != nBuf))
        {
            rc = (int)(sqlite3CorruptError((int)(64882)));
        }
        else
        {
            rc = (int)(walCheckpoint(pWal, db, (int)(eMode2), xBusy2, pBusyArg, (int)(sync_flags), zBuf));
        }

        if (((rc) == (0)) || ((rc) == (5)))
        {
            if ((pnLog) != null)
                *pnLog = ((int)(pWal.hdr.mxFrame));
            if ((pnCkpt) != null)
                *pnCkpt = ((int)(walCkptInfo(pWal)-&gt;nBackfill));
        }
    }

    if ((isChanged) != 0)
    {
        CRuntime.memset(&amp;pWal.hdr, (int)(0), (ulong)(sizeof(WalIndexHdr)));
    }

    sqlite3WalEndWriteTransaction(pWal);
    if ((pWal.ckptLock) != 0)
    {
        walUnlockExclusive(pWal, (int)(1), (int)(1));
        pWal.ckptLock = (byte)(0);
    }

    return (int)(((rc) == (0)) &amp;&amp; (eMode != eMode2) ? 5 : rc);
}</function>
  <function>public static int sqlite3WalClose(Wal pWal, sqlite3 db, int sync_flags, int nBuf, byte* zBuf)
{
    int rc = (int)(0);
    if ((pWal) != null)
    {
        int isDelete = (int)(0);
        if ((zBuf != null) &amp;&amp; ((0) == (rc = (int)(sqlite3OsLock(pWal.pDbFd, (int)(4))))))
        {
            if ((pWal.exclusiveMode) == (0))
            {
                pWal.exclusiveMode = (byte)(1);
            }

            rc = (int)(sqlite3WalCheckpoint(pWal, db, (int)(0), null, null, (int)(sync_flags), (int)(nBuf), zBuf, null, null));
            if ((rc) == (0))
            {
                int bPersist = (int)(-1);
                sqlite3OsFileControlHint(pWal.pDbFd, (int)(10), &amp;bPersist);
                if (bPersist != 1)
                {
                    isDelete = (int)(1);
                }
                else if ((pWal.mxWalSize) &gt;= (0))
                {
                    walLimitSize(pWal, (long)(0));
                }
            }
        }

        walIndexClose(pWal, (int)(isDelete));
        sqlite3OsClose(pWal.pWalFd);
        if ((isDelete) != 0)
        {
            sqlite3BeginBenignMalloc();
            sqlite3OsDelete(pWal.pVfs, pWal.zWalName, (int)(0));
            sqlite3EndBenignMalloc();
        }

        sqlite3_free((void*)(pWal.apWiData));
        sqlite3_free(pWal);
    }

    return (int)(rc);
}</function>
  <function>public static uint sqlite3WalDbsize(Wal pWal)
{
    if (((pWal) != null) &amp;&amp; ((pWal.readLock) &gt;= (0)))
    {
        return (uint)(pWal.hdr.nPage);
    }

    return (uint)(0);
}</function>
  <function>public static int sqlite3WalDefaultHook(void* pClientData, sqlite3 db, sbyte* zDb, int nFrame)
{
    if ((nFrame) &gt;= ((int)((long)(pClientData))))
    {
        sqlite3BeginBenignMalloc();
        sqlite3_wal_checkpoint(db, zDb);
        sqlite3EndBenignMalloc();
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3WalEndReadTransaction(Wal pWal)
{
    sqlite3WalEndWriteTransaction(pWal);
    if ((pWal.readLock) &gt;= (0))
    {
        walUnlockShared(pWal, (int)(3 + (pWal.readLock)));
        pWal.readLock = (short)(-1);
    }
}</function>
  <function>public static int sqlite3WalEndWriteTransaction(Wal pWal)
{
    if ((pWal.writeLock) != 0)
    {
        walUnlockExclusive(pWal, (int)(0), (int)(1));
        pWal.writeLock = (byte)(0);
        pWal.iReCksum = (uint)(0);
        pWal.truncateOnCommit = (byte)(0);
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3WalExclusiveMode(Wal pWal, int op)
{
    int rc = 0;
    if ((op) == (0))
    {
        if (pWal.exclusiveMode != 0)
        {
            pWal.exclusiveMode = (byte)(0);
            if (walLockShared(pWal, (int)(3 + (pWal.readLock))) != 0)
            {
                pWal.exclusiveMode = (byte)(1);
            }

            rc = (int)((pWal.exclusiveMode) == (0) ? 1 : 0);
        }
        else
        {
            rc = (int)(0);
        }
    }
    else if ((op) &gt; (0))
    {
        walUnlockShared(pWal, (int)(3 + (pWal.readLock)));
        pWal.exclusiveMode = (byte)(1);
        rc = (int)(1);
    }
    else
    {
        rc = (int)((pWal.exclusiveMode) == (0) ? 1 : 0);
    }

    return (int)(rc);
}</function>
  <function>public static sqlite3_file sqlite3WalFile(Wal pWal)
{
    return pWal.pWalFd;
}</function>
  <function>public static int sqlite3WalFindFrame(Wal pWal, uint pgno, uint* piRead)
{
    uint iRead = (uint)(0);
    uint iLast = (uint)(pWal.hdr.mxFrame);
    int iHash = 0;
    int iMinHash = 0;
    if (((iLast) == (0)) || (((pWal.readLock) == (0)) &amp;&amp; ((pWal.bShmUnreliable) == (0))))
    {
        *piRead = (uint)(0);
        return (int)(0);
    }

    iMinHash = (int)(walFramePage((uint)(pWal.minFrame)));
    for (iHash = (int)(walFramePage((uint)(iLast))); (iHash) &gt;= (iMinHash); iHash--)
    {
        WalHashLoc sLoc = new WalHashLoc();
        int iKey = 0;
        int nCollide = 0;
        int rc = 0;
        uint iH = 0;
        rc = (int)(walHashGet(pWal, (int)(iHash), &amp;sLoc));
        if (rc != 0)
        {
            return (int)(rc);
        }

        nCollide = (int)(4096 * 2);
        iKey = (int)(walHash((uint)(pgno)));
        while ((iH = (uint)(0)) != 0)
        {
            uint iFrame = (uint)(iH + sLoc.iZero);
            if ((((iFrame) &lt;= (iLast)) &amp;&amp; ((iFrame) &gt;= (pWal.minFrame))) &amp;&amp; ((sLoc.aPgno[iH - 1]) == (pgno)))
            {
                iRead = (uint)(iFrame);
            }

            if ((nCollide--) == (0))
            {
                return (int)(sqlite3CorruptError((int)(64163)));
            }

            iKey = (int)(walNextHash((int)(iKey)));
        }

        if ((iRead) != 0)
            break;
    }

    *piRead = (uint)(iRead);
    return (int)(0);
}</function>
  <function>public static int sqlite3WalFrames(Wal pWal, int szPage, PgHdr pList, uint nTruncate, int isCommit, int sync_flags)
{
    int rc = 0;
    uint iFrame = 0;
    PgHdr p;
    PgHdr pLast = null;
    int nExtra = (int)(0);
    int szFrame = 0;
    long iOffset = 0;
    WalWriter w = new WalWriter();
    uint iFirst = (uint)(0);
    WalIndexHdr* pLive;
    pLive = (WalIndexHdr*)(walIndexHdr(pWal));
    if (memcmp(&amp;pWal.hdr, (void*)(pLive), (ulong)(sizeof(WalIndexHdr))) != 0)
    {
        iFirst = (uint)(pLive-&gt;mxFrame + 1);
    }

    if (0 != (rc = (int)(walRestartLog(pWal))))
    {
        return (int)(rc);
    }

    iFrame = (uint)(pWal.hdr.mxFrame);
    if ((iFrame) == (0))
    {
        byte* aWalHdr = stackalloc byte[32];
        uint* aCksum = stackalloc uint[2];
        sqlite3Put4byte(&amp;aWalHdr[0], (uint)(0x377f0682 | 0));
        sqlite3Put4byte(&amp;aWalHdr[4], (uint)(3007000));
        sqlite3Put4byte(&amp;aWalHdr[8], (uint)(szPage));
        sqlite3Put4byte(&amp;aWalHdr[12], (uint)(pWal.nCkpt));
        if ((pWal.nCkpt) == (0))
            sqlite3_randomness((int)(8), pWal.hdr.aSalt);
        CRuntime.memcpy(&amp;aWalHdr[16], pWal.hdr.aSalt, (ulong)(8));
        walChecksumBytes((int)(1), aWalHdr, (int)(32 - 2 * 4), null, aCksum);
        sqlite3Put4byte(&amp;aWalHdr[24], (uint)(aCksum[0]));
        sqlite3Put4byte(&amp;aWalHdr[28], (uint)(aCksum[1]));
        pWal.szPage = (uint)(szPage);
        pWal.hdr.bigEndCksum = (byte)(0);
        pWal.hdr.aFrameCksum[0] = (uint)(aCksum[0]);
        pWal.hdr.aFrameCksum[1] = (uint)(aCksum[1]);
        pWal.truncateOnCommit = (byte)(1);
        rc = (int)(sqlite3OsWrite(pWal.pWalFd, aWalHdr, (int)(32 * sizeof(byte)), (long)(0)));
        if (rc != 0)
        {
            return (int)(rc);
        }

        if ((pWal.syncHeader) != 0)
        {
            rc = (int)(sqlite3OsSync(pWal.pWalFd, (int)(((sync_flags) &gt;&gt; 2) &amp; 0x03)));
            if ((rc) != 0)
                return (int)(rc);
        }
    }

    w.pWal = pWal;
    w.pFd = pWal.pWalFd;
    w.iSyncPoint = (long)(0);
    w.syncFlags = (int)(sync_flags);
    w.szPage = (int)(szPage);
    iOffset = (long)(32 + ((iFrame + 1) - 1) * (long)((szPage) + 24));
    szFrame = (int)(szPage + 24);
    for (p = pList; p; p = p.pDirty)
    {
        int nDbSize = 0;
        if (((iFirst) != 0) &amp;&amp; (((p.pDirty) != null) || ((isCommit) == (0))))
        {
            uint iWrite = (uint)(0);
            sqlite3WalFindFrame(pWal, (uint)(p.pgno), &amp;iWrite);
            if ((iWrite) &gt;= (iFirst))
            {
                long iOff = (long)((32 + ((iWrite) - 1) * (long)((szPage) + 24)) + 24);
                void* pData;
                if (((pWal.iReCksum) == (0)) || ((iWrite) &lt; (pWal.iReCksum)))
                {
                    pWal.iReCksum = (uint)(iWrite);
                }

                pData = p.pData;
                rc = (int)(sqlite3OsWrite(pWal.pWalFd, pData, (int)(szPage), (long)(iOff)));
                if ((rc) != 0)
                    return (int)(rc);
                p.flags &amp;= (ushort)(~0x040);
                continue;
            }
        }

        iFrame++;
        nDbSize = (int)((((isCommit) != 0) &amp;&amp; ((p.pDirty) == (null))) ? nTruncate : 0);
        rc = (int)(walWriteOneFrame(w, p, (int)(nDbSize), (long)(iOffset)));
        if ((rc) != 0)
            return (int)(rc);
        pLast = p;
        iOffset += (long)(szFrame);
        p.flags |= (ushort)(0x040);
    }

    if (((isCommit) != 0) &amp;&amp; ((pWal.iReCksum) != 0))
    {
        rc = (int)(walRewriteChecksums(pWal, (uint)(iFrame)));
        if ((rc) != 0)
            return (int)(rc);
    }

    if (((isCommit) != 0) &amp;&amp; (((sync_flags) &amp; 0x03) != 0))
    {
        int bSync = (int)(1);
        if ((pWal.padToSectorBoundary) != 0)
        {
            int sectorSize = (int)(sqlite3SectorSize(pWal.pWalFd));
            w.iSyncPoint = (long)(((iOffset + sectorSize - 1) / sectorSize) * sectorSize);
            bSync = (int)((w.iSyncPoint) == (iOffset) ? 1 : 0);
            while ((iOffset) &lt; (w.iSyncPoint))
            {
                rc = (int)(walWriteOneFrame(w, pLast, (int)(nTruncate), (long)(iOffset)));
                if ((rc) != 0)
                    return (int)(rc);
                iOffset += (long)(szFrame);
                nExtra++;
            }
        }

        if ((bSync) != 0)
        {
            rc = (int)(sqlite3OsSync(w.pFd, (int)((sync_flags) &amp; 0x03)));
        }
    }

    if ((((isCommit) != 0) &amp;&amp; ((pWal.truncateOnCommit) != 0)) &amp;&amp; ((pWal.mxWalSize) &gt;= (0)))
    {
        long sz = (long)(pWal.mxWalSize);
        if ((32 + ((iFrame + nExtra + 1) - 1) * (long)((szPage) + 24)) &gt; (pWal.mxWalSize))
        {
            sz = (long)(32 + ((iFrame + nExtra + 1) - 1) * (long)((szPage) + 24));
        }

        walLimitSize(pWal, (long)(sz));
        pWal.truncateOnCommit = (byte)(0);
    }

    iFrame = (uint)(pWal.hdr.mxFrame);
    for (p = pList; ((p) != null) &amp;&amp; ((rc) == (0)); p = p.pDirty)
    {
        if ((p.flags &amp; 0x040) == (0))
            continue;
        iFrame++;
        rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(p.pgno)));
    }

    while (((rc) == (0)) &amp;&amp; ((nExtra) &gt; (0)))
    {
        iFrame++;
        nExtra--;
        rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(pLast.pgno)));
    }

    if ((rc) == (0))
    {
        pWal.hdr.szPage = ((ushort)((szPage &amp; 0xff00) | (szPage &gt;&gt; 16)));
        pWal.hdr.mxFrame = (uint)(iFrame);
        if ((isCommit) != 0)
        {
            pWal.hdr.iChange++;
            pWal.hdr.nPage = (uint)(nTruncate);
        }

        if ((isCommit) != 0)
        {
            walIndexWriteHdr(pWal);
            pWal.iCallback = (uint)(iFrame);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3WalHeapMemory(Wal pWal)
{
    return ((((pWal) != null) &amp;&amp; ((pWal.exclusiveMode) == (2))) ? 1 : 0);
}</function>
  <function>public static void sqlite3WalkerDepthDecrease(Walker pWalker, Select pSelect)
{
    pWalker.walkerDepth--;
}</function>
  <function>public static int sqlite3WalkerDepthIncrease(Walker pWalker, Select pSelect)
{
    pWalker.walkerDepth++;
    return (int)(0);
}</function>
  <function>public static int sqlite3WalkExpr(Walker pWalker, Expr pExpr)
{
    return (int)(pExpr ? walkExpr(pWalker, pExpr) : 0);
}</function>
  <function>public static int sqlite3WalkExprList(Walker pWalker, ExprList p)
{
    int i = 0;
    ExprList_item* pItem;
    if ((p) != null)
    {
        for (i = (int)(p.nExpr), pItem = p.a; (i) &gt; (0); i--, pItem++)
        {
            if ((sqlite3WalkExpr(pWalker, pItem-&gt;pExpr)) != 0)
                return (int)(2);
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3WalkSelect(Walker pWalker, Select p)
{
    int rc = 0;
    if ((p) == (null))
        return (int)(0);
    if ((pWalker.xSelectCallback) == (null))
        return (int)(0);
    do
    {
        rc = (int)(pWalker.xSelectCallback(pWalker, p));
        if ((rc) != 0)
            return (int)(rc &amp; 2);
        if (((sqlite3WalkSelectExpr(pWalker, p)) != 0) || ((sqlite3WalkSelectFrom(pWalker, p)) != 0))
        {
            return (int)(2);
        }

        if ((pWalker.xSelectCallback2) != null)
        {
            pWalker.xSelectCallback2(pWalker, p);
        }

        p = p.pPrior;
    }
    while (p != null);
    return (int)(0);
}</function>
  <function>public static int sqlite3WalkSelectExpr(Walker pWalker, Select p)
{
    if ((sqlite3WalkExprList(pWalker, p.pEList)) != 0)
        return (int)(2);
    if ((sqlite3WalkExpr(pWalker, p.pWhere)) != 0)
        return (int)(2);
    if ((sqlite3WalkExprList(pWalker, p.pGroupBy)) != 0)
        return (int)(2);
    if ((sqlite3WalkExpr(pWalker, p.pHaving)) != 0)
        return (int)(2);
    if ((sqlite3WalkExprList(pWalker, p.pOrderBy)) != 0)
        return (int)(2);
    if ((sqlite3WalkExpr(pWalker, p.pLimit)) != 0)
        return (int)(2);
    if ((p.pWinDefn) != null)
    {
        Parse pParse;
        if ((((pWalker.xSelectCallback2) == (sqlite3WalkWinDefnDummyCallback)) || (((pParse = pWalker.pParse) != null) &amp;&amp; ((pParse.eParseMode) &gt;= (2)))) || ((pWalker.xSelectCallback2) == (sqlite3SelectPopWith)))
        {
            int rc = (int)(walkWindowList(pWalker, p.pWinDefn, (int)(0)));
            return (int)(rc);
        }
    }

    return (int)(0);
}</function>
  <function>public static int sqlite3WalkSelectFrom(Walker pWalker, Select p)
{
    SrcList pSrc;
    int i = 0;
    SrcItem pItem;
    pSrc = p.pSrc;
    if ((pSrc) != null)
    {
        for (i = (int)(pSrc.nSrc), pItem = pSrc.a; (i) &gt; (0); i--, pItem++)
        {
            if (((pItem.pSelect) != null) &amp;&amp; ((sqlite3WalkSelect(pWalker, pItem.pSelect)) != 0))
            {
                return (int)(2);
            }

            if (((pItem.fg.isTabFunc) != 0) &amp;&amp; ((sqlite3WalkExprList(pWalker, pItem.u1.pFuncArg)) != 0))
            {
                return (int)(2);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3WalkWinDefnDummyCallback(Walker pWalker, Select p)
{
}</function>
  <function>public static void sqlite3WalLimit(Wal pWal, long iLimit)
{
    if ((pWal) != null)
        pWal.mxWalSize = (long)(iLimit);
}</function>
  <function>public static int sqlite3WalOpen(sqlite3_vfs pVfs, sqlite3_file pDbFd, sbyte* zWalName, int bNoShm, long mxWalSize, Wal ppWal)
{
    int rc = 0;
    Wal pRet;
    int flags = 0;
    ppWal = null;
    pRet = (Wal)(sqlite3MallocZero((ulong)(sizeof(Wal) + pVfs.szOsFile)));
    if (pRet == null)
    {
        return (int)(7);
    }

    pRet.pVfs = pVfs;
    pRet.pWalFd = (sqlite3_file)(pRet[1]);
    pRet.pDbFd = pDbFd;
    pRet.readLock = (short)(-1);
    pRet.mxWalSize = (long)(mxWalSize);
    pRet.zWalName = zWalName;
    pRet.syncHeader = (byte)(1);
    pRet.padToSectorBoundary = (byte)(1);
    pRet.exclusiveMode = (byte)((bNoShm) != 0 ? 2 : 0);
    flags = (int)(0x00000002 | 0x00000004 | 0x00080000);
    rc = (int)(sqlite3OsOpen(pVfs, zWalName, pRet.pWalFd, (int)(flags), &amp;flags));
    if (((rc) == (0)) &amp;&amp; ((flags &amp; 0x00000001) != 0))
    {
        pRet.readOnly = (byte)(1);
    }

    if (rc != 0)
    {
        walIndexClose(pRet, (int)(0));
        sqlite3OsClose(pRet.pWalFd);
        sqlite3_free(pRet);
    }
    else
    {
        int iDC = (int)(sqlite3OsDeviceCharacteristics(pDbFd));
        if ((iDC &amp; 0x00000400) != 0)
        {
            pRet.syncHeader = (byte)(0);
        }

        if ((iDC &amp; 0x00001000) != 0)
        {
            pRet.padToSectorBoundary = (byte)(0);
        }

        ppWal = pRet;
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3WalReadFrame(Wal pWal, uint iRead, int nOut, byte* pOut)
{
    int sz = 0;
    long iOffset = 0;
    sz = (int)(pWal.hdr.szPage);
    sz = (int)((sz &amp; 0xfe00) + ((sz &amp; 0x0001) &lt;&lt; 16));
    iOffset = (long)((32 + ((iRead) - 1) * (long)((sz) + 24)) + 24);
    return (int)(sqlite3OsRead(pWal.pWalFd, pOut, (int)((nOut) &gt; (sz) ? sz : nOut), (long)(iOffset)));
}</function>
  <function>public static void sqlite3WalSavepoint(Wal pWal, uint* aWalData)
{
    aWalData[0] = (uint)(pWal.hdr.mxFrame);
    aWalData[1] = (uint)(pWal.hdr.aFrameCksum[0]);
    aWalData[2] = (uint)(pWal.hdr.aFrameCksum[1]);
    aWalData[3] = (uint)(pWal.nCkpt);
}</function>
  <function>public static int sqlite3WalSavepointUndo(Wal pWal, uint* aWalData)
{
    int rc = (int)(0);
    if (aWalData[3] != pWal.nCkpt)
    {
        aWalData[0] = (uint)(0);
        aWalData[3] = (uint)(pWal.nCkpt);
    }

    if ((aWalData[0]) &lt; (pWal.hdr.mxFrame))
    {
        pWal.hdr.mxFrame = (uint)(aWalData[0]);
        pWal.hdr.aFrameCksum[0] = (uint)(aWalData[1]);
        pWal.hdr.aFrameCksum[1] = (uint)(aWalData[2]);
        walCleanupHash(pWal);
    }

    return (int)(rc);
}</function>
  <function>public static int sqlite3WalUndo(Wal pWal, delegate59 xUndo, void* pUndoCtx)
{
    int rc = (int)(0);
    if ((pWal.writeLock) != 0)
    {
        uint iMax = (uint)(pWal.hdr.mxFrame);
        uint iFrame = 0;
        CRuntime.memcpy(&amp;pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr)));
        for (iFrame = (uint)(pWal.hdr.mxFrame + 1); ((rc) == (0)) &amp;&amp; ((iFrame) &lt;= (iMax)); iFrame++)
        {
            rc = (int)(xUndo(pUndoCtx, (uint)(walFramePgno(pWal, (uint)(iFrame)))));
        }

        if (iMax != pWal.hdr.mxFrame)
            walCleanupHash(pWal);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3WhereAddLimit(WhereClause pWC, Select p)
{
    if (((((p) != null) &amp;&amp; ((p.pLimit) != null)) &amp;&amp; ((p.selFlags &amp; (0x0000001 | 0x0000008)) == (0))) &amp;&amp; (((p.pSrc.nSrc) == (1)) &amp;&amp; (((p.pSrc.a[0].pTab).eTabType) == (1))))
    {
        ExprList pOrderBy = p.pOrderBy;
        int iCsr = (int)(p.pSrc.a[0].iCursor);
        int ii = 0;
        for (ii = (int)(0); (ii) &lt; (pWC.nTerm); ii++)
        {
            if ((pWC.a[ii].wtFlags &amp; 0x0004) != 0)
            {
                continue;
            }

            if (pWC.a[ii].leftCursor != iCsr)
                return;
        }

        if ((pOrderBy) != null)
        {
            for (ii = (int)(0); (ii) &lt; (pOrderBy.nExpr); ii++)
            {
                Expr pExpr = pOrderBy.a[ii].pExpr;
                if (pExpr.op != 167)
                    return;
                if (pExpr.iTable != iCsr)
                    return;
                if ((pOrderBy.a[ii].sortFlags &amp; 0x02) != 0)
                    return;
            }
        }

        whereAddLimitExpr(pWC, (int)(p.iLimit), p.pLimit.pLeft, (int)(iCsr), (int)(73));
        if ((p.iOffset) &gt; (0))
        {
            whereAddLimitExpr(pWC, (int)(p.iOffset), p.pLimit.pRight, (int)(iCsr), (int)(74));
        }
    }
}</function>
  <function>public static WhereInfo sqlite3WhereBegin(Parse pParse, SrcList pTabList, Expr pWhere, ExprList pOrderBy, ExprList pResultSet, Select pLimit, ushort wctrlFlags, int iAuxArg)
{
    int nByteWInfo = 0;
    int nTabList = 0;
    WhereInfo pWInfo;
    Vdbe v = pParse.pVdbe;
    ulong notReady = 0;
    WhereLoopBuilder sWLB = new WhereLoopBuilder();
    WhereMaskSet* pMaskSet;
    WhereLevel pLevel;
    WhereLoop pLoop;
    int ii = 0;
    sqlite3 db;
    int rc = 0;
    byte bFordelete = (byte)(0);
    db = pParse.db;
    CRuntime.memset(sWLB, (int)(0), (ulong)(sizeof(WhereLoopBuilder)));
    if (((pOrderBy) != null) &amp;&amp; ((pOrderBy.nExpr) &gt;= ((int)(sizeof(ulong) * 8))))
        pOrderBy = null;
    if ((pTabList.nSrc) &gt; ((int)(sizeof(ulong) * 8)))
    {
        sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int)(sizeof(ulong) * 8)));
        return null;
    }

    nTabList = (int)((wctrlFlags &amp; 0x0020) ? 1 : pTabList.nSrc);
    nByteWInfo = (int)(((sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel)) + 7) &amp; ~7);
    pWInfo = sqlite3DbMallocRawNN(db, (ulong)(nByteWInfo + sizeof(WhereLoop)));
    if ((db.mallocFailed) != 0)
    {
        sqlite3DbFree(db, pWInfo);
        pWInfo = null;
        goto whereBeginError;
    }

    pWInfo.pParse = pParse;
    pWInfo.pTabList = pTabList;
    pWInfo.pOrderBy = pOrderBy;
    pWInfo.pWhere = pWhere;
    pWInfo.pResultSet = pResultSet;
    pWInfo.aiCurOnePass[0] = (int)(pWInfo.aiCurOnePass[1] = (int)(-1));
    pWInfo.nLevel = (byte)(nTabList);
    pWInfo.iBreak = (int)(pWInfo.iContinue = (int)(sqlite3VdbeMakeLabel(pParse)));
    pWInfo.wctrlFlags = (ushort)(wctrlFlags);
    pWInfo.iLimit = (short)(iAuxArg);
    pWInfo.savedNQueryLoop = (int)(pParse.nQueryLoop);
    pWInfo.pLimit = pLimit;
    CRuntime.memset(&amp;pWInfo.nOBSat, (int)(0), (ulong)(((ulong)((0).sWC)) - ((ulong)(&amp;((0).nOBSat)))));
    CRuntime.memset(pWInfo.a[0], (int)(0), (ulong)(sizeof(WhereLoop) + nTabList * sizeof(WhereLevel)));
    pMaskSet = &amp;pWInfo.sMaskSet;
    pMaskSet-&gt;n = (int)(0);
    pMaskSet-&gt;ix[0] = (int)(-99);
    sWLB.pWInfo = pWInfo;
    sWLB.pWC = pWInfo.sWC;
    sWLB.pNew = (WhereLoop)(((sbyte*)(pWInfo)) + nByteWInfo);
    whereLoopInit(sWLB.pNew);
    sqlite3WhereClauseInit(pWInfo.sWC, pWInfo);
    sqlite3WhereSplit(pWInfo.sWC, pWhere, (byte)(44));
    if ((nTabList) == (0))
    {
        if ((pOrderBy) != null)
            pWInfo.nOBSat = (sbyte)(pOrderBy.nExpr);
        if (((wctrlFlags &amp; 0x0100) != 0) &amp;&amp; (((db).dbOptFlags &amp; (0x00000010)) == (0)))
        {
            pWInfo.eDistinct = (byte)(1);
        }

        sqlite3VdbeExplain(pParse, (byte)(0), "SCAN CONSTANT ROW");
    }
    else
    {
        ii = (int)(0);
        do
        {
            createMask(pMaskSet, (int)(pTabList.a[ii].iCursor));
            sqlite3WhereTabFuncArgs(pParse, pTabList.a[ii], pWInfo.sWC);
        }
        while ((++ii) &lt; (pTabList.nSrc));
    }

    sqlite3WhereExprAnalyze(pTabList, pWInfo.sWC);
    sqlite3WhereAddLimit(pWInfo.sWC, pLimit);
    if ((db.mallocFailed) != 0)
        goto whereBeginError;
    for (ii = (int)(0); (ii) &lt; (sWLB.pWC.nBase); ii++)
    {
        WhereTerm pT = sWLB.pWC.a[ii];
        if ((pT.wtFlags &amp; 0x0002) != 0)
            continue;
        if (((pT.prereqAll) == (0)) &amp;&amp; (((nTabList) == (0)) || ((exprIsDeterministic(pT.pExpr)) != 0)))
        {
            sqlite3ExprIfFalse(pParse, pT.pExpr, (int)(pWInfo.iBreak), (int)(0x10));
            pT.wtFlags |= (ushort)(0x0004);
        }
    }

    if ((wctrlFlags &amp; 0x0100) != 0)
    {
        if ((((db).dbOptFlags &amp; (0x00000010)) != 0))
        {
            wctrlFlags &amp;= (ushort)(~0x0100);
            pWInfo.wctrlFlags &amp;= (ushort)(~0x0100);
        }
        else if ((isDistinctRedundant(pParse, pTabList, pWInfo.sWC, pResultSet)) != 0)
        {
            pWInfo.eDistinct = (byte)(1);
        }
        else if ((pOrderBy) == (null))
        {
            pWInfo.wctrlFlags |= (ushort)(0x0080);
            pWInfo.pOrderBy = pResultSet;
        }
    }

    if ((nTabList != 1) || ((whereShortCut(sWLB)) == (0)))
    {
        rc = (int)(whereLoopAddAll(sWLB));
        if ((rc) != 0)
            goto whereBeginError;
        wherePathSolver(pWInfo, (short)(0));
        if ((db.mallocFailed) != 0)
            goto whereBeginError;
        if ((pWInfo.pOrderBy) != null)
        {
            wherePathSolver(pWInfo, (short)(pWInfo.nRowOut + 1));
            if ((db.mallocFailed) != 0)
                goto whereBeginError;
        }
    }

    if (((pWInfo.pOrderBy) == (null)) &amp;&amp; ((db.flags &amp; 0x00001000) != 0))
    {
        pWInfo.revMask = ((ulong)(-1));
    }

    if ((pParse.nErr) != 0)
    {
        goto whereBeginError;
    }

    notReady = (ulong)(~(ulong)(0));
    if (((((pWInfo.nLevel) &gt;= (2)) &amp;&amp; (pResultSet != null)) &amp;&amp; ((0) == (wctrlFlags &amp; 0x0400))) &amp;&amp; (((db).dbOptFlags &amp; (0x00000100)) == (0)))
    {
        notReady = (ulong)(whereOmitNoopJoin(pWInfo, (ulong)(notReady)));
        nTabList = (int)(pWInfo.nLevel);
    }

    if (((pWInfo.nLevel) &gt;= (2)) &amp;&amp; (((db).dbOptFlags &amp; (0x00080000)) == (0)))
    {
        whereCheckIfBloomFilterIsUseful(pWInfo);
    }

    pWInfo.pParse.nQueryLoop += (uint)(pWInfo.nRowOut);
    if ((wctrlFlags &amp; 0x0004) != 0)
    {
        int wsFlags = (int)(pWInfo.a[0].pWLoop.wsFlags);
        int bOnerow = (int)((wsFlags &amp; 0x00001000) != 0);
        if (((bOnerow) != 0) || (((0 != (wctrlFlags &amp; 0x0008)) &amp;&amp; (!(((pTabList.a[0].pTab).eTabType) == (1)))) &amp;&amp; (((0) == (wsFlags &amp; 0x00002000)) || ((wctrlFlags &amp; 0x0010) != 0))))
        {
            pWInfo.eOnePass = (byte)((bOnerow) != 0 ? 1 : 2);
            if ((((pTabList.a[0].pTab).tabFlags &amp; 0x00000080) == (0)) &amp;&amp; ((wsFlags &amp; 0x00000040) != 0))
            {
                if ((wctrlFlags &amp; 0x0008) != 0)
                {
                    bFordelete = (byte)(0x08);
                }

                pWInfo.a[0].pWLoop.wsFlags = (uint)(wsFlags &amp; ~0x00000040);
            }
        }
    }

    for (ii = (int)(0), pLevel = pWInfo.a; (ii) &lt; (nTabList); ii++, pLevel++)
    {
        Table pTab;
        int iDb = 0;
        SrcItem pTabItem;
        pTabItem = pTabList.a[pLevel.iFrom];
        pTab = pTabItem.pTab;
        iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
        pLoop = pLevel.pWLoop;
        if (((pTab.tabFlags &amp; 0x00004000) != 0) || (((pTab).eTabType) == (2)))
        {
        }
        else if ((pLoop.wsFlags &amp; 0x00000400) != 0)
        {
            sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
            int iCur = (int)(pTabItem.iCursor);
            sqlite3VdbeAddOp4(v, (int)(172), (int)(iCur), (int)(0), (int)(0), pVTab, (int)(-12));
        }
        else if ((((pTab).eTabType) == (1)))
        {
        }
        else if (((pLoop.wsFlags &amp; 0x00000040) == (0)) &amp;&amp; ((wctrlFlags &amp; 0x0020) == (0)))
        {
            int op = (int)(101);
            if (pWInfo.eOnePass != 0)
            {
                op = (int)(112);
                pWInfo.aiCurOnePass[0] = (int)(pTabItem.iCursor);
            }

            sqlite3OpenTable(pParse, (int)(pTabItem.iCursor), (int)(iDb), pTab, (int)(op));
            if (((((pWInfo.eOnePass) == (0)) &amp;&amp; ((pTab.nCol) &lt; ((int)(sizeof(ulong) * 8)))) &amp;&amp; ((pTab.tabFlags &amp; (0x00000060 | 0x00000080)) == (0))) &amp;&amp; ((pLoop.wsFlags &amp; (0x00004000 | 0x00400000)) == (0)))
            {
                ulong b = (ulong)(pTabItem.colUsed);
                int n = (int)(0);
                for (b;; b = (ulong)(b &gt;&gt; 1), n++)
                {
                }

                sqlite3VdbeChangeP4(v, (int)(-1), ((void*)((long)(n))), (int)(-3));
            }

            {
                sqlite3VdbeChangeP5(v, (ushort)(bFordelete));
            }
        }
        else
        {
            sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
        }

        if ((pLoop.wsFlags &amp; 0x00000200) != 0)
        {
            Index pIx = pLoop.u.btree.pIndex;
            int iIndexCur = 0;
            int op = (int)(101);
            if (((!(((pTab).tabFlags &amp; 0x00000080) == (0))) &amp;&amp; (((pIx).idxType) == (2))) &amp;&amp; ((wctrlFlags &amp; 0x0020) != 0))
            {
                iIndexCur = (int)(pLevel.iTabCur);
                op = (int)(0);
            }
            else if (pWInfo.eOnePass != 0)
            {
                Index pJ = pTabItem.pTab.pIndex;
                iIndexCur = (int)(iAuxArg);
                while (((pJ) != null) &amp;&amp; (pJ != pIx))
                {
                    iIndexCur++;
                    pJ = pJ.pNext;
                }

                op = (int)(112);
                pWInfo.aiCurOnePass[1] = (int)(iIndexCur);
            }
            else if (((iAuxArg) != 0) &amp;&amp; ((wctrlFlags &amp; 0x0020) != 0))
            {
                iIndexCur = (int)(iAuxArg);
                op = (int)(100);
            }
            else
            {
                iIndexCur = (int)(pParse.nTab++);
            }

            pLevel.iIdxCur = (int)(iIndexCur);
            if ((op) != 0)
            {
                sqlite3VdbeAddOp3(v, (int)(op), (int)(iIndexCur), (int)(pIx.tnum), (int)(iDb));
                sqlite3VdbeSetP4KeyInfo(pParse, pIx);
                if (((((((pLoop.wsFlags &amp; 0x0000000f) != 0) &amp;&amp; ((pLoop.wsFlags &amp; (0x00000002 | 0x00008000)) == (0))) &amp;&amp; ((pLoop.wsFlags &amp; 0x00080000) == (0))) &amp;&amp; ((pLoop.wsFlags &amp; 0x00100000) == (0))) &amp;&amp; ((pWInfo.wctrlFlags &amp; 0x0001) == (0))) &amp;&amp; (pWInfo.eDistinct != 2))
                {
                    sqlite3VdbeChangeP5(v, (ushort)(0x02));
                }
            }
        }

        if ((iDb) &gt;= (0))
            sqlite3CodeVerifySchema(pParse, (int)(iDb));
    }

    pWInfo.iTop = (int)(sqlite3VdbeCurrentAddr(v));
    if ((db.mallocFailed) != 0)
        goto whereBeginError;
    for (ii = (int)(0); (ii) &lt; (nTabList); ii++)
    {
        int addrExplain = 0;
        int wsFlags = 0;
        if ((pParse.nErr) != 0)
            goto whereBeginError;
        pLevel = pWInfo.a[ii];
        wsFlags = (int)(pLevel.pWLoop.wsFlags);
        if ((wsFlags &amp; (0x00004000 | 0x00400000)) != 0)
        {
            if ((wsFlags &amp; 0x00004000) != 0)
            {
                constructAutomaticIndex(pParse, pWInfo.sWC, pTabList.a[pLevel.iFrom], (ulong)(notReady), pLevel);
            }
            else
            {
                sqlite3ConstructBloomFilter(pWInfo, (int)(ii), pLevel, (ulong)(notReady));
            }

            if ((db.mallocFailed) != 0)
                goto whereBeginError;
        }

        addrExplain = (int)(sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, (ushort)(wctrlFlags)));
        pLevel.addrBody = (int)(sqlite3VdbeCurrentAddr(v));
        notReady = (ulong)(sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, (int)(ii), pLevel, (ulong)(notReady)));
        pWInfo.iContinue = (int)(pLevel.addrCont);
        if (((wsFlags &amp; 0x00002000) == (0)) &amp;&amp; ((wctrlFlags &amp; 0x0020) == (0)))
        {
            ((void)(addrExplain));
        }
    }

    pWInfo.iEndWhere = (int)(sqlite3VdbeCurrentAddr(v));
    return pWInfo;
    whereBeginError:
        ; if  ( ( pWInfo ) != null ) { whereUndoExprMods ( pWInfo ) ;  pParse . nQueryLoop  =  ( uint ) ( pWInfo . savedNQueryLoop ) ;  whereInfoFree ( db ,  pWInfo ) ;  }
    return null;
}</function>
  <function>public static int sqlite3WhereBreakLabel(WhereInfo pWInfo)
{
    return (int)(pWInfo.iBreak);
}</function>
  <function>public static void sqlite3WhereClauseClear(WhereClause pWC)
{
    sqlite3 db = pWC.pWInfo.pParse.db;
    if ((pWC.nTerm) &gt; (0))
    {
        WhereTerm a = pWC.a;
        WhereTerm aLast = pWC.a[pWC.nTerm - 1];
        while ((1) != 0)
        {
            if ((a.wtFlags &amp; 0x0001) != 0)
            {
                sqlite3ExprDelete(db, a.pExpr);
            }

            if ((a.wtFlags &amp; (0x0010 | 0x0020)) != 0)
            {
                if ((a.wtFlags &amp; 0x0010) != 0)
                {
                    whereOrInfoDelete(db, a.u.pOrInfo);
                }
                else
                {
                    whereAndInfoDelete(db, a.u.pAndInfo);
                }
            }

            if ((a) == (aLast))
                break;
            a++;
        }
    }

    if (pWC.a != pWC.aStatic)
    {
        sqlite3DbFree(db, pWC.a);
    }
}</function>
  <function>public static void sqlite3WhereClauseInit(WhereClause pWC, WhereInfo pWInfo)
{
    pWC.pWInfo = pWInfo;
    pWC.hasOr = (byte)(0);
    pWC.pOuter = null;
    pWC.nTerm = (int)(0);
    pWC.nBase = (int)(0);
    pWC.nSlot = ((int)(8 * sizeof(WhereTerm) / sizeof(WhereTerm)));
    pWC.a = pWC.aStatic;
}</function>
  <function>public static ulong sqlite3WhereCodeOneLoopStart(Parse pParse, Vdbe v, WhereInfo pWInfo, int iLevel, WhereLevel pLevel, ulong notReady)
{
    int j = 0; int  k  =  0 ; 
    int iCur = 0;
    int addrNxt = 0;
    int bRev = 0;
    WhereLoop pLoop;
    WhereClause pWC;
    WhereTerm pTerm;
    sqlite3 db;
    SrcItem pTabItem;
    int addrBrk = 0;
    int addrHalt = 0;
    int addrCont = 0;
    int iRowidReg = (int)(0);
    int iReleaseReg = (int)(0);
    Index pIdx = null;
    int iLoop = 0;
    pWC = pWInfo.sWC;
    db = pParse.db;
    pLoop = pLevel.pWLoop;
    pTabItem = pWInfo.pTabList.a[pLevel.iFrom];
    iCur = (int)(pTabItem.iCursor);
    pLevel.notReady = (ulong)(notReady &amp; ~sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(iCur)));
    bRev = (int)((pWInfo.revMask &gt;&gt; iLevel) &amp; 1);
    addrBrk = (int)(pLevel.addrBrk = (int)(pLevel.addrNxt = (int)(sqlite3VdbeMakeLabel(pParse))));
    addrCont = (int)(pLevel.addrCont = (int)(sqlite3VdbeMakeLabel(pParse)));
    if (((pLevel.iFrom) &gt; (0)) &amp;&amp; ((pTabItem[0].fg.jointype &amp; 0x0008) != 0))
    {
        pLevel.iLeftJoin = (int)(++pParse.nMem);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pLevel.iLeftJoin));
    }

    for (j = (int)(iLevel); ((j) &gt; (0)) &amp;&amp; ((pWInfo.a[j].iLeftJoin) == (0)); j--)
    {
    }

    addrHalt = (int)(pWInfo.a[j].addrBrk);
    if ((pTabItem.fg.viaCoroutine) != 0)
    {
        int regYield = (int)(pTabItem.regReturn);
        sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(pTabItem.addrFillSub));
        pLevel.p2 = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regYield), (int)(addrBrk)));
        pLevel.op = (byte)(11);
    }
    else if ((pLoop.wsFlags &amp; 0x00000400) != 0)
    {
        int iReg = 0;
        int addrNotFound = 0;
        int nConstraint = (int)(pLoop.nLTerm);
        iReg = (int)(sqlite3GetTempRange(pParse, (int)(nConstraint + 2)));
        addrNotFound = (int)(pLevel.addrBrk);
        for (j = (int)(0); (j) &lt; (nConstraint); j++)
        {
            int iTarget = (int)(iReg + j + 2);
            pTerm = pLoop.aLTerm[j];
            if (((pTerm) == (null)))
                continue;
            if ((pTerm.eOperator &amp; 0x0001) != 0)
            {
                if ((((j) &lt;= (31) ? ((uint)(1)) &lt;&lt; (j) : 0) &amp; pLoop.u.vtab.mHandleIn) != 0)
                {
                    int iTab = (int)(pParse.nTab++);
                    int iCache = (int)(++pParse.nMem);
                    sqlite3CodeRhsOfIN(pParse, pTerm.pExpr, (int)(iTab));
                    sqlite3VdbeAddOp3(v, (int)(173), (int)(iTab), (int)(iTarget), (int)(iCache));
                }
                else
                {
                    codeEqualityTerm(pParse, pTerm, pLevel, (int)(j), (int)(bRev), (int)(iTarget));
                    addrNotFound = (int)(pLevel.addrNxt);
                }
            }
            else
            {
                Expr pRight = pTerm.pExpr.pRight;
                codeExprOrVector(pParse, pRight, (int)(iTarget), (int)(1));
                if (((pTerm.eMatchOp) == (74)) &amp;&amp; ((pLoop.u.vtab.bOmitOffset) != 0))
                {
                    sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWInfo.pLimit.iOffset));
                }
            }
        }

        sqlite3VdbeAddOp2(v, (int)(71), (int)(pLoop.u.vtab.idxNum), (int)(iReg));
        sqlite3VdbeAddOp2(v, (int)(71), (int)(nConstraint), (int)(iReg + 1));
        sqlite3VdbeAddOp4(v, (int)(9), (int)(iCur), (int)(addrNotFound), (int)(iReg), pLoop.u.vtab.idxStr, (int)((pLoop.u.vtab.needFree) != 0 ? (-7) : (-1)));
        pLoop.u.vtab.needFree = (uint)(0);
        if ((db.mallocFailed) != 0)
            pLoop.u.vtab.idxStr = null;
        pLevel.p1 = (int)(iCur);
        pLevel.op = (byte)((pWInfo.eOnePass) != 0 ? 182 : 62);
        pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
        for (j = (int)(0); (j) &lt; (nConstraint); j++)
        {
            pTerm = pLoop.aLTerm[j];
            if (((j) &lt; (16)) &amp;&amp; (((pLoop.u.vtab.omitMask &gt;&gt; j) &amp; 1) != 0))
            {
                disableTerm(pLevel, pTerm);
                continue;
            }

            if ((((pTerm.eOperator &amp; 0x0001) != 0) &amp;&amp; ((((j) &lt;= (31) ? ((uint)(1)) &lt;&lt; (j) : 0) &amp; pLoop.u.vtab.mHandleIn) == (0))) &amp;&amp; (db.mallocFailed == 0))
            {
                Expr pCompare;
                Expr pRight;
                VdbeOp* pOp;
                int iIn = 0;
                for (iIn = (int)(0); ((iIn) &lt; (pLevel.u._in_.nIn)); iIn++)
                {
                    pOp = sqlite3VdbeGetOp(v, (int)(pLevel.u._in_.aInLoop[iIn].addrInTop));
                    if ((((pOp-&gt;opcode) == (93)) &amp;&amp; ((pOp-&gt;p3) == (iReg + j + 2))) || (((pOp-&gt;opcode) == (134)) &amp;&amp; ((pOp-&gt;p2) == (iReg + j + 2))))
                    {
                        sqlite3VdbeAddOp3(v, (int)(pOp-&gt;opcode), (int)(pOp-&gt;p1), (int)(pOp-&gt;p2), (int)(pOp-&gt;p3));
                        break;
                    }
                }

                pCompare = sqlite3PExpr(pParse, (int)(53), null, null);
                if (db.mallocFailed == 0)
                {
                    int iFld = (int)(pTerm.u.x.iField);
                    Expr pLeft = pTerm.pExpr.pLeft;
                    if ((iFld) &gt; (0))
                    {
                        pCompare.pLeft = pLeft.x.pList.a[iFld - 1].pExpr;
                    }
                    else
                    {
                        pCompare.pLeft = pLeft;
                    }

                    pCompare.pRight = pRight = sqlite3Expr(db, (int)(176), null);
                    if ((pRight) != null)
                    {
                        pRight.iTable = (int)(iReg + j + 2);
                        sqlite3ExprIfFalse(pParse, pCompare, (int)(pLevel.addrCont), (int)(0x10));
                    }

                    pCompare.pLeft = null;
                }

                sqlite3ExprDelete(db, pCompare);
            }
        }
    }
    else if (((pLoop.wsFlags &amp; 0x00000100) != 0) &amp;&amp; ((pLoop.wsFlags &amp; (0x00000004 | 0x00000001)) != 0))
    {
        pTerm = pLoop.aLTerm[0];
        iReleaseReg = (int)(++pParse.nMem);
        iRowidReg = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(0), (int)(bRev), (int)(iReleaseReg)));
        if (iRowidReg != iReleaseReg)
            sqlite3ReleaseTempReg(pParse, (int)(iReleaseReg));
        addrNxt = (int)(pLevel.addrNxt);
        if ((pLevel.regFilter) != 0)
        {
            sqlite3VdbeAddOp4Int(v, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(iRowidReg), (int)(1));
            filterPullDown(pParse, pWInfo, (int)(iLevel), (int)(addrNxt), (ulong)(notReady));
        }

        sqlite3VdbeAddOp3(v, (int)(32), (int)(iCur), (int)(addrNxt), (int)(iRowidReg));
        pLevel.op = (byte)(182);
    }
    else if (((pLoop.wsFlags &amp; 0x00000100) != 0) &amp;&amp; ((pLoop.wsFlags &amp; 0x00000002) != 0))
    {
        int testOp = (int)(182);
        int start = 0;
        int memEndValue = (int)(0);
        WhereTerm pStart;
        WhereTerm pEnd;
        j = (int)(0);
        pStart = pEnd = null;
        if ((pLoop.wsFlags &amp; 0x00000020) != 0)
            pStart = pLoop.aLTerm[j++];
        if ((pLoop.wsFlags &amp; 0x00000010) != 0)
            pEnd = pLoop.aLTerm[j++];
        if ((bRev) != 0)
        {
            pTerm = pStart;
            pStart = pEnd;
            pEnd = pTerm;
        }

        if ((pStart) != null)
        {
            Expr pX;
            int r1 = 0;
            int rTemp = 0;
            int op = 0;
            byte* aMoveOp = stackalloc byte[]{26, 24, 23, 25};
            pX = pStart.pExpr;
            if ((sqlite3ExprIsVector(pX.pRight)) != 0)
            {
                r1 = (int)(rTemp = (int)(sqlite3GetTempReg(pParse)));
                codeExprOrVector(pParse, pX.pRight, (int)(r1), (int)(1));
                op = (int)(aMoveOp[((pX.op - 54 - 1) &amp; 0x3) | 0x1]);
            }
            else
            {
                r1 = (int)(sqlite3ExprCodeTemp(pParse, pX.pRight, &amp;rTemp));
                disableTerm(pLevel, pStart);
                op = (int)(aMoveOp[(pX.op - 54)]);
            }

            sqlite3VdbeAddOp3(v, (int)(op), (int)(iCur), (int)(addrBrk), (int)(r1));
            sqlite3ReleaseTempReg(pParse, (int)(rTemp));
        }
        else
        {
            sqlite3VdbeAddOp2(v, (int)((bRev) != 0 ? 34 : 38), (int)(iCur), (int)(addrHalt));
        }

        if ((pEnd) != null)
        {
            Expr pX;
            pX = pEnd.pExpr;
            memEndValue = (int)(++pParse.nMem);
            codeExprOrVector(pParse, pX.pRight, (int)(memEndValue), (int)(1));
            if (((0) == (sqlite3ExprIsVector(pX.pRight))) &amp;&amp; (((pX.op) == (56)) || ((pX.op) == (54))))
            {
                testOp = (int)((bRev) != 0 ? 55 : 57);
            }
            else
            {
                testOp = (int)((bRev) != 0 ? 56 : 54);
            }

            if ((0) == (sqlite3ExprIsVector(pX.pRight)))
            {
                disableTerm(pLevel, pEnd);
            }
        }

        start = (int)(sqlite3VdbeCurrentAddr(v));
        pLevel.op = (byte)((bRev) != 0 ? 4 : 5);
        pLevel.p1 = (int)(iCur);
        pLevel.p2 = (int)(start);
        if (testOp != 182)
        {
            iRowidReg = (int)(++pParse.nMem);
            sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(iRowidReg));
            sqlite3VdbeAddOp3(v, (int)(testOp), (int)(memEndValue), (int)(addrBrk), (int)(iRowidReg));
            sqlite3VdbeChangeP5(v, (ushort)(0x43 | 0x10));
        }
    }
    else if ((pLoop.wsFlags &amp; 0x00000200) != 0)
    {
        ushort nEq = (ushort)(pLoop.u.btree.nEq);
        ushort nBtm = (ushort)(pLoop.u.btree.nBtm);
        ushort nTop = (ushort)(pLoop.u.btree.nTop);
        int regBase = 0;
        WhereTerm pRangeStart = null;
        WhereTerm pRangeEnd = null;
        int startEq = 0;
        int endEq = 0;
        int start_constraints = 0;
        int nConstraint = 0;
        int iIdxCur = 0;
        int nExtraReg = (int)(0);
        int op = 0;
        sbyte* zStartAff;
        sbyte* zEndAff = null;
        byte bSeekPastNull = (byte)(0);
        byte bStopAtNull = (byte)(0);
        int omitTable = 0;
        int regBignull = (int)(0);
        int addrSeekScan = (int)(0);
        pIdx = pLoop.u.btree.pIndex;
        iIdxCur = (int)(pLevel.iIdxCur);
        j = (int)(nEq);
        if ((pLoop.wsFlags &amp; 0x00000020) != 0)
        {
            pRangeStart = pLoop.aLTerm[j++];
            nExtraReg = (int)((nExtraReg) &gt; (pLoop.u.btree.nBtm) ? (nExtraReg) : (pLoop.u.btree.nBtm));
        }

        if ((pLoop.wsFlags &amp; 0x00000010) != 0)
        {
            pRangeEnd = pLoop.aLTerm[j++];
            nExtraReg = (int)((nExtraReg) &gt; (pLoop.u.btree.nTop) ? (nExtraReg) : (pLoop.u.btree.nTop));
            if ((pRangeEnd.wtFlags &amp; 0x0100) != 0)
            {
                pLevel.iLikeRepCntr = ((uint)(++pParse.nMem));
                sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pLevel.iLikeRepCntr));
                pLevel.addrLikeRep = (int)(sqlite3VdbeCurrentAddr(v));
                pLevel.iLikeRepCntr &lt;&lt;= 1;
                pLevel.iLikeRepCntr |= (uint)(bRev ^ ((pIdx.aSortOrder[nEq]) == (1)));
            }

            if ((pRangeStart) == (null))
            {
                j = (int)(pIdx.aiColumn[nEq]);
                if ((((j) &gt;= (0)) &amp;&amp; ((pIdx.pTable.aCol[j].notNull) == (0))) || ((j) == (-2)))
                {
                    bSeekPastNull = (byte)(1);
                }
            }
        }

        if (((pLoop.wsFlags &amp; (0x00000010 | 0x00000020)) == (0)) &amp;&amp; ((pLoop.wsFlags &amp; 0x00080000) != 0))
        {
            nExtraReg = (int)(1);
            bSeekPastNull = (byte)(1);
            pLevel.regBignull = (int)(regBignull = (int)(++pParse.nMem));
            if ((pLevel.iLeftJoin) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regBignull));
            }

            pLevel.addrBignull = (int)(sqlite3VdbeMakeLabel(pParse));
        }

        if ((((nEq) &lt; (pIdx.nColumn)) &amp;&amp; ((bRev) == ((pIdx.aSortOrder[nEq]) == (0)))))
        {
            {
                WhereTerm t = pRangeEnd;
                pRangeEnd = pRangeStart;
                pRangeStart = t;
            }

            {
                byte t = (byte)(bSeekPastNull);
                bSeekPastNull = (byte)(bStopAtNull);
                bStopAtNull = (byte)(t);
            }

            {
                byte t = (byte)(nBtm);
                nBtm = (ushort)(nTop);
                nTop = (ushort)(t);
            }
        }

        if (((iLevel) &gt; (0)) &amp;&amp; ((pLoop.wsFlags &amp; 0x00100000) != 0))
        {
            sqlite3VdbeAddOp1(v, (int)(135), (int)(iIdxCur));
        }

        regBase = (int)(codeAllEqualityTerms(pParse, pLevel, (int)(bRev), (int)(nExtraReg), &amp;zStartAff));
        if (((zStartAff) != null) &amp;&amp; ((nTop) != 0))
        {
            zEndAff = sqlite3DbStrDup(db, &amp;zStartAff[nEq]);
        }

        addrNxt = (int)((regBignull) != 0 ? pLevel.addrBignull : pLevel.addrNxt);
        startEq = (int)((pRangeStart == null) || ((pRangeStart.eOperator &amp; ((0x0002 &lt;&lt; (55 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) != 0) ? 1 : 0);
        endEq = (int)((pRangeEnd == null) || ((pRangeEnd.eOperator &amp; ((0x0002 &lt;&lt; (55 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) != 0) ? 1 : 0);
        start_constraints = (int)(((pRangeStart) != null) || ((nEq) &gt; (0)) ? 1 : 0);
        nConstraint = (int)(nEq);
        if ((pRangeStart) != null)
        {
            Expr pRight = pRangeStart.pExpr.pRight;
            codeExprOrVector(pParse, pRight, (int)(regBase + nEq), (int)(nBtm));
            whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
            if (((pRangeStart.wtFlags &amp; 0x0080) == (0)) &amp;&amp; ((sqlite3ExprCanBeNull(pRight)) != 0))
            {
                sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + nEq), (int)(addrNxt));
            }

            if ((zStartAff) != null)
            {
                updateRangeAffinityStr(pRight, (int)(nBtm), &amp;zStartAff[nEq]);
            }

            nConstraint += (int)(nBtm);
            if ((sqlite3ExprIsVector(pRight)) == (0))
            {
                disableTerm(pLevel, pRangeStart);
            }
            else
            {
                startEq = (int)(1);
            }

            bSeekPastNull = (byte)(0);
        }
        else if ((bSeekPastNull) != 0)
        {
            startEq = (int)(0);
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
            start_constraints = (int)(1);
            nConstraint++;
        }
        else if ((regBignull) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
            start_constraints = (int)(1);
            nConstraint++;
        }

        codeApplyAffinity(pParse, (int)(regBase), (int)(nConstraint - bSeekPastNull), zStartAff);
        if (((pLoop.nSkip) &gt; (0)) &amp;&amp; ((nConstraint) == (pLoop.nSkip)))
        {
        }
        else
        {
            if ((regBignull) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regBignull));
            }

            if ((pLevel.regFilter) != 0)
            {
                sqlite3VdbeAddOp4Int(v, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(regBase), (int)(nEq));
                filterPullDown(pParse, pWInfo, (int)(iLevel), (int)(addrNxt), (ulong)(notReady));
            }

            op = (int)(sqlite3WhereCodeOneLoopStart_aStartOp[(start_constraints &lt;&lt; 2) + (startEq &lt;&lt; 1) + bRev]);
            if (((pLoop.wsFlags &amp; 0x00100000) != 0) &amp;&amp; ((op) == (25)))
            {
                addrSeekScan = (int)(sqlite3VdbeAddOp1(v, (int)(123), (int)((pIdx.aiRowLogEst[0] + 9) / 10)));
            }

            sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint));
            if ((regBignull) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(sqlite3VdbeCurrentAddr(v) + 2));
                op = (int)(sqlite3WhereCodeOneLoopStart_aStartOp[((nConstraint) &gt; (1)) * 4 + 2 + bRev]);
                sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint - startEq));
            }
        }

        nConstraint = (int)(nEq);
        if ((pRangeEnd) != null)
        {
            Expr pRight = pRangeEnd.pExpr.pRight;
            if ((addrSeekScan) != 0)
            {
                pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
            }

            codeExprOrVector(pParse, pRight, (int)(regBase + nEq), (int)(nTop));
            whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
            if (((pRangeEnd.wtFlags &amp; 0x0080) == (0)) &amp;&amp; ((sqlite3ExprCanBeNull(pRight)) != 0))
            {
                sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + nEq), (int)(addrNxt));
            }

            if ((zEndAff) != null)
            {
                updateRangeAffinityStr(pRight, (int)(nTop), zEndAff);
                codeApplyAffinity(pParse, (int)(regBase + nEq), (int)(nTop), zEndAff);
            }
            else
            {
            }

            nConstraint += (int)(nTop);
            if ((sqlite3ExprIsVector(pRight)) == (0))
            {
                disableTerm(pLevel, pRangeEnd);
            }
            else
            {
                endEq = (int)(1);
            }
        }
        else if ((bStopAtNull) != 0)
        {
            if ((regBignull) == (0))
            {
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
                endEq = (int)(0);
            }

            nConstraint++;
        }

        sqlite3DbFree(db, zStartAff);
        sqlite3DbFree(db, zEndAff);
        if ((pLevel.p2) == (0))
            pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
        if ((nConstraint) != 0)
        {
            if ((regBignull) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(20), (int)(regBignull), (int)(sqlite3VdbeCurrentAddr(v) + 3));
            }

            op = (int)(sqlite3WhereCodeOneLoopStart_aEndOp[bRev * 2 + endEq]);
            sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint));
            if ((addrSeekScan) != 0)
                sqlite3VdbeJumpHere(v, (int)(addrSeekScan));
        }

        if ((regBignull) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(18), (int)(regBignull), (int)(sqlite3VdbeCurrentAddr(v) + 2));
            op = (int)(sqlite3WhereCodeOneLoopStart_aEndOp[bRev * 2 + bSeekPastNull]);
            sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint + bSeekPastNull));
        }

        if ((pLoop.wsFlags &amp; 0x00040000) != 0)
        {
            sqlite3VdbeAddOp3(v, (int)(124), (int)(iIdxCur), (int)(nEq), (int)(nEq));
        }

        omitTable = (int)(((pLoop.wsFlags &amp; 0x00000040) != 0) &amp;&amp; ((pWInfo.wctrlFlags &amp; 0x0020) == (0)) ? 1 : 0);
        if ((omitTable) != 0)
        {
        }
        else if ((((pIdx.pTable).tabFlags &amp; 0x00000080) == (0)))
        {
            codeDeferredSeek(pWInfo, pIdx, (int)(iCur), (int)(iIdxCur));
        }
        else if (iCur != iIdxCur)
        {
            Index pPk = sqlite3PrimaryKeyIndex(pIdx.pTable);
            iRowidReg = (int)(sqlite3GetTempRange(pParse, (int)(pPk.nKeyCol)));
            for (j = (int)(0); (j) &lt; (pPk.nKeyCol); j++)
            {
                k = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[j])));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(k), (int)(iRowidReg + j));
            }

            sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iCur), (int)(addrCont), (int)(iRowidReg), (int)(pPk.nKeyCol));
        }

        if ((pLevel.iLeftJoin) == (0))
        {
            if ((pWInfo.wctrlFlags &amp; 0x0020) == (0))
            {
                whereIndexExprTrans(pIdx, (int)(iCur), (int)(iIdxCur), pWInfo);
            }

            if ((pIdx.pPartIdxWhere) != null)
            {
                whereApplyPartialIndexConstraints(pIdx.pPartIdxWhere, (int)(iCur), pWC);
            }
        }
        else
        {
        }

        if ((pLoop.wsFlags &amp; 0x00001000) != 0)
        {
            pLevel.op = (byte)(182);
        }
        else if ((bRev) != 0)
        {
            pLevel.op = (byte)(4);
        }
        else
        {
            pLevel.op = (byte)(5);
        }

        pLevel.p1 = (int)(iIdxCur);
        pLevel.p3 = (byte)((pLoop.wsFlags &amp; 0x00010000) != 0 ? 1 : 0);
        if ((pLoop.wsFlags &amp; 0x0000000f) == (0))
        {
            pLevel.p5 = (byte)(1);
        }
        else
        {
        }

        if ((omitTable) != 0)
            pIdx = null;
    }
    else if ((pLoop.wsFlags &amp; 0x00002000) != 0)
    {
        WhereClause pOrWc;
        SrcList pOrTab;
        Index pCov = null;
        int iCovCur = (int)(pParse.nTab++);
        int regReturn = (int)(++pParse.nMem);
        int regRowset = (int)(0);
        int regRowid = (int)(0);
        int iLoopBody = (int)(sqlite3VdbeMakeLabel(pParse));
        int iRetInit = 0;
        int untestedTerms = (int)(0);
        int ii = 0;
        Expr pAndExpr = null;
        Table pTab = pTabItem.pTab;
        pTerm = pLoop.aLTerm[0];
        pOrWc = pTerm.u.pOrInfo.wc;
        pLevel.op = (byte)(67);
        pLevel.p1 = (int)(regReturn);
        if ((pWInfo.nLevel) &gt; (1))
        {
            int nNotReady = 0;
            SrcItem origSrc;
            nNotReady = (int)(pWInfo.nLevel - iLevel - 1);
            pOrTab = sqlite3DbMallocRaw(db, (ulong)(sizeof(SrcList) + nNotReady * sizeof(SrcItem)));
            if ((pOrTab) == (null))
                return (ulong)(notReady);
            pOrTab.nAlloc = (uint)((byte)(nNotReady + 1));
            pOrTab.nSrc = (int)(pOrTab.nAlloc);
            CRuntime.memcpy(pOrTab.a, pTabItem, (ulong)(sizeof(SrcItem)));
            origSrc = pWInfo.pTabList.a;
            for (k = (int)(1); (k) &lt;= (nNotReady); k++)
            {
                CRuntime.memcpy(pOrTab.a[k], origSrc[pLevel[k].iFrom], (ulong)(sizeof(SrcItem)));
            }
        }
        else
        {
            pOrTab = pWInfo.pTabList;
        }

        if ((pWInfo.wctrlFlags &amp; 0x0010) == (0))
        {
            if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
            {
                regRowset = (int)(++pParse.nMem);
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regRowset));
            }
            else
            {
                Index pPk = sqlite3PrimaryKeyIndex(pTab);
                regRowset = (int)(pParse.nTab++);
                sqlite3VdbeAddOp2(v, (int)(116), (int)(regRowset), (int)(pPk.nKeyCol));
                sqlite3VdbeSetP4KeyInfo(pParse, pPk);
            }

            regRowid = (int)(++pParse.nMem);
        }

        iRetInit = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regReturn)));
        if ((pWC.nTerm) &gt; (1))
        {
            int iTerm = 0;
            for (iTerm = (int)(0); (iTerm) &lt; (pWC.nTerm); iTerm++)
            {
                Expr pExpr = pWC.a[iTerm].pExpr;
                if ((pWC.a[iTerm]) == (pTerm))
                    continue;
                if ((pWC.a[iTerm].wtFlags &amp; (0x0002 | 0x0004 | 0x8000)) != 0)
                {
                    continue;
                }

                if ((pWC.a[iTerm].eOperator &amp; 0x1fff) == (0))
                    continue;
                if ((((pExpr).flags &amp; (0x200000)) != 0))
                    continue;
                pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
                pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
            }

            if ((pAndExpr) != null)
            {
                pAndExpr = sqlite3PExpr(pParse, (int)(44 | 0x10000), null, pAndExpr);
            }
        }

        sqlite3VdbeExplain(pParse, (byte)(1), "MULTI-INDEX OR");
        for (ii = (int)(0); (ii) &lt; (pOrWc.nTerm); ii++)
        {
            WhereTerm pOrTerm = pOrWc.a[ii];
            if (((pOrTerm.leftCursor) == (iCur)) || ((pOrTerm.eOperator &amp; 0x0400) != 0))
            {
                WhereInfo pSubWInfo;
                Expr pOrExpr = pOrTerm.pExpr;
                Expr pDelete;
                int jmp1 = (int)(0);
                pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, (int)(0));
                if ((db.mallocFailed) != 0)
                {
                    sqlite3ExprDelete(db, pDelete);
                    continue;
                }

                if ((pAndExpr) != null)
                {
                    pAndExpr.pLeft = pOrExpr;
                    pOrExpr = pAndExpr;
                }

                sqlite3VdbeExplain(pParse, (byte)(1), "INDEX %d", (int)(ii + 1));
                pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, null, null, null, (ushort)(0x0020), (int)(iCovCur));
                if ((pSubWInfo) != null)
                {
                    WhereLoop pSubLoop;
                    int addrExplain = (int)(sqlite3WhereExplainOneScan(pParse, pOrTab, pSubWInfo.a[0], (ushort)(0)));
                    ((void)(addrExplain));
                    if ((pWInfo.wctrlFlags &amp; 0x0010) == (0))
                    {
                        int iSet = (int)(((ii) == (pOrWc.nTerm - 1)) ? -1 : ii);
                        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
                        {
                            sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(-1), (int)(regRowid));
                            jmp1 = (int)(sqlite3VdbeAddOp4Int(v, (int)(46), (int)(regRowset), (int)(0), (int)(regRowid), (int)(iSet)));
                        }
                        else
                        {
                            Index pPk = sqlite3PrimaryKeyIndex(pTab);
                            int nPk = (int)(pPk.nKeyCol);
                            int iPk = 0;
                            int r = 0;
                            r = (int)(sqlite3GetTempRange(pParse, (int)(nPk)));
                            for (iPk = (int)(0); (iPk) &lt; (nPk); iPk++)
                            {
                                int iCol = (int)(pPk.aiColumn[iPk]);
                                sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(iCol), (int)(r + iPk));
                            }

                            if ((iSet) != 0)
                            {
                                jmp1 = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(regRowset), (int)(0), (int)(r), (int)(nPk)));
                            }

                            if ((iSet) &gt;= (0))
                            {
                                sqlite3VdbeAddOp3(v, (int)(96), (int)(r), (int)(nPk), (int)(regRowid));
                                sqlite3VdbeAddOp4Int(v, (int)(137), (int)(regRowset), (int)(regRowid), (int)(r), (int)(nPk));
                                if ((iSet) != 0)
                                    sqlite3VdbeChangeP5(v, (ushort)(0x10));
                            }

                            sqlite3ReleaseTempRange(pParse, (int)(r), (int)(nPk));
                        }
                    }

                    sqlite3VdbeAddOp2(v, (int)(12), (int)(regReturn), (int)(iLoopBody));
                    if ((jmp1) != 0)
                        sqlite3VdbeJumpHere(v, (int)(jmp1));
                    if ((pSubWInfo.untestedTerms) != 0)
                        untestedTerms = (int)(1);
                    pSubLoop = pSubWInfo.a[0].pWLoop;
                    if ((((pSubLoop.wsFlags &amp; 0x00000200) != 0) &amp;&amp; (((ii) == (0)) || ((pSubLoop.u.btree.pIndex) == (pCov)))) &amp;&amp; ((((pTab).tabFlags &amp; 0x00000080) == (0)) || (!(((pSubLoop.u.btree.pIndex).idxType) == (2)))))
                    {
                        pCov = pSubLoop.u.btree.pIndex;
                    }
                    else
                    {
                        pCov = null;
                    }

                    if ((sqlite3WhereUsesDeferredSeek(pSubWInfo)) != 0)
                    {
                        pWInfo.bDeferredSeek = (uint)(1);
                    }

                    sqlite3WhereEnd(pSubWInfo);
                    sqlite3VdbeExplainPop(pParse);
                }

                sqlite3ExprDelete(db, pDelete);
            }
        }

        sqlite3VdbeExplainPop(pParse);
        pLevel.u.pCoveringIdx = pCov;
        if ((pCov) != null)
            pLevel.iIdxCur = (int)(iCovCur);
        if ((pAndExpr) != null)
        {
            pAndExpr.pLeft = null;
            sqlite3ExprDelete(db, pAndExpr);
        }

        sqlite3VdbeChangeP1(v, (int)(iRetInit), (int)(sqlite3VdbeCurrentAddr(v)));
        sqlite3VdbeGoto(v, (int)(pLevel.addrBrk));
        sqlite3VdbeResolveLabel(v, (int)(iLoopBody));
        if ((pWInfo.nLevel) &gt; (1))
        {
            sqlite3DbFree(db, pOrTab);
        }

        if (untestedTerms == 0)
            disableTerm(pLevel, pTerm);
    }
    else
    {
        if ((pTabItem.fg.isRecursive) != 0)
        {
            pLevel.op = (byte)(182);
        }
        else
        {
            pLevel.op = (byte)(sqlite3WhereCodeOneLoopStart_aStep[bRev]);
            pLevel.p1 = (int)(iCur);
            pLevel.p2 = (int)(1 + sqlite3VdbeAddOp2(v, (int)(sqlite3WhereCodeOneLoopStart_aStart[bRev]), (int)(iCur), (int)(addrHalt)));
            pLevel.p5 = (byte)(1);
        }
    }

    iLoop = (int)(pIdx ? 1 : 2);
    do
    {
        int iNext = (int)(0);
        for (pTerm = pWC.a, j = (int)(pWC.nTerm); (j) &gt; (0); j--, pTerm++)
        {
            Expr pE;
            int skipLikeAddr = (int)(0);
            if ((pTerm.wtFlags &amp; (0x0002 | 0x0004)) != 0)
                continue;
            if ((pTerm.prereqAll &amp; pLevel.notReady) != 0)
            {
                pWInfo.untestedTerms = (uint)(1);
                continue;
            }

            pE = pTerm.pExpr;
            if (((pTabItem.fg.jointype &amp; 0x0008) != 0) &amp;&amp; (!(((pE).flags &amp; (0x000001)) != 0)))
            {
                continue;
            }

            if (((iLoop) == (1)) &amp;&amp; (sqlite3ExprCoveredByIndex(pE, (int)(pLevel.iTabCur), pIdx) == 0))
            {
                iNext = (int)(2);
                continue;
            }

            if (((iLoop) &lt; (3)) &amp;&amp; ((pTerm.wtFlags &amp; 0x1000) != 0))
            {
                if ((iNext) == (0))
                    iNext = (int)(3);
                continue;
            }

            if ((pTerm.wtFlags &amp; 0x0200) != 0)
            {
                uint x = (uint)(pLevel.iLikeRepCntr);
                if ((x) &gt; (0))
                {
                    skipLikeAddr = (int)(sqlite3VdbeAddOp1(v, (int)((x &amp; 1) ? 20 : 18), (int)(x &gt;&gt; 1)));
                }
            }

            sqlite3ExprIfFalse(pParse, pE, (int)(addrCont), (int)(0x10));
            if ((skipLikeAddr) != 0)
                sqlite3VdbeJumpHere(v, (int)(skipLikeAddr));
            pTerm.wtFlags |= (ushort)(0x0004);
        }

        iLoop = (int)(iNext);
    }
    while ((iLoop) &gt; (0));
    for (pTerm = pWC.a, j = (int)(pWC.nBase); (j) &gt; (0); j--, pTerm++)
    {
        Expr pE;
        Expr sEAlt = new Expr();
        WhereTerm pAlt;
        if ((pTerm.wtFlags &amp; (0x0002 | 0x0004)) != 0)
            continue;
        if ((pTerm.eOperator &amp; (0x0002 | 0x0080)) == (0))
            continue;
        if ((pTerm.eOperator &amp; 0x0800) == (0))
            continue;
        if (pTerm.leftCursor != iCur)
            continue;
        if ((pTabItem.fg.jointype &amp; 0x0008) != 0)
            continue;
        pE = pTerm.pExpr;
        pAlt = sqlite3WhereFindTerm(pWC, (int)(iCur), (int)(pTerm.u.x.leftColumn), (ulong)(notReady), (uint)(0x0002 | 0x0001 | 0x0080), null);
        if ((pAlt) == (null))
            continue;
        if ((pAlt.wtFlags &amp; (0x0004)) != 0)
            continue;
        if ((((pAlt.eOperator &amp; 0x0001) != 0) &amp;&amp; (((pAlt.pExpr).flags &amp; 0x000800) != 0)) &amp;&amp; ((pAlt.pExpr.x.pSelect.pEList.nExpr) &gt; (1)))
        {
            continue;
        }

        sEAlt = (Expr)(pAlt.pExpr);
        sEAlt.pLeft = pE.pLeft;
        sqlite3ExprIfFalse(pParse, sEAlt, (int)(addrCont), (int)(0x10));
        pAlt.wtFlags |= (ushort)(0x0004);
    }

    if ((pLevel.iLeftJoin) != 0)
    {
        pLevel.addrFirst = (int)(sqlite3VdbeCurrentAddr(v));
        sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pLevel.iLeftJoin));
        for (pTerm = pWC.a, j = (int)(0); (j) &lt; (pWC.nBase); j++, pTerm++)
        {
            if ((pTerm.wtFlags &amp; (0x0002 | 0x0004)) != 0)
                continue;
            if ((pTerm.prereqAll &amp; pLevel.notReady) != 0)
            {
                continue;
            }

            sqlite3ExprIfFalse(pParse, pTerm.pExpr, (int)(addrCont), (int)(0x10));
            pTerm.wtFlags |= (ushort)(0x0004);
        }
    }

    return (ulong)(pLevel.notReady);
}</function>
  <function>public static int sqlite3WhereContinueLabel(WhereInfo pWInfo)
{
    return (int)(pWInfo.iContinue);
}</function>
  <function>public static void sqlite3WhereEnd(WhereInfo pWInfo)
{
    Parse pParse = pWInfo.pParse;
    Vdbe v = pParse.pVdbe;
    int i = 0;
    WhereLevel pLevel;
    WhereLoop pLoop;
    SrcList pTabList = pWInfo.pTabList;
    sqlite3 db = pParse.db;
    int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
    for (i = (int)(pWInfo.nLevel - 1); (i) &gt;= (0); i--)
    {
        int addr = 0;
        pLevel = pWInfo.a[i];
        pLoop = pLevel.pWLoop;
        if (pLevel.op != 182)
        {
            int addrSeek = (int)(0);
            Index pIdx;
            int n = 0;
            if (((((((pWInfo.eDistinct) == (2)) &amp;&amp; ((i) == (pWInfo.nLevel - 1))) &amp;&amp; ((pLoop.wsFlags &amp; 0x00000200) != 0)) &amp;&amp; (((pIdx = pLoop.u.btree.pIndex).hasStat1) != 0)) &amp;&amp; ((n = (int)(pLoop.u.btree.nDistinctCol)) &gt; (0))) &amp;&amp; ((pIdx.aiRowLogEst[n]) &gt;= (36)))
            {
                int r1 = (int)(pParse.nMem + 1);
                int j = 0;
                int op = 0;
                for (j = (int)(0); (j) &lt; (n); j++)
                {
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(pLevel.iIdxCur), (int)(j), (int)(r1 + j));
                }

                pParse.nMem += (int)(n + 1);
                op = (int)((pLevel.op) == (4) ? 23 : 26);
                addrSeek = (int)(sqlite3VdbeAddOp4Int(v, (int)(op), (int)(pLevel.iIdxCur), (int)(0), (int)(r1), (int)(n)));
                sqlite3VdbeAddOp2(v, (int)(11), (int)(1), (int)(pLevel.p2));
            }

            sqlite3VdbeResolveLabel(v, (int)(pLevel.addrCont));
            sqlite3VdbeAddOp3(v, (int)(pLevel.op), (int)(pLevel.p1), (int)(pLevel.p2), (int)(pLevel.p3));
            sqlite3VdbeChangeP5(v, (ushort)(pLevel.p5));
            if ((pLevel.regBignull) != 0)
            {
                sqlite3VdbeResolveLabel(v, (int)(pLevel.addrBignull));
                sqlite3VdbeAddOp2(v, (int)(60), (int)(pLevel.regBignull), (int)(pLevel.p2 - 1));
            }

            if ((addrSeek) != 0)
                sqlite3VdbeJumpHere(v, (int)(addrSeek));
        }
        else
        {
            sqlite3VdbeResolveLabel(v, (int)(pLevel.addrCont));
        }

        if (((pLoop.wsFlags &amp; 0x00000800) != 0) &amp;&amp; ((pLevel.u._in_.nIn) &gt; (0)))
        {
            InLoop* pIn;
            int j = 0;
            sqlite3VdbeResolveLabel(v, (int)(pLevel.addrNxt));
            for (j = (int)(pLevel.u._in_.nIn), pIn = &amp;pLevel.u._in_.aInLoop[j - 1]; (j) &gt; (0); j--, pIn--)
            {
                sqlite3VdbeJumpHere(v, (int)(pIn-&gt;addrInTop + 1));
                if (pIn-&gt;eEndLoopOp != 182)
                {
                    if ((pIn-&gt;nPrefix) != 0)
                    {
                        int bEarlyOut = (int)(((pLoop.wsFlags &amp; 0x00000400) == (0)) &amp;&amp; ((pLoop.wsFlags &amp; 0x00040000) != 0) ? 1 : 0);
                        if ((pLevel.iLeftJoin) != 0)
                        {
                            sqlite3VdbeAddOp2(v, (int)(27), (int)(pIn-&gt;iCur), (int)(sqlite3VdbeCurrentAddr(v) + 2 + bEarlyOut));
                        }

                        if ((bEarlyOut) != 0)
                        {
                            sqlite3VdbeAddOp4Int(v, (int)(28), (int)(pLevel.iIdxCur), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(pIn-&gt;iBase), (int)(pIn-&gt;nPrefix));
                            sqlite3VdbeJumpHere(v, (int)(pIn-&gt;addrInTop + 1));
                        }
                    }

                    sqlite3VdbeAddOp2(v, (int)(pIn-&gt;eEndLoopOp), (int)(pIn-&gt;iCur), (int)(pIn-&gt;addrInTop));
                }

                sqlite3VdbeJumpHere(v, (int)(pIn-&gt;addrInTop - 1));
            }
        }

        sqlite3VdbeResolveLabel(v, (int)(pLevel.addrBrk));
        if ((pLevel.addrSkip) != 0)
        {
            sqlite3VdbeGoto(v, (int)(pLevel.addrSkip));
            sqlite3VdbeJumpHere(v, (int)(pLevel.addrSkip));
            sqlite3VdbeJumpHere(v, (int)(pLevel.addrSkip - 2));
        }

        if ((pLevel.addrLikeRep) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(60), (int)(pLevel.iLikeRepCntr &gt;&gt; 1), (int)(pLevel.addrLikeRep));
        }

        if ((pLevel.iLeftJoin) != 0)
        {
            int ws = (int)(pLoop.wsFlags);
            addr = (int)(sqlite3VdbeAddOp1(v, (int)(49), (int)(pLevel.iLeftJoin)));
            if ((ws &amp; 0x00000040) == (0))
            {
                sqlite3VdbeAddOp1(v, (int)(135), (int)(pLevel.iTabCur));
            }

            if (((ws &amp; 0x00000200) != 0) || (((ws &amp; 0x00002000) != 0) &amp;&amp; ((pLevel.u.pCoveringIdx) != null)))
            {
                if ((ws &amp; 0x00002000) != 0)
                {
                    Index pIx = pLevel.u.pCoveringIdx;
                    int iDb = (int)(sqlite3SchemaToIndex(db, pIx.pSchema));
                    sqlite3VdbeAddOp3(v, (int)(100), (int)(pLevel.iIdxCur), (int)(pIx.tnum), (int)(iDb));
                    sqlite3VdbeSetP4KeyInfo(pParse, pIx);
                }

                sqlite3VdbeAddOp1(v, (int)(135), (int)(pLevel.iIdxCur));
            }

            if ((pLevel.op) == (67))
            {
                sqlite3VdbeAddOp2(v, (int)(12), (int)(pLevel.p1), (int)(pLevel.addrFirst));
            }
            else
            {
                sqlite3VdbeGoto(v, (int)(pLevel.addrFirst));
            }

            sqlite3VdbeJumpHere(v, (int)(addr));
        }
    }

    sqlite3VdbeResolveLabel(v, (int)(pWInfo.iBreak));
    for (i = (int)(0), pLevel = pWInfo.a; (i) &lt; (pWInfo.nLevel); i++, pLevel++)
    {
        int k = 0;
        int last = 0;
        VdbeOp* pOp;
        VdbeOp* pLastOp;
        Index pIdx = null;
        SrcItem pTabItem = pTabList.a[pLevel.iFrom];
        Table pTab = pTabItem.pTab;
        pLoop = pLevel.pWLoop;
        if ((pTabItem.fg.viaCoroutine) != 0)
        {
            translateColumnToCopy(pParse, (int)(pLevel.addrBody), (int)(pLevel.iTabCur), (int)(pTabItem.regResult), (int)(0));
            continue;
        }

        if ((pLoop.wsFlags &amp; (0x00000200 | 0x00000040)) != 0)
        {
            pIdx = pLoop.u.btree.pIndex;
        }
        else if ((pLoop.wsFlags &amp; 0x00002000) != 0)
        {
            pIdx = pLevel.u.pCoveringIdx;
        }

        if (((pIdx) != null) &amp;&amp; (db.mallocFailed == 0))
        {
            if (((pWInfo.eOnePass) == (0)) || (!(((pIdx.pTable).tabFlags &amp; 0x00000080) == (0))))
            {
                last = (int)(iEnd);
            }
            else
            {
                last = (int)(pWInfo.iEndWhere);
            }

            k = (int)(pLevel.addrBody + 1);
            pOp = sqlite3VdbeGetOp(v, (int)(k));
            pLastOp = pOp + (last - k);
            do
            {
                if (pOp-&gt;p1 != pLevel.iTabCur)
                {
                }
                else if ((pOp-&gt;opcode) == (93))
                {
                    int x = (int)(pOp-&gt;p2);
                    if (!(((pTab).tabFlags &amp; 0x00000080) == (0)))
                    {
                        Index pPk = sqlite3PrimaryKeyIndex(pTab);
                        x = (int)(pPk.aiColumn[x]);
                    }
                    else
                    {
                        x = (int)(sqlite3StorageColumnToTable(pTab, (short)(x)));
                    }

                    x = (int)(sqlite3TableColumnToIndex(pIdx, (short)(x)));
                    if ((x) &gt;= (0))
                    {
                        pOp-&gt;p2 = (int)(x);
                        pOp-&gt;p1 = (int)(pLevel.iIdxCur);
                    }
                    else
                    {
                    }
                }
                else if ((pOp-&gt;opcode) == (134))
                {
                    pOp-&gt;p1 = (int)(pLevel.iIdxCur);
                    pOp-&gt;opcode = (byte)(141);
                }
                else if ((pOp-&gt;opcode) == (22))
                {
                    pOp-&gt;p1 = (int)(pLevel.iIdxCur);
                }
            }
            while ((++pOp) &lt; (pLastOp));
        }
    }

    if ((pWInfo.pExprMods) != null)
        whereUndoExprMods(pWInfo);
    pParse.nQueryLoop = (uint)(pWInfo.savedNQueryLoop);
    whereInfoFree(db, pWInfo);
    return;
}</function>
  <function>public static int sqlite3WhereExplainBloomFilter(Parse pParse, WhereInfo pWInfo, WhereLevel pLevel)
{
    int ret = (int)(0);
    SrcItem pItem = pWInfo.pTabList.a[pLevel.iFrom];
    Vdbe v = pParse.pVdbe;
    sqlite3 db = pParse.db;
    sbyte* zMsg;
    int i = 0;
    WhereLoop pLoop;
    sqlite3_str str = new sqlite3_str();
    sbyte* zBuf = stackalloc sbyte[100];
    sqlite3StrAccumInit(str, db, zBuf, (int)(100 * sizeof(sbyte)), (int)(1000000000));
    str.printfFlags = (byte)(0x01);
    sqlite3_str_appendf(str, "BLOOM FILTER ON %S (", pItem);
    pLoop = pLevel.pWLoop;
    if ((pLoop.wsFlags &amp; 0x00000100) != 0)
    {
        Table pTab = pItem.pTab;
        if ((pTab.iPKey) &gt;= (0))
        {
            sqlite3_str_appendf(str, "%s=?", pTab.aCol[pTab.iPKey].zCnName);
        }
        else
        {
            sqlite3_str_appendf(str, "rowid=?");
        }
    }
    else
    {
        for (i = (int)(pLoop.nSkip); (i) &lt; (pLoop.u.btree.nEq); i++)
        {
            sbyte* z = explainIndexColumnName(pLoop.u.btree.pIndex, (int)(i));
            if ((i) &gt; (pLoop.nSkip))
                sqlite3_str_append(str, " AND ", (int)(5));
            sqlite3_str_appendf(str, "%s=?", z);
        }
    }

    sqlite3_str_append(str, ")", (int)(1));
    zMsg = sqlite3StrAccumFinish(str);
    ret = (int)(sqlite3VdbeAddOp4(v, (int)(183), (int)(sqlite3VdbeCurrentAddr(v)), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7)));
    return (int)(ret);
}</function>
  <function>public static int sqlite3WhereExplainOneScan(Parse pParse, SrcList pTabList, WhereLevel pLevel, ushort wctrlFlags)
{
    int ret = (int)(0);
    if ((((pParse).pToplevel ? (pParse).pToplevel : (pParse)).explain) == (2))
    {
        SrcItem pItem = pTabList.a[pLevel.iFrom];
        Vdbe v = pParse.pVdbe;
        sqlite3 db = pParse.db;
        int isSearch = 0;
        WhereLoop pLoop;
        uint flags = 0;
        sbyte* zMsg;
        sqlite3_str str = new sqlite3_str();
        sbyte* zBuf = stackalloc sbyte[100];
        pLoop = pLevel.pWLoop;
        flags = (uint)(pLoop.wsFlags);
        if (((flags &amp; 0x00002000) != 0) || ((wctrlFlags &amp; 0x0020) != 0))
            return (int)(0);
        isSearch = (int)((((flags &amp; (0x00000020 | 0x00000010)) != 0) || (((flags &amp; 0x00000400) == (0)) &amp;&amp; ((pLoop.u.btree.nEq) &gt; (0)))) || ((wctrlFlags &amp; (0x0001 | 0x0002)) != 0) ? 1 : 0);
        sqlite3StrAccumInit(str, db, zBuf, (int)(100 * sizeof(sbyte)), (int)(1000000000));
        str.printfFlags = (byte)(0x01);
        sqlite3_str_appendf(str, "%s %S", (isSearch) != 0 ? "SEARCH" : "SCAN", pItem);
        if ((flags &amp; (0x00000100 | 0x00000400)) == (0))
        {
            sbyte* zFmt = null;
            Index pIdx;
            pIdx = pLoop.u.btree.pIndex;
            if ((!(((pItem.pTab).tabFlags &amp; 0x00000080) == (0))) &amp;&amp; (((pIdx).idxType) == (2)))
            {
                if ((isSearch) != 0)
                {
                    zFmt = "PRIMARY KEY";
                }
            }
            else if ((flags &amp; 0x00020000) != 0)
            {
                zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
            }
            else if ((flags &amp; 0x00004000) != 0)
            {
                zFmt = "AUTOMATIC COVERING INDEX";
            }
            else if ((flags &amp; 0x00000040) != 0)
            {
                zFmt = "COVERING INDEX %s";
            }
            else
            {
                zFmt = "INDEX %s";
            }

            if ((zFmt) != null)
            {
                sqlite3_str_append(str, " USING ", (int)(7));
                sqlite3_str_appendf(str, zFmt, pIdx.zName);
                explainIndexRange(str, pLoop);
            }
        }
        else if (((flags &amp; 0x00000100) != 0) &amp;&amp; ((flags &amp; 0x0000000f) != 0))
        {
            sbyte cRangeOp = 0;
            sbyte* zRowid = "rowid";
            sqlite3_str_appendf(str, " USING INTEGER PRIMARY KEY (%s", zRowid);
            if ((flags &amp; (0x00000001 | 0x00000004)) != 0)
            {
                cRangeOp = (sbyte)(61);
            }
            else if ((flags &amp; 0x00000030) == (0x00000030))
            {
                sqlite3_str_appendf(str, "&gt;? AND %s", zRowid);
                cRangeOp = (sbyte)(60);
            }
            else if ((flags &amp; 0x00000020) != 0)
            {
                cRangeOp = (sbyte)(62);
            }
            else
            {
                cRangeOp = (sbyte)(60);
            }

            sqlite3_str_appendf(str, "%c?)", (int)(cRangeOp));
        }
        else if ((flags &amp; 0x00000400) != 0)
        {
            sqlite3_str_appendf(str, " VIRTUAL TABLE INDEX %d:%s", (int)(pLoop.u.vtab.idxNum), pLoop.u.vtab.idxStr);
        }

        zMsg = sqlite3StrAccumFinish(str);
        ret = (int)(sqlite3VdbeAddOp4(v, (int)(183), (int)(sqlite3VdbeCurrentAddr(v)), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7)));
    }

    return (int)(ret);
}</function>
  <function>public static void sqlite3WhereExprAnalyze(SrcList pTabList, WhereClause pWC)
{
    int i = 0;
    for (i = (int)(pWC.nTerm - 1); (i) &gt;= (0); i--)
    {
        exprAnalyze(pTabList, pWC, (int)(i));
    }
}</function>
  <function>public static ulong sqlite3WhereExprListUsage(WhereMaskSet* pMaskSet, ExprList pList)
{
    int i = 0;
    ulong mask = (ulong)(0);
    if ((pList) != null)
    {
        for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
        {
            mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pList.a[i].pExpr));
        }
    }

    return (ulong)(mask);
}</function>
  <function>public static ulong sqlite3WhereExprUsage(WhereMaskSet* pMaskSet, Expr p)
{
    return (ulong)(p ? sqlite3WhereExprUsageNN(pMaskSet, p) : 0);
}</function>
  <function>public static ulong sqlite3WhereExprUsageFull(WhereMaskSet* pMaskSet, Expr p)
{
    ulong mask = 0;
    mask = (ulong)(((p.op) == (179)) ? sqlite3WhereGetMask(pMaskSet, (int)(p.iTable)) : 0);
    if ((p.pLeft) != null)
        mask |= (ulong)(sqlite3WhereExprUsageNN(pMaskSet, p.pLeft));
    if ((p.pRight) != null)
    {
        mask |= (ulong)(sqlite3WhereExprUsageNN(pMaskSet, p.pRight));
    }
    else if ((((p).flags &amp; 0x000800) != 0))
    {
        if ((((p).flags &amp; (0x000020)) != 0))
            pMaskSet-&gt;bVarSelect = (int)(1);
        mask |= (ulong)(exprSelectUsage(pMaskSet, p.x.pSelect));
    }
    else if ((p.x.pList) != null)
    {
        mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, p.x.pList));
    }

    if ((((p.op) == (172)) || ((p.op) == (168))) &amp;&amp; (((p).flags &amp; 0x1000000) != 0))
    {
        mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, p.y.pWin.pPartition));
        mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, p.y.pWin.pOrderBy));
        mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, p.y.pWin.pFilter));
    }

    return (ulong)(mask);
}</function>
  <function>public static ulong sqlite3WhereExprUsageNN(WhereMaskSet* pMaskSet, Expr p)
{
    if (((p.op) == (167)) &amp;&amp; (!(((p).flags &amp; (0x000008)) != 0)))
    {
        return (ulong)(sqlite3WhereGetMask(pMaskSet, (int)(p.iTable)));
    }
    else if ((((p).flags &amp; (0x004000 | 0x800000)) != 0))
    {
        return (ulong)(0);
    }

    return (ulong)(sqlite3WhereExprUsageFull(pMaskSet, p));
}</function>
  <function>public static WhereTerm sqlite3WhereFindTerm(WhereClause pWC, int iCur, int iColumn, ulong notReady, uint op, Index pIdx)
{
    WhereTerm pResult = null;
    WhereTerm p;
    WhereScan scan = new WhereScan();
    p = whereScanInit(scan, pWC, (int)(iCur), (int)(iColumn), (uint)(op), pIdx);
    op &amp;= (uint)(0x0002 | 0x0080);
    while ((p) != null)
    {
        if ((p.prereqRight &amp; notReady) == (0))
        {
            if (((p.prereqRight) == (0)) &amp;&amp; ((p.eOperator &amp; op) != 0))
            {
                return p;
            }

            if ((pResult) == (null))
                pResult = p;
        }

        p = whereScanNext(scan);
    }

    return pResult;
}</function>
  <function>public static ulong sqlite3WhereGetMask(WhereMaskSet* pMaskSet, int iCursor)
{
    int i = 0;
    if ((pMaskSet-&gt;ix[0]) == (iCursor))
    {
        return (ulong)(1);
    }

    for (i = (int)(1); (i) &lt; (pMaskSet-&gt;n); i++)
    {
        if ((pMaskSet-&gt;ix[i]) == (iCursor))
        {
            return (ulong)(((ulong)(1)) &lt;&lt; (i));
        }
    }

    return (ulong)(0);
}</function>
  <function>public static int sqlite3WhereIsDistinct(WhereInfo pWInfo)
{
    return (int)(pWInfo.eDistinct);
}</function>
  <function>public static int sqlite3WhereIsOrdered(WhereInfo pWInfo)
{
    return (int)(pWInfo.nOBSat);
}</function>
  <function>public static int sqlite3WhereIsSorted(WhereInfo pWInfo)
{
    return (int)(pWInfo.sorted);
}</function>
  <function>public static void sqlite3WhereMinMaxOptEarlyOut(Vdbe v, WhereInfo pWInfo)
{
    WhereLevel pInner;
    int i = 0;
    if (pWInfo.bOrderedInnerLoop == 0)
        return;
    if ((pWInfo.nOBSat) == (0))
        return;
    for (i = (int)(pWInfo.nLevel - 1); (i) &gt;= (0); i--)
    {
        pInner = pWInfo.a[i];
        if ((pInner.pWLoop.wsFlags &amp; 0x00000004) != 0)
        {
            sqlite3VdbeGoto(v, (int)(pInner.addrNxt));
            return;
        }
    }

    sqlite3VdbeGoto(v, (int)(pWInfo.iBreak));
}</function>
  <function>public static int sqlite3WhereOkOnePass(WhereInfo pWInfo, int* aiCur)
{
    CRuntime.memcpy(aiCur, pWInfo.aiCurOnePass, (ulong)(sizeof(int) * 2));
    return (int)(pWInfo.eOnePass);
}</function>
  <function>public static int sqlite3WhereOrderByLimitOptLabel(WhereInfo pWInfo)
{
    WhereLevel pInner;
    if (pWInfo.bOrderedInnerLoop == 0)
    {
        return (int)(pWInfo.iContinue);
    }

    pInner = pWInfo.a[pWInfo.nLevel - 1];
    return (int)(pInner.addrNxt);
}</function>
  <function>public static short sqlite3WhereOutputRowCount(WhereInfo pWInfo)
{
    return (short)(pWInfo.nRowOut);
}</function>
  <function>public static void sqlite3WhereSplit(WhereClause pWC, Expr pExpr, byte op)
{
    Expr pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);
    pWC.op = (byte)(op);
    if ((pE2) == (null))
        return;
    if (pE2.op != op)
    {
        whereClauseInsert(pWC, pExpr, (ushort)(0));
    }
    else
    {
        sqlite3WhereSplit(pWC, pE2.pLeft, (byte)(op));
        sqlite3WhereSplit(pWC, pE2.pRight, (byte)(op));
    }
}</function>
  <function>public static void sqlite3WhereTabFuncArgs(Parse pParse, SrcItem pItem, WhereClause pWC)
{
    Table pTab;
    int j = 0; int  k  =  0 ; 
    ExprList pArgs;
    Expr pColRef;
    Expr pTerm;
    if ((pItem.fg.isTabFunc) == (0))
        return;
    pTab = pItem.pTab;
    pArgs = pItem.u1.pFuncArg;
    if ((pArgs) == (null))
        return;
    for (j = (int)(k = (int)(0)); (j) &lt; (pArgs.nExpr); j++)
    {
        Expr pRhs;
        while (((k) &lt; (pTab.nCol)) &amp;&amp; ((pTab.aCol[k].colFlags &amp; 0x0002) == (0)))
        {
            k++;
        }

        if ((k) &gt;= (pTab.nCol))
        {
            sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d", pTab.zName, (int)(j));
            return;
        }

        pColRef = sqlite3ExprAlloc(pParse.db, (int)(167), null, (int)(0));
        if ((pColRef) == (null))
            return;
        pColRef.iTable = (int)(pItem.iCursor);
        pColRef.iColumn = (short)(k++);
        pColRef.y.pTab = pTab;
        pItem.colUsed |= (ulong)(sqlite3ExprColUsed(pColRef));
        pRhs = sqlite3PExpr(pParse, (int)(174), sqlite3ExprDup(pParse.db, pArgs.a[j].pExpr, (int)(0)), null);
        pTerm = sqlite3PExpr(pParse, (int)(53), pColRef, pRhs);
        if ((pItem.fg.jointype &amp; 0x0008) != 0)
        {
            sqlite3SetJoinExpr(pTerm, (int)(pItem.iCursor));
        }

        whereClauseInsert(pWC, pTerm, (ushort)(0x0001));
    }
}</function>
  <function>public static int sqlite3WhereUsesDeferredSeek(WhereInfo pWInfo)
{
    return (int)(pWInfo.bDeferredSeek);
}</function>
  <function>public static uint sqlite3Win32Wait(void* hObject)
{
    uint rc = 0;
    while ((rc = (uint)((Uint(Void * , Void * , Void * ))(aSyscall[64].pCurrent)(hObject, (uint)(0xFFFFFFFF), (int)(1)))) == ((uint)(0x000000C0L)))
    {
    }

    return (uint)(rc);
}</function>
  <function>public static Window sqlite3WindowAlloc(Parse pParse, int eType, int eStart, Expr pStart, int eEnd, Expr pEnd, byte eExclude)
{
    Window pWin = null;
    int bImplicitFrame = (int)(0);
    if ((eType) == (0))
    {
        bImplicitFrame = (int)(1);
        eType = (int)(89);
    }

    if ((((eStart) == (85)) &amp;&amp; ((eEnd) == (88))) || (((eStart) == (86)) &amp;&amp; (((eEnd) == (88)) || ((eEnd) == (85)))))
    {
        sqlite3ErrorMsg(pParse, "unsupported frame specification");
        goto windowAllocErr;
    }

    pWin = (Window)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(Window))));
    if ((pWin) == (null))
        goto windowAllocErr;
    pWin.eFrmType = (byte)(eType);
    pWin.eStart = (byte)(eStart);
    pWin.eEnd = (byte)(eEnd);
    if (((eExclude) == (0)) &amp;&amp; (((pParse.db).dbOptFlags &amp; (0x00000002)) != 0))
    {
        eExclude = (byte)(66);
    }

    pWin.eExclude = (byte)(eExclude);
    pWin.bImplicitFrame = (byte)(bImplicitFrame);
    pWin.pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
    pWin.pStart = sqlite3WindowOffsetExpr(pParse, pStart);
    return pWin;
    windowAllocErr:
        ; sqlite3ExprDelete ( pParse . db ,  pEnd ) ; 
    sqlite3ExprDelete(pParse.db, pStart);
    return null;
}</function>
  <function>public static Window sqlite3WindowAssemble(Parse pParse, Window pWin, ExprList pPartition, ExprList pOrderBy, Token* pBase)
{
    if ((pWin) != null)
    {
        pWin.pPartition = pPartition;
        pWin.pOrderBy = pOrderBy;
        if ((pBase) != null)
        {
            pWin.zBase = sqlite3DbStrNDup(pParse.db, pBase-&gt;z, (ulong)(pBase-&gt;n));
        }
    }
    else
    {
        sqlite3ExprListDelete(pParse.db, pPartition);
        sqlite3ExprListDelete(pParse.db, pOrderBy);
    }

    return pWin;
}</function>
  <function>public static void sqlite3WindowAttach(Parse pParse, Expr p, Window pWin)
{
    if ((p) != null)
    {
        p.y.pWin = pWin;
        (p).flags |= (uint)(0x1000000);
        pWin.pOwner = p;
        if (((p.flags &amp; 0x000002) != 0) &amp;&amp; (pWin.eFrmType != 166))
        {
            sqlite3ErrorMsg(pParse, "DISTINCT is not supported for window functions");
        }
    }
    else
    {
        sqlite3WindowDelete(pParse.db, pWin);
    }
}</function>
  <function>public static void sqlite3WindowChain(Parse pParse, Window pWin, Window pList)
{
    if ((pWin.zBase) != null)
    {
        sqlite3 db = pParse.db;
        Window pExist = windowFind(pParse, pList, pWin.zBase);
        if ((pExist) != null)
        {
            sbyte* zErr = null;
            if ((pWin.pPartition) != null)
            {
                zErr = "PARTITION clause";
            }
            else if (((pExist.pOrderBy) != null) &amp;&amp; ((pWin.pOrderBy) != null))
            {
                zErr = "ORDER BY clause";
            }
            else if ((pExist.bImplicitFrame) == (0))
            {
                zErr = "frame specification";
            }

            if ((zErr) != null)
            {
                sqlite3ErrorMsg(pParse, "cannot override %s of window: %s", zErr, pWin.zBase);
            }
            else
            {
                pWin.pPartition = sqlite3ExprListDup(db, pExist.pPartition, (int)(0));
                if ((pExist.pOrderBy) != null)
                {
                    pWin.pOrderBy = sqlite3ExprListDup(db, pExist.pOrderBy, (int)(0));
                }

                sqlite3DbFree(db, pWin.zBase);
                pWin.zBase = null;
            }
        }
    }
}</function>
  <function>public static void sqlite3WindowCodeInit(Parse pParse, Select pSelect)
{
    int nEphExpr = (int)(pSelect.pSrc.a[0].pSelect.pEList.nExpr);
    Window pMWin = pSelect.pWin;
    Window pWin;
    Vdbe v = sqlite3GetVdbe(pParse);
    sqlite3VdbeAddOp2(v, (int)(116), (int)(pMWin.iEphCsr), (int)(nEphExpr));
    sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 1), (int)(pMWin.iEphCsr));
    sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 2), (int)(pMWin.iEphCsr));
    sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 3), (int)(pMWin.iEphCsr));
    if ((pMWin.pPartition) != null)
    {
        int nExpr = (int)(pMWin.pPartition.nExpr);
        pMWin.regPart = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nExpr);
        sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(pMWin.regPart), (int)(pMWin.regPart + nExpr - 1));
    }

    pMWin.regOne = (int)(++pParse.nMem);
    sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regOne));
    if ((pMWin.eExclude) != 0)
    {
        pMWin.regStartRowid = (int)(++pParse.nMem);
        pMWin.regEndRowid = (int)(++pParse.nMem);
        pMWin.csrApp = (int)(pParse.nTab++);
        sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regStartRowid));
        sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pMWin.regEndRowid));
        sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.csrApp), (int)(pMWin.iEphCsr));
        return;
    }

    for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
    {
        FuncDef p = pWin.pFunc;
        if (((p.funcFlags &amp; 0x1000) != 0) &amp;&amp; (pWin.eStart != 90))
        {
            ExprList pList;
            KeyInfo pKeyInfo;
            pList = pWin.pOwner.x.pList;
            pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, (int)(0), (int)(0));
            pWin.csrApp = (int)(pParse.nTab++);
            pWin.regApp = (int)(pParse.nMem + 1);
            pParse.nMem += (int)(3);
            if (((pKeyInfo) != null) &amp;&amp; ((pWin.pFunc.zName[1]) == (105)))
            {
                pKeyInfo.aSortFlags[0] = (byte)(0x01);
            }

            sqlite3VdbeAddOp2(v, (int)(116), (int)(pWin.csrApp), (int)(2));
            sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
        }
        else if (((p.zName) == (nth_valueName)) || ((p.zName) == (first_valueName)))
        {
            pWin.regApp = (int)(pParse.nMem + 1);
            pWin.csrApp = (int)(pParse.nTab++);
            pParse.nMem += (int)(2);
            sqlite3VdbeAddOp2(v, (int)(113), (int)(pWin.csrApp), (int)(pMWin.iEphCsr));
        }
        else if (((p.zName) == (leadName)) || ((p.zName) == (lagName)))
        {
            pWin.csrApp = (int)(pParse.nTab++);
            sqlite3VdbeAddOp2(v, (int)(113), (int)(pWin.csrApp), (int)(pMWin.iEphCsr));
        }
    }
}</function>
  <function>public static void sqlite3WindowCodeStep(Parse pParse, Select p, WhereInfo pWInfo, int regGosub, int addrGosub)
{
    Window pMWin = p.pWin;
    ExprList pOrderBy = pMWin.pOrderBy;
    Vdbe v = sqlite3GetVdbe(pParse);
    int csrWrite = 0;
    int csrInput = (int)(p.pSrc.a[0].iCursor);
    int nInput = (int)(p.pSrc.a[0].pTab.nCol);
    int iInput = 0;
    int addrNe = 0;
    int addrGosubFlush = (int)(0);
    int addrInteger = (int)(0);
    int addrEmpty = 0;
    int regNew = 0;
    int regRecord = 0;
    int regNewPeer = (int)(0);
    int regPeer = (int)(0);
    int regFlushPart = (int)(0);
    WindowCodeArg s = new WindowCodeArg();
    int lblWhereEnd = 0;
    int regStart = (int)(0);
    int regEnd = (int)(0);
    lblWhereEnd = (int)(sqlite3VdbeMakeLabel(pParse));
    CRuntime.memset(s, (int)(0), (ulong)(sizeof(WindowCodeArg)));
    s.pParse = pParse;
    s.pMWin = pMWin;
    s.pVdbe = v;
    s.regGosub = (int)(regGosub);
    s.addrGosub = (int)(addrGosub);
    s.current.csr = (int)(pMWin.iEphCsr);
    csrWrite = (int)(s.current.csr + 1);
    s.start.csr = (int)(s.current.csr + 2);
    s.end.csr = (int)(s.current.csr + 3);
    switch (pMWin.eStart)
    {
        case 86:
            if ((pMWin.eFrmType != 89) &amp;&amp; ((windowExprGtZero(pParse, pMWin.pStart)) != 0))
            {
                s.eDelete = (int)(1);
            }

            break;
        case 90:
            if ((windowCacheFrame(pMWin)) == (0))
            {
                if ((pMWin.eEnd) == (88))
                {
                    if ((pMWin.eFrmType != 89) &amp;&amp; ((windowExprGtZero(pParse, pMWin.pEnd)) != 0))
                    {
                        s.eDelete = (int)(3);
                    }
                }
                else
                {
                    s.eDelete = (int)(1);
                }
            }

            break;
        default:
            s.eDelete = (int)(2);
            break;
    }

    regNew = (int)(pParse.nMem + 1);
    pParse.nMem += (int)(nInput);
    regRecord = (int)(++pParse.nMem);
    s.regRowid = (int)(++pParse.nMem);
    if (((pMWin.eStart) == (88)) || ((pMWin.eStart) == (86)))
    {
        regStart = (int)(++pParse.nMem);
    }

    if (((pMWin.eEnd) == (88)) || ((pMWin.eEnd) == (86)))
    {
        regEnd = (int)(++pParse.nMem);
    }

    if (pMWin.eFrmType != 76)
    {
        int nPeer = (int)(pOrderBy ? pOrderBy.nExpr : 0);
        regNewPeer = (int)(regNew + pMWin.nBufferCol);
        if ((pMWin.pPartition) != null)
            regNewPeer += (int)(pMWin.pPartition.nExpr);
        regPeer = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nPeer);
        s.start.reg = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nPeer);
        s.current.reg = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nPeer);
        s.end.reg = (int)(pParse.nMem + 1);
        pParse.nMem += (int)(nPeer);
    }

    for (iInput = (int)(0); (iInput) &lt; (nInput); iInput++)
    {
        sqlite3VdbeAddOp3(v, (int)(93), (int)(csrInput), (int)(iInput), (int)(regNew + iInput));
    }

    sqlite3VdbeAddOp3(v, (int)(96), (int)(regNew), (int)(nInput), (int)(regRecord));
    if ((pMWin.pPartition) != null)
    {
        int addr = 0;
        ExprList pPart = pMWin.pPartition;
        int nPart = (int)(pPart.nExpr);
        int regNewPart = (int)(regNew + pMWin.nBufferCol);
        KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, (int)(0), (int)(0));
        regFlushPart = (int)(++pParse.nMem);
        addr = (int)(sqlite3VdbeAddOp3(v, (int)(89), (int)(regNewPart), (int)(pMWin.regPart), (int)(nPart)));
        sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
        sqlite3VdbeAddOp3(v, (int)(16), (int)(addr + 2), (int)(addr + 4), (int)(addr + 2));
        addrGosubFlush = (int)(sqlite3VdbeAddOp1(v, (int)(12), (int)(regFlushPart)));
        sqlite3VdbeAddOp3(v, (int)(79), (int)(regNewPart), (int)(pMWin.regPart), (int)(nPart - 1));
    }

    sqlite3VdbeAddOp2(v, (int)(126), (int)(csrWrite), (int)(s.regRowid));
    sqlite3VdbeAddOp3(v, (int)(127), (int)(csrWrite), (int)(regRecord), (int)(s.regRowid));
    addrNe = (int)(sqlite3VdbeAddOp3(v, (int)(52), (int)(pMWin.regOne), (int)(0), (int)(s.regRowid)));
    s.regArg = (int)(windowInitAccum(pParse, pMWin));
    if ((regStart) != 0)
    {
        sqlite3ExprCode(pParse, pMWin.pStart, (int)(regStart));
        windowCheckValue(pParse, (int)(regStart), (int)(0 + ((pMWin.eFrmType) == (89) ? 3 : 0)));
    }

    if ((regEnd) != 0)
    {
        sqlite3ExprCode(pParse, pMWin.pEnd, (int)(regEnd));
        windowCheckValue(pParse, (int)(regEnd), (int)(1 + ((pMWin.eFrmType) == (89) ? 3 : 0)));
    }

    if (((pMWin.eFrmType != 89) &amp;&amp; ((pMWin.eStart) == (pMWin.eEnd))) &amp;&amp; ((regStart) != 0))
    {
        int op = (int)(((pMWin.eStart) == (86)) ? 57 : 55);
        int addrGe = (int)(sqlite3VdbeAddOp3(v, (int)(op), (int)(regStart), (int)(0), (int)(regEnd)));
        windowAggFinal(s, (int)(0));
        sqlite3VdbeAddOp2(v, (int)(38), (int)(s.current.csr), (int)(1));
        windowReturnOneRow(s);
        sqlite3VdbeAddOp1(v, (int)(145), (int)(s.current.csr));
        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblWhereEnd));
        sqlite3VdbeJumpHere(v, (int)(addrGe));
    }

    if ((((pMWin.eStart) == (86)) &amp;&amp; (pMWin.eFrmType != 89)) &amp;&amp; ((regEnd) != 0))
    {
        sqlite3VdbeAddOp3(v, (int)(107), (int)(regStart), (int)(regEnd), (int)(regStart));
    }

    if (pMWin.eStart != 90)
    {
        sqlite3VdbeAddOp2(v, (int)(38), (int)(s.start.csr), (int)(1));
    }

    sqlite3VdbeAddOp2(v, (int)(38), (int)(s.current.csr), (int)(1));
    sqlite3VdbeAddOp2(v, (int)(38), (int)(s.end.csr), (int)(1));
    if (((regPeer) != 0) &amp;&amp; ((pOrderBy) != null))
    {
        sqlite3VdbeAddOp3(v, (int)(79), (int)(regNewPeer), (int)(regPeer), (int)(pOrderBy.nExpr - 1));
        sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.start.reg), (int)(pOrderBy.nExpr - 1));
        sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.current.reg), (int)(pOrderBy.nExpr - 1));
        sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.end.reg), (int)(pOrderBy.nExpr - 1));
    }

    sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblWhereEnd));
    sqlite3VdbeJumpHere(v, (int)(addrNe));
    if ((regPeer) != 0)
    {
        windowIfNewPeer(pParse, pOrderBy, (int)(regNewPeer), (int)(regPeer), (int)(lblWhereEnd));
    }

    if ((pMWin.eStart) == (86))
    {
        windowCodeOp(s, (int)(3), (int)(0), (int)(0));
        if (pMWin.eEnd != 90)
        {
            if ((pMWin.eFrmType) == (89))
            {
                int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
                int addrNext = (int)(sqlite3VdbeCurrentAddr(v));
                windowCodeRangeTest(s, (int)(57), (int)(s.current.csr), (int)(regEnd), (int)(s.end.csr), (int)(lbl));
                windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
                windowCodeOp(s, (int)(1), (int)(0), (int)(0));
                sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrNext));
                sqlite3VdbeResolveLabel(v, (int)(lbl));
            }
            else
            {
                windowCodeOp(s, (int)(1), (int)(regEnd), (int)(0));
                windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
            }
        }
    }
    else if ((pMWin.eEnd) == (88))
    {
        int bRPS = (int)((((pMWin.eStart) == (88)) &amp;&amp; ((pMWin.eFrmType) == (89))) ? 1 : 0);
        windowCodeOp(s, (int)(3), (int)(regEnd), (int)(0));
        if ((bRPS) != 0)
            windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
        windowCodeOp(s, (int)(1), (int)(0), (int)(0));
        if (bRPS == 0)
            windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
    }
    else
    {
        int addr = (int)(0);
        windowCodeOp(s, (int)(3), (int)(0), (int)(0));
        if (pMWin.eEnd != 90)
        {
            if ((pMWin.eFrmType) == (89))
            {
                int lbl = (int)(0);
                addr = (int)(sqlite3VdbeCurrentAddr(v));
                if ((regEnd) != 0)
                {
                    lbl = (int)(sqlite3VdbeMakeLabel(pParse));
                    windowCodeRangeTest(s, (int)(57), (int)(s.current.csr), (int)(regEnd), (int)(s.end.csr), (int)(lbl));
                }

                windowCodeOp(s, (int)(1), (int)(0), (int)(0));
                windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
                if ((regEnd) != 0)
                {
                    sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addr));
                    sqlite3VdbeResolveLabel(v, (int)(lbl));
                }
            }
            else
            {
                if ((regEnd) != 0)
                {
                    addr = (int)(sqlite3VdbeAddOp3(v, (int)(49), (int)(regEnd), (int)(0), (int)(1)));
                }

                windowCodeOp(s, (int)(1), (int)(0), (int)(0));
                windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
                if ((regEnd) != 0)
                    sqlite3VdbeJumpHere(v, (int)(addr));
            }
        }
    }

    sqlite3VdbeResolveLabel(v, (int)(lblWhereEnd));
    sqlite3WhereEnd(pWInfo);
    if ((pMWin.pPartition) != null)
    {
        addrInteger = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regFlushPart)));
        sqlite3VdbeJumpHere(v, (int)(addrGosubFlush));
    }

    s.regRowid = (int)(0);
    addrEmpty = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(csrWrite)));
    if ((pMWin.eEnd) == (88))
    {
        int bRPS = (int)((((pMWin.eStart) == (88)) &amp;&amp; ((pMWin.eFrmType) == (89))) ? 1 : 0);
        windowCodeOp(s, (int)(3), (int)(regEnd), (int)(0));
        if ((bRPS) != 0)
            windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
        windowCodeOp(s, (int)(1), (int)(0), (int)(0));
    }
    else if ((pMWin.eStart) == (86))
    {
        int addrStart = 0;
        int addrBreak1 = 0;
        int addrBreak2 = 0;
        int addrBreak3 = 0;
        windowCodeOp(s, (int)(3), (int)(0), (int)(0));
        if ((pMWin.eFrmType) == (89))
        {
            addrStart = (int)(sqlite3VdbeCurrentAddr(v));
            addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(regStart), (int)(1)));
            addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
        }
        else if ((pMWin.eEnd) == (90))
        {
            addrStart = (int)(sqlite3VdbeCurrentAddr(v));
            addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(regStart), (int)(1)));
            addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(0), (int)(1)));
        }
        else
        {
            addrStart = (int)(sqlite3VdbeCurrentAddr(v));
            addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(regEnd), (int)(1)));
            addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(regStart), (int)(1)));
        }

        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
        sqlite3VdbeJumpHere(v, (int)(addrBreak2));
        addrStart = (int)(sqlite3VdbeCurrentAddr(v));
        addrBreak3 = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
        sqlite3VdbeJumpHere(v, (int)(addrBreak1));
        sqlite3VdbeJumpHere(v, (int)(addrBreak3));
    }
    else
    {
        int addrBreak = 0;
        int addrStart = 0;
        windowCodeOp(s, (int)(3), (int)(0), (int)(0));
        addrStart = (int)(sqlite3VdbeCurrentAddr(v));
        addrBreak = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
        windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
        sqlite3VdbeJumpHere(v, (int)(addrBreak));
    }

    sqlite3VdbeJumpHere(v, (int)(addrEmpty));
    sqlite3VdbeAddOp1(v, (int)(145), (int)(s.current.csr));
    if ((pMWin.pPartition) != null)
    {
        if ((pMWin.regStartRowid) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regStartRowid));
            sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pMWin.regEndRowid));
        }

        sqlite3VdbeChangeP1(v, (int)(addrInteger), (int)(sqlite3VdbeCurrentAddr(v)));
        sqlite3VdbeAddOp1(v, (int)(67), (int)(regFlushPart));
    }
}</function>
  <function>public static int sqlite3WindowCompare(Parse pParse, Window p1, Window p2, int bFilter)
{
    int res = 0;
    if (((p1) == (null)) || ((p2) == (null)))
        return (int)(1);
    if (p1.eFrmType != p2.eFrmType)
        return (int)(1);
    if (p1.eStart != p2.eStart)
        return (int)(1);
    if (p1.eEnd != p2.eEnd)
        return (int)(1);
    if (p1.eExclude != p2.eExclude)
        return (int)(1);
    if ((sqlite3ExprCompare(pParse, p1.pStart, p2.pStart, (int)(-1))) != 0)
        return (int)(1);
    if ((sqlite3ExprCompare(pParse, p1.pEnd, p2.pEnd, (int)(-1))) != 0)
        return (int)(1);
    if ((res = (int)(sqlite3ExprListCompare(p1.pPartition, p2.pPartition, (int)(-1)))))
    {
        return (int)(res);
    }

    if ((res = (int)(sqlite3ExprListCompare(p1.pOrderBy, p2.pOrderBy, (int)(-1)))))
    {
        return (int)(res);
    }

    if ((bFilter) != 0)
    {
        if ((res = (int)(sqlite3ExprCompare(pParse, p1.pFilter, p2.pFilter, (int)(-1)))))
        {
            return (int)(res);
        }
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3WindowDelete(sqlite3 db, Window p)
{
    if ((p) != null)
    {
        sqlite3WindowUnlinkFromSelect(p);
        sqlite3ExprDelete(db, p.pFilter);
        sqlite3ExprListDelete(db, p.pPartition);
        sqlite3ExprListDelete(db, p.pOrderBy);
        sqlite3ExprDelete(db, p.pEnd);
        sqlite3ExprDelete(db, p.pStart);
        sqlite3DbFree(db, p.zName);
        sqlite3DbFree(db, p.zBase);
        sqlite3DbFree(db, p);
    }
}</function>
  <function>public static Window sqlite3WindowDup(sqlite3 db, Expr pOwner, Window p)
{
    Window pNew = null;
    if ((p) != null)
    {
        pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Window)));
        if ((pNew) != null)
        {
            pNew.zName = sqlite3DbStrDup(db, p.zName);
            pNew.zBase = sqlite3DbStrDup(db, p.zBase);
            pNew.pFilter = sqlite3ExprDup(db, p.pFilter, (int)(0));
            pNew.pFunc = p.pFunc;
            pNew.pPartition = sqlite3ExprListDup(db, p.pPartition, (int)(0));
            pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, (int)(0));
            pNew.eFrmType = (byte)(p.eFrmType);
            pNew.eEnd = (byte)(p.eEnd);
            pNew.eStart = (byte)(p.eStart);
            pNew.eExclude = (byte)(p.eExclude);
            pNew.regResult = (int)(p.regResult);
            pNew.regAccum = (int)(p.regAccum);
            pNew.iArgCol = (int)(p.iArgCol);
            pNew.iEphCsr = (int)(p.iEphCsr);
            pNew.bExprArgs = (byte)(p.bExprArgs);
            pNew.pStart = sqlite3ExprDup(db, p.pStart, (int)(0));
            pNew.pEnd = sqlite3ExprDup(db, p.pEnd, (int)(0));
            pNew.pOwner = pOwner;
            pNew.bImplicitFrame = (byte)(p.bImplicitFrame);
        }
    }

    return pNew;
}</function>
  <function>public static int sqlite3WindowExtraAggFuncDepth(Walker pWalker, Expr pExpr)
{
    if (((pExpr.op) == (168)) &amp;&amp; ((pExpr.op2) &gt;= (pWalker.walkerDepth)))
    {
        pExpr.op2++;
    }

    return (int)(0);
}</function>
  <function>public static void sqlite3WindowFunctions()
{
    sqlite3InsertBuiltinFuncs(sqlite3WindowFunctions_aWindowFuncs, ((int)(15 * sizeof(FuncDef) / sizeof(FuncDef))));
}</function>
  <function>public static void sqlite3WindowLink(Select pSel, Window pWin)
{
    if ((pSel) != null)
    {
        if (((null) == (pSel.pWin)) || ((0) == (sqlite3WindowCompare(null, pSel.pWin, pWin, (int)(0)))))
        {
            pWin.pNextWin = pSel.pWin;
            if ((pSel.pWin) != null)
            {
                pSel.pWin.ppThis = pWin.pNextWin;
            }

            pSel.pWin = pWin;
            pWin.ppThis = pSel.pWin;
        }
        else
        {
            if ((sqlite3ExprListCompare(pWin.pPartition, pSel.pWin.pPartition, (int)(-1))) != 0)
            {
                pSel.selFlags |= (uint)(0x2000000);
            }
        }
    }
}</function>
  <function>public static void sqlite3WindowListDelete(sqlite3 db, Window p)
{
    while ((p) != null)
    {
        Window pNext = p.pNextWin;
        sqlite3WindowDelete(db, p);
        p = pNext;
    }
}</function>
  <function>public static Window sqlite3WindowListDup(sqlite3 db, Window p)
{
    Window pWin;
    Window pRet = null;
    Window pp = pRet;
    for (pWin = p; pWin; pWin = pWin.pNextWin)
    {
        pp = sqlite3WindowDup(db, null, pWin);
        if ((pp) == (null))
            break;
        pp = ((pp).pNextWin);
    }

    return pRet;
}</function>
  <function>public static Expr sqlite3WindowOffsetExpr(Parse pParse, Expr pExpr)
{
    if ((0) == (sqlite3ExprIsConstant(pExpr)))
    {
        if (((pParse.eParseMode) &gt;= (2)))
            sqlite3RenameExprUnmap(pParse, pExpr);
        sqlite3ExprDelete(pParse.db, pExpr);
        pExpr = sqlite3ExprAlloc(pParse.db, (int)(121), null, (int)(0));
    }

    return pExpr;
}</function>
  <function>public static int sqlite3WindowRewrite(Parse pParse, Select p)
{
    int rc = (int)(0);
    if (((((p.pWin) != null) &amp;&amp; ((p.pPrior) == (null))) &amp;&amp; ((p.selFlags &amp; 0x0100000) == (0))) &amp;&amp; ((!((pParse.eParseMode) &gt;= (2))) != 0))
    {
        Vdbe v = sqlite3GetVdbe(pParse);
        sqlite3 db = pParse.db;
        Select pSub = null;
        SrcList pSrc = p.pSrc;
        Expr pWhere = p.pWhere;
        ExprList pGroupBy = p.pGroupBy;
        Expr pHaving = p.pHaving;
        ExprList pSort = null;
        ExprList pSublist = null;
        Window pMWin = p.pWin;
        Window pWin;
        Table pTab;
        Walker w = new Walker();
        uint selFlags = (uint)(p.selFlags);
        pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
        if ((pTab) == (null))
        {
            return (int)(sqlite3ErrorToParser(db, (int)(7)));
        }

        sqlite3AggInfoPersistWalkerInit(w, pParse);
        sqlite3WalkSelect(w, p);
        if ((p.selFlags &amp; 0x0000008) == (0))
        {
            w.xExprCallback = disallowAggregatesInOrderByCb;
            w.xSelectCallback = null;
            sqlite3WalkExprList(w, p.pOrderBy);
        }

        p.pSrc = null;
        p.pWhere = null;
        p.pGroupBy = null;
        p.pHaving = null;
        p.selFlags &amp;= (uint)(~0x0000008);
        p.selFlags |= (uint)(0x0100000);
        pSort = exprListAppendList(pParse, null, pMWin.pPartition, (int)(1));
        pSort = exprListAppendList(pParse, pSort, pMWin.pOrderBy, (int)(1));
        if ((((pSort) != null) &amp;&amp; ((p.pOrderBy) != null)) &amp;&amp; ((p.pOrderBy.nExpr) &lt;= (pSort.nExpr)))
        {
            int nSave = (int)(pSort.nExpr);
            pSort.nExpr = (int)(p.pOrderBy.nExpr);
            if ((sqlite3ExprListCompare(pSort, p.pOrderBy, (int)(-1))) == (0))
            {
                sqlite3ExprListDelete(db, p.pOrderBy);
                p.pOrderBy = null;
            }

            pSort.nExpr = (int)(nSave);
        }

        pMWin.iEphCsr = (int)(pParse.nTab++);
        pParse.nTab += (int)(3);
        selectWindowRewriteEList(pParse, pMWin, pSrc, p.pEList, pTab, pSublist);
        selectWindowRewriteEList(pParse, pMWin, pSrc, p.pOrderBy, pTab, pSublist);
        pMWin.nBufferCol = (int)(pSublist ? pSublist.nExpr : 0);
        pSublist = exprListAppendList(pParse, pSublist, pMWin.pPartition, (int)(0));
        pSublist = exprListAppendList(pParse, pSublist, pMWin.pOrderBy, (int)(0));
        for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
        {
            ExprList pArgs;
            pArgs = pWin.pOwner.x.pList;
            if ((pWin.pFunc.funcFlags &amp; 0x00100000) != 0)
            {
                selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, pSublist);
                pWin.iArgCol = (int)(pSublist ? pSublist.nExpr : 0);
                pWin.bExprArgs = (byte)(1);
            }
            else
            {
                pWin.iArgCol = (int)(pSublist ? pSublist.nExpr : 0);
                pSublist = exprListAppendList(pParse, pSublist, pArgs, (int)(0));
            }

            if ((pWin.pFilter) != null)
            {
                Expr pFilter = sqlite3ExprDup(db, pWin.pFilter, (int)(0));
                pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
            }

            pWin.regAccum = (int)(++pParse.nMem);
            pWin.regResult = (int)(++pParse.nMem);
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
        }

        if ((pSublist) == (null))
        {
            pSublist = sqlite3ExprListAppend(pParse, null, sqlite3Expr(db, (int)(155), "0"));
        }

        pSub = sqlite3SelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, (uint)(0), null);
        p.pSrc = sqlite3SrcListAppend(pParse, null, null, null);
        if ((p.pSrc) != null)
        {
            Table pTab2;
            p.pSrc.a[0].pSelect = pSub;
            sqlite3SrcListAssignCursors(pParse, p.pSrc);
            pSub.selFlags |= (uint)(0x0000040 | 0x8000000);
            pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, (sbyte)(0x40));
            pSub.selFlags |= (uint)(selFlags &amp; 0x0000008);
            if ((pTab2) == (null))
            {
                rc = (int)(7);
            }
            else
            {
                CRuntime.memcpy(pTab, pTab2, (ulong)(sizeof(Table)));
                pTab.tabFlags |= (uint)(0x00004000);
                p.pSrc.a[0].pTab = pTab;
                pTab = pTab2;
                CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
                w.xExprCallback = sqlite3WindowExtraAggFuncDepth;
                w.xSelectCallback = sqlite3WalkerDepthIncrease;
                w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
                sqlite3WalkSelect(w, pSub);
            }
        }
        else
        {
            sqlite3SelectDelete(db, pSub);
        }

        if ((db.mallocFailed) != 0)
            rc = (int)(7);
        sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pTab);
    }

    return (int)(rc);
}</function>
  <function>public static void sqlite3WindowUnlinkFromSelect(Window p)
{
    if ((p.ppThis) != null)
    {
        p.ppThis = p.pNextWin;
        if ((p.pNextWin) != null)
            p.pNextWin.ppThis = p.ppThis;
        p.ppThis = null;
    }
}</function>
  <function>public static void sqlite3WindowUpdate(Parse pParse, Window pList, Window pWin, FuncDef pFunc)
{
    if (((pWin.zName) != null) &amp;&amp; ((pWin.eFrmType) == (0)))
    {
        Window p = windowFind(pParse, pList, pWin.zName);
        if ((p) == (null))
            return;
        pWin.pPartition = sqlite3ExprListDup(pParse.db, p.pPartition, (int)(0));
        pWin.pOrderBy = sqlite3ExprListDup(pParse.db, p.pOrderBy, (int)(0));
        pWin.pStart = sqlite3ExprDup(pParse.db, p.pStart, (int)(0));
        pWin.pEnd = sqlite3ExprDup(pParse.db, p.pEnd, (int)(0));
        pWin.eStart = (byte)(p.eStart);
        pWin.eEnd = (byte)(p.eEnd);
        pWin.eFrmType = (byte)(p.eFrmType);
        pWin.eExclude = (byte)(p.eExclude);
    }
    else
    {
        sqlite3WindowChain(pParse, pWin, pList);
    }

    if ((((pWin.eFrmType) == (89)) &amp;&amp; (((pWin.pStart) != null) || ((pWin.pEnd) != null))) &amp;&amp; (((pWin.pOrderBy) == (null)) || (pWin.pOrderBy.nExpr != 1)))
    {
        sqlite3ErrorMsg(pParse, "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression");
    }
    else if ((pFunc.funcFlags &amp; 0x00010000) != 0)
    {
        sqlite3 db = pParse.db;
        if ((pWin.pFilter) != null)
        {
            sqlite3ErrorMsg(pParse, "FILTER clause may only be used with aggregate window functions");
        }
        else
        {
            WindowUpdate* aUp = stackalloc WindowUpdate[]{{row_numberName, 76, 90, 85}, {dense_rankName, 89, 90, 85}, {rankName, 89, 90, 85}, {percent_rankName, 92, 85, 90}, {cume_distName, 92, 86, 90}, {ntileName, 76, 85, 90}, {leadName, 76, 90, 90}, {lagName, 76, 90, 85}};
            int i = 0;
            for (i = (int)(0); (i) &lt; ((int)(8 * sizeof(WindowUpdate) / sizeof(WindowUpdate))); i++)
            {
                if ((pFunc.zName) == (aUp[i].zFunc))
                {
                    sqlite3ExprDelete(db, pWin.pStart);
                    sqlite3ExprDelete(db, pWin.pEnd);
                    pWin.pEnd = pWin.pStart = null;
                    pWin.eFrmType = (byte)(aUp[i].eFrmType);
                    pWin.eStart = (byte)(aUp[i].eStart);
                    pWin.eEnd = (byte)(aUp[i].eEnd);
                    pWin.eExclude = (byte)(0);
                    if ((pWin.eStart) == (86))
                    {
                        pWin.pStart = sqlite3Expr(db, (int)(155), "1");
                    }

                    break;
                }
            }
        }
    }

    pWin.pFunc = pFunc;
}</function>
  <function>public static With sqlite3WithAdd(Parse pParse, With pWith, Cte pCte)
{
    sqlite3 db = pParse.db;
    With pNew;
    sbyte* zName;
    if ((pCte) == (null))
    {
        return pWith;
    }

    zName = pCte.zName;
    if (((zName) != null) &amp;&amp; ((pWith) != null))
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pWith.nCte); i++)
        {
            if ((sqlite3StrICmp(zName, pWith.a[i].zName)) == (0))
            {
                sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
            }
        }
    }

    if ((pWith) != null)
    {
        long nByte = (long)(sizeof(With) + (sizeof(Cte) * pWith.nCte));
        pNew = sqlite3DbRealloc(db, pWith, (ulong)(nByte));
    }
    else
    {
        pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(With)));
    }

    if ((db.mallocFailed) != 0)
    {
        sqlite3CteDelete(db, pCte);
        pNew = pWith;
    }
    else
    {
        pNew.a[pNew.nCte++] = (Cte)(pCte);
        sqlite3DbFree(db, pCte);
    }

    return pNew;
}</function>
  <function>public static void sqlite3WithDelete(sqlite3 db, With pWith)
{
    if ((pWith) != null)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pWith.nCte); i++)
        {
            cteClear(db, pWith.a[i]);
        }

        sqlite3DbFree(db, pWith);
    }
}</function>
  <function>public static With sqlite3WithDup(sqlite3 db, With p)
{
    With pRet = null;
    if ((p) != null)
    {
        long nByte = (long)(sizeof(With) + sizeof(Cte) * (p.nCte - 1));
        pRet = sqlite3DbMallocZero(db, (ulong)(nByte));
        if ((pRet) != null)
        {
            int i = 0;
            pRet.nCte = (int)(p.nCte);
            for (i = (int)(0); (i) &lt; (p.nCte); i++)
            {
                pRet.a[i].pSelect = sqlite3SelectDup(db, p.a[i].pSelect, (int)(0));
                pRet.a[i].pCols = sqlite3ExprListDup(db, p.a[i].pCols, (int)(0));
                pRet.a[i].zName = sqlite3DbStrDup(db, p.a[i].zName);
            }
        }
    }

    return pRet;
}</function>
  <function>public static With sqlite3WithPush(Parse pParse, With pWith, byte bFree)
{
    if ((pWith) != null)
    {
        if ((bFree) != 0)
        {
            pWith = (With)(sqlite3ParserAddCleanup(pParse, sqlite3WithDelete, pWith));
            if ((pWith) == (null))
                return null;
        }

        if ((pParse.nErr) == (0))
        {
            pWith.pOuter = pParse.pWith;
            pParse.pWith = pWith;
        }
    }

    return pWith;
}</function>
  <function>public static int sqlite3WritableSchema(sqlite3 db)
{
    return ((db.flags &amp; (0x00000001 | 0x10000000)) == (0x00000001) ? 1 : 0);
}</function>
  <function>public static void sqliteAuthBadReturnCode(Parse pParse)
{
    sqlite3ErrorMsg(pParse, "authorizer malfunction");
    pParse.rc = (int)(1);
}</function>
  <function>public static int sqliteDefaultBusyCallback(void* ptr, int count)
{
    sqlite3 db = (sqlite3)(ptr);
    int tmout = (int)(db.busyTimeout);
    int delay = 0; int  prior  =  0 ; 
    if ((count) &lt; ((int)(12 * sizeof(byte) / sizeof(byte))))
    {
        delay = (int)(sqliteDefaultBusyCallback_delays[count]);
        prior = (int)(sqliteDefaultBusyCallback_totals[count]);
    }
    else
    {
        delay = (int)(sqliteDefaultBusyCallback_delays[((int)(12 * sizeof(byte) / sizeof(byte))) - 1]);
        prior = (int)(sqliteDefaultBusyCallback_totals[((int)(12 * sizeof(byte) / sizeof(byte))) - 1] + delay * (count - (((int)(12 * sizeof(byte) / sizeof(byte))) - 1)));
    }

    if ((prior + delay) &gt; (tmout))
    {
        delay = (int)(tmout - prior);
        if ((delay) &lt;= (0))
            return (int)(0);
    }

    sqlite3OsSleep(db.pVfs, (int)(delay * 1000));
    return (int)(1);
}</function>
  <function>public static int sqliteProcessJoin(Parse pParse, Select p)
{
    SrcList pSrc;
    int i = 0; int  j  =  0 ; 
    SrcItem pLeft;
    SrcItem pRight;
    pSrc = p.pSrc;
    pLeft = pSrc.a[0];
    pRight = pLeft[1];
    for (i = (int)(0); (i) &lt; (pSrc.nSrc - 1); i++, pRight++, pLeft++)
    {
        Table pRightTab = pRight.pTab;
        int isOuter = 0;
        if ((((pLeft.pTab) == (null)) || ((pRightTab) == (null))))
            continue;
        isOuter = (int)((pRight.fg.jointype &amp; 0x0020) != 0);
        if ((pRight.fg.jointype &amp; 0x0004) != 0)
        {
            if (((pRight.pOn) != null) || ((pRight.pUsing) != null))
            {
                sqlite3ErrorMsg(pParse, "a NATURAL join may not have an ON or USING clause", (int)(0));
                return (int)(1);
            }

            for (j = (int)(0); (j) &lt; (pRightTab.nCol); j++)
            {
                sbyte* zName;
                int iLeft = 0;
                int iLeftCol = 0;
                if ((((&amp;pRightTab.aCol[j])-&gt;colFlags &amp; 0x0002) != 0))
                    continue;
                zName = pRightTab.aCol[j].zCnName;
                if ((tableAndColumnIndex(pSrc, (int)(i + 1), zName, &amp;iLeft, &amp;iLeftCol, (int)(1))) != 0)
                {
                    addWhereTerm(pParse, pSrc, (int)(iLeft), (int)(iLeftCol), (int)(i + 1), (int)(j), (int)(isOuter), p.pWhere);
                }
            }
        }

        if (((pRight.pOn) != null) &amp;&amp; ((pRight.pUsing) != null))
        {
            sqlite3ErrorMsg(pParse, "cannot have both ON and USING clauses in the same join");
            return (int)(1);
        }

        if ((pRight.pOn) != null)
        {
            if ((isOuter) != 0)
                sqlite3SetJoinExpr(pRight.pOn, (int)(pRight.iCursor));
            p.pWhere = sqlite3ExprAnd(pParse, p.pWhere, pRight.pOn);
            pRight.pOn = null;
        }

        if ((pRight.pUsing) != null)
        {
            IdList* pList = pRight.pUsing;
            for (j = (int)(0); (j) &lt; (pList-&gt;nId); j++)
            {
                sbyte* zName;
                int iLeft = 0;
                int iLeftCol = 0;
                int iRightCol = 0;
                zName = pList-&gt;a[j].zName;
                iRightCol = (int)(sqlite3ColumnIndex(pRightTab, zName));
                if (((iRightCol) &lt; (0)) || (tableAndColumnIndex(pSrc, (int)(i + 1), zName, &amp;iLeft, &amp;iLeftCol, (int)(0)) == 0))
                {
                    sqlite3ErrorMsg(pParse, "cannot join using column %s - column not present in both tables", zName);
                    return (int)(1);
                }

                addWhereTerm(pParse, pSrc, (int)(iLeft), (int)(iLeftCol), (int)(i + 1), (int)(iRightCol), (int)(isOuter), p.pWhere);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static void sqliteViewResetAll(sqlite3 db, int idx)
{
    HashElem* i;
    if (!(((db).aDb[idx].pSchema.schemaFlags &amp; (0x0002)) == (0x0002)))
        return;
    for (i = ((&amp;db.aDb[idx].pSchema.tblHash)-&gt;first); i; i = ((i)-&gt;next))
    {
        Table pTab = ((i)-&gt;data);
        if ((((pTab).eTabType) == (2)))
        {
            sqlite3DeleteColumnNames(db, pTab);
        }
    }

    (db).aDb[idx].pSchema.schemaFlags &amp;= (ushort)(~(0x0002));
}</function>
  <function>public static void srclistRenumberCursors(Parse pParse, int* aCsrMap, SrcList pSrc, int iExcept)
{
    int i = 0;
    SrcItem pItem;
    for (i = (int)(0), pItem = pSrc.a; (i) &lt; (pSrc.nSrc); i++, pItem++)
    {
        if (i != iExcept)
        {
            Select p;
            if ((pItem.fg.isRecursive == 0) || ((aCsrMap[pItem.iCursor + 1]) == (0)))
            {
                aCsrMap[pItem.iCursor + 1] = (int)(pParse.nTab++);
            }

            pItem.iCursor = (int)(aCsrMap[pItem.iCursor + 1]);
            for (p = pItem.pSelect; p; p = p.pPrior)
            {
                srclistRenumberCursors(pParse, aCsrMap, p.pSrc, (int)(-1));
            }
        }
    }
}</function>
  <function>public static void statAccumDestructor(void* pOld)
{
    StatAccum p = (StatAccum)(pOld);
    sqlite3DbFree(p.db, p);
}</function>
  <function>public static void statGet(sqlite3_context context, int argc, sqlite3_value argv)
{
    StatAccum p = (StatAccum)(sqlite3_value_blob(argv[0]));
    {
        sqlite3_str sStat = new sqlite3_str();
        int i = 0;
        sqlite3StrAccumInit(sStat, null, null, (int)(0), (int)((p.nKeyCol + 1) * 100));
        sqlite3_str_appendf(sStat, "%llu", (ulong)((p.nSkipAhead) != 0 ? (ulong)(p.nEst) : (ulong)(p.nRow)));
        for (i = (int)(0); (i) &lt; (p.nKeyCol); i++)
        {
            ulong nDistinct = (ulong)(p.current.anDLt[i] + 1);
            ulong iVal = (ulong)((p.nRow + nDistinct - 1) / nDistinct);
            sqlite3_str_appendf(sStat, " %llu", (ulong)(iVal));
        }

        sqlite3ResultStrAccum(context, sStat);
    }
}</function>
  <function>public static void statInit(sqlite3_context context, int argc, sqlite3_value argv)
{
    StatAccum p;
    int nCol = 0;
    int nKeyCol = 0;
    int nColUp = 0;
    int n = 0;
    sqlite3 db = sqlite3_context_db_handle(context);
    nCol = (int)(sqlite3_value_int(argv[0]));
    nColUp = (int)((sizeof(uint)) &lt; (8) ? (nCol + 1) &amp; ~1 : nCol);
    nKeyCol = (int)(sqlite3_value_int(argv[1]));
    n = (int)(sizeof(StatAccum) + sizeof(uint) * nColUp + sizeof(uint) * nColUp);
    p = sqlite3DbMallocZero(db, (ulong)(n));
    if ((p) == (null))
    {
        sqlite3_result_error_nomem(context);
        return;
    }

    p.db = db;
    p.nEst = (uint)(sqlite3_value_int64(argv[2]));
    p.nRow = (uint)(0);
    p.nLimit = (int)(sqlite3_value_int64(argv[3]));
    p.nCol = (int)(nCol);
    p.nKeyCol = (int)(nKeyCol);
    p.nSkipAhead = (byte)(0);
    p.current.anDLt = (uint*)(p[1]);
    p.current.anEq = &amp;p.current.anDLt[nColUp];
    sqlite3_result_blob(context, p, (int)(sizeof(StatAccum)), statAccumDestructor);
}</function>
  <function>public static void statPush(sqlite3_context context, int argc, sqlite3_value argv)
{
    int i = 0;
    StatAccum p = (StatAccum)(sqlite3_value_blob(argv[0]));
    int iChng = (int)(sqlite3_value_int(argv[1]));
    if ((p.nRow) == (0))
    {
        for (i = (int)(0); (i) &lt; (p.nCol); i++)
        {
            p.current.anEq[i] = (uint)(1);
        }
    }
    else
    {
        for (i = (int)(0); (i) &lt; (iChng); i++)
        {
            p.current.anEq[i]++;
        }

        for (i = (int)(iChng); (i) &lt; (p.nCol); i++)
        {
            p.current.anDLt[i]++;
            p.current.anEq[i] = (uint)(1);
        }
    }

    p.nRow++;
    if (((p.nLimit) != 0) &amp;&amp; ((p.nRow) &gt; ((uint)(p.nLimit) * (p.nSkipAhead + 1))))
    {
        p.nSkipAhead++;
        sqlite3_result_int(context, ((p.current.anDLt[0]) &gt; (0) ? 1 : 0));
    }
}</function>
  <function>public static sbyte* strAccumFinishRealloc(sqlite3_str p)
{
    sbyte* zText;
    zText = sqlite3DbMallocRaw(p.db, (ulong)(p.nChar + 1));
    if ((zText) != null)
    {
        CRuntime.memcpy(zText, p.zText, (ulong)(p.nChar + 1));
        p.printfFlags |= (byte)(0x04);
    }
    else
    {
        sqlite3StrAccumSetError(p, (byte)(7));
    }

    p.zText = zText;
    return zText;
}</function>
  <function>public static void strftimeFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    DateTime x = new DateTime();
    ulong i = 0; ulong  j  =  0 ; 
    sqlite3 db;
    sbyte* zFmt;
    sqlite3_str sRes = new sqlite3_str();
    if ((argc) == (0))
        return;
    zFmt = (sbyte*)(sqlite3_value_text(argv[0]));
    if (((zFmt) == (null)) || ((isDate(context, (int)(argc - 1), argv[1], &amp;x)) != 0))
        return;
    db = sqlite3_context_db_handle(context);
    sqlite3StrAccumInit(sRes, null, null, (int)(0), (int)(db.aLimit[0]));
    computeJD(&amp;x);
    computeYMD_HMS(&amp;x);
    for (i = (ulong)(j = (ulong)(0)); zFmt[i]; i++)
    {
        if (zFmt[i] != 37)
            continue;
        if ((j) &lt; (i))
            sqlite3_str_append(sRes, zFmt + j, (int)(i - j));
        i++;
        j = (ulong)(i + 1);
        switch (zFmt[i])
        {
            case 100:
            {
                sqlite3_str_appendf(sRes, "%02d", (int)(x.D));
                break;
            }

            case 102:
            {
                double s = (double)(x.s);
                if ((s) &gt; (59.999))
                    s = (double)(59.999);
                sqlite3_str_appendf(sRes, "%06.3f", (double)(s));
                break;
            }

            case 72:
            {
                sqlite3_str_appendf(sRes, "%02d", (int)(x.h));
                break;
            }

            case 87:
            case 106:
            {
                int nDay = 0;
                DateTime y = (DateTime)(x);
                y.validJD = (sbyte)(0);
                y.M = (int)(1);
                y.D = (int)(1);
                computeJD(&amp;y);
                nDay = ((int)((x.iJD - y.iJD + 43200000) / 86400000));
                if ((zFmt[i]) == (87))
                {
                    int wd = 0;
                    wd = ((int)(((x.iJD + 43200000) / 86400000) % 7));
                    sqlite3_str_appendf(sRes, "%02d", (int)((nDay + 7 - wd) / 7));
                }
                else
                {
                    sqlite3_str_appendf(sRes, "%03d", (int)(nDay + 1));
                }

                break;
            }

            case 74:
            {
                sqlite3_str_appendf(sRes, "%.16g", (double)(x.iJD / 86400000.0));
                break;
            }

            case 109:
            {
                sqlite3_str_appendf(sRes, "%02d", (int)(x.M));
                break;
            }

            case 77:
            {
                sqlite3_str_appendf(sRes, "%02d", (int)(x.m));
                break;
            }

            case 115:
            {
                long iS = (long)(x.iJD / 1000 - 21086676 * (long)(10000));
                sqlite3_str_appendf(sRes, "%lld", (long)(iS));
                break;
            }

            case 83:
            {
                sqlite3_str_appendf(sRes, "%02d", (int)(x.s));
                break;
            }

            case 119:
            {
                sqlite3_str_appendchar(sRes, (int)(1), (sbyte)((sbyte)(((x.iJD + 129600000) / 86400000) % 7) + 48));
                break;
            }

            case 89:
            {
                sqlite3_str_appendf(sRes, "%04d", (int)(x.Y));
                break;
            }

            case 37:
            {
                sqlite3_str_appendchar(sRes, (int)(1), (sbyte)(37));
                break;
            }

            default:
            {
                sqlite3_str_reset(sRes);
                return;
            }
        }
    }

    if ((j) &lt; (i))
        sqlite3_str_append(sRes, zFmt + j, (int)(i - j));
    sqlite3ResultStrAccum(context, sRes);
}</function>
  <function>public static uint strHash(sbyte* z)
{
    uint h = (uint)(0);
    byte c = 0;
    while ((c = ((byte)(*z++))) != 0)
    {
        h += (uint)(sqlite3UpperToLower[c]);
        h *= (uint)(0x9e3779b1);
    }

    return (uint)(h);
}</function>
  <function>public static int subjournalPage(PgHdr pPg)
{
    int rc = (int)(0);
    Pager pPager = pPg.pPager;
    if (pPager.journalMode != 2)
    {
        rc = (int)(openSubJournal(pPager));
        if ((rc) == (0))
        {
            void* pData = pPg.pData;
            long offset = (long)((long)(pPager.nSubRec) * (4 + pPager.pageSize));
            sbyte* pData2;
            pData2 = pData;
            rc = (int)(write32bits(pPager.sjfd, (long)(offset), (uint)(pPg.pgno)));
            if ((rc) == (0))
            {
                rc = (int)(sqlite3OsWrite(pPager.sjfd, pData2, (int)(pPager.pageSize), (long)(offset + 4)));
            }
        }
    }

    if ((rc) == (0))
    {
        pPager.nSubRec++;
        rc = (int)(addToSavepointBitvecs(pPager, (uint)(pPg.pgno)));
    }

    return (int)(rc);
}</function>
  <function>public static int subjournalPageIfRequired(PgHdr pPg)
{
    if ((subjRequiresPage(pPg)) != 0)
    {
        return (int)(subjournalPage(pPg));
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static int subjRequiresPage(PgHdr pPg)
{
    Pager pPager = pPg.pPager;
    PagerSavepoint* p;
    uint pgno = (uint)(pPg.pgno);
    int i = 0;
    for (i = (int)(0); (i) &lt; (pPager.nSavepoint); i++)
    {
        p = &amp;pPager.aSavepoint[i];
        if (((p-&gt;nOrig) &gt;= (pgno)) &amp;&amp; ((0) == (sqlite3BitvecTestNotNull(p-&gt;pInSavepoint, (uint)(pgno)))))
        {
            for (i = (int)(i + 1); (i) &lt; (pPager.nSavepoint); i++)
            {
                pPager.aSavepoint[i].bTruncateOnRelease = (int)(0);
            }

            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static Expr substExpr(SubstContext pSubst, Expr pExpr)
{
    if ((pExpr) == (null))
        return null;
    if ((((pExpr).flags &amp; (0x000001)) != 0) &amp;&amp; ((pExpr.w.iRightJoinTable) == (pSubst.iTable)))
    {
        pExpr.w.iRightJoinTable = (int)(pSubst.iNewTable);
    }

    if ((((pExpr.op) == (167)) &amp;&amp; ((pExpr.iTable) == (pSubst.iTable))) &amp;&amp; (!(((pExpr).flags &amp; (0x000008)) != 0)))
    {
        {
            Expr pNew;
            Expr pCopy = pSubst.pEList.a[pExpr.iColumn].pExpr;
            Expr ifNullRow = new Expr();
            if ((sqlite3ExprIsVector(pCopy)) != 0)
            {
                sqlite3VectorErrorMsg(pSubst.pParse, pCopy);
            }
            else
            {
                sqlite3 db = pSubst.pParse.db;
                if (((pSubst.isLeftJoin) != 0) &amp;&amp; (pCopy.op != 167))
                {
                    CRuntime.memset(ifNullRow, (int)(0), (ulong)(sizeof(Expr)));
                    ifNullRow.op = (byte)(179);
                    ifNullRow.pLeft = pCopy;
                    ifNullRow.iTable = (int)(pSubst.iNewTable);
                    ifNullRow.flags = (uint)(0x020000);
                    pCopy = ifNullRow;
                }

                pNew = sqlite3ExprDup(db, pCopy, (int)(0));
                if ((db.mallocFailed) != 0)
                {
                    sqlite3ExprDelete(db, pNew);
                    return pExpr;
                }

                if ((pSubst.isLeftJoin) != 0)
                {
                    (pNew).flags |= (uint)(0x100000);
                }

                if ((((pExpr).flags &amp; (0x000001)) != 0))
                {
                    sqlite3SetJoinExpr(pNew, (int)(pExpr.w.iRightJoinTable));
                }

                sqlite3ExprDelete(db, pExpr);
                pExpr = pNew;
                if ((pExpr.op != 167) &amp;&amp; (pExpr.op != 113))
                {
                    CollSeq pColl = sqlite3ExprCollSeq(pSubst.pParse, pExpr);
                    pExpr = sqlite3ExprAddCollateString(pSubst.pParse, pExpr, (pColl ? pColl.zName : "BINARY"));
                }

                (pExpr).flags &amp;= (uint)(~(0x000100));
            }
        }
    }
    else
    {
        if (((pExpr.op) == (179)) &amp;&amp; ((pExpr.iTable) == (pSubst.iTable)))
        {
            pExpr.iTable = (int)(pSubst.iNewTable);
        }

        pExpr.pLeft = substExpr(pSubst, pExpr.pLeft);
        pExpr.pRight = substExpr(pSubst, pExpr.pRight);
        if ((((pExpr).flags &amp; 0x000800) != 0))
        {
            substSelect(pSubst, pExpr.x.pSelect, (int)(1));
        }
        else
        {
            substExprList(pSubst, pExpr.x.pList);
        }

        if ((((pExpr).flags &amp; (0x1000000)) != 0))
        {
            Window pWin = pExpr.y.pWin;
            pWin.pFilter = substExpr(pSubst, pWin.pFilter);
            substExprList(pSubst, pWin.pPartition);
            substExprList(pSubst, pWin.pOrderBy);
        }
    }

    return pExpr;
}</function>
  <function>public static void substExprList(SubstContext pSubst, ExprList pList)
{
    int i = 0;
    if ((pList) == (null))
        return;
    for (i = (int)(0); (i) &lt; (pList.nExpr); i++)
    {
        pList.a[i].pExpr = substExpr(pSubst, pList.a[i].pExpr);
    }
}</function>
  <function>public static void substrFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* z;
    byte* z2;
    int len = 0;
    int p0type = 0;
    long p1 = 0; long  p2  =  0 ; 
    int negP2 = (int)(0);
    if (((sqlite3_value_type(argv[1])) == (5)) || (((argc) == (3)) &amp;&amp; ((sqlite3_value_type(argv[2])) == (5))))
    {
        return;
    }

    p0type = (int)(sqlite3_value_type(argv[0]));
    p1 = (long)(sqlite3_value_int(argv[1]));
    if ((p0type) == (4))
    {
        len = (int)(sqlite3_value_bytes(argv[0]));
        z = sqlite3_value_blob(argv[0]);
        if ((z) == (null))
            return;
    }
    else
    {
        z = sqlite3_value_text(argv[0]);
        if ((z) == (null))
            return;
        len = (int)(0);
        if ((p1) &lt; (0))
        {
            for (z2 = z; *z2; len++)
            {
                {
                    if ((*(z2++)) &gt;= (0xc0))
                    {
                        while ((*z2 &amp; 0xc0) == (0x80))
                        {
                            z2++;
                        }
                    }
                }
            }
        }
    }

    if ((argc) == (3))
    {
        p2 = (long)(sqlite3_value_int(argv[2]));
        if ((p2) &lt; (0))
        {
            p2 = (long)(-p2);
            negP2 = (int)(1);
        }
    }
    else
    {
        p2 = (long)(sqlite3_context_db_handle(context).aLimit[0]);
    }

    if ((p1) &lt; (0))
    {
        p1 += (long)(len);
        if ((p1) &lt; (0))
        {
            p2 += (long)(p1);
            if ((p2) &lt; (0))
                p2 = (long)(0);
            p1 = (long)(0);
        }
    }
    else if ((p1) &gt; (0))
    {
        p1--;
    }
    else if ((p2) &gt; (0))
    {
        p2--;
    }

    if ((negP2) != 0)
    {
        p1 -= (long)(p2);
        if ((p1) &lt; (0))
        {
            p2 += (long)(p1);
            p1 = (long)(0);
        }
    }

    if (p0type != 4)
    {
        while (((*z) != 0) &amp;&amp; ((p1) != 0))
        {
            {
                if ((*(z++)) &gt;= (0xc0))
                {
                    while ((*z &amp; 0xc0) == (0x80))
                    {
                        z++;
                    }
                }
            }

            p1--;
        }

        for (z2 = z; ((*z2) != 0) &amp;&amp; ((p2) != 0); p2--)
        {
            {
                if ((*(z2++)) &gt;= (0xc0))
                {
                    while ((*z2 &amp; 0xc0) == (0x80))
                    {
                        z2++;
                    }
                }
            }
        }

        sqlite3_result_text64(context, (sbyte*)(z), (ulong)(z2 - z), ((Void(Void * ))(-1)), (byte)(1));
    }
    else
    {
        if ((p1 + p2) &gt; (len))
        {
            p2 = (long)(len - p1);
            if ((p2) &lt; (0))
                p2 = (long)(0);
        }

        sqlite3_result_blob64(context, (sbyte*)(&amp;z[p1]), (ulong)(p2), ((Void(Void * ))(-1)));
    }
}</function>
  <function>public static void substSelect(SubstContext pSubst, Select p, int doPrior)
{
    SrcList pSrc;
    SrcItem pItem;
    int i = 0;
    if (p == null)
        return;
    do
    {
        substExprList(pSubst, p.pEList);
        substExprList(pSubst, p.pGroupBy);
        substExprList(pSubst, p.pOrderBy);
        p.pHaving = substExpr(pSubst, p.pHaving);
        p.pWhere = substExpr(pSubst, p.pWhere);
        pSrc = p.pSrc;
        for (i = (int)(pSrc.nSrc), pItem = pSrc.a; (i) &gt; (0); i--, pItem++)
        {
            substSelect(pSubst, pItem.pSelect, (int)(1));
            if ((pItem.fg.isTabFunc) != 0)
            {
                substExprList(pSubst, pItem.u1.pFuncArg);
            }
        }
    }
    while (((doPrior) != 0) &amp;&amp; ((p = p.pPrior) != null));
}</function>
  <function>public static void subtypeFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    sqlite3_result_int(context, (int)(sqlite3_value_subtype(argv[0])));
}</function>
  <function>public static void sumFinalize(sqlite3_context context)
{
    SumCtx* p;
    p = sqlite3_aggregate_context(context, (int)(0));
    if (((p) != null) &amp;&amp; ((p-&gt;cnt) &gt; (0)))
    {
        if ((p-&gt;overflow) != 0)
        {
            sqlite3_result_error(context, "integer overflow", (int)(-1));
        }
        else if ((p-&gt;approx) != 0)
        {
            sqlite3_result_double(context, (double)(p-&gt;rSum));
        }
        else
        {
            sqlite3_result_int64(context, (long)(p-&gt;iSum));
        }
    }
}</function>
  <function>public static void sumInverse(sqlite3_context context, int argc, sqlite3_value argv)
{
    SumCtx* p;
    int type = 0;
    p = sqlite3_aggregate_context(context, (int)(sizeof(SumCtx)));
    type = (int)(sqlite3_value_numeric_type(argv[0]));
    if (((p) != null) &amp;&amp; (type != 5))
    {
        p-&gt;cnt--;
        if (((type) == (1)) &amp;&amp; ((p-&gt;approx) == (0)))
        {
            long v = (long)(sqlite3_value_int64(argv[0]));
            p-&gt;rSum -= (double)(v);
            p-&gt;iSum -= (long)(v);
        }
        else
        {
            p-&gt;rSum -= (double)(sqlite3_value_double(argv[0]));
        }
    }
}</function>
  <function>public static void sumStep(sqlite3_context context, int argc, sqlite3_value argv)
{
    SumCtx* p;
    int type = 0;
    p = sqlite3_aggregate_context(context, (int)(sizeof(SumCtx)));
    type = (int)(sqlite3_value_numeric_type(argv[0]));
    if (((p) != null) &amp;&amp; (type != 5))
    {
        p-&gt;cnt++;
        if ((type) == (1))
        {
            long v = (long)(sqlite3_value_int64(argv[0]));
            p-&gt;rSum += (double)(v);
            if (((p-&gt;approx | p-&gt;overflow) == (0)) &amp;&amp; ((sqlite3AddInt64(&amp;p-&gt;iSum, (long)(v))) != 0))
            {
                p-&gt;approx = (byte)(p-&gt;overflow = (byte)(1));
            }
        }
        else
        {
            p-&gt;rSum += (double)(sqlite3_value_double(argv[0]));
            p-&gt;approx = (byte)(1);
        }
    }
}</function>
  <function>public static int syncJournal(Pager pPager, int newHdr)
{
    int rc = 0;
    rc = (int)(sqlite3PagerExclusiveLock(pPager));
    if (rc != 0)
        return (int)(rc);
    if (pPager.noSync == 0)
    {
        if (((pPager.jfd).pMethods != null) &amp;&amp; (pPager.journalMode != 4))
        {
            int iDc = (int)(sqlite3OsDeviceCharacteristics(pPager.fd));
            if ((0) == (iDc &amp; 0x00000200))
            {
                long iNextHdrOffset = 0;
                byte* aMagic = stackalloc byte[8];
                byte* zHeader = stackalloc byte[12];
                CRuntime.memcpy(zHeader, aJournalMagic, (ulong)(8 * sizeof(byte)));
                sqlite3Put4byte(&amp;zHeader[8 * sizeof(byte)], (uint)(pPager.nRec));
                iNextHdrOffset = (long)(journalHdrOffset(pPager));
                rc = (int)(sqlite3OsRead(pPager.jfd, aMagic, (int)(8), (long)(iNextHdrOffset)));
                if (((rc) == (0)) &amp;&amp; ((0) == (memcmp(aMagic, aJournalMagic, (ulong)(8)))))
                {
                    rc = (int)(sqlite3OsWrite(pPager.jfd, &amp;syncJournal_zerobyte, (int)(1), (long)(iNextHdrOffset)));
                }

                if ((rc != 0) &amp;&amp; (rc != (10 | (2 &lt;&lt; 8))))
                {
                    return (int)(rc);
                }

                if (((pPager.fullSync) != 0) &amp;&amp; ((0) == (iDc &amp; 0x00000400)))
                {
                    rc = (int)(sqlite3OsSync(pPager.jfd, (int)(pPager.syncFlags)));
                    if (rc != 0)
                        return (int)(rc);
                }

                rc = (int)(sqlite3OsWrite(pPager.jfd, zHeader, (int)(12 * sizeof(byte)), (long)(pPager.journalHdr)));
                if (rc != 0)
                    return (int)(rc);
            }

            if ((0) == (iDc &amp; 0x00000400))
            {
                rc = (int)(sqlite3OsSync(pPager.jfd, (int)(pPager.syncFlags | ((pPager.syncFlags) == (0x00003) ? 0x00010 : 0))));
                if (rc != 0)
                    return (int)(rc);
            }

            pPager.journalHdr = (long)(pPager.journalOff);
            if (((newHdr) != 0) &amp;&amp; ((0) == (iDc &amp; 0x00000200)))
            {
                pPager.nRec = (int)(0);
                rc = (int)(writeJournalHdr(pPager));
                if (rc != 0)
                    return (int)(rc);
            }
        }
        else
        {
            pPager.journalHdr = (long)(pPager.journalOff);
        }
    }

    sqlite3PcacheClearSyncFlags(pPager.pPCache);
    pPager.eState = (byte)(4);
    return (int)(0);
}</function>
  <function>public static int synthCollSeq(sqlite3 db, CollSeq pColl)
{
    CollSeq pColl2;
    sbyte* z = pColl.zName;
    int i = 0;
    for (i = (int)(0); (i) &lt; (3); i++)
    {
        pColl2 = sqlite3FindCollSeq(db, (byte)(synthCollSeq_aEnc[i]), z, (int)(0));
        if (pColl2.xCmp != null)
        {
            CRuntime.memcpy(pColl, pColl2, (ulong)(sizeof(CollSeq)));
            pColl.xDel = null;
            return (int)(0);
        }
    }

    return (int)(1);
}</function>
  <function>public static int tabIsReadOnly(Parse pParse, Table pTab)
{
    sqlite3 db;
    if ((((pTab).eTabType) == (1)))
    {
        return ((sqlite3GetVTable(pParse.db, pTab).pMod.pModule.xUpdate) == (null) ? 1 : 0);
    }

    if ((pTab.tabFlags &amp; (0x00000001 | 0x00001000)) == (0))
        return (int)(0);
    db = pParse.db;
    if ((pTab.tabFlags &amp; 0x00000001) != 0)
    {
        return (((sqlite3WritableSchema(db)) == (0)) &amp;&amp; ((pParse.nested) == (0)) ? 1 : 0);
    }

    return (int)(sqlite3ReadOnlyShadowTables(db));
}</function>
  <function>public static int tableAndColumnIndex(SrcList pSrc, int N, sbyte* zCol, int* piTab, int* piCol, int bIgnoreHidden)
{
    int i = 0;
    int iCol = 0;
    for (i = (int)(0); (i) &lt; (N); i++)
    {
        iCol = (int)(sqlite3ColumnIndex(pSrc.a[i].pTab, zCol));
        if (((iCol) &gt;= (0)) &amp;&amp; (((bIgnoreHidden) == (0)) || ((((&amp;pSrc.a[i].pTab.aCol[iCol])-&gt;colFlags &amp; 0x0002) != 0) == (0))))
        {
            if ((piTab) != null)
            {
                *piTab = (int)(i);
                *piCol = (int)(iCol);
            }

            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int tableMayNotBeDropped(sqlite3 db, Table pTab)
{
    if ((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0))
    {
        if ((sqlite3_strnicmp(pTab.zName + 7, "stat", (int)(4))) == (0))
            return (int)(0);
        if ((sqlite3_strnicmp(pTab.zName + 7, "parameters", (int)(10))) == (0))
            return (int)(0);
        return (int)(1);
    }

    if (((pTab.tabFlags &amp; 0x00001000) != 0) &amp;&amp; ((sqlite3ReadOnlyShadowTables(db)) != 0))
    {
        return (int)(1);
    }

    if ((pTab.tabFlags &amp; 0x00008000) != 0)
    {
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static Table tableOfTrigger(Trigger pTrigger)
{
    return sqlite3HashFind(&amp;pTrigger.pTabSchema.tblHash, pTrigger.table);
}</function>
  <function>public static int termCanDriveIndex(WhereTerm pTerm, SrcItem pSrc, ulong notReady)
{
    sbyte aff = 0;
    if (pTerm.leftCursor != pSrc.iCursor)
        return (int)(0);
    if ((pTerm.eOperator &amp; (0x0002 | 0x0080)) == (0))
        return (int)(0);
    if ((((pSrc.fg.jointype &amp; 0x0008) != 0) &amp;&amp; (!(((pTerm.pExpr).flags &amp; (0x000001)) != 0))) &amp;&amp; ((pTerm.eOperator &amp; 0x0080) != 0))
    {
        return (int)(0);
    }

    if ((pTerm.prereqRight &amp; notReady) != 0)
        return (int)(0);
    if ((pTerm.u.x.leftColumn) &lt; (0))
        return (int)(0);
    aff = (sbyte)(pSrc.pTab.aCol[pTerm.u.x.leftColumn].affinity);
    if (sqlite3IndexAffinityOk(pTerm.pExpr, (sbyte)(aff)) == 0)
        return (int)(0);
    return (int)(1);
}</function>
  <function>public static int termIsEquivalence(Parse pParse, Expr pExpr)
{
    sbyte aff1 = 0; sbyte  aff2  =  0 ; 
    CollSeq pColl;
    if (!(((pParse.db).dbOptFlags &amp; (0x00000080)) == (0)))
        return (int)(0);
    if ((pExpr.op != 53) &amp;&amp; (pExpr.op != 45))
        return (int)(0);
    if ((((pExpr).flags &amp; (0x000001)) != 0))
        return (int)(0);
    aff1 = (sbyte)(sqlite3ExprAffinity(pExpr.pLeft));
    aff2 = (sbyte)(sqlite3ExprAffinity(pExpr.pRight));
    if ((aff1 != aff2) &amp;&amp; ((!((aff1) &gt;= (0x43))) || (!((aff2) &gt;= (0x43)))))
    {
        return (int)(0);
    }

    pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);
    if ((sqlite3IsBinary(pColl)) != 0)
        return (int)(1);
    return (int)(sqlite3ExprCollSeqMatch(pParse, pExpr.pLeft, pExpr.pRight));
}</function>
  <function>public static void timeFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    DateTime x = new DateTime();
    if ((isDate(context, (int)(argc), argv, &amp;x)) == (0))
    {
        int s = 0;
        sbyte* zBuf = stackalloc sbyte[16];
        computeHMS(&amp;x);
        zBuf[0] = (sbyte)(48 + (x.h / 10) % 10);
        zBuf[1] = (sbyte)(48 + (x.h) % 10);
        zBuf[2] = (sbyte)(58);
        zBuf[3] = (sbyte)(48 + (x.m / 10) % 10);
        zBuf[4] = (sbyte)(48 + (x.m) % 10);
        zBuf[5] = (sbyte)(58);
        s = ((int)(x.s));
        zBuf[6] = (sbyte)(48 + (s / 10) % 10);
        zBuf[7] = (sbyte)(48 + (s) % 10);
        zBuf[8] = (sbyte)(0);
        sqlite3_result_text(context, zBuf, (int)(8), ((Void(Void * ))(-1)));
    }
}</function>
  <function>public static Expr tokenExpr(Parse pParse, int op, Token t)
{
    Expr p = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Expr) + t.n + 1));
    if ((p) != null)
    {
        p.op = ((byte)(op));
        p.affExpr = (sbyte)(0);
        p.flags = (uint)(0x800000);
        p.iAgg = (short)(-1);
        p.pLeft = p.pRight = null;
        p.pAggInfo = null;
        CRuntime.memset(&amp;p.x, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18074 : 3)) ) )
        ;
        CRuntime.memset(&amp;p.y, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18103 : 3)) ) )
        ;
        p.op2 = (byte)(0);
        p.iTable = (int)(0);
        p.iColumn = (short)(0);
        p.u.zToken = (sbyte*)(p[1]);
        CRuntime.memcpy(p.u.zToken, t.z, (ulong)(t.n));
        p.u.zToken[t.n] = (sbyte)(0);
        p.w.iOfst = ((int)(t.z - pParse.zTail));
        if ((sqlite3CtypeMap[(byte)(p.u.zToken[0])] &amp; 0x80) != 0)
        {
            sqlite3DequoteExpr(p);
        }

        p.nHeight = (int)(1);
        if (((pParse.eParseMode) &gt;= (2)))
        {
            return (Expr)(sqlite3RenameTokenMap(pParse, (void*)(p), &amp;t));
        }
    }

    return p;
}</function>
  <function>public static int toLocaltime(DateTime* p, sqlite3_context pCtx)
{
    long t = 0;
    tm sLocal = new tm();
    int iYearDiff = 0;
    CRuntime.memset(&amp;sLocal, (int)(0), (ulong)(sizeof(tm)));
    computeJD(p);
    if (((p-&gt;iJD) &lt; (2108667600 * (long)(100000))) || ((p-&gt;iJD) &gt; (2130141456 * (long)(100000))))
    {
        DateTime x = (DateTime)(*p);
        computeYMD_HMS(&amp;x);
        iYearDiff = (int)((2000 + x.Y % 4) - x.Y);
        x.Y += (int)(iYearDiff);
        x.validJD = (sbyte)(0);
        computeJD(&amp;x);
        t = (long)(x.iJD / 1000 - 21086676 * (long)(10000));
    }
    else
    {
        iYearDiff = (int)(0);
        t = (long)(p-&gt;iJD / 1000 - 21086676 * (long)(10000));
    }

    if ((osLocaltime(&amp;t, &amp;sLocal)) != 0)
    {
        sqlite3_result_error(pCtx, "local time unavailable", (int)(-1));
        return (int)(1);
    }

    p-&gt;Y = (int)(sLocal.tm_year + 1900 - iYearDiff);
    p-&gt;M = (int)(sLocal.tm_mon + 1);
    p-&gt;D = (int)(sLocal.tm_mday);
    p-&gt;h = (int)(sLocal.tm_hour);
    p-&gt;m = (int)(sLocal.tm_min);
    p-&gt;s = (double)(sLocal.tm_sec + (p-&gt;iJD % 1000) * 0.001);
    p-&gt;validYMD = (sbyte)(1);
    p-&gt;validHMS = (sbyte)(1);
    p-&gt;validJD = (sbyte)(0);
    p-&gt;rawS = (sbyte)(0);
    p-&gt;validTZ = (sbyte)(0);
    p-&gt;isError = (sbyte)(0);
    return (int)(0);
}</function>
  <function>public static void total_changes(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    sqlite3 db = sqlite3_context_db_handle(context);
    sqlite3_result_int64(context, (long)(sqlite3_total_changes64(db)));
}</function>
  <function>public static void totalFinalize(sqlite3_context context)
{
    SumCtx* p;
    p = sqlite3_aggregate_context(context, (int)(0));
    sqlite3_result_double(context, (double)(p ? p-&gt;rSum : (double)(0)));
}</function>
  <function>public static void transferJoinMarkings(Expr pDerived, Expr pBase)
{
    if ((pDerived) != null)
    {
        pDerived.flags |= (uint)(pBase.flags &amp; 0x000001);
        pDerived.w.iRightJoinTable = (int)(pBase.w.iRightJoinTable);
    }
}</function>
  <function>public static void transferParseError(Parse pTo, Parse pFrom)
{
    if ((pTo.nErr) == (0))
    {
        pTo.zErrMsg = pFrom.zErrMsg;
        pTo.nErr = (int)(pFrom.nErr);
        pTo.rc = (int)(pFrom.rc);
    }
    else
    {
        sqlite3DbFree(pFrom.db, pFrom.zErrMsg);
    }
}</function>
  <function>public static void translateColumnToCopy(Parse pParse, int iStart, int iTabCur, int iRegister, int iAutoidxCur)
{
    Vdbe v = pParse.pVdbe;
    VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iStart));
    int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
    if ((pParse.db.mallocFailed) != 0)
        return;
    for (; (iStart) &lt; (iEnd); iStart++, pOp++)
    {
        if (pOp-&gt;p1 != iTabCur)
            continue;
        if ((pOp-&gt;opcode) == (93))
        {
            pOp-&gt;opcode = (byte)(79);
            pOp-&gt;p1 = (int)(pOp-&gt;p2 + iRegister);
            pOp-&gt;p2 = (int)(pOp-&gt;p3);
            pOp-&gt;p3 = (int)(0);
        }
        else if ((pOp-&gt;opcode) == (134))
        {
            pOp-&gt;opcode = (byte)(125);
            pOp-&gt;p1 = (int)(iAutoidxCur);
        }
    }
}</function>
  <function>public static sbyte* triggerSpanDup(sqlite3 db, sbyte* zStart, sbyte* zEnd)
{
    sbyte* z = sqlite3DbSpanDup(db, zStart, zEnd);
    int i = 0;
    if ((z) != null)
        for (i = (int)(0); z[i]; i++)
        {
            if ((sqlite3CtypeMap[(byte)(z[i])] &amp; 0x01) != 0)
                z[i] = (sbyte)(32);
        }

    return z;
}</function>
  <function>public static TriggerStep triggerStepAllocate(Parse pParse, byte op, Token* pName, sbyte* zStart, sbyte* zEnd)
{
    sqlite3 db = pParse.db;
    TriggerStep pTriggerStep;
    if ((pParse.nErr) != 0)
        return null;
    pTriggerStep = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerStep) + pName-&gt;n + 1));
    if ((pTriggerStep) != null)
    {
        sbyte* z = (sbyte*)(pTriggerStep[1]);
        CRuntime.memcpy(z, pName-&gt;z, (ulong)(pName-&gt;n));
        sqlite3Dequote(z);
        pTriggerStep.zTarget = z;
        pTriggerStep.op = (byte)(op);
        pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd);
        if (((pParse.eParseMode) &gt;= (2)))
        {
            sqlite3RenameTokenMap(pParse, pTriggerStep.zTarget, pName);
        }
    }

    return pTriggerStep;
}</function>
  <function>public static void trimFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* zIn;
    byte* zCharSet;
    uint nIn = 0;
    int flags = 0;
    int i = 0;
    uint* aLen = null;
    byte** azChar = null;
    int nChar = 0;
    if ((sqlite3_value_type(argv[0])) == (5))
    {
        return;
    }

    zIn = sqlite3_value_text(argv[0]);
    if ((zIn) == (null))
        return;
    nIn = ((uint)(sqlite3_value_bytes(argv[0])));
    if ((argc) == (1))
    {
        nChar = (int)(1);
        aLen = trimFunc_lenOne;
        azChar = trimFunc_azOne;
        zCharSet = null;
    }
    else if ((zCharSet = sqlite3_value_text(argv[1])) == (null))
    {
        return;
    }
    else
    {
        byte* z;
        for (z = zCharSet, nChar = (int)(0); *z; nChar++)
        {
            {
                if ((*(z++)) &gt;= (0xc0))
                {
                    while ((*z &amp; 0xc0) == (0x80))
                    {
                        z++;
                    }
                }
            }
        }

        if ((nChar) &gt; (0))
        {
            azChar = contextMalloc(context, (long)(((long)(nChar)) * (sizeof(char*) + sizeof(unsigned))));
            if ((azChar) == (null))
            {
                return;
            }

            aLen = (uint*)(&amp;azChar[nChar]);
            for (z = zCharSet, nChar = (int)(0); *z; nChar++)
            {
                azChar[nChar] = z;
                {
                    if ((*(z++)) &gt;= (0xc0))
                    {
                        while ((*z &amp; 0xc0) == (0x80))
                        {
                            z++;
                        }
                    }
                }

                aLen[nChar] = ((uint)(z - azChar[nChar]));
            }
        }
    }

    if ((nChar) &gt; (0))
    {
        flags = ((int)((long)(sqlite3_user_data(context))));
        if ((flags &amp; 1) != 0)
        {
            while ((nIn) &gt; (0))
            {
                uint len = (uint)(0);
                for (i = (int)(0); (i) &lt; (nChar); i++)
                {
                    len = (uint)(aLen[i]);
                    if (((len) &lt;= (nIn)) &amp;&amp; ((memcmp(zIn, azChar[i], (ulong)(len))) == (0)))
                        break;
                }

                if ((i) &gt;= (nChar))
                    break;
                zIn += len;
                nIn -= (uint)(len);
            }
        }

        if ((flags &amp; 2) != 0)
        {
            while ((nIn) &gt; (0))
            {
                uint len = (uint)(0);
                for (i = (int)(0); (i) &lt; (nChar); i++)
                {
                    len = (uint)(aLen[i]);
                    if (((len) &lt;= (nIn)) &amp;&amp; ((memcmp(&amp;zIn[nIn - len], azChar[i], (ulong)(len))) == (0)))
                        break;
                }

                if ((i) &gt;= (nChar))
                    break;
                nIn -= (uint)(len);
            }
        }

        if ((zCharSet) != null)
        {
            sqlite3_free(azChar);
        }
    }

    sqlite3_result_text(context, (sbyte*)(zIn), (int)(nIn), ((Void(Void * ))(-1)));
}</function>
  <function>public static void typeofFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
{
    int i = (int)(sqlite3_value_type(argv[0]) - 1);
    sqlite3_result_text(context, typeofFunc_azType[i], (int)(-1), null);
}</function>
  <function>public static void unicodeFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    byte* z = sqlite3_value_text(argv[0]);
    (void)(argc);
    if (((z) != null) &amp;&amp; ((z[0]) != 0))
        sqlite3_result_int(context, (int)(sqlite3Utf8Read(&amp;z)));
}</function>
  <function>public static void unixepochFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    DateTime x = new DateTime();
    if ((isDate(context, (int)(argc), argv, &amp;x)) == (0))
    {
        computeJD(&amp;x);
        sqlite3_result_int64(context, (long)(x.iJD / 1000 - 21086676 * (long)(10000)));
    }
}</function>
  <function>public static void unlockBtreeIfUnused(BtShared pBt)
{
    if (((pBt.inTransaction) == (0)) &amp;&amp; (pBt.pPage1 != null))
    {
        MemPage pPage1 = pBt.pPage1;
        pBt.pPage1 = null;
        releasePageOne(pPage1);
    }
}</function>
  <function>public static void unlockBtreeMutex(Btree p)
{
    BtShared pBt = p.pBt;
    sqlite3_mutex_leave(pBt.mutex);
    p.locked = (byte)(0);
}</function>
  <function>public static void unmapColumnIdlistNames(Parse pParse, IdList* pIdList)
{
    if ((pIdList) != null)
    {
        int ii = 0;
        for (ii = (int)(0); (ii) &lt; (pIdList-&gt;nId); ii++)
        {
            sqlite3RenameTokenRemap(pParse, null, (void*)(pIdList-&gt;a[ii].zName));
        }
    }
}</function>
  <function>public static void unsetJoinExpr(Expr p, int iTable)
{
    while ((p) != null)
    {
        if ((((p).flags &amp; (0x000001)) != 0) &amp;&amp; (((iTable) &lt; (0)) || ((p.w.iRightJoinTable) == (iTable))))
        {
            (p).flags &amp;= (uint)(~(0x000001));
        }

        if (((p.op) == (167)) &amp;&amp; ((p.iTable) == (iTable)))
        {
            (p).flags &amp;= (uint)(~(0x100000));
        }

        if ((p.op) == (172))
        {
            if ((p.x.pList) != null)
            {
                int i = 0;
                for (i = (int)(0); (i) &lt; (p.x.pList.nExpr); i++)
                {
                    unsetJoinExpr(p.x.pList.a[i].pExpr, (int)(iTable));
                }
            }
        }

        unsetJoinExpr(p.pLeft, (int)(iTable));
        p = p.pRight;
    }
}</function>
  <function>public static void updateAccumulator(Parse pParse, int regAcc, AggInfo pAggInfo, int eDistinctType)
{
    Vdbe v = pParse.pVdbe;
    int i = 0;
    int regHit = (int)(0);
    int addrHitTest = (int)(0);
    AggInfo_func pF;
    AggInfo_col pC;
    pAggInfo.directMode = (byte)(1);
    for (i = (int)(0), pF = pAggInfo.aFunc; (i) &lt; (pAggInfo.nFunc); i++, pF++)
    {
        int nArg = 0;
        int addrNext = (int)(0);
        int regAgg = 0;
        ExprList pList;
        pList = pF.pFExpr.x.pList;
        if ((((pF.pFExpr).flags &amp; (0x1000000)) != 0))
        {
            Expr pFilter = pF.pFExpr.y.pWin.pFilter;
            if ((((pAggInfo.nAccumulator) != 0) &amp;&amp; ((pF.pFunc.funcFlags &amp; 0x0020) != 0)) &amp;&amp; ((regAcc) != 0))
            {
                if ((regHit) == (0))
                    regHit = (int)(++pParse.nMem);
                sqlite3VdbeAddOp2(v, (int)(79), (int)(regAcc), (int)(regHit));
            }

            addrNext = (int)(sqlite3VdbeMakeLabel(pParse));
            sqlite3ExprIfFalse(pParse, pFilter, (int)(addrNext), (int)(0x10));
        }

        if ((pList) != null)
        {
            nArg = (int)(pList.nExpr);
            regAgg = (int)(sqlite3GetTempRange(pParse, (int)(nArg)));
            sqlite3ExprCodeExprList(pParse, pList, (int)(regAgg), (int)(0), (byte)(0x01));
        }
        else
        {
            nArg = (int)(0);
            regAgg = (int)(0);
        }

        if (((pF.iDistinct) &gt;= (0)) &amp;&amp; ((pList) != null))
        {
            if ((addrNext) == (0))
            {
                addrNext = (int)(sqlite3VdbeMakeLabel(pParse));
            }

            pF.iDistinct = (int)(codeDistinct(pParse, (int)(eDistinctType), (int)(pF.iDistinct), (int)(addrNext), pList, (int)(regAgg)));
        }

        if ((pF.pFunc.funcFlags &amp; 0x0020) != 0)
        {
            CollSeq pColl = null;
            ExprList_item* pItem;
            int j = 0;
            for (j = (int)(0), pItem = pList.a; (pColl == null) &amp;&amp; ((j) &lt; (nArg)); j++, pItem++)
            {
                pColl = sqlite3ExprCollSeq(pParse, pItem-&gt;pExpr);
            }

            if (pColl == null)
            {
                pColl = pParse.db.pDfltColl;
            }

            if (((regHit) == (0)) &amp;&amp; ((pAggInfo.nAccumulator) != 0))
                regHit = (int)(++pParse.nMem);
            sqlite3VdbeAddOp4(v, (int)(84), (int)(regHit), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
        }

        sqlite3VdbeAddOp3(v, (int)(161), (int)(0), (int)(regAgg), (int)(pF.iMem));
        sqlite3VdbeAppendP4(v, pF.pFunc, (int)(-8));
        sqlite3VdbeChangeP5(v, (ushort)((byte)(nArg)));
        sqlite3ReleaseTempRange(pParse, (int)(regAgg), (int)(nArg));
        if ((addrNext) != 0)
        {
            sqlite3VdbeResolveLabel(v, (int)(addrNext));
        }
    }

    if (((regHit) == (0)) &amp;&amp; ((pAggInfo.nAccumulator) != 0))
    {
        regHit = (int)(regAcc);
    }

    if ((regHit) != 0)
    {
        addrHitTest = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(regHit)));
    }

    for (i = (int)(0), pC = pAggInfo.aCol; (i) &lt; (pAggInfo.nAccumulator); i++, pC++)
    {
        sqlite3ExprCode(pParse, pC.pCExpr, (int)(pC.iMem));
    }

    pAggInfo.directMode = (byte)(0);
    if ((addrHitTest) != 0)
    {
        sqlite3VdbeJumpHereOrPopInst(v, (int)(addrHitTest));
    }
}</function>
  <function>public static void updateFromSelect(Parse pParse, int iEph, Index pPk, ExprList pChanges, SrcList pTabList, Expr pWhere, ExprList pOrderBy, Expr pLimit)
{
    int i = 0;
    SelectDest dest = new SelectDest();
    Select pSelect = null;
    ExprList pList = null;
    ExprList pGrp = null;
    Expr pLimit2 = null;
    ExprList pOrderBy2 = null;
    sqlite3 db = pParse.db;
    Table pTab = pTabList.a[0].pTab;
    SrcList pSrc;
    Expr pWhere2;
    int eDest = 0;
    pSrc = sqlite3SrcListDup(db, pTabList, (int)(0));
    pWhere2 = sqlite3ExprDup(db, pWhere, (int)(0));
    if ((pSrc) != null)
    {
        pSrc.a[0].fg.notCte = (uint)(1);
        pSrc.a[0].iCursor = (int)(-1);
        pSrc.a[0].pTab.nTabRef--;
        pSrc.a[0].pTab = null;
    }

    if ((pPk) != null)
    {
        for (i = (int)(0); (i) &lt; (pPk.nKeyCol); i++)
        {
            Expr pNew = exprRowColumn(pParse, (int)(pPk.aiColumn[i]));
            pList = sqlite3ExprListAppend(pParse, pList, pNew);
        }

        eDest = (int)((((pTab).eTabType) == (1)) ? 14 : 15);
    }
    else if ((((pTab).eTabType) == (2)))
    {
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, (int)(i)));
        }

        eDest = (int)(14);
    }
    else
    {
        eDest = (int)((((pTab).eTabType) == (1)) ? 14 : 15);
        pList = sqlite3ExprListAppend(pParse, null, sqlite3PExpr(pParse, (int)(75), null, null));
    }

    if ((pChanges) != null)
    {
        for (i = (int)(0); (i) &lt; (pChanges.nExpr); i++)
        {
            pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, pChanges.a[i].pExpr, (int)(0)));
        }
    }

    pSelect = sqlite3SelectNew(pParse, pList, pSrc, pWhere2, pGrp, null, pOrderBy2, (uint)(0x0800000 | 0x0020000), pLimit2);
    if ((pSelect) != null)
        pSelect.selFlags |= (uint)(0x8000000);
    sqlite3SelectDestInit(dest, (int)(eDest), (int)(iEph));
    dest.iSDParm2 = (int)(pPk ? pPk.nKeyCol : -1);
    sqlite3Select(pParse, pSelect, dest);
    sqlite3SelectDelete(db, pSelect);
}</function>
  <function>public static void updateRangeAffinityStr(Expr pRight, int n, sbyte* zAff)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (n); i++)
    {
        Expr p = sqlite3VectorFieldSubexpr(pRight, (int)(i));
        if (((sqlite3CompareAffinity(p, (sbyte)(zAff[i]))) == (0x41)) || ((sqlite3ExprNeedsNoAffinityChange(p, (sbyte)(zAff[i]))) != 0))
        {
            zAff[i] = (sbyte)(0x41);
        }
    }
}</function>
  <function>public static void updateVirtualTable(Parse pParse, SrcList pSrc, Table pTab, ExprList pChanges, Expr pRowid, int* aXRef, Expr pWhere, int onError)
{
    Vdbe v = pParse.pVdbe;
    int ephemTab = 0;
    int i = 0;
    sqlite3 db = pParse.db;
    sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
    WhereInfo pWInfo = null;
    int nArg = (int)(2 + pTab.nCol);
    int regArg = 0;
    int regRec = 0;
    int regRowid = 0;
    int iCsr = (int)(pSrc.a[0].iCursor);
    int* aDummy = stackalloc int[2];
    int eOnePass = 0;
    int addr = 0;
    ephemTab = (int)(pParse.nTab++);
    addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(ephemTab), (int)(nArg)));
    regArg = (int)(pParse.nMem + 1);
    pParse.nMem += (int)(nArg);
    if ((pSrc.nSrc) &gt; (1))
    {
        Index pPk = null;
        Expr pRow;
        ExprList pList;
        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            if ((pRowid) != null)
            {
                pRow = sqlite3ExprDup(db, pRowid, (int)(0));
            }
            else
            {
                pRow = sqlite3PExpr(pParse, (int)(75), null, null);
            }
        }
        else
        {
            short iPk = 0;
            pPk = sqlite3PrimaryKeyIndex(pTab);
            iPk = (short)(pPk.aiColumn[0]);
            if ((aXRef[iPk]) &gt;= (0))
            {
                pRow = sqlite3ExprDup(db, pChanges.a[aXRef[iPk]].pExpr, (int)(0));
            }
            else
            {
                pRow = exprRowColumn(pParse, (int)(iPk));
            }
        }

        pList = sqlite3ExprListAppend(pParse, null, pRow);
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            if ((aXRef[i]) &gt;= (0))
            {
                pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, pChanges.a[aXRef[i]].pExpr, (int)(0)));
            }
            else
            {
                pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, (int)(i)));
            }
        }

        updateFromSelect(pParse, (int)(ephemTab), pPk, pList, pSrc, pWhere, null, null);
        sqlite3ExprListDelete(db, pList);
        eOnePass = (int)(0);
    }
    else
    {
        regRec = (int)(++pParse.nMem);
        regRowid = (int)(++pParse.nMem);
        pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, null, null, null, (ushort)(0x0004), (int)(0));
        if ((pWInfo) == (null))
            return;
        for (i = (int)(0); (i) &lt; (pTab.nCol); i++)
        {
            if ((aXRef[i]) &gt;= (0))
            {
                sqlite3ExprCode(pParse, pChanges.a[aXRef[i]].pExpr, (int)(regArg + 2 + i));
            }
            else
            {
                sqlite3VdbeAddOp3(v, (int)(174), (int)(iCsr), (int)(i), (int)(regArg + 2 + i));
                sqlite3VdbeChangeP5(v, (ushort)(0x01));
            }
        }

        if ((((pTab).tabFlags &amp; 0x00000080) == (0)))
        {
            sqlite3VdbeAddOp2(v, (int)(134), (int)(iCsr), (int)(regArg));
            if ((pRowid) != null)
            {
                sqlite3ExprCode(pParse, pRowid, (int)(regArg + 1));
            }
            else
            {
                sqlite3VdbeAddOp2(v, (int)(134), (int)(iCsr), (int)(regArg + 1));
            }
        }
        else
        {
            Index pPk;
            short iPk = 0;
            pPk = sqlite3PrimaryKeyIndex(pTab);
            iPk = (short)(pPk.aiColumn[0]);
            sqlite3VdbeAddOp3(v, (int)(174), (int)(iCsr), (int)(iPk), (int)(regArg));
            sqlite3VdbeAddOp2(v, (int)(80), (int)(regArg + 2 + iPk), (int)(regArg + 1));
        }

        eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aDummy));
        if ((eOnePass) != 0)
        {
            sqlite3VdbeChangeToNoop(v, (int)(addr));
            sqlite3VdbeAddOp1(v, (int)(121), (int)(iCsr));
        }
        else
        {
            sqlite3MultiWrite(pParse);
            sqlite3VdbeAddOp3(v, (int)(96), (int)(regArg), (int)(nArg), (int)(regRec));
            sqlite3VdbeAddOp2(v, (int)(126), (int)(ephemTab), (int)(regRowid));
            sqlite3VdbeAddOp3(v, (int)(127), (int)(ephemTab), (int)(regRec), (int)(regRowid));
        }
    }

    if ((eOnePass) == (0))
    {
        if ((pSrc.nSrc) == (1))
        {
            sqlite3WhereEnd(pWInfo);
        }

        addr = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(ephemTab)));
        for (i = (int)(0); (i) &lt; (nArg); i++)
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(ephemTab), (int)(i), (int)(regArg + i));
        }
    }

    sqlite3VtabMakeWritable(pParse, pTab);
    sqlite3VdbeAddOp4(v, (int)(10), (int)(0), (int)(nArg), (int)(regArg), pVTab, (int)(-12));
    sqlite3VdbeChangeP5(v, (ushort)((onError) == (11) ? 2 : onError));
    sqlite3MayAbort(pParse);
    if ((eOnePass) == (0))
    {
        sqlite3VdbeAddOp2(v, (int)(5), (int)(ephemTab), (int)(addr + 1));
        sqlite3VdbeJumpHere(v, (int)(addr));
        sqlite3VdbeAddOp2(v, (int)(121), (int)(ephemTab), (int)(0));
    }
    else
    {
        sqlite3WhereEnd(pWInfo);
    }
}</function>
  <function>public static void upperFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    sbyte* z1;
    sbyte* z2;
    int i = 0; int  n  =  0 ; 
    z2 = (sbyte*)(sqlite3_value_text(argv[0]));
    n = (int)(sqlite3_value_bytes(argv[0]));
    if ((z2) != null)
    {
        z1 = contextMalloc(context, (long)(((long)(n)) + 1));
        if ((z1) != null)
        {
            for (i = (int)(0); (i) &lt; (n); i++)
            {
                z1[i] = ((sbyte)((z2[i]) &amp; ~(sqlite3CtypeMap[(byte)(z2[i])] &amp; 0x20)));
            }

            sqlite3_result_text(context, z1, (int)(n), sqlite3_free);
        }
    }
}</function>
  <function>public static void upsertDelete(sqlite3 db, Upsert p)
{
    do
    {
        Upsert pNext = p.pNextUpsert;
        sqlite3ExprListDelete(db, p.pUpsertTarget);
        sqlite3ExprDelete(db, p.pUpsertTargetWhere);
        sqlite3ExprListDelete(db, p.pUpsertSet);
        sqlite3ExprDelete(db, p.pUpsertWhere);
        sqlite3DbFree(db, p.pToFree);
        sqlite3DbFree(db, p);
        p = pNext;
    }
    while ((p) != null);
}</function>
  <function>public static sbyte* uriParameter(sbyte* zFilename, sbyte* zParam)
{
    zFilename += sqlite3Strlen30(zFilename) + 1;
    while ((zFilename != null) &amp;&amp; ((zFilename[0]) != 0))
    {
        int x = (int)(CRuntime.strcmp(zFilename, zParam));
        zFilename += sqlite3Strlen30(zFilename) + 1;
        if ((x) == (0))
            return zFilename;
        zFilename += sqlite3Strlen30(zFilename) + 1;
    }

    return null;
}</function>
  <function>public static int validJulianDay(long iJD)
{
    return (((iJD) &gt;= (0)) &amp;&amp; ((iJD) &lt;= ((((long)(0x1a640)) &lt;&lt; 32) | 0x1072fdff)) ? 1 : 0);
}</function>
  <function>public static int valueBytes(sqlite3_value pVal, byte enc)
{
    return (int)(valueToText(pVal, (byte)(enc)) != null ? pVal.n : 0);
}</function>
  <function>public static int valueFromExpr(sqlite3 db, Expr pExpr, byte enc, byte affinity, sqlite3_value ppVal, ValueNewStat4Ctx pCtx)
{
    int op = 0;
    sbyte* zVal = null;
    sqlite3_value pVal = null;
    int negInt = (int)(1);
    sbyte* zNeg = "";
    int rc = (int)(0);
    while (((op = (int)(pExpr.op)) == (174)) || ((op) == (181)))
    {
        pExpr = pExpr.pLeft;
    }

    if ((op) == (176))
        op = (int)(pExpr.op2);
    if ((op) == (36))
    {
        byte aff = 0;
        aff = (byte)(sqlite3AffinityType(pExpr.u.zToken, null));
        rc = (int)(valueFromExpr(db, pExpr.pLeft, (byte)(enc), (byte)(aff), ppVal, pCtx));
        if ((ppVal) != null)
        {
            sqlite3VdbeMemCast(ppVal, (byte)(aff), (byte)(1));
            sqlite3ValueApplyAffinity(ppVal, (byte)(affinity), (byte)(1));
        }

        return (int)(rc);
    }

    if (((op) == (173)) &amp;&amp; (((pExpr.pLeft.op) == (155)) || ((pExpr.pLeft.op) == (153))))
    {
        pExpr = pExpr.pLeft;
        op = (int)(pExpr.op);
        negInt = (int)(-1);
        zNeg = "-";
    }

    if ((((op) == (117)) || ((op) == (153))) || ((op) == (155)))
    {
        pVal = valueNew(db, pCtx);
        if ((pVal) == (null))
            goto no_mem;
        if ((((pExpr).flags &amp; (0x000400)) != 0))
        {
            sqlite3VdbeMemSetInt64(pVal, (long)((long)(pExpr.u.iValue) * negInt));
        }
        else
        {
            zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr.u.zToken);
            if ((zVal) == (null))
                goto no_mem;
            sqlite3ValueSetStr(pVal, (int)(-1), zVal, (byte)(1), ((Void(Void * ))(sqlite3OomFault)));
        }

        if ((((op) == (155)) || ((op) == (153))) &amp;&amp; ((affinity) == (0x41)))
        {
            sqlite3ValueApplyAffinity(pVal, (byte)(0x43), (byte)(1));
        }
        else
        {
            sqlite3ValueApplyAffinity(pVal, (byte)(affinity), (byte)(1));
        }

        if ((pVal.flags &amp; (0x0004 | 0x0020 | 0x0008)) != 0)
        {
            pVal.flags &amp;= (ushort)(~0x0002);
        }

        if (enc != 1)
        {
            rc = (int)(sqlite3VdbeChangeEncoding(pVal, (int)(enc)));
        }
    }
    else if ((op) == (173))
    {
        if (((0) == (valueFromExpr(db, pExpr.pLeft, (byte)(enc), (byte)(affinity), pVal, pCtx))) &amp;&amp; (pVal != null))
        {
            sqlite3VdbeMemNumerify(pVal);
            if ((pVal.flags &amp; 0x0008) != 0)
            {
                pVal.u.r = (double)(-pVal.u.r);
            }
            else if ((pVal.u.i) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))))
            {
                pVal.u.r = (double)(-(double)(((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) &lt;&lt; 32))));
                ((pVal).flags = (ushort)(((pVal).flags &amp; ~(0xc1bf | 0x4000)) | 0x0008));
            }
            else
            {
                pVal.u.i = (long)(-pVal.u.i);
            }

            sqlite3ValueApplyAffinity(pVal, (byte)(affinity), (byte)(enc));
        }
    }
    else if ((op) == (121))
    {
        pVal = valueNew(db, pCtx);
        if ((pVal) == (null))
            goto no_mem;
        sqlite3VdbeMemSetNull(pVal);
    }
    else if ((op) == (154))
    {
        int nVal = 0;
        pVal = valueNew(db, pCtx);
        if (pVal == null)
            goto no_mem;
        zVal = &amp;pExpr.u.zToken[2];
        nVal = (int)(sqlite3Strlen30(zVal) - 1);
        sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, (int)(nVal)), (long)(nVal / 2), (byte)(0), ((Void(Void * ))(sqlite3OomFault)));
    }
    else if ((op) == (170))
    {
        pVal = valueNew(db, pCtx);
        if ((pVal) != null)
        {
            pVal.flags = (ushort)(0x0004);
            pVal.u.i = (long)((pExpr.u.zToken[4]) == (0));
        }
    }

    ppVal = pVal;
    return (int)(rc);
    no_mem:
        ; sqlite3OomFault ( db ) ; 
    sqlite3DbFree(db, zVal);
    sqlite3ValueFree(pVal);
    return (int)(7);
}</function>
  <function>public static int valueFromValueList(sqlite3_value pVal, sqlite3_value ppOut, int bNext)
{
    int rc = 0;
    ValueList pRhs;
    ppOut = null;
    if ((pVal) == (null))
        return (int)(21);
    pRhs = (ValueList)(sqlite3_value_pointer(pVal, "ValueList"));
    if ((pRhs) == (null))
        return (int)(21);
    if ((bNext) != 0)
    {
        rc = (int)(sqlite3BtreeNext(pRhs.pCsr, (int)(0)));
    }
    else
    {
        int dummy = (int)(0);
        rc = (int)(sqlite3BtreeFirst(pRhs.pCsr, &amp;dummy));
        if ((sqlite3BtreeEof(pRhs.pCsr)) != 0)
            rc = (int)(101);
    }

    if ((rc) == (0))
    {
        uint sz = 0;
        sqlite3_value sMem = new sqlite3_value();
        CRuntime.memset(sMem, (int)(0), (ulong)(sizeof(sqlite3_value)));
        sz = (uint)(sqlite3BtreePayloadSize(pRhs.pCsr));
        rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pRhs.pCsr, (uint)((int)(sz)), sMem));
        if ((rc) == (0))
        {
            byte* zBuf = (byte*)(sMem.z);
            uint iSerial = 0;
            sqlite3_value pOut = pRhs.pOut;
            int iOff = (int)(1 + (byte)(((*(&amp;zBuf[1])) &lt; ((byte)(0x80))) ? ((iSerial) = ((uint)(*(&amp;zBuf[1])))), 1 : 
            sqlite3GetVarint32((&amp;zBuf[1]), &amp;(iSerial)) ) )
            ;
            sqlite3VdbeSerialGet(&amp;zBuf[iOff], (uint)(iSerial), pOut);
            pOut.enc = (byte)((pOut.db).enc);
            if (((pOut.flags &amp; 0x1000) != 0) &amp;&amp; ((sqlite3VdbeMemMakeWriteable(pOut)) != 0))
            {
                rc = (int)(7);
            }
            else
            {
                ppOut = pOut;
            }
        }

        sqlite3VdbeMemRelease(sMem);
    }

    return (int)(rc);
}</function>
  <function>public static sqlite3_value valueNew(sqlite3 db, ValueNewStat4Ctx p)
{
    return sqlite3ValueNew(db);
}</function>
  <function>public static void* valueToText(sqlite3_value pVal, byte enc)
{
    if ((pVal.flags &amp; (0x0010 | 0x0002)) != 0)
    {
        if ((((pVal).flags &amp; 0x4000) ? sqlite3VdbeMemExpandBlob(pVal) : 0) != 0)
            return null;
        pVal.flags |= (ushort)(0x0002);
        if (pVal.enc != (enc &amp; ~8))
        {
            sqlite3VdbeChangeEncoding(pVal, (int)(enc &amp; ~8));
        }

        if (((enc &amp; 8) != 0) &amp;&amp; ((1) == (1 &amp; ((int)((long)(pVal.z))))))
        {
            if (sqlite3VdbeMemMakeWriteable(pVal) != 0)
            {
                return null;
            }
        }

        sqlite3VdbeMemNulTerminate(pVal);
    }
    else
    {
        sqlite3VdbeMemStringify(pVal, (byte)(enc), (byte)(0));
    }

    if ((pVal.enc) == (enc &amp; ~8))
    {
        return pVal.z;
    }
    else
    {
        return null;
    }
}</function>
  <function>public static void vdbeChangeP4Full(Vdbe p, VdbeOp* pOp, sbyte* zP4, int n)
{
    if ((pOp-&gt;p4type) != 0)
    {
        freeP4(p.db, (int)(pOp-&gt;p4type), pOp-&gt;p4.p);
        pOp-&gt;p4type = (sbyte)(0);
        pOp-&gt;p4.p = null;
    }

    if ((n) &lt; (0))
    {
        sqlite3VdbeChangeP4(p, (int)(pOp - p.aOp), zP4, (int)(n));
    }
    else
    {
        if ((n) == (0))
            n = (int)(sqlite3Strlen30(zP4));
        pOp-&gt;p4.z = sqlite3DbStrNDup(p.db, zP4, (ulong)(n));
        pOp-&gt;p4type = (sbyte)(-7);
    }
}</function>
  <function>public static int vdbeCloseStatement(Vdbe p, int eOp)
{
    sqlite3 db = p.db;
    int rc = (int)(0);
    int i = 0;
    int iSavepoint = (int)(p.iStatement - 1);
    for (i = (int)(0); (i) &lt; (db.nDb); i++)
    {
        int rc2 = (int)(0);
        Btree pBt = db.aDb[i].pBt;
        if ((pBt) != null)
        {
            if ((eOp) == (2))
            {
                rc2 = (int)(sqlite3BtreeSavepoint(pBt, (int)(2), (int)(iSavepoint)));
            }

            if ((rc2) == (0))
            {
                rc2 = (int)(sqlite3BtreeSavepoint(pBt, (int)(1), (int)(iSavepoint)));
            }

            if ((rc) == (0))
            {
                rc = (int)(rc2);
            }
        }
    }

    db.nStatement--;
    p.iStatement = (int)(0);
    if ((rc) == (0))
    {
        if ((eOp) == (2))
        {
            rc = (int)(sqlite3VtabSavepoint(db, (int)(2), (int)(iSavepoint)));
        }

        if ((rc) == (0))
        {
            rc = (int)(sqlite3VtabSavepoint(db, (int)(1), (int)(iSavepoint)));
        }
    }

    if ((eOp) == (2))
    {
        db.nDeferredCons = (long)(p.nStmtDefCons);
        db.nDeferredImmCons = (long)(p.nStmtDefImmCons);
    }

    return (int)(rc);
}</function>
  <function>public static void vdbeClrCopy(sqlite3_value pTo, sqlite3_value pFrom, int eType)
{
    vdbeMemClearExternAndSetNull(pTo);
    sqlite3VdbeMemShallowCopy(pTo, pFrom, (int)(eType));
}</function>
  <function>public static int vdbeCommit(sqlite3 db, Vdbe p)
{
    int i = 0;
    int nTrans = (int)(0);
    int rc = (int)(0);
    int needXcommit = (int)(0);
    rc = (int)(sqlite3VtabSync(db, p));
    for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nDb)); i++)
    {
        Btree pBt = db.aDb[i].pBt;
        if ((sqlite3BtreeTxnState(pBt)) == (2))
        {
            Pager pPager;
            needXcommit = (int)(1);
            sqlite3BtreeEnter(pBt);
            pPager = sqlite3BtreePager(pBt);
            if (((db.aDb[i].safety_level != 0x01) &amp;&amp; ((vdbeCommit_aMJNeeded[sqlite3PagerGetJournalMode(pPager)]) != 0)) &amp;&amp; ((sqlite3PagerIsMemdb(pPager)) == (0)))
            {
                nTrans++;
            }

            rc = (int)(sqlite3PagerExclusiveLock(pPager));
            sqlite3BtreeLeave(pBt);
        }
    }

    if (rc != 0)
    {
        return (int)(rc);
    }

    if (((needXcommit) != 0) &amp;&amp; ((db.xCommitCallback) != null))
    {
        rc = (int)(db.xCommitCallback(db.pCommitArg));
        if ((rc) != 0)
        {
            return (int)(19 | (2 &lt;&lt; 8));
        }
    }

    if (((0) == (sqlite3Strlen30(sqlite3BtreeGetFilename(db.aDb[0].pBt)))) || ((nTrans) &lt;= (1)))
    {
        for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nDb)); i++)
        {
            Btree pBt = db.aDb[i].pBt;
            if ((pBt) != null)
            {
                rc = (int)(sqlite3BtreeCommitPhaseOne(pBt, null));
            }
        }

        for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nDb)); i++)
        {
            Btree pBt = db.aDb[i].pBt;
            if ((pBt) != null)
            {
                rc = (int)(sqlite3BtreeCommitPhaseTwo(pBt, (int)(0)));
            }
        }

        if ((rc) == (0))
        {
            sqlite3VtabCommit(db);
        }
    }
    else
    {
        sqlite3_vfs pVfs = db.pVfs;
        sbyte* zSuper = null;
        sbyte* zMainFile = sqlite3BtreeGetFilename(db.aDb[0].pBt);
        sqlite3_file pSuperJrnl = null;
        long offset = (long)(0);
        int res = 0;
        int retryCount = (int)(0);
        int nMainFile = 0;
        nMainFile = (int)(sqlite3Strlen30(zMainFile));
        zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", (int)(0), zMainFile, (int)(0));
        if ((zSuper) == (null))
            return (int)(7);
        zSuper += 4;
        do
        {
            uint iRandom = 0;
            if ((retryCount) != 0)
            {
                if ((retryCount) &gt; (100))
                {
                    sqlite3_log((int)(13), "MJ delete: %s", zSuper);
                    sqlite3OsDelete(pVfs, zSuper, (int)(0));
                    break;
                }
                else if ((retryCount) == (1))
                {
                    sqlite3_log((int)(13), "MJ collide: %s", zSuper);
                }
            }

            retryCount++;
            sqlite3_randomness((int)(sizeof(uint)), &amp;iRandom);
            sqlite3_snprintf((int)(13), &amp;zSuper[nMainFile], "-mj%06X9%02X", (uint)((iRandom &gt;&gt; 8) &amp; 0xffffff), (uint)(iRandom &amp; 0xff));
            rc = (int)(sqlite3OsAccess(pVfs, zSuper, (int)(0), &amp;res));
        }
        while (((rc) == (0)) &amp;&amp; ((res) != 0));
        if ((rc) == (0))
        {
            rc = (int)(sqlite3OsOpenMalloc(pVfs, zSuper, pSuperJrnl, (int)(0x00000002 | 0x00000004 | 0x00000010 | 0x00004000), null));
        }

        if (rc != 0)
        {
            sqlite3DbFree(db, zSuper - 4);
            return (int)(rc);
        }

        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            Btree pBt = db.aDb[i].pBt;
            if ((sqlite3BtreeTxnState(pBt)) == (2))
            {
                sbyte* zFile = sqlite3BtreeGetJournalname(pBt);
                if ((zFile) == (null))
                {
                    continue;
                }

                rc = (int)(sqlite3OsWrite(pSuperJrnl, zFile, (int)(sqlite3Strlen30(zFile) + 1), (long)(offset)));
                offset += (long)(sqlite3Strlen30(zFile) + 1);
                if (rc != 0)
                {
                    sqlite3OsCloseFree(pSuperJrnl);
                    sqlite3OsDelete(pVfs, zSuper, (int)(0));
                    sqlite3DbFree(db, zSuper - 4);
                    return (int)(rc);
                }
            }
        }

        if (((0) == (sqlite3OsDeviceCharacteristics(pSuperJrnl) &amp; 0x00000400)) &amp;&amp; (0 != (rc = (int)(sqlite3OsSync(pSuperJrnl, (int)(0x00002))))))
        {
            sqlite3OsCloseFree(pSuperJrnl);
            sqlite3OsDelete(pVfs, zSuper, (int)(0));
            sqlite3DbFree(db, zSuper - 4);
            return (int)(rc);
        }

        for (i = (int)(0); ((rc) == (0)) &amp;&amp; ((i) &lt; (db.nDb)); i++)
        {
            Btree pBt = db.aDb[i].pBt;
            if ((pBt) != null)
            {
                rc = (int)(sqlite3BtreeCommitPhaseOne(pBt, zSuper));
            }
        }

        sqlite3OsCloseFree(pSuperJrnl);
        if (rc != 0)
        {
            sqlite3DbFree(db, zSuper - 4);
            return (int)(rc);
        }

        rc = (int)(sqlite3OsDelete(pVfs, zSuper, (int)(1)));
        sqlite3DbFree(db, zSuper - 4);
        zSuper = null;
        if ((rc) != 0)
        {
            return (int)(rc);
        }

        sqlite3BeginBenignMalloc();
        for (i = (int)(0); (i) &lt; (db.nDb); i++)
        {
            Btree pBt = db.aDb[i].pBt;
            if ((pBt) != null)
            {
                sqlite3BtreeCommitPhaseTwo(pBt, (int)(1));
            }
        }

        sqlite3EndBenignMalloc();
        sqlite3VtabCommit(db);
    }

    return (int)(rc);
}</function>
  <function>public static int vdbeCompareMemString(sqlite3_value pMem1, sqlite3_value pMem2, CollSeq pColl, byte* prcErr)
{
    if ((pMem1.enc) == (pColl.enc))
    {
        return (int)(pColl.xCmp(pColl.pUser, (int)(pMem1.n), pMem1.z, (int)(pMem2.n), pMem2.z));
    }
    else
    {
        int rc = 0;
        void* v1;
        void* v2;
        sqlite3_value c1 = new sqlite3_value();
        sqlite3_value c2 = new sqlite3_value();
        sqlite3VdbeMemInit(c1, pMem1.db, (ushort)(0x0001));
        sqlite3VdbeMemInit(c2, pMem1.db, (ushort)(0x0001));
        sqlite3VdbeMemShallowCopy(c1, pMem1, (int)(0x1000));
        sqlite3VdbeMemShallowCopy(c2, pMem2, (int)(0x1000));
        v1 = sqlite3ValueText(c1, (byte)(pColl.enc));
        v2 = sqlite3ValueText(c2, (byte)(pColl.enc));
        if ((((v1) == (null)) || ((v2) == (null))))
        {
            if ((prcErr) != null)
                *prcErr = (byte)(7);
            rc = (int)(0);
        }
        else
        {
            rc = (int)(pColl.xCmp(pColl.pUser, (int)(c1.n), v1, (int)(c2.n), v2));
        }

        sqlite3VdbeMemRelease(c1);
        sqlite3VdbeMemRelease(c2);
        return (int)(rc);
    }
}</function>
  <function>public static void vdbeFreeOpArray(sqlite3 db, VdbeOp* aOp, int nOp)
{
    if ((aOp) != null)
    {
        VdbeOp* pOp;
        for (pOp = &amp;aOp[nOp - 1]; (pOp) &gt;= (aOp); pOp--)
        {
            if ((pOp-&gt;p4type) &lt;= (-7))
                freeP4(db, (int)(pOp-&gt;p4type), pOp-&gt;p4.p);
        }

        sqlite3DbFreeNN(db, aOp);
    }
}</function>
  <function>public static int vdbeIncrBgPopulate(IncrMerger pIncr)
{
    void* p = (void*)(pIncr);
    return (int)(vdbeSorterCreateThread(pIncr.pTask, vdbeIncrPopulateThread, p));
}</function>
  <function>public static void vdbeIncrFree(IncrMerger pIncr)
{
    if ((pIncr) != null)
    {
        if ((pIncr.bUseThread) != 0)
        {
            vdbeSorterJoinThread(pIncr.pTask);
            if ((pIncr.aFile[0].pFd) != null)
                sqlite3OsCloseFree(pIncr.aFile[0].pFd);
            if ((pIncr.aFile[1].pFd) != null)
                sqlite3OsCloseFree(pIncr.aFile[1].pFd);
        }

        vdbeMergeEngineFree(pIncr.pMerger);
        sqlite3_free(pIncr);
    }
}</function>
  <function>public static int vdbeIncrMergerNew(SortSubtask pTask, MergeEngine pMerger, IncrMerger ppOut)
{
    int rc = (int)(0);
    IncrMerger pIncr = ppOut = (IncrMerger)((sqlite3FaultSim((int)(100))) != 0 ? null : sqlite3MallocZero((ulong)(sizeof(IncrMerger))));
    if ((pIncr) != null)
    {
        pIncr.pMerger = pMerger;
        pIncr.pTask = pTask;
        pIncr.mxSz = (int)((pTask.pSorter.mxKeysize + 9) &gt; (pTask.pSorter.mxPmaSize / 2) ? (pTask.pSorter.mxKeysize + 9) : (pTask.pSorter.mxPmaSize / 2));
        pTask.file2.iEof += (long)(pIncr.mxSz);
    }
    else
    {
        vdbeMergeEngineFree(pMerger);
        rc = (int)(7);
    }

    return (int)(rc);
}</function>
  <function>public static void vdbeIncrMergerSetThreads(IncrMerger pIncr)
{
    pIncr.bUseThread = (int)(1);
    pIncr.pTask.file2.iEof -= (long)(pIncr.mxSz);
}</function>
  <function>public static int vdbeIncrPopulate(IncrMerger pIncr)
{
    int rc = (int)(0);
    int rc2 = 0;
    long iStart = (long)(pIncr.iStartOff);
    SorterFile pOut = pIncr.aFile[1];
    SortSubtask pTask = pIncr.pTask;
    MergeEngine pMerger = pIncr.pMerger;
    PmaWriter writer = new PmaWriter();
    vdbePmaWriterInit(pOut.pFd, writer, (int)(pTask.pSorter.pgsz), (long)(iStart));
    while ((rc) == (0))
    {
        int dummy = 0;
        PmaReader pReader = pMerger.aReadr[pMerger.aTree[1]];
        int nKey = (int)(pReader.nKey);
        long iEof = (long)(writer.iWriteOff + writer.iBufEnd);
        if ((pReader.pFd) == (null))
            break;
        if ((iEof + nKey + sqlite3VarintLen((ulong)(nKey))) &gt; (iStart + pIncr.mxSz))
            break;
        vdbePmaWriteVarint(writer, (ulong)(nKey));
        vdbePmaWriteBlob(writer, pReader.aKey, (int)(nKey));
        rc = (int)(vdbeMergeEngineStep(pIncr.pMerger, &amp;dummy));
    }

    rc2 = (int)(vdbePmaWriterFinish(writer, &amp;pOut.iEof));
    if ((rc) == (0))
        rc = (int)(rc2);
    return (int)(rc);
}</function>
  <function>public static void* vdbeIncrPopulateThread(void* pCtx)
{
    IncrMerger pIncr = (IncrMerger)(pCtx);
    void* pRet = ((void*)((long)(vdbeIncrPopulate(pIncr))));
    pIncr.pTask.bDone = (int)(1);
    return pRet;
}</function>
  <function>public static int vdbeIncrSwap(IncrMerger pIncr)
{
    int rc = (int)(0);
    if ((pIncr.bUseThread) != 0)
    {
        rc = (int)(vdbeSorterJoinThread(pIncr.pTask));
        if ((rc) == (0))
        {
            SorterFile f0 = (SorterFile)(pIncr.aFile[0]);
            pIncr.aFile[0] = (SorterFile)(pIncr.aFile[1]);
            pIncr.aFile[1] = (SorterFile)(f0);
        }

        if ((rc) == (0))
        {
            if ((pIncr.aFile[0].iEof) == (pIncr.iStartOff))
            {
                pIncr.bEof = (int)(1);
            }
            else
            {
                rc = (int)(vdbeIncrBgPopulate(pIncr));
            }
        }
    }
    else
    {
        rc = (int)(vdbeIncrPopulate(pIncr));
        pIncr.aFile[0] = (SorterFile)(pIncr.aFile[1]);
        if ((pIncr.aFile[0].iEof) == (pIncr.iStartOff))
        {
            pIncr.bEof = (int)(1);
        }
    }

    return (int)(rc);
}</function>
  <function>public static void vdbeLeave(Vdbe p)
{
    int i = 0;
    sqlite3 db;
    Db aDb;
    int nDb = 0;
    db = p.db;
    aDb = db.aDb;
    nDb = (int)(db.nDb);
    for (i = (int)(0); (i) &lt; (nDb); i++)
    {
        if (((i != 1) &amp;&amp; (((p.lockMask) &amp; (((uint)(1)) &lt;&lt; (i))) != 0)) &amp;&amp; (aDb[i].pBt != null))
        {
            sqlite3BtreeLeave(aDb[i].pBt);
        }
    }
}</function>
  <function>public static int vdbeMemAddTerminator(sqlite3_value pMem)
{
    if ((sqlite3VdbeMemGrow(pMem, (int)(pMem.n + 3), (int)(1))) != 0)
    {
        return (int)(7);
    }

    pMem.z[pMem.n] = (sbyte)(0);
    pMem.z[pMem.n + 1] = (sbyte)(0);
    pMem.z[pMem.n + 2] = (sbyte)(0);
    pMem.flags |= (ushort)(0x0200);
    return (int)(0);
}</function>
  <function>public static void vdbeMemClear(sqlite3_value p)
{
    if ((((p).flags &amp; (0x2000 | 0x0400)) != 0))
    {
        vdbeMemClearExternAndSetNull(p);
    }

    if ((p.szMalloc) != 0)
    {
        sqlite3DbFreeNN(p.db, p.zMalloc);
        p.szMalloc = (int)(0);
    }

    p.z = null;
}</function>
  <function>public static void vdbeMemClearExternAndSetNull(sqlite3_value p)
{
    if ((p.flags &amp; 0x2000) != 0)
    {
        sqlite3VdbeMemFinalize(p, p.u.pDef);
    }

    if ((p.flags &amp; 0x0400) != 0)
    {
        p.xDel((void*)(p.z));
    }

    p.flags = (ushort)(0x0001);
}</function>
  <function>public static void vdbeMemRenderNum(int sz, sbyte* zBuf, sqlite3_value p)
{
    sqlite3_str acc = new sqlite3_str();
    if ((p.flags &amp; 0x0004) != 0)
    {
        sqlite3Int64ToText((long)(p.u.i), zBuf);
    }
    else
    {
        sqlite3StrAccumInit(acc, null, zBuf, (int)(sz), (int)(0));
        sqlite3_str_appendf(acc, "%!.15g", (double)((p.flags &amp; 0x0020) != 0 ? (double)(p.u.i) : p.u.r));
        zBuf[acc.nChar] = (sbyte)(0);
    }
}</function>
  <function>public static sbyte* vdbeMemTypeName(sqlite3_value pMem)
{
    return vdbeMemTypeName_azTypes[sqlite3_value_type(pMem) - 1];
}</function>
  <function>public static void vdbeMergeEngineCompare(MergeEngine pMerger, int iOut)
{
    int i1 = 0;
    int i2 = 0;
    int iRes = 0;
    PmaReader p1;
    PmaReader p2;
    if ((iOut) &gt;= (pMerger.nTree / 2))
    {
        i1 = (int)((iOut - pMerger.nTree / 2) * 2);
        i2 = (int)(i1 + 1);
    }
    else
    {
        i1 = (int)(pMerger.aTree[iOut * 2]);
        i2 = (int)(pMerger.aTree[iOut * 2 + 1]);
    }

    p1 = pMerger.aReadr[i1];
    p2 = pMerger.aReadr[i2];
    if ((p1.pFd) == (null))
    {
        iRes = (int)(i2);
    }
    else if ((p2.pFd) == (null))
    {
        iRes = (int)(i1);
    }
    else
    {
        SortSubtask pTask = pMerger.pTask;
        int bCached = (int)(0);
        int res = 0;
        res = (int)(pTask.xCompare(pTask, &amp;bCached, p1.aKey, (int)(p1.nKey), p2.aKey, (int)(p2.nKey)));
        if ((res) &lt;= (0))
        {
            iRes = (int)(i1);
        }
        else
        {
            iRes = (int)(i2);
        }
    }

    pMerger.aTree[iOut] = (int)(iRes);
}</function>
  <function>public static void vdbeMergeEngineFree(MergeEngine pMerger)
{
    int i = 0;
    if ((pMerger) != null)
    {
        for (i = (int)(0); (i) &lt; (pMerger.nTree); i++)
        {
            vdbePmaReaderClear(pMerger.aReadr[i]);
        }
    }

    sqlite3_free(pMerger);
}</function>
  <function>public static int vdbeMergeEngineInit(SortSubtask pTask, MergeEngine pMerger, int eMode)
{
    int rc = (int)(0);
    int i = 0;
    int nTree = 0;
    pMerger.pTask = pTask;
    nTree = (int)(pMerger.nTree);
    for (i = (int)(0); (i) &lt; (nTree); i++)
    {
        if (((8) &gt; (0)) &amp;&amp; ((eMode) == (2)))
        {
            rc = (int)(vdbePmaReaderNext(pMerger.aReadr[nTree - i - 1]));
        }
        else
        {
            rc = (int)(vdbePmaReaderIncrInit(pMerger.aReadr[i], (int)(0)));
        }

        if (rc != 0)
            return (int)(rc);
    }

    for (i = (int)(pMerger.nTree - 1); (i) &gt; (0); i--)
    {
        vdbeMergeEngineCompare(pMerger, (int)(i));
    }

    return (int)(pTask.pUnpacked.errCode);
}</function>
  <function>public static int vdbeMergeEngineLevel0(SortSubtask pTask, int nPMA, long* piOffset, MergeEngine ppOut)
{
    MergeEngine pNew;
    long iOff = (long)(*piOffset);
    int i = 0;
    int rc = (int)(0);
    ppOut = pNew = vdbeMergeEngineNew((int)(nPMA));
    if ((pNew) == (null))
        rc = (int)(7);
    for (i = (int)(0); ((i) &lt; (nPMA)) &amp;&amp; ((rc) == (0)); i++)
    {
        long nDummy = (long)(0);
        PmaReader pReadr = pNew.aReadr[i];
        rc = (int)(vdbePmaReaderInit(pTask, pTask.file, (long)(iOff), pReadr, &amp;nDummy));
        iOff = (long)(pReadr.iEof);
    }

    if (rc != 0)
    {
        vdbeMergeEngineFree(pNew);
        ppOut = null;
    }

    *piOffset = (long)(iOff);
    return (int)(rc);
}</function>
  <function>public static MergeEngine vdbeMergeEngineNew(int nReader)
{
    int N = (int)(2);
    int nByte = 0;
    MergeEngine pNew;
    while ((N) &lt; (nReader))
    {
        N += (int)(N);
    }

    nByte = (int)(sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader)));
    pNew = (sqlite3FaultSim((int)(100))) != 0 ? null : (MergeEngine)(sqlite3MallocZero((ulong)(nByte)));
    if ((pNew) != null)
    {
        pNew.nTree = (int)(N);
        pNew.pTask = null;
        pNew.aReadr = (PmaReader)(pNew[1]);
        pNew.aTree = (int*)(pNew.aReadr[N]);
    }

    return pNew;
}</function>
  <function>public static int vdbeMergeEngineStep(MergeEngine pMerger, int* pbEof)
{
    int rc = 0;
    int iPrev = (int)(pMerger.aTree[1]);
    SortSubtask pTask = pMerger.pTask;
    rc = (int)(vdbePmaReaderNext(pMerger.aReadr[iPrev]));
    if ((rc) == (0))
    {
        int i = 0;
        PmaReader pReadr1;
        PmaReader pReadr2;
        int bCached = (int)(0);
        pReadr1 = pMerger.aReadr[(iPrev &amp; 0xFFFE)];
        pReadr2 = pMerger.aReadr[(iPrev | 0x0001)];
        for (i = (int)((pMerger.nTree + iPrev) / 2); (i) &gt; (0); i = (int)(i / 2))
        {
            int iRes = 0;
            if ((pReadr1.pFd) == (null))
            {
                iRes = (int)(+1);
            }
            else if ((pReadr2.pFd) == (null))
            {
                iRes = (int)(-1);
            }
            else
            {
                iRes = (int)(pTask.xCompare(pTask, &amp;bCached, pReadr1.aKey, (int)(pReadr1.nKey), pReadr2.aKey, (int)(pReadr2.nKey)));
            }

            if (((iRes) &lt; (0)) || (((iRes) == (0)) &amp;&amp; ((pReadr1) &lt; (pReadr2))))
            {
                pMerger.aTree[i] = ((int)(pReadr1 - pMerger.aReadr));
                pReadr2 = pMerger.aReadr[pMerger.aTree[i ^ 0x0001]];
                bCached = (int)(0);
            }
            else
            {
                if ((pReadr1.pFd) != null)
                    bCached = (int)(0);
                pMerger.aTree[i] = ((int)(pReadr2 - pMerger.aReadr));
                pReadr1 = pMerger.aReadr[pMerger.aTree[i ^ 0x0001]];
            }
        }

        *pbEof = (int)((pMerger.aReadr[pMerger.aTree[1]].pFd) == (null) ? 1 : 0);
    }

    return (int)((rc) == (0) ? pTask.pUnpacked.errCode : rc);
}</function>
  <function>public static int vdbePmaReadBlob(PmaReader p, int nByte, byte** ppOut)
{
    int iBuf = 0;
    int nAvail = 0;
    if ((p.aMap) != null)
    {
        *ppOut = &amp;p.aMap[p.iReadOff];
        p.iReadOff += (long)(nByte);
        return (int)(0);
    }

    iBuf = (int)(p.iReadOff % p.nBuffer);
    if ((iBuf) == (0))
    {
        int nRead = 0;
        int rc = 0;
        if ((p.iEof - p.iReadOff) &gt; ((long)(p.nBuffer)))
        {
            nRead = (int)(p.nBuffer);
        }
        else
        {
            nRead = ((int)(p.iEof - p.iReadOff));
        }

        rc = (int)(sqlite3OsRead(p.pFd, p.aBuffer, (int)(nRead), (long)(p.iReadOff)));
        if (rc != 0)
            return (int)(rc);
    }

    nAvail = (int)(p.nBuffer - iBuf);
    if ((nByte) &lt;= (nAvail))
    {
        *ppOut = &amp;p.aBuffer[iBuf];
        p.iReadOff += (long)(nByte);
    }
    else
    {
        int nRem = 0;
        if ((p.nAlloc) &lt; (nByte))
        {
            byte* aNew;
            long nNew = (long)((128) &gt; (2 * (long)(p.nAlloc)) ? (128) : (2 * (long)(p.nAlloc)));
            while ((nByte) &gt; (nNew))
            {
                nNew = (long)(nNew * 2);
            }

            aNew = sqlite3Realloc(p.aAlloc, (ulong)(nNew));
            if (aNew == null)
                return (int)(7);
            p.nAlloc = (int)(nNew);
            p.aAlloc = aNew;
        }

        CRuntime.memcpy(p.aAlloc, &amp;p.aBuffer[iBuf], (ulong)(nAvail));
        p.iReadOff += (long)(nAvail);
        nRem = (int)(nByte - nAvail);
        while ((nRem) &gt; (0))
        {
            int rc = 0;
            int nCopy = 0;
            byte* aNext;
            nCopy = (int)(nRem);
            if ((nRem) &gt; (p.nBuffer))
                nCopy = (int)(p.nBuffer);
            rc = (int)(vdbePmaReadBlob(p, (int)(nCopy), &amp;aNext));
            if (rc != 0)
                return (int)(rc);
            CRuntime.memcpy(&amp;p.aAlloc[nByte - nRem], aNext, (ulong)(nCopy));
            nRem -= (int)(nCopy);
        }

        *ppOut = p.aAlloc;
    }

    return (int)(0);
}</function>
  <function>public static void* vdbePmaReaderBgIncrInit(void* pCtx)
{
    PmaReader pReader = (PmaReader)(pCtx);
    void* pRet = ((void*)((long)(vdbePmaReaderIncrMergeInit(pReader, (int)(1)))));
    pReader.pIncr.pTask.bDone = (int)(1);
    return pRet;
}</function>
  <function>public static void vdbePmaReaderClear(PmaReader pReadr)
{
    sqlite3_free(pReadr.aAlloc);
    sqlite3_free(pReadr.aBuffer);
    if ((pReadr.aMap) != null)
        sqlite3OsUnfetch(pReadr.pFd, (long)(0), pReadr.aMap);
    vdbeIncrFree(pReadr.pIncr);
    CRuntime.memset(pReadr, (int)(0), (ulong)(sizeof(PmaReader)));
}</function>
  <function>public static int vdbePmaReaderIncrInit(PmaReader pReadr, int eMode)
{
    IncrMerger pIncr = pReadr.pIncr;
    int rc = (int)(0);
    if ((pIncr) != null)
    {
        if ((pIncr.bUseThread) != 0)
        {
            void* pCtx = (void*)(pReadr);
            rc = (int)(vdbeSorterCreateThread(pIncr.pTask, vdbePmaReaderBgIncrInit, pCtx));
        }
        else
        {
            rc = (int)(vdbePmaReaderIncrMergeInit(pReadr, (int)(eMode)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int vdbePmaReaderIncrMergeInit(PmaReader pReadr, int eMode)
{
    int rc = (int)(0);
    IncrMerger pIncr = pReadr.pIncr;
    SortSubtask pTask = pIncr.pTask;
    sqlite3 db = pTask.pSorter.db;
    rc = (int)(vdbeMergeEngineInit(pTask, pIncr.pMerger, (int)(eMode)));
    if ((rc) == (0))
    {
        int mxSz = (int)(pIncr.mxSz);
        if ((pIncr.bUseThread) != 0)
        {
            rc = (int)(vdbeSorterOpenTempFile(db, (long)(mxSz), pIncr.aFile[0].pFd));
            if ((rc) == (0))
            {
                rc = (int)(vdbeSorterOpenTempFile(db, (long)(mxSz), pIncr.aFile[1].pFd));
            }
        }
        else
        {
            if ((pTask.file2.pFd) == (null))
            {
                rc = (int)(vdbeSorterOpenTempFile(db, (long)(pTask.file2.iEof), pTask.file2.pFd));
                pTask.file2.iEof = (long)(0);
            }

            if ((rc) == (0))
            {
                pIncr.aFile[1].pFd = pTask.file2.pFd;
                pIncr.iStartOff = (long)(pTask.file2.iEof);
                pTask.file2.iEof += (long)(mxSz);
            }
        }
    }

    if (((rc) == (0)) &amp;&amp; ((pIncr.bUseThread) != 0))
    {
        rc = (int)(vdbeIncrPopulate(pIncr));
    }

    if (((rc) == (0)) &amp;&amp; (((8) == (0)) || (eMode != 1)))
    {
        rc = (int)(vdbePmaReaderNext(pReadr));
    }

    return (int)(rc);
}</function>
  <function>public static int vdbePmaReaderInit(SortSubtask pTask, SorterFile pFile, long iStart, PmaReader pReadr, long* pnByte)
{
    int rc = 0;
    rc = (int)(vdbePmaReaderSeek(pTask, pReadr, pFile, (long)(iStart)));
    if ((rc) == (0))
    {
        ulong nByte = (ulong)(0);
        rc = (int)(vdbePmaReadVarint(pReadr, &amp;nByte));
        pReadr.iEof = (long)(pReadr.iReadOff + nByte);
        *pnByte += (long)(nByte);
    }

    if ((rc) == (0))
    {
        rc = (int)(vdbePmaReaderNext(pReadr));
    }

    return (int)(rc);
}</function>
  <function>public static int vdbePmaReaderNext(PmaReader pReadr)
{
    int rc = (int)(0);
    ulong nRec = (ulong)(0);
    if ((pReadr.iReadOff) &gt;= (pReadr.iEof))
    {
        IncrMerger pIncr = pReadr.pIncr;
        int bEof = (int)(1);
        if ((pIncr) != null)
        {
            rc = (int)(vdbeIncrSwap(pIncr));
            if (((rc) == (0)) &amp;&amp; ((pIncr.bEof) == (0)))
            {
                rc = (int)(vdbePmaReaderSeek(pIncr.pTask, pReadr, pIncr.aFile[0], (long)(pIncr.iStartOff)));
                bEof = (int)(0);
            }
        }

        if ((bEof) != 0)
        {
            vdbePmaReaderClear(pReadr);
            return (int)(rc);
        }
    }

    if ((rc) == (0))
    {
        rc = (int)(vdbePmaReadVarint(pReadr, &amp;nRec));
    }

    if ((rc) == (0))
    {
        pReadr.nKey = ((int)(nRec));
        rc = (int)(vdbePmaReadBlob(pReadr, (int)(nRec), &amp;pReadr.aKey));
    }

    return (int)(rc);
}</function>
  <function>public static int vdbePmaReaderSeek(SortSubtask pTask, PmaReader pReadr, SorterFile pFile, long iOff)
{
    int rc = (int)(0);
    if ((sqlite3FaultSim((int)(201))) != 0)
        return (int)(10 | (1 &lt;&lt; 8));
    if ((pReadr.aMap) != null)
    {
        sqlite3OsUnfetch(pReadr.pFd, (long)(0), pReadr.aMap);
        pReadr.aMap = null;
    }

    pReadr.iReadOff = (long)(iOff);
    pReadr.iEof = (long)(pFile.iEof);
    pReadr.pFd = pFile.pFd;
    rc = (int)(vdbeSorterMapFile(pTask, pFile, &amp;pReadr.aMap));
    if (((rc) == (0)) &amp;&amp; ((pReadr.aMap) == (null)))
    {
        int pgsz = (int)(pTask.pSorter.pgsz);
        int iBuf = (int)(pReadr.iReadOff % pgsz);
        if ((pReadr.aBuffer) == (null))
        {
            pReadr.aBuffer = (byte*)(sqlite3Malloc((ulong)(pgsz)));
            if ((pReadr.aBuffer) == (null))
                rc = (int)(7);
            pReadr.nBuffer = (int)(pgsz);
        }

        if (((rc) == (0)) &amp;&amp; ((iBuf) != 0))
        {
            int nRead = (int)(pgsz - iBuf);
            if ((pReadr.iReadOff + nRead) &gt; (pReadr.iEof))
            {
                nRead = ((int)(pReadr.iEof - pReadr.iReadOff));
            }

            rc = (int)(sqlite3OsRead(pReadr.pFd, &amp;pReadr.aBuffer[iBuf], (int)(nRead), (long)(pReadr.iReadOff)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int vdbePmaReadVarint(PmaReader p, ulong* pnOut)
{
    int iBuf = 0;
    if ((p.aMap) != null)
    {
        p.iReadOff += (long)(sqlite3GetVarint(&amp;p.aMap[p.iReadOff], pnOut));
    }
    else
    {
        iBuf = (int)(p.iReadOff % p.nBuffer);
        if (((iBuf) != 0) &amp;&amp; ((p.nBuffer - iBuf) &gt;= (9)))
        {
            p.iReadOff += (long)(sqlite3GetVarint(&amp;p.aBuffer[iBuf], pnOut));
        }
        else
        {
            byte* aVarint = stackalloc byte[16];
            byte* a;
            int i = (int)(0);
            int rc = 0;
            do
            {
                rc = (int)(vdbePmaReadBlob(p, (int)(1), &amp;a));
                if ((rc) != 0)
                    return (int)(rc);
                aVarint[(i++) &amp; 0xf] = (byte)(a[0]);
            }
            while ((a[0] &amp; 0x80) != 0);
            sqlite3GetVarint(aVarint, pnOut);
        }
    }

    return (int)(0);
}</function>
  <function>public static void vdbePmaWriteBlob(PmaWriter p, byte* pData, int nData)
{
    int nRem = (int)(nData);
    while (((nRem) &gt; (0)) &amp;&amp; ((p.eFWErr) == (0)))
    {
        int nCopy = (int)(nRem);
        if ((nCopy) &gt; (p.nBuffer - p.iBufEnd))
        {
            nCopy = (int)(p.nBuffer - p.iBufEnd);
        }

        CRuntime.memcpy(&amp;p.aBuffer[p.iBufEnd], &amp;pData[nData - nRem], (ulong)(nCopy));
        p.iBufEnd += (int)(nCopy);
        if ((p.iBufEnd) == (p.nBuffer))
        {
            p.eFWErr = (int)(sqlite3OsWrite(p.pFd, &amp;p.aBuffer[p.iBufStart], (int)(p.iBufEnd - p.iBufStart), (long)(p.iWriteOff + p.iBufStart)));
            p.iBufStart = (int)(p.iBufEnd = (int)(0));
            p.iWriteOff += (long)(p.nBuffer);
        }

        nRem -= (int)(nCopy);
    }
}</function>
  <function>public static int vdbePmaWriterFinish(PmaWriter p, long* piEof)
{
    int rc = 0;
    if ((((p.eFWErr) == (0)) &amp;&amp; ((p.aBuffer) != null)) &amp;&amp; ((p.iBufEnd) &gt; (p.iBufStart)))
    {
        p.eFWErr = (int)(sqlite3OsWrite(p.pFd, &amp;p.aBuffer[p.iBufStart], (int)(p.iBufEnd - p.iBufStart), (long)(p.iWriteOff + p.iBufStart)));
    }

    *piEof = (long)(p.iWriteOff + p.iBufEnd);
    sqlite3_free(p.aBuffer);
    rc = (int)(p.eFWErr);
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(PmaWriter)));
    return (int)(rc);
}</function>
  <function>public static void vdbePmaWriterInit(sqlite3_file pFd, PmaWriter p, int nBuf, long iStart)
{
    CRuntime.memset(p, (int)(0), (ulong)(sizeof(PmaWriter)));
    p.aBuffer = (byte*)(sqlite3Malloc((ulong)(nBuf)));
    if (p.aBuffer == null)
    {
        p.eFWErr = (int)(7);
    }
    else
    {
        p.iBufEnd = (int)(p.iBufStart = (int)(iStart % nBuf));
        p.iWriteOff = (long)(iStart - p.iBufStart);
        p.nBuffer = (int)(nBuf);
        p.pFd = pFd;
    }
}</function>
  <function>public static void vdbePmaWriteVarint(PmaWriter p, ulong iVal)
{
    int nByte = 0;
    byte* aByte = stackalloc byte[10];
    nByte = (int)(sqlite3PutVarint(aByte, (ulong)(iVal)));
    vdbePmaWriteBlob(p, aByte, (int)(nByte));
}</function>
  <function>public static int vdbeRecordCompareInt(int nKey1, void* pKey1, UnpackedRecord pPKey2)
{
    byte* aKey = &amp;((byte*)(pKey1))[*(byte*)(pKey1) &amp; 0x3F];
    int serial_type = (int)(((byte*)(pKey1))[1]);
    int res = 0;
    uint y = 0;
    ulong x = 0;
    long v = 0;
    long lhs = 0;
    switch (serial_type)
    {
        case 1:
        {
            lhs = (long)((sbyte)((aKey)[0]));
            break;
        }

        case 2:
        {
            lhs = (long)(256 * (sbyte)((aKey)[0]) | (aKey)[1]);
            break;
        }

        case 3:
        {
            lhs = (long)(65536 * (sbyte)((aKey)[0]) | ((aKey)[1] &lt;&lt; 8) | (aKey)[2]);
            break;
        }

        case 4:
        {
            y = (uint)(((uint)((aKey)[0]) &lt;&lt; 24) | ((aKey)[1] &lt;&lt; 16) | ((aKey)[2] &lt;&lt; 8) | (aKey)[3]);
            lhs = ((long)(*(int*)(&amp;y)));
            break;
        }

        case 5:
        {
            lhs = (long)((((uint)((aKey + 2)[0]) &lt;&lt; 24) | ((aKey + 2)[1] &lt;&lt; 16) | ((aKey + 2)[2] &lt;&lt; 8) | (aKey + 2)[3]) + (((long)(1)) &lt;&lt; 32) * (256 * (sbyte)((aKey)[0]) | (aKey)[1]));
            break;
        }

        case 6:
        {
            x = (ulong)(((uint)((aKey)[0]) &lt;&lt; 24) | ((aKey)[1] &lt;&lt; 16) | ((aKey)[2] &lt;&lt; 8) | (aKey)[3]);
            x = (ulong)((x &lt;&lt; 32) | (((uint)((aKey + 4)[0]) &lt;&lt; 24) | ((aKey + 4)[1] &lt;&lt; 16) | ((aKey + 4)[2] &lt;&lt; 8) | (aKey + 4)[3]));
            lhs = (long)(*(long*)(&amp;x));
            break;
        }

        case 8:
            lhs = (long)(0);
            break;
        case 9:
            lhs = (long)(1);
            break;
        case 0:
        case 7:
            return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, pPKey2));
        default:
            return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, pPKey2));
    }

    v = (long)(pPKey2.aMem[0].u.i);
    if ((v) &gt; (lhs))
    {
        res = (int)(pPKey2.r1);
    }
    else if ((v) &lt; (lhs))
    {
        res = (int)(pPKey2.r2);
    }
    else if ((pPKey2.nField) &gt; (1))
    {
        res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(1)));
    }
    else
    {
        res = (int)(pPKey2.default_rc);
        pPKey2.eqSeen = (byte)(1);
    }

    return (int)(res);
}</function>
  <function>public static int vdbeRecordCompareString(int nKey1, void* pKey1, UnpackedRecord pPKey2)
{
    byte* aKey1 = (byte*)(pKey1);
    int serial_type = 0;
    int res = 0;
    serial_type = (int)(aKey1[1]);
    if ((serial_type) &gt;= (0x80))
    {
        sqlite3GetVarint32(&amp;aKey1[1], (uint*)(&amp;serial_type));
    }

    if ((serial_type) &lt; (12))
    {
        res = (int)(pPKey2.r1);
    }
    else if ((serial_type &amp; 0x01) == 0)
    {
        res = (int)(pPKey2.r2);
    }
    else
    {
        int nCmp = 0;
        int nStr = 0;
        int szHdr = (int)(aKey1[0]);
        nStr = (int)((serial_type - 12) / 2);
        if ((szHdr + nStr) &gt; (nKey1))
        {
            pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84621))));
            return (int)(0);
        }

        nCmp = (int)((pPKey2.aMem[0].n) &lt; (nStr) ? (pPKey2.aMem[0].n) : (nStr));
        res = (int)(memcmp(&amp;aKey1[szHdr], pPKey2.aMem[0].z, (ulong)(nCmp)));
        if ((res) &gt; (0))
        {
            res = (int)(pPKey2.r2);
        }
        else if ((res) &lt; (0))
        {
            res = (int)(pPKey2.r1);
        }
        else
        {
            res = (int)(nStr - pPKey2.aMem[0].n);
            if ((res) == (0))
            {
                if ((pPKey2.nField) &gt; (1))
                {
                    res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(1)));
                }
                else
                {
                    res = (int)(pPKey2.default_rc);
                    pPKey2.eqSeen = (byte)(1);
                }
            }
            else if ((res) &gt; (0))
            {
                res = (int)(pPKey2.r2);
            }
            else
            {
                res = (int)(pPKey2.r1);
            }
        }
    }

    return (int)(res);
}</function>
  <function>public static long vdbeRecordDecodeInt(uint serial_type, byte* aKey)
{
    uint y = 0;
    switch (serial_type)
    {
        case 0:
        case 1:
            ;
            return (long)((sbyte)((aKey)[0]));
        case 2:
            ;
            return (long)(256 * (sbyte)((aKey)[0]) | (aKey)[1]);
        case 3:
            ;
            return (long)(65536 * (sbyte)((aKey)[0]) | ((aKey)[1] &lt;&lt; 8) | (aKey)[2]);
        case 4:
        {
            y = (uint)(((uint)((aKey)[0]) &lt;&lt; 24) | ((aKey)[1] &lt;&lt; 16) | ((aKey)[2] &lt;&lt; 8) | (aKey)[3]);
            return (long)(*(int*)(&amp;y));
        }

        case 5:
        {
            return (long)((((uint)((aKey + 2)[0]) &lt;&lt; 24) | ((aKey + 2)[1] &lt;&lt; 16) | ((aKey + 2)[2] &lt;&lt; 8) | (aKey + 2)[3]) + (((long)(1)) &lt;&lt; 32) * (256 * (sbyte)((aKey)[0]) | (aKey)[1]));
        }

        case 6:
        {
            ulong x = (ulong)(((uint)((aKey)[0]) &lt;&lt; 24) | ((aKey)[1] &lt;&lt; 16) | ((aKey)[2] &lt;&lt; 8) | (aKey)[3]);
            x = (ulong)((x &lt;&lt; 32) | (((uint)((aKey + 4)[0]) &lt;&lt; 24) | ((aKey + 4)[1] &lt;&lt; 16) | ((aKey + 4)[2] &lt;&lt; 8) | (aKey + 4)[3]));
            return (long)(*(long*)(&amp;x));
        }
    }

    return (long)(serial_type - 8);
}</function>
  <function>public static void vdbeReleaseAndSetInt64(sqlite3_value pMem, long val)
{
    sqlite3VdbeMemSetNull(pMem);
    pMem.u.i = (long)(val);
    pMem.flags = (ushort)(0x0004);
}</function>
  <function>public static int vdbeSafety(Vdbe p)
{
    if ((p.db) == (null))
    {
        sqlite3_log((int)(21), "API called with finalized prepared statement");
        return (int)(1);
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static int vdbeSafetyNotNull(Vdbe p)
{
    if ((p) == (null))
    {
        sqlite3_log((int)(21), "API called with NULL prepared statement");
        return (int)(1);
    }
    else
    {
        return (int)(vdbeSafety(p));
    }
}</function>
  <function>public static int vdbeSortAllocUnpacked(SortSubtask pTask)
{
    if ((pTask.pUnpacked) == (null))
    {
        pTask.pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask.pSorter.pKeyInfo);
        if ((pTask.pUnpacked) == (null))
            return (int)(7);
        pTask.pUnpacked.nField = (ushort)(pTask.pSorter.pKeyInfo.nKeyField);
        pTask.pUnpacked.errCode = (byte)(0);
    }

    return (int)(0);
}</function>
  <function>public static int vdbeSorterAddToTree(SortSubtask pTask, int nDepth, int iSeq, MergeEngine pRoot, MergeEngine pLeaf)
{
    int rc = (int)(0);
    int nDiv = (int)(1);
    int i = 0;
    MergeEngine p = pRoot;
    IncrMerger pIncr;
    rc = (int)(vdbeIncrMergerNew(pTask, pLeaf, pIncr));
    for (i = (int)(1); (i) &lt; (nDepth); i++)
    {
        nDiv = (int)(nDiv * 16);
    }

    for (i = (int)(1); ((i) &lt; (nDepth)) &amp;&amp; ((rc) == (0)); i++)
    {
        int iIter = (int)((iSeq / nDiv) % 16);
        PmaReader pReadr = p.aReadr[iIter];
        if ((pReadr.pIncr) == (null))
        {
            MergeEngine pNew = vdbeMergeEngineNew((int)(16));
            if ((pNew) == (null))
            {
                rc = (int)(7);
            }
            else
            {
                rc = (int)(vdbeIncrMergerNew(pTask, pNew, pReadr.pIncr));
            }
        }

        if ((rc) == (0))
        {
            p = pReadr.pIncr.pMerger;
            nDiv = (int)(nDiv / 16);
        }
    }

    if ((rc) == (0))
    {
        p.aReadr[iSeq % 16].pIncr = pIncr;
    }
    else
    {
        vdbeIncrFree(pIncr);
    }

    return (int)(rc);
}</function>
  <function>public static int vdbeSorterCompare(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
{
    UnpackedRecord r2 = pTask.pUnpacked;
    if (*pbKey2Cached == 0)
    {
        sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, (int)(nKey2), pKey2, r2);
        *pbKey2Cached = (int)(1);
    }

    return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, r2));
}</function>
  <function>public static int vdbeSorterCompareInt(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
{
    byte* p1 = (byte*)(pKey1);
    byte* p2 = (byte*)(pKey2);
    int s1 = (int)(p1[1]);
    int s2 = (int)(p2[1]);
    byte* v1 = &amp;p1[p1[0]];
    byte* v2 = &amp;p2[p2[0]];
    int res = 0;
    if ((s1) == (s2))
    {
        byte n = (byte)(vdbeSorterCompareInt_aLen[s1]);
        int i = 0;
        res = (int)(0);
        for (i = (int)(0); (i) &lt; (n); i++)
        {
            if ((res = (int)(v1[i] - v2[i])) != 0)
            {
                if (((v1[0] ^ v2[0]) &amp; 0x80) != 0)
                {
                    res = (int)((v1[0] &amp; 0x80) != 0 ? -1 : +1);
                }

                break;
            }
        }
    }
    else if (((s1) &gt; (7)) &amp;&amp; ((s2) &gt; (7)))
    {
        res = (int)(s1 - s2);
    }
    else
    {
        if ((s2) &gt; (7))
        {
            res = (int)(+1);
        }
        else if ((s1) &gt; (7))
        {
            res = (int)(-1);
        }
        else
        {
            res = (int)(s1 - s2);
        }

        if ((res) &gt; (0))
        {
            if ((*v1 &amp; 0x80) != 0)
                res = (int)(-1);
        }
        else
        {
            if ((*v2 &amp; 0x80) != 0)
                res = (int)(+1);
        }
    }

    if ((res) == (0))
    {
        if ((pTask.pSorter.pKeyInfo.nKeyField) &gt; (1))
        {
            res = (int)(vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, (int)(nKey1), pKey2, (int)(nKey2)));
        }
    }
    else if ((pTask.pSorter.pKeyInfo.aSortFlags[0]) != 0)
    {
        res = (int)(res * -1);
    }

    return (int)(res);
}</function>
  <function>public static int vdbeSorterCompareTail(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
{
    UnpackedRecord r2 = pTask.pUnpacked;
    if ((*pbKey2Cached) == (0))
    {
        sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, (int)(nKey2), pKey2, r2);
        *pbKey2Cached = (int)(1);
    }

    return (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, r2, (int)(1)));
}</function>
  <function>public static int vdbeSorterCompareText(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
{
    byte* p1 = (byte*)(pKey1);
    byte* p2 = (byte*)(pKey2);
    byte* v1 = &amp;p1[p1[0]];
    byte* v2 = &amp;p2[p2[0]];
    int n1 = 0;
    int n2 = 0;
    int res = 0;
    n1 = (int)((uint)(*(&amp;p1[1])));
    if ((n1) &gt;= (0x80))
        sqlite3GetVarint32((&amp;p1[1]), (uint*)(&amp;(n1)));
    n2 = (int)((uint)(*(&amp;p2[1])));
    if ((n2) &gt;= (0x80))
        sqlite3GetVarint32((&amp;p2[1]), (uint*)(&amp;(n2)));
    res = (int)(memcmp(v1, v2, (ulong)((((n1) &lt; (n2) ? (n1) : (n2)) - 13) / 2)));
    if ((res) == (0))
    {
        res = (int)(n1 - n2);
    }

    if ((res) == (0))
    {
        if ((pTask.pSorter.pKeyInfo.nKeyField) &gt; (1))
        {
            res = (int)(vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, (int)(nKey1), pKey2, (int)(nKey2)));
        }
    }
    else
    {
        if ((pTask.pSorter.pKeyInfo.aSortFlags[0]) != 0)
        {
            res = (int)(res * -1);
        }
    }

    return (int)(res);
}</function>
  <function>public static int vdbeSorterCreateThread(SortSubtask pTask, delegate75 xTask, void* pIn)
{
    return (int)(sqlite3ThreadCreate(pTask.pThread, xTask, pIn));
}</function>
  <function>public static void vdbeSorterExtendFile(sqlite3 db, sqlite3_file pFd, long nByte)
{
    if (((nByte) &lt;= ((long)(db.nMaxSorterMmap))) &amp;&amp; ((pFd.pMethods.iVersion) &gt;= (3)))
    {
        void* p = null;
        int chunksize = (int)(4 * 1024);
        sqlite3OsFileControlHint(pFd, (int)(6), &amp;chunksize);
        sqlite3OsFileControlHint(pFd, (int)(5), &amp;nByte);
        sqlite3OsFetch(pFd, (long)(0), (int)(nByte), &amp;p);
        if ((p) != null)
            sqlite3OsUnfetch(pFd, (long)(0), p);
    }
}</function>
  <function>public static int vdbeSorterFlushPMA(VdbeSorter pSorter)
{
    int rc = (int)(0);
    int i = 0;
    SortSubtask pTask = null;
    int nWorker = (int)(pSorter.nTask - 1);
    pSorter.bUsePMA = (byte)(1);
    for (i = (int)(0); (i) &lt; (nWorker); i++)
    {
        int iTest = (int)((pSorter.iPrev + i + 1) % nWorker);
        pTask = pSorter.aTask[iTest];
        if ((pTask.bDone) != 0)
        {
            rc = (int)(vdbeSorterJoinThread(pTask));
        }

        if ((rc != 0) || ((pTask.pThread) == (null)))
            break;
    }

    if ((rc) == (0))
    {
        if ((i) == (nWorker))
        {
            rc = (int)(vdbeSorterListToPMA(pSorter.aTask[nWorker], &amp;pSorter.list));
        }
        else
        {
            byte* aMem;
            void* pCtx;
            aMem = pTask.list.aMemory;
            pCtx = (void*)(pTask);
            pSorter.iPrev = ((byte)(pTask - pSorter.aTask));
            pTask.list = (SorterList)(pSorter.list);
            pSorter.list.pList = null;
            pSorter.list.szPMA = (int)(0);
            if ((aMem) != null)
            {
                pSorter.list.aMemory = aMem;
                pSorter.nMemory = (int)(sqlite3MallocSize(aMem));
            }
            else if ((pSorter.list.aMemory) != null)
            {
                pSorter.list.aMemory = sqlite3Malloc((ulong)(pSorter.nMemory));
                if (pSorter.list.aMemory == null)
                    return (int)(7);
            }

            rc = (int)(vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx));
        }
    }

    return (int)(rc);
}</function>
  <function>public static void* vdbeSorterFlushThread(void* pCtx)
{
    SortSubtask pTask = (SortSubtask)(pCtx);
    int rc = 0;
    rc = (int)(vdbeSorterListToPMA(pTask, &amp;pTask.list));
    pTask.bDone = (int)(1);
    return ((void*)((long)(rc)));
}</function>
  <function>public static Int ( SortSubtask * ,  SortSubtask * ,  SortSubtask * ,  SortSubtask * ,  SortSubtask * ,  SortSubtask * )vdbeSorterGetCompare(VdbeSorter p)
{
    if ((p.typeMask) == (0x01))
    {
        return vdbeSorterCompareInt;
    }
    else if ((p.typeMask) == (0x02))
    {
        return vdbeSorterCompareText;
    }

    return vdbeSorterCompare;
}</function>
  <function>public static int vdbeSorterJoinAll(VdbeSorter pSorter, int rcin)
{
    int rc = (int)(rcin);
    int i = 0;
    for (i = (int)(pSorter.nTask - 1); (i) &gt;= (0); i--)
    {
        SortSubtask pTask = pSorter.aTask[i];
        int rc2 = (int)(vdbeSorterJoinThread(pTask));
        if ((rc) == (0))
            rc = (int)(rc2);
    }

    return (int)(rc);
}</function>
  <function>public static int vdbeSorterJoinThread(SortSubtask pTask)
{
    int rc = (int)(0);
    if ((pTask.pThread) != null)
    {
        void* pRet = ((void*)((long)(1)));
        (void)(sqlite3ThreadJoin(pTask.pThread, &amp;pRet));
        rc = ((int)((long)(pRet)));
        pTask.bDone = (int)(0);
        pTask.pThread = null;
    }

    return (int)(rc);
}</function>
  <function>public static int vdbeSorterListToPMA(SortSubtask pTask, SorterList* pList)
{
    sqlite3 db = pTask.pSorter.db;
    int rc = (int)(0);
    PmaWriter writer = new PmaWriter();
    CRuntime.memset(writer, (int)(0), (ulong)(sizeof(PmaWriter)));
    if ((pTask.file.pFd) == (null))
    {
        rc = (int)(vdbeSorterOpenTempFile(db, (long)(0), pTask.file.pFd));
    }

    if ((rc) == (0))
    {
        vdbeSorterExtendFile(db, pTask.file.pFd, (long)(pTask.file.iEof + pList-&gt;szPMA + 9));
    }

    if ((rc) == (0))
    {
        rc = (int)(vdbeSorterSort(pTask, pList));
    }

    if ((rc) == (0))
    {
        SorterRecord* p;
        SorterRecord* pNext = null;
        vdbePmaWriterInit(pTask.file.pFd, writer, (int)(pTask.pSorter.pgsz), (long)(pTask.file.iEof));
        pTask.nPMA++;
        vdbePmaWriteVarint(writer, (ulong)(pList-&gt;szPMA));
        for (p = pList-&gt;pList; p; p = pNext)
        {
            pNext = p-&gt;u.pNext;
            vdbePmaWriteVarint(writer, (ulong)(p-&gt;nVal));
            vdbePmaWriteBlob(writer, ((void*)((p) + 1)), (int)(p-&gt;nVal));
            if ((pList-&gt;aMemory) == (null))
                sqlite3_free(p);
        }

        pList-&gt;pList = p;
        rc = (int)(vdbePmaWriterFinish(writer, &amp;pTask.file.iEof));
    }

    return (int)(rc);
}</function>
  <function>public static int vdbeSorterMapFile(SortSubtask pTask, SorterFile pFile, byte** pp)
{
    int rc = (int)(0);
    if ((pFile.iEof) &lt;= ((long)(pTask.pSorter.db.nMaxSorterMmap)))
    {
        sqlite3_file pFd = pFile.pFd;
        if ((pFd.pMethods.iVersion) &gt;= (3))
        {
            rc = (int)(sqlite3OsFetch(pFd, (long)(0), (int)(pFile.iEof), (void**)(pp)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static SorterRecord* vdbeSorterMerge(SortSubtask pTask, SorterRecord* p1, SorterRecord* p2)
{
    SorterRecord* pFinal = null;
    SorterRecord** pp = &amp;pFinal;
    int bCached = (int)(0);
    for (;;)
    {
        int res = 0;
        res = (int)(pTask.xCompare(pTask, &amp;bCached, ((void*)((p1) + 1)), (int)(p1-&gt;nVal), ((void*)((p2) + 1)), (int)(p2-&gt;nVal)));
        if ((res) &lt;= (0))
        {
            *pp = p1;
            pp = &amp;p1-&gt;u.pNext;
            p1 = p1-&gt;u.pNext;
            if ((p1) == (null))
            {
                *pp = p2;
                break;
            }
        }
        else
        {
            *pp = p2;
            pp = &amp;p2-&gt;u.pNext;
            p2 = p2-&gt;u.pNext;
            bCached = (int)(0);
            if ((p2) == (null))
            {
                *pp = p1;
                break;
            }
        }
    }

    return pFinal;
}</function>
  <function>public static int vdbeSorterMergeTreeBuild(VdbeSorter pSorter, MergeEngine ppOut)
{
    MergeEngine pMain = null;
    int rc = (int)(0);
    int iTask = 0;
    if ((pSorter.nTask) &gt; (1))
    {
        pMain = vdbeMergeEngineNew((int)(pSorter.nTask));
        if ((pMain) == (null))
            rc = (int)(7);
    }

    for (iTask = (int)(0); ((rc) == (0)) &amp;&amp; ((iTask) &lt; (pSorter.nTask)); iTask++)
    {
        SortSubtask pTask = pSorter.aTask[iTask];
        if (((8) == (0)) || ((pTask.nPMA) != 0))
        {
            MergeEngine pRoot = null;
            int nDepth = (int)(vdbeSorterTreeDepth((int)(pTask.nPMA)));
            long iReadOff = (long)(0);
            if ((pTask.nPMA) &lt;= (16))
            {
                rc = (int)(vdbeMergeEngineLevel0(pTask, (int)(pTask.nPMA), &amp;iReadOff, pRoot));
            }
            else
            {
                int i = 0;
                int iSeq = (int)(0);
                pRoot = vdbeMergeEngineNew((int)(16));
                if ((pRoot) == (null))
                    rc = (int)(7);
                for (i = (int)(0); ((i) &lt; (pTask.nPMA)) &amp;&amp; ((rc) == (0)); i += (int)(16))
                {
                    MergeEngine pMerger = null;
                    int nReader = 0;
                    nReader = (int)((pTask.nPMA - i) &lt; (16) ? (pTask.nPMA - i) : (16));
                    rc = (int)(vdbeMergeEngineLevel0(pTask, (int)(nReader), &amp;iReadOff, pMerger));
                    if ((rc) == (0))
                    {
                        rc = (int)(vdbeSorterAddToTree(pTask, (int)(nDepth), (int)(iSeq++), pRoot, pMerger));
                    }
                }
            }

            if ((rc) == (0))
            {
                if (pMain != null)
                {
                    rc = (int)(vdbeIncrMergerNew(pTask, pRoot, pMain.aReadr[iTask].pIncr));
                }
                else
                {
                    pMain = pRoot;
                }
            }
            else
            {
                vdbeMergeEngineFree(pRoot);
            }
        }
    }

    if (rc != 0)
    {
        vdbeMergeEngineFree(pMain);
        pMain = null;
    }

    ppOut = pMain;
    return (int)(rc);
}</function>
  <function>public static int vdbeSorterOpenTempFile(sqlite3 db, long nExtend, sqlite3_file ppFd)
{
    int rc = 0;
    if ((sqlite3FaultSim((int)(202))) != 0)
        return (int)(10 | (13 &lt;&lt; 8));
    rc = (int)(sqlite3OsOpenMalloc(db.pVfs, null, ppFd, (int)(0x00001000 | 0x00000002 | 0x00000004 | 0x00000010 | 0x00000008), &amp;rc));
    if ((rc) == (0))
    {
        long max = (long)(0x7fff0000);
        sqlite3OsFileControlHint(ppFd, (int)(18), (void*)(&amp;max));
        if ((nExtend) &gt; (0))
        {
            vdbeSorterExtendFile(db, ppFd, (long)(nExtend));
        }
    }

    return (int)(rc);
}</function>
  <function>public static void vdbeSorterRecordFree(sqlite3 db, SorterRecord* pRecord)
{
    SorterRecord* p;
    SorterRecord* pNext;
    for (p = pRecord; p; p = pNext)
    {
        pNext = p-&gt;u.pNext;
        sqlite3DbFree(db, p);
    }
}</function>
  <function>public static void* vdbeSorterRowkey(VdbeSorter pSorter, int* pnKey)
{
    void* pKey;
    if ((pSorter.bUsePMA) != 0)
    {
        PmaReader pReader;
        if ((pSorter.bUseThreads) != 0)
        {
            pReader = pSorter.pReader;
        }
        else
        {
            pReader = pSorter.pMerger.aReadr[pSorter.pMerger.aTree[1]];
        }

        *pnKey = (int)(pReader.nKey);
        pKey = pReader.aKey;
    }
    else
    {
        *pnKey = (int)(pSorter.list.pList-&gt;nVal);
        pKey = ((void*)((pSorter.list.pList) + 1));
    }

    return pKey;
}</function>
  <function>public static int vdbeSorterSetupMerge(VdbeSorter pSorter)
{
    int rc = 0;
    SortSubtask pTask0 = pSorter.aTask[0];
    MergeEngine pMain = null;
    sqlite3 db = pTask0.pSorter.db;
    int i = 0;
    delegate80 xCompare = vdbeSorterGetCompare(pSorter);
    for (i = (int)(0); (i) &lt; (pSorter.nTask); i++)
    {
        pSorter.aTask[i].xCompare = xCompare;
    }

    rc = (int)(vdbeSorterMergeTreeBuild(pSorter, pMain));
    if ((rc) == (0))
    {
        if ((pSorter.bUseThreads) != 0)
        {
            int iTask = 0;
            PmaReader pReadr = null;
            SortSubtask pLast = pSorter.aTask[pSorter.nTask - 1];
            rc = (int)(vdbeSortAllocUnpacked(pLast));
            if ((rc) == (0))
            {
                pReadr = (PmaReader)(sqlite3DbMallocZero(db, (ulong)(sizeof(PmaReader))));
                pSorter.pReader = pReadr;
                if ((pReadr) == (null))
                    rc = (int)(7);
            }

            if ((rc) == (0))
            {
                rc = (int)(vdbeIncrMergerNew(pLast, pMain, pReadr.pIncr));
                if ((rc) == (0))
                {
                    vdbeIncrMergerSetThreads(pReadr.pIncr);
                    for (iTask = (int)(0); (iTask) &lt; (pSorter.nTask - 1); iTask++)
                    {
                        IncrMerger pIncr;
                        if ((pIncr = pMain.aReadr[iTask].pIncr))
                        {
                            vdbeIncrMergerSetThreads(pIncr);
                        }
                    }

                    for (iTask = (int)(0); ((rc) == (0)) &amp;&amp; ((iTask) &lt; (pSorter.nTask)); iTask++)
                    {
                        PmaReader p = pMain.aReadr[iTask];
                        rc = (int)(vdbePmaReaderIncrInit(p, (int)(1)));
                    }
                }

                pMain = null;
            }

            if ((rc) == (0))
            {
                rc = (int)(vdbePmaReaderIncrMergeInit(pReadr, (int)(2)));
            }
        }
        else
        {
            rc = (int)(vdbeMergeEngineInit(pTask0, pMain, (int)(0)));
            pSorter.pMerger = pMain;
            pMain = null;
        }
    }

    if (rc != 0)
    {
        vdbeMergeEngineFree(pMain);
    }

    return (int)(rc);
}</function>
  <function>public static int vdbeSorterSort(SortSubtask pTask, SorterList* pList)
{
    int i = 0;
    SorterRecord* p;
    int rc = 0;
    SorterRecord** aSlot = stackalloc SorterRecord[64];
    rc = (int)(vdbeSortAllocUnpacked(pTask));
    if (rc != 0)
        return (int)(rc);
    p = pList-&gt;pList;
    pTask.xCompare = vdbeSorterGetCompare(pTask.pSorter);
    CRuntime.memset(aSlot, (int)(0), (ulong)(64 * sizeof(SorterRecord)));
    while ((p) != null)
    {
        SorterRecord* pNext;
        if ((pList-&gt;aMemory) != null)
        {
            if (((byte*)(p)) == (pList-&gt;aMemory))
            {
                pNext = null;
            }
            else
            {
                pNext = (SorterRecord*)(&amp;pList-&gt;aMemory[p-&gt;u.iNext]);
            }
        }
        else
        {
            pNext = p-&gt;u.pNext;
        }

        p-&gt;u.pNext = null;
        for (i = (int)(0); aSlot[i]; i++)
        {
            p = vdbeSorterMerge(pTask, p, aSlot[i]);
            aSlot[i] = null;
        }

        aSlot[i] = p;
        p = pNext;
    }

    p = null;
    for (i = (int)(0); (i) &lt; ((int)(64 * sizeof(SorterRecord) / sizeof(SorterRecord*))); i++)
    {
        if ((aSlot[i]) == (null))
            continue;
        p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
    }

    pList-&gt;pList = p;
    return (int)(pTask.pUnpacked.errCode);
}</function>
  <function>public static int vdbeSorterTreeDepth(int nPMA)
{
    int nDepth = (int)(0);
    long nDiv = (long)(16);
    while ((nDiv) &lt; ((long)(nPMA)))
    {
        nDiv = (long)(nDiv * 16);
        nDepth++;
    }

    return (int)(nDepth);
}</function>
  <function>public static void vdbeSortSubtaskCleanup(sqlite3 db, SortSubtask pTask)
{
    sqlite3DbFree(db, pTask.pUnpacked);
    if ((pTask.list.aMemory) != null)
    {
        sqlite3_free(pTask.list.aMemory);
    }
    else
    {
        vdbeSorterRecordFree(null, pTask.list.pList);
    }

    if ((pTask.file.pFd) != null)
    {
        sqlite3OsCloseFree(pTask.file.pFd);
    }

    if ((pTask.file2.pFd) != null)
    {
        sqlite3OsCloseFree(pTask.file2.pFd);
    }

    CRuntime.memset(pTask, (int)(0), (ulong)(sizeof(SortSubtask)));
}</function>
  <function>public static int vdbeUnbind(Vdbe p, int i)
{
    sqlite3_value pVar;
    if ((vdbeSafetyNotNull(p)) != 0)
    {
        return (int)(sqlite3MisuseError((int)(86472)));
    }

    sqlite3_mutex_enter(p.db.mutex);
    if ((p.iVdbeMagic != 0x2df20da3) || ((p.pc) &gt;= (0)))
    {
        sqlite3Error(p.db, (int)(21));
        sqlite3_mutex_leave(p.db.mutex);
        sqlite3_log((int)(21), "bind on a busy prepared statement: [%s]", p.zSql);
        return (int)(sqlite3MisuseError((int)(86480)));
    }

    if (((i) &lt; (1)) || ((i) &gt; (p.nVar)))
    {
        sqlite3Error(p.db, (int)(25));
        sqlite3_mutex_leave(p.db.mutex);
        return (int)(25);
    }

    i--;
    pVar = p.aVar[i];
    sqlite3VdbeMemRelease(pVar);
    pVar.flags = (ushort)(0x0001);
    p.db.errCode = (int)(0);
    if ((p.expmask != 0) &amp;&amp; ((p.expmask &amp; ((i) &gt;= (31) ? 0x80000000 : (uint)(1) &lt;&lt; i)) != 0))
    {
        p.expired = (uint)(1);
    }

    return (int)(0);
}</function>
  <function>public static void versionFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
{
    sqlite3_result_text(context, sqlite3_libversion(), (int)(-1), null);
}</function>
  <function>public static void vfsUnlink(sqlite3_vfs pVfs)
{
    if ((pVfs) == (null))
    {
    }
    else if ((vfsList) == (pVfs))
    {
        vfsList = pVfs.pNext;
    }
    else if ((vfsList) != null)
    {
        sqlite3_vfs p = vfsList;
        while (((p.pNext) != null) &amp;&amp; (p.pNext != pVfs))
        {
            p = p.pNext;
        }

        if ((p.pNext) == (pVfs))
        {
            p.pNext = pVfs.pNext;
        }
    }
}</function>
  <function>public static int vtabBestIndex(Parse pParse, Table pTab, sqlite3_index_info* p)
{
    sqlite3_vtab pVtab = sqlite3GetVTable(pParse.db, pTab).pVtab;
    int rc = 0;
    pParse.db.nSchemaLock++;
    rc = (int)(pVtab.pModule.xBestIndex(pVtab, p));
    pParse.db.nSchemaLock--;
    if ((rc != 0) &amp;&amp; (rc != 19))
    {
        if ((rc) == (7))
        {
            sqlite3OomFault(pParse.db);
        }
        else if (pVtab.zErrMsg == null)
        {
            sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr((int)(rc)));
        }
        else
        {
            sqlite3ErrorMsg(pParse, "%s", pVtab.zErrMsg);
        }
    }

    sqlite3_free(pVtab.zErrMsg);
    pVtab.zErrMsg = null;
    return (int)(rc);
}</function>
  <function>public static int vtabCallConstructor(sqlite3 db, Table pTab, Module pMod, delegate21 xConstruct, sbyte** pzErr)
{
    VtabCtx sCtx = new VtabCtx();
    VTable pVTable;
    int rc = 0;
    sbyte** azArg;
    int nArg = (int)(pTab.u.vtab.nArg);
    sbyte* zErr = null;
    sbyte* zModuleName;
    int iDb = 0;
    VtabCtx pCtx;
    azArg = pTab.u.vtab.azArg;
    for (pCtx = db.pVtabCtx; pCtx; pCtx = pCtx.pPrior)
    {
        if ((pCtx.pTab) == (pTab))
        {
            *pzErr = sqlite3MPrintf(db, "vtable constructor called recursively: %s", pTab.zName);
            return (int)(6);
        }
    }

    zModuleName = sqlite3DbStrDup(db, pTab.zName);
    if (zModuleName == null)
    {
        return (int)(7);
    }

    pVTable = sqlite3MallocZero((ulong)(sizeof(VTable)));
    if (pVTable == null)
    {
        sqlite3OomFault(db);
        sqlite3DbFree(db, zModuleName);
        return (int)(7);
    }

    pVTable.db = db;
    pVTable.pMod = pMod;
    pVTable.eVtabRisk = (byte)(1);
    iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
    pTab.u.vtab.azArg[1] = db.aDb[iDb].zDbSName;
    sCtx.pTab = pTab;
    sCtx.pVTable = pVTable;
    sCtx.pPrior = db.pVtabCtx;
    sCtx.bDeclared = (int)(0);
    db.pVtabCtx = sCtx;
    rc = (int)(xConstruct(db, pMod.pAux, (int)(nArg), azArg, pVTable.pVtab, &amp;zErr));
    db.pVtabCtx = sCtx.pPrior;
    if ((rc) == (7))
        sqlite3OomFault(db);
    if (0 != rc)
    {
        if ((zErr) == (null))
        {
            *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
        }
        else
        {
            *pzErr = sqlite3MPrintf(db, "%s", zErr);
            sqlite3_free(zErr);
        }

        sqlite3DbFree(db, pVTable);
    }
    else if ((pVTable.pVtab) != null)
    {
        CRuntime.memset(pVTable.pVtab, (int)(0), (ulong)(sizeof(sqlite3_vtab)));
        pVTable.pVtab.pModule = pMod.pModule;
        pMod.nRefModule++;
        pVTable.nRef = (int)(1);
        if ((sCtx.bDeclared) == (0))
        {
            sbyte* zFormat = "vtable constructor did not declare schema: %s";
            *pzErr = sqlite3MPrintf(db, zFormat, pTab.zName);
            sqlite3VtabUnlock(pVTable);
            rc = (int)(1);
        }
        else
        {
            int iCol = 0;
            ushort oooHidden = (ushort)(0);
            pVTable.pNext = pTab.u.vtab.p;
            pTab.u.vtab.p = pVTable;
            for (iCol = (int)(0); (iCol) &lt; (pTab.nCol); iCol++)
            {
                sbyte* zType = sqlite3ColumnType(&amp;pTab.aCol[iCol], "");
                int nType = 0;
                int i = (int)(0);
                nType = (int)(sqlite3Strlen30(zType));
                for (i = (int)(0); (i) &lt; (nType); i++)
                {
                    if ((((0) == (sqlite3_strnicmp("hidden", &amp;zType[i], (int)(6)))) &amp;&amp; (((i) == (0)) || ((zType[i - 1]) == (32)))) &amp;&amp; (((zType[i + 6]) == (0)) || ((zType[i + 6]) == (32))))
                    {
                        break;
                    }
                }

                if ((i) &lt; (nType))
                {
                    int j = 0;
                    int nDel = (int)(6 + ((zType[i + 6]) != 0 ? 1 : 0));
                    for (j = (int)(i); (j + nDel) &lt;= (nType); j++)
                    {
                        zType[j] = (sbyte)(zType[j + nDel]);
                    }

                    if (((zType[i]) == (0)) &amp;&amp; ((i) &gt; (0)))
                    {
                        zType[i - 1] = (sbyte)(0);
                    }

                    pTab.aCol[iCol].colFlags |= (ushort)(0x0002);
                    pTab.tabFlags |= (uint)(0x00000002);
                    oooHidden = (ushort)(0x00000400);
                }
                else
                {
                    pTab.tabFlags |= (uint)(oooHidden);
                }
            }
        }
    }

    sqlite3DbFree(db, zModuleName);
    return (int)(rc);
}</function>
  <function>public static VTable vtabDisconnectAll(sqlite3 db, Table p)
{
    VTable pRet = null;
    VTable pVTable;
    pVTable = p.u.vtab.p;
    p.u.vtab.p = null;
    while ((pVTable) != null)
    {
        sqlite3 db2 = pVTable.db;
        VTable pNext = pVTable.pNext;
        if ((db2) == (db))
        {
            pRet = pVTable;
            p.u.vtab.p = pRet;
            pRet.pNext = null;
        }
        else
        {
            pVTable.pNext = db2.pDisconnect;
            db2.pDisconnect = pVTable;
        }

        pVTable = pNext;
    }

    return pRet;
}</function>
  <function>public static int walBeginShmUnreliable(Wal pWal, int* pChanged)
{
    long szWal = 0;
    long iOffset = 0;
    byte* aBuf = stackalloc byte[32];
    byte* aFrame = null;
    int szFrame = 0;
    byte* aData;
    void* pDummy;
    int rc = 0;
    uint* aSaveCksum = stackalloc uint[2];
    rc = (int)(walLockShared(pWal, (int)(3 + (0))));
    if (rc != 0)
    {
        if ((rc) == (5))
            rc = (int)(-1);
        goto begin_unreliable_shm_out;
    }

    pWal.readLock = (short)(0);
    rc = (int)(sqlite3OsShmMap(pWal.pDbFd, (int)(0), (int)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)), (int)(0), &amp;pDummy));
    if (rc != (8 | (5 &lt;&lt; 8)))
    {
        rc = (int)((rc) == (8) ? (-1) : rc);
        goto begin_unreliable_shm_out;
    }

    CRuntime.memcpy(&amp;pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr)));
    rc = (int)(sqlite3OsFileSize(pWal.pWalFd, &amp;szWal));
    if (rc != 0)
    {
        goto begin_unreliable_shm_out;
    }

    if ((szWal) &lt; (32))
    {
        *pChanged = (int)(1);
        rc = (int)((pWal.hdr.mxFrame) == (0) ? 0 : (-1));
        goto begin_unreliable_shm_out;
    }

    rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(32), (long)(0)));
    if (rc != 0)
    {
        goto begin_unreliable_shm_out;
    }

    if ((memcmp(&amp;pWal.hdr.aSalt, &amp;aBuf[16], (ulong)(8))) != 0)
    {
        rc = (int)(-1);
        goto begin_unreliable_shm_out;
    }

    szFrame = (int)(pWal.szPage + 24);
    aFrame = (byte*)(sqlite3_malloc64((ulong)(szFrame)));
    if ((aFrame) == (null))
    {
        rc = (int)(7);
        goto begin_unreliable_shm_out;
    }

    aData = &amp;aFrame[24];
    aSaveCksum[0] = (uint)(pWal.hdr.aFrameCksum[0]);
    aSaveCksum[1] = (uint)(pWal.hdr.aFrameCksum[1]);
    for (iOffset = (long)(32 + ((pWal.hdr.mxFrame + 1) - 1) * (long)((pWal.szPage) + 24)); (iOffset + szFrame) &lt;= (szWal); iOffset += (long)(szFrame))
    {
        uint pgno = 0;
        uint nTruncate = 0;
        rc = (int)(sqlite3OsRead(pWal.pWalFd, aFrame, (int)(szFrame), (long)(iOffset)));
        if (rc != 0)
            break;
        if (walDecodeFrame(pWal, &amp;pgno, &amp;nTruncate, aData, aFrame) == 0)
            break;
        if ((nTruncate) != 0)
        {
            rc = (int)(-1);
            break;
        }
    }

    pWal.hdr.aFrameCksum[0] = (uint)(aSaveCksum[0]);
    pWal.hdr.aFrameCksum[1] = (uint)(aSaveCksum[1]);
    begin_unreliable_shm_out:
        ; sqlite3_free ( aFrame ) ; 
    if (rc != 0)
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pWal.nWiData); i++)
        {
            sqlite3_free((void*)(pWal.apWiData[i]));
            pWal.apWiData[i] = null;
        }

        pWal.bShmUnreliable = (byte)(0);
        sqlite3WalEndReadTransaction(pWal);
        *pChanged = (int)(1);
    }

    return (int)(rc);
}</function>
  <function>public static int walBusyLock(Wal pWal, delegate19 xBusy, void* pBusyArg, int lockIdx, int n)
{
    int rc = 0;
    do
    {
        rc = (int)(walLockExclusive(pWal, (int)(lockIdx), (int)(n)));
    }
    while ((((xBusy) != null) &amp;&amp; ((rc) == (5))) &amp;&amp; ((xBusy(pBusyArg)) != 0));
    return (int)(rc);
}</function>
  <function>public static int walCheckpoint(Wal pWal, sqlite3 db, int eMode, delegate19 xBusy, void* pBusyArg, int sync_flags, byte* zBuf)
{
    int rc = (int)(0);
    int szPage = 0;
    WalIterator pIter = null;
    uint iDbpage = (uint)(0);
    uint iFrame = (uint)(0);
    uint mxSafeFrame = 0;
    uint mxPage = 0;
    int i = 0;
    volatile WalCkptInfo* pInfo;
    szPage = (int)(walPagesize(pWal));
    pInfo = walCkptInfo(pWal);
    if ((pInfo-&gt;nBackfill) &lt; (pWal.hdr.mxFrame))
    {
        mxSafeFrame = (uint)(pWal.hdr.mxFrame);
        mxPage = (uint)(pWal.hdr.nPage);
        for (i = (int)(1); (i) &lt; (8 - 3); i++)
        {
            uint y = (uint)(0);
            if ((mxSafeFrame) &gt; (y))
            {
                rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (i)), (int)(1)));
                if ((rc) == (0))
                {
                    uint iMark = (uint)((i) == (1) ? mxSafeFrame : 0xffffffff);
                    (iMark);
                    walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1));
                }
                else if ((rc) == (5))
                {
                    mxSafeFrame = (uint)(y);
                    xBusy = null;
                }
                else
                {
                    goto walcheckpoint_out;
                }
            }
        }

        if ((pInfo-&gt;nBackfill) &lt; (mxSafeFrame))
        {
            rc = (int)(walIteratorInit(pWal, (uint)(pInfo-&gt;nBackfill), pIter));
        }

        if (((pIter) != null) &amp;&amp; ((rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (0)), (int)(1)))) == (0)))
        {
            uint nBackfill = (uint)(pInfo-&gt;nBackfill);
            pInfo-&gt;nBackfillAttempted = (uint)(mxSafeFrame);
            rc = (int)(sqlite3OsSync(pWal.pWalFd, (int)(((sync_flags) &gt;&gt; 2) &amp; 0x03)));
            if ((rc) == (0))
            {
                long nReq = (long)((long)(mxPage) * szPage);
                long nSize = 0;
                sqlite3OsFileControl(pWal.pDbFd, (int)(39), null);
                rc = (int)(sqlite3OsFileSize(pWal.pDbFd, &amp;nSize));
                if (((rc) == (0)) &amp;&amp; ((nSize) &lt; (nReq)))
                {
                    if ((nSize + 65536 + (long)(pWal.hdr.mxFrame) * szPage) &lt; (nReq))
                    {
                        rc = (int)(sqlite3CorruptError((int)(63077)));
                    }
                    else
                    {
                        sqlite3OsFileControlHint(pWal.pDbFd, (int)(5), &amp;nReq);
                    }
                }
            }

            while (((rc) == (0)) &amp;&amp; ((0) == (walIteratorNext(pIter, &amp;iDbpage, &amp;iFrame))))
            {
                long iOffset = 0;
                if ((0) != 0)
                {
                    rc = (int)((db.mallocFailed) != 0 ? 7 : 9);
                    break;
                }

                if ((((iFrame) &lt;= (nBackfill)) || ((iFrame) &gt; (mxSafeFrame))) || ((iDbpage) &gt; (mxPage)))
                {
                    continue;
                }

                iOffset = (long)((32 + ((iFrame) - 1) * (long)((szPage) + 24)) + 24);
                rc = (int)(sqlite3OsRead(pWal.pWalFd, zBuf, (int)(szPage), (long)(iOffset)));
                if (rc != 0)
                    break;
                iOffset = (long)((iDbpage - 1) * (long)(szPage));
                rc = (int)(sqlite3OsWrite(pWal.pDbFd, zBuf, (int)(szPage), (long)(iOffset)));
                if (rc != 0)
                    break;
            }

            sqlite3OsFileControl(pWal.pDbFd, (int)(37), null);
            if ((rc) == (0))
            {
                if ((mxSafeFrame) == (walIndexHdr(pWal)-&gt;mxFrame))
                {
                    long szDb = (long)(pWal.hdr.nPage * (long)(szPage));
                    rc = (int)(sqlite3OsTruncate(pWal.pDbFd, (long)(szDb)));
                    if ((rc) == (0))
                    {
                        rc = (int)(sqlite3OsSync(pWal.pDbFd, (int)(((sync_flags) &gt;&gt; 2) &amp; 0x03)));
                    }
                }

                if ((rc) == (0))
                {
                    (mxSafeFrame);
                }
            }

            walUnlockExclusive(pWal, (int)(3 + (0)), (int)(1));
        }

        if ((rc) == (5))
        {
            rc = (int)(0);
        }
    }

    if (((rc) == (0)) &amp;&amp; (eMode != 0))
    {
        if ((pInfo-&gt;nBackfill) &lt; (pWal.hdr.mxFrame))
        {
            rc = (int)(5);
        }
        else if ((eMode) &gt;= (2))
        {
            uint salt1 = 0;
            sqlite3_randomness((int)(4), &amp;salt1);
            rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (1)), (int)((8 - 3) - 1)));
            if ((rc) == (0))
            {
                if ((eMode) == (3))
                {
                    walRestartHdr(pWal, (uint)(salt1));
                    rc = (int)(sqlite3OsTruncate(pWal.pWalFd, (long)(0)));
                }

                walUnlockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1));
            }
        }
    }

    walcheckpoint_out:
        ; walIteratorFree ( pIter ) ; 
    return (int)(rc);
}</function>
  <function>public static void walChecksumBytes(int nativeCksum, byte* a, int nByte, uint* aIn, uint* aOut)
{
    uint s1 = 0; uint  s2  =  0 ; 
    uint* aData = (uint*)(a);
    uint* aEnd = (uint*)(&amp;a[nByte]);
    if ((aIn) != null)
    {
        s1 = (uint)(aIn[0]);
        s2 = (uint)(aIn[1]);
    }
    else
    {
        s1 = (uint)(s2 = (uint)(0));
    }

    if ((nativeCksum) != 0)
    {
        do
        {
            s1 += (uint)(*aData++ + s2);
            s2 += (uint)(*aData++ + s1);
        }
        while ((aData) &lt; (aEnd));
    }
    else
    {
        do
        {
            s1 += (uint)(((((aData[0]) &amp; 0x000000FF) &lt;&lt; 24) + (((aData[0]) &amp; 0x0000FF00) &lt;&lt; 8) + (((aData[0]) &amp; 0x00FF0000) &gt;&gt; 8) + (((aData[0]) &amp; 0xFF000000) &gt;&gt; 24)) + s2);
            s2 += (uint)(((((aData[1]) &amp; 0x000000FF) &lt;&lt; 24) + (((aData[1]) &amp; 0x0000FF00) &lt;&lt; 8) + (((aData[1]) &amp; 0x00FF0000) &gt;&gt; 8) + (((aData[1]) &amp; 0xFF000000) &gt;&gt; 24)) + s1);
            aData += 2;
        }
        while ((aData) &lt; (aEnd));
    }

    aOut[0] = (uint)(s1);
    aOut[1] = (uint)(s2);
}</function>
  <function>public static  volatile  WalCkptInfo * walCkptInfo(Wal pWal)
{
    return ( volatile  WalCkptInfo * ) ( &amp; ( pWal . apWiData [ 0 ] [ sizeof ( WalIndexHdr ) / 2 ] ) ) ; 
}</function>
  <function>public static void walCleanupHash(Wal pWal)
{
    WalHashLoc sLoc = new WalHashLoc();
    int iLimit = (int)(0);
    int nByte = 0;
    int i = 0;
    if ((pWal.hdr.mxFrame) == (0))
        return;
    i = (int)(walHashGet(pWal, (int)(walFramePage((uint)(pWal.hdr.mxFrame))), &amp;sLoc));
    if ((i) != 0)
        return;
    iLimit = (int)(pWal.hdr.mxFrame - sLoc.iZero);
    for (i = (int)(0); (i) &lt; (4096 * 2); i++)
    {
        if ((sLoc.aHash[i]) &gt; (iLimit))
        {
            sLoc.aHash[i] = (ushort)(0);
        }
    }

    nByte = ((int)((sbyte*)(sLoc.aHash) - (sbyte*)(&amp;sLoc.aPgno[iLimit])));
    CRuntime.memset((void*)(&amp;sLoc.aPgno[iLimit]), (int)(0), (ulong)(nByte));
}</function>
  <function>public static int walDecodeFrame(Wal pWal, uint* piPage, uint* pnTruncate, byte* aData, byte* aFrame)
{
    int nativeCksum = 0;
    uint* aCksum = pWal.hdr.aFrameCksum;
    uint pgno = 0;
    if (memcmp(&amp;pWal.hdr.aSalt, &amp;aFrame[8], (ulong)(8)) != 0)
    {
        return (int)(0);
    }

    pgno = (uint)(sqlite3Get4byte(&amp;aFrame[0]));
    if ((pgno) == (0))
    {
        return (int)(0);
    }

    nativeCksum = (int)((pWal.hdr.bigEndCksum) == (0) ? 1 : 0);
    walChecksumBytes((int)(nativeCksum), aFrame, (int)(8), aCksum, aCksum);
    walChecksumBytes((int)(nativeCksum), aData, (int)(pWal.szPage), aCksum, aCksum);
    if ((aCksum[0] != sqlite3Get4byte(&amp;aFrame[16])) || (aCksum[1] != sqlite3Get4byte(&amp;aFrame[20])))
    {
        return (int)(0);
    }

    *piPage = (uint)(pgno);
    *pnTruncate = (uint)(sqlite3Get4byte(&amp;aFrame[4]));
    return (int)(1);
}</function>
  <function>public static void walEncodeFrame(Wal pWal, uint iPage, uint nTruncate, byte* aData, byte* aFrame)
{
    int nativeCksum = 0;
    uint* aCksum = pWal.hdr.aFrameCksum;
    sqlite3Put4byte(&amp;aFrame[0], (uint)(iPage));
    sqlite3Put4byte(&amp;aFrame[4], (uint)(nTruncate));
    if ((pWal.iReCksum) == (0))
    {
        CRuntime.memcpy(&amp;aFrame[8], pWal.hdr.aSalt, (ulong)(8));
        nativeCksum = (int)((pWal.hdr.bigEndCksum) == (0) ? 1 : 0);
        walChecksumBytes((int)(nativeCksum), aFrame, (int)(8), aCksum, aCksum);
        walChecksumBytes((int)(nativeCksum), aData, (int)(pWal.szPage), aCksum, aCksum);
        sqlite3Put4byte(&amp;aFrame[16], (uint)(aCksum[0]));
        sqlite3Put4byte(&amp;aFrame[20], (uint)(aCksum[1]));
    }
    else
    {
        CRuntime.memset(&amp;aFrame[8], (int)(0), (ulong)(16));
    }
}</function>
  <function>public static int walFramePage(uint iFrame)
{
    int iHash = (int)((iFrame + 4096 - (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) - 1) / 4096);
    return (int)(iHash);
}</function>
  <function>public static uint walFramePgno(Wal pWal, uint iFrame)
{
    int iHash = (int)(walFramePage((uint)(iFrame)));
    if ((iHash) == (0))
    {
        return (uint)(pWal.apWiData[0][(sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint) + iFrame - 1]);
    }

    return (uint)(pWal.apWiData[iHash][(iFrame - 1 - (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint)))) % 4096]);
}</function>
  <function>public static int walHash(uint iPage)
{
    return (int)((iPage * 383) &amp; ((4096 * 2) - 1));
}</function>
  <function>public static int walHashGet(Wal pWal, int iHash, WalHashLoc* pLoc)
{
    int rc = 0;
    rc = (int)(walIndexPage(pWal, (int)(iHash), &amp;pLoc-&gt;aPgno));
    if ((pLoc-&gt;aPgno) != null)
    {
        pLoc-&gt;aHash = (ushort*)(&amp;pLoc-&gt;aPgno[4096]);
        if ((iHash) == (0))
        {
            pLoc-&gt;aPgno = &amp;pLoc-&gt;aPgno[(sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint)];
            pLoc-&gt;iZero = (uint)(0);
        }
        else
        {
            pLoc-&gt;iZero = (uint)((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + (iHash - 1) * 4096);
        }
    }
    else if (((rc) == (0)))
    {
        rc = (int)(1);
    }

    return (int)(rc);
}</function>
  <function>public static int walIndexAppend(Wal pWal, uint iFrame, uint iPage)
{
    int rc = 0;
    WalHashLoc sLoc = new WalHashLoc();
    rc = (int)(walHashGet(pWal, (int)(walFramePage((uint)(iFrame))), &amp;sLoc));
    if ((rc) == (0))
    {
        int iKey = 0;
        int idx = 0;
        int nCollide = 0;
        idx = (int)(iFrame - sLoc.iZero);
        if ((idx) == (1))
        {
            int nByte = (int)((byte*)(&amp;sLoc.aHash[(4096 * 2)]) - (byte*)(sLoc.aPgno));
            CRuntime.memset((void*)(sLoc.aPgno), (int)(0), (ulong)(nByte));
        }

        if ((sLoc.aPgno[idx - 1]) != 0)
        {
            walCleanupHash(pWal);
        }

        nCollide = (int)(idx);
        for (iKey = (int)(walHash((uint)(iPage))); sLoc.aHash[iKey]; iKey = (int)(walNextHash((int)(iKey))))
        {
            if ((nCollide--) == (0))
                return (int)(sqlite3CorruptError((int)(62131)));
        }

        sLoc.aPgno[idx - 1] = (uint)(iPage);
        ((ushort)(idx));
    }

    return (int)(rc);
}</function>
  <function>public static void walIndexClose(Wal pWal, int isDelete)
{
    if (((pWal.exclusiveMode) == (2)) || ((pWal.bShmUnreliable) != 0))
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; (pWal.nWiData); i++)
        {
            sqlite3_free((void*)(pWal.apWiData[i]));
            pWal.apWiData[i] = null;
        }
    }

    if (pWal.exclusiveMode != 2)
    {
        sqlite3OsShmUnmap(pWal.pDbFd, (int)(isDelete));
    }
}</function>
  <function>public static  volatile  WalIndexHdr * walIndexHdr(Wal pWal)
{
    return ( volatile  WalIndexHdr * ) ( pWal . apWiData [ 0 ] ) ; 
}</function>
  <function>public static int walIndexPage(Wal pWal, int iPage, uint** ppPage)
{
    if (((pWal.nWiData) &lt;= (iPage)) || ((*ppPage = pWal.apWiData[iPage]) == (null)))
    {
        return (int)(walIndexPageRealloc(pWal, (int)(iPage), ppPage));
    }

    return (int)(0);
}</function>
  <function>public static int walIndexPageRealloc(Wal pWal, int iPage, uint** ppPage)
{
    int rc = (int)(0);
    if ((pWal.nWiData) &lt;= (iPage))
    {
        long nByte = (long)(sizeof(uint) * (iPage + 1));
        uint** apNew;
        apNew = (uint**)(sqlite3Realloc((void*)(pWal.apWiData), (ulong)(nByte)));
        if (apNew == null)
        {
            *ppPage = null;
            return (int)(7);
        }

        CRuntime.memset((void*)(&amp;apNew[pWal.nWiData]), (int)(0), (ulong)(sizeof(uint) * (iPage + 1 - pWal.nWiData)));
        pWal.apWiData = apNew;
        pWal.nWiData = (int)(iPage + 1);
    }

    if ((pWal.exclusiveMode) == (2))
    {
        pWal.apWiData[iPage] = (uint*)(sqlite3MallocZero((ulong)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint))));
        if (pWal.apWiData[iPage] == null)
            rc = (int)(7);
    }
    else
    {
        rc = (int)(sqlite3OsShmMap(pWal.pDbFd, (int)(iPage), (int)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)), (int)(pWal.writeLock), (void**)(&amp;pWal.apWiData[iPage])));
        if ((rc) == (0))
        {
            if (((iPage) &gt; (0)) &amp;&amp; ((sqlite3FaultSim((int)(600))) != 0))
                rc = (int)(7);
        }
        else if ((rc &amp; 0xff) == (8))
        {
            pWal.readOnly |= (byte)(2);
            if ((rc) == (8))
            {
                rc = (int)(0);
            }
        }
    }

    *ppPage = pWal.apWiData[iPage];
    return (int)(rc);
}</function>
  <function>public static int walIndexReadHdr(Wal pWal, int* pChanged)
{
    int rc = 0;
    int badHdr = 0;
    uint* page0;
    rc = (int)(walIndexPage(pWal, (int)(0), &amp;page0));
    if (rc != 0)
    {
        if ((rc) == (8 | (5 &lt;&lt; 8)))
        {
            pWal.bShmUnreliable = (byte)(1);
            pWal.exclusiveMode = (byte)(2);
            *pChanged = (int)(1);
        }
        else
        {
            return (int)(rc);
        }
    }
    else
    {
    }

    badHdr = (int)((page0) != 0 ? walIndexTryHdr(pWal, pChanged) : 1);
    if ((badHdr) != 0)
    {
        if (((pWal.bShmUnreliable) == (0)) &amp;&amp; ((pWal.readOnly &amp; 2) != 0))
        {
            if ((0) == (rc = (int)(walLockShared(pWal, (int)(0)))))
            {
                walUnlockShared(pWal, (int)(0));
                rc = (int)(8 | (1 &lt;&lt; 8));
            }
        }
        else
        {
            int bWriteLock = (int)(pWal.writeLock);
            if (((bWriteLock) != 0) || ((0) == (rc = (int)(walLockExclusive((pWal), (int)(0), (int)(1))))))
            {
                pWal.writeLock = (byte)(1);
                if ((0) == (rc = (int)(walIndexPage(pWal, (int)(0), &amp;page0))))
                {
                    badHdr = (int)(walIndexTryHdr(pWal, pChanged));
                    if ((badHdr) != 0)
                    {
                        rc = (int)(walIndexRecover(pWal));
                        *pChanged = (int)(1);
                    }
                }

                if ((bWriteLock) == (0))
                {
                    pWal.writeLock = (byte)(0);
                    walUnlockExclusive(pWal, (int)(0), (int)(1));
                }
            }
        }
    }

    if (((badHdr) == (0)) &amp;&amp; (pWal.hdr.iVersion != 3007000))
    {
        rc = (int)(sqlite3CantopenError((int)(63426)));
    }

    if ((pWal.bShmUnreliable) != 0)
    {
        if (rc != 0)
        {
            walIndexClose(pWal, (int)(0));
            pWal.bShmUnreliable = (byte)(0);
            if ((rc) == (10 | (2 &lt;&lt; 8)))
                rc = (int)(-1);
        }

        pWal.exclusiveMode = (byte)(0);
    }

    return (int)(rc);
}</function>
  <function>public static int walIndexRecover(Wal pWal)
{
    int rc = 0;
    long nSize = 0;
    uint* aFrameCksum = stackalloc uint[]{0, 0};
    int iLock = 0;
    iLock = (int)(1 + pWal.ckptLock);
    rc = (int)(walLockExclusive(pWal, (int)(iLock), (int)((3 + (0)) - iLock)));
    if ((rc) != 0)
    {
        return (int)(rc);
    }

    CRuntime.memset(&amp;pWal.hdr, (int)(0), (ulong)(sizeof(WalIndexHdr)));
    rc = (int)(sqlite3OsFileSize(pWal.pWalFd, &amp;nSize));
    if (rc != 0)
    {
        goto recovery_error;
    }

    if ((nSize) &gt; (32))
    {
        byte* aBuf = stackalloc byte[32];
        uint* aPrivate = null;
        byte* aFrame = null;
        int szFrame = 0;
        byte* aData;
        int szPage = 0;
        uint magic = 0;
        uint version = 0;
        int isValid = 0;
        uint iPg = 0;
        uint iLastFrame = 0;
        rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(32), (long)(0)));
        if (rc != 0)
        {
            goto recovery_error;
        }

        magic = (uint)(sqlite3Get4byte(&amp;aBuf[0]));
        szPage = (int)(sqlite3Get4byte(&amp;aBuf[8]));
        if (((((magic &amp; 0xFFFFFFFE) != 0x377f0682) || ((szPage &amp; (szPage - 1)) != 0)) || ((szPage) &gt; (65536))) || ((szPage) &lt; (512)))
        {
            goto finished;
        }

        pWal.hdr.bigEndCksum = ((byte)(magic &amp; 0x00000001));
        pWal.szPage = (uint)(szPage);
        pWal.nCkpt = (uint)(sqlite3Get4byte(&amp;aBuf[12]));
        CRuntime.memcpy(&amp;pWal.hdr.aSalt, &amp;aBuf[16], (ulong)(8));
        walChecksumBytes(((pWal.hdr.bigEndCksum) == (0) ? 1 : 0), aBuf, (int)(32 - 2 * 4), null, pWal.hdr.aFrameCksum);
        if ((pWal.hdr.aFrameCksum[0] != sqlite3Get4byte(&amp;aBuf[24])) || (pWal.hdr.aFrameCksum[1] != sqlite3Get4byte(&amp;aBuf[28])))
        {
            goto finished;
        }

        version = (uint)(sqlite3Get4byte(&amp;aBuf[4]));
        if (version != 3007000)
        {
            rc = (int)(sqlite3CantopenError((int)(62263)));
            goto finished;
        }

        szFrame = (int)(szPage + 24);
        aFrame = (byte*)(sqlite3_malloc64((ulong)(szFrame + (sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)))));
        if (aFrame == null)
        {
            rc = (int)(7);
            goto recovery_error;
        }

        aData = &amp;aFrame[24];
        aPrivate = (uint*)(&amp;aData[szPage]);
        iLastFrame = (uint)((nSize - 32) / szFrame);
        for (iPg = (uint)(0); (iPg) &lt;= ((uint)(walFramePage((uint)(iLastFrame)))); iPg++)
        {
            uint* aShare;
            uint iFrame = 0;
            uint iLast = (uint)((iLastFrame) &lt; ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + iPg * 4096) ? (iLastFrame) : ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + iPg * 4096));
            uint iFirst = (uint)(1 + ((iPg) == (0) ? 0 : (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + (iPg - 1) * 4096));
            uint nHdr = 0;
            uint nHdr32 = 0;
            rc = (int)(walIndexPage(pWal, (int)(iPg), &amp;aShare));
            if ((aShare) == (null))
                break;
            pWal.apWiData[iPg] = aPrivate;
            for (iFrame = (uint)(iFirst); (iFrame) &lt;= (iLast); iFrame++)
            {
                long iOffset = (long)(32 + ((iFrame) - 1) * (long)((szPage) + 24));
                uint pgno = 0;
                uint nTruncate = 0;
                rc = (int)(sqlite3OsRead(pWal.pWalFd, aFrame, (int)(szFrame), (long)(iOffset)));
                if (rc != 0)
                    break;
                isValid = (int)(walDecodeFrame(pWal, &amp;pgno, &amp;nTruncate, aData, aFrame));
                if (isValid == 0)
                    break;
                rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(pgno)));
                if ((rc != 0))
                    break;
                if ((nTruncate) != 0)
                {
                    pWal.hdr.mxFrame = (uint)(iFrame);
                    pWal.hdr.nPage = (uint)(nTruncate);
                    pWal.hdr.szPage = ((ushort)((szPage &amp; 0xff00) | (szPage &gt;&gt; 16)));
                    aFrameCksum[0] = (uint)(pWal.hdr.aFrameCksum[0]);
                    aFrameCksum[1] = (uint)(pWal.hdr.aFrameCksum[1]);
                }
            }

            pWal.apWiData[iPg] = aShare;
            nHdr = (uint)((iPg) == (0) ? (sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) : 0);
            nHdr32 = (uint)(nHdr / sizeof(uint));
            CRuntime.memcpy(&amp;aShare[nHdr32], &amp;aPrivate[nHdr32], (ulong)((sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)) - nHdr));
            if ((iFrame) &lt;= (iLast))
                break;
        }

        sqlite3_free(aFrame);
    }

    finished:
        ; if  ( ( rc ) == ( 0 ) ) { volatile  WalCkptInfo * pInfo ;  int  i  =  0 ;  pWal . hdr . aFrameCksum [ 0 ]  =  ( uint ) ( aFrameCksum [ 0 ] ) ;  pWal . hdr . aFrameCksum [ 1 ]  =  ( uint ) ( aFrameCksum [ 1 ] ) ;  walIndexWriteHdr ( pWal ) ;  pInfo  =  walCkptInfo ( pWal ) ;  pInfo -&gt; nBackfill  =  ( uint ) ( 0 ) ;  pInfo -&gt; nBackfillAttempted  =  ( uint ) ( pWal . hdr . mxFrame ) ;  pInfo -&gt; aReadMark [ 0 ]  =  ( uint ) ( 0 ) ;  for  ( i  =  ( int ) ( 1 ) ;  ( i ) &lt; ( 8 - 3 ) ;  i ++ ) { rc  =  ( int ) ( walLockExclusive ( pWal ,  ( int ) ( 3 + ( i ) ) ,  ( int ) ( 1 ) ) ) ;  if  ( ( rc ) == ( 0 ) ) { if  ( ( ( i ) == ( 1 ) ) &amp;&amp; ( ( pWal . hdr . mxFrame ) != 0 ) ) { pInfo -&gt; aReadMark [ i ]  =  ( uint ) ( pWal . hdr . mxFrame ) ;  } else  { pInfo -&gt; aReadMark [ i ]  =  ( uint ) ( 0xffffffff ) ;  } walUnlockExclusive ( pWal ,  ( int ) ( 3 + ( i ) ) ,  ( int ) ( 1 ) ) ;  } else  if  ( rc != 5 ) { goto  recovery_error ;  } } if  ( ( pWal . hdr . nPage ) != 0 ) { sqlite3_log ( ( int ) ( 27 | ( 1 &lt;&lt; 8 ) ) ,  "recovered %d frames from WAL file %s" ,  ( uint ) ( pWal . hdr . mxFrame ) ,  pWal . zWalName ) ;  } }
    recovery_error:
        ;
    walUnlockExclusive(pWal, (int)(iLock), (int)((3 + (0)) - iLock));
    return (int)(rc);
}</function>
  <function>public static int walIndexTryHdr(Wal pWal, int* pChanged)
{
    uint* aCksum = stackalloc uint[2];
    WalIndexHdr h1 = new WalIndexHdr(); WalIndexHdr  h2  =  new  WalIndexHdr ( ) ; 
    volatile WalIndexHdr* aHdr;
    aHdr = walIndexHdr(pWal);
    CRuntime.memcpy(&amp;h1, (void*)(&amp;aHdr[0]), (ulong)(sizeof(WalIndexHdr)));
    walShmBarrier(pWal);
    CRuntime.memcpy(&amp;h2, (void*)(&amp;aHdr[1]), (ulong)(sizeof(WalIndexHdr)));
    if (memcmp(&amp;h1, &amp;h2, (ulong)(sizeof(WalIndexHdr))) != 0)
    {
        return (int)(1);
    }

    if ((h1.isInit) == (0))
    {
        return (int)(1);
    }

    walChecksumBytes((int)(1), (byte*)(&amp;h1), (int)(sizeof(WalIndexHdr) - 2 * sizeof(uint)), null, aCksum);
    if ((aCksum[0] != h1.aCksum[0]) || (aCksum[1] != h1.aCksum[1]))
    {
        return (int)(1);
    }

    if ((memcmp(&amp;pWal.hdr, &amp;h1, (ulong)(sizeof(WalIndexHdr)))) != 0)
    {
        *pChanged = (int)(1);
        CRuntime.memcpy(&amp;pWal.hdr, &amp;h1, (ulong)(sizeof(WalIndexHdr)));
        pWal.szPage = (uint)((pWal.hdr.szPage &amp; 0xfe00) + ((pWal.hdr.szPage &amp; 0x0001) &lt;&lt; 16));
    }

    return (int)(0);
}</function>
  <function>public static void walIndexWriteHdr(Wal pWal)
{
    volatile WalIndexHdr* aHdr = walIndexHdr(pWal);
    int nCksum = (int)((ulong)(&amp;((0)-&gt;aCksum)));
    pWal.hdr.isInit = (byte)(1);
    pWal.hdr.iVersion = (uint)(3007000);
    walChecksumBytes((int)(1), (byte*)(&amp;pWal.hdr), (int)(nCksum), null, pWal.hdr.aCksum);
    CRuntime.memcpy((void*)(&amp;aHdr[1]), (void*)(&amp;pWal.hdr), (ulong)(sizeof(WalIndexHdr)));
    walShmBarrier(pWal);
    CRuntime.memcpy((void*)(&amp;aHdr[0]), (void*)(&amp;pWal.hdr), (ulong)(sizeof(WalIndexHdr)));
}</function>
  <function>public static void walIteratorFree(WalIterator p)
{
    sqlite3_free(p);
}</function>
  <function>public static int walIteratorInit(Wal pWal, uint nBackfill, WalIterator pp)
{
    WalIterator p;
    int nSegment = 0;
    uint iLast = 0;
    long nByte = 0;
    int i = 0;
    ushort* aTmp;
    int rc = (int)(0);
    iLast = (uint)(pWal.hdr.mxFrame);
    nSegment = (int)(walFramePage((uint)(iLast)) + 1);
    nByte = (long)(sizeof(WalIterator) + (nSegment - 1) * sizeof(WalSegment) + iLast * sizeof(ushort));
    p = (WalIterator)(sqlite3_malloc64((ulong)(nByte)));
    if (p == null)
    {
        return (int)(7);
    }

    CRuntime.memset(p, (int)(0), (ulong)(nByte));
    p.nSegment = (int)(nSegment);
    aTmp = (ushort*)(sqlite3_malloc64((ulong)(sizeof(ushort) * ((iLast) &gt; (4096) ? 4096 : iLast))));
    if (aTmp == null)
    {
        rc = (int)(7);
    }

    for (i = (int)(walFramePage((uint)(nBackfill + 1))); ((rc) == (0)) &amp;&amp; ((i) &lt; (nSegment)); i++)
    {
        WalHashLoc sLoc = new WalHashLoc();
        rc = (int)(walHashGet(pWal, (int)(i), &amp;sLoc));
        if ((rc) == (0))
        {
            int j = 0;
            int nEntry = 0;
            ushort* aIndex;
            if ((i + 1) == (nSegment))
            {
                nEntry = ((int)(iLast - sLoc.iZero));
            }
            else
            {
                nEntry = ((int)((uint*)(sLoc.aHash) - sLoc.aPgno));
            }

            aIndex = &amp;((ushort*)(&amp;p.aSegment[p.nSegment]))[sLoc.iZero];
            sLoc.iZero++;
            for (j = (int)(0); (j) &lt; (nEntry); j++)
            {
                aIndex[j] = ((ushort)(j));
            }

            walMergesort(sLoc.aPgno, aTmp, aIndex, &amp;nEntry);
            p.aSegment[i].iZero = (int)(sLoc.iZero);
            p.aSegment[i].nEntry = (int)(nEntry);
            p.aSegment[i].aIndex = aIndex;
            p.aSegment[i].aPgno = sLoc.aPgno;
        }
    }

    sqlite3_free(aTmp);
    if (rc != 0)
    {
        walIteratorFree(p);
        p = null;
    }

    pp = p;
    return (int)(rc);
}</function>
  <function>public static int walIteratorNext(WalIterator p, uint* piPage, uint* piFrame)
{
    uint iMin = 0;
    uint iRet = (uint)(0xFFFFFFFF);
    int i = 0;
    iMin = (uint)(p.iPrior);
    for (i = (int)(p.nSegment - 1); (i) &gt;= (0); i--)
    {
        WalSegment* pSegment = &amp;p.aSegment[i];
        while ((pSegment-&gt;iNext) &lt; (pSegment-&gt;nEntry))
        {
            uint iPg = (uint)(pSegment-&gt;aPgno[pSegment-&gt;aIndex[pSegment-&gt;iNext]]);
            if ((iPg) &gt; (iMin))
            {
                if ((iPg) &lt; (iRet))
                {
                    iRet = (uint)(iPg);
                    *piFrame = (uint)(pSegment-&gt;iZero + pSegment-&gt;aIndex[pSegment-&gt;iNext]);
                }

                break;
            }

            pSegment-&gt;iNext++;
        }
    }

    *piPage = (uint)(p.iPrior = (uint)(iRet));
    return (((iRet) == (0xFFFFFFFF)) ? 1 : 0);
}</function>
  <function>public static int walkExpr(Walker pWalker, Expr pExpr)
{
    int rc = 0;
    while ((1) != 0)
    {
        rc = (int)(pWalker.xExprCallback(pWalker, pExpr));
        if ((rc) != 0)
            return (int)(rc &amp; 2);
        if (!(((pExpr).flags &amp; (0x004000 | 0x800000)) != 0))
        {
            if (((pExpr.pLeft) != null) &amp;&amp; ((walkExpr(pWalker, pExpr.pLeft)) != 0))
                return (int)(2);
            if ((pExpr.pRight) != null)
            {
                pExpr = pExpr.pRight;
                continue;
            }
            else if ((((pExpr).flags &amp; 0x000800) != 0))
            {
                if ((sqlite3WalkSelect(pWalker, pExpr.x.pSelect)) != 0)
                    return (int)(2);
            }
            else
            {
                if ((pExpr.x.pList) != null)
                {
                    if ((sqlite3WalkExprList(pWalker, pExpr.x.pList)) != 0)
                        return (int)(2);
                }

                if ((((pExpr).flags &amp; (0x1000000)) != 0))
                {
                    if ((walkWindowList(pWalker, pExpr.y.pWin, (int)(1))) != 0)
                        return (int)(2);
                }
            }
        }

        break;
    }

    return (int)(0);
}</function>
  <function>public static int walkWindowList(Walker pWalker, Window pList, int bOneOnly)
{
    Window pWin;
    for (pWin = pList; pWin; pWin = pWin.pNextWin)
    {
        int rc = 0;
        rc = (int)(sqlite3WalkExprList(pWalker, pWin.pOrderBy));
        if ((rc) != 0)
            return (int)(2);
        rc = (int)(sqlite3WalkExprList(pWalker, pWin.pPartition));
        if ((rc) != 0)
            return (int)(2);
        rc = (int)(sqlite3WalkExpr(pWalker, pWin.pFilter));
        if ((rc) != 0)
            return (int)(2);
        rc = (int)(sqlite3WalkExpr(pWalker, pWin.pStart));
        if ((rc) != 0)
            return (int)(2);
        rc = (int)(sqlite3WalkExpr(pWalker, pWin.pEnd));
        if ((rc) != 0)
            return (int)(2);
        if ((bOneOnly) != 0)
            break;
    }

    return (int)(0);
}</function>
  <function>public static void walLimitSize(Wal pWal, long nMax)
{
    long sz = 0;
    int rx = 0;
    sqlite3BeginBenignMalloc();
    rx = (int)(sqlite3OsFileSize(pWal.pWalFd, &amp;sz));
    if (((rx) == (0)) &amp;&amp; ((sz) &gt; (nMax)))
    {
        rx = (int)(sqlite3OsTruncate(pWal.pWalFd, (long)(nMax)));
    }

    sqlite3EndBenignMalloc();
    if ((rx) != 0)
    {
        sqlite3_log((int)(rx), "cannot limit WAL size: %s", pWal.zWalName);
    }
}</function>
  <function>public static int walLockExclusive(Wal pWal, int lockIdx, int n)
{
    int rc = 0;
    if ((pWal.exclusiveMode) != 0)
        return (int)(0);
    rc = (int)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(n), (int)(2 | 8)));
    return (int)(rc);
}</function>
  <function>public static int walLockShared(Wal pWal, int lockIdx)
{
    int rc = 0;
    if ((pWal.exclusiveMode) != 0)
        return (int)(0);
    rc = (int)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(1), (int)(2 | 4)));
    return (int)(rc);
}</function>
  <function>public static void walMerge(uint* aContent, ushort* aLeft, int nLeft, ushort** paRight, int* pnRight, ushort* aTmp)
{
    int iLeft = (int)(0);
    int iRight = (int)(0);
    int iOut = (int)(0);
    int nRight = (int)(*pnRight);
    ushort* aRight = *paRight;
    while (((iRight) &lt; (nRight)) || ((iLeft) &lt; (nLeft)))
    {
        ushort logpage = 0;
        uint dbpage = 0;
        if (((iLeft) &lt; (nLeft)) &amp;&amp; (((iRight) &gt;= (nRight)) || ((aContent[aLeft[iLeft]]) &lt; (aContent[aRight[iRight]]))))
        {
            logpage = (ushort)(aLeft[iLeft++]);
        }
        else
        {
            logpage = (ushort)(aRight[iRight++]);
        }

        dbpage = (uint)(aContent[logpage]);
        aTmp[iOut++] = (ushort)(logpage);
        if (((iLeft) &lt; (nLeft)) &amp;&amp; ((aContent[aLeft[iLeft]]) == (dbpage)))
            iLeft++;
    }

    *paRight = aLeft;
    *pnRight = (int)(iOut);
    CRuntime.memcpy(aLeft, aTmp, (ulong)(sizeof(ushort) * iOut));
}</function>
  <function>public static void walMergesort(uint* aContent, ushort* aBuffer, ushort* aList, int* pnList)
{
    int nList = (int)(*pnList);
    int nMerge = (int)(0);
    ushort* aMerge = null;
    int iList = 0;
    uint iSub = (uint)(0);
    Sublist* aSub = stackalloc Sublist[13];
    CRuntime.memset(aSub, (int)(0), (ulong)(13 * sizeof(Sublist)));
    for (iList = (int)(0); (iList) &lt; (nList); iList++)
    {
        nMerge = (int)(1);
        aMerge = &amp;aList[iList];
        for (iSub = (uint)(0); iList &amp; (1 &lt;&lt; iSub); iSub++)
        {
            Sublist* p;
            p = &amp;aSub[iSub];
            walMerge(aContent, p-&gt;aList, (int)(p-&gt;nList), &amp;aMerge, &amp;nMerge, aBuffer);
        }

        aSub[iSub].aList = aMerge;
        aSub[iSub].nList = (int)(nMerge);
    }

    for (iSub++; (iSub) &lt; ((int)(13 * sizeof(Sublist) / sizeof(Sublist))); iSub++)
    {
        if ((nList &amp; (1 &lt;&lt; iSub)) != 0)
        {
            Sublist* p;
            p = &amp;aSub[iSub];
            walMerge(aContent, p-&gt;aList, (int)(p-&gt;nList), &amp;aMerge, &amp;nMerge, aBuffer);
        }
    }

    *pnList = (int)(nMerge);
}</function>
  <function>public static int walNextHash(int iPriorHash)
{
    return (int)((iPriorHash + 1) &amp; ((4096 * 2) - 1));
}</function>
  <function>public static int walPagesize(Wal pWal)
{
    return (int)((pWal.hdr.szPage &amp; 0xfe00) + ((pWal.hdr.szPage &amp; 0x0001) &lt;&lt; 16));
}</function>
  <function>public static void walRestartHdr(Wal pWal, uint salt1)
{
    volatile WalCkptInfo* pInfo = walCkptInfo(pWal);
    int i = 0;
    uint* aSalt = pWal.hdr.aSalt;
    pWal.nCkpt++;
    pWal.hdr.mxFrame = (uint)(0);
    sqlite3Put4byte((byte*)(&amp;aSalt[0]), (uint)(1 + sqlite3Get4byte((byte*)(&amp;aSalt[0]))));
    CRuntime.memcpy(&amp;pWal.hdr.aSalt[1], &amp;salt1, (ulong)(4));
    walIndexWriteHdr(pWal);
    (0);
    pInfo-&gt;nBackfillAttempted = (uint)(0);
    pInfo-&gt;aReadMark[1] = (uint)(0);
    for (i = (int)(2); (i) &lt; (8 - 3); i++)
    {
        pInfo-&gt;aReadMark[i] = (uint)(0xffffffff);
    }
}</function>
  <function>public static int walRestartLog(Wal pWal)
{
    int rc = (int)(0);
    int cnt = 0;
    if ((pWal.readLock) == (0))
    {
        volatile WalCkptInfo* pInfo = walCkptInfo(pWal);
        if ((pInfo-&gt;nBackfill) &gt; (0))
        {
            uint salt1 = 0;
            sqlite3_randomness((int)(4), &amp;salt1);
            rc = (int)(walLockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1)));
            if ((rc) == (0))
            {
                walRestartHdr(pWal, (uint)(salt1));
                walUnlockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1));
            }
            else if (rc != 5)
            {
                return (int)(rc);
            }
        }

        walUnlockShared(pWal, (int)(3 + (0)));
        pWal.readLock = (short)(-1);
        cnt = (int)(0);
        do
        {
            int notUsed = 0;
            rc = (int)(walTryBeginRead(pWal, &amp;notUsed, (int)(1), (int)(++cnt)));
        }
        while ((rc) == (-1));
    }

    return (int)(rc);
}</function>
  <function>public static int walRewriteChecksums(Wal pWal, uint iLast)
{
    int szPage = (int)(pWal.szPage);
    int rc = (int)(0);
    byte* aBuf;
    byte* aFrame = stackalloc byte[24];
    uint iRead = 0;
    long iCksumOff = 0;
    aBuf = sqlite3_malloc((int)(szPage + 24));
    if ((aBuf) == (null))
        return (int)(7);
    if ((pWal.iReCksum) == (1))
    {
        iCksumOff = (long)(24);
    }
    else
    {
        iCksumOff = (long)((32 + ((pWal.iReCksum - 1) - 1) * (long)((szPage) + 24)) + 16);
    }

    rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(sizeof(uint) * 2), (long)(iCksumOff)));
    pWal.hdr.aFrameCksum[0] = (uint)(sqlite3Get4byte(aBuf));
    pWal.hdr.aFrameCksum[1] = (uint)(sqlite3Get4byte(&amp;aBuf[sizeof(uint)]));
    iRead = (uint)(pWal.iReCksum);
    pWal.iReCksum = (uint)(0);
    for (; ((rc) == (0)) &amp;&amp; ((iRead) &lt;= (iLast)); iRead++)
    {
        long iOff = (long)(32 + ((iRead) - 1) * (long)((szPage) + 24));
        rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(szPage + 24), (long)(iOff)));
        if ((rc) == (0))
        {
            uint iPgno = 0;
            uint nDbSize = 0;
            iPgno = (uint)(sqlite3Get4byte(aBuf));
            nDbSize = (uint)(sqlite3Get4byte(&amp;aBuf[4]));
            walEncodeFrame(pWal, (uint)(iPgno), (uint)(nDbSize), &amp;aBuf[24], aFrame);
            rc = (int)(sqlite3OsWrite(pWal.pWalFd, aFrame, (int)(24 * sizeof(byte)), (long)(iOff)));
        }
    }

    sqlite3_free(aBuf);
    return (int)(rc);
}</function>
  <function>public static void walShmBarrier(Wal pWal)
{
    if (pWal.exclusiveMode != 2)
    {
        sqlite3OsShmBarrier(pWal.pDbFd);
    }
}</function>
  <function>public static int walTryBeginRead(Wal pWal, int* pChanged, int useWal, int cnt)
{
    volatile WalCkptInfo* pInfo;
    uint mxReadMark = 0;
    int mxI = 0;
    int i = 0;
    int rc = (int)(0);
    uint mxFrame = 0;
    if ((cnt) &gt; (5))
    {
        int nDelay = (int)(1);
        if ((cnt) &gt; (100))
        {
            return (int)(15);
        }

        if ((cnt) &gt;= (10))
            nDelay = (int)((cnt - 9) * (cnt - 9) * 39);
        sqlite3OsSleep(pWal.pVfs, (int)(nDelay));
    }

    if (useWal == 0)
    {
        if ((pWal.bShmUnreliable) == (0))
        {
            rc = (int)(walIndexReadHdr(pWal, pChanged));
        }

        if ((rc) == (5))
        {
            if ((pWal.apWiData[0]) == (null))
            {
                rc = (int)(-1);
            }
            else if ((0) == (rc = (int)(walLockShared(pWal, (int)(2)))))
            {
                walUnlockShared(pWal, (int)(2));
                rc = (int)(-1);
            }
            else if ((rc) == (5))
            {
                rc = (int)(5 | (1 &lt;&lt; 8));
            }
        }

        if (rc != 0)
        {
            return (int)(rc);
        }
        else if ((pWal.bShmUnreliable) != 0)
        {
            return (int)(walBeginShmUnreliable(pWal, pChanged));
        }
    }

    pInfo = walCkptInfo(pWal);
    if ((useWal == 0) &amp;&amp; ((0) == (pWal.hdr.mxFrame)))
    {
        rc = (int)(walLockShared(pWal, (int)(3 + (0))));
        walShmBarrier(pWal);
        if ((rc) == (0))
        {
            if ((memcmp((void*)(walIndexHdr(pWal)), &amp;pWal.hdr, (ulong)(sizeof(WalIndexHdr)))) != 0)
            {
                walUnlockShared(pWal, (int)(3 + (0)));
                return (int)(-1);
            }

            pWal.readLock = (short)(0);
            return (int)(0);
        }
        else if (rc != 5)
        {
            return (int)(rc);
        }
    }

    mxReadMark = (uint)(0);
    mxI = (int)(0);
    mxFrame = (uint)(pWal.hdr.mxFrame);
    for (i = (int)(1); (i) &lt; (8 - 3); i++)
    {
        uint thisMark = (uint)(0);
        if (((mxReadMark) &lt;= (thisMark)) &amp;&amp; ((thisMark) &lt;= (mxFrame)))
        {
            mxReadMark = (uint)(thisMark);
            mxI = (int)(i);
        }
    }

    if (((pWal.readOnly &amp; 2) == (0)) &amp;&amp; (((mxReadMark) &lt; (mxFrame)) || ((mxI) == (0))))
    {
        for (i = (int)(1); (i) &lt; (8 - 3); i++)
        {
            rc = (int)(walLockExclusive(pWal, (int)(3 + (i)), (int)(1)));
            if ((rc) == (0))
            {
                (mxFrame);
                mxReadMark = (uint)(mxFrame);
                mxI = (int)(i);
                walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1));
                break;
            }
            else if (rc != 5)
            {
                return (int)(rc);
            }
        }
    }

    if ((mxI) == (0))
    {
        return (int)((rc) == (5) ? (-1) : (8 | (5 &lt;&lt; 8)));
    }

    rc = (int)(walLockShared(pWal, (int)(3 + (mxI))));
    if ((rc) != 0)
    {
        return (int)((rc) == (5) ? (-1) : rc);
    }

    pWal.minFrame = (uint)(0 + 1);
    walShmBarrier(pWal);
    if ((0 != mxReadMark) || ((memcmp((void*)(walIndexHdr(pWal)), &amp;pWal.hdr, (ulong)(sizeof(WalIndexHdr)))) != 0))
    {
        walUnlockShared(pWal, (int)(3 + (mxI)));
        return (int)(-1);
    }
    else
    {
        pWal.readLock = ((short)(mxI));
    }

    return (int)(rc);
}</function>
  <function>public static void walUnlockExclusive(Wal pWal, int lockIdx, int n)
{
    if ((pWal.exclusiveMode) != 0)
        return;
    (void)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(n), (int)(1 | 8)));
}</function>
  <function>public static void walUnlockShared(Wal pWal, int lockIdx)
{
    if ((pWal.exclusiveMode) != 0)
        return;
    (void)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(1), (int)(1 | 4)));
}</function>
  <function>public static int walWriteOneFrame(WalWriter p, PgHdr pPage, int nTruncate, long iOffset)
{
    int rc = 0;
    void* pData;
    byte* aFrame = stackalloc byte[24];
    pData = pPage.pData;
    walEncodeFrame(p.pWal, (uint)(pPage.pgno), (uint)(nTruncate), pData, aFrame);
    rc = (int)(walWriteToLog(p, aFrame, (int)(24 * sizeof(byte)), (long)(iOffset)));
    if ((rc) != 0)
        return (int)(rc);
    rc = (int)(walWriteToLog(p, pData, (int)(p.szPage), (long)(iOffset + 24 * sizeof(byte))));
    return (int)(rc);
}</function>
  <function>public static int walWriteToLog(WalWriter p, void* pContent, int iAmt, long iOffset)
{
    int rc = 0;
    if (((iOffset) &lt; (p.iSyncPoint)) &amp;&amp; ((iOffset + iAmt) &gt;= (p.iSyncPoint)))
    {
        int iFirstAmt = (int)(p.iSyncPoint - iOffset);
        rc = (int)(sqlite3OsWrite(p.pFd, pContent, (int)(iFirstAmt), (long)(iOffset)));
        if ((rc) != 0)
            return (int)(rc);
        iOffset += (long)(iFirstAmt);
        iAmt -= (int)(iFirstAmt);
        pContent = (void*)(iFirstAmt + (sbyte*)(pContent));
        rc = (int)(sqlite3OsSync(p.pFd, (int)((p.syncFlags) &amp; 0x03)));
        if (((iAmt) == (0)) || ((rc) != 0))
            return (int)(rc);
    }

    rc = (int)(sqlite3OsWrite(p.pFd, pContent, (int)(iAmt), (long)(iOffset)));
    return (int)(rc);
}</function>
  <function>public static void whereAddLimitExpr(WhereClause pWC, int iReg, Expr pExpr, int iCsr, int eMatchOp)
{
    Parse pParse = pWC.pWInfo.pParse;
    sqlite3 db = pParse.db;
    Expr pNew;
    int iVal = (int)(0);
    if (((sqlite3ExprIsInteger(pExpr, &amp;iVal)) != 0) &amp;&amp; ((iVal) &gt;= (0)))
    {
        Expr pVal = sqlite3Expr(db, (int)(155), null);
        if ((pVal) == (null))
            return;
        (pVal).flags |= (uint)(0x000400);
        pVal.u.iValue = (int)(iVal);
        pNew = sqlite3PExpr(pParse, (int)(46), null, pVal);
    }
    else
    {
        Expr pVal = sqlite3Expr(db, (int)(176), null);
        if ((pVal) == (null))
            return;
        pVal.iTable = (int)(iReg);
        pNew = sqlite3PExpr(pParse, (int)(46), null, pVal);
    }

    if ((pNew) != null)
    {
        WhereTerm pTerm;
        int idx = 0;
        idx = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0001 | 0x0002)));
        pTerm = pWC.a[idx];
        pTerm.leftCursor = (int)(iCsr);
        pTerm.eOperator = (ushort)(0x0040);
        pTerm.eMatchOp = (byte)(eMatchOp);
    }
}</function>
  <function>public static void whereAndInfoDelete(sqlite3 db, WhereAndInfo p)
{
    sqlite3WhereClauseClear(p.wc);
    sqlite3DbFree(db, p);
}</function>
  <function>public static void whereApplyPartialIndexConstraints(Expr pTruth, int iTabCur, WhereClause pWC)
{
    int i = 0;
    WhereTerm pTerm;
    while ((pTruth.op) == (44))
    {
        whereApplyPartialIndexConstraints(pTruth.pLeft, (int)(iTabCur), pWC);
        pTruth = pTruth.pRight;
    }

    for (i = (int)(0), pTerm = pWC.a; (i) &lt; (pWC.nTerm); i++, pTerm++)
    {
        Expr pExpr;
        if ((pTerm.wtFlags &amp; 0x0004) != 0)
            continue;
        pExpr = pTerm.pExpr;
        if ((sqlite3ExprCompare(null, pExpr, pTruth, (int)(iTabCur))) == (0))
        {
            pTerm.wtFlags |= (ushort)(0x0004);
        }
    }
}</function>
  <function>public static void whereCheckIfBloomFilterIsUseful(WhereInfo pWInfo)
{
    int i = 0;
    short nSearch = 0;
    nSearch = (short)(pWInfo.a[0].pWLoop.nOut);
    for (i = (int)(1); (i) &lt; (pWInfo.nLevel); i++)
    {
        WhereLoop pLoop = pWInfo.a[i].pWLoop;
        uint reqFlags = (uint)(0x00800000 | 0x00000001);
        if (((pLoop.wsFlags &amp; reqFlags) == (reqFlags)) &amp;&amp; ((pLoop.wsFlags &amp; (0x00000100 | 0x00000200)) != 0))
        {
            SrcItem pItem = pWInfo.pTabList.a[pLoop.iTab];
            Table pTab = pItem.pTab;
            pTab.tabFlags |= (uint)(0x00000100);
            if (((nSearch) &gt; (pTab.nRowLogEst)) &amp;&amp; ((pTab.tabFlags &amp; 0x00000010) != 0))
            {
                pLoop.wsFlags |= (uint)(0x00400000);
                pLoop.wsFlags &amp;= (uint)(~0x00000040);
            }
        }

        nSearch += (short)(pLoop.nOut);
    }
}</function>
  <function>public static int whereClauseInsert(WhereClause pWC, Expr p, ushort wtFlags)
{
    WhereTerm pTerm;
    int idx = 0;
    if ((pWC.nTerm) &gt;= (pWC.nSlot))
    {
        WhereTerm pOld = pWC.a;
        sqlite3 db = pWC.pWInfo.pParse.db;
        pWC.a = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereTerm) * pWC.nSlot * 2));
        if ((pWC.a) == (null))
        {
            if ((wtFlags &amp; 0x0001) != 0)
            {
                sqlite3ExprDelete(db, p);
            }

            pWC.a = pOld;
            return (int)(0);
        }

        CRuntime.memcpy(pWC.a, pOld, (ulong)(sizeof(WhereTerm) * pWC.nTerm));
        if (pOld != pWC.aStatic)
        {
            sqlite3DbFree(db, pOld);
        }

        pWC.nSlot = (int)(sqlite3DbMallocSize(db, pWC.a) / sizeof(WhereTerm));
    }

    pTerm = pWC.a[idx = (int)(pWC.nTerm++)];
    if ((wtFlags &amp; 0x0002) == (0))
        pWC.nBase = (int)(pWC.nTerm);
    if (((p) != null) &amp;&amp; (((p).flags &amp; (0x040000)) != 0))
    {
        pTerm.truthProb = (short)(sqlite3LogEst((ulong)(p.iTable)) - 270);
    }
    else
    {
        pTerm.truthProb = (short)(1);
    }

    pTerm.pExpr = sqlite3ExprSkipCollateAndLikely(p);
    pTerm.wtFlags = (ushort)(wtFlags);
    pTerm.pWC = pWC;
    pTerm.iParent = (int)(-1);
    CRuntime.memset(&amp;pTerm.eOperator, (int)(0), (ulong)(sizeof(WhereTerm) - ((ulong)(&amp;((0).eOperator)))));
    return (int)(idx);
}</function>
  <function>public static void whereCombineDisjuncts(SrcList pSrc, WhereClause pWC, WhereTerm pOne, WhereTerm pTwo)
{
    ushort eOp = (ushort)(pOne.eOperator | pTwo.eOperator);
    sqlite3 db;
    Expr pNew;
    int op = 0;
    int idxNew = 0;
    if (((pOne.wtFlags | pTwo.wtFlags) &amp; 0x0080) != 0)
        return;
    if ((pOne.eOperator &amp; (0x0002 | (0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)) | (0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) == (0))
        return;
    if ((pTwo.eOperator &amp; (0x0002 | (0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)) | (0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) == (0))
        return;
    if (((eOp &amp; (0x0002 | (0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)))) != eOp) &amp;&amp; ((eOp &amp; (0x0002 | (0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) != eOp))
        return;
    if ((sqlite3ExprCompare(null, pOne.pExpr.pLeft, pTwo.pExpr.pLeft, (int)(-1))) != 0)
        return;
    if ((sqlite3ExprCompare(null, pOne.pExpr.pRight, pTwo.pExpr.pRight, (int)(-1))) != 0)
        return;
    if ((eOp &amp; (eOp - 1)) != 0)
    {
        if ((eOp &amp; ((0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)))) != 0)
        {
            eOp = (ushort)(0x0002 &lt;&lt; (55 - 53));
        }
        else
        {
            eOp = (ushort)(0x0002 &lt;&lt; (57 - 53));
        }
    }

    db = pWC.pWInfo.pParse.db;
    pNew = sqlite3ExprDup(db, pOne.pExpr, (int)(0));
    if ((pNew) == (null))
        return;
    for (op = (int)(53); eOp != (0x0002 &lt;&lt; (op - 53)); op++)
    {
    }

    pNew.op = (byte)(op);
    idxNew = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0002 | 0x0001)));
    exprAnalyze(pSrc, pWC, (int)(idxNew));
}</function>
  <function>public static void whereIndexExprTrans(Index pIdx, int iTabCur, int iIdxCur, WhereInfo pWInfo)
{
    int iIdxCol = 0;
    ExprList aColExpr;
    Table pTab;
    Walker w = new Walker();
    IdxExprTrans x = new IdxExprTrans();
    aColExpr = pIdx.aColExpr;
    if (((aColExpr) == (null)) &amp;&amp; (pIdx.bHasVCol == 0))
    {
        return;
    }

    pTab = pIdx.pTable;
    CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
    w.u.pIdxTrans = x;
    x.iTabCur = (int)(iTabCur);
    x.iIdxCur = (int)(iIdxCur);
    x.pWInfo = pWInfo;
    x.db = pWInfo.pParse.db;
    for (iIdxCol = (int)(0); (iIdxCol) &lt; (pIdx.nColumn); iIdxCol++)
    {
        short iRef = (short)(pIdx.aiColumn[iIdxCol]);
        if ((iRef) == (-2))
        {
            x.pIdxExpr = aColExpr.a[iIdxCol].pExpr;
            if ((sqlite3ExprIsConstant(x.pIdxExpr)) != 0)
                continue;
            w.xExprCallback = whereIndexExprTransNode;
        }
        else if ((((iRef) &gt;= (0)) &amp;&amp; ((pTab.aCol[iRef].colFlags &amp; 0x0020) != 0)) &amp;&amp; (((pTab.aCol[iRef].colFlags &amp; 0x0200) == (0)) || ((sqlite3StrICmp(sqlite3ColumnColl(&amp;pTab.aCol[iRef]), sqlite3StrBINARY)) == (0))))
        {
            x.iTabCol = (int)(iRef);
            w.xExprCallback = whereIndexExprTransColumn;
        }
        else
        {
            continue;
        }

        x.iIdxCol = (int)(iIdxCol);
        sqlite3WalkExpr(w, pWInfo.pWhere);
        sqlite3WalkExprList(w, pWInfo.pOrderBy);
        sqlite3WalkExprList(w, pWInfo.pResultSet);
    }
}</function>
  <function>public static int whereIndexExprTransColumn(Walker p, Expr pExpr)
{
    if ((pExpr.op) == (167))
    {
        IdxExprTrans pX = p.u.pIdxTrans;
        if (((pExpr.iTable) == (pX.iTabCur)) &amp;&amp; ((pExpr.iColumn) == (pX.iTabCol)))
        {
            preserveExpr(pX, pExpr);
            pExpr.affExpr = (sbyte)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
            pExpr.iTable = (int)(pX.iIdxCur);
            pExpr.iColumn = (short)(pX.iIdxCol);
            pExpr.y.pTab = null;
        }
    }

    return (int)(0);
}</function>
  <function>public static int whereIndexExprTransNode(Walker p, Expr pExpr)
{
    IdxExprTrans pX = p.u.pIdxTrans;
    if ((sqlite3ExprCompare(null, pExpr, pX.pIdxExpr, (int)(pX.iTabCur))) == (0))
    {
        preserveExpr(pX, pExpr);
        pExpr.affExpr = (sbyte)(sqlite3ExprAffinity(pExpr));
        pExpr.op = (byte)(167);
        pExpr.iTable = (int)(pX.iIdxCur);
        pExpr.iColumn = (short)(pX.iIdxCol);
        (pExpr).flags &amp;= (uint)(~(0x001000 | 0x040000 | 0x1000000 | 0x2000000));
        pExpr.y.pTab = null;
        return (int)(1);
    }
    else
    {
        return (int)(0);
    }
}</function>
  <function>public static void whereInfoFree(sqlite3 db, WhereInfo pWInfo)
{
    int i = 0;
    for (i = (int)(0); (i) &lt; (pWInfo.nLevel); i++)
    {
        WhereLevel pLevel = pWInfo.a[i];
        if (((pLevel.pWLoop) != null) &amp;&amp; ((pLevel.pWLoop.wsFlags &amp; 0x00000800) != 0))
        {
            sqlite3DbFree(db, pLevel.u._in_.aInLoop);
        }
    }

    sqlite3WhereClauseClear(pWInfo.sWC);
    while ((pWInfo.pLoops) != null)
    {
        WhereLoop p = pWInfo.pLoops;
        pWInfo.pLoops = p.pNextLoop;
        whereLoopDelete(db, p);
    }

    sqlite3DbFreeNN(db, pWInfo);
}</function>
  <function>public static void whereLikeOptimizationStringFixup(Vdbe v, WhereLevel pLevel, WhereTerm pTerm)
{
    if ((pTerm.wtFlags &amp; 0x0100) != 0)
    {
        VdbeOp* pOp;
        pOp = sqlite3VdbeGetOp(v, (int)(-1));
        pOp-&gt;p3 = ((int)(pLevel.iLikeRepCntr &gt;&gt; 1));
        pOp-&gt;p5 = (ushort)((byte)(pLevel.iLikeRepCntr &amp; 1));
    }
}</function>
  <function>public static int whereLoopAddAll(WhereLoopBuilder pBuilder)
{
    WhereInfo pWInfo = pBuilder.pWInfo;
    ulong mPrereq = (ulong)(0);
    ulong mPrior = (ulong)(0);
    int iTab = 0;
    SrcList pTabList = pWInfo.pTabList;
    SrcItem pItem;
    SrcItem pEnd = pTabList.a[pWInfo.nLevel];
    sqlite3 db = pWInfo.pParse.db;
    int rc = (int)(0);
    WhereLoop pNew;
    pNew = pBuilder.pNew;
    whereLoopInit(pNew);
    pBuilder.iPlanLimit = (uint)(20000);
    for (iTab = (int)(0), pItem = pTabList.a; (pItem) &lt; (pEnd); iTab++, pItem++)
    {
        ulong mUnusable = (ulong)(0);
        pNew.iTab = (byte)(iTab);
        pBuilder.iPlanLimit += (uint)(1000);
        pNew.maskSelf = (ulong)(sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(pItem.iCursor)));
        if ((pItem.fg.jointype &amp; (0x0008 | 0x0002)) != 0)
        {
            mPrereq = (ulong)(mPrior);
        }
        else
        {
            mPrereq = (ulong)(0);
        }

        if ((((pItem.pTab).eTabType) == (1)))
        {
            SrcItem p;
            for (p = pItem[1]; (p) &lt; (pEnd); p++)
            {
                if (((mUnusable) != 0) || ((p.fg.jointype &amp; (0x0008 | 0x0002)) != 0))
                {
                    mUnusable |= (ulong)(sqlite3WhereGetMask(&amp;pWInfo.sMaskSet, (int)(p.iCursor)));
                }
            }

            rc = (int)(whereLoopAddVirtual(pBuilder, (ulong)(mPrereq), (ulong)(mUnusable)));
        }
        else
        {
            rc = (int)(whereLoopAddBtree(pBuilder, (ulong)(mPrereq)));
        }

        if (((rc) == (0)) &amp;&amp; ((pBuilder.pWC.hasOr) != 0))
        {
            rc = (int)(whereLoopAddOr(pBuilder, (ulong)(mPrereq), (ulong)(mUnusable)));
        }

        mPrior |= (ulong)(pNew.maskSelf);
        if (((rc) != 0) || ((db.mallocFailed) != 0))
        {
            if ((rc) == (101))
            {
                sqlite3_log((int)(28), "abbreviated query algorithm search");
                rc = (int)(0);
            }
            else
            {
                break;
            }
        }
    }

    whereLoopClear(db, pNew);
    return (int)(rc);
}</function>
  <function>public static int whereLoopAddBtree(WhereLoopBuilder pBuilder, ulong mPrereq)
{
    WhereInfo pWInfo;
    Index pProbe;
    Index sPk = new Index();
    short* aiRowEstPk = stackalloc short[2];
    short aiColumnPk = (short)(-1);
    SrcList pTabList;
    SrcItem pSrc;
    WhereLoop pNew;
    int rc = (int)(0);
    int iSortIdx = (int)(1);
    int b = 0;
    short rSize = 0;
    WhereClause pWC;
    Table pTab;
    pNew = pBuilder.pNew;
    pWInfo = pBuilder.pWInfo;
    pTabList = pWInfo.pTabList;
    pSrc = pTabList.a[pNew.iTab];
    pTab = pSrc.pTab;
    pWC = pBuilder.pWC;
    if ((pSrc.fg.isIndexedBy) != 0)
    {
        pProbe = pSrc.u2.pIBIndex;
    }
    else if (!(((pTab).tabFlags &amp; 0x00000080) == (0)))
    {
        pProbe = pTab.pIndex;
    }
    else
    {
        Index pFirst;
        CRuntime.memset(sPk, (int)(0), (ulong)(sizeof(Index)));
        sPk.nKeyCol = (ushort)(1);
        sPk.nColumn = (ushort)(1);
        sPk.aiColumn = &amp;aiColumnPk;
        sPk.aiRowLogEst = aiRowEstPk;
        sPk.onError = (byte)(5);
        sPk.pTable = pTab;
        sPk.szIdxRow = (short)(pTab.szTabRow);
        sPk.idxType = (uint)(3);
        aiRowEstPk[0] = (short)(pTab.nRowLogEst);
        aiRowEstPk[1] = (short)(0);
        pFirst = pSrc.pTab.pIndex;
        if ((pSrc.fg.notIndexed) == (0))
        {
            sPk.pNext = pFirst;
        }

        pProbe = sPk;
    }

    rSize = (short)(pTab.nRowLogEst);
    if ((((((((pBuilder.pOrSet == null) &amp;&amp; ((pWInfo.wctrlFlags &amp; 0x0020) == (0))) &amp;&amp; ((pWInfo.pParse.db.flags &amp; 0x00008000) != 0)) &amp;&amp; (pSrc.fg.isIndexedBy == 0)) &amp;&amp; (pSrc.fg.notIndexed == 0)) &amp;&amp; (((pTab).tabFlags &amp; 0x00000080) == (0))) &amp;&amp; (pSrc.fg.isCorrelated == 0)) &amp;&amp; (pSrc.fg.isRecursive == 0))
    {
        short rLogSize = 0;
        WhereTerm pTerm;
        WhereTerm pWCEnd = pWC.a[pWC.nTerm];
        rLogSize = (short)(estLog((short)(rSize)));
        for (pTerm = pWC.a; ((rc) == (0)) &amp;&amp; ((pTerm) &lt; (pWCEnd)); pTerm++)
        {
            if ((pTerm.prereqRight &amp; pNew.maskSelf) != 0)
                continue;
            if ((termCanDriveIndex(pTerm, pSrc, (ulong)(0))) != 0)
            {
                pNew.u.btree.nEq = (ushort)(1);
                pNew.nSkip = (ushort)(0);
                pNew.u.btree.pIndex = null;
                pNew.nLTerm = (ushort)(1);
                pNew.aLTerm[0] = pTerm;
                pNew.rSetup = (short)(rLogSize + rSize);
                if ((!(((pTab).eTabType) == (2))) &amp;&amp; ((pTab.tabFlags &amp; 0x00004000) == (0)))
                {
                    pNew.rSetup += (short)(28);
                }
                else
                {
                    pNew.rSetup -= (short)(10);
                }

                if ((pNew.rSetup) &lt; (0))
                    pNew.rSetup = (short)(0);
                pNew.nOut = (short)(43);
                pNew.rRun = (short)(sqlite3LogEstAdd((short)(rLogSize), (short)(pNew.nOut)));
                pNew.wsFlags = (uint)(0x00004000);
                pNew.prereq = (ulong)(mPrereq | pTerm.prereqRight);
                rc = (int)(whereLoopInsert(pBuilder, pNew));
            }
        }
    }

    for (; ((rc) == (0)) &amp;&amp; ((pProbe) != null); pProbe = ((pSrc.fg.isIndexedBy) != 0 ? null : pProbe.pNext), iSortIdx++)
    {
        int isLeft = (int)((pSrc.fg.jointype &amp; 0x0020) != 0);
        if ((pProbe.pPartIdxWhere != null) &amp;&amp; (whereUsablePartialIndex((int)(pSrc.iCursor), (int)(isLeft), pWC, pProbe.pPartIdxWhere) == 0))
        {
            continue;
        }

        if ((pProbe.bNoQuery) != 0)
            continue;
        rSize = (short)(pProbe.aiRowLogEst[0]);
        pNew.u.btree.nEq = (ushort)(0);
        pNew.u.btree.nBtm = (ushort)(0);
        pNew.u.btree.nTop = (ushort)(0);
        pNew.nSkip = (ushort)(0);
        pNew.nLTerm = (ushort)(0);
        pNew.iSortIdx = (byte)(0);
        pNew.rSetup = (short)(0);
        pNew.prereq = (ulong)(mPrereq);
        pNew.nOut = (short)(rSize);
        pNew.u.btree.pIndex = pProbe;
        b = (int)(indexMightHelpWithOrderBy(pBuilder, pProbe, (int)(pSrc.iCursor)));
        if ((pProbe.idxType) == (3))
        {
            pNew.wsFlags = (uint)(0x00000100);
            pNew.iSortIdx = (byte)((b) != 0 ? iSortIdx : 0);
            pNew.rRun = (short)(rSize + 16);
            whereLoopOutputAdjust(pWC, pNew, (short)(rSize));
            rc = (int)(whereLoopInsert(pBuilder, pNew));
            pNew.nOut = (short)(rSize);
            if ((rc) != 0)
                break;
        }
        else
        {
            ulong m = 0;
            if ((pProbe.isCovering) != 0)
            {
                pNew.wsFlags = (uint)(0x00000040 | 0x00000200);
                m = (ulong)(0);
            }
            else
            {
                m = (ulong)(pSrc.colUsed &amp; pProbe.colNotIdxed);
                pNew.wsFlags = (uint)(((m) == (0)) ? (0x00000040 | 0x00000200) : 0x00000200);
            }

            if ((((((b) != 0) || (!(((pTab).tabFlags &amp; 0x00000080) == (0)))) || (pProbe.pPartIdxWhere != null)) || ((pSrc.fg.isIndexedBy) != 0)) || (((((((m) == (0)) &amp;&amp; ((pProbe.bUnordered) == (0))) &amp;&amp; ((pProbe.szIdxRow) &lt; (pTab.szTabRow))) &amp;&amp; ((pWInfo.wctrlFlags &amp; 0x0004) == (0))) &amp;&amp; ((sqlite3Config.bUseCis) != 0)) &amp;&amp; (((pWInfo.pParse.db).dbOptFlags &amp; (0x00000020)) == (0))))
            {
                pNew.iSortIdx = (byte)((b) != 0 ? iSortIdx : 0);
                pNew.rRun = (short)(rSize + 1 + (15 * pProbe.szIdxRow) / pTab.szTabRow);
                if (m != 0)
                {
                    short nLookup = (short)(rSize + 16);
                    int ii = 0;
                    int iCur = (int)(pSrc.iCursor);
                    WhereClause pWC2 = pWInfo.sWC;
                    for (ii = (int)(0); (ii) &lt; (pWC2.nTerm); ii++)
                    {
                        WhereTerm pTerm = pWC2.a[ii];
                        if (sqlite3ExprCoveredByIndex(pTerm.pExpr, (int)(iCur), pProbe) == 0)
                        {
                            break;
                        }

                        if ((pTerm.truthProb) &lt;= (0))
                        {
                            nLookup += (short)(pTerm.truthProb);
                        }
                        else
                        {
                            nLookup--;
                            if ((pTerm.eOperator &amp; (0x0002 | 0x0080)) != 0)
                                nLookup -= (short)(19);
                        }
                    }

                    pNew.rRun = (short)(sqlite3LogEstAdd((short)(pNew.rRun), (short)(nLookup)));
                }

                whereLoopOutputAdjust(pWC, pNew, (short)(rSize));
                rc = (int)(whereLoopInsert(pBuilder, pNew));
                pNew.nOut = (short)(rSize);
                if ((rc) != 0)
                    break;
            }
        }

        pBuilder.bldFlags1 = (byte)(0);
        rc = (int)(whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(0)));
        if ((pBuilder.bldFlags1) == (0x0001))
        {
            pTab.tabFlags |= (uint)(0x00000100);
        }
    }

    return (int)(rc);
}</function>
  <function>public static int whereLoopAddBtreeIndex(WhereLoopBuilder pBuilder, SrcItem pSrc, Index pProbe, short nInMul)
{
    WhereInfo pWInfo = pBuilder.pWInfo;
    Parse pParse = pWInfo.pParse;
    sqlite3 db = pParse.db;
    WhereLoop pNew;
    WhereTerm pTerm;
    int opMask = 0;
    WhereScan scan = new WhereScan();
    ulong saved_prereq = 0;
    ushort saved_nLTerm = 0;
    ushort saved_nEq = 0;
    ushort saved_nBtm = 0;
    ushort saved_nTop = 0;
    ushort saved_nSkip = 0;
    uint saved_wsFlags = 0;
    short saved_nOut = 0;
    int rc = (int)(0);
    short rSize = 0;
    short rLogSize = 0;
    WhereTerm pTop = null; WhereTerm  pBtm  =  null ; 
    pNew = pBuilder.pNew;
    if ((db.mallocFailed) != 0)
        return (int)(7);
    if ((pNew.wsFlags &amp; 0x00000020) != 0)
    {
        opMask = (int)((0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)));
    }
    else
    {
        opMask = (int)(0x0002 | 0x0001 | (0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)) | (0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53)) | 0x0100 | 0x0080);
    }

    if ((pProbe.bUnordered) != 0)
        opMask &amp;= (int)(~((0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)) | (0x0002 &lt;&lt; (56 - 53)) | (0x0002 &lt;&lt; (55 - 53))));
    saved_nEq = (ushort)(pNew.u.btree.nEq);
    saved_nBtm = (ushort)(pNew.u.btree.nBtm);
    saved_nTop = (ushort)(pNew.u.btree.nTop);
    saved_nSkip = (ushort)(pNew.nSkip);
    saved_nLTerm = (ushort)(pNew.nLTerm);
    saved_wsFlags = (uint)(pNew.wsFlags);
    saved_prereq = (ulong)(pNew.prereq);
    saved_nOut = (short)(pNew.nOut);
    pTerm = whereScanInit(scan, pBuilder.pWC, (int)(pSrc.iCursor), (int)(saved_nEq), (uint)(opMask), pProbe);
    pNew.rSetup = (short)(0);
    rSize = (short)(pProbe.aiRowLogEst[0]);
    rLogSize = (short)(estLog((short)(rSize)));
    for (; ((rc) == (0)) &amp;&amp; (pTerm != null); pTerm = whereScanNext(scan))
    {
        ushort eOp = (ushort)(pTerm.eOperator);
        short rCostIdx = 0;
        short nOutUnadjusted = 0;
        int nIn = (int)(0);
        if ((((eOp) == (0x0100)) || ((pTerm.wtFlags &amp; 0x0080) != 0)) &amp;&amp; ((indexColumnNotNull(pProbe, (int)(saved_nEq))) != 0))
        {
            continue;
        }

        if ((pTerm.prereqRight &amp; pNew.maskSelf) != 0)
            continue;
        if (((pTerm.wtFlags &amp; 0x0100) != 0) &amp;&amp; ((pTerm.eOperator) == (0x0002 &lt;&lt; (56 - 53))))
            continue;
        if (((pSrc.fg.jointype &amp; 0x0008) != 0) &amp;&amp; (!(((pTerm.pExpr).flags &amp; (0x000001)) != 0)))
        {
            continue;
        }

        if (((pProbe).onError != 0) &amp;&amp; ((saved_nEq) == (pProbe.nKeyCol - 1)))
        {
            pBuilder.bldFlags1 |= (byte)(0x0002);
        }
        else
        {
            pBuilder.bldFlags1 |= (byte)(0x0001);
        }

        pNew.wsFlags = (uint)(saved_wsFlags);
        pNew.u.btree.nEq = (ushort)(saved_nEq);
        pNew.u.btree.nBtm = (ushort)(saved_nBtm);
        pNew.u.btree.nTop = (ushort)(saved_nTop);
        pNew.nLTerm = (ushort)(saved_nLTerm);
        if ((whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1))) != 0)
            break;
        pNew.aLTerm[pNew.nLTerm++] = pTerm;
        pNew.prereq = (ulong)((saved_prereq | pTerm.prereqRight) &amp; ~pNew.maskSelf);
        if ((eOp &amp; 0x0001) != 0)
        {
            Expr pExpr = pTerm.pExpr;
            if ((((pExpr).flags &amp; 0x000800) != 0))
            {
                int i = 0;
                nIn = (int)(46);
                for (i = (int)(0); (i) &lt; (pNew.nLTerm - 1); i++)
                {
                    if (((pNew.aLTerm[i]) != null) &amp;&amp; ((pNew.aLTerm[i].pExpr) == (pExpr)))
                        nIn = (int)(0);
                }
            }
            else if ((((pExpr.x.pList) != null) &amp;&amp; ((pExpr.x.pList.nExpr) != 0)))
            {
                nIn = (int)(sqlite3LogEst((ulong)(pExpr.x.pList.nExpr)));
            }

            if (((pProbe.hasStat1) != 0) &amp;&amp; ((rLogSize) &gt;= (10)))
            {
                short M = 0;
                short logK = 0;
                short x = 0;
                M = (short)(pProbe.aiRowLogEst[saved_nEq]);
                logK = (short)(estLog((short)(nIn)));
                x = (short)(M + logK + 10 - (nIn + rLogSize));
                if ((x) &gt;= (0))
                {
                }
                else if (((nInMul) &lt; (2)) &amp;&amp; (((db).dbOptFlags &amp; (0x00020000)) == (0)))
                {
                    pNew.wsFlags |= (uint)(0x00100000);
                }
                else
                {
                    continue;
                }
            }

            pNew.wsFlags |= (uint)(0x00000004);
        }
        else if ((eOp &amp; (0x0002 | 0x0080)) != 0)
        {
            int iCol = (int)(pProbe.aiColumn[saved_nEq]);
            pNew.wsFlags |= (uint)(0x00000001);
            if (((iCol) == (-1)) || ((((iCol) &gt;= (0)) &amp;&amp; ((nInMul) == (0))) &amp;&amp; ((saved_nEq) == (pProbe.nKeyCol - 1))))
            {
                if ((((iCol) == (-1)) || ((pProbe.uniqNotNull) != 0)) || ((((pProbe.nKeyCol) == (1)) &amp;&amp; ((pProbe.onError) != 0)) &amp;&amp; ((eOp) == (0x0002))))
                {
                    pNew.wsFlags |= (uint)(0x00001000);
                }
                else
                {
                    pNew.wsFlags |= (uint)(0x00010000);
                }
            }

            if ((scan.iEquiv) &gt; (1))
                pNew.wsFlags |= (uint)(0x00200000);
        }
        else if ((eOp &amp; 0x0100) != 0)
        {
            pNew.wsFlags |= (uint)(0x00000008);
        }
        else if ((eOp &amp; ((0x0002 &lt;&lt; (54 - 53)) | (0x0002 &lt;&lt; (57 - 53)))) != 0)
        {
            pNew.wsFlags |= (uint)(0x00000002 | 0x00000020);
            pNew.u.btree.nBtm = (ushort)(whereRangeVectorLen(pParse, (int)(pSrc.iCursor), pProbe, (int)(saved_nEq), pTerm));
            pBtm = pTerm;
            pTop = null;
            if ((pTerm.wtFlags &amp; 0x0100) != 0)
            {
                pTop = pTerm[1];
                if ((whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1))) != 0)
                    break;
                pNew.aLTerm[pNew.nLTerm++] = pTop;
                pNew.wsFlags |= (uint)(0x00000010);
                pNew.u.btree.nTop = (ushort)(1);
            }
        }
        else
        {
            pNew.wsFlags |= (uint)(0x00000002 | 0x00000010);
            pNew.u.btree.nTop = (ushort)(whereRangeVectorLen(pParse, (int)(pSrc.iCursor), pProbe, (int)(saved_nEq), pTerm));
            pTop = pTerm;
            pBtm = (pNew.wsFlags &amp; 0x00000020) != 0 ? pNew.aLTerm[pNew.nLTerm - 2] : null;
        }

        if ((pNew.wsFlags &amp; 0x00000002) != 0)
        {
            whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
        }
        else
        {
            int nEq = (int)(++pNew.u.btree.nEq);
            if (((pTerm.truthProb) &lt;= (0)) &amp;&amp; ((pProbe.aiColumn[saved_nEq]) &gt;= (0)))
            {
                pNew.nOut += (short)(pTerm.truthProb);
                pNew.nOut -= (short)(nIn);
            }
            else
            {
                {
                    pNew.nOut += (short)(pProbe.aiRowLogEst[nEq] - pProbe.aiRowLogEst[nEq - 1]);
                    if ((eOp &amp; 0x0100) != 0)
                    {
                        pNew.nOut += (short)(10);
                    }
                }
            }
        }

        rCostIdx = (short)(pNew.nOut + 1 + (15 * pProbe.szIdxRow) / pSrc.pTab.szTabRow);
        pNew.rRun = (short)(sqlite3LogEstAdd((short)(rLogSize), (short)(rCostIdx)));
        if ((pNew.wsFlags &amp; (0x00000040 | 0x00000100)) == (0))
        {
            pNew.rRun = (short)(sqlite3LogEstAdd((short)(pNew.rRun), (short)(pNew.nOut + 16)));
        }

        nOutUnadjusted = (short)(pNew.nOut);
        pNew.rRun += (short)(nInMul + nIn);
        pNew.nOut += (short)(nInMul + nIn);
        whereLoopOutputAdjust(pBuilder.pWC, pNew, (short)(rSize));
        rc = (int)(whereLoopInsert(pBuilder, pNew));
        if ((pNew.wsFlags &amp; 0x00000002) != 0)
        {
            pNew.nOut = (short)(saved_nOut);
        }
        else
        {
            pNew.nOut = (short)(nOutUnadjusted);
        }

        if ((((pNew.wsFlags &amp; 0x00000010) == (0)) &amp;&amp; ((pNew.u.btree.nEq) &lt; (pProbe.nColumn))) &amp;&amp; (((pNew.u.btree.nEq) &lt; (pProbe.nKeyCol)) || (pProbe.idxType != 2)))
        {
            whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(nInMul + nIn));
        }

        pNew.nOut = (short)(saved_nOut);
    }

    pNew.prereq = (ulong)(saved_prereq);
    pNew.u.btree.nEq = (ushort)(saved_nEq);
    pNew.u.btree.nBtm = (ushort)(saved_nBtm);
    pNew.u.btree.nTop = (ushort)(saved_nTop);
    pNew.nSkip = (ushort)(saved_nSkip);
    pNew.wsFlags = (uint)(saved_wsFlags);
    pNew.nOut = (short)(saved_nOut);
    pNew.nLTerm = (ushort)(saved_nLTerm);
    if (((((((((saved_nEq) == (saved_nSkip)) &amp;&amp; ((saved_nEq + 1) &lt; (pProbe.nKeyCol))) &amp;&amp; ((saved_nEq) == (pNew.nLTerm))) &amp;&amp; ((pProbe.noSkipScan) == (0))) &amp;&amp; (pProbe.hasStat1 != 0)) &amp;&amp; (((db).dbOptFlags &amp; (0x00004000)) == (0))) &amp;&amp; ((pProbe.aiRowLogEst[saved_nEq + 1]) &gt;= (42))) &amp;&amp; ((rc = (int)(whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1)))) == (0)))
    {
        short nIter = 0;
        pNew.u.btree.nEq++;
        pNew.nSkip++;
        pNew.aLTerm[pNew.nLTerm++] = null;
        pNew.wsFlags |= (uint)(0x00008000);
        nIter = (short)(pProbe.aiRowLogEst[saved_nEq] - pProbe.aiRowLogEst[saved_nEq + 1]);
        pNew.nOut -= (short)(nIter);
        nIter += (short)(5);
        whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(nIter + nInMul));
        pNew.nOut = (short)(saved_nOut);
        pNew.u.btree.nEq = (ushort)(saved_nEq);
        pNew.nSkip = (ushort)(saved_nSkip);
        pNew.wsFlags = (uint)(saved_wsFlags);
    }

    return (int)(rc);
}</function>
  <function>public static int whereLoopAddOr(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUnusable)
{
    WhereInfo pWInfo = pBuilder.pWInfo;
    WhereClause pWC;
    WhereLoop pNew;
    WhereTerm pTerm; WhereTerm  pWCEnd ; 
    int rc = (int)(0);
    int iCur = 0;
    WhereClause tempWC = new WhereClause();
    WhereLoopBuilder sSubBuild = new WhereLoopBuilder();
    WhereOrSet sSum = new WhereOrSet(); WhereOrSet  sCur  =  new  WhereOrSet ( ) ; 
    SrcItem pItem;
    pWC = pBuilder.pWC;
    pWCEnd = pWC.a[pWC.nTerm];
    pNew = pBuilder.pNew;
    CRuntime.memset(sSum, (int)(0), (ulong)(sizeof(WhereOrSet)));
    pItem = pWInfo.pTabList.a[pNew.iTab];
    iCur = (int)(pItem.iCursor);
    for (pTerm = pWC.a; ((pTerm) &lt; (pWCEnd)) &amp;&amp; ((rc) == (0)); pTerm++)
    {
        if (((pTerm.eOperator &amp; 0x0200) != 0) &amp;&amp; ((pTerm.u.pOrInfo.indexable &amp; pNew.maskSelf) != 0))
        {
            WhereClause pOrWC = pTerm.u.pOrInfo.wc;
            WhereTerm pOrWCEnd = pOrWC.a[pOrWC.nTerm];
            WhereTerm pOrTerm;
            int once = (int)(1);
            int i = 0;
            int j = 0;
            sSubBuild = (WhereLoopBuilder)(pBuilder);
            sSubBuild.pOrSet = sCur;
            for (pOrTerm = pOrWC.a; (pOrTerm) &lt; (pOrWCEnd); pOrTerm++)
            {
                if ((pOrTerm.eOperator &amp; 0x0400) != 0)
                {
                    sSubBuild.pWC = pOrTerm.u.pAndInfo.wc;
                }
                else if ((pOrTerm.leftCursor) == (iCur))
                {
                    tempWC.pWInfo = pWC.pWInfo;
                    tempWC.pOuter = pWC;
                    tempWC.op = (byte)(44);
                    tempWC.nTerm = (int)(1);
                    tempWC.nBase = (int)(1);
                    tempWC.a = pOrTerm;
                    sSubBuild.pWC = tempWC;
                }
                else
                {
                    continue;
                }

                sCur.n = (ushort)(0);
                if ((((pItem.pTab).eTabType) == (1)))
                {
                    rc = (int)(whereLoopAddVirtual(sSubBuild, (ulong)(mPrereq), (ulong)(mUnusable)));
                }
                else
                {
                    rc = (int)(whereLoopAddBtree(sSubBuild, (ulong)(mPrereq)));
                }

                if ((rc) == (0))
                {
                    rc = (int)(whereLoopAddOr(sSubBuild, (ulong)(mPrereq), (ulong)(mUnusable)));
                }

                if ((sCur.n) == (0))
                {
                    sSum.n = (ushort)(0);
                    break;
                }
                else if ((once) != 0)
                {
                    whereOrMove(sSum, sCur);
                    once = (int)(0);
                }
                else
                {
                    WhereOrSet sPrev = new WhereOrSet();
                    whereOrMove(sPrev, sSum);
                    sSum.n = (ushort)(0);
                    for (i = (int)(0); (i) &lt; (sPrev.n); i++)
                    {
                        for (j = (int)(0); (j) &lt; (sCur.n); j++)
                        {
                            whereOrInsert(sSum, (ulong)(sPrev.a[i].prereq | sCur.a[j].prereq), (short)(sqlite3LogEstAdd((short)(sPrev.a[i].rRun), (short)(sCur.a[j].rRun))), (short)(sqlite3LogEstAdd((short)(sPrev.a[i].nOut), (short)(sCur.a[j].nOut))));
                        }
                    }
                }
            }

            pNew.nLTerm = (ushort)(1);
            pNew.aLTerm[0] = pTerm;
            pNew.wsFlags = (uint)(0x00002000);
            pNew.rSetup = (short)(0);
            pNew.iSortIdx = (byte)(0);
            CRuntime.memset(&amp;pNew.u, (int)(0), (ulong)(sizeof(union WhereLoop::(unnamed at sqlite3.c : 146967 : 3)) ) ) ;  for  ( i  =  ( int ) ( 0 ) ;  ( ( rc ) == ( 0 ) ) &amp;&amp; ( ( i ) &lt; ( sSum . n ) ) ;  i ++ ) { pNew . rRun  =  ( short ) ( sSum . a [ i ] . rRun + 1 ) ;  pNew . nOut  =  ( short ) ( sSum . a [ i ] . nOut ) ;  pNew . prereq  =  ( ulong ) ( sSum . a [ i ] . prereq ) ;  rc  =  ( int ) ( whereLoopInsert ( pBuilder ,  pNew ) ) ;  } } }

    return (int)(rc);
}</function>
  <function>public static int whereLoopAddVirtual(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUnusable)
{
    int rc = (int)(0);
    WhereInfo pWInfo;
    Parse pParse;
    WhereClause pWC;
    SrcItem pSrc;
    sqlite3_index_info* p;
    int nConstraint = 0;
    int bIn = 0;
    WhereLoop pNew;
    ulong mBest = 0;
    ushort mNoOmit = 0;
    int bRetry = (int)(0);
    pWInfo = pBuilder.pWInfo;
    pParse = pWInfo.pParse;
    pWC = pBuilder.pWC;
    pNew = pBuilder.pNew;
    pSrc = pWInfo.pTabList.a[pNew.iTab];
    p = allocateIndexInfo(pWInfo, pWC, (ulong)(mUnusable), pSrc, &amp;mNoOmit);
    if ((p) == (null))
        return (int)(7);
    pNew.rSetup = (short)(0);
    pNew.wsFlags = (uint)(0x00000400);
    pNew.nLTerm = (ushort)(0);
    pNew.u.vtab.needFree = (uint)(0);
    nConstraint = (int)(p-&gt;nConstraint);
    if ((whereLoopResize(pParse.db, pNew, (int)(nConstraint))) != 0)
    {
        freeIndexInfo(pParse.db, p);
        return (int)(7);
    }

    rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0), p, (ushort)(mNoOmit), &amp;bIn, &amp;bRetry));
    if ((bRetry) != 0)
    {
        rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0), p, (ushort)(mNoOmit), &amp;bIn, null));
    }

    if (((rc) == (0)) &amp;&amp; (((mBest = (ulong)(pNew.prereq &amp; ~mPrereq)) != 0) || ((bIn) != 0)))
    {
        int seenZero = (int)(0);
        int seenZeroNoIN = (int)(0);
        ulong mPrev = (ulong)(0);
        ulong mBestNoIn = (ulong)(0);
        if ((bIn) != 0)
        {
            rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0x0001), p, (ushort)(mNoOmit), &amp;bIn, null));
            mBestNoIn = (ulong)(pNew.prereq &amp; ~mPrereq);
            if ((mBestNoIn) == (0))
            {
                seenZero = (int)(1);
                seenZeroNoIN = (int)(1);
            }
        }

        while ((rc) == (0))
        {
            int i = 0;
            ulong mNext = ((ulong)(-1));
            for (i = (int)(0); (i) &lt; (nConstraint); i++)
            {
                ulong mThis = (ulong)(pWC.a[p-&gt;aConstraint[i].iTermOffset].prereqRight &amp; ~mPrereq);
                if (((mThis) &gt; (mPrev)) &amp;&amp; ((mThis) &lt; (mNext)))
                    mNext = (ulong)(mThis);
            }

            mPrev = (ulong)(mNext);
            if ((mNext) == ((ulong)(-1)))
                break;
            if (((mNext) == (mBest)) || ((mNext) == (mBestNoIn)))
                continue;
            rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mNext | mPrereq), (ushort)(0), p, (ushort)(mNoOmit), &amp;bIn, null));
            if ((pNew.prereq) == (mPrereq))
            {
                seenZero = (int)(1);
                if ((bIn) == (0))
                    seenZeroNoIN = (int)(1);
            }
        }

        if (((rc) == (0)) &amp;&amp; ((seenZero) == (0)))
        {
            rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mPrereq), (ushort)(0), p, (ushort)(mNoOmit), &amp;bIn, null));
            if ((bIn) == (0))
                seenZeroNoIN = (int)(1);
        }

        if (((rc) == (0)) &amp;&amp; ((seenZeroNoIN) == (0)))
        {
            rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mPrereq), (ushort)(0x0001), p, (ushort)(mNoOmit), &amp;bIn, null));
        }
    }

    if ((p-&gt;needToFreeIdxStr) != 0)
        sqlite3_free(p-&gt;idxStr);
    freeIndexInfo(pParse.db, p);
    return (int)(rc);
}</function>
  <function>public static int whereLoopAddVirtualOne(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUsable, ushort mExclude, sqlite3_index_info* pIdxInfo, ushort mNoOmit, int* pbIn, int* pbRetryLimit)
{
    WhereClause pWC = pBuilder.pWC;
    HiddenIndexInfo pHidden = (HiddenIndexInfo)(&amp;pIdxInfo[1]);
    sqlite3_index_constraint* pIdxCons;
    sqlite3_index_constraint_usage* pUsage = pIdxInfo-&gt;aConstraintUsage;
    int i = 0;
    int mxTerm = 0;
    int rc = (int)(0);
    WhereLoop pNew = pBuilder.pNew;
    Parse pParse = pBuilder.pWInfo.pParse;
    SrcItem pSrc = pBuilder.pWInfo.pTabList.a[pNew.iTab];
    int nConstraint = (int)(pIdxInfo-&gt;nConstraint);
    *pbIn = (int)(0);
    pNew.prereq = (ulong)(mPrereq);
    pIdxCons = *&amp;pIdxInfo-&gt;aConstraint;
    for (i = (int)(0); (i) &lt; (nConstraint); i++, pIdxCons++)
    {
        WhereTerm pTerm = pWC.a[pIdxCons-&gt;iTermOffset];
        pIdxCons-&gt;usable = (byte)(0);
        if ((((pTerm.prereqRight &amp; mUsable) == (pTerm.prereqRight)) &amp;&amp; ((pTerm.eOperator &amp; mExclude) == (0))) &amp;&amp; (((pbRetryLimit) != null) || (isLimitTerm(pTerm) == 0)))
        {
            pIdxCons-&gt;usable = (byte)(1);
        }
    }

    CRuntime.memset(pUsage, (int)(0), (ulong)(sizeof(sqlite3_index_constraint_usage) * nConstraint));
    pIdxInfo-&gt;idxStr = null;
    pIdxInfo-&gt;idxNum = (int)(0);
    pIdxInfo-&gt;orderByConsumed = (int)(0);
    pIdxInfo-&gt;estimatedCost = (double)((1e99) / (double)(2));
    pIdxInfo-&gt;estimatedRows = (long)(25);
    pIdxInfo-&gt;idxFlags = (int)(0);
    pIdxInfo-&gt;colUsed = (ulong)((long)(pSrc.colUsed));
    pHidden.mHandleIn = (uint)(0);
    rc = (int)(vtabBestIndex(pParse, pSrc.pTab, pIdxInfo));
    if ((rc) != 0)
    {
        if ((rc) == (19))
        {
            return (int)(0);
        }

        return (int)(rc);
    }

    mxTerm = (int)(-1);
    CRuntime.memset(pNew.aLTerm, (int)(0), (ulong)(sizeof(WhereTerm) * nConstraint));
    CRuntime.memset(&amp;pNew.u.vtab, (int)(0), (ulong)(sizeof(WhereLoop::(unnamed at sqlite3.c : 146975 : 5))) ) ; 
    pIdxCons = *&amp;pIdxInfo-&gt;aConstraint;
    for (i = (int)(0); (i) &lt; (nConstraint); i++, pIdxCons++)
    {
        int iTerm = 0;
        if ((iTerm = (int)(pUsage[i].argvIndex - 1)) &gt;= (0))
        {
            WhereTerm pTerm;
            int j = (int)(pIdxCons-&gt;iTermOffset);
            if ((((((iTerm) &gt;= (nConstraint)) || ((j) &lt; (0))) || ((j) &gt;= (pWC.nTerm))) || (pNew.aLTerm[iTerm] != null)) || ((pIdxCons-&gt;usable) == (0)))
            {
                sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc.pTab.zName);
                return (int)(1);
            }

            pTerm = pWC.a[j];
            pNew.prereq |= (ulong)(pTerm.prereqRight);
            pNew.aLTerm[iTerm] = pTerm;
            if ((iTerm) &gt; (mxTerm))
                mxTerm = (int)(iTerm);
            if ((pUsage[i].omit) != 0)
            {
                if (((i) &lt; (16)) &amp;&amp; (((1 &lt;&lt; i) &amp; mNoOmit) == (0)))
                {
                    pNew.u.vtab.omitMask |= (ushort)(1 &lt;&lt; iTerm);
                }
                else
                {
                }

                if ((pTerm.eMatchOp) == (74))
                {
                    pNew.u.vtab.bOmitOffset = (uint)(1);
                }
            }

            if ((((i) &lt;= (31) ? ((uint)(1)) &lt;&lt; (i) : 0) &amp; pHidden.mHandleIn) != 0)
            {
                pNew.u.vtab.mHandleIn |= (uint)(((uint)(1)) &lt;&lt; (iTerm));
            }
            else if ((pTerm.eOperator &amp; 0x0001) != 0)
            {
                pIdxInfo-&gt;orderByConsumed = (int)(0);
                pIdxInfo-&gt;idxFlags &amp;= (int)(~1);
                *pbIn = (int)(1);
            }

            if (((isLimitTerm(pTerm)) != 0) &amp;&amp; ((*pbIn) != 0))
            {
                if ((pIdxInfo-&gt;needToFreeIdxStr) != 0)
                {
                    sqlite3_free(pIdxInfo-&gt;idxStr);
                    pIdxInfo-&gt;idxStr = null;
                    pIdxInfo-&gt;needToFreeIdxStr = (int)(0);
                }

                *pbRetryLimit = (int)(1);
                return (int)(0);
            }
        }
    }

    pNew.nLTerm = (ushort)(mxTerm + 1);
    for (i = (int)(0); (i) &lt;= (mxTerm); i++)
    {
        if ((pNew.aLTerm[i]) == (null))
        {
            sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc.pTab.zName);
            return (int)(1);
        }
    }

    pNew.u.vtab.idxNum = (int)(pIdxInfo-&gt;idxNum);
    pNew.u.vtab.needFree = (uint)(pIdxInfo-&gt;needToFreeIdxStr);
    pIdxInfo-&gt;needToFreeIdxStr = (int)(0);
    pNew.u.vtab.idxStr = pIdxInfo-&gt;idxStr;
    pNew.u.vtab.isOrdered = ((sbyte)((pIdxInfo-&gt;orderByConsumed) != 0 ? pIdxInfo-&gt;nOrderBy : 0));
    pNew.rSetup = (short)(0);
    pNew.rRun = (short)(sqlite3LogEstFromDouble((double)(pIdxInfo-&gt;estimatedCost)));
    pNew.nOut = (short)(sqlite3LogEst((ulong)(pIdxInfo-&gt;estimatedRows)));
    if ((pIdxInfo-&gt;idxFlags &amp; 1) != 0)
    {
        pNew.wsFlags |= (uint)(0x00001000);
    }
    else
    {
        pNew.wsFlags &amp;= (uint)(~0x00001000);
    }

    rc = (int)(whereLoopInsert(pBuilder, pNew));
    if ((pNew.u.vtab.needFree) != 0)
    {
        sqlite3_free(pNew.u.vtab.idxStr);
        pNew.u.vtab.needFree = (uint)(0);
    }

    return (int)(rc);
}</function>
  <function>public static void whereLoopAdjustCost(WhereLoop p, WhereLoop pTemplate)
{
    if ((pTemplate.wsFlags &amp; 0x00000200) == (0))
        return;
    for (p;; p = p.pNextLoop)
    {
        if (p.iTab != pTemplate.iTab)
            continue;
        if ((p.wsFlags &amp; 0x00000200) == (0))
            continue;
        if ((whereLoopCheaperProperSubset(p, pTemplate)) != 0)
        {
            pTemplate.rRun = (short)((p.rRun) &lt; (pTemplate.rRun) ? (p.rRun) : (pTemplate.rRun));
            pTemplate.nOut = (short)((p.nOut - 1) &lt; (pTemplate.nOut) ? (p.nOut - 1) : (pTemplate.nOut));
        }
        else if ((whereLoopCheaperProperSubset(pTemplate, p)) != 0)
        {
            pTemplate.rRun = (short)((p.rRun) &gt; (pTemplate.rRun) ? (p.rRun) : (pTemplate.rRun));
            pTemplate.nOut = (short)((p.nOut + 1) &gt; (pTemplate.nOut) ? (p.nOut + 1) : (pTemplate.nOut));
        }
    }
}</function>
  <function>public static int whereLoopCheaperProperSubset(WhereLoop pX, WhereLoop pY)
{
    int i = 0; int  j  =  0 ; 
    if ((pX.nLTerm - pX.nSkip) &gt;= (pY.nLTerm - pY.nSkip))
    {
        return (int)(0);
    }

    if (((pX.rRun) &gt; (pY.rRun)) &amp;&amp; ((pX.nOut) &gt; (pY.nOut)))
        return (int)(0);
    if ((pY.nSkip) &gt; (pX.nSkip))
        return (int)(0);
    for (i = (int)(pX.nLTerm - 1); (i) &gt;= (0); i--)
    {
        if ((pX.aLTerm[i]) == (null))
            continue;
        for (j = (int)(pY.nLTerm - 1); (j) &gt;= (0); j--)
        {
            if ((pY.aLTerm[j]) == (pX.aLTerm[i]))
                break;
        }

        if ((j) &lt; (0))
            return (int)(0);
    }

    if (((pX.wsFlags &amp; 0x00000040) != 0) &amp;&amp; ((pY.wsFlags &amp; 0x00000040) == (0)))
    {
        return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static void whereLoopClear(sqlite3 db, WhereLoop p)
{
    if (p.aLTerm != p.aLTermSpace)
        sqlite3DbFreeNN(db, p.aLTerm);
    whereLoopClearUnion(db, p);
    whereLoopInit(p);
}</function>
  <function>public static void whereLoopClearUnion(sqlite3 db, WhereLoop p)
{
    if ((p.wsFlags &amp; (0x00000400 | 0x00004000)) != 0)
    {
        if (((p.wsFlags &amp; 0x00000400) != 0) &amp;&amp; ((p.u.vtab.needFree) != 0))
        {
            sqlite3_free(p.u.vtab.idxStr);
            p.u.vtab.needFree = (uint)(0);
            p.u.vtab.idxStr = null;
        }
        else if (((p.wsFlags &amp; 0x00004000) != 0) &amp;&amp; (p.u.btree.pIndex != null))
        {
            sqlite3DbFree(db, p.u.btree.pIndex.zColAff);
            sqlite3DbFreeNN(db, p.u.btree.pIndex);
            p.u.btree.pIndex = null;
        }
    }
}</function>
  <function>public static void whereLoopDelete(sqlite3 db, WhereLoop p)
{
    whereLoopClear(db, p);
    sqlite3DbFreeNN(db, p);
}</function>
  <function>public static WhereLoop whereLoopFindLesser(WhereLoop ppPrev, WhereLoop pTemplate)
{
    WhereLoop p;
    for (p = (ppPrev); p; ppPrev = p.pNextLoop, p = ppPrev)
    {
        if ((p.iTab != pTemplate.iTab) || (p.iSortIdx != pTemplate.iSortIdx))
        {
            continue;
        }

        if ((((((p.wsFlags &amp; 0x00004000) != 0) &amp;&amp; ((pTemplate.nSkip) == (0))) &amp;&amp; ((pTemplate.wsFlags &amp; 0x00000200) != 0)) &amp;&amp; ((pTemplate.wsFlags &amp; 0x00000001) != 0)) &amp;&amp; ((p.prereq &amp; pTemplate.prereq) == (pTemplate.prereq)))
        {
            break;
        }

        if (((((p.prereq &amp; pTemplate.prereq) == (p.prereq)) &amp;&amp; ((p.rSetup) &lt;= (pTemplate.rSetup))) &amp;&amp; ((p.rRun) &lt;= (pTemplate.rRun))) &amp;&amp; ((p.nOut) &lt;= (pTemplate.nOut)))
        {
            return null;
        }

        if ((((p.prereq &amp; pTemplate.prereq) == (pTemplate.prereq)) &amp;&amp; ((p.rRun) &gt;= (pTemplate.rRun))) &amp;&amp; ((p.nOut) &gt;= (pTemplate.nOut)))
        {
            break;
        }
    }

    return ppPrev;
}</function>
  <function>public static void whereLoopInit(WhereLoop p)
{
    p.aLTerm = p.aLTermSpace;
    p.nLTerm = (ushort)(0);
    p.nLSlot = (ushort)((int)(3 * sizeof(WhereTerm) / sizeof(WhereTerm)));
    p.wsFlags = (uint)(0);
}</function>
  <function>public static int whereLoopInsert(WhereLoopBuilder pBuilder, WhereLoop pTemplate)
{
    WhereLoop ppPrev; WhereLoop  p ; 
    WhereInfo pWInfo = pBuilder.pWInfo;
    sqlite3 db = pWInfo.pParse.db;
    int rc = 0;
    if ((pBuilder.iPlanLimit) == (0))
    {
        if ((pBuilder.pOrSet) != null)
            pBuilder.pOrSet.n = (ushort)(0);
        return (int)(101);
    }

    pBuilder.iPlanLimit--;
    whereLoopAdjustCost(pWInfo.pLoops, pTemplate);
    if (pBuilder.pOrSet != null)
    {
        if ((pTemplate.nLTerm) != 0)
        {
            whereOrInsert(pBuilder.pOrSet, (ulong)(pTemplate.prereq), (short)(pTemplate.rRun), (short)(pTemplate.nOut));
        }

        return (int)(0);
    }

    ppPrev = whereLoopFindLesser(pWInfo.pLoops, pTemplate);
    if ((ppPrev) == (null))
    {
        return (int)(0);
    }
    else
    {
        p = ppPrev;
    }

    if ((p) == (null))
    {
        ppPrev = p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereLoop)));
        if ((p) == (null))
            return (int)(7);
        whereLoopInit(p);
        p.pNextLoop = null;
    }
    else
    {
        WhereLoop ppTail = p.pNextLoop;
        WhereLoop pToDel;
        while ((ppTail) != null)
        {
            ppTail = whereLoopFindLesser(ppTail, pTemplate);
            if ((ppTail) == (null))
                break;
            pToDel = ppTail;
            if ((pToDel) == (null))
                break;
            ppTail = pToDel.pNextLoop;
            whereLoopDelete(db, pToDel);
        }
    }

    rc = (int)(whereLoopXfer(db, p, pTemplate));
    if ((p.wsFlags &amp; 0x00000400) == (0))
    {
        Index pIndex = p.u.btree.pIndex;
        if (((pIndex) != null) &amp;&amp; ((pIndex.idxType) == (3)))
        {
            p.u.btree.pIndex = null;
        }
    }

    return (int)(rc);
}</function>
  <function>public static void whereLoopOutputAdjust(WhereClause pWC, WhereLoop pLoop, short nRow)
{
    WhereTerm pTerm; WhereTerm  pX ; 
    ulong notAllowed = (ulong)(~(pLoop.prereq | pLoop.maskSelf));
    int i = 0; int  j  =  0 ; 
    short iReduce = (short)(0);
    for (i = (int)(pWC.nBase), pTerm = pWC.a; (i) &gt; (0); i--, pTerm++)
    {
        if ((pTerm.prereqAll &amp; notAllowed) != 0)
            continue;
        if ((pTerm.prereqAll &amp; pLoop.maskSelf) == (0))
            continue;
        if ((pTerm.wtFlags &amp; 0x0002) != 0)
            continue;
        for (j = (int)(pLoop.nLTerm - 1); (j) &gt;= (0); j--)
        {
            pX = pLoop.aLTerm[j];
            if ((pX) == (null))
                continue;
            if ((pX) == (pTerm))
                break;
            if (((pX.iParent) &gt;= (0)) &amp;&amp; ((pWC.a[pX.iParent]) == (pTerm)))
                break;
        }

        if ((j) &lt; (0))
        {
            if ((pLoop.maskSelf) == (pTerm.prereqAll))
            {
                if (((pTerm.eOperator &amp; 0x3f) != 0) || ((pWC.pWInfo.pTabList.a[pLoop.iTab].fg.jointype &amp; 0x0008) == (0)))
                {
                    pLoop.wsFlags |= (uint)(0x00800000);
                }
            }

            if ((pTerm.truthProb) &lt;= (0))
            {
                pLoop.nOut += (short)(pTerm.truthProb);
            }
            else
            {
                pLoop.nOut--;
                if (((pTerm.eOperator &amp; (0x0002 | 0x0080)) != 0) &amp;&amp; ((pTerm.wtFlags &amp; 0) == (0)))
                {
                    Expr pRight = pTerm.pExpr.pRight;
                    int k = (int)(0);
                    if ((((sqlite3ExprIsInteger(pRight, &amp;k)) != 0) &amp;&amp; ((k) &gt;= (-1))) &amp;&amp; ((k) &lt;= (1)))
                    {
                        k = (int)(10);
                    }
                    else
                    {
                        k = (int)(20);
                    }

                    if ((iReduce) &lt; (k))
                    {
                        pTerm.wtFlags |= (ushort)(0x2000);
                        iReduce = (short)(k);
                    }
                }
            }
        }
    }

    if ((pLoop.nOut) &gt; (nRow - iReduce))
    {
        pLoop.nOut = (short)(nRow - iReduce);
    }
}</function>
  <function>public static int whereLoopResize(sqlite3 db, WhereLoop p, int n)
{
    WhereTerm paNew;
    if ((p.nLSlot) &gt;= (n))
        return (int)(0);
    n = (int)((n + 7) &amp; ~7);
    paNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereTerm) * n));
    if ((paNew) == (null))
        return (int)(7);
    CRuntime.memcpy(paNew, p.aLTerm, (ulong)(sizeof(WhereTerm) * p.nLSlot));
    if (p.aLTerm != p.aLTermSpace)
        sqlite3DbFreeNN(db, p.aLTerm);
    p.aLTerm = paNew;
    p.nLSlot = (ushort)(n);
    return (int)(0);
}</function>
  <function>public static int whereLoopXfer(sqlite3 db, WhereLoop pTo, WhereLoop pFrom)
{
    whereLoopClearUnion(db, pTo);
    if ((whereLoopResize(db, pTo, (int)(pFrom.nLTerm))) != 0)
    {
        CRuntime.memset(pTo, (int)(0), ((ulong)(&amp;((0).nLSlot))));
        return (int)(7);
    }

    CRuntime.memcpy(pTo, pFrom, ((ulong)(&amp;((0).nLSlot))));
    CRuntime.memcpy(pTo.aLTerm, pFrom.aLTerm, (ulong)(pTo.nLTerm * sizeof(WhereTerm)));
    if ((pFrom.wsFlags &amp; 0x00000400) != 0)
    {
        pFrom.u.vtab.needFree = (uint)(0);
    }
    else if ((pFrom.wsFlags &amp; 0x00004000) != 0)
    {
        pFrom.u.btree.pIndex = null;
    }

    return (int)(0);
}</function>
  <function>public static WhereTerm whereNthSubterm(WhereTerm pTerm, int N)
{
    if (pTerm.eOperator != 0x0400)
    {
        return (N) == (0) ? pTerm : null;
    }

    if ((N) &lt; (pTerm.u.pAndInfo.wc.nTerm))
    {
        return pTerm.u.pAndInfo.wc.a[N];
    }

    return null;
}</function>
  <function>public static ulong whereOmitNoopJoin(WhereInfo pWInfo, ulong notReady)
{
    int i = 0;
    ulong tabUsed = 0;
    tabUsed = (ulong)(sqlite3WhereExprListUsage(&amp;pWInfo.sMaskSet, pWInfo.pResultSet));
    if ((pWInfo.pOrderBy) != null)
    {
        tabUsed |= (ulong)(sqlite3WhereExprListUsage(&amp;pWInfo.sMaskSet, pWInfo.pOrderBy));
    }

    for (i = (int)(pWInfo.nLevel - 1); (i) &gt;= (1); i--)
    {
        WhereTerm pTerm;
        WhereTerm pEnd;
        SrcItem pItem;
        WhereLoop pLoop;
        pLoop = pWInfo.a[i].pWLoop;
        pItem = pWInfo.pTabList.a[pLoop.iTab];
        if ((pItem.fg.jointype &amp; 0x0008) == (0))
            continue;
        if (((pWInfo.wctrlFlags &amp; 0x0100) == (0)) &amp;&amp; ((pLoop.wsFlags &amp; 0x00001000) == (0)))
        {
            continue;
        }

        if ((tabUsed &amp; pLoop.maskSelf) != 0)
            continue;
        pEnd = pWInfo.sWC.a[pWInfo.sWC.nTerm];
        for (pTerm = pWInfo.sWC.a; (pTerm) &lt; (pEnd); pTerm++)
        {
            if ((pTerm.prereqAll &amp; pLoop.maskSelf) != 0)
            {
                if ((!(((pTerm.pExpr).flags &amp; (0x000001)) != 0)) || (pTerm.pExpr.w.iRightJoinTable != pItem.iCursor))
                {
                    break;
                }
            }
        }

        if ((pTerm) &lt; (pEnd))
            continue;
        notReady &amp;= (ulong)(~pLoop.maskSelf);
        for (pTerm = pWInfo.sWC.a; (pTerm) &lt; (pEnd); pTerm++)
        {
            if ((pTerm.prereqAll &amp; pLoop.maskSelf) != 0)
            {
                pTerm.wtFlags |= (ushort)(0x0004);
            }
        }

        if (i != pWInfo.nLevel - 1)
        {
            int nByte = (int)((pWInfo.nLevel - 1 - i) * sizeof(WhereLevel));
            CRuntime.memmove(pWInfo.a[i], pWInfo.a[i + 1], (ulong)(nByte));
        }

        pWInfo.nLevel--;
    }

    return (ulong)(notReady);
}</function>
  <function>public static void whereOrInfoDelete(sqlite3 db, WhereOrInfo p)
{
    sqlite3WhereClauseClear(p.wc);
    sqlite3DbFree(db, p);
}</function>
  <function>public static int whereOrInsert(WhereOrSet pSet, ulong prereq, short rRun, short nOut)
{
    ushort i = 0;
    WhereOrCost* p;
    for (i = (ushort)(pSet.n), p = pSet.a; (i) &gt; (0); i--, p++)
    {
        if (((rRun) &lt;= (p-&gt;rRun)) &amp;&amp; ((prereq &amp; p-&gt;prereq) == (prereq)))
        {
            goto whereOrInsert_done;
        }

        if (((p-&gt;rRun) &lt;= (rRun)) &amp;&amp; ((p-&gt;prereq &amp; prereq) == (p-&gt;prereq)))
        {
            return (int)(0);
        }
    }

    if ((pSet.n) &lt; (3))
    {
        p = &amp;pSet.a[pSet.n++];
        p-&gt;nOut = (short)(nOut);
    }
    else
    {
        p = pSet.a;
        for (i = (ushort)(1); (i) &lt; (pSet.n); i++)
        {
            if ((p-&gt;rRun) &gt; (pSet.a[i].rRun))
                p = pSet.a + i;
        }

        if ((p-&gt;rRun) &lt;= (rRun))
            return (int)(0);
    }

    whereOrInsert_done:
        ; p -&gt; prereq  =  ( ulong ) ( prereq ) ; 
    p-&gt;rRun = (short)(rRun);
    if ((p-&gt;nOut) &gt; (nOut))
        p-&gt;nOut = (short)(nOut);
    return (int)(1);
}</function>
  <function>public static void whereOrMove(WhereOrSet pDest, WhereOrSet pSrc)
{
    pDest.n = (ushort)(pSrc.n);
    CRuntime.memcpy(pDest.a, pSrc.a, (ulong)(pDest.n * sizeof(WhereOrCost)));
}</function>
  <function>public static sbyte wherePathSatisfiesOrderBy(WhereInfo pWInfo, ExprList pOrderBy, WherePath pPath, ushort wctrlFlags, ushort nLoop, WhereLoop pLast, ulong* pRevMask)
{
    byte revSet = 0;
    byte rev = 0;
    byte revIdx = 0;
    byte isOrderDistinct = 0;
    byte distinctColumns = 0;
    byte isMatch = 0;
    ushort eqOpMask = 0;
    ushort nKeyCol = 0;
    ushort nColumn = 0;
    ushort nOrderBy = 0;
    int iLoop = 0;
    int i = 0; int  j  =  0 ; 
    int iCur = 0;
    int iColumn = 0;
    WhereLoop pLoop = null;
    WhereTerm pTerm;
    Expr pOBExpr;
    CollSeq pColl;
    Index pIndex;
    sqlite3 db = pWInfo.pParse.db;
    ulong obSat = (ulong)(0);
    ulong obDone = 0;
    ulong orderDistinctMask = 0;
    ulong ready = 0;
    if (((nLoop) != 0) &amp;&amp; (((db).dbOptFlags &amp; (0x00000040)) != 0))
        return (sbyte)(0);
    nOrderBy = (ushort)(pOrderBy.nExpr);
    if ((nOrderBy) &gt; (((int)(sizeof(ulong) * 8)) - 1))
        return (sbyte)(0);
    isOrderDistinct = (byte)(1);
    obDone = (ulong)((((ulong)(1)) &lt;&lt; (nOrderBy)) - 1);
    orderDistinctMask = (ulong)(0);
    ready = (ulong)(0);
    eqOpMask = (ushort)(0x0002 | 0x0080 | 0x0100);
    if ((wctrlFlags &amp; (0x0800 | 0x0002 | 0x0001)) != 0)
    {
        eqOpMask |= (ushort)(0x0001);
    }

    for (iLoop = (int)(0); (((isOrderDistinct) != 0) &amp;&amp; ((obSat) &lt; (obDone))) &amp;&amp; ((iLoop) &lt;= (nLoop)); iLoop++)
    {
        if ((iLoop) &gt; (0))
            ready |= (ulong)(pLoop.maskSelf);
        if ((iLoop) &lt; (nLoop))
        {
            pLoop = pPath.aLoop[iLoop];
            if ((wctrlFlags &amp; 0x0800) != 0)
                continue;
        }
        else
        {
            pLoop = pLast;
        }

        if ((pLoop.wsFlags &amp; 0x00000400) != 0)
        {
            if (((pLoop.u.vtab.isOrdered) != 0) &amp;&amp; ((wctrlFlags &amp; 0x0080) == (0)))
            {
                obSat = (ulong)(obDone);
            }

            break;
        }
        else if ((wctrlFlags &amp; 0x0080) != 0)
        {
            pLoop.u.btree.nDistinctCol = (ushort)(0);
        }

        iCur = (int)(pWInfo.pTabList.a[pLoop.iTab].iCursor);
        for (i = (int)(0); (i) &lt; (nOrderBy); i++)
        {
            if (((((ulong)(1)) &lt;&lt; (i)) &amp; obSat) != 0)
                continue;
            pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy.a[i].pExpr);
            if (((pOBExpr) == (null)))
                continue;
            if ((pOBExpr.op != 167) &amp;&amp; (pOBExpr.op != 169))
                continue;
            if (pOBExpr.iTable != iCur)
                continue;
            pTerm = sqlite3WhereFindTerm(pWInfo.sWC, (int)(iCur), (int)(pOBExpr.iColumn), (ulong)(~ready), (uint)(eqOpMask), null);
            if ((pTerm) == (null))
                continue;
            if ((pTerm.eOperator) == (0x0001))
            {
                for (j = (int)(0); ((j) &lt; (pLoop.nLTerm)) &amp;&amp; (pTerm != pLoop.aLTerm[j]); j++)
                {
                }

                if ((j) &gt;= (pLoop.nLTerm))
                    continue;
            }

            if (((pTerm.eOperator &amp; (0x0002 | 0x0080)) != 0) &amp;&amp; ((pOBExpr.iColumn) &gt;= (0)))
            {
                Parse pParse = pWInfo.pParse;
                CollSeq pColl1 = sqlite3ExprNNCollSeq(pParse, pOrderBy.a[i].pExpr);
                CollSeq pColl2 = sqlite3ExprCompareCollSeq(pParse, pTerm.pExpr);
                if (((pColl2) == (null)) || ((sqlite3StrICmp(pColl1.zName, pColl2.zName)) != 0))
                {
                    continue;
                }
            }

            obSat |= (ulong)(((ulong)(1)) &lt;&lt; (i));
        }

        if ((pLoop.wsFlags &amp; 0x00001000) == (0))
        {
            if ((pLoop.wsFlags &amp; 0x00000100) != 0)
            {
                pIndex = null;
                nKeyCol = (ushort)(0);
                nColumn = (ushort)(1);
            }
            else if (((pIndex = pLoop.u.btree.pIndex) == (null)) || ((pIndex.bUnordered) != 0))
            {
                return (sbyte)(0);
            }
            else
            {
                nKeyCol = (ushort)(pIndex.nKeyCol);
                nColumn = (ushort)(pIndex.nColumn);
                isOrderDistinct = (byte)(((pIndex).onError != 0) &amp;&amp; ((pLoop.wsFlags &amp; 0x00008000) == (0)));
            }

            rev = (byte)(revSet = (byte)(0));
            distinctColumns = (byte)(0);
            for (j = (int)(0); (j) &lt; (nColumn); j++)
            {
                byte bOnce = (byte)(1);
                if (((j) &lt; (pLoop.u.btree.nEq)) &amp;&amp; ((j) &gt;= (pLoop.nSkip)))
                {
                    ushort eOp = (ushort)(pLoop.aLTerm[j].eOperator);
                    if ((eOp &amp; eqOpMask) != 0)
                    {
                        if ((eOp &amp; (0x0100 | 0x0080)) != 0)
                        {
                            isOrderDistinct = (byte)(0);
                        }

                        continue;
                    }
                    else if ((eOp &amp; 0x0001) != 0)
                    {
                        Expr pX = pLoop.aLTerm[j].pExpr;
                        for (i = (int)(j + 1); (i) &lt; (pLoop.u.btree.nEq); i++)
                        {
                            if ((pLoop.aLTerm[i].pExpr) == (pX))
                            {
                                bOnce = (byte)(0);
                                break;
                            }
                        }
                    }
                }

                if ((pIndex) != null)
                {
                    iColumn = (int)(pIndex.aiColumn[j]);
                    revIdx = (byte)(pIndex.aSortOrder[j] &amp; 0x01);
                    if ((iColumn) == (pIndex.pTable.iPKey))
                        iColumn = (int)(-1);
                }
                else
                {
                    iColumn = (int)(-1);
                    revIdx = (byte)(0);
                }

                if ((isOrderDistinct) != 0)
                {
                    if ((((iColumn) &gt;= (0)) &amp;&amp; ((j) &gt;= (pLoop.u.btree.nEq))) &amp;&amp; ((pIndex.pTable.aCol[iColumn].notNull) == (0)))
                    {
                        isOrderDistinct = (byte)(0);
                    }

                    if ((iColumn) == (-2))
                    {
                        isOrderDistinct = (byte)(0);
                    }
                }

                isMatch = (byte)(0);
                for (i = (int)(0); ((bOnce) != 0) &amp;&amp; ((i) &lt; (nOrderBy)); i++)
                {
                    if (((((ulong)(1)) &lt;&lt; (i)) &amp; obSat) != 0)
                        continue;
                    pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy.a[i].pExpr);
                    if (((pOBExpr) == (null)))
                        continue;
                    if ((wctrlFlags &amp; (0x0040 | 0x0080)) == (0))
                        bOnce = (byte)(0);
                    if ((iColumn) &gt;= (-1))
                    {
                        if ((pOBExpr.op != 167) &amp;&amp; (pOBExpr.op != 169))
                            continue;
                        if (pOBExpr.iTable != iCur)
                            continue;
                        if (pOBExpr.iColumn != iColumn)
                            continue;
                    }
                    else
                    {
                        Expr pIdxExpr = pIndex.aColExpr.a[j].pExpr;
                        if ((sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, (int)(iCur))) != 0)
                        {
                            continue;
                        }
                    }

                    if (iColumn != (-1))
                    {
                        pColl = sqlite3ExprNNCollSeq(pWInfo.pParse, pOrderBy.a[i].pExpr);
                        if (sqlite3StrICmp(pColl.zName, pIndex.azColl[j]) != 0)
                            continue;
                    }

                    if ((wctrlFlags &amp; 0x0080) != 0)
                    {
                        pLoop.u.btree.nDistinctCol = (ushort)(j + 1);
                    }

                    isMatch = (byte)(1);
                    break;
                }

                if (((isMatch) != 0) &amp;&amp; ((wctrlFlags &amp; 0x0040) == (0)))
                {
                    if ((revSet) != 0)
                    {
                        if ((rev ^ revIdx) != (pOrderBy.a[i].sortFlags &amp; 0x01))
                        {
                            isMatch = (byte)(0);
                        }
                    }
                    else
                    {
                        rev = (byte)(revIdx ^ (pOrderBy.a[i].sortFlags &amp; 0x01));
                        if ((rev) != 0)
                            *pRevMask |= (ulong)(((ulong)(1)) &lt;&lt; (iLoop));
                        revSet = (byte)(1);
                    }
                }

                if (((isMatch) != 0) &amp;&amp; ((pOrderBy.a[i].sortFlags &amp; 0x02) != 0))
                {
                    if ((j) == (pLoop.u.btree.nEq))
                    {
                        pLoop.wsFlags |= (uint)(0x00080000);
                    }
                    else
                    {
                        isMatch = (byte)(0);
                    }
                }

                if ((isMatch) != 0)
                {
                    if ((iColumn) == (-1))
                    {
                        distinctColumns = (byte)(1);
                    }

                    obSat |= (ulong)(((ulong)(1)) &lt;&lt; (i));
                }
                else
                {
                    if (((j) == (0)) || ((j) &lt; (nKeyCol)))
                    {
                        isOrderDistinct = (byte)(0);
                    }

                    break;
                }
            }

            if ((distinctColumns) != 0)
            {
                isOrderDistinct = (byte)(1);
            }
        }

        if ((isOrderDistinct) != 0)
        {
            orderDistinctMask |= (ulong)(pLoop.maskSelf);
            for (i = (int)(0); (i) &lt; (nOrderBy); i++)
            {
                Expr p;
                ulong mTerm = 0;
                if (((((ulong)(1)) &lt;&lt; (i)) &amp; obSat) != 0)
                    continue;
                p = pOrderBy.a[i].pExpr;
                mTerm = (ulong)(sqlite3WhereExprUsage(&amp;pWInfo.sMaskSet, p));
                if (((mTerm) == (0)) &amp;&amp; (sqlite3ExprIsConstant(p) == 0))
                    continue;
                if ((mTerm &amp; ~orderDistinctMask) == (0))
                {
                    obSat |= (ulong)(((ulong)(1)) &lt;&lt; (i));
                }
            }
        }
    }

    if ((obSat) == (obDone))
        return (sbyte)(nOrderBy);
    if (isOrderDistinct == 0)
    {
        for (i = (int)(nOrderBy - 1); (i) &gt; (0); i--)
        {
            ulong m = (ulong)(((i) &lt; ((int)(sizeof(ulong) * 8))) ? (((ulong)(1)) &lt;&lt; (i)) - 1 : 0);
            if ((obSat &amp; m) == (m))
                return (sbyte)(i);
        }

        return (sbyte)(0);
    }

    return (sbyte)(-1);
}</function>
  <function>public static int wherePathSolver(WhereInfo pWInfo, short nRowEst)
{
    int mxChoice = 0;
    int nLoop = 0;
    Parse pParse;
    sqlite3 db;
    int iLoop = 0;
    int ii = 0; int  jj  =  0 ; 
    int mxI = (int)(0);
    int nOrderBy = 0;
    short mxCost = (short)(0);
    short mxUnsorted = (short)(0);
    int nTo = 0; int  nFrom  =  0 ; 
    WherePath aFrom;
    WherePath aTo;
    WherePath pFrom;
    WherePath pTo;
    WhereLoop pWLoop;
    WhereLoop pX;
    short* aSortCost = null;
    sbyte* pSpace;
    int nSpace = 0;
    pParse = pWInfo.pParse;
    db = pParse.db;
    nLoop = (int)(pWInfo.nLevel);
    mxChoice = (int)(((nLoop) &lt;= (1)) ? 1 : ((nLoop) == (2) ? 5 : 10));
    if (((pWInfo.pOrderBy) == (null)) || ((nRowEst) == (0)))
    {
        nOrderBy = (int)(0);
    }
    else
    {
        nOrderBy = (int)(pWInfo.pOrderBy.nExpr);
    }

    nSpace = (int)((sizeof(WherePath) + sizeof(WhereLoop) * nLoop) * mxChoice * 2);
    nSpace += (int)(sizeof(short) * nOrderBy);
    pSpace = sqlite3DbMallocRawNN(db, (ulong)(nSpace));
    if ((pSpace) == (null))
        return (int)(7);
    aTo = (WherePath)(pSpace);
    aFrom = aTo[mxChoice];
    CRuntime.memset(aFrom, (int)(0), (ulong)(sizeof(WherePath)));
    pX = (WhereLoop)(aFrom[mxChoice]);
    for (ii = (int)(mxChoice * 2), pFrom = aTo; (ii) &gt; (0); ii--, pFrom++, pX += nLoop)
    {
        pFrom.aLoop = pX;
    }

    if ((nOrderBy) != 0)
    {
        aSortCost = (short*)(pX);
        CRuntime.memset(aSortCost, (int)(0), (ulong)(sizeof(short) * nOrderBy));
    }

    aFrom[0].nRow = (short)((pParse.nQueryLoop) &lt; (48) ? (pParse.nQueryLoop) : (48));
    nFrom = (int)(1);
    if ((nOrderBy) != 0)
    {
        aFrom[0].isOrdered = (sbyte)((nLoop) &gt; (0) ? -1 : nOrderBy);
    }

    for (iLoop = (int)(0); (iLoop) &lt; (nLoop); iLoop++)
    {
        nTo = (int)(0);
        for (ii = (int)(0), pFrom = aFrom; (ii) &lt; (nFrom); ii++, pFrom++)
        {
            for (pWLoop = pWInfo.pLoops; pWLoop; pWLoop = pWLoop.pNextLoop)
            {
                short nOut = 0;
                short rCost = 0;
                short rUnsorted = 0;
                sbyte isOrdered = (sbyte)(pFrom.isOrdered);
                ulong maskNew = 0;
                ulong revMask = (ulong)(0);
                if ((pWLoop.prereq &amp; ~pFrom.maskLoop) != 0)
                    continue;
                if ((pWLoop.maskSelf &amp; pFrom.maskLoop) != 0)
                    continue;
                if (((pWLoop.wsFlags &amp; 0x00004000) != 0) &amp;&amp; ((pFrom.nRow) &lt; (3)))
                {
                    continue;
                }

                rUnsorted = (short)(sqlite3LogEstAdd((short)(pWLoop.rSetup), (short)(pWLoop.rRun + pFrom.nRow)));
                rUnsorted = (short)(sqlite3LogEstAdd((short)(rUnsorted), (short)(pFrom.rUnsorted)));
                nOut = (short)(pFrom.nRow + pWLoop.nOut);
                maskNew = (ulong)(pFrom.maskLoop | pWLoop.maskSelf);
                if ((isOrdered) &lt; (0))
                {
                    isOrdered = (sbyte)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, (ushort)(pWInfo.wctrlFlags), (ushort)(iLoop), pWLoop, &amp;revMask));
                }
                else
                {
                    revMask = (ulong)(pFrom.revLoop);
                }

                if (((isOrdered) &gt;= (0)) &amp;&amp; ((isOrdered) &lt; (nOrderBy)))
                {
                    if ((aSortCost[isOrdered]) == (0))
                    {
                        aSortCost[isOrdered] = (short)(whereSortingCost(pWInfo, (short)(nRowEst), (int)(nOrderBy), (int)(isOrdered)));
                    }

                    rCost = (short)(sqlite3LogEstAdd((short)(rUnsorted), (short)(aSortCost[isOrdered])) + 5);
                }
                else
                {
                    rCost = (short)(rUnsorted);
                    rUnsorted -= (short)(2);
                }

                for (jj = (int)(0), pTo = aTo; (jj) &lt; (nTo); jj++, pTo++)
                {
                    if (((pTo.maskLoop) == (maskNew)) &amp;&amp; (((pTo.isOrdered ^ isOrdered) &amp; 0x80) == (0)))
                    {
                        break;
                    }
                }

                if ((jj) &gt;= (nTo))
                {
                    if (((nTo) &gt;= (mxChoice)) &amp;&amp; (((rCost) &gt; (mxCost)) || (((rCost) == (mxCost)) &amp;&amp; ((rUnsorted) &gt;= (mxUnsorted)))))
                    {
                        continue;
                    }

                    if ((nTo) &lt; (mxChoice))
                    {
                        jj = (int)(nTo++);
                    }
                    else
                    {
                        jj = (int)(mxI);
                    }

                    pTo = aTo[jj];
                }
                else
                {
                    if (((pTo.rCost) &lt; (rCost)) || (((pTo.rCost) == (rCost)) &amp;&amp; (((pTo.nRow) &lt; (nOut)) || (((pTo.nRow) == (nOut)) &amp;&amp; ((pTo.rUnsorted) &lt;= (rUnsorted))))))
                    {
                        continue;
                    }
                }

                pTo.maskLoop = (ulong)(pFrom.maskLoop | pWLoop.maskSelf);
                pTo.revLoop = (ulong)(revMask);
                pTo.nRow = (short)(nOut);
                pTo.rCost = (short)(rCost);
                pTo.rUnsorted = (short)(rUnsorted);
                pTo.isOrdered = (sbyte)(isOrdered);
                CRuntime.memcpy(pTo.aLoop, pFrom.aLoop, (ulong)(sizeof(WhereLoop) * iLoop));
                pTo.aLoop[iLoop] = pWLoop;
                if ((nTo) &gt;= (mxChoice))
                {
                    mxI = (int)(0);
                    mxCost = (short)(aTo[0].rCost);
                    mxUnsorted = (short)(aTo[0].nRow);
                    for (jj = (int)(1), pTo = aTo[1]; (jj) &lt; (mxChoice); jj++, pTo++)
                    {
                        if (((pTo.rCost) &gt; (mxCost)) || (((pTo.rCost) == (mxCost)) &amp;&amp; ((pTo.rUnsorted) &gt; (mxUnsorted))))
                        {
                            mxCost = (short)(pTo.rCost);
                            mxUnsorted = (short)(pTo.rUnsorted);
                            mxI = (int)(jj);
                        }
                    }
                }
            }
        }

        pFrom = aTo;
        aTo = aFrom;
        aFrom = pFrom;
        nFrom = (int)(nTo);
    }

    if ((nFrom) == (0))
    {
        sqlite3ErrorMsg(pParse, "no query solution");
        sqlite3DbFreeNN(db, pSpace);
        return (int)(1);
    }

    pFrom = aFrom;
    for (ii = (int)(1); (ii) &lt; (nFrom); ii++)
    {
        if ((pFrom.rCost) &gt; (aFrom[ii].rCost))
            pFrom = aFrom[ii];
    }

    for (iLoop = (int)(0); (iLoop) &lt; (nLoop); iLoop++)
    {
        WhereLevel pLevel = pWInfo.a[iLoop];
        pLevel.pWLoop = pWLoop = pFrom.aLoop[iLoop];
        pLevel.iFrom = (byte)(pWLoop.iTab);
        pLevel.iTabCur = (int)(pWInfo.pTabList.a[pLevel.iFrom].iCursor);
    }

    if (((((pWInfo.wctrlFlags &amp; 0x0100) != 0) &amp;&amp; ((pWInfo.wctrlFlags &amp; 0x0080) == (0))) &amp;&amp; ((pWInfo.eDistinct) == (0))) &amp;&amp; ((nRowEst) != 0))
    {
        ulong notUsed = 0;
        int rc = (int)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pResultSet, pFrom, (ushort)(0x0080), (ushort)(nLoop - 1), pFrom.aLoop[nLoop - 1], &amp;notUsed));
        if ((rc) == (pWInfo.pResultSet.nExpr))
        {
            pWInfo.eDistinct = (byte)(2);
        }
    }

    pWInfo.bOrderedInnerLoop = (uint)(0);
    if ((pWInfo.pOrderBy) != null)
    {
        if ((pWInfo.wctrlFlags &amp; 0x0080) != 0)
        {
            if ((pFrom.isOrdered) == (pWInfo.pOrderBy.nExpr))
            {
                pWInfo.eDistinct = (byte)(2);
            }
        }
        else
        {
            pWInfo.nOBSat = (sbyte)(pFrom.isOrdered);
            pWInfo.revMask = (ulong)(pFrom.revLoop);
            if ((pWInfo.nOBSat) &lt;= (0))
            {
                pWInfo.nOBSat = (sbyte)(0);
                if ((nLoop) &gt; (0))
                {
                    uint wsFlags = (uint)(pFrom.aLoop[nLoop - 1].wsFlags);
                    if (((wsFlags &amp; 0x00001000) == (0)) &amp;&amp; ((wsFlags &amp; (0x00000100 | 0x00000004)) != (0x00000100 | 0x00000004)))
                    {
                        ulong m = (ulong)(0);
                        int rc = (int)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, (ushort)(0x0800), (ushort)(nLoop - 1), pFrom.aLoop[nLoop - 1], &amp;m));
                        if ((rc) == (pWInfo.pOrderBy.nExpr))
                        {
                            pWInfo.bOrderedInnerLoop = (uint)(1);
                            pWInfo.revMask = (ulong)(m);
                        }
                    }
                }
            }
            else if ((((nLoop) != 0) &amp;&amp; ((pWInfo.nOBSat) == (1))) &amp;&amp; ((pWInfo.wctrlFlags &amp; (0x0001 | 0x0002)) != 0))
            {
                pWInfo.bOrderedInnerLoop = (uint)(1);
            }
        }

        if ((((pWInfo.wctrlFlags &amp; 0x0200) != 0) &amp;&amp; ((pWInfo.nOBSat) == (pWInfo.pOrderBy.nExpr))) &amp;&amp; ((nLoop) &gt; (0)))
        {
            ulong revMask = (ulong)(0);
            int nOrder = (int)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, (ushort)(0), (ushort)(nLoop - 1), pFrom.aLoop[nLoop - 1], &amp;revMask));
            if ((nOrder) == (pWInfo.pOrderBy.nExpr))
            {
                pWInfo.sorted = (uint)(1);
                pWInfo.revMask = (ulong)(revMask);
            }
        }
    }

    pWInfo.nRowOut = (short)(pFrom.nRow);
    sqlite3DbFreeNN(db, pSpace);
    return (int)(0);
}</function>
  <function>public static short whereRangeAdjust(WhereTerm pTerm, short nNew)
{
    short nRet = (short)(nNew);
    if ((pTerm) != null)
    {
        if ((pTerm.truthProb) &lt;= (0))
        {
            nRet += (short)(pTerm.truthProb);
        }
        else if ((pTerm.wtFlags &amp; 0x0080) == (0))
        {
            nRet -= (short)(20);
        }
    }

    return (short)(nRet);
}</function>
  <function>public static int whereRangeScanEst(Parse pParse, WhereLoopBuilder pBuilder, WhereTerm pLower, WhereTerm pUpper, WhereLoop pLoop)
{
    int rc = (int)(0);
    int nOut = (int)(pLoop.nOut);
    short nNew = 0;
    nNew = (short)(whereRangeAdjust(pLower, (short)(nOut)));
    nNew = (short)(whereRangeAdjust(pUpper, (short)(nNew)));
    if (((((pLower) != null) &amp;&amp; ((pLower.truthProb) &gt; (0))) &amp;&amp; ((pUpper) != null)) &amp;&amp; ((pUpper.truthProb) &gt; (0)))
    {
        nNew -= (short)(20);
    }

    nOut -= (int)((pLower != null) + (pUpper != null));
    if ((nNew) &lt; (10))
        nNew = (short)(10);
    if ((nNew) &lt; (nOut))
        nOut = (int)(nNew);
    pLoop.nOut = ((short)(nOut));
    return (int)(rc);
}</function>
  <function>public static int whereRangeVectorLen(Parse pParse, int iCur, Index pIdx, int nEq, WhereTerm pTerm)
{
    int nCmp = (int)(sqlite3ExprVectorSize(pTerm.pExpr.pLeft));
    int i = 0;
    nCmp = (int)((nCmp) &lt; (pIdx.nColumn - nEq) ? (nCmp) : (pIdx.nColumn - nEq));
    for (i = (int)(1); (i) &lt; (nCmp); i++)
    {
        sbyte aff = 0;
        sbyte idxaff = (sbyte)(0);
        CollSeq pColl;
        Expr pLhs;
        Expr pRhs;
        pLhs = pTerm.pExpr.pLeft.x.pList.a[i].pExpr;
        pRhs = pTerm.pExpr.pRight;
        if ((((pRhs).flags &amp; 0x000800) != 0))
        {
            pRhs = pRhs.x.pSelect.pEList.a[i].pExpr;
        }
        else
        {
            pRhs = pRhs.x.pList.a[i].pExpr;
        }

        if ((((pLhs.op != 167) || (pLhs.iTable != iCur)) || (pLhs.iColumn != pIdx.aiColumn[i + nEq])) || (pIdx.aSortOrder[i + nEq] != pIdx.aSortOrder[nEq]))
        {
            break;
        }

        aff = (sbyte)(sqlite3CompareAffinity(pRhs, (sbyte)(sqlite3ExprAffinity(pLhs))));
        idxaff = (sbyte)(sqlite3TableColumnAffinity(pIdx.pTable, (int)(pLhs.iColumn)));
        if (aff != idxaff)
            break;
        pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
        if ((pColl) == (null))
            break;
        if ((sqlite3StrICmp(pColl.zName, pIdx.azColl[i + nEq])) != 0)
            break;
    }

    return (int)(i);
}</function>
  <function>public static Expr whereRightSubexprIsColumn(Expr p)
{
    p = sqlite3ExprSkipCollateAndLikely(p.pRight);
    if (((p != null) &amp;&amp; ((p.op) == (167))) &amp;&amp; (!(((p).flags &amp; (0x000008)) != 0)))
    {
        return p;
    }

    return null;
}</function>
  <function>public static WhereTerm whereScanInit(WhereScan pScan, WhereClause pWC, int iCur, int iColumn, uint opMask, Index pIdx)
{
    pScan.pOrigWC = pWC;
    pScan.pWC = pWC;
    pScan.pIdxExpr = null;
    pScan.idxaff = (sbyte)(0);
    pScan.zCollName = null;
    pScan.opMask = (uint)(opMask);
    pScan.k = (int)(0);
    pScan.aiCur[0] = (int)(iCur);
    pScan.nEquiv = (byte)(1);
    pScan.iEquiv = (byte)(1);
    if ((pIdx) != null)
    {
        int j = (int)(iColumn);
        iColumn = (int)(pIdx.aiColumn[j]);
        if ((iColumn) == (pIdx.pTable.iPKey))
        {
            iColumn = (int)(-1);
        }
        else if ((iColumn) &gt;= (0))
        {
            pScan.idxaff = (sbyte)(pIdx.pTable.aCol[iColumn].affinity);
            pScan.zCollName = pIdx.azColl[j];
        }
        else if ((iColumn) == (-2))
        {
            pScan.pIdxExpr = pIdx.aColExpr.a[j].pExpr;
            pScan.zCollName = pIdx.azColl[j];
            pScan.aiColumn[0] = (short)(-2);
            return whereScanInitIndexExpr(pScan);
        }
    }
    else if ((iColumn) == (-2))
    {
        return null;
    }

    pScan.aiColumn[0] = (short)(iColumn);
    return whereScanNext(pScan);
}</function>
  <function>public static WhereTerm whereScanInitIndexExpr(WhereScan pScan)
{
    pScan.idxaff = (sbyte)(sqlite3ExprAffinity(pScan.pIdxExpr));
    return whereScanNext(pScan);
}</function>
  <function>public static WhereTerm whereScanNext(WhereScan pScan)
{
    int iCur = 0;
    short iColumn = 0;
    Expr pX;
    WhereClause pWC;
    WhereTerm pTerm;
    int k = (int)(pScan.k);
    pWC = pScan.pWC;
    while ((1) != 0)
    {
        iColumn = (short)(pScan.aiColumn[pScan.iEquiv - 1]);
        iCur = (int)(pScan.aiCur[pScan.iEquiv - 1]);
        do
        {
            for (pTerm = pWC.a[k]; (k) &lt; (pWC.nTerm); k++, pTerm++)
            {
                if (((((pTerm.leftCursor) == (iCur)) &amp;&amp; ((pTerm.u.x.leftColumn) == (iColumn))) &amp;&amp; ((iColumn != (-2)) || ((sqlite3ExprCompareSkip(pTerm.pExpr.pLeft, pScan.pIdxExpr, (int)(iCur))) == (0)))) &amp;&amp; (((pScan.iEquiv) &lt;= (1)) || (!(((pTerm.pExpr).flags &amp; (0x000001)) != 0))))
                {
                    if ((((pTerm.eOperator &amp; 0x0800) != 0) &amp;&amp; ((pScan.nEquiv) &lt; ((int)(11 * sizeof(int) / sizeof(int))))) &amp;&amp; ((pX = whereRightSubexprIsColumn(pTerm.pExpr)) != null))
                    {
                        int j = 0;
                        for (j = (int)(0); (j) &lt; (pScan.nEquiv); j++)
                        {
                            if (((pScan.aiCur[j]) == (pX.iTable)) &amp;&amp; ((pScan.aiColumn[j]) == (pX.iColumn)))
                            {
                                break;
                            }
                        }

                        if ((j) == (pScan.nEquiv))
                        {
                            pScan.aiCur[j] = (int)(pX.iTable);
                            pScan.aiColumn[j] = (short)(pX.iColumn);
                            pScan.nEquiv++;
                        }
                    }

                    if ((pTerm.eOperator &amp; pScan.opMask) != 0)
                    {
                        if (((pScan.zCollName) != null) &amp;&amp; ((pTerm.eOperator &amp; 0x0100) == (0)))
                        {
                            CollSeq pColl;
                            Parse pParse = pWC.pWInfo.pParse;
                            pX = pTerm.pExpr;
                            if (sqlite3IndexAffinityOk(pX, (sbyte)(pScan.idxaff)) == 0)
                            {
                                continue;
                            }

                            pColl = sqlite3ExprCompareCollSeq(pParse, pX);
                            if ((pColl) == (null))
                                pColl = pParse.db.pDfltColl;
                            if ((sqlite3StrICmp(pColl.zName, pScan.zCollName)) != 0)
                            {
                                continue;
                            }
                        }

                        if ((((((pTerm.eOperator &amp; (0x0002 | 0x0080)) != 0) &amp;&amp; (pX = pTerm.pExpr.pRight, (pX != null))) &amp;&amp; ((pX.op) == (167))) &amp;&amp; ((pX.iTable) == (pScan.aiCur[0]))) &amp;&amp; ((pX.iColumn) == (pScan.aiColumn[0])))
                        {
                            continue;
                        }

                        pScan.pWC = pWC;
                        pScan.k = (int)(k + 1);
                        return pTerm;
                    }
                }
            }

            pWC = pWC.pOuter;
            k = (int)(0);
        }
        while (pWC != null);
        if ((pScan.iEquiv) &gt;= (pScan.nEquiv))
            break;
        pWC = pScan.pOrigWC;
        k = (int)(0);
        pScan.iEquiv++;
    }

    return null;
}</function>
  <function>public static int whereShortCut(WhereLoopBuilder pBuilder)
{
    WhereInfo pWInfo;
    SrcItem pItem;
    WhereClause pWC;
    WhereTerm pTerm;
    WhereLoop pLoop;
    int iCur = 0;
    int j = 0;
    Table pTab;
    Index pIdx;
    WhereScan scan = new WhereScan();
    pWInfo = pBuilder.pWInfo;
    if ((pWInfo.wctrlFlags &amp; 0x0020) != 0)
        return (int)(0);
    pItem = pWInfo.pTabList.a;
    pTab = pItem.pTab;
    if ((((pTab).eTabType) == (1)))
        return (int)(0);
    if ((pItem.fg.isIndexedBy) != 0)
        return (int)(0);
    iCur = (int)(pItem.iCursor);
    pWC = pWInfo.sWC;
    pLoop = pBuilder.pNew;
    pLoop.wsFlags = (uint)(0);
    pLoop.nSkip = (ushort)(0);
    pTerm = whereScanInit(scan, pWC, (int)(iCur), (int)(-1), (uint)(0x0002 | 0x0080), null);
    while (((pTerm) != null) &amp;&amp; ((pTerm.prereqRight) != 0))
    {
        pTerm = whereScanNext(scan);
    }

    if ((pTerm) != null)
    {
        pLoop.wsFlags = (uint)(0x00000001 | 0x00000100 | 0x00001000);
        pLoop.aLTerm[0] = pTerm;
        pLoop.nLTerm = (ushort)(1);
        pLoop.u.btree.nEq = (ushort)(1);
        pLoop.rRun = (short)(33);
    }
    else
    {
        for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
        {
            int opMask = 0;
            if (((!((pIdx).onError != 0)) || (pIdx.pPartIdxWhere != null)) || ((pIdx.nKeyCol) &gt; ((int)(3 * sizeof(WhereTerm) / sizeof(WhereTerm)))))
                continue;
            opMask = (int)((pIdx.uniqNotNull) != 0 ? (0x0002 | 0x0080) : 0x0002);
            for (j = (int)(0); (j) &lt; (pIdx.nKeyCol); j++)
            {
                pTerm = whereScanInit(scan, pWC, (int)(iCur), (int)(j), (uint)(opMask), pIdx);
                while (((pTerm) != null) &amp;&amp; ((pTerm.prereqRight) != 0))
                {
                    pTerm = whereScanNext(scan);
                }

                if ((pTerm) == (null))
                    break;
                pLoop.aLTerm[j] = pTerm;
            }

            if (j != pIdx.nKeyCol)
                continue;
            pLoop.wsFlags = (uint)(0x00000001 | 0x00001000 | 0x00000200);
            if (((pIdx.isCovering) != 0) || ((pItem.colUsed &amp; pIdx.colNotIdxed) == (0)))
            {
                pLoop.wsFlags |= (uint)(0x00000040);
            }

            pLoop.nLTerm = (ushort)(j);
            pLoop.u.btree.nEq = (ushort)(j);
            pLoop.u.btree.pIndex = pIdx;
            pLoop.rRun = (short)(39);
            break;
        }
    }

    if ((pLoop.wsFlags) != 0)
    {
        pLoop.nOut = ((short)(1));
        pWInfo.a[0].pWLoop = pLoop;
        pLoop.maskSelf = (ulong)(1);
        pWInfo.a[0].iTabCur = (int)(iCur);
        pWInfo.nRowOut = (short)(1);
        if ((pWInfo.pOrderBy) != null)
            pWInfo.nOBSat = (sbyte)(pWInfo.pOrderBy.nExpr);
        if ((pWInfo.wctrlFlags &amp; 0x0100) != 0)
        {
            pWInfo.eDistinct = (byte)(1);
        }

        if ((scan.iEquiv) &gt; (1))
            pLoop.wsFlags |= (uint)(0x00200000);
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static short whereSortingCost(WhereInfo pWInfo, short nRow, int nOrderBy, int nSorted)
{
    short rScale = 0; short  rSortCost  =  0 ; 
    rScale = (short)(sqlite3LogEst((ulong)((nOrderBy - nSorted) * 100 / nOrderBy)) - 66);
    rSortCost = (short)(nRow + rScale + 16);
    if (((pWInfo.wctrlFlags &amp; 0x4000) != 0) &amp;&amp; ((pWInfo.iLimit) &lt; (nRow)))
    {
        nRow = (short)(pWInfo.iLimit);
    }
    else if ((pWInfo.wctrlFlags &amp; 0x0100) != 0)
    {
        if ((nRow) &gt; (10))
        {
            nRow -= (short)(10);
        }
    }

    rSortCost += (short)(estLog((short)(nRow)));
    return (short)(rSortCost);
}</function>
  <function>public static void whereUndoExprMods(WhereInfo pWInfo)
{
    while ((pWInfo.pExprMods) != null)
    {
        WhereExprMod p = pWInfo.pExprMods;
        pWInfo.pExprMods = p.pNext;
        CRuntime.memcpy(p.pExpr, p.orig, (ulong)(sizeof(Expr)));
        sqlite3DbFree(pWInfo.pParse.db, p);
    }
}</function>
  <function>public static int whereUsablePartialIndex(int iTab, int isLeft, WhereClause pWC, Expr pWhere)
{
    int i = 0;
    WhereTerm pTerm;
    Parse pParse = pWC.pWInfo.pParse;
    while ((pWhere.op) == (44))
    {
        if (whereUsablePartialIndex((int)(iTab), (int)(isLeft), pWC, pWhere.pLeft) == 0)
            return (int)(0);
        pWhere = pWhere.pRight;
    }

    if ((pParse.db.flags &amp; 0x00800000) != 0)
        pParse = null;
    for (i = (int)(0), pTerm = pWC.a; (i) &lt; (pWC.nTerm); i++, pTerm++)
    {
        Expr pExpr;
        pExpr = pTerm.pExpr;
        if (((((!(((pExpr).flags &amp; (0x000001)) != 0)) || ((pExpr.w.iRightJoinTable) == (iTab))) &amp;&amp; (((isLeft) == (0)) || (((pExpr).flags &amp; (0x000001)) != 0))) &amp;&amp; ((sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, (int)(iTab))) != 0)) &amp;&amp; ((pTerm.wtFlags &amp; 0x0080) == (0)))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static int winAccess(sqlite3_vfs pVfs, sbyte* zFilename, int flags, int* pResOut)
{
    uint attr = 0;
    int rc = (int)(0);
    uint lastErrno = (uint)(0);
    void* zConverted;
    zConverted = winConvertFromUtf8Filename(zFilename);
    if ((zConverted) == (null))
    {
        return (int)(10 | (12 &lt;&lt; 8));
    }

    if ((1) != 0)
    {
        int cnt = (int)(0);
        _WIN32_FILE_ATTRIBUTE_DATA sAttrData = new _WIN32_FILE_ATTRIBUTE_DATA();
        CRuntime.memset(&amp;sAttrData, (int)(0), (ulong)(sizeof(_WIN32_FILE_ATTRIBUTE_DATA)));
        while ((!(rc = (int)((Int(UShort * , UShort * , UShort * ))(aSyscall[22].pCurrent)((ushort*)(zConverted), ( enum _GET_FILEEX_INFO_LEVELS)(GetFileExInfoStandard), &amp;sAttrData))))
            &amp;&amp; ((winRetryIoerr(&amp;cnt, &amp;lastErrno)) != 0) )
        {
        }

        if ((rc) != 0)
        {
            if ((((flags) == (0)) &amp;&amp; ((sAttrData.nFileSizeHigh) == (0))) &amp;&amp; ((sAttrData.nFileSizeLow) == (0)))
            {
                attr = ((uint)(-1));
            }
            else
            {
                attr = (uint)(sAttrData.dwFileAttributes);
            }
        }
        else
        {
            winLogIoerr((int)(cnt), (int)(48387));
            if ((lastErrno != 2L) &amp;&amp; (lastErrno != 3L))
            {
                sqlite3_free(zConverted);
                return (int)(winLogErrorAtLine((int)(10 | (13 &lt;&lt; 8)), (uint)(lastErrno), "winAccess", zFilename, (int)(48391)));
            }
            else
            {
                attr = ((uint)(-1));
            }
        }
    }
    else
    {
        attr = (uint)((Uint(Sbyte * ))(aSyscall[20].pCurrent)((sbyte*)(zConverted)));
    }

    sqlite3_free(zConverted);
    switch (flags)
    {
        case 2:
        case 0:
            rc = (int)(attr != ((uint)(-1)));
            break;
        case 1:
            rc = (int)((attr != ((uint)(-1))) &amp;&amp; ((attr &amp; 0x00000001) == (0)) ? 1 : 0);
            break;
        default:
            ;
    }

    *pResOut = (int)(rc);
    return (int)(0);
}</function>
  <function>public static int winCheckReservedLock(sqlite3_file id, int* pResOut)
{
    int res = 0;
    winFile pFile = (winFile)(id);
    if ((pFile.locktype) &gt;= (2))
    {
        res = (int)(1);
    }
    else
    {
        res = (int)(winLockFile(&amp;pFile.h, (uint)(0x00000001), (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0)));
        if ((res) != 0)
        {
            winUnlockFile(&amp;pFile.h, (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0));
        }

        res = (int)(!res);
    }

    *pResOut = (int)(res);
    return (int)(0);
}</function>
  <function>public static int winClose(sqlite3_file id)
{
    int rc = 0; int  cnt  =  ( int ) ( 0 ) ; 
    winFile pFile = (winFile)(id);
    winUnmapfile(pFile);
    do
    {
        rc = (int)((Int(Void * ))(aSyscall[3].pCurrent)(pFile.h));
    }
    while ((((rc) == (0)) &amp;&amp; ((++cnt) &lt; (3))) &amp;&amp; (sqlite3_win32_sleep((uint)(100)), 1));
    if ((rc) != 0)
    {
        pFile.h = null;
    }

    return (int)((rc) != 0 ? 0 : winLogErrorAtLine((int)(10 | (16 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winClose", pFile.zPath, (int)(45631)));
}</function>
  <function>public static void* winConvertFromUtf8Filename(sbyte* zFilename)
{
    void* zConverted = null;
    if ((1) != 0)
    {
        zConverted = winUtf8ToUnicode(zFilename);
    }
    else
    {
        zConverted = winUtf8ToMbcs(zFilename, (int)((Int())(aSyscall[0].pCurrent)()));
    }

    return zConverted;
}</function>
  <function>public static int winCurrentTime(sqlite3_vfs pVfs, double* prNow)
{
    int rc = 0;
    long i = 0;
    rc = (int)(winCurrentTimeInt64(pVfs, &amp;i));
    if (rc == 0)
    {
        *prNow = (double)(i / 86400000.0);
    }

    return (int)(rc);
}</function>
  <function>public static int winCurrentTimeInt64(sqlite3_vfs pVfs, long* piNow)
{
    _FILETIME ft = new _FILETIME();
    (Void(_FILETIME * ))(aSyscall[30].pCurrent)(&amp;ft);
    *piNow = (long)(winCurrentTimeInt64_winFiletimeEpoch + ((((long)(ft.dwHighDateTime)) * winCurrentTimeInt64_max32BitValue) + (long)(ft.dwLowDateTime)) / (long)(10000));
    return (int)(0);
}</function>
  <function>public static int winDelete(sqlite3_vfs pVfs, sbyte* zFilename, int syncDir)
{
    int cnt = (int)(0);
    int rc = 0;
    uint attr = 0;
    uint lastErrno = (uint)(0);
    void* zConverted;
    zConverted = winConvertFromUtf8Filename(zFilename);
    if ((zConverted) == (null))
    {
        return (int)(10 | (12 &lt;&lt; 8));
    }

    if ((1) != 0)
    {
        do
        {
            attr = (uint)((Uint(UShort * ))(aSyscall[21].pCurrent)(zConverted));
            if ((attr) == ((uint)(-1)))
            {
                lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
                if (((lastErrno) == (2L)) || ((lastErrno) == (3L)))
                {
                    rc = (int)(10 | (23 &lt;&lt; 8));
                }
                else
                {
                    rc = (int)(1);
                }

                break;
            }

            if ((attr &amp; 0x00000010) != 0)
            {
                rc = (int)(1);
                break;
            }

            if (((Int(UShort * ))(aSyscall[10].pCurrent)(zConverted)) != 0)
            {
                rc = (int)(0);
                break;
            }

            if (winRetryIoerr(&amp;cnt, &amp;lastErrno) == 0)
            {
                rc = (int)(1);
                break;
            }
        }
        while ((1) != 0);
    }
    else
    {
        do
        {
            attr = (uint)((Uint(Sbyte * ))(aSyscall[20].pCurrent)(zConverted));
            if ((attr) == ((uint)(-1)))
            {
                lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
                if (((lastErrno) == (2L)) || ((lastErrno) == (3L)))
                {
                    rc = (int)(10 | (23 &lt;&lt; 8));
                }
                else
                {
                    rc = (int)(1);
                }

                break;
            }

            if ((attr &amp; 0x00000010) != 0)
            {
                rc = (int)(1);
                break;
            }

            if (((Int(Sbyte * ))(aSyscall[9].pCurrent)(zConverted)) != 0)
            {
                rc = (int)(0);
                break;
            }

            if (winRetryIoerr(&amp;cnt, &amp;lastErrno) == 0)
            {
                rc = (int)(1);
                break;
            }
        }
        while ((1) != 0);
    }

    if (((rc) != 0) &amp;&amp; (rc != (10 | (23 &lt;&lt; 8))))
    {
        rc = (int)(winLogErrorAtLine((int)(10 | (10 &lt;&lt; 8)), (uint)(lastErrno), "winDelete", zFilename, (int)(48335)));
    }
    else
    {
        winLogIoerr((int)(cnt), (int)(48337));
    }

    sqlite3_free(zConverted);
    return (int)(rc);
}</function>
  <function>public static int winDeviceCharacteristics(sqlite3_file id)
{
    winFile p = (winFile)(id);
    return (int)(0x00000800 | ((p.ctrlFlags &amp; 0x10) ? 0x00001000 : 0));
}</function>
  <function>public static void winDlClose(sqlite3_vfs pVfs, void* pHandle)
{
    (Int(HINSTANCE__ * ))(aSyscall[16].pCurrent)(pHandle);
}</function>
  <function>public static void winDlError(sqlite3_vfs pVfs, int nBuf, sbyte* zBufOut)
{
    winGetLastErrorMsg((uint)((Uint())(aSyscall[26].pCurrent)()), (int)(nBuf), zBufOut);
}</function>
  <function>public static void* winDlOpen(sqlite3_vfs pVfs, sbyte* zFilename)
{
    void* h;
    void* zConverted = winConvertFromUtf8Filename(zFilename);
    if ((zConverted) == (null))
    {
        return null;
    }

    if ((1) != 0)
    {
        h = (HINSTANCE__ * (UShort*))(aSyscall[45].pCurrent)((ushort*)(zConverted));
    }
    else
    {
        h = (HINSTANCE__ * (Sbyte*))(aSyscall[44].pCurrent)((sbyte*)(zConverted));
    }

    sqlite3_free(zConverted);
    return h;
}</function>
  <function>public static Void ( )winDlSym(sqlite3_vfs pVfs, void* pH, sbyte* zSym)
{
    long  long  (  ) * proc ; 
    proc = (longlong() * (HINSTANCE__ * , HINSTANCE__ * ))(aSyscall[27].pCurrent)(pH, zSym);
    return (Void())(proc);
}</function>
  <function>public static void windowAggFinal(WindowCodeArg p, int bFin)
{
    Parse pParse = p.pParse;
    Window pMWin = p.pMWin;
    Vdbe v = sqlite3GetVdbe(pParse);
    Window pWin;
    for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
    {
        if ((((pMWin.regStartRowid) == (0)) &amp;&amp; ((pWin.pFunc.funcFlags &amp; 0x1000) != 0)) &amp;&amp; (pWin.eStart != 90))
        {
            sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regResult));
            sqlite3VdbeAddOp1(v, (int)(34), (int)(pWin.csrApp));
            sqlite3VdbeAddOp3(v, (int)(93), (int)(pWin.csrApp), (int)(0), (int)(pWin.regResult));
            sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
        }
        else if ((pWin.regApp) != 0)
        {
        }
        else
        {
            int nArg = (int)(windowArgCount(pWin));
            if ((bFin) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(164), (int)(pWin.regAccum), (int)(nArg));
                sqlite3VdbeAppendP4(v, pWin.pFunc, (int)(-8));
                sqlite3VdbeAddOp2(v, (int)(79), (int)(pWin.regAccum), (int)(pWin.regResult));
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
            }
            else
            {
                sqlite3VdbeAddOp3(v, (int)(163), (int)(pWin.regAccum), (int)(nArg), (int)(pWin.regResult));
                sqlite3VdbeAppendP4(v, pWin.pFunc, (int)(-8));
            }
        }
    }
}</function>
  <function>public static void windowAggStep(WindowCodeArg p, Window pMWin, int csr, int bInverse, int reg)
{
    Parse pParse = p.pParse;
    Vdbe v = sqlite3GetVdbe(pParse);
    Window pWin;
    for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
    {
        FuncDef pFunc = pWin.pFunc;
        int regArg = 0;
        int nArg = (int)((pWin.bExprArgs) != 0 ? 0 : windowArgCount(pWin));
        int i = 0;
        for (i = (int)(0); (i) &lt; (nArg); i++)
        {
            if ((i != 1) || (pFunc.zName != nth_valueName))
            {
                sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol + i), (int)(reg + i));
            }
            else
            {
                sqlite3VdbeAddOp3(v, (int)(93), (int)(pMWin.iEphCsr), (int)(pWin.iArgCol + i), (int)(reg + i));
            }
        }

        regArg = (int)(reg);
        if ((((pMWin.regStartRowid) == (0)) &amp;&amp; ((pFunc.funcFlags &amp; 0x1000) != 0)) &amp;&amp; (pWin.eStart != 90))
        {
            int addrIsNull = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(regArg)));
            if ((bInverse) == (0))
            {
                sqlite3VdbeAddOp2(v, (int)(85), (int)(pWin.regApp + 1), (int)(1));
                sqlite3VdbeAddOp2(v, (int)(80), (int)(regArg), (int)(pWin.regApp));
                sqlite3VdbeAddOp3(v, (int)(96), (int)(pWin.regApp), (int)(2), (int)(pWin.regApp + 2));
                sqlite3VdbeAddOp2(v, (int)(137), (int)(pWin.csrApp), (int)(pWin.regApp + 2));
            }
            else
            {
                sqlite3VdbeAddOp4Int(v, (int)(25), (int)(pWin.csrApp), (int)(0), (int)(regArg), (int)(1));
                sqlite3VdbeAddOp1(v, (int)(129), (int)(pWin.csrApp));
                sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
            }

            sqlite3VdbeJumpHere(v, (int)(addrIsNull));
        }
        else if ((pWin.regApp) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(85), (int)(pWin.regApp + 1 - bInverse), (int)(1));
        }
        else if (pFunc.xSFunc != noopStepFunc)
        {
            int addrIf = (int)(0);
            if ((pWin.pFilter) != null)
            {
                int regTmp = 0;
                regTmp = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol + nArg), (int)(regTmp));
                addrIf = (int)(sqlite3VdbeAddOp3(v, (int)(20), (int)(regTmp), (int)(0), (int)(1)));
                sqlite3ReleaseTempReg(pParse, (int)(regTmp));
            }

            if ((pWin.bExprArgs) != 0)
            {
                int iOp = (int)(sqlite3VdbeCurrentAddr(v));
                int iEnd = 0;
                nArg = (int)(pWin.pOwner.x.pList.nExpr);
                regArg = (int)(sqlite3GetTempRange(pParse, (int)(nArg)));
                sqlite3ExprCodeExprList(pParse, pWin.pOwner.x.pList, (int)(regArg), (int)(0), (byte)(0));
                for (iEnd = (int)(sqlite3VdbeCurrentAddr(v)); (iOp) &lt; (iEnd); iOp++)
                {
                    VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iOp));
                    if (((pOp-&gt;opcode) == (93)) &amp;&amp; ((pOp-&gt;p1) == (pWin.iEphCsr)))
                    {
                        pOp-&gt;p1 = (int)(csr);
                    }
                }
            }

            if ((pFunc.funcFlags &amp; 0x0020) != 0)
            {
                CollSeq pColl;
                pColl = sqlite3ExprNNCollSeq(pParse, pWin.pOwner.x.pList.a[0].pExpr);
                sqlite3VdbeAddOp4(v, (int)(84), (int)(0), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
            }

            sqlite3VdbeAddOp3(v, (int)((bInverse) != 0 ? 160 : 161), (int)(bInverse), (int)(regArg), (int)(pWin.regAccum));
            sqlite3VdbeAppendP4(v, pFunc, (int)(-8));
            sqlite3VdbeChangeP5(v, (ushort)((byte)(nArg)));
            if ((pWin.bExprArgs) != 0)
            {
                sqlite3ReleaseTempRange(pParse, (int)(regArg), (int)(nArg));
            }

            if ((addrIf) != 0)
                sqlite3VdbeJumpHere(v, (int)(addrIf));
        }
    }
}</function>
  <function>public static int windowArgCount(Window pWin)
{
    ExprList pList;
    pList = pWin.pOwner.x.pList;
    return (int)(pList ? pList.nExpr : 0);
}</function>
  <function>public static int windowCacheFrame(Window pMWin)
{
    Window pWin;
    if ((pMWin.regStartRowid) != 0)
        return (int)(1);
    for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
    {
        FuncDef pFunc = pWin.pFunc;
        if (((((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName))) || ((pFunc.zName) == (leadName))) || ((pFunc.zName) == (lagName)))
        {
            return (int)(1);
        }
    }

    return (int)(0);
}</function>
  <function>public static void windowCheckValue(Parse pParse, int reg, int eCond)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    int regZero = (int)(sqlite3GetTempReg(pParse));
    sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regZero));
    if ((eCond) &gt;= (3))
    {
        int regString = (int)(sqlite3GetTempReg(pParse));
        sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(regString), (int)(0), "", (int)(-1));
        sqlite3VdbeAddOp3(v, (int)(57), (int)(regString), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(reg));
        sqlite3VdbeChangeP5(v, (ushort)(0x43 | 0x10));
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(15), (int)(reg), (int)(sqlite3VdbeCurrentAddr(v) + 2));
    }

    sqlite3VdbeAddOp3(v, (int)(windowCheckValue_aOp[eCond]), (int)(regZero), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(reg));
    sqlite3VdbeChangeP5(v, (ushort)(0x43));
    sqlite3MayAbort(pParse);
    sqlite3VdbeAddOp2(v, (int)(70), (int)(1), (int)(2));
    sqlite3VdbeAppendP4(v, (void*)(windowCheckValue_azErr[eCond]), (int)(-1));
    sqlite3ReleaseTempReg(pParse, (int)(regZero));
}</function>
  <function>public static int windowCodeOp(WindowCodeArg p, int op, int regCountdown, int jumpOnEof)
{
    int csr = 0; int  reg  =  0 ; 
    Parse pParse = p.pParse;
    Window pMWin = p.pMWin;
    int ret = (int)(0);
    Vdbe v = p.pVdbe;
    int addrContinue = (int)(0);
    int bPeer = (int)(pMWin.eFrmType != 76);
    int lblDone = (int)(sqlite3VdbeMakeLabel(pParse));
    int addrNextRange = (int)(0);
    if (((op) == (2)) &amp;&amp; ((pMWin.eStart) == (90)))
    {
        return (int)(0);
    }

    if ((regCountdown) &gt; (0))
    {
        if ((pMWin.eFrmType) == (89))
        {
            addrNextRange = (int)(sqlite3VdbeCurrentAddr(v));
            if ((op) == (2))
            {
                if ((pMWin.eStart) == (86))
                {
                    windowCodeRangeTest(p, (int)(55), (int)(p.current.csr), (int)(regCountdown), (int)(p.start.csr), (int)(lblDone));
                }
                else
                {
                    windowCodeRangeTest(p, (int)(57), (int)(p.start.csr), (int)(regCountdown), (int)(p.current.csr), (int)(lblDone));
                }
            }
            else
            {
                windowCodeRangeTest(p, (int)(54), (int)(p.end.csr), (int)(regCountdown), (int)(p.current.csr), (int)(lblDone));
            }
        }
        else
        {
            sqlite3VdbeAddOp3(v, (int)(49), (int)(regCountdown), (int)(lblDone), (int)(1));
        }
    }

    if (((op) == (1)) &amp;&amp; ((pMWin.regStartRowid) == (0)))
    {
        windowAggFinal(p, (int)(0));
    }

    addrContinue = (int)(sqlite3VdbeCurrentAddr(v));
    if ((((pMWin.eStart) == (pMWin.eEnd)) &amp;&amp; ((regCountdown) != 0)) &amp;&amp; ((pMWin.eFrmType) == (89)))
    {
        int regRowid1 = (int)(sqlite3GetTempReg(pParse));
        int regRowid2 = (int)(sqlite3GetTempReg(pParse));
        if ((op) == (2))
        {
            sqlite3VdbeAddOp2(v, (int)(134), (int)(p.start.csr), (int)(regRowid1));
            sqlite3VdbeAddOp2(v, (int)(134), (int)(p.end.csr), (int)(regRowid2));
            sqlite3VdbeAddOp3(v, (int)(57), (int)(regRowid2), (int)(lblDone), (int)(regRowid1));
        }
        else if ((p.regRowid) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(134), (int)(p.end.csr), (int)(regRowid1));
            sqlite3VdbeAddOp3(v, (int)(57), (int)(p.regRowid), (int)(lblDone), (int)(regRowid1));
        }

        sqlite3ReleaseTempReg(pParse, (int)(regRowid1));
        sqlite3ReleaseTempReg(pParse, (int)(regRowid2));
    }

    switch (op)
    {
        case 1:
            csr = (int)(p.current.csr);
            reg = (int)(p.current.reg);
            windowReturnOneRow(p);
            break;
        case 2:
            csr = (int)(p.start.csr);
            reg = (int)(p.start.reg);
            if ((pMWin.regStartRowid) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(85), (int)(pMWin.regStartRowid), (int)(1));
            }
            else
            {
                windowAggStep(p, pMWin, (int)(csr), (int)(1), (int)(p.regArg));
            }

            break;
        default:
            ;
            csr = (int)(p.end.csr);
            reg = (int)(p.end.reg);
            if ((pMWin.regStartRowid) != 0)
            {
                sqlite3VdbeAddOp2(v, (int)(85), (int)(pMWin.regEndRowid), (int)(1));
            }
            else
            {
                windowAggStep(p, pMWin, (int)(csr), (int)(0), (int)(p.regArg));
            }

            break;
    }

    if ((op) == (p.eDelete))
    {
        sqlite3VdbeAddOp1(v, (int)(129), (int)(csr));
        sqlite3VdbeChangeP5(v, (ushort)(0x02));
    }

    if ((jumpOnEof) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(5), (int)(csr), (int)(sqlite3VdbeCurrentAddr(v) + 2));
        ret = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(5), (int)(csr), (int)(sqlite3VdbeCurrentAddr(v) + 1 + bPeer));
        if ((bPeer) != 0)
        {
            sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblDone));
        }
    }

    if ((bPeer) != 0)
    {
        int nReg = (int)(pMWin.pOrderBy ? pMWin.pOrderBy.nExpr : 0);
        int regTmp = (int)((nReg) != 0 ? sqlite3GetTempRange(pParse, (int)(nReg)) : 0);
        windowReadPeerValues(p, (int)(csr), (int)(regTmp));
        windowIfNewPeer(pParse, pMWin.pOrderBy, (int)(regTmp), (int)(reg), (int)(addrContinue));
        sqlite3ReleaseTempRange(pParse, (int)(regTmp), (int)(nReg));
    }

    if ((addrNextRange) != 0)
    {
        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrNextRange));
    }

    sqlite3VdbeResolveLabel(v, (int)(lblDone));
    return (int)(ret);
}</function>
  <function>public static void windowCodeRangeTest(WindowCodeArg p, int op, int csr1, int regVal, int csr2, int lbl)
{
    Parse pParse = p.pParse;
    Vdbe v = sqlite3GetVdbe(pParse);
    ExprList pOrderBy = p.pMWin.pOrderBy;
    int reg1 = (int)(sqlite3GetTempReg(pParse));
    int reg2 = (int)(sqlite3GetTempReg(pParse));
    int regString = (int)(++pParse.nMem);
    int arith = (int)(106);
    int addrGe = 0;
    int addrDone = (int)(sqlite3VdbeMakeLabel(pParse));
    CollSeq pColl;
    windowReadPeerValues(p, (int)(csr1), (int)(reg1));
    windowReadPeerValues(p, (int)(csr2), (int)(reg2));
    if ((pOrderBy.a[0].sortFlags &amp; 0x01) != 0)
    {
        switch (op)
        {
            case 57:
                op = (int)(55);
                break;
            case 54:
                op = (int)(56);
                break;
            default:
                ;
                op = (int)(57);
                break;
        }

        arith = (int)(107);
    }

    if ((pOrderBy.a[0].sortFlags &amp; 0x02) != 0)
    {
        int addr = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(reg1)));
        switch (op)
        {
            case 57:
                sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lbl));
                break;
            case 54:
                sqlite3VdbeAddOp2(v, (int)(51), (int)(reg2), (int)(lbl));
                break;
            case 55:
                sqlite3VdbeAddOp2(v, (int)(50), (int)(reg2), (int)(lbl));
                break;
            default:
                ;
                break;
        }

        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrDone));
        sqlite3VdbeJumpHere(v, (int)(addr));
        sqlite3VdbeAddOp2(v, (int)(50), (int)(reg2), (int)(lbl));
        if (((op) == (54)) || ((op) == (57)))
        {
            sqlite3VdbeChangeP2(v, (int)(-1), (int)(addrDone));
        }
    }

    sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(regString), (int)(0), "", (int)(-1));
    addrGe = (int)(sqlite3VdbeAddOp3(v, (int)(57), (int)(regString), (int)(0), (int)(reg1)));
    if ((((op) == (57)) &amp;&amp; ((arith) == (106))) || (((op) == (55)) &amp;&amp; ((arith) == (107))))
    {
        sqlite3VdbeAddOp3(v, (int)(op), (int)(reg2), (int)(lbl), (int)(reg1));
    }

    sqlite3VdbeAddOp3(v, (int)(arith), (int)(regVal), (int)(reg1), (int)(reg1));
    sqlite3VdbeJumpHere(v, (int)(addrGe));
    sqlite3VdbeAddOp3(v, (int)(op), (int)(reg2), (int)(lbl), (int)(reg1));
    pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy.a[0].pExpr);
    sqlite3VdbeAppendP4(v, (void*)(pColl), (int)(-2));
    sqlite3VdbeChangeP5(v, (ushort)(0x80));
    sqlite3VdbeResolveLabel(v, (int)(addrDone));
    sqlite3ReleaseTempReg(pParse, (int)(reg1));
    sqlite3ReleaseTempReg(pParse, (int)(reg2));
}</function>
  <function>public static int windowExprGtZero(Parse pParse, Expr pExpr)
{
    int ret = (int)(0);
    sqlite3 db = pParse.db;
    sqlite3_value pVal = null;
    sqlite3ValueFromExpr(db, pExpr, (byte)(db.enc), (byte)(0x43), pVal);
    if (((pVal) != null) &amp;&amp; ((sqlite3_value_int(pVal)) &gt; (0)))
    {
        ret = (int)(1);
    }

    sqlite3ValueFree(pVal);
    return (int)(ret);
}</function>
  <function>public static Window windowFind(Parse pParse, Window pList, sbyte* zName)
{
    Window p;
    for (p = pList; p; p = p.pNextWin)
    {
        if ((sqlite3StrICmp(p.zName, zName)) == (0))
            break;
    }

    if ((p) == (null))
    {
        sqlite3ErrorMsg(pParse, "no such window: %s", zName);
    }

    return p;
}</function>
  <function>public static void windowFullScan(WindowCodeArg p)
{
    Window pWin;
    Parse pParse = p.pParse;
    Window pMWin = p.pMWin;
    Vdbe v = p.pVdbe;
    int regCRowid = (int)(0);
    int regCPeer = (int)(0);
    int regRowid = (int)(0);
    int regPeer = (int)(0);
    int nPeer = 0;
    int lblNext = 0;
    int lblBrk = 0;
    int addrNext = 0;
    int csr = 0;
    csr = (int)(pMWin.csrApp);
    nPeer = (int)(pMWin.pOrderBy ? pMWin.pOrderBy.nExpr : 0);
    lblNext = (int)(sqlite3VdbeMakeLabel(pParse));
    lblBrk = (int)(sqlite3VdbeMakeLabel(pParse));
    regCRowid = (int)(sqlite3GetTempReg(pParse));
    regRowid = (int)(sqlite3GetTempReg(pParse));
    if ((nPeer) != 0)
    {
        regCPeer = (int)(sqlite3GetTempRange(pParse, (int)(nPeer)));
        regPeer = (int)(sqlite3GetTempRange(pParse, (int)(nPeer)));
    }

    sqlite3VdbeAddOp2(v, (int)(134), (int)(pMWin.iEphCsr), (int)(regCRowid));
    windowReadPeerValues(p, (int)(pMWin.iEphCsr), (int)(regCPeer));
    for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
    {
        sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
    }

    sqlite3VdbeAddOp3(v, (int)(25), (int)(csr), (int)(lblBrk), (int)(pMWin.regStartRowid));
    addrNext = (int)(sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp2(v, (int)(134), (int)(csr), (int)(regRowid));
    sqlite3VdbeAddOp3(v, (int)(54), (int)(pMWin.regEndRowid), (int)(lblBrk), (int)(regRowid));
    if ((pMWin.eExclude) == (85))
    {
        sqlite3VdbeAddOp3(v, (int)(53), (int)(regCRowid), (int)(lblNext), (int)(regRowid));
    }
    else if (pMWin.eExclude != 66)
    {
        int addr = 0;
        int addrEq = (int)(0);
        KeyInfo pKeyInfo = null;
        if ((pMWin.pOrderBy) != null)
        {
            pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin.pOrderBy, (int)(0), (int)(0));
        }

        if ((pMWin.eExclude) == (94))
        {
            addrEq = (int)(sqlite3VdbeAddOp3(v, (int)(53), (int)(regCRowid), (int)(0), (int)(regRowid)));
        }

        if ((pKeyInfo) != null)
        {
            windowReadPeerValues(p, (int)(csr), (int)(regPeer));
            sqlite3VdbeAddOp3(v, (int)(89), (int)(regPeer), (int)(regCPeer), (int)(nPeer));
            sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
            addr = (int)(sqlite3VdbeCurrentAddr(v) + 1);
            sqlite3VdbeAddOp3(v, (int)(16), (int)(addr), (int)(lblNext), (int)(addr));
        }
        else
        {
            sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblNext));
        }

        if ((addrEq) != 0)
            sqlite3VdbeJumpHere(v, (int)(addrEq));
    }

    windowAggStep(p, pMWin, (int)(csr), (int)(0), (int)(p.regArg));
    sqlite3VdbeResolveLabel(v, (int)(lblNext));
    sqlite3VdbeAddOp2(v, (int)(5), (int)(csr), (int)(addrNext));
    sqlite3VdbeJumpHere(v, (int)(addrNext - 1));
    sqlite3VdbeJumpHere(v, (int)(addrNext + 1));
    sqlite3ReleaseTempReg(pParse, (int)(regRowid));
    sqlite3ReleaseTempReg(pParse, (int)(regCRowid));
    if ((nPeer) != 0)
    {
        sqlite3ReleaseTempRange(pParse, (int)(regPeer), (int)(nPeer));
        sqlite3ReleaseTempRange(pParse, (int)(regCPeer), (int)(nPeer));
    }

    windowAggFinal(p, (int)(1));
}</function>
  <function>public static void windowIfNewPeer(Parse pParse, ExprList pOrderBy, int regNew, int regOld, int addr)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    if ((pOrderBy) != null)
    {
        int nVal = (int)(pOrderBy.nExpr);
        KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, (int)(0), (int)(0));
        sqlite3VdbeAddOp3(v, (int)(89), (int)(regOld), (int)(regNew), (int)(nVal));
        sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
        sqlite3VdbeAddOp3(v, (int)(16), (int)(sqlite3VdbeCurrentAddr(v) + 1), (int)(addr), (int)(sqlite3VdbeCurrentAddr(v) + 1));
        sqlite3VdbeAddOp3(v, (int)(79), (int)(regNew), (int)(regOld), (int)(nVal - 1));
    }
    else
    {
        sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addr));
    }
}</function>
  <function>public static int windowInitAccum(Parse pParse, Window pMWin)
{
    Vdbe v = sqlite3GetVdbe(pParse);
    int regArg = 0;
    int nArg = (int)(0);
    Window pWin;
    for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
    {
        FuncDef pFunc = pWin.pFunc;
        sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
        nArg = (int)((nArg) &gt; (windowArgCount(pWin)) ? (nArg) : (windowArgCount(pWin)));
        if ((pMWin.regStartRowid) == (0))
        {
            if (((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName)))
            {
                sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp));
                sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
            }

            if (((pFunc.funcFlags &amp; 0x1000) != 0) &amp;&amp; ((pWin.csrApp) != 0))
            {
                sqlite3VdbeAddOp1(v, (int)(145), (int)(pWin.csrApp));
                sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
            }
        }
    }

    regArg = (int)(pParse.nMem + 1);
    pParse.nMem += (int)(nArg);
    return (int)(regArg);
}</function>
  <function>public static void windowReadPeerValues(WindowCodeArg p, int csr, int reg)
{
    Window pMWin = p.pMWin;
    ExprList pOrderBy = pMWin.pOrderBy;
    if ((pOrderBy) != null)
    {
        Vdbe v = sqlite3GetVdbe(p.pParse);
        ExprList pPart = pMWin.pPartition;
        int iColOff = (int)(pMWin.nBufferCol + (pPart ? pPart.nExpr : 0));
        int i = 0;
        for (i = (int)(0); (i) &lt; (pOrderBy.nExpr); i++)
        {
            sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(iColOff + i), (int)(reg + i));
        }
    }
}</function>
  <function>public static void windowRemoveExprFromSelect(Select pSelect, Expr pExpr)
{
    if ((pSelect.pWin) != null)
    {
        Walker sWalker = new Walker();
        CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
        sWalker.xExprCallback = resolveRemoveWindowsCb;
        sWalker.u.pSelect = pSelect;
        sqlite3WalkExpr(sWalker, pExpr);
    }
}</function>
  <function>public static void windowReturnOneRow(WindowCodeArg p)
{
    Window pMWin = p.pMWin;
    Vdbe v = p.pVdbe;
    if ((pMWin.regStartRowid) != 0)
    {
        windowFullScan(p);
    }
    else
    {
        Parse pParse = p.pParse;
        Window pWin;
        for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
        {
            FuncDef pFunc = pWin.pFunc;
            if (((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName)))
            {
                int csr = (int)(pWin.csrApp);
                int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
                int tmpReg = (int)(sqlite3GetTempReg(pParse));
                sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regResult));
                if ((pFunc.zName) == (nth_valueName))
                {
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(pMWin.iEphCsr), (int)(pWin.iArgCol + 1), (int)(tmpReg));
                    windowCheckValue(pParse, (int)(tmpReg), (int)(2));
                }
                else
                {
                    sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(tmpReg));
                }

                sqlite3VdbeAddOp3(v, (int)(106), (int)(tmpReg), (int)(pWin.regApp), (int)(tmpReg));
                sqlite3VdbeAddOp3(v, (int)(54), (int)(pWin.regApp + 1), (int)(lbl), (int)(tmpReg));
                sqlite3VdbeAddOp3(v, (int)(32), (int)(csr), (int)(0), (int)(tmpReg));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol), (int)(pWin.regResult));
                sqlite3VdbeResolveLabel(v, (int)(lbl));
                sqlite3ReleaseTempReg(pParse, (int)(tmpReg));
            }
            else if (((pFunc.zName) == (leadName)) || ((pFunc.zName) == (lagName)))
            {
                int nArg = (int)(pWin.pOwner.x.pList.nExpr);
                int csr = (int)(pWin.csrApp);
                int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
                int tmpReg = (int)(sqlite3GetTempReg(pParse));
                int iEph = (int)(pMWin.iEphCsr);
                if ((nArg) &lt; (3))
                {
                    sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regResult));
                }
                else
                {
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(pWin.iArgCol + 2), (int)(pWin.regResult));
                }

                sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(tmpReg));
                if ((nArg) &lt; (2))
                {
                    int val = (int)((pFunc.zName) == (leadName) ? 1 : -1);
                    sqlite3VdbeAddOp2(v, (int)(85), (int)(tmpReg), (int)(val));
                }
                else
                {
                    int op = (int)((pFunc.zName) == (leadName) ? 106 : 107);
                    int tmpReg2 = (int)(sqlite3GetTempReg(pParse));
                    sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(pWin.iArgCol + 1), (int)(tmpReg2));
                    sqlite3VdbeAddOp3(v, (int)(op), (int)(tmpReg2), (int)(tmpReg), (int)(tmpReg));
                    sqlite3ReleaseTempReg(pParse, (int)(tmpReg2));
                }

                sqlite3VdbeAddOp3(v, (int)(32), (int)(csr), (int)(lbl), (int)(tmpReg));
                sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol), (int)(pWin.regResult));
                sqlite3VdbeResolveLabel(v, (int)(lbl));
                sqlite3ReleaseTempReg(pParse, (int)(tmpReg));
            }
        }
    }

    sqlite3VdbeAddOp2(v, (int)(12), (int)(p.regGosub), (int)(p.addrGosub));
}</function>
  <function>public static int winFetch(sqlite3_file fd, long iOff, int nAmt, void** pp)
{
    winFile pFd = (winFile)(fd);
    *pp = null;
    if ((pFd.mmapSizeMax) &gt; (0))
    {
        if ((pFd.pMapRegion) == (null))
        {
            int rc = (int)(winMapfile(pFd, (long)(-1)));
            if (rc != 0)
            {
                return (int)(rc);
            }
        }

        if ((pFd.mmapSize) &gt;= (iOff + nAmt))
        {
            *pp = &amp;((byte*)(pFd.pMapRegion))[iOff];
            pFd.nFetchOut++;
        }
    }

    return (int)(0);
}</function>
  <function>public static int winFileControl(sqlite3_file id, int op, void* pArg)
{
    winFile pFile = (winFile)(id);
    switch (op)
    {
        case 1:
        {
            *(int*)(pArg) = (int)(pFile.locktype);
            return (int)(0);
        }

        case 4:
        {
            *(int*)(pArg) = ((int)(pFile.lastErrno));
            return (int)(0);
        }

        case 6:
        {
            pFile.szChunk = (int)(*(int*)(pArg));
            return (int)(0);
        }

        case 5:
        {
            if ((pFile.szChunk) &gt; (0))
            {
                long oldSz = 0;
                int rc = (int)(winFileSize(id, &amp;oldSz));
                if ((rc) == (0))
                {
                    long newSz = (long)(*(long*)(pArg));
                    if ((newSz) &gt; (oldSz))
                    {
                        rc = (int)(winTruncate(id, (long)(newSz)));
                    }
                }

                return (int)(rc);
            }

            return (int)(0);
        }

        case 10:
        {
            winModeBit(pFile, (byte)(0x04), (int*)(pArg));
            return (int)(0);
        }

        case 13:
        {
            winModeBit(pFile, (byte)(0x10), (int*)(pArg));
            return (int)(0);
        }

        case 12:
        {
            *(sbyte**)(pArg) = sqlite3_mprintf("%s", pFile.pVfs.zName);
            return (int)(0);
        }

        case 9:
        {
            int* a = (int*)(pArg);
            if ((a[0]) &gt; (0))
            {
                winIoerrRetry = (int)(a[0]);
            }
            else
            {
                a[0] = (int)(winIoerrRetry);
            }

            if ((a[1]) &gt; (0))
            {
                winIoerrRetryDelay = (int)(a[1]);
            }
            else
            {
                a[1] = (int)(winIoerrRetryDelay);
            }

            return (int)(0);
        }

        case 29:
        {
            void** phFile = (void**)(pArg);
            *phFile = pFile.h;
            return (int)(0);
        }

        case 16:
        {
            sbyte* zTFile = null;
            int rc = (int)(winGetTempname(pFile.pVfs, &amp;zTFile));
            if ((rc) == (0))
            {
                *(sbyte**)(pArg) = zTFile;
            }

            return (int)(rc);
        }

        case 18:
        {
            long newLimit = (long)(*(long*)(pArg));
            int rc = (int)(0);
            if ((newLimit) &gt; (sqlite3Config.mxMmap))
            {
                newLimit = (long)(sqlite3Config.mxMmap);
            }

            if (((newLimit) &gt; (0)) &amp;&amp; ((sizeof(ulong)) &lt; (8)))
            {
                newLimit = (long)(newLimit &amp; 0x7FFFFFFF);
            }

            *(long*)(pArg) = (long)(pFile.mmapSizeMax);
            if ((((newLimit) &gt;= (0)) &amp;&amp; (newLimit != pFile.mmapSizeMax)) &amp;&amp; ((pFile.nFetchOut) == (0)))
            {
                pFile.mmapSizeMax = (long)(newLimit);
                if ((pFile.mmapSize) &gt; (0))
                {
                    winUnmapfile(pFile);
                    rc = (int)(winMapfile(pFile, (long)(-1)));
                }
            }

            return (int)(rc);
        }
    }

    return (int)(12);
}</function>
  <function>public static int winFileSize(sqlite3_file id, long* pSize)
{
    winFile pFile = (winFile)(id);
    int rc = (int)(0);
    {
        uint upperBits = 0;
        uint lowerBits = 0;
        uint lastErrno = 0;
        lowerBits = (uint)((Uint(Void * , Void * ))(aSyscall[23].pCurrent)(pFile.h, &amp;upperBits));
        *pSize = (long)((((long)(upperBits)) &lt;&lt; 32) + lowerBits);
        if (((lowerBits) == (0xFFFFFFFF)) &amp;&amp; ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 0L))
        {
            pFile.lastErrno = (uint)(lastErrno);
            rc = (int)(winLogErrorAtLine((int)(10 | (7 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winFileSize", pFile.zPath, (int)(46035)));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int winFullPathname(sqlite3_vfs pVfs, sbyte* zRelative, int nFull, sbyte* zFull)
{
    uint nByte = 0;
    void* zConverted;
    sbyte* zOut;
    if (((zRelative[0]) == (47)) &amp;&amp; (((winIsDriveLetterAndColon(zRelative + 1)) != 0) || ((winIsLongPathPrefix(zRelative + 1)) != 0)))
    {
        zRelative++;
    }

    if (((sqlite3_data_directory) != null) &amp;&amp; (winIsVerbatimPathname(zRelative) == 0))
    {
        sqlite3_snprintf((int)((nFull) &lt; (pVfs.mxPathname) ? (nFull) : (pVfs.mxPathname)), zFull, "%s%c%s", sqlite3_data_directory, (int)(92), zRelative);
        return (int)(0);
    }

    zConverted = winConvertFromUtf8Filename(zRelative);
    if ((zConverted) == (null))
    {
        return (int)(10 | (12 &lt;&lt; 8));
    }

    if ((1) != 0)
    {
        ushort* zTemp;
        nByte = (uint)((Uint(UShort * , UShort * , UShort * , UShort * ))(aSyscall[25].pCurrent)((ushort*)(zConverted), (uint)(0), null, null));
        if ((nByte) == (0))
        {
            sqlite3_free(zConverted);
            return (int)(winLogErrorAtLine((int)(14 | (3 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname1", zRelative, (int)(48608)));
        }

        nByte += (uint)(3);
        zTemp = sqlite3MallocZero((ulong)(nByte * sizeof(ushort)));
        if ((zTemp) == (null))
        {
            sqlite3_free(zConverted);
            return (int)(10 | (12 &lt;&lt; 8));
        }

        nByte = (uint)((Uint(UShort * , UShort * , UShort * , UShort * ))(aSyscall[25].pCurrent)((ushort*)(zConverted), (uint)(nByte), zTemp, null));
        if ((nByte) == (0))
        {
            sqlite3_free(zConverted);
            sqlite3_free(zTemp);
            return (int)(winLogErrorAtLine((int)(14 | (3 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname2", zRelative, (int)(48621)));
        }

        sqlite3_free(zConverted);
        zOut = winUnicodeToUtf8(zTemp);
        sqlite3_free(zTemp);
    }
    else
    {
        sbyte* zTemp;
        nByte = (uint)((Uint(Sbyte * , Sbyte * , Sbyte * , Sbyte * ))(aSyscall[24].pCurrent)((sbyte*)(zConverted), (uint)(0), null, null));
        if ((nByte) == (0))
        {
            sqlite3_free(zConverted);
            return (int)(winLogErrorAtLine((int)(14 | (3 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname3", zRelative, (int)(48634)));
        }

        nByte += (uint)(3);
        zTemp = sqlite3MallocZero((ulong)(nByte * sizeof(sbyte)));
        if ((zTemp) == (null))
        {
            sqlite3_free(zConverted);
            return (int)(10 | (12 &lt;&lt; 8));
        }

        nByte = (uint)((Uint(Sbyte * , Sbyte * , Sbyte * , Sbyte * ))(aSyscall[24].pCurrent)((sbyte*)(zConverted), (uint)(nByte), zTemp, null));
        if ((nByte) == (0))
        {
            sqlite3_free(zConverted);
            sqlite3_free(zTemp);
            return (int)(winLogErrorAtLine((int)(14 | (3 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname4", zRelative, (int)(48647)));
        }

        sqlite3_free(zConverted);
        zOut = winMbcsToUtf8(zTemp, (int)((Int())(aSyscall[0].pCurrent)()));
        sqlite3_free(zTemp);
    }

    if ((zOut) != null)
    {
        sqlite3_snprintf((int)((nFull) &lt; (pVfs.mxPathname) ? (nFull) : (pVfs.mxPathname)), zFull, "%s", zOut);
        sqlite3_free(zOut);
        return (int)(0);
    }
    else
    {
        return (int)(10 | (12 &lt;&lt; 8));
    }
}</function>
  <function>public static int winGetLastError(sqlite3_vfs pVfs, int nBuf, sbyte* zBuf)
{
    uint e = (uint)((Uint())(aSyscall[26].pCurrent)());
    if ((nBuf) &gt; (0))
        winGetLastErrorMsg((uint)(e), (int)(nBuf), zBuf);
    return (int)(e);
}</function>
  <function>public static int winGetLastErrorMsg(uint lastErrno, int nBuf, sbyte* zBuf)
{
    uint dwLen = (uint)(0);
    sbyte* zOut = null;
    if ((1) != 0)
    {
        ushort* zTempWide = null;
        dwLen = (uint)((Uint(Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[15].pCurrent)((uint)(0x00000100 | 0x00001000 | 0x00000200), null, (uint)(lastErrno), (uint)(0), (ushort*)(&amp;zTempWide), (uint)(0), null));
        if ((dwLen) &gt; (0))
        {
            sqlite3BeginBenignMalloc();
            zOut = winUnicodeToUtf8(zTempWide);
            sqlite3EndBenignMalloc();
            (Void * (Void*))(aSyscall[46].pCurrent)(zTempWide);
        }
    }
    else
    {
        sbyte* zTemp = null;
        dwLen = (uint)((Uint(Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[14].pCurrent)((uint)(0x00000100 | 0x00001000 | 0x00000200), null, (uint)(lastErrno), (uint)(0), (sbyte*)(&amp;zTemp), (uint)(0), null));
        if ((dwLen) &gt; (0))
        {
            sqlite3BeginBenignMalloc();
            zOut = winMbcsToUtf8(zTemp, (int)((Int())(aSyscall[0].pCurrent)()));
            sqlite3EndBenignMalloc();
            (Void * (Void*))(aSyscall[46].pCurrent)(zTemp);
        }
    }

    if ((0) == (dwLen))
    {
        sqlite3_snprintf((int)(nBuf), zBuf, "OsError 0x%lx (%lu)", (uint)(lastErrno), (uint)(lastErrno));
    }
    else
    {
        sqlite3_snprintf((int)(nBuf), zBuf, "%s", zOut);
        sqlite3_free(zOut);
    }

    return (int)(0);
}</function>
  <function>public static int winGetReadLock(winFile pFile)
{
    int res = 0;
    if ((1) != 0)
    {
        res = (int)(winLockFile(&amp;pFile.h, (uint)(0x00000001), (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
    }
    else
    {
        int lk = 0;
        sqlite3_randomness((int)(sizeof(int)), &amp;lk);
        pFile.sharedLockByte = ((short)((lk &amp; 0x7fffffff) % (510 - 1)));
        res = (int)(winLockFile(&amp;pFile.h, (uint)(0x00000001 | 0x00000002), (uint)((sqlite3PendingByte + 2) + pFile.sharedLockByte), (uint)(0), (uint)(1), (uint)(0)));
    }

    if ((res) == (0))
    {
        pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
    }

    return (int)(res);
}</function>
  <function>public static Void ( )winGetSystemCall(sqlite3_vfs pNotUsed, sbyte* zName)
{
    uint i = 0;
    for (i = (uint)(0); (i) &lt; (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
    {
        if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
            return aSyscall[i].pCurrent;
    }

    return null;
}</function>
  <function>public static int winGetTempname(sqlite3_vfs pVfs, sbyte** pzBuf)
{
    ulong i = 0; ulong  j  =  0 ; 
    int nPre = (int)(sqlite3Strlen30("etilqs_"));
    int nMax = 0; int  nBuf  =  0 ;  int  nDir  =  0 ;  int  nLen  =  0 ; 
    sbyte* zBuf;
    nMax = (int)(pVfs.mxPathname);
    nBuf = (int)(nMax + 2);
    zBuf = sqlite3MallocZero((ulong)(nBuf));
    if (zBuf == null)
    {
        return (int)(10 | (12 &lt;&lt; 8));
    }

    nDir = (int)(nMax - (nPre + 15));
    if ((sqlite3_temp_directory) != null)
    {
        int nDirLen = (int)(sqlite3Strlen30(sqlite3_temp_directory));
        if ((nDirLen) &gt; (0))
        {
            if (!(((sqlite3_temp_directory[nDirLen - 1]) == (47)) || ((sqlite3_temp_directory[nDirLen - 1]) == (92))))
            {
                nDirLen++;
            }

            if ((nDirLen) &gt; (nDir))
            {
                sqlite3_free(zBuf);
                return (int)(winLogErrorAtLine((int)(1), (uint)(0), "winGetTempname1", null, (int)(47691)));
            }

            sqlite3_snprintf((int)(nMax), zBuf, "%s", sqlite3_temp_directory);
        }
    }
    else if ((1) != 0)
    {
        sbyte* zMulti;
        ushort* zWidePath = sqlite3MallocZero((ulong)(nMax * sizeof(ushort)));
        if (zWidePath == null)
        {
            sqlite3_free(zBuf);
            return (int)(10 | (12 &lt;&lt; 8));
        }

        if (((Uint(Uint, Uint))(aSyscall[32].pCurrent)((uint)(nMax), zWidePath)) == (0))
        {
            sqlite3_free(zWidePath);
            sqlite3_free(zBuf);
            return (int)(winLogErrorAtLine((int)(10 | (25 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winGetTempname2", null, (int)(47790)));
        }

        zMulti = winUnicodeToUtf8(zWidePath);
        if ((zMulti) != null)
        {
            sqlite3_snprintf((int)(nMax), zBuf, "%s", zMulti);
            sqlite3_free(zMulti);
            sqlite3_free(zWidePath);
        }
        else
        {
            sqlite3_free(zWidePath);
            sqlite3_free(zBuf);
            return (int)(10 | (12 &lt;&lt; 8));
        }
    }
    else
    {
        sbyte* zUtf8;
        sbyte* zMbcsPath = sqlite3MallocZero((ulong)(nMax));
        if (zMbcsPath == null)
        {
            sqlite3_free(zBuf);
            return (int)(10 | (12 &lt;&lt; 8));
        }

        if (((Uint(Uint, Uint))(aSyscall[31].pCurrent)((uint)(nMax), zMbcsPath)) == (0))
        {
            sqlite3_free(zBuf);
            return (int)(winLogErrorAtLine((int)(10 | (25 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winGetTempname3", null, (int)(47817)));
        }

        zUtf8 = winMbcsToUtf8(zMbcsPath, (int)((Int())(aSyscall[0].pCurrent)()));
        if ((zUtf8) != null)
        {
            sqlite3_snprintf((int)(nMax), zBuf, "%s", zUtf8);
            sqlite3_free(zUtf8);
        }
        else
        {
            sqlite3_free(zBuf);
            return (int)(10 | (12 &lt;&lt; 8));
        }
    }

    if (winMakeEndInDirSep((int)(nDir + 1), zBuf) == 0)
    {
        sqlite3_free(zBuf);
        return (int)(winLogErrorAtLine((int)(1), (uint)(0), "winGetTempname4", null, (int)(47840)));
    }

    nLen = (int)(sqlite3Strlen30(zBuf));
    if ((nLen + nPre + 17) &gt; (nBuf))
    {
        sqlite3_free(zBuf);
        return (int)(winLogErrorAtLine((int)(1), (uint)(0), "winGetTempname5", null, (int)(47858)));
    }

    sqlite3_snprintf((int)(nBuf - 16 - nLen), zBuf + nLen, "etilqs_");
    j = (ulong)(sqlite3Strlen30(zBuf));
    sqlite3_randomness((int)(15), &amp;zBuf[j]);
    for (i = (ulong)(0); (i) &lt; (15); i++, j++)
    {
        zBuf[j] = (sbyte)(winGetTempname_zChars[((byte)(zBuf[j])) % (63 * sizeof(sbyte) - 1)]);
    }

    zBuf[j] = (sbyte)(0);
    zBuf[j + 1] = (sbyte)(0);
    *pzBuf = zBuf;
    return (int)(0);
}</function>
  <function>public static int winIsDir(void* zConverted)
{
    uint attr = 0;
    int rc = (int)(0);
    uint lastErrno = 0;
    if ((1) != 0)
    {
        int cnt = (int)(0);
        _WIN32_FILE_ATTRIBUTE_DATA sAttrData = new _WIN32_FILE_ATTRIBUTE_DATA();
        CRuntime.memset(&amp;sAttrData, (int)(0), (ulong)(sizeof(_WIN32_FILE_ATTRIBUTE_DATA)));
        while ((!(rc = (int)((Int(UShort * , UShort * , UShort * ))(aSyscall[22].pCurrent)((ushort*)(zConverted), ( enum _GET_FILEEX_INFO_LEVELS)(GetFileExInfoStandard), &amp;sAttrData))))
            &amp;&amp; ((winRetryIoerr(&amp;cnt, &amp;lastErrno)) != 0) )
        {
        }

        if (rc == 0)
        {
            return (int)(0);
        }

        attr = (uint)(sAttrData.dwFileAttributes);
    }
    else
    {
        attr = (uint)((Uint(Sbyte * ))(aSyscall[20].pCurrent)((sbyte*)(zConverted)));
    }

    return ((attr != ((uint)(-1))) &amp;&amp; ((attr &amp; 0x00000010) != 0) ? 1 : 0);
}</function>
  <function>public static int winIsDriveLetterAndColon(sbyte* zPathname)
{
    return ((((sqlite3CtypeMap[(byte)(zPathname[0])] &amp; 0x02) != 0) &amp;&amp; ((zPathname[1]) == (58))) ? 1 : 0);
}</function>
  <function>public static int winIsLongPathPrefix(sbyte* zPathname)
{
    return ((((((zPathname[0]) == (92)) &amp;&amp; ((zPathname[1]) == (92))) &amp;&amp; ((zPathname[2]) == (63))) &amp;&amp; ((zPathname[3]) == (92))) ? 1 : 0);
}</function>
  <function>public static int winIsVerbatimPathname(sbyte* zPathname)
{
    if ((((zPathname[0]) == (47)) || ((zPathname[0]) == (92))))
    {
        return (int)(1);
    }

    if ((winIsDriveLetterAndColon(zPathname)) != 0)
    {
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int winLock(sqlite3_file id, int locktype)
{
    int rc = (int)(0);
    int res = (int)(1);
    int newLocktype = 0;
    int gotPendingLock = (int)(0);
    winFile pFile = (winFile)(id);
    uint lastErrno = (uint)(0L);
    if ((pFile.locktype) &gt;= (locktype))
    {
        return (int)(0);
    }

    if (((pFile.ctrlFlags &amp; 0x02) != 0) &amp;&amp; ((locktype) &gt;= (2)))
    {
        return (int)(10 | (15 &lt;&lt; 8));
    }

    newLocktype = (int)(pFile.locktype);
    if (((pFile.locktype) == (0)) || (((locktype) == (4)) &amp;&amp; ((pFile.locktype) &lt;= (2))))
    {
        int cnt = (int)(3);
        while (((cnt--) &gt; (0)) &amp;&amp; ((res = (int)(winLockFile(&amp;pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0)))) == (0)))
        {
            lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            if ((lastErrno) == (6L))
            {
                pFile.lastErrno = (uint)(lastErrno);
                rc = (int)(10 | (15 &lt;&lt; 8));
                return (int)(rc);
            }

            if ((cnt) != 0)
                sqlite3_win32_sleep((uint)(1));
        }

        gotPendingLock = (int)(res);
        if (res == 0)
        {
            lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
        }
    }

    if (((locktype) == (1)) &amp;&amp; ((res) != 0))
    {
        res = (int)(winGetReadLock(pFile));
        if ((res) != 0)
        {
            newLocktype = (int)(1);
        }
        else
        {
            lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
        }
    }

    if (((locktype) == (2)) &amp;&amp; ((res) != 0))
    {
        res = (int)(winLockFile(&amp;pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0)));
        if ((res) != 0)
        {
            newLocktype = (int)(2);
        }
        else
        {
            lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
        }
    }

    if (((locktype) == (4)) &amp;&amp; ((res) != 0))
    {
        newLocktype = (int)(3);
        gotPendingLock = (int)(0);
    }

    if (((locktype) == (4)) &amp;&amp; ((res) != 0))
    {
        res = (int)(winUnlockReadLock(pFile));
        res = (int)(winLockFile(&amp;pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
        if ((res) != 0)
        {
            newLocktype = (int)(4);
        }
        else
        {
            lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            winGetReadLock(pFile);
        }
    }

    if (((gotPendingLock) != 0) &amp;&amp; ((locktype) == (1)))
    {
        winUnlockFile(&amp;pFile.h, (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0));
    }

    if ((res) != 0)
    {
        rc = (int)(0);
    }
    else
    {
        pFile.lastErrno = (uint)(lastErrno);
        rc = (int)(5);
    }

    pFile.locktype = ((byte)(newLocktype));
    return (int)(rc);
}</function>
  <function>public static int winLockFile(void** phFile, uint flags, uint offsetLow, uint offsetHigh, uint numBytesLow, uint numBytesHigh)
{
    if ((1) != 0)
    {
        _OVERLAPPED ovlp = new _OVERLAPPED();
        CRuntime.memset(&amp;ovlp, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
        ovlp..Offset = (uint)(offsetLow);
        ovlp..OffsetHigh = (uint)(offsetHigh);
        return (int)((Int(Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[48].pCurrent)(*phFile, (uint)(flags), (uint)(0), (uint)(numBytesLow), (uint)(numBytesHigh), &amp;ovlp));
    }
    else
    {
        return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[47].pCurrent)(*phFile, (uint)(offsetLow), (uint)(offsetHigh), (uint)(numBytesLow), (uint)(numBytesHigh)));
    }
}</function>
  <function>public static int winLockSharedMemory(winShmNode pShmNode)
{
    int rc = (int)(winShmSystemLock(pShmNode, (int)(3), (int)(((22 + 8) * 4) + 8), (int)(1)));
    if ((rc) == (0))
    {
        if ((pShmNode.isReadonly) != 0)
        {
            pShmNode.isUnlocked = (byte)(1);
            winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
            return (int)(8 | (5 &lt;&lt; 8));
        }
        else if ((winTruncate((sqlite3_file)(pShmNode.hFile), (long)(0))) != 0)
        {
            winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
            return (int)(winLogErrorAtLine((int)(10 | (18 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winLockSharedMemory", pShmNode.zFilename, (int)(46822)));
        }
    }

    if ((rc) == (0))
    {
        winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
    }

    return (int)(winShmSystemLock(pShmNode, (int)(2), (int)(((22 + 8) * 4) + 8), (int)(1)));
}</function>
  <function>public static int winLogErrorAtLine(int errcode, uint lastErrno, sbyte* zFunc, sbyte* zPath, int iLine)
{
    sbyte* zMsg = stackalloc sbyte[500];
    int i = 0;
    zMsg[0] = (sbyte)(0);
    winGetLastErrorMsg((uint)(lastErrno), (int)(500 * sizeof(sbyte)), zMsg);
    if ((zPath) == (null))
        zPath = "";
    for (i = (int)(0); (((zMsg[i]) != 0) &amp;&amp; (zMsg[i] != 13)) &amp;&amp; (zMsg[i] != 10); i++)
    {
    }

    zMsg[i] = (sbyte)(0);
    sqlite3_log((int)(errcode), "os_win.c:%d: (%lu) %s(%s) - %s", (int)(iLine), (uint)(lastErrno), zFunc, zPath, zMsg);
    return (int)(errcode);
}</function>
  <function>public static void winLogIoerr(int nRetry, int lineno)
{
    if ((nRetry) != 0)
    {
        sqlite3_log((int)(27), "delayed %dms for lock/sharing conflict at line %d", (int)(winIoerrRetryDelay * nRetry * (nRetry + 1) / 2), (int)(lineno));
    }
}</function>
  <function>public static int winMakeEndInDirSep(int nBuf, sbyte* zBuf)
{
    if ((zBuf) != null)
    {
        int nLen = (int)(sqlite3Strlen30(zBuf));
        if ((nLen) &gt; (0))
        {
            if ((((zBuf[nLen - 1]) == (47)) || ((zBuf[nLen - 1]) == (92))))
            {
                return (int)(1);
            }
            else if ((nLen + 1) &lt; (nBuf))
            {
                zBuf[nLen] = (sbyte)(92);
                zBuf[nLen + 1] = (sbyte)(0);
                return (int)(1);
            }
        }
    }

    return (int)(0);
}</function>
  <function>public static int winMapfile(winFile pFd, long nByte)
{
    long nMap = (long)(nByte);
    int rc = 0;
    if ((pFd.nFetchOut) &gt; (0))
        return (int)(0);
    if ((nMap) &lt; (0))
    {
        rc = (int)(winFileSize((sqlite3_file)(pFd), &amp;nMap));
        if ((rc) != 0)
        {
            return (int)(10 | (7 &lt;&lt; 8));
        }
    }

    if ((nMap) &gt; (pFd.mmapSizeMax))
    {
        nMap = (long)(pFd.mmapSizeMax);
    }

    nMap &amp;= (long)(~(long)(winSysInfo.dwPageSize - 1));
    if (((nMap) == (0)) &amp;&amp; ((pFd.mmapSize) &gt; (0)))
    {
        winUnmapfile(pFd);
    }

    if (nMap != pFd.mmapSize)
    {
        void* pNew = null;
        uint protect = (uint)(0x02);
        uint flags = (uint)(0x0004);
        winUnmapfile(pFd);
        pFd.hMap = (Void * (Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[7].pCurrent)(pFd.h, null, (uint)(protect), (uint)((nMap &gt;&gt; 32) &amp; 0xffffffff), (uint)(nMap &amp; 0xffffffff), null);
        if ((pFd.hMap) == null)
        {
            pFd.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            rc = (int)(winLogErrorAtLine((int)(10 | (24 &lt;&lt; 8)), (uint)(pFd.lastErrno), "winMapfile1", pFd.zPath, (int)(47386)));
            return (int)(0);
        }

        pNew = (Void * (Void * , Void * , Void * , Void * , Void * ))(aSyscall[49].pCurrent)(pFd.hMap, (uint)(flags), (uint)(0), (uint)(0), (ulong)(nMap));
        if ((pNew) == null)
        {
            (Int(Void * ))(aSyscall[3].pCurrent)(pFd.hMap);
            pFd.hMap = null;
            pFd.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            rc = (int)(winLogErrorAtLine((int)(10 | (24 &lt;&lt; 8)), (uint)(pFd.lastErrno), "winMapfile2", pFd.zPath, (int)(47404)));
            return (int)(0);
        }

        pFd.pMapRegion = pNew;
        pFd.mmapSize = (long)(nMap);
    }

    return (int)(0);
}</function>
  <function>public static ushort* winMbcsToUnicode(sbyte* zText, int useAnsi)
{
    int nByte = 0;
    ushort* zMbcsText;
    int codepage = (int)((useAnsi) != 0 ? 0 : 1);
    nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(codepage), (uint)(0), zText, (int)(-1), null, (int)(0)) * sizeof(ushort));
    if ((nByte) == (0))
    {
        return null;
    }

    zMbcsText = sqlite3MallocZero((ulong)(nByte * sizeof(ushort)));
    if ((zMbcsText) == (null))
    {
        return null;
    }

    nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(codepage), (uint)(0), zText, (int)(-1), zMbcsText, (int)(nByte)));
    if ((nByte) == (0))
    {
        sqlite3_free(zMbcsText);
        zMbcsText = null;
    }

    return zMbcsText;
}</function>
  <function>public static sbyte* winMbcsToUtf8(sbyte* zText, int useAnsi)
{
    sbyte* zTextUtf8;
    ushort* zTmpWide;
    zTmpWide = winMbcsToUnicode(zText, (int)(useAnsi));
    if ((zTmpWide) == (null))
    {
        return null;
    }

    zTextUtf8 = winUnicodeToUtf8(zTmpWide);
    sqlite3_free(zTmpWide);
    return zTextUtf8;
}</function>
  <function>public static void winModeBit(winFile pFile, byte mask, int* pArg)
{
    if ((*pArg) &lt; (0))
    {
        *pArg = (int)((pFile.ctrlFlags &amp; mask) != 0);
    }
    else if ((*pArg) == (0))
    {
        pFile.ctrlFlags &amp;= (byte)(~mask);
    }
    else
    {
        pFile.ctrlFlags |= (byte)(mask);
    }
}</function>
  <function>public static sqlite3_mutex* winMutexAlloc(int iType)
{
    sqlite3_mutex* p;
    switch (iType)
    {
        case 0:
        case 1:
        {
            p = sqlite3MallocZero((ulong)(sizeof(sqlite3_mutex)));
            if ((p) != null)
            {
                p-&gt;id = (int)(iType);
                InitializeCriticalSection(&amp;p-&gt;mutex);
            }

            break;
        }

        default:
        {
            p = &amp;winMutex_staticMutexes[iType - 2];
            break;
        }
    }

    return p;
}</function>
  <function>public static int winMutexEnd()
{
    if ((_InterlockedCompareExchange(&amp;winMutex_lock, (int)(0), (int)(1))) == (1))
    {
        if ((winMutex_isInit) == (1))
        {
            int i = 0;
            for (i = (int)(0); (i) &lt; ((int)(12 * sizeof(sqlite3_mutex) / sizeof(sqlite3_mutex))); i++)
            {
                DeleteCriticalSection(&amp;winMutex_staticMutexes[i].mutex);
            }

            winMutex_isInit = (int)(0);
        }
    }

    return (int)(0);
}</function>
  <function>public static void winMutexEnter(sqlite3_mutex* p)
{
    EnterCriticalSection(&amp;p-&gt;mutex);
}</function>
  <function>public static void winMutexFree(sqlite3_mutex* p)
{
    if (((p-&gt;id) == (0)) || ((p-&gt;id) == (1)))
    {
        DeleteCriticalSection(&amp;p-&gt;mutex);
        sqlite3_free(p);
    }
    else
    {
    }
}</function>
  <function>public static int winMutexInit()
{
    if ((_InterlockedCompareExchange(&amp;winMutex_lock, (int)(1), (int)(0))) == (0))
    {
        int i = 0;
        for (i = (int)(0); (i) &lt; ((int)(12 * sizeof(sqlite3_mutex) / sizeof(sqlite3_mutex))); i++)
        {
            InitializeCriticalSection(&amp;winMutex_staticMutexes[i].mutex);
        }

        winMutex_isInit = (int)(1);
    }
    else
    {
        while (winMutex_isInit == 0)
        {
            sqlite3_win32_sleep((uint)(1));
        }
    }

    return (int)(0);
}</function>
  <function>public static void winMutexLeave(sqlite3_mutex* p)
{
    LeaveCriticalSection(&amp;p-&gt;mutex);
}</function>
  <function>public static int winMutexTry(sqlite3_mutex* p)
{
    int rc = (int)(5);
    if ((winMutex_isNt) &lt; (0))
    {
        winMutex_isNt = (int)(sqlite3_win32_is_nt());
    }

    if (((winMutex_isNt) != 0) &amp;&amp; ((TryEnterCriticalSection(&amp;p-&gt;mutex)) != 0))
    {
        rc = (int)(0);
    }

    return (int)(rc);
}</function>
  <function>public static sbyte* winNextSystemCall(sqlite3_vfs p, sbyte* zName)
{
    int i = (int)(-1);
    if ((zName) != null)
    {
        for (i = (int)(0); (i) &lt; (((int)(80 * sizeof(win_syscall) / sizeof(win_syscall))) - 1); i++)
        {
            if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
                break;
        }
    }

    for (i++; (i) &lt; ((int)(80 * sizeof(win_syscall) / sizeof(win_syscall))); i++)
    {
        if (aSyscall[i].pCurrent != null)
            return aSyscall[i].zName;
    }

    return null;
}</function>
  <function>public static int winNolockCheckReservedLock(sqlite3_file id, int* pResOut)
{
    return (int)(0);
}</function>
  <function>public static int winNolockLock(sqlite3_file id, int locktype)
{
    return (int)(0);
}</function>
  <function>public static int winNolockUnlock(sqlite3_file id, int locktype)
{
    return (int)(0);
}</function>
  <function>public static int winOpen(sqlite3_vfs pVfs, sbyte* zName, sqlite3_file id, int flags, int* pOutFlags)
{
    void* h;
    uint lastErrno = (uint)(0);
    uint dwDesiredAccess = 0;
    uint dwShareMode = 0;
    uint dwCreationDisposition = 0;
    uint dwFlagsAndAttributes = (uint)(0);
    winVfsAppData pAppData;
    winFile pFile = (winFile)(id);
    void* zConverted;
    sbyte* zUtf8Name = zName;
    int cnt = (int)(0);
    sbyte* zTmpname = null;
    int rc = (int)(0);
    int isExclusive = (int)(flags &amp; 0x00000010);
    int isDelete = (int)(flags &amp; 0x00000008);
    int isCreate = (int)(flags &amp; 0x00000004);
    int isReadonly = (int)(flags &amp; 0x00000001);
    int isReadWrite = (int)(flags &amp; 0x00000002);
    CRuntime.memset(pFile, (int)(0), (ulong)(sizeof(winFile)));
    pFile.h = ((void*)((long)(-1)));
    if (zUtf8Name == null)
    {
        rc = (int)(winGetTempname(pVfs, &amp;zTmpname));
        if (rc != 0)
        {
            return (int)(rc);
        }

        zUtf8Name = zTmpname;
    }

    zConverted = winConvertFromUtf8Filename(zUtf8Name);
    if ((zConverted) == (null))
    {
        sqlite3_free(zTmpname);
        return (int)(10 | (12 &lt;&lt; 8));
    }

    if ((winIsDir(zConverted)) != 0)
    {
        sqlite3_free(zConverted);
        sqlite3_free(zTmpname);
        return (int)(14 | (2 &lt;&lt; 8));
    }

    if ((isReadWrite) != 0)
    {
        dwDesiredAccess = (uint)((0x80000000L) | (0x40000000L));
    }
    else
    {
        dwDesiredAccess = (uint)(0x80000000L);
    }

    if ((isExclusive) != 0)
    {
        dwCreationDisposition = (uint)(1);
    }
    else if ((isCreate) != 0)
    {
        dwCreationDisposition = (uint)(4);
    }
    else
    {
        dwCreationDisposition = (uint)(3);
    }

    if ((0) == (sqlite3_uri_boolean(zName, "exclusive", (int)(0))))
    {
        dwShareMode = (uint)(0x00000001 | 0x00000002);
    }
    else
    {
        dwShareMode = (uint)(0);
    }

    if ((isDelete) != 0)
    {
        dwFlagsAndAttributes = (uint)(0x00000100 | 0x00000002 | 0x04000000);
    }
    else
    {
        dwFlagsAndAttributes = (uint)(0x00000080);
    }

    if ((1) != 0)
    {
        do
        {
            h = (Void * (UShort * , UShort * , UShort * , UShort * , UShort * , UShort * , UShort * ))(aSyscall[5].pCurrent)((ushort*)(zConverted), (uint)(dwDesiredAccess), (uint)(dwShareMode), null, (uint)(dwCreationDisposition), (uint)(dwFlagsAndAttributes), null);
            if (h != ((void*)((long)(-1))))
                break;
            if ((isReadWrite) != 0)
            {
                int rc2 = 0;
                int isRO = (int)(0);
                sqlite3BeginBenignMalloc();
                rc2 = (int)(winAccess(pVfs, zName, (int)(2), &amp;isRO));
                sqlite3EndBenignMalloc();
                if (((rc2) == (0)) &amp;&amp; ((isRO) != 0))
                    break;
            }
        }
        while ((winRetryIoerr(&amp;cnt, &amp;lastErrno)) != 0);
    }
    else
    {
        do
        {
            h = (Void * (Sbyte * , Sbyte * , Sbyte * , Sbyte * , Sbyte * , Sbyte * , Sbyte * ))(aSyscall[4].pCurrent)((sbyte*)(zConverted), (uint)(dwDesiredAccess), (uint)(dwShareMode), null, (uint)(dwCreationDisposition), (uint)(dwFlagsAndAttributes), null);
            if (h != ((void*)((long)(-1))))
                break;
            if ((isReadWrite) != 0)
            {
                int rc2 = 0;
                int isRO = (int)(0);
                sqlite3BeginBenignMalloc();
                rc2 = (int)(winAccess(pVfs, zName, (int)(2), &amp;isRO));
                sqlite3EndBenignMalloc();
                if (((rc2) == (0)) &amp;&amp; ((isRO) != 0))
                    break;
            }
        }
        while ((winRetryIoerr(&amp;cnt, &amp;lastErrno)) != 0);
    }

    winLogIoerr((int)(cnt), (int)(48147));
    if ((h) == ((void*)((long)(-1))))
    {
        sqlite3_free(zConverted);
        sqlite3_free(zTmpname);
        if (((isReadWrite) != 0) &amp;&amp; (isExclusive == 0))
        {
            return (int)(winOpen(pVfs, zName, id, (int)((flags | 0x00000001) &amp; ~(0x00000004 | 0x00000002)), pOutFlags));
        }
        else
        {
            pFile.lastErrno = (uint)(lastErrno);
            winLogErrorAtLine((int)(14), (uint)(pFile.lastErrno), "winOpen", zUtf8Name, (int)(48162));
            return (int)(sqlite3CantopenError((int)(48163)));
        }
    }

    if ((pOutFlags) != null)
    {
        if ((isReadWrite) != 0)
        {
            *pOutFlags = (int)(0x00000002);
        }
        else
        {
            *pOutFlags = (int)(0x00000001);
        }
    }

    pAppData = (winVfsAppData)(pVfs.pAppData);
    {
        sqlite3_free(zConverted);
    }

    sqlite3_free(zTmpname);
    id.pMethods = pAppData ? pAppData.pMethod : winIoMethod;
    pFile.pVfs = pVfs;
    pFile.h = h;
    if ((isReadonly) != 0)
    {
        pFile.ctrlFlags |= (byte)(0x02);
    }

    if (((flags &amp; 0x00000100) != 0) &amp;&amp; ((sqlite3_uri_boolean(zName, "psow", (int)(1))) != 0))
    {
        pFile.ctrlFlags |= (byte)(0x10);
    }

    pFile.lastErrno = (uint)(0L);
    pFile.zPath = zName;
    pFile.hMap = null;
    pFile.pMapRegion = null;
    pFile.mmapSize = (long)(0);
    pFile.mmapSizeMax = (long)(sqlite3Config.szMmap);
    return (int)(rc);
}</function>
  <function>public static int winOpenSharedMemory(winFile pDbFd)
{
    winShm p;
    winShmNode pShmNode = null;
    int rc = (int)(0);
    winShmNode pNew;
    int nName = 0;
    p = sqlite3MallocZero((ulong)(sizeof(winShm)));
    if ((p) == (null))
        return (int)(10 | (12 &lt;&lt; 8));
    nName = (int)(sqlite3Strlen30(pDbFd.zPath));
    pNew = sqlite3MallocZero((ulong)(sizeof(winShmNode) + nName + 17));
    if ((pNew) == (null))
    {
        sqlite3_free(p);
        return (int)(10 | (12 &lt;&lt; 8));
    }

    pNew.zFilename = (sbyte*)(pNew[1]);
    sqlite3_snprintf((int)(nName + 15), pNew.zFilename, "%s-shm", pDbFd.zPath);
    winShmEnterMutex();
    for (pShmNode = winShmNodeList; pShmNode; pShmNode = pShmNode.pNext)
    {
        if ((sqlite3StrICmp(pShmNode.zFilename, pNew.zFilename)) == (0))
            break;
    }

    if ((pShmNode) != null)
    {
        sqlite3_free(pNew);
    }
    else
    {
        int inFlags = (int)(0x00080000);
        int outFlags = (int)(0);
        pShmNode = pNew;
        pNew = null;
        (pShmNode.hFile).h = ((void*)((long)(-1)));
        pShmNode.pNext = winShmNodeList;
        winShmNodeList = pShmNode;
        if ((sqlite3Config.bCoreMutex) != 0)
        {
            pShmNode.mutex = sqlite3_mutex_alloc((int)(0));
            if ((pShmNode.mutex) == (null))
            {
                rc = (int)(10 | (12 &lt;&lt; 8));
                goto shm_open_err;
            }
        }

        if ((0) == (sqlite3_uri_boolean(pDbFd.zPath, "readonly_shm", (int)(0))))
        {
            inFlags |= (int)(0x00000002 | 0x00000004);
        }
        else
        {
            inFlags |= (int)(0x00000001);
        }

        rc = (int)(winOpen(pDbFd.pVfs, pShmNode.zFilename, (sqlite3_file)(pShmNode.hFile), (int)(inFlags), &amp;outFlags));
        if (rc != 0)
        {
            rc = (int)(winLogErrorAtLine((int)(rc), (uint)((Uint())(aSyscall[26].pCurrent)()), "winOpenShm", pShmNode.zFilename, (int)(46904)));
            goto shm_open_err;
        }

        if ((outFlags) == (0x00000001))
            pShmNode.isReadonly = (byte)(1);
        rc = (int)(winLockSharedMemory(pShmNode));
        if ((rc != 0) &amp;&amp; (rc != (8 | (5 &lt;&lt; 8))))
            goto shm_open_err;
    }

    p.pShmNode = pShmNode;
    pShmNode.nRef++;
    pDbFd.pShm = p;
    winShmLeaveMutex();
    sqlite3_mutex_enter(pShmNode.mutex);
    p.pNext = pShmNode.pFirst;
    pShmNode.pFirst = p;
    sqlite3_mutex_leave(pShmNode.mutex);
    return (int)(rc);
    shm_open_err:
        ; winShmSystemLock ( pShmNode ,  ( int ) ( 1 ) ,  ( int ) ( ( ( 22 + 8 ) * 4 ) + 8 ) ,  ( int ) ( 1 ) ) ; 
    winShmPurge(pDbFd.pVfs, (int)(0));
    sqlite3_free(p);
    sqlite3_free(pNew);
    winShmLeaveMutex();
    return (int)(rc);
}</function>
  <function>public static int winRandomness(sqlite3_vfs pVfs, int nBuf, sbyte* zBuf)
{
    EntropyGatherer e = new EntropyGatherer();
    CRuntime.memset(zBuf, (int)(0), (ulong)(nBuf));
    e.a = (byte*)(zBuf);
    e.na = (int)(nBuf);
    e.nXor = (int)(0);
    e.i = (int)(0);
    {
        _SYSTEMTIME x = new _SYSTEMTIME();
        (Void(_SYSTEMTIME * ))(aSyscall[29].pCurrent)(&amp;x);
        xorMemory(&amp;e, (byte*)(&amp;x), (int)(sizeof(_SYSTEMTIME)));
    }

    {
        uint pid = (uint)((Uint())(aSyscall[17].pCurrent)());
        xorMemory(&amp;e, (byte*)(&amp;pid), (int)(sizeof(uint)));
    }

    {
        uint cnt = (uint)((Uint())(aSyscall[33].pCurrent)());
        xorMemory(&amp;e, (byte*)(&amp;cnt), (int)(sizeof(uint)));
    }

    {
        union _LARGE_INTEGER i = new union _LARGE_INTEGER();
        (Int(union_LARGE_INTEGER * ))(aSyscall[51].pCurrent)(&amp;i);
        xorMemory(&amp;e, (byte*)(&amp;i), (int)(sizeof(union _LARGE_INTEGER) ) )
        ;
    }

    return (int)((e.nXor) &gt; (nBuf) ? nBuf : e.nXor);
}</function>
  <function>public static int winRead(sqlite3_file id, void* pBuf, int amt, long offset)
{
    _OVERLAPPED overlapped = new _OVERLAPPED();
    winFile pFile = (winFile)(id);
    uint nRead = 0;
    int nRetry = (int)(0);
    if ((offset) &lt; (pFile.mmapSize))
    {
        if ((offset + amt) &lt;= (pFile.mmapSize))
        {
            CRuntime.memcpy(pBuf, &amp;((byte*)(pFile.pMapRegion))[offset], (ulong)(amt));
            return (int)(0);
        }
        else
        {
            int nCopy = (int)(pFile.mmapSize - offset);
            CRuntime.memcpy(pBuf, &amp;((byte*)(pFile.pMapRegion))[offset], (ulong)(nCopy));
            pBuf = &amp;((byte*)(pBuf))[nCopy];
            amt -= (int)(nCopy);
            offset += (long)(nCopy);
        }
    }

    CRuntime.memset(&amp;overlapped, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
    overlapped..Offset = (uint)((int)(offset &amp; 0xffffffff));
    overlapped..OffsetHigh = (uint)((int)((offset &gt;&gt; 32) &amp; 0x7fffffff));
    while (((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[52].pCurrent)(pFile.h, pBuf, (uint)(amt), &amp;nRead, &amp;overlapped) == 0) &amp;&amp; ((Uint())(aSyscall[26].pCurrent)() != 38L))
    {
        uint lastErrno = 0;
        if ((winRetryIoerr(&amp;nRetry, &amp;lastErrno)) != 0)
            continue;
        pFile.lastErrno = (uint)(lastErrno);
        return (int)(winLogErrorAtLine((int)(10 | (1 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winRead", pFile.zPath, (int)(45699)));
    }

    winLogIoerr((int)(nRetry), (int)(45701));
    if ((nRead) &lt; ((uint)(amt)))
    {
        CRuntime.memset(&amp;((sbyte*)(pBuf))[nRead], (int)(0), (ulong)(amt - nRead));
        return (int)(10 | (2 &lt;&lt; 8));
    }

    return (int)(0);
}</function>
  <function>public static int winRetryIoerr(int* pnRetry, uint* pError)
{
    uint e = (uint)((Uint())(aSyscall[26].pCurrent)());
    if ((*pnRetry) &gt;= (winIoerrRetry))
    {
        if ((pError) != null)
        {
            *pError = (uint)(e);
        }

        return (int)(0);
    }

    if (((((((((e) == (5L)) || ((e) == (32L))) || ((e) == (33L))) || ((e) == (55L))) || ((e) == (64L))) || ((e) == (121L))) || ((e) == (1231L))))
    {
        sqlite3_win32_sleep((uint)(winIoerrRetryDelay * (1 + *pnRetry)));
        ++*pnRetry;
        return (int)(1);
    }

    if ((pError) != null)
    {
        *pError = (uint)(e);
    }

    return (int)(0);
}</function>
  <function>public static int winSectorSize(sqlite3_file id)
{
    (void)(id);
    return (int)(4096);
}</function>
  <function>public static int winSeekFile(winFile pFile, long iOffset)
{
    int upperBits = 0;
    int lowerBits = 0;
    uint dwRet = 0;
    uint lastErrno = 0;
    upperBits = ((int)((iOffset &gt;&gt; 32) &amp; 0x7fffffff));
    lowerBits = ((int)(iOffset &amp; 0xffffffff));
    dwRet = (uint)((Uint(Void * , Void * , Void * , Void * ))(aSyscall[54].pCurrent)(pFile.h, (int)(lowerBits), &amp;upperBits, (uint)(0)));
    if ((((dwRet) == ((uint)(-1))) &amp;&amp; ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 0L)))
    {
        pFile.lastErrno = (uint)(lastErrno);
        winLogErrorAtLine((int)(10 | (22 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winSeekFile", pFile.zPath, (int)(45535));
        return (int)(1);
    }

    return (int)(0);
}</function>
  <function>public static int winSetSystemCall(sqlite3_vfs pNotUsed, sbyte* zName, delegate74 pNewFunc)
{
    uint i = 0;
    int rc = (int)(12);
    if ((zName) == (null))
    {
        rc = (int)(0);
        for (i = (uint)(0); (i) &lt; (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
        {
            if ((aSyscall[i].pDefault) != null)
            {
                aSyscall[i].pCurrent = aSyscall[i].pDefault;
            }
        }
    }
    else
    {
        for (i = (uint)(0); (i) &lt; (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
        {
            if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
            {
                if ((aSyscall[i].pDefault) == (null))
                {
                    aSyscall[i].pDefault = aSyscall[i].pCurrent;
                }

                rc = (int)(0);
                if ((pNewFunc) == (null))
                    pNewFunc = aSyscall[i].pDefault;
                aSyscall[i].pCurrent = pNewFunc;
                break;
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static void winShmBarrier(sqlite3_file fd)
{
    sqlite3MemoryBarrier();
    winShmEnterMutex();
    winShmLeaveMutex();
}</function>
  <function>public static void winShmEnterMutex()
{
    sqlite3_mutex_enter(winBigLock);
}</function>
  <function>public static void winShmLeaveMutex()
{
    sqlite3_mutex_leave(winBigLock);
}</function>
  <function>public static int winShmLock(sqlite3_file fd, int ofst, int n, int flags)
{
    winFile pDbFd = (winFile)(fd);
    winShm p = pDbFd.pShm;
    winShm pX;
    winShmNode pShmNode;
    int rc = (int)(0);
    ushort mask = 0;
    if ((p) == (null))
        return (int)(10 | (20 &lt;&lt; 8));
    pShmNode = p.pShmNode;
    if (((pShmNode) == (null)))
        return (int)(10 | (20 &lt;&lt; 8));
    mask = ((ushort)((1U &lt;&lt; (ofst + n)) - (1U &lt;&lt; ofst)));
    sqlite3_mutex_enter(pShmNode.mutex);
    if ((flags &amp; 1) != 0)
    {
        ushort allMask = (ushort)(0);
        for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
        {
            if ((pX) == (p))
                continue;
            allMask |= (ushort)(pX.sharedMask);
        }

        if ((mask &amp; allMask) == (0))
        {
            rc = (int)(winShmSystemLock(pShmNode, (int)(1), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
        }
        else
        {
            rc = (int)(0);
        }

        if ((rc) == (0))
        {
            p.exclMask &amp;= (ushort)(~mask);
            p.sharedMask &amp;= (ushort)(~mask);
        }
    }
    else if ((flags &amp; 4) != 0)
    {
        ushort allShared = (ushort)(0);
        for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
        {
            if ((pX.exclMask &amp; mask) != 0)
            {
                rc = (int)(5);
                break;
            }

            allShared |= (ushort)(pX.sharedMask);
        }

        if ((rc) == (0))
        {
            if ((allShared &amp; mask) == (0))
            {
                rc = (int)(winShmSystemLock(pShmNode, (int)(2), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
            }
            else
            {
                rc = (int)(0);
            }
        }

        if ((rc) == (0))
        {
            p.sharedMask |= (ushort)(mask);
        }
    }
    else
    {
        for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
        {
            if (((pX.exclMask &amp; mask) != 0) || ((pX.sharedMask &amp; mask) != 0))
            {
                rc = (int)(5);
                break;
            }
        }

        if ((rc) == (0))
        {
            rc = (int)(winShmSystemLock(pShmNode, (int)(3), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
            if ((rc) == (0))
            {
                p.exclMask |= (ushort)(mask);
            }
        }
    }

    sqlite3_mutex_leave(pShmNode.mutex);
    return (int)(rc);
}</function>
  <function>public static int winShmMap(sqlite3_file fd, int iRegion, int szRegion, int isWrite, void** pp)
{
    winFile pDbFd = (winFile)(fd);
    winShm pShm = pDbFd.pShm;
    winShmNode pShmNode;
    uint protect = (uint)(0x04);
    uint flags = (uint)(0x0002 | 0x0004);
    int rc = (int)(0);
    if (pShm == null)
    {
        rc = (int)(winOpenSharedMemory(pDbFd));
        if (rc != 0)
            return (int)(rc);
        pShm = pDbFd.pShm;
    }

    pShmNode = pShm.pShmNode;
    sqlite3_mutex_enter(pShmNode.mutex);
    if ((pShmNode.isUnlocked) != 0)
    {
        rc = (int)(winLockSharedMemory(pShmNode));
        if (rc != 0)
            goto shmpage_out;
        pShmNode.isUnlocked = (byte)(0);
    }

    if ((pShmNode.nRegion) &lt;= (iRegion))
    {
        ShmRegion* apNew;
        int nByte = (int)((iRegion + 1) * szRegion);
        long sz = 0;
        pShmNode.szRegion = (int)(szRegion);
        rc = (int)(winFileSize((sqlite3_file)(pShmNode.hFile), &amp;sz));
        if (rc != 0)
        {
            rc = (int)(winLogErrorAtLine((int)(10 | (19 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winShmMap1", pDbFd.zPath, (int)(47175)));
            goto shmpage_out;
        }

        if ((sz) &lt; (nByte))
        {
            if (isWrite == 0)
                goto shmpage_out;
            rc = (int)(winTruncate((sqlite3_file)(pShmNode.hFile), (long)(nByte)));
            if (rc != 0)
            {
                rc = (int)(winLogErrorAtLine((int)(10 | (19 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winShmMap2", pDbFd.zPath, (int)(47190)));
                goto shmpage_out;
            }
        }

        apNew = (ShmRegion*)(sqlite3_realloc64(pShmNode.aRegion, (ulong)((iRegion + 1) * sizeof(ShmRegion))));
        if (apNew == null)
        {
            rc = (int)(10 | (12 &lt;&lt; 8));
            goto shmpage_out;
        }

        pShmNode.aRegion = apNew;
        if ((pShmNode.isReadonly) != 0)
        {
            protect = (uint)(0x02);
            flags = (uint)(0x0004);
        }

        while ((pShmNode.nRegion) &lt;= (iRegion))
        {
            void* hMap = null;
            void* pMap = null;
            hMap = (Void * (Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[7].pCurrent)(pShmNode.hFile.h, null, (uint)(protect), (uint)(0), (uint)(nByte), null);
            if ((hMap) != null)
            {
                int iOffset = (int)(pShmNode.nRegion * szRegion);
                int iOffsetShift = (int)(iOffset % winSysInfo.dwAllocationGranularity);
                pMap = (Void * (Void * , Void * , Void * , Void * , Void * ))(aSyscall[49].pCurrent)(hMap, (uint)(flags), (uint)(0), (uint)(iOffset - iOffsetShift), (ulong)(szRegion + iOffsetShift));
            }

            if (pMap == null)
            {
                pShmNode.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
                rc = (int)(winLogErrorAtLine((int)(10 | (21 &lt;&lt; 8)), (uint)(pShmNode.lastErrno), "winShmMap3", pDbFd.zPath, (int)(47249)));
                if ((hMap) != null)
                    (Int(Void * ))(aSyscall[3].pCurrent)(hMap);
                goto shmpage_out;
            }

            pShmNode.aRegion[pShmNode.nRegion].pMap = pMap;
            pShmNode.aRegion[pShmNode.nRegion].hMap = hMap;
            pShmNode.nRegion++;
        }
    }

    shmpage_out:
        ; if  ( ( pShmNode . nRegion ) &gt; ( iRegion ) ) { int  iOffset  =  ( int ) ( iRegion * szRegion ) ;  int  iOffsetShift  =  ( int ) ( iOffset % winSysInfo . dwAllocationGranularity ) ;  sbyte  * p  =  ( sbyte  * ) ( pShmNode . aRegion [ iRegion ] . pMap ) ;  * pp  =  ( void  * ) ( &amp; p [ iOffsetShift ] ) ;  } else  { * pp  =  null ;  }
    if (((pShmNode.isReadonly) != 0) &amp;&amp; ((rc) == (0)))
        rc = (int)(8);
    sqlite3_mutex_leave(pShmNode.mutex);
    return (int)(rc);
}</function>
  <function>public static void winShmPurge(sqlite3_vfs pVfs, int deleteFlag)
{
    winShmNode pp;
    winShmNode p;
    pp = winShmNodeList;
    while ((p = pp) != null)
    {
        if ((p.nRef) == (0))
        {
            int i = 0;
            if ((p.mutex) != null)
            {
                sqlite3_mutex_free(p.mutex);
            }

            for (i = (int)(0); (i) &lt; (p.nRegion); i++)
            {
                int bRc = (int)((Int(Void * ))(aSyscall[59].pCurrent)(p.aRegion[i].pMap));
                (void)(bRc);
                bRc = (int)((Int(Void * ))(aSyscall[3].pCurrent)(p.aRegion[i].hMap));
                (void)(bRc);
            }

            if ((p.hFile.h != null) &amp;&amp; (p.hFile.h != ((void*)((long)(-1)))))
            {
                winClose((sqlite3_file)(p.hFile));
            }

            if ((deleteFlag) != 0)
            {
                sqlite3BeginBenignMalloc();
                winDelete(pVfs, p.zFilename, (int)(0));
                sqlite3EndBenignMalloc();
            }

            pp = p.pNext;
            sqlite3_free(p.aRegion);
            sqlite3_free(p);
        }
        else
        {
            pp = p.pNext;
        }
    }
}</function>
  <function>public static int winShmSystemLock(winShmNode pFile, int lockType, int ofst, int nByte)
{
    int rc = (int)(0);
    if ((lockType) == (1))
    {
        rc = (int)(winUnlockFile(&amp;pFile.hFile.h, (uint)(ofst), (uint)(0), (uint)(nByte), (uint)(0)));
    }
    else
    {
        uint dwFlags = (uint)(0x00000001);
        if ((lockType) == (3))
            dwFlags |= (uint)(0x00000002);
        rc = (int)(winLockFile(&amp;pFile.hFile.h, (uint)(dwFlags), (uint)(ofst), (uint)(0), (uint)(nByte), (uint)(0)));
    }

    if (rc != 0)
    {
        rc = (int)(0);
    }
    else
    {
        pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
        rc = (int)(5);
    }

    return (int)(rc);
}</function>
  <function>public static int winShmUnmap(sqlite3_file fd, int deleteFlag)
{
    winFile pDbFd;
    winShm p;
    winShmNode pShmNode;
    winShm pp;
    pDbFd = (winFile)(fd);
    p = pDbFd.pShm;
    if ((p) == (null))
        return (int)(0);
    pShmNode = p.pShmNode;
    sqlite3_mutex_enter(pShmNode.mutex);
    for (pp = pShmNode.pFirst; (pp) != p; pp = (pp).pNext)
    {
    }

    pp = p.pNext;
    sqlite3_free(p);
    pDbFd.pShm = null;
    sqlite3_mutex_leave(pShmNode.mutex);
    winShmEnterMutex();
    pShmNode.nRef--;
    if ((pShmNode.nRef) == (0))
    {
        winShmPurge(pDbFd.pVfs, (int)(deleteFlag));
    }

    winShmLeaveMutex();
    return (int)(0);
}</function>
  <function>public static int winSleep(sqlite3_vfs pVfs, int microsec)
{
    sqlite3_win32_sleep((uint)((microsec + 999) / 1000));
    return (int)(((microsec + 999) / 1000) * 1000);
}</function>
  <function>public static int winSync(sqlite3_file id, int flags)
{
    int rc = 0;
    winFile pFile = (winFile)(id);
    if ((pFile.pMapRegion) != null)
    {
        if (((Int(Void * , Void * ))(aSyscall[79].pCurrent)(pFile.pMapRegion, (ulong)(0))) != 0)
        {
        }
        else
        {
            pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            return (int)(winLogErrorAtLine((int)(10 | (24 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winSync1", pFile.zPath, (int)(45979)));
        }
    }

    rc = (int)((Int(Void * ))(aSyscall[13].pCurrent)(pFile.h));
    if ((rc) != 0)
    {
        return (int)(0);
    }
    else
    {
        pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
        return (int)(winLogErrorAtLine((int)(10 | (4 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winSync2", pFile.zPath, (int)(45994)));
    }
}</function>
  <function>public static int winTruncate(sqlite3_file id, long nByte)
{
    winFile pFile = (winFile)(id);
    int rc = (int)(0);
    uint lastErrno = 0;
    long oldMmapSize = 0;
    if ((pFile.nFetchOut) &gt; (0))
    {
        return (int)(0);
    }

    if ((pFile.szChunk) &gt; (0))
    {
        nByte = (long)(((nByte + pFile.szChunk - 1) / pFile.szChunk) * pFile.szChunk);
    }

    if ((pFile.pMapRegion) != null)
    {
        oldMmapSize = (long)(pFile.mmapSize);
    }
    else
    {
        oldMmapSize = (long)(0);
    }

    winUnmapfile(pFile);
    if ((winSeekFile(pFile, (long)(nByte))) != 0)
    {
        rc = (int)(winLogErrorAtLine((int)(10 | (6 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winTruncate1", pFile.zPath, (int)(45882)));
    }
    else if (((0) == ((Int(Void * ))(aSyscall[53].pCurrent)(pFile.h))) &amp;&amp; ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 1224L))
    {
        pFile.lastErrno = (uint)(lastErrno);
        rc = (int)(winLogErrorAtLine((int)(10 | (6 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winTruncate2", pFile.zPath, (int)(45887)));
    }

    if (((rc) == (0)) &amp;&amp; ((oldMmapSize) &gt; (0)))
    {
        if ((oldMmapSize) &gt; (nByte))
        {
            winMapfile(pFile, (long)(-1));
        }
        else
        {
            winMapfile(pFile, (long)(oldMmapSize));
        }
    }

    return (int)(rc);
}</function>
  <function>public static int winUnfetch(sqlite3_file fd, long iOff, void* p)
{
    winFile pFd = (winFile)(fd);
    if ((p) != null)
    {
        pFd.nFetchOut--;
    }
    else
    {
        winUnmapfile(pFd);
    }

    return (int)(0);
}</function>
  <function>public static sbyte* winUnicodeToMbcs(ushort* zWideText, int useAnsi)
{
    int nByte = 0;
    sbyte* zText;
    int codepage = (int)((useAnsi) != 0 ? 0 : 1);
    nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(codepage), (uint)(0), zWideText, (int)(-1), null, (int)(0), null, null));
    if ((nByte) == (0))
    {
        return null;
    }

    zText = sqlite3MallocZero((ulong)(nByte));
    if ((zText) == (null))
    {
        return null;
    }

    nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(codepage), (uint)(0), zWideText, (int)(-1), zText, (int)(nByte), null, null));
    if ((nByte) == (0))
    {
        sqlite3_free(zText);
        zText = null;
    }

    return zText;
}</function>
  <function>public static sbyte* winUnicodeToUtf8(ushort* zWideText)
{
    int nByte = 0;
    sbyte* zText;
    nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(65001), (uint)(0), zWideText, (int)(-1), null, (int)(0), null, null));
    if ((nByte) == (0))
    {
        return null;
    }

    zText = sqlite3MallocZero((ulong)(nByte));
    if ((zText) == (null))
    {
        return null;
    }

    nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(65001), (uint)(0), zWideText, (int)(-1), zText, (int)(nByte), null, null));
    if ((nByte) == (0))
    {
        sqlite3_free(zText);
        zText = null;
    }

    return zText;
}</function>
  <function>public static int winUnlock(sqlite3_file id, int locktype)
{
    int type = 0;
    winFile pFile = (winFile)(id);
    int rc = (int)(0);
    type = (int)(pFile.locktype);
    if ((type) &gt;= (4))
    {
        winUnlockFile(&amp;pFile.h, (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0));
        if (((locktype) == (1)) &amp;&amp; (winGetReadLock(pFile) == 0))
        {
            rc = (int)(winLogErrorAtLine((int)(10 | (8 &lt;&lt; 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winUnlock", pFile.zPath, (int)(46356)));
        }
    }

    if ((type) &gt;= (2))
    {
        winUnlockFile(&amp;pFile.h, (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0));
    }

    if (((locktype) == (0)) &amp;&amp; ((type) &gt;= (1)))
    {
        winUnlockReadLock(pFile);
    }

    if ((type) &gt;= (3))
    {
        winUnlockFile(&amp;pFile.h, (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0));
    }

    pFile.locktype = ((byte)(locktype));
    return (int)(rc);
}</function>
  <function>public static int winUnlockFile(void** phFile, uint offsetLow, uint offsetHigh, uint numBytesLow, uint numBytesHigh)
{
    if ((1) != 0)
    {
        _OVERLAPPED ovlp = new _OVERLAPPED();
        CRuntime.memset(&amp;ovlp, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
        ovlp..Offset = (uint)(offsetLow);
        ovlp..OffsetHigh = (uint)(offsetHigh);
        return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[58].pCurrent)(*phFile, (uint)(0), (uint)(numBytesLow), (uint)(numBytesHigh), &amp;ovlp));
    }
    else
    {
        return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[57].pCurrent)(*phFile, (uint)(offsetLow), (uint)(offsetHigh), (uint)(numBytesLow), (uint)(numBytesHigh)));
    }
}</function>
  <function>public static int winUnlockReadLock(winFile pFile)
{
    int res = 0;
    uint lastErrno = 0;
    if ((1) != 0)
    {
        res = (int)(winUnlockFile(&amp;pFile.h, (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
    }
    else
    {
        res = (int)(winUnlockFile(&amp;pFile.h, (uint)((sqlite3PendingByte + 2) + pFile.sharedLockByte), (uint)(0), (uint)(1), (uint)(0)));
    }

    if (((res) == (0)) &amp;&amp; ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 158L))
    {
        pFile.lastErrno = (uint)(lastErrno);
        winLogErrorAtLine((int)(10 | (8 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winUnlockReadLock", pFile.zPath, (int)(46130));
    }

    return (int)(res);
}</function>
  <function>public static int winUnmapfile(winFile pFile)
{
    if ((pFile.pMapRegion) != null)
    {
        if ((Int(Void * ))(aSyscall[59].pCurrent)(pFile.pMapRegion) == 0)
        {
            pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            return (int)(winLogErrorAtLine((int)(10 | (24 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winUnmapfile1", pFile.zPath, (int)(47298)));
        }

        pFile.pMapRegion = null;
        pFile.mmapSize = (long)(0);
    }

    if (pFile.hMap != null)
    {
        if ((Int(Void * ))(aSyscall[3].pCurrent)(pFile.hMap) == 0)
        {
            pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
            return (int)(winLogErrorAtLine((int)(10 | (24 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winUnmapfile2", pFile.zPath, (int)(47309)));
        }

        pFile.hMap = null;
    }

    return (int)(0);
}</function>
  <function>public static sbyte* winUtf8ToMbcs(sbyte* zText, int useAnsi)
{
    sbyte* zTextMbcs;
    ushort* zTmpWide;
    zTmpWide = winUtf8ToUnicode(zText);
    if ((zTmpWide) == (null))
    {
        return null;
    }

    zTextMbcs = winUnicodeToMbcs(zTmpWide, (int)(useAnsi));
    sqlite3_free(zTmpWide);
    return zTextMbcs;
}</function>
  <function>public static ushort* winUtf8ToUnicode(sbyte* zText)
{
    int nChar = 0;
    ushort* zWideText;
    nChar = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(65001), (uint)(0), zText, (int)(-1), null, (int)(0)));
    if ((nChar) == (0))
    {
        return null;
    }

    zWideText = sqlite3MallocZero((ulong)(nChar * sizeof(ushort)));
    if ((zWideText) == (null))
    {
        return null;
    }

    nChar = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(65001), (uint)(0), zText, (int)(-1), zWideText, (int)(nChar)));
    if ((nChar) == (0))
    {
        sqlite3_free(zWideText);
        zWideText = null;
    }

    return zWideText;
}</function>
  <function>public static int winWrite(sqlite3_file id, void* pBuf, int amt, long offset)
{
    int rc = (int)(0);
    winFile pFile = (winFile)(id);
    int nRetry = (int)(0);
    {
        _OVERLAPPED overlapped = new _OVERLAPPED();
        byte* aRem = (byte*)(pBuf);
        int nRem = (int)(amt);
        uint nWrite = 0;
        uint lastErrno = (uint)(0L);
        CRuntime.memset(&amp;overlapped, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
        overlapped..Offset = (uint)((int)(offset &amp; 0xffffffff));
        overlapped..OffsetHigh = (uint)((int)((offset &gt;&gt; 32) &amp; 0x7fffffff));
        while ((nRem) &gt; (0))
        {
            if ((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[61].pCurrent)(pFile.h, aRem, (uint)(nRem), &amp;nWrite, &amp;overlapped) == 0)
            {
                if ((winRetryIoerr(&amp;nRetry, &amp;lastErrno)) != 0)
                    continue;
                break;
            }

            if (((nWrite) == (0)) || ((nWrite) &gt; ((uint)(nRem))))
            {
                lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
                break;
            }

            offset += (long)(nWrite);
            overlapped..Offset = (uint)((int)(offset &amp; 0xffffffff));
            overlapped..OffsetHigh = (uint)((int)((offset &gt;&gt; 32) &amp; 0x7fffffff));
            aRem += nWrite;
            nRem -= (int)(nWrite);
        }

        if ((nRem) &gt; (0))
        {
            pFile.lastErrno = (uint)(lastErrno);
            rc = (int)(1);
        }
    }

    if ((rc) != 0)
    {
        if (((pFile.lastErrno) == (39L)) || ((pFile.lastErrno) == (112L)))
        {
            return (int)(winLogErrorAtLine((int)(13), (uint)(pFile.lastErrno), "winWrite1", pFile.zPath, (int)(45811)));
        }

        return (int)(winLogErrorAtLine((int)(10 | (3 &lt;&lt; 8)), (uint)(pFile.lastErrno), "winWrite2", pFile.zPath, (int)(45816)));
    }
    else
    {
        winLogIoerr((int)(nRetry), (int)(45818));
    }

    return (int)(0);
}</function>
  <function>public static int write32bits(sqlite3_file fd, long offset, uint val)
{
    sbyte* ac = stackalloc sbyte[4];
    sqlite3Put4byte((byte*)(ac), (uint)(val));
    return (int)(sqlite3OsWrite(fd, ac, (int)(4), (long)(offset)));
}</function>
  <function>public static int writeJournalHdr(Pager pPager)
{
    int rc = (int)(0);
    sbyte* zHeader = pPager.pTmpSpace;
    uint nHeader = (uint)(pPager.pageSize);
    uint nWrite = 0;
    int ii = 0;
    if ((nHeader) &gt; (pPager.sectorSize))
    {
        nHeader = (uint)(pPager.sectorSize);
    }

    for (ii = (int)(0); (ii) &lt; (pPager.nSavepoint); ii++)
    {
        if ((pPager.aSavepoint[ii].iHdrOffset) == (0))
        {
            pPager.aSavepoint[ii].iHdrOffset = (long)(pPager.journalOff);
        }
    }

    pPager.journalHdr = (long)(pPager.journalOff = (long)(journalHdrOffset(pPager)));
    if ((((pPager.noSync) != 0) || ((pPager.journalMode) == (4))) || ((sqlite3OsDeviceCharacteristics(pPager.fd) &amp; 0x00000200) != 0))
    {
        CRuntime.memcpy(zHeader, aJournalMagic, (ulong)(8 * sizeof(byte)));
        sqlite3Put4byte((byte*)(&amp;zHeader[8 * sizeof(byte)]), (uint)(0xffffffff));
    }
    else
    {
        CRuntime.memset(zHeader, (int)(0), (ulong)(8 * sizeof(byte) + 4));
    }

    sqlite3_randomness((int)(sizeof(uint)), &amp;pPager.cksumInit);
    sqlite3Put4byte((byte*)(&amp;zHeader[8 * sizeof(byte) + 4]), (uint)(pPager.cksumInit));
    sqlite3Put4byte((byte*)(&amp;zHeader[8 * sizeof(byte) + 8]), (uint)(pPager.dbOrigSize));
    sqlite3Put4byte((byte*)(&amp;zHeader[8 * sizeof(byte) + 12]), (uint)(pPager.sectorSize));
    sqlite3Put4byte((byte*)(&amp;zHeader[8 * sizeof(byte) + 16]), (uint)(pPager.pageSize));
    CRuntime.memset(&amp;zHeader[8 * sizeof(byte) + 20], (int)(0), (ulong)(nHeader - (8 * sizeof(byte) + 20)));
    for (nWrite = (uint)(0); ((rc) == (0)) &amp;&amp; ((nWrite) &lt; (pPager.sectorSize)); nWrite += (uint)(nHeader))
    {
        rc = (int)(sqlite3OsWrite(pPager.jfd, zHeader, (int)(nHeader), (long)(pPager.journalOff)));
        pPager.journalOff += (long)(nHeader);
    }

    return (int)(rc);
}</function>
  <function>public static int writeSuperJournal(Pager pPager, sbyte* zSuper)
{
    int rc = 0;
    int nSuper = 0;
    long iHdrOff = 0;
    long jrnlSize = 0;
    uint cksum = (uint)(0);
    if (((zSuper == null) || ((pPager.journalMode) == (4))) || (!((pPager.jfd).pMethods != null)))
    {
        return (int)(0);
    }

    pPager.setSuper = (byte)(1);
    for (nSuper = (int)(0); zSuper[nSuper]; nSuper++)
    {
        cksum += (uint)(zSuper[nSuper]);
    }

    if ((pPager.fullSync) != 0)
    {
        pPager.journalOff = (long)(journalHdrOffset(pPager));
    }

    iHdrOff = (long)(pPager.journalOff);
    if (((((0 != (rc = (int)(write32bits(pPager.jfd, (long)(iHdrOff), ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1)))))) || (0 != (rc = (int)(sqlite3OsWrite(pPager.jfd, zSuper, (int)(nSuper), (long)(iHdrOff + 4)))))) || (0 != (rc = (int)(write32bits(pPager.jfd, (long)(iHdrOff + 4 + nSuper), (uint)(nSuper)))))) || (0 != (rc = (int)(write32bits(pPager.jfd, (long)(iHdrOff + 4 + nSuper + 4), (uint)(cksum)))))) || (0 != (rc = (int)(sqlite3OsWrite(pPager.jfd, aJournalMagic, (int)(8), (long)(iHdrOff + 4 + nSuper + 8))))))
    {
        return (int)(rc);
    }

    pPager.journalOff += (long)(nSuper + 20);
    if (((0) == (rc = (int)(sqlite3OsFileSize(pPager.jfd, &amp;jrnlSize)))) &amp;&amp; ((jrnlSize) &gt; (pPager.journalOff)))
    {
        rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(pPager.journalOff)));
    }

    return (int)(rc);
}</function>
  <function>public static int xferCompatibleIndex(Index pDest, Index pSrc)
{
    int i = 0;
    if ((pDest.nKeyCol != pSrc.nKeyCol) || (pDest.nColumn != pSrc.nColumn))
    {
        return (int)(0);
    }

    if (pDest.onError != pSrc.onError)
    {
        return (int)(0);
    }

    for (i = (int)(0); (i) &lt; (pSrc.nKeyCol); i++)
    {
        if (pSrc.aiColumn[i] != pDest.aiColumn[i])
        {
            return (int)(0);
        }

        if ((pSrc.aiColumn[i]) == (-2))
        {
            if (sqlite3ExprCompare(null, pSrc.aColExpr.a[i].pExpr, pDest.aColExpr.a[i].pExpr, (int)(-1)) != 0)
            {
                return (int)(0);
            }
        }

        if (pSrc.aSortOrder[i] != pDest.aSortOrder[i])
        {
            return (int)(0);
        }

        if (sqlite3_stricmp(pSrc.azColl[i], pDest.azColl[i]) != 0)
        {
            return (int)(0);
        }
    }

    if ((sqlite3ExprCompare(null, pSrc.pPartIdxWhere, pDest.pPartIdxWhere, (int)(-1))) != 0)
    {
        return (int)(0);
    }

    return (int)(1);
}</function>
  <function>public static int xferOptimization(Parse pParse, Table pDest, Select pSelect, int onError, int iDbDest)
{
    sqlite3 db = pParse.db;
    ExprList pEList;
    Table pSrc;
    Index pSrcIdx; Index  pDestIdx ; 
    SrcItem pItem;
    int i = 0;
    int iDbSrc = 0;
    int iSrc = 0; int  iDest  =  0 ; 
    int addr1 = 0; int  addr2  =  0 ; 
    int emptyDestTest = (int)(0);
    int emptySrcTest = (int)(0);
    Vdbe v;
    int regAutoinc = 0;
    int destHasUniqueIdx = (int)(0);
    int regData = 0; int  regRowid  =  0 ; 
    if (((pParse.pWith) != null) || ((pSelect.pWith) != null))
    {
        return (int)(0);
    }

    if ((((pDest).eTabType) == (1)))
    {
        return (int)(0);
    }

    if ((onError) == (11))
    {
        if ((pDest.iPKey) &gt;= (0))
            onError = (int)(pDest.keyConf);
        if ((onError) == (11))
            onError = (int)(2);
    }

    if (pSelect.pSrc.nSrc != 1)
    {
        return (int)(0);
    }

    if ((pSelect.pSrc.a[0].pSelect) != null)
    {
        return (int)(0);
    }

    if ((pSelect.pWhere) != null)
    {
        return (int)(0);
    }

    if ((pSelect.pOrderBy) != null)
    {
        return (int)(0);
    }

    if ((pSelect.pGroupBy) != null)
    {
        return (int)(0);
    }

    if ((pSelect.pLimit) != null)
    {
        return (int)(0);
    }

    if ((pSelect.pPrior) != null)
    {
        return (int)(0);
    }

    if ((pSelect.selFlags &amp; 0x0000001) != 0)
    {
        return (int)(0);
    }

    pEList = pSelect.pEList;
    if (pEList.nExpr != 1)
    {
        return (int)(0);
    }

    if (pEList.a[0].pExpr.op != 180)
    {
        return (int)(0);
    }

    pItem = pSelect.pSrc.a;
    pSrc = sqlite3LocateTableItem(pParse, (uint)(0), pItem);
    if ((pSrc) == (null))
    {
        return (int)(0);
    }

    if (((pSrc.tnum) == (pDest.tnum)) &amp;&amp; ((pSrc.pSchema) == (pDest.pSchema)))
    {
        return (int)(0);
    }

    if ((((pDest).tabFlags &amp; 0x00000080) == (0)) != (((pSrc).tabFlags &amp; 0x00000080) == (0)))
    {
        return (int)(0);
    }

    if (!(((pSrc).eTabType) == (0)))
    {
        return (int)(0);
    }

    if (pDest.nCol != pSrc.nCol)
    {
        return (int)(0);
    }

    if (pDest.iPKey != pSrc.iPKey)
    {
        return (int)(0);
    }

    if (((pDest.tabFlags &amp; 0x00010000) != 0) &amp;&amp; ((pSrc.tabFlags &amp; 0x00010000) == (0)))
    {
        return (int)(0);
    }

    for (i = (int)(0); (i) &lt; (pDest.nCol); i++)
    {
        Column* pDestCol = &amp;pDest.aCol[i];
        Column* pSrcCol = &amp;pSrc.aCol[i];
        if ((pDestCol-&gt;colFlags &amp; 0x0060) != (pSrcCol-&gt;colFlags &amp; 0x0060))
        {
            return (int)(0);
        }

        if ((pDestCol-&gt;colFlags &amp; 0x0060) != 0)
        {
            if (sqlite3ExprCompare(null, sqlite3ColumnExpr(pSrc, pSrcCol), sqlite3ColumnExpr(pDest, pDestCol), (int)(-1)) != 0)
            {
                return (int)(0);
            }
        }

        if (pDestCol-&gt;affinity != pSrcCol-&gt;affinity)
        {
            return (int)(0);
        }

        if (sqlite3_stricmp(sqlite3ColumnColl(pDestCol), sqlite3ColumnColl(pSrcCol)) != 0)
        {
            return (int)(0);
        }

        if (((pDestCol-&gt;notNull) != 0) &amp;&amp; (pSrcCol-&gt;notNull == 0))
        {
            return (int)(0);
        }

        if (((pDestCol-&gt;colFlags &amp; 0x0060) == (0)) &amp;&amp; ((i) &gt; (0)))
        {
            Expr pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);
            Expr pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);
            if ((((pDestExpr) == (null)) != ((pSrcExpr) == (null))) || ((pDestExpr != null) &amp;&amp; (CRuntime.strcmp(pDestExpr.u.zToken, pSrcExpr.u.zToken) != 0)))
            {
                return (int)(0);
            }
        }
    }

    for (pDestIdx = pDest.pIndex; pDestIdx; pDestIdx = pDestIdx.pNext)
    {
        if (((pDestIdx).onError != 0))
        {
            destHasUniqueIdx = (int)(1);
        }

        for (pSrcIdx = pSrc.pIndex; pSrcIdx; pSrcIdx = pSrcIdx.pNext)
        {
            if ((xferCompatibleIndex(pDestIdx, pSrcIdx)) != 0)
                break;
        }

        if ((pSrcIdx) == (null))
        {
            return (int)(0);
        }

        if ((((pSrcIdx.tnum) == (pDestIdx.tnum)) &amp;&amp; ((pSrc.pSchema) == (pDest.pSchema))) &amp;&amp; ((sqlite3FaultSim((int)(411))) == (0)))
        {
            return (int)(0);
        }
    }

    if (((pDest.pCheck) != null) &amp;&amp; ((sqlite3ExprListCompare(pSrc.pCheck, pDest.pCheck, (int)(-1))) != 0))
    {
        return (int)(0);
    }

    if (((db.flags &amp; 0x00004000) != 0) &amp;&amp; (pDest.u.tab.pFKey != null))
    {
        return (int)(0);
    }

    if ((db.flags &amp; ((ulong)(0x00001) &lt;&lt; 32)) != 0)
    {
        return (int)(0);
    }

    iDbSrc = (int)(sqlite3SchemaToIndex(db, pSrc.pSchema));
    v = sqlite3GetVdbe(pParse);
    sqlite3CodeVerifySchema(pParse, (int)(iDbSrc));
    iSrc = (int)(pParse.nTab++);
    iDest = (int)(pParse.nTab++);
    regAutoinc = (int)(autoIncBegin(pParse, (int)(iDbDest), pDest));
    regData = (int)(sqlite3GetTempReg(pParse));
    sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regData));
    regRowid = (int)(sqlite3GetTempReg(pParse));
    sqlite3OpenTable(pParse, (int)(iDest), (int)(iDbDest), pDest, (int)(112));
    if (((db.mDbFlags &amp; 0x0004) == (0)) &amp;&amp; (((((pDest.iPKey) &lt; (0)) &amp;&amp; (pDest.pIndex != null)) || ((destHasUniqueIdx) != 0)) || ((onError != 2) &amp;&amp; (onError != 1))))
    {
        addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iDest), (int)(0)));
        emptyDestTest = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
        sqlite3VdbeJumpHere(v, (int)(addr1));
    }

    if ((((pSrc).tabFlags &amp; 0x00000080) == (0)))
    {
        byte insFlags = 0;
        sqlite3OpenTable(pParse, (int)(iSrc), (int)(iDbSrc), pSrc, (int)(101));
        emptySrcTest = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iSrc), (int)(0)));
        if ((pDest.iPKey) &gt;= (0))
        {
            addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iSrc), (int)(regRowid)));
            if ((db.mDbFlags &amp; 0x0004) == (0))
            {
                addr2 = (int)(sqlite3VdbeAddOp3(v, (int)(33), (int)(iDest), (int)(0), (int)(regRowid)));
                sqlite3RowidConstraint(pParse, (int)(onError), pDest);
                sqlite3VdbeJumpHere(v, (int)(addr2));
            }

            autoIncStep(pParse, (int)(regAutoinc), (int)(regRowid));
        }
        else if (((pDest.pIndex) == (null)) &amp;&amp; ((db.mDbFlags &amp; 0x0008) == 0))
        {
            addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(126), (int)(iDest), (int)(regRowid)));
        }
        else
        {
            addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iSrc), (int)(regRowid)));
        }

        if ((db.mDbFlags &amp; 0x0004) != 0)
        {
            sqlite3VdbeAddOp1(v, (int)(136), (int)(iDest));
            insFlags = (byte)(0x08 | 0x10 | 0x80);
        }
        else
        {
            insFlags = (byte)(0x01 | 0x20 | 0x08 | 0x80);
        }

        {
            sqlite3VdbeAddOp3(v, (int)(128), (int)(iDest), (int)(iSrc), (int)(regRowid));
        }

        sqlite3VdbeAddOp3(v, (int)(127), (int)(iDest), (int)(regData), (int)(regRowid));
        if ((db.mDbFlags &amp; 0x0004) == (0))
        {
            sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pDest), (int)(-6));
        }

        sqlite3VdbeChangeP5(v, (ushort)(insFlags));
        sqlite3VdbeAddOp2(v, (int)(5), (int)(iSrc), (int)(addr1));
        sqlite3VdbeAddOp2(v, (int)(121), (int)(iSrc), (int)(0));
        sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
    }
    else
    {
        sqlite3TableLock(pParse, (int)(iDbDest), (uint)(pDest.tnum), (byte)(1), pDest.zName);
        sqlite3TableLock(pParse, (int)(iDbSrc), (uint)(pSrc.tnum), (byte)(0), pSrc.zName);
    }

    for (pDestIdx = pDest.pIndex; pDestIdx; pDestIdx = pDestIdx.pNext)
    {
        byte idxInsFlags = (byte)(0);
        for (pSrcIdx = pSrc.pIndex; (pSrcIdx); pSrcIdx = pSrcIdx.pNext)
        {
            if ((xferCompatibleIndex(pDestIdx, pSrcIdx)) != 0)
                break;
        }

        sqlite3VdbeAddOp3(v, (int)(101), (int)(iSrc), (int)(pSrcIdx.tnum), (int)(iDbSrc));
        sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
        sqlite3VdbeAddOp3(v, (int)(112), (int)(iDest), (int)(pDestIdx.tnum), (int)(iDbDest));
        sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
        sqlite3VdbeChangeP5(v, (ushort)(0x01));
        addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iSrc), (int)(0)));
        if ((db.mDbFlags &amp; 0x0004) != 0)
        {
            for (i = (int)(0); (i) &lt; (pSrcIdx.nColumn); i++)
            {
                sbyte* zColl = pSrcIdx.azColl[i];
                if ((sqlite3_stricmp(sqlite3StrBINARY, zColl)) != 0)
                    break;
            }

            if ((i) == (pSrcIdx.nColumn))
            {
                idxInsFlags = (byte)(0x10 | 0x80);
                sqlite3VdbeAddOp1(v, (int)(136), (int)(iDest));
                sqlite3VdbeAddOp2(v, (int)(128), (int)(iDest), (int)(iSrc));
            }
        }
        else if ((!(((pSrc).tabFlags &amp; 0x00000080) == (0))) &amp;&amp; ((pDestIdx.idxType) == (2)))
        {
            idxInsFlags |= (byte)(0x01);
        }

        if (idxInsFlags != (0x10 | 0x80))
        {
            sqlite3VdbeAddOp3(v, (int)(133), (int)(iSrc), (int)(regData), (int)(1));
            if ((((db.mDbFlags &amp; 0x0004) == (0)) &amp;&amp; (!(((pDest).tabFlags &amp; 0x00000080) == (0)))) &amp;&amp; (((pDestIdx).idxType) == (2)))
            {
            }
        }

        sqlite3VdbeAddOp2(v, (int)(137), (int)(iDest), (int)(regData));
        sqlite3VdbeChangeP5(v, (ushort)(idxInsFlags | 0x08));
        sqlite3VdbeAddOp2(v, (int)(5), (int)(iSrc), (int)(addr1 + 1));
        sqlite3VdbeJumpHere(v, (int)(addr1));
        sqlite3VdbeAddOp2(v, (int)(121), (int)(iSrc), (int)(0));
        sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
    }

    if ((emptySrcTest) != 0)
        sqlite3VdbeJumpHere(v, (int)(emptySrcTest));
    sqlite3ReleaseTempReg(pParse, (int)(regRowid));
    sqlite3ReleaseTempReg(pParse, (int)(regData));
    if ((emptyDestTest) != 0)
    {
        sqlite3AutoincrementEnd(pParse);
        sqlite3VdbeAddOp2(v, (int)(70), (int)(0), (int)(0));
        sqlite3VdbeJumpHere(v, (int)(emptyDestTest));
        sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
        return (int)(0);
    }
    else
    {
        return (int)(1);
    }
}</function>
  <function>public static void xorMemory(EntropyGatherer* p, byte* x, int sz)
{
    int j = 0; int  k  =  0 ; 
    for (j = (int)(0), k = (int)(p-&gt;i); (j) &lt; (sz); j++)
    {
        p-&gt;a[k++] ^= (byte)(x[j]);
        if ((k) &gt;= (p-&gt;na))
            k = (int)(0);
    }

    p-&gt;i = (int)(k);
    p-&gt;nXor += (int)(sz);
}</function>
  <function>public static void yy_accept(yyParser yypParser)
{
    Parse pParse = yypParser.pParse;
    yypParser.pParse = pParse;
}</function>
  <function>public static void yy_destructor(yyParser yypParser, ushort yymajor, YYMINORTYPE* yypminor)
{
    Parse pParse = yypParser.pParse;
    switch (yymajor)
    {
        case 204:
        case 239:
        case 240:
        case 252:
        {
            sqlite3SelectDelete(pParse.db, (yypminor-&gt;yy47));
        }

            break;
        case 216:
        case 217:
        case 246:
        case 248:
        case 260:
        case 267:
        case 278:
        case 280:
        case 283:
        case 290:
        case 295:
        case 311:
        {
            sqlite3ExprDelete(pParse.db, (yypminor-&gt;yy528));
        }

            break;
        case 221:
        case 231:
        case 232:
        case 244:
        case 247:
        case 249:
        case 253:
        case 254:
        case 262:
        case 268:
        case 277:
        case 279:
        case 310:
        {
            sqlite3ExprListDelete(pParse.db, (yypminor-&gt;yy322));
        }

            break;
        case 238:
        case 245:
        case 256:
        case 257:
        case 263:
        {
            sqlite3SrcListDelete(pParse.db, (yypminor-&gt;yy131));
        }

            break;
        case 241:
        {
            sqlite3WithDelete(pParse.db, (yypminor-&gt;yy521));
        }

            break;
        case 251:
        case 306:
        {
            sqlite3WindowListDelete(pParse.db, (yypminor-&gt;yy41));
        }

            break;
        case 261:
        case 264:
        case 270:
        {
            sqlite3IdListDelete(pParse.db, (yypminor-&gt;yy254));
        }

            break;
        case 273:
        case 307:
        case 308:
        case 309:
        case 312:
        {
            sqlite3WindowDelete(pParse.db, (yypminor-&gt;yy41));
        }

            break;
        case 286:
        case 291:
        {
            sqlite3DeleteTriggerStep(pParse.db, (yypminor-&gt;yy33));
        }

            break;
        case 288:
        {
            sqlite3IdListDelete(pParse.db, (yypminor-&gt;yy180).b);
        }

            break;
        case 314:
        case 315:
        case 316:
        {
            sqlite3ExprDelete(pParse.db, (yypminor-&gt;yy595).pExpr);
        }

            break;
        default:
            break;
    }
}</function>
  <function>public static ushort yy_find_reduce_action(ushort stateno, ushort iLookAhead)
{
    int i = 0;
    i = (int)(yy_reduce_ofst[stateno]);
    i += (int)(iLookAhead);
    return (ushort)(yy_action[i]);
}</function>
  <function>public static ushort yy_find_shift_action(ushort iLookAhead, ushort stateno)
{
    int i = 0;
    if ((stateno) &gt; (573))
        return (ushort)(stateno);
    do
    {
        i = (int)(yy_shift_ofst[stateno]);
        i += (int)(iLookAhead);
        if (yy_lookahead[i] != iLookAhead)
        {
            ushort iFallback = 0;
            iFallback = (ushort)(yyFallback[iLookAhead]);
            if (iFallback != 0)
            {
                iLookAhead = (ushort)(iFallback);
                continue;
            }

            {
                int j = (int)(i - iLookAhead + 101);
                if (((yy_lookahead[j]) == (101)) &amp;&amp; ((iLookAhead) &gt; (0)))
                {
                    return (ushort)(yy_action[j]);
                }
            }

            return (ushort)(yy_default[stateno]);
        }
        else
        {
            return (ushort)(yy_action[i]);
        }
    }
    while ((1) != 0);
}</function>
  <function>public static void yy_pop_parser_stack(yyParser pParser)
{
    yyStackEntry* yytos;
    yytos = pParser.yytos--;
    yy_destructor(pParser, (ushort)(yytos-&gt;major), &amp;yytos-&gt;minor);
}</function>
  <function>public static ushort yy_reduce(yyParser yypParser, uint yyruleno, int yyLookahead, Token yyLookaheadToken, Parse pParse)
{
    int yygoto = 0;
    ushort yyact = 0;
    yyStackEntry* yymsp;
    int yysize = 0;
    (void)(yyLookahead);
    (void)(yyLookaheadToken);
    yymsp = yypParser.yytos;
    switch (yyruleno)
    {
     YYMINORTYPE  yylhsminor  =  new  YYMINORTYPE ( ) ;  case  0 :  { pParse . explain  =  ( byte ) ( 1 ) ;  } break ;  case  1 :  { pParse . explain  =  ( byte ) ( 2 ) ;  } break ;  case  2 :  { sqlite3FinishCoding ( pParse ) ;  } break ;  case  3 :  { sqlite3BeginTransaction ( pParse ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  } break ;  case  4 :  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( 7 ) ;  } break ;  case  5 :  case  6 :  ;  case  7 :  ;  case  321 :  ;  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( yymsp [ 0 ] . major ) ;  } break ;  case  8 :  case  9 :  ;  { sqlite3EndTransaction ( pParse ,  ( int ) ( yymsp [ - 1 ] . major ) ) ;  } break ;  case  10 :  { sqlite3Savepoint ( pParse ,  ( int ) ( 0 ) ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  11 :  { sqlite3Savepoint ( pParse ,  ( int ) ( 1 ) ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  12 :  { sqlite3Savepoint ( pParse ,  ( int ) ( 2 ) ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  13 :  { sqlite3StartTable ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( yymsp [ - 4 ] . minor . yy394 ) ,  ( int ) ( 0 ) ,  ( int ) ( 0 ) ,  ( int ) ( yymsp [ - 2 ] . minor . yy394 ) ) ;  } break ;  case  14 :  { disableLookaside ( pParse ) ;  } break ;  case  15 :  case  18 :  ;  case  47 :  ;  case  62 :  ;  case  72 :  ;  case  81 :  ;  case  98 :  ;  case  242 :  ;  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  16 :  { yymsp [ - 2 ] . minor . yy394  =  ( int ) ( 1 ) ;  } break ;  case  17 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( ( pParse . db . init . busy ) == ( 0 ) ? 1 :  0 ) ;  } break ;  case  19 :  { sqlite3EndTable ( pParse ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( uint ) ( yymsp [ 0 ] . minor . yy285 ) ,  null ) ;  } break ;  case  20 :  { sqlite3EndTable ( pParse ,  null ,  null ,  ( uint ) ( 0 ) ,  yymsp [ 0 ] . minor . yy47 ) ;  sqlite3SelectDelete ( pParse . db ,  yymsp [ 0 ] . minor . yy47 ) ;  } break ;  case  21 :  { yymsp [ 1 ] . minor . yy285  =  ( uint ) ( 0 ) ;  } break ;  case  22 :  { yylhsminor . yy285  =  ( uint ) ( yymsp [ - 2 ] . minor . yy285 | yymsp [ 0 ] . minor . yy285 ) ;  } yymsp [ - 2 ] . minor . yy285  =  ( uint ) ( yylhsminor . yy285 ) ;  break ;  case  23 :  { if  ( ( ( yymsp [ 0 ] . minor . yy0 . n ) == ( 5 ) ) &amp;&amp; ( ( sqlite3_strnicmp ( yymsp [ 0 ] . minor . yy0 . z ,  "rowid" ,  ( int ) ( 5 ) ) ) == ( 0 ) ) ) { yymsp [ - 1 ] . minor . yy285  =  ( uint ) ( 0x00000080 | 0x00000200 ) ;  } else  { yymsp [ - 1 ] . minor . yy285  =  ( uint ) ( 0 ) ;  sqlite3ErrorMsg ( pParse ,  "unknown table option: %.*s" ,  ( uint ) ( yymsp [ 0 ] . minor . yy0 . n ) ,  yymsp [ 0 ] . minor . yy0 . z ) ;  } } break ;  case  24 :  { if  ( ( ( yymsp [ 0 ] . minor . yy0 . n ) == ( 6 ) ) &amp;&amp; ( ( sqlite3_strnicmp ( yymsp [ 0 ] . minor . yy0 . z ,  "strict" ,  ( int ) ( 6 ) ) ) == ( 0 ) ) ) { yylhsminor . yy285  =  ( uint ) ( 0x00010000 ) ;  } else  { yylhsminor . yy285  =  ( uint ) ( 0 ) ;  sqlite3ErrorMsg ( pParse ,  "unknown table option: %.*s" ,  ( uint ) ( yymsp [ 0 ] . minor . yy0 . n ) ,  yymsp [ 0 ] . minor . yy0 . z ) ;  } } yymsp [ 0 ] . minor . yy285  =  ( uint ) ( yylhsminor . yy285 ) ;  break ;  case  25 :  { sqlite3AddColumn ( pParse ,  ( Token ) ( yymsp [ - 1 ] . minor . yy0 ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  } break ;  case  26 :  case  65 :  ;  case  104 :  ;  { yymsp [ 1 ] . minor . yy0 . n  =  ( uint ) ( 0 ) ;  yymsp [ 1 ] . minor . yy0 . z  =  null ;  } break ;  case  27 :  { yymsp [ - 3 ] . minor . yy0 . n  =  ( uint ) ( ( int ) ( &amp; yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] - yymsp [ - 3 ] . minor . yy0 . z ) ) ;  } break ;  case  28 :  { yymsp [ - 5 ] . minor . yy0 . n  =  ( uint ) ( ( int ) ( &amp; yymsp [ 0 ] . minor . yy0 . z [ yymsp [ 0 ] . minor . yy0 . n ] - yymsp [ - 5 ] . minor . yy0 . z ) ) ;  } break ;  case  29 :  { yymsp [ - 1 ] . minor . yy0 . n  =  ( uint ) ( yymsp [ 0 ] . minor . yy0 . n + ( int ) ( yymsp [ 0 ] . minor . yy0 . z - yymsp [ - 1 ] . minor . yy0 . z ) ) ;  } break ;  case  30 :  { yymsp [ 1 ] . minor . yy522  =  yyLookaheadToken . z ;  } break ;  case  31 :  { yymsp [ 1 ] . minor . yy0  =  ( Token ) ( yyLookaheadToken ) ;  } break ;  case  32 :  case  67 :  ;  { pParse . constraintName  =  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  33 :  { sqlite3AddDefaultValue ( pParse ,  yymsp [ 0 ] . minor . yy528 ,  yymsp [ - 1 ] . minor . yy0 . z ,  &amp; yymsp [ - 1 ] . minor . yy0 . z [ yymsp [ - 1 ] . minor . yy0 . n ] ) ;  } break ;  case  34 :  { sqlite3AddDefaultValue ( pParse ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ - 2 ] . minor . yy0 . z + 1 ,  yymsp [ 0 ] . minor . yy0 . z ) ;  } break ;  case  35 :  { sqlite3AddDefaultValue ( pParse ,  yymsp [ 0 ] . minor . yy528 ,  yymsp [ - 2 ] . minor . yy0 . z ,  &amp; yymsp [ - 1 ] . minor . yy0 . z [ yymsp [ - 1 ] . minor . yy0 . n ] ) ;  } break ;  case  36 :  { Expr  p  =  sqlite3PExpr ( pParse ,  ( int ) ( 173 ) ,  yymsp [ 0 ] . minor . yy528 ,  null ) ;  sqlite3AddDefaultValue ( pParse ,  p ,  yymsp [ - 2 ] . minor . yy0 . z ,  &amp; yymsp [ - 1 ] . minor . yy0 . z [ yymsp [ - 1 ] . minor . yy0 . n ] ) ;  } break ;  case  37 :  { Expr  p  =  tokenExpr ( pParse ,  ( int ) ( 117 ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  if  ( ( p ) != null ) { sqlite3ExprIdToTrueFalse ( p ) ;  } sqlite3AddDefaultValue ( pParse ,  p ,  yymsp [ 0 ] . minor . yy0 . z ,  yymsp [ 0 ] . minor . yy0 . z + yymsp [ 0 ] . minor . yy0 . n ) ;  } break ;  case  38 :  { sqlite3AddNotNull ( pParse ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  39 :  { sqlite3AddPrimaryKey ( pParse ,  null ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 2 ] . minor . yy394 ) ) ;  } break ;  case  40 :  { sqlite3CreateIndex ( pParse ,  null ,  null ,  null ,  null ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ,  null ,  null ,  ( int ) ( 0 ) ,  ( int ) ( 0 ) ,  ( byte ) ( 1 ) ) ;  } break ;  case  41 :  { sqlite3AddCheckConstraint ( pParse ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ - 2 ] . minor . yy0 . z ,  yymsp [ 0 ] . minor . yy0 . z ) ;  } break ;  case  42 :  { sqlite3CreateForeignKey ( pParse ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  yymsp [ - 1 ] . minor . yy322 ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  43 :  { sqlite3DeferForeignKey ( pParse ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  44 :  { sqlite3AddCollateType ( pParse ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  45 :  { sqlite3AddGenerated ( pParse ,  yymsp [ - 1 ] . minor . yy528 ,  null ) ;  } break ;  case  46 :  { sqlite3AddGenerated ( pParse ,  yymsp [ - 2 ] . minor . yy528 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  48 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 1 ) ;  } break ;  case  49 :  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( 0 * 0x0101 ) ;  } break ;  case  50 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( ( yymsp [ - 1 ] . minor . yy394 &amp; ~ yymsp [ 0 ] . minor . yy231 . mask ) | yymsp [ 0 ] . minor . yy231 . value ) ;  } break ;  case  51 :  { yymsp [ - 1 ] . minor . yy231 . value  =  ( int ) ( 0 ) ;  yymsp [ - 1 ] . minor . yy231 . mask  =  ( int ) ( 0x000000 ) ;  } break ;  case  52 :  { yymsp [ - 2 ] . minor . yy231 . value  =  ( int ) ( 0 ) ;  yymsp [ - 2 ] . minor . yy231 . mask  =  ( int ) ( 0x000000 ) ;  } break ;  case  53 :  { yymsp [ - 2 ] . minor . yy231 . value  =  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ;  yymsp [ - 2 ] . minor . yy231 . mask  =  ( int ) ( 0x0000ff ) ;  } break ;  case  54 :  { yymsp [ - 2 ] . minor . yy231 . value  =  ( int ) ( yymsp [ 0 ] . minor . yy394 &lt;&lt; 8 ) ;  yymsp [ - 2 ] . minor . yy231 . mask  =  ( int ) ( 0x00ff00 ) ;  } break ;  case  55 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 8 ) ;  } break ;  case  56 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 9 ) ;  } break ;  case  57 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 10 ) ;  } break ;  case  58 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 7 ) ;  } break ;  case  59 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  60 :  { yymsp [ - 2 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  61 :  case  76 :  ;  case  171 :  ;  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ;  } break ;  case  63 :  case  80 :  ;  case  214 :  ;  case  217 :  ;  case  243 :  ;  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 1 ) ;  } break ;  case  64 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  66 :  { pParse . constraintName . n  =  ( uint ) ( 0 ) ;  } break ;  case  68 :  { sqlite3AddPrimaryKey ( pParse ,  yymsp [ - 3 ] . minor . yy322 ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 2 ] . minor . yy394 ) ,  ( int ) ( 0 ) ) ;  } break ;  case  69 :  { sqlite3CreateIndex ( pParse ,  null ,  null ,  null ,  yymsp [ - 2 ] . minor . yy322 ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ,  null ,  null ,  ( int ) ( 0 ) ,  ( int ) ( 0 ) ,  ( byte ) ( 1 ) ) ;  } break ;  case  70 :  { sqlite3AddCheckConstraint ( pParse ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ - 3 ] . minor . yy0 . z ,  yymsp [ - 1 ] . minor . yy0 . z ) ;  } break ;  case  71 :  { sqlite3CreateForeignKey ( pParse ,  yymsp [ - 6 ] . minor . yy322 ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  yymsp [ - 2 ] . minor . yy322 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  sqlite3DeferForeignKey ( pParse ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  73 :  case  75 :  ;  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( 11 ) ;  } break ;  case  74 :  { yymsp [ - 2 ] . minor . yy394  =  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ;  } break ;  case  77 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 4 ) ;  } break ;  case  78 :  case  172 :  ;  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 5 ) ;  } break ;  case  79 :  { sqlite3DropTable ( pParse ,  yymsp [ 0 ] . minor . yy131 ,  ( int ) ( 0 ) ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  } break ;  case  82 :  { sqlite3CreateView ( pParse ,  &amp; yymsp [ - 8 ] . minor . yy0 ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ 0 ] . minor . yy47 ,  ( int ) ( yymsp [ - 7 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 5 ] . minor . yy394 ) ) ;  } break ;  case  83 :  { sqlite3DropTable ( pParse ,  yymsp [ 0 ] . minor . yy131 ,  ( int ) ( 1 ) ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  } break ;  case  84 :  { SelectDest  dest  =  ( SelectDest ) ( stackalloc  SelectDest [ ] { 9 ,  0 ,  0 ,  0 ,  0 ,  null ,  null } ; ) ;  sqlite3Select ( pParse ,  yymsp [ 0 ] . minor . yy47 ,  dest ) ;  sqlite3SelectDelete ( pParse . db ,  yymsp [ 0 ] . minor . yy47 ) ;  } break ;  case  85 :  { yymsp [ - 2 ] . minor . yy47  =  attachWithToSelect ( pParse ,  yymsp [ 0 ] . minor . yy47 ,  yymsp [ - 1 ] . minor . yy521 ) ;  } break ;  case  86 :  { yymsp [ - 3 ] . minor . yy47  =  attachWithToSelect ( pParse ,  yymsp [ 0 ] . minor . yy47 ,  yymsp [ - 1 ] . minor . yy521 ) ;  } break ;  case  87 :  { Select  p  =  yymsp [ 0 ] . minor . yy47 ;  if  ( ( p ) != null ) { parserDoubleLinkSelect ( pParse ,  p ) ;  } yymsp [ 0 ] . minor . yy47  =  p ;  } break ;  case  88 :  { Select  pRhs  =  yymsp [ 0 ] . minor . yy47 ;  Select  pLhs  =  yymsp [ - 2 ] . minor . yy47 ;  if  ( ( ( pRhs ) != null ) &amp;&amp; ( ( pRhs . pPrior ) != null ) ) { SrcList  pFrom ;  Token  x  =  new  Token ( ) ;  x . n  =  ( uint ) ( 0 ) ;  parserDoubleLinkSelect ( pParse ,  pRhs ) ;  pFrom  =  sqlite3SrcListAppendFromTerm ( pParse ,  null ,  null ,  null ,  &amp; x ,  pRhs ,  null ,  null ) ;  pRhs  =  sqlite3SelectNew ( pParse ,  null ,  pFrom ,  null ,  null ,  null ,  null ,  ( uint ) ( 0 ) ,  null ) ;  } if  ( ( pRhs ) != null ) { pRhs . op  =  ( ( byte ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  pRhs . pPrior  =  pLhs ;  if  ( ( pLhs ) != null ) pLhs . selFlags &amp;= ( uint ) ( ~ 0x0000400 ) ;  pRhs . selFlags &amp;= ( uint ) ( ~ 0x0000400 ) ;  if  ( yymsp [ - 1 ] . minor . yy394 != 135 ) pParse . hasCompound  =  ( byte ) ( 1 ) ;  } else  { sqlite3SelectDelete ( pParse . db ,  pLhs ) ;  } yymsp [ - 2 ] . minor . yy47  =  pRhs ;  } break ;  case  89 :  case  91 :  ;  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( yymsp [ 0 ] . major ) ;  } break ;  case  90 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 135 ) ;  } break ;  case  92 :  { yymsp [ - 8 ] . minor . yy47  =  sqlite3SelectNew ( pParse ,  yymsp [ - 6 ] . minor . yy322 ,  yymsp [ - 5 ] . minor . yy131 ,  yymsp [ - 4 ] . minor . yy528 ,  yymsp [ - 3 ] . minor . yy322 ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ - 1 ] . minor . yy322 ,  ( uint ) ( yymsp [ - 7 ] . minor . yy394 ) ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  93 :  { yymsp [ - 9 ] . minor . yy47  =  sqlite3SelectNew ( pParse ,  yymsp [ - 7 ] . minor . yy322 ,  yymsp [ - 6 ] . minor . yy131 ,  yymsp [ - 5 ] . minor . yy528 ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ - 3 ] . minor . yy528 ,  yymsp [ - 1 ] . minor . yy322 ,  ( uint ) ( yymsp [ - 8 ] . minor . yy394 ) ,  yymsp [ 0 ] . minor . yy528 ) ;  if  ( ( yymsp [ - 9 ] . minor . yy47 ) != null ) { yymsp [ - 9 ] . minor . yy47 . pWinDefn  =  yymsp [ - 2 ] . minor . yy41 ;  } else  { sqlite3WindowListDelete ( pParse . db ,  yymsp [ - 2 ] . minor . yy41 ) ;  } } break ;  case  94 :  { yymsp [ - 3 ] . minor . yy47  =  sqlite3SelectNew ( pParse ,  yymsp [ - 1 ] . minor . yy322 ,  null ,  null ,  null ,  null ,  null ,  ( uint ) ( 0x0000200 ) ,  null ) ;  } break ;  case  95 :  { Select  pRight ;  Select  pLeft  =  yymsp [ - 4 ] . minor . yy47 ;  pRight  =  sqlite3SelectNew ( pParse ,  yymsp [ - 1 ] . minor . yy322 ,  null ,  null ,  null ,  null ,  null ,  ( uint ) ( 0x0000200 | 0x0000400 ) ,  null ) ;  if  ( ( pLeft ) != null ) pLeft . selFlags &amp;= ( uint ) ( ~ 0x0000400 ) ;  if  ( ( pRight ) != null ) { pRight . op  =  ( byte ) ( 135 ) ;  pRight . pPrior  =  pLeft ;  yymsp [ - 4 ] . minor . yy47  =  pRight ;  } else  { yymsp [ - 4 ] . minor . yy47  =  pLeft ;  } } break ;  case  96 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 0x0000001 ) ;  } break ;  case  97 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 0x0000002 ) ;  } break ;  case  99 :  case  132 :  ;  case  142 :  ;  case  230 :  ;  case  233 :  ;  case  238 :  ;  { yymsp [ 1 ] . minor . yy322  =  null ;  } break ;  case  100 :  { yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ - 2 ] . minor . yy528 ) ;  if  ( ( yymsp [ 0 ] . minor . yy0 . n ) &gt; ( 0 ) ) sqlite3ExprListSetName ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  sqlite3ExprListSetSpan ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ - 3 ] . minor . yy522 ,  yymsp [ - 1 ] . minor . yy522 ) ;  } break ;  case  101 :  { Expr  p  =  sqlite3Expr ( pParse . db ,  ( int ) ( 180 ) ,  null ) ;  yymsp [ - 2 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 2 ] . minor . yy322 ,  p ) ;  } break ;  case  102 :  { Expr  pRight  =  sqlite3PExpr ( pParse ,  ( int ) ( 180 ) ,  null ,  null ) ;  Expr  pLeft  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ - 2 ] . minor . yy0 ) ) ;  Expr  pDot  =  sqlite3PExpr ( pParse ,  ( int ) ( 141 ) ,  pLeft ,  pRight ) ;  yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  pDot ) ;  } break ;  case  103 :  case  114 :  ;  case  254 :  ;  case  255 :  ;  { yymsp [ - 1 ] . minor . yy0  =  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  105 :  case  108 :  ;  { yymsp [ 1 ] . minor . yy131  =  null ;  } break ;  case  106 :  { yymsp [ - 1 ] . minor . yy131  =  yymsp [ 0 ] . minor . yy131 ;  sqlite3SrcListShiftJoinType ( yymsp [ - 1 ] . minor . yy131 ) ;  } break ;  case  107 :  { if  ( ( ( ( yymsp [ - 1 ] . minor . yy131 ) != null ) &amp;&amp; ( ( yymsp [ - 1 ] . minor . yy131 . nSrc ) &gt; ( 0 ) ) ) ) yymsp [ - 1 ] . minor . yy131 . a [ yymsp [ - 1 ] . minor . yy131 . nSrc - 1 ] . fg . jointype  =  ( ( byte ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  109 :  { yymsp [ - 6 ] . minor . yy131  =  sqlite3SrcListAppendFromTerm ( pParse ,  yymsp [ - 6 ] . minor . yy131 ,  &amp; yymsp [ - 5 ] . minor . yy0 ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  null ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy254 ) ;  sqlite3SrcListIndexedBy ( pParse ,  yymsp [ - 6 ] . minor . yy131 ,  &amp; yymsp [ - 2 ] . minor . yy0 ) ;  } break ;  case  110 :  { yymsp [ - 8 ] . minor . yy131  =  sqlite3SrcListAppendFromTerm ( pParse ,  yymsp [ - 8 ] . minor . yy131 ,  &amp; yymsp [ - 7 ] . minor . yy0 ,  &amp; yymsp [ - 6 ] . minor . yy0 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  null ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy254 ) ;  sqlite3SrcListFuncArgs ( pParse ,  yymsp [ - 8 ] . minor . yy131 ,  yymsp [ - 4 ] . minor . yy322 ) ;  } break ;  case  111 :  { yymsp [ - 6 ] . minor . yy131  =  sqlite3SrcListAppendFromTerm ( pParse ,  yymsp [ - 6 ] . minor . yy131 ,  null ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  yymsp [ - 4 ] . minor . yy47 ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy254 ) ;  } break ;  case  112 :  { if  ( ( ( ( ( yymsp [ - 6 ] . minor . yy131 ) == ( null ) ) &amp;&amp; ( ( yymsp [ - 2 ] . minor . yy0 . n ) == ( 0 ) ) ) &amp;&amp; ( ( yymsp [ - 1 ] . minor . yy528 ) == ( null ) ) ) &amp;&amp; ( ( yymsp [ 0 ] . minor . yy254 ) == ( null ) ) ) { yymsp [ - 6 ] . minor . yy131  =  yymsp [ - 4 ] . minor . yy131 ;  } else  if  ( ( yymsp [ - 4 ] . minor . yy131 . nSrc ) == ( 1 ) ) { yymsp [ - 6 ] . minor . yy131  =  sqlite3SrcListAppendFromTerm ( pParse ,  yymsp [ - 6 ] . minor . yy131 ,  null ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  null ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy254 ) ;  if  ( ( yymsp [ - 6 ] . minor . yy131 ) != null ) { SrcItem  pNew  =  yymsp [ - 6 ] . minor . yy131 . a [ yymsp [ - 6 ] . minor . yy131 . nSrc - 1 ] ;  SrcItem  pOld  =  yymsp [ - 4 ] . minor . yy131 . a ;  pNew . zName  =  pOld . zName ;  pNew . zDatabase  =  pOld . zDatabase ;  pNew . pSelect  =  pOld . pSelect ;  if  ( ( pOld . fg . isTabFunc ) != 0 ) { pNew . u1 . pFuncArg  =  pOld . u1 . pFuncArg ;  pOld . u1 . pFuncArg  =  null ;  pOld . fg . isTabFunc  =  ( uint ) ( 0 ) ;  pNew . fg . isTabFunc  =  ( uint ) ( 1 ) ;  } pOld . zName  =  pOld . zDatabase  =  null ;  pOld . pSelect  =  null ;  } sqlite3SrcListDelete ( pParse . db ,  yymsp [ - 4 ] . minor . yy131 ) ;  } else  { Select  pSubquery ;  sqlite3SrcListShiftJoinType ( yymsp [ - 4 ] . minor . yy131 ) ;  pSubquery  =  sqlite3SelectNew ( pParse ,  null ,  yymsp [ - 4 ] . minor . yy131 ,  null ,  null ,  null ,  null ,  ( uint ) ( 0x0000800 ) ,  null ) ;  yymsp [ - 6 ] . minor . yy131  =  sqlite3SrcListAppendFromTerm ( pParse ,  yymsp [ - 6 ] . minor . yy131 ,  null ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  pSubquery ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy254 ) ;  } } break ;  case  113 :  case  127 :  ;  { yymsp [ 1 ] . minor . yy0 . z  =  null ;  yymsp [ 1 ] . minor . yy0 . n  =  ( uint ) ( 0 ) ;  } break ;  case  115 :  { yylhsminor . yy131  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ 0 ] . minor . yy0 ,  null ) ;  if  ( ( ( pParse . eParseMode ) &gt;= ( 2 ) ) &amp;&amp; ( ( yylhsminor . yy131 ) != null ) ) sqlite3RenameTokenMap ( pParse ,  yylhsminor . yy131 . a [ 0 ] . zName ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } yymsp [ 0 ] . minor . yy131  =  yylhsminor . yy131 ;  break ;  case  116 :  { yylhsminor . yy131  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  if  ( ( ( pParse . eParseMode ) &gt;= ( 2 ) ) &amp;&amp; ( ( yylhsminor . yy131 ) != null ) ) sqlite3RenameTokenMap ( pParse ,  yylhsminor . yy131 . a [ 0 ] . zName ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } yymsp [ - 2 ] . minor . yy131  =  yylhsminor . yy131 ;  break ;  case  117 :  { yymsp [ 0 ] . minor . yy131  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ 0 ] . minor . yy0 ,  null ) ;  } break ;  case  118 :  { yymsp [ - 2 ] . minor . yy131  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  119 :  { yymsp [ - 4 ] . minor . yy131  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  &amp; yymsp [ - 2 ] . minor . yy0 ) ;  if  ( ( yymsp [ - 4 ] . minor . yy131 ) != null ) yymsp [ - 4 ] . minor . yy131 . a [ 0 ] . zAlias  =  sqlite3NameFromToken ( pParse . db ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  120 :  { yymsp [ - 2 ] . minor . yy131  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  null ) ;  if  ( ( yymsp [ - 2 ] . minor . yy131 ) != null ) yymsp [ - 2 ] . minor . yy131 . a [ 0 ] . zAlias  =  sqlite3NameFromToken ( pParse . db ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  121 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 0x0001 ) ;  } break ;  case  122 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( sqlite3JoinType ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  null ,  null ) ) ;  } break ;  case  123 :  { yymsp [ - 2 ] . minor . yy394  =  ( int ) ( sqlite3JoinType ( pParse ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  null ) ) ;  } break ;  case  124 :  { yymsp [ - 3 ] . minor . yy394  =  ( int ) ( sqlite3JoinType ( pParse ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ - 1 ] . minor . yy0 ) ) ;  } break ;  case  125 :  case  145 :  ;  case  152 :  ;  case  154 :  ;  case  226 :  ;  case  247 :  ;  { yymsp [ - 1 ] . minor . yy528  =  yymsp [ 0 ] . minor . yy528 ;  } break ;  case  126 :  case  144 :  ;  case  146 :  ;  case  151 :  ;  case  153 :  ;  case  227 :  ;  case  229 :  ;  case  248 :  ;  { yymsp [ 1 ] . minor . yy528  =  null ;  } break ;  case  128 :  { yymsp [ - 2 ] . minor . yy0  =  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  129 :  { yymsp [ - 1 ] . minor . yy0 . z  =  null ;  yymsp [ - 1 ] . minor . yy0 . n  =  ( uint ) ( 1 ) ;  } break ;  case  130 :  { yymsp [ - 3 ] . minor . yy254  =  yymsp [ - 1 ] . minor . yy254 ;  } break ;  case  131 :  case  173 :  ;  { yymsp [ 1 ] . minor . yy254  =  null ;  } break ;  case  133 :  case  143 :  ;  { yymsp [ - 2 ] . minor . yy322  =  yymsp [ 0 ] . minor . yy322 ;  } break ;  case  134 :  { yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ - 2 ] . minor . yy528 ) ;  sqlite3ExprListSetSortOrder ( yymsp [ - 4 ] . minor . yy322 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  135 :  { yymsp [ - 2 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ - 2 ] . minor . yy528 ) ;  sqlite3ExprListSetSortOrder ( yymsp [ - 2 ] . minor . yy322 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  136 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  137 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 1 ) ;  } break ;  case  138 :  case  141 :  ;  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( - 1 ) ;  } break ;  case  139 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  140 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 1 ) ;  } break ;  case  147 :  { yymsp [ - 1 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 148 ) ,  yymsp [ 0 ] . minor . yy528 ,  null ) ;  } break ;  case  148 :  { yymsp [ - 3 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 148 ) ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  149 :  { yymsp [ - 3 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 148 ) ,  yymsp [ 0 ] . minor . yy528 ,  yymsp [ - 2 ] . minor . yy528 ) ;  } break ;  case  150 :  { sqlite3SrcListIndexedBy ( pParse ,  yymsp [ - 2 ] . minor . yy131 ,  &amp; yymsp [ - 1 ] . minor . yy0 ) ;  sqlite3DeleteFrom ( pParse ,  yymsp [ - 2 ] . minor . yy131 ,  yymsp [ 0 ] . minor . yy528 ,  null ,  null ) ;  } break ;  case  155 :  { sqlite3AddReturning ( pParse ,  yymsp [ 0 ] . minor . yy322 ) ;  yymsp [ - 1 ] . minor . yy528  =  null ;  } break ;  case  156 :  { sqlite3AddReturning ( pParse ,  yymsp [ 0 ] . minor . yy322 ) ;  yymsp [ - 3 ] . minor . yy528  =  yymsp [ - 2 ] . minor . yy528 ;  } break ;  case  157 :  { sqlite3SrcListIndexedBy ( pParse ,  yymsp [ - 5 ] . minor . yy131 ,  &amp; yymsp [ - 4 ] . minor . yy0 ) ;  sqlite3ExprListCheckLength ( pParse ,  yymsp [ - 2 ] . minor . yy322 ,  "set list" ) ;  yymsp [ - 5 ] . minor . yy131  =  sqlite3SrcListAppendList ( pParse ,  yymsp [ - 5 ] . minor . yy131 ,  yymsp [ - 1 ] . minor . yy131 ) ;  sqlite3Update ( pParse ,  yymsp [ - 5 ] . minor . yy131 ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ 0 ] . minor . yy528 ,  ( int ) ( yymsp [ - 6 ] . minor . yy394 ) ,  null ,  null ,  null ) ;  } break ;  case  158 :  { yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ 0 ] . minor . yy528 ) ;  sqlite3ExprListSetName ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  } break ;  case  159 :  { yymsp [ - 6 ] . minor . yy322  =  sqlite3ExprListAppendVector ( pParse ,  yymsp [ - 6 ] . minor . yy322 ,  yymsp [ - 3 ] . minor . yy254 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  160 :  { yylhsminor . yy322  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ 0 ] . minor . yy528 ) ;  sqlite3ExprListSetName ( pParse ,  yylhsminor . yy322 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  } yymsp [ - 2 ] . minor . yy322  =  yylhsminor . yy322 ;  break ;  case  161 :  { yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppendVector ( pParse ,  null ,  yymsp [ - 3 ] . minor . yy254 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  162 :  { sqlite3Insert ( pParse ,  yymsp [ - 3 ] . minor . yy131 ,  yymsp [ - 1 ] . minor . yy47 ,  yymsp [ - 2 ] . minor . yy254 ,  ( int ) ( yymsp [ - 5 ] . minor . yy394 ) ,  yymsp [ 0 ] . minor . yy444 ) ;  } break ;  case  163 :  { sqlite3Insert ( pParse ,  yymsp [ - 4 ] . minor . yy131 ,  null ,  yymsp [ - 3 ] . minor . yy254 ,  ( int ) ( yymsp [ - 6 ] . minor . yy394 ) ,  null ) ;  } break ;  case  164 :  { yymsp [ 1 ] . minor . yy444  =  null ;  } break ;  case  165 :  { yymsp [ - 1 ] . minor . yy444  =  null ;  sqlite3AddReturning ( pParse ,  yymsp [ 0 ] . minor . yy322 ) ;  } break ;  case  166 :  { yymsp [ - 11 ] . minor . yy444  =  sqlite3UpsertNew ( pParse . db ,  yymsp [ - 8 ] . minor . yy322 ,  yymsp [ - 6 ] . minor . yy528 ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy444 ) ;  } break ;  case  167 :  { yymsp [ - 8 ] . minor . yy444  =  sqlite3UpsertNew ( pParse . db ,  yymsp [ - 5 ] . minor . yy322 ,  yymsp [ - 3 ] . minor . yy528 ,  null ,  null ,  yymsp [ 0 ] . minor . yy444 ) ;  } break ;  case  168 :  { yymsp [ - 4 ] . minor . yy444  =  sqlite3UpsertNew ( pParse . db ,  null ,  null ,  null ,  null ,  null ) ;  } break ;  case  169 :  { yymsp [ - 7 ] . minor . yy444  =  sqlite3UpsertNew ( pParse . db ,  null ,  null ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy528 ,  null ) ;  } break ;  case  170 :  { sqlite3AddReturning ( pParse ,  yymsp [ 0 ] . minor . yy322 ) ;  } break ;  case  174 :  { yymsp [ - 2 ] . minor . yy254  =  yymsp [ - 1 ] . minor . yy254 ;  } break ;  case  175 :  { yymsp [ - 2 ] . minor . yy254  =  sqlite3IdListAppend ( pParse ,  yymsp [ - 2 ] . minor . yy254 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  176 :  { yymsp [ 0 ] . minor . yy254  =  sqlite3IdListAppend ( pParse ,  null ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  177 :  { yymsp [ - 2 ] . minor . yy528  =  yymsp [ - 1 ] . minor . yy528 ;  } break ;  case  178 :  case  179 :  ;  { yymsp [ 0 ] . minor . yy528  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  } break ;  case  180 :  { Expr  temp1  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ - 2 ] . minor . yy0 ) ) ;  Expr  temp2  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  yylhsminor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 141 ) ,  temp1 ,  temp2 ) ;  } yymsp [ - 2 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  181 :  { Expr  temp1  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ - 4 ] . minor . yy0 ) ) ;  Expr  temp2  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ - 2 ] . minor . yy0 ) ) ;  Expr  temp3  =  tokenExpr ( pParse ,  ( int ) ( 59 ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  Expr  temp4  =  sqlite3PExpr ( pParse ,  ( int ) ( 141 ) ,  temp2 ,  temp3 ) ;  if  ( ( ( pParse . eParseMode ) &gt;= ( 2 ) ) ) { sqlite3RenameTokenRemap ( pParse ,  null ,  temp1 ) ;  } yylhsminor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 141 ) ,  temp1 ,  temp4 ) ;  } yymsp [ - 4 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  182 :  case  183 :  ;  { yymsp [ 0 ] . minor . yy528  =  tokenExpr ( pParse ,  ( int ) ( yymsp [ 0 ] . major ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  } break ;  case  184 :  { yylhsminor . yy528  =  sqlite3ExprAlloc ( pParse . db ,  ( int ) ( 155 ) ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  if  ( ( yylhsminor . yy528 ) != null ) yylhsminor . yy528 . w . iOfst  =  ( ( int ) ( yymsp [ 0 ] . minor . yy0 . z - pParse . zTail ) ) ;  } yymsp [ 0 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  185 :  { if  ( ! ( ( ( yymsp [ 0 ] . minor . yy0 . z [ 0 ] ) == ( 35 ) ) &amp;&amp; ( ( sqlite3CtypeMap [ ( byte ) ( yymsp [ 0 ] . minor . yy0 . z [ 1 ] ) ] &amp; 0x04 ) != 0 ) ) ) { uint  n  =  ( uint ) ( yymsp [ 0 ] . minor . yy0 . n ) ;  yymsp [ 0 ] . minor . yy528  =  tokenExpr ( pParse ,  ( int ) ( 156 ) ,  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ) ;  sqlite3ExprAssignVarNumber ( pParse ,  yymsp [ 0 ] . minor . yy528 ,  ( uint ) ( n ) ) ;  } else  { Token  t  =  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ;  if  ( ( pParse . nested ) == ( 0 ) ) { sqlite3ErrorMsg ( pParse ,  "near \"%T\": syntax error" ,  &amp; t ) ;  yymsp [ 0 ] . minor . yy528  =  null ;  } else  { yymsp [ 0 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 176 ) ,  null ,  null ) ;  if  ( ( yymsp [ 0 ] . minor . yy528 ) != null ) sqlite3GetInt32 ( &amp; t . z [ 1 ] ,  &amp; yymsp [ 0 ] . minor . yy528 . iTable ) ;  } } } break ;  case  186 :  { yymsp [ - 2 ] . minor . yy528  =  sqlite3ExprAddCollateToken ( pParse ,  yymsp [ - 2 ] . minor . yy528 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  } break ;  case  187 :  { yymsp [ - 5 ] . minor . yy528  =  sqlite3ExprAlloc ( pParse . db ,  ( int ) ( 36 ) ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  sqlite3ExprAttachSubtrees ( pParse . db ,  yymsp [ - 5 ] . minor . yy528 ,  yymsp [ - 3 ] . minor . yy528 ,  null ) ;  } break ;  case  188 :  { yylhsminor . yy528  =  sqlite3ExprFunction ( pParse ,  yymsp [ - 1 ] . minor . yy322 ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  ( int ) ( yymsp [ - 2 ] . minor . yy394 ) ) ;  } yymsp [ - 4 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  189 :  { yylhsminor . yy528  =  sqlite3ExprFunction ( pParse ,  null ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  } yymsp [ - 3 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  190 :  { yylhsminor . yy528  =  sqlite3ExprFunction ( pParse ,  yymsp [ - 2 ] . minor . yy322 ,  &amp; yymsp [ - 5 ] . minor . yy0 ,  ( int ) ( yymsp [ - 3 ] . minor . yy394 ) ) ;  sqlite3WindowAttach ( pParse ,  yylhsminor . yy528 ,  yymsp [ 0 ] . minor . yy41 ) ;  } yymsp [ - 5 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  191 :  { yylhsminor . yy528  =  sqlite3ExprFunction ( pParse ,  null ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  sqlite3WindowAttach ( pParse ,  yylhsminor . yy528 ,  yymsp [ 0 ] . minor . yy41 ) ;  } yymsp [ - 4 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  192 :  { yylhsminor . yy528  =  sqlite3ExprFunction ( pParse ,  null ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  } yymsp [ 0 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  193 :  { ExprList  pList  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 3 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy528 ) ;  yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 177 ) ,  null ,  null ) ;  if  ( ( yymsp [ - 4 ] . minor . yy528 ) != null ) { yymsp [ - 4 ] . minor . yy528 . x . pList  =  pList ;  if  ( ( pList . nExpr ) != 0 ) { yymsp [ - 4 ] . minor . yy528 . flags |= ( uint ) ( pList . a [ 0 ] . pExpr . flags &amp; ( 0x000100 | 0x200000 | 0x000004 ) ) ;  } } else  { sqlite3ExprListDelete ( pParse . db ,  pList ) ;  } } break ;  case  194 :  { yymsp [ - 2 ] . minor . yy528  =  sqlite3ExprAnd ( pParse ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  195 :  case  196 :  ;  case  197 :  ;  case  198 :  ;  case  199 :  ;  case  200 :  ;  case  201 :  ;  { yymsp [ - 2 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( yymsp [ - 1 ] . major ) ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  202 :  { yymsp [ - 1 ] . minor . yy0  =  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ;  yymsp [ - 1 ] . minor . yy0 . n |= ( uint ) ( 0x80000000 ) ;  } break ;  case  203 :  { ExprList  pList ;  int  bNot  =  ( int ) ( yymsp [ - 1 ] . minor . yy0 . n &amp; 0x80000000 ) ;  yymsp [ - 1 ] . minor . yy0 . n &amp;= ( uint ) ( 0x7fffffff ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ 0 ] . minor . yy528 ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  pList ,  yymsp [ - 2 ] . minor . yy528 ) ;  yymsp [ - 2 ] . minor . yy528  =  sqlite3ExprFunction ( pParse ,  pList ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  if  ( ( bNot ) != 0 ) yymsp [ - 2 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  yymsp [ - 2 ] . minor . yy528 ,  null ) ;  if  ( ( yymsp [ - 2 ] . minor . yy528 ) != null ) yymsp [ - 2 ] . minor . yy528 . flags |= ( uint ) ( 0x000080 ) ;  } break ;  case  204 :  { ExprList  pList ;  int  bNot  =  ( int ) ( yymsp [ - 3 ] . minor . yy0 . n &amp; 0x80000000 ) ;  yymsp [ - 3 ] . minor . yy0 . n &amp;= ( uint ) ( 0x7fffffff ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ - 2 ] . minor . yy528 ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  pList ,  yymsp [ - 4 ] . minor . yy528 ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  pList ,  yymsp [ 0 ] . minor . yy528 ) ;  yymsp [ - 4 ] . minor . yy528  =  sqlite3ExprFunction ( pParse ,  pList ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  if  ( ( bNot ) != 0 ) yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  if  ( ( yymsp [ - 4 ] . minor . yy528 ) != null ) yymsp [ - 4 ] . minor . yy528 . flags |= ( uint ) ( 0x000080 ) ;  } break ;  case  205 :  { yymsp [ - 1 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( yymsp [ 0 ] . major ) ,  yymsp [ - 1 ] . minor . yy528 ,  null ) ;  } break ;  case  206 :  { yymsp [ - 2 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 51 ) ,  yymsp [ - 2 ] . minor . yy528 ,  null ) ;  } break ;  case  207 :  { yymsp [ - 2 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 45 ) ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy528 ) ;  binaryToUnaryIfNull ( pParse ,  yymsp [ 0 ] . minor . yy528 ,  yymsp [ - 2 ] . minor . yy528 ,  ( int ) ( 50 ) ) ;  } break ;  case  208 :  { yymsp [ - 3 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 171 ) ,  yymsp [ - 3 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy528 ) ;  binaryToUnaryIfNull ( pParse ,  yymsp [ 0 ] . minor . yy528 ,  yymsp [ - 3 ] . minor . yy528 ,  ( int ) ( 51 ) ) ;  } break ;  case  209 :  case  210 :  ;  { yymsp [ - 1 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( yymsp [ - 1 ] . major ) ,  yymsp [ 0 ] . minor . yy528 ,  null ) ;  } break ;  case  211 :  { yymsp [ - 1 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( ( yymsp [ - 1 ] . major ) == ( 106 ) ? 174 :  173 ) ,  yymsp [ 0 ] . minor . yy528 ,  null ) ;  } break ;  case  212 :  { ExprList  pList  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ - 2 ] . minor . yy528 ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  pList ,  yymsp [ 0 ] . minor . yy528 ) ;  yylhsminor . yy528  =  sqlite3ExprFunction ( pParse ,  pList ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  } yymsp [ - 2 ] . minor . yy528  =  yylhsminor . yy528 ;  break ;  case  213 :  case  216 :  ;  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  215 :  { ExprList  pList  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ - 2 ] . minor . yy528 ) ;  pList  =  sqlite3ExprListAppend ( pParse ,  pList ,  yymsp [ 0 ] . minor . yy528 ) ;  yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 48 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  if  ( ( yymsp [ - 4 ] . minor . yy528 ) != null ) { yymsp [ - 4 ] . minor . yy528 . x . pList  =  pList ;  } else  { sqlite3ExprListDelete ( pParse . db ,  pList ) ;  } if  ( ( yymsp [ - 3 ] . minor . yy394 ) != 0 ) yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  } break ;  case  218 :  { if  ( ( yymsp [ - 1 ] . minor . yy322 ) == ( null ) ) { sqlite3ExprUnmapAndDelete ( pParse ,  yymsp [ - 4 ] . minor . yy528 ) ;  yymsp [ - 4 ] . minor . yy528  =  sqlite3Expr ( pParse . db ,  ( int ) ( 155 ) ,  ( yymsp [ - 3 ] . minor . yy394 ) != 0 ? "1" :  "0" ) ;  } else  { Expr  pRHS  =  yymsp [ - 1 ] . minor . yy322 . a [ 0 ] . pExpr ;  if  ( ( ( ( yymsp [ - 1 ] . minor . yy322 . nExpr ) == ( 1 ) ) &amp;&amp; ( ( sqlite3ExprIsConstant ( pRHS ) ) != 0 ) ) &amp;&amp; ( yymsp [ - 4 ] . minor . yy528 . op != 177 ) ) { yymsp [ - 1 ] . minor . yy322 . a [ 0 ] . pExpr  =  null ;  sqlite3ExprListDelete ( pParse . db ,  yymsp [ - 1 ] . minor . yy322 ) ;  pRHS  =  sqlite3PExpr ( pParse ,  ( int ) ( 174 ) ,  pRHS ,  null ) ;  yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 53 ) ,  yymsp [ - 4 ] . minor . yy528 ,  pRHS ) ;  } else  { yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 49 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  if  ( ( yymsp [ - 4 ] . minor . yy528 ) == ( null ) ) { sqlite3ExprListDelete ( pParse . db ,  yymsp [ - 1 ] . minor . yy322 ) ;  } else  if  ( ( yymsp [ - 4 ] . minor . yy528 . pLeft . op ) == ( 177 ) ) { int  nExpr  =  ( int ) ( yymsp [ - 4 ] . minor . yy528 . pLeft . x . pList . nExpr ) ;  Select  pSelectRHS  =  sqlite3ExprListToValues ( pParse ,  ( int ) ( nExpr ) ,  yymsp [ - 1 ] . minor . yy322 ) ;  if  ( ( pSelectRHS ) != null ) { parserDoubleLinkSelect ( pParse ,  pSelectRHS ) ;  sqlite3PExprAddSelect ( pParse ,  yymsp [ - 4 ] . minor . yy528 ,  pSelectRHS ) ;  } } else  { yymsp [ - 4 ] . minor . yy528 . x . pList  =  yymsp [ - 1 ] . minor . yy322 ;  sqlite3ExprSetHeightAndFlags ( pParse ,  yymsp [ - 4 ] . minor . yy528 ) ;  } } if  ( ( yymsp [ - 3 ] . minor . yy394 ) != 0 ) yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  } } break ;  case  219 :  { yymsp [ - 2 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 138 ) ,  null ,  null ) ;  sqlite3PExprAddSelect ( pParse ,  yymsp [ - 2 ] . minor . yy528 ,  yymsp [ - 1 ] . minor . yy47 ) ;  } break ;  case  220 :  { yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 49 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  sqlite3PExprAddSelect ( pParse ,  yymsp [ - 4 ] . minor . yy528 ,  yymsp [ - 1 ] . minor . yy47 ) ;  if  ( ( yymsp [ - 3 ] . minor . yy394 ) != 0 ) yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  } break ;  case  221 :  { SrcList  pSrc  =  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ - 1 ] . minor . yy0 ) ;  Select  pSelect  =  sqlite3SelectNew ( pParse ,  null ,  pSrc ,  null ,  null ,  null ,  null ,  ( uint ) ( 0 ) ,  null ) ;  if  ( ( yymsp [ 0 ] . minor . yy322 ) != null ) sqlite3SrcListFuncArgs ( pParse ,  pSelect ? pSrc :  null ,  yymsp [ 0 ] . minor . yy322 ) ;  yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 49 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  sqlite3PExprAddSelect ( pParse ,  yymsp [ - 4 ] . minor . yy528 ,  pSelect ) ;  if  ( ( yymsp [ - 3 ] . minor . yy394 ) != 0 ) yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 19 ) ,  yymsp [ - 4 ] . minor . yy528 ,  null ) ;  } break ;  case  222 :  { Expr  p ;  p  =  yymsp [ - 3 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 20 ) ,  null ,  null ) ;  sqlite3PExprAddSelect ( pParse ,  p ,  yymsp [ - 1 ] . minor . yy47 ) ;  } break ;  case  223 :  { yymsp [ - 4 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 157 ) ,  yymsp [ - 3 ] . minor . yy528 ,  null ) ;  if  ( ( yymsp [ - 4 ] . minor . yy528 ) != null ) { yymsp [ - 4 ] . minor . yy528 . x . pList  =  yymsp [ - 1 ] . minor . yy528 ? sqlite3ExprListAppend ( pParse ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy528 ) :  yymsp [ - 2 ] . minor . yy322 ;  sqlite3ExprSetHeightAndFlags ( pParse ,  yymsp [ - 4 ] . minor . yy528 ) ;  } else  { sqlite3ExprListDelete ( pParse . db ,  yymsp [ - 2 ] . minor . yy322 ) ;  sqlite3ExprDelete ( pParse . db ,  yymsp [ - 1 ] . minor . yy528 ) ;  } } break ;  case  224 :  { yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ - 2 ] . minor . yy528 ) ;  yymsp [ - 4 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  225 :  { yymsp [ - 3 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ - 2 ] . minor . yy528 ) ;  yymsp [ - 3 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 3 ] . minor . yy322 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  228 :  { yymsp [ 0 ] . minor . yy528  =  yymsp [ 0 ] . minor . yy528 ;  } break ;  case  231 :  { yymsp [ - 2 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  232 :  { yymsp [ 0 ] . minor . yy322  =  sqlite3ExprListAppend ( pParse ,  null ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  234 :  case  239 :  ;  { yymsp [ - 2 ] . minor . yy322  =  yymsp [ - 1 ] . minor . yy322 ;  } break ;  case  235 :  { sqlite3CreateIndex ( pParse ,  &amp; yymsp [ - 7 ] . minor . yy0 ,  &amp; yymsp [ - 6 ] . minor . yy0 ,  sqlite3SrcListAppend ( pParse ,  null ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  null ) ,  yymsp [ - 2 ] . minor . yy322 ,  ( int ) ( yymsp [ - 10 ] . minor . yy394 ) ,  &amp; yymsp [ - 11 ] . minor . yy0 ,  yymsp [ 0 ] . minor . yy528 ,  ( int ) ( 0 ) ,  ( int ) ( yymsp [ - 8 ] . minor . yy394 ) ,  ( byte ) ( 0 ) ) ;  if  ( ( ( pParse . eParseMode ) &gt;= ( 2 ) ) &amp;&amp; ( ( pParse . pNewIndex ) != null ) ) { sqlite3RenameTokenMap ( pParse ,  pParse . pNewIndex . zName ,  &amp; yymsp [ - 4 ] . minor . yy0 ) ;  } } break ;  case  236 :  case  278 :  ;  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 2 ) ;  } break ;  case  237 :  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( 0 ) ;  } break ;  case  240 :  { yymsp [ - 4 ] . minor . yy322  =  parserAddExprIdListTerm ( pParse ,  yymsp [ - 4 ] . minor . yy322 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  241 :  { yymsp [ - 2 ] . minor . yy322  =  parserAddExprIdListTerm ( pParse ,  null ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ,  ( int ) ( yymsp [ 0 ] . minor . yy394 ) ) ;  } break ;  case  244 :  { sqlite3DropIndex ( pParse ,  yymsp [ 0 ] . minor . yy131 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  } break ;  case  245 :  { sqlite3Vacuum ( pParse ,  null ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  246 :  { sqlite3Vacuum ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  249 :  { sqlite3Pragma ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  null ,  ( int ) ( 0 ) ) ;  } break ;  case  250 :  { sqlite3Pragma ( pParse ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  } break ;  case  251 :  { sqlite3Pragma ( pParse ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( int ) ( 0 ) ) ;  } break ;  case  252 :  { sqlite3Pragma ( pParse ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  } break ;  case  253 :  { sqlite3Pragma ( pParse ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  } break ;  case  256 :  { Token  all  =  new  Token ( ) ;  all . z  =  yymsp [ - 3 ] . minor . yy0 . z ;  all . n  =  ( uint ) ( ( int ) ( yymsp [ 0 ] . minor . yy0 . z - yymsp [ - 3 ] . minor . yy0 . z ) + yymsp [ 0 ] . minor . yy0 . n ) ;  sqlite3FinishTrigger ( pParse ,  yymsp [ - 1 ] . minor . yy33 ,  &amp; all ) ;  } break ;  case  257 :  { sqlite3BeginTrigger ( pParse ,  &amp; yymsp [ - 7 ] . minor . yy0 ,  &amp; yymsp [ - 6 ] . minor . yy0 ,  ( int ) ( yymsp [ - 5 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 4 ] . minor . yy180 . a ) ,  yymsp [ - 4 ] . minor . yy180 . b ,  yymsp [ - 2 ] . minor . yy131 ,  yymsp [ 0 ] . minor . yy528 ,  ( int ) ( yymsp [ - 10 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 8 ] . minor . yy394 ) ) ;  yymsp [ - 10 ] . minor . yy0  =  ( Token ) ( ( yymsp [ - 6 ] . minor . yy0 . n ) == ( 0 ) ? yymsp [ - 7 ] . minor . yy0 :  yymsp [ - 6 ] . minor . yy0 ) ;  } break ;  case  258 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( yymsp [ 0 ] . major ) ;  } break ;  case  259 :  { yymsp [ - 1 ] . minor . yy394  =  ( int ) ( 65 ) ;  } break ;  case  260 :  { yymsp [ 1 ] . minor . yy394  =  ( int ) ( 33 ) ;  } break ;  case  261 :  case  262 :  ;  { yymsp [ 0 ] . minor . yy180 . a  =  ( int ) ( yymsp [ 0 ] . major ) ;  yymsp [ 0 ] . minor . yy180 . b  =  null ;  } break ;  case  263 :  { yymsp [ - 2 ] . minor . yy180 . a  =  ( int ) ( 129 ) ;  yymsp [ - 2 ] . minor . yy180 . b  =  yymsp [ 0 ] . minor . yy254 ;  } break ;  case  264 :  case  283 :  ;  { yymsp [ 1 ] . minor . yy528  =  null ;  } break ;  case  265 :  case  284 :  ;  { yymsp [ - 1 ] . minor . yy528  =  yymsp [ 0 ] . minor . yy528 ;  } break ;  case  266 :  { yymsp [ - 2 ] . minor . yy33 . pLast . pNext  =  yymsp [ - 1 ] . minor . yy33 ;  yymsp [ - 2 ] . minor . yy33 . pLast  =  yymsp [ - 1 ] . minor . yy33 ;  } break ;  case  267 :  { yymsp [ - 1 ] . minor . yy33 . pLast  =  yymsp [ - 1 ] . minor . yy33 ;  } break ;  case  268 :  { yymsp [ - 2 ] . minor . yy0  =  ( Token ) ( yymsp [ 0 ] . minor . yy0 ) ;  sqlite3ErrorMsg ( pParse ,  "qualified table names are not allowed on INSERT, UPDATE, and DELETE statements within triggers" ) ;  } break ;  case  269 :  { sqlite3ErrorMsg ( pParse ,  "the INDEXED BY clause is not allowed on UPDATE or DELETE statements within triggers" ) ;  } break ;  case  270 :  { sqlite3ErrorMsg ( pParse ,  "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements within triggers" ) ;  } break ;  case  271 :  { yylhsminor . yy33  =  sqlite3TriggerUpdateStep ( pParse ,  &amp; yymsp [ - 6 ] . minor . yy0 ,  yymsp [ - 2 ] . minor . yy131 ,  yymsp [ - 3 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy528 ,  ( byte ) ( yymsp [ - 7 ] . minor . yy394 ) ,  yymsp [ - 8 ] . minor . yy0 . z ,  yymsp [ 0 ] . minor . yy522 ) ;  } yymsp [ - 8 ] . minor . yy33  =  yylhsminor . yy33 ;  break ;  case  272 :  { yylhsminor . yy33  =  sqlite3TriggerInsertStep ( pParse ,  &amp; yymsp [ - 4 ] . minor . yy0 ,  yymsp [ - 3 ] . minor . yy254 ,  yymsp [ - 2 ] . minor . yy47 ,  ( byte ) ( yymsp [ - 6 ] . minor . yy394 ) ,  yymsp [ - 1 ] . minor . yy444 ,  yymsp [ - 7 ] . minor . yy522 ,  yymsp [ 0 ] . minor . yy522 ) ;  } yymsp [ - 7 ] . minor . yy33  =  yylhsminor . yy33 ;  break ;  case  273 :  { yylhsminor . yy33  =  sqlite3TriggerDeleteStep ( pParse ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ - 5 ] . minor . yy0 . z ,  yymsp [ 0 ] . minor . yy522 ) ;  } yymsp [ - 5 ] . minor . yy33  =  yylhsminor . yy33 ;  break ;  case  274 :  { yylhsminor . yy33  =  sqlite3TriggerSelectStep ( pParse . db ,  yymsp [ - 1 ] . minor . yy47 ,  yymsp [ - 2 ] . minor . yy522 ,  yymsp [ 0 ] . minor . yy522 ) ;  } yymsp [ - 2 ] . minor . yy33  =  yylhsminor . yy33 ;  break ;  case  275 :  { yymsp [ - 3 ] . minor . yy528  =  sqlite3PExpr ( pParse ,  ( int ) ( 71 ) ,  null ,  null ) ;  if  ( ( yymsp [ - 3 ] . minor . yy528 ) != null ) { yymsp [ - 3 ] . minor . yy528 . affExpr  =  ( sbyte ) ( 4 ) ;  } } break ;  case  276 :  { yymsp [ - 5 ] . minor . yy528  =  sqlite3ExprAlloc ( pParse . db ,  ( int ) ( 71 ) ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  ( int ) ( 1 ) ) ;  if  ( ( yymsp [ - 5 ] . minor . yy528 ) != null ) { yymsp [ - 5 ] . minor . yy528 . affExpr  =  ( ( sbyte ) ( yymsp [ - 3 ] . minor . yy394 ) ) ;  } } break ;  case  277 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 1 ) ;  } break ;  case  279 :  { yymsp [ 0 ] . minor . yy394  =  ( int ) ( 3 ) ;  } break ;  case  280 :  { sqlite3DropTrigger ( pParse ,  yymsp [ 0 ] . minor . yy131 ,  ( int ) ( yymsp [ - 1 ] . minor . yy394 ) ) ;  } break ;  case  281 :  { sqlite3Attach ( pParse ,  yymsp [ - 3 ] . minor . yy528 ,  yymsp [ - 1 ] . minor . yy528 ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  282 :  { sqlite3Detach ( pParse ,  yymsp [ 0 ] . minor . yy528 ) ;  } break ;  case  285 :  { sqlite3Reindex ( pParse ,  null ,  null ) ;  } break ;  case  286 :  { sqlite3Reindex ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  287 :  { sqlite3Analyze ( pParse ,  null ,  null ) ;  } break ;  case  288 :  { sqlite3Analyze ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  289 :  { sqlite3AlterRenameTable ( pParse ,  yymsp [ - 3 ] . minor . yy131 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  290 :  { yymsp [ - 1 ] . minor . yy0 . n  =  ( uint ) ( ( int ) ( pParse . sLastToken . z - yymsp [ - 1 ] . minor . yy0 . z ) + pParse . sLastToken . n ) ;  sqlite3AlterFinishAddColumn ( pParse ,  &amp; yymsp [ - 1 ] . minor . yy0 ) ;  } break ;  case  291 :  { sqlite3AlterDropColumn ( pParse ,  yymsp [ - 3 ] . minor . yy131 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  292 :  { disableLookaside ( pParse ) ;  sqlite3AlterBeginAddColumn ( pParse ,  yymsp [ 0 ] . minor . yy131 ) ;  } break ;  case  293 :  { sqlite3AlterRenameColumn ( pParse ,  yymsp [ - 5 ] . minor . yy131 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  294 :  { sqlite3VtabFinishParse ( pParse ,  null ) ;  } break ;  case  295 :  { sqlite3VtabFinishParse ( pParse ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  296 :  { sqlite3VtabBeginParse ( pParse ,  &amp; yymsp [ - 3 ] . minor . yy0 ,  &amp; yymsp [ - 2 ] . minor . yy0 ,  &amp; yymsp [ 0 ] . minor . yy0 ,  ( int ) ( yymsp [ - 4 ] . minor . yy394 ) ) ;  } break ;  case  297 :  { sqlite3VtabArgInit ( pParse ) ;  } break ;  case  298 :  case  299 :  ;  case  300 :  ;  { sqlite3VtabArgExtend ( pParse ,  &amp; yymsp [ 0 ] . minor . yy0 ) ;  } break ;  case  301 :  case  302 :  ;  { sqlite3WithPush ( pParse ,  yymsp [ 0 ] . minor . yy521 ,  ( byte ) ( 1 ) ) ;  } break ;  case  303 :  { yymsp [ 0 ] . minor . yy516  =  ( byte ) ( 1 ) ;  } break ;  case  304 :  { yymsp [ - 1 ] . minor . yy516  =  ( byte ) ( 0 ) ;  } break ;  case  305 :  { yymsp [ - 2 ] . minor . yy516  =  ( byte ) ( 2 ) ;  } break ;  case  306 :  { yymsp [ - 5 ] . minor . yy385  =  sqlite3CteNew ( pParse ,  &amp; yymsp [ - 5 ] . minor . yy0 ,  yymsp [ - 4 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy47 ,  ( byte ) ( yymsp [ - 3 ] . minor . yy516 ) ) ;  } break ;  case  307 :  { yymsp [ 0 ] . minor . yy521  =  sqlite3WithAdd ( pParse ,  null ,  yymsp [ 0 ] . minor . yy385 ) ;  } break ;  case  308 :  { yymsp [ - 2 ] . minor . yy521  =  sqlite3WithAdd ( pParse ,  yymsp [ - 2 ] . minor . yy521 ,  yymsp [ 0 ] . minor . yy385 ) ;  } break ;  case  309 :  { yylhsminor . yy41  =  yymsp [ 0 ] . minor . yy41 ;  } yymsp [ 0 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  310 :  { sqlite3WindowChain ( pParse ,  yymsp [ 0 ] . minor . yy41 ,  yymsp [ - 2 ] . minor . yy41 ) ;  yymsp [ 0 ] . minor . yy41 . pNextWin  =  yymsp [ - 2 ] . minor . yy41 ;  yylhsminor . yy41  =  yymsp [ 0 ] . minor . yy41 ;  } yymsp [ - 2 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  311 :  { if  ( ( yymsp [ - 1 ] . minor . yy41 ) != null ) { yymsp [ - 1 ] . minor . yy41 . zName  =  sqlite3DbStrNDup ( pParse . db ,  yymsp [ - 4 ] . minor . yy0 . z ,  ( ulong ) ( yymsp [ - 4 ] . minor . yy0 . n ) ) ;  } yylhsminor . yy41  =  yymsp [ - 1 ] . minor . yy41 ;  } yymsp [ - 4 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  312 :  { yymsp [ - 4 ] . minor . yy41  =  sqlite3WindowAssemble ( pParse ,  yymsp [ 0 ] . minor . yy41 ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy322 ,  null ) ;  } break ;  case  313 :  { yylhsminor . yy41  =  sqlite3WindowAssemble ( pParse ,  yymsp [ 0 ] . minor . yy41 ,  yymsp [ - 2 ] . minor . yy322 ,  yymsp [ - 1 ] . minor . yy322 ,  &amp; yymsp [ - 5 ] . minor . yy0 ) ;  } yymsp [ - 5 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  314 :  { yymsp [ - 3 ] . minor . yy41  =  sqlite3WindowAssemble ( pParse ,  yymsp [ 0 ] . minor . yy41 ,  null ,  yymsp [ - 1 ] . minor . yy322 ,  null ) ;  } break ;  case  315 :  { yylhsminor . yy41  =  sqlite3WindowAssemble ( pParse ,  yymsp [ 0 ] . minor . yy41 ,  null ,  yymsp [ - 1 ] . minor . yy322 ,  &amp; yymsp [ - 4 ] . minor . yy0 ) ;  } yymsp [ - 4 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  316 :  case  335 :  ;  { yylhsminor . yy41  =  yymsp [ 0 ] . minor . yy41 ;  } yymsp [ 0 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  317 :  { yylhsminor . yy41  =  sqlite3WindowAssemble ( pParse ,  yymsp [ 0 ] . minor . yy41 ,  null ,  null ,  &amp; yymsp [ - 1 ] . minor . yy0 ) ;  } yymsp [ - 1 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  318 :  { yymsp [ 1 ] . minor . yy41  =  sqlite3WindowAlloc ( pParse ,  ( int ) ( 0 ) ,  ( int ) ( 90 ) ,  null ,  ( int ) ( 85 ) ,  null ,  ( byte ) ( 0 ) ) ;  } break ;  case  319 :  { yylhsminor . yy41  =  sqlite3WindowAlloc ( pParse ,  ( int ) ( yymsp [ - 2 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 1 ] . minor . yy595 . eType ) ,  yymsp [ - 1 ] . minor . yy595 . pExpr ,  ( int ) ( 85 ) ,  null ,  ( byte ) ( yymsp [ 0 ] . minor . yy516 ) ) ;  } yymsp [ - 2 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  320 :  { yylhsminor . yy41  =  sqlite3WindowAlloc ( pParse ,  ( int ) ( yymsp [ - 5 ] . minor . yy394 ) ,  ( int ) ( yymsp [ - 3 ] . minor . yy595 . eType ) ,  yymsp [ - 3 ] . minor . yy595 . pExpr ,  ( int ) ( yymsp [ - 1 ] . minor . yy595 . eType ) ,  yymsp [ - 1 ] . minor . yy595 . pExpr ,  ( byte ) ( yymsp [ 0 ] . minor . yy516 ) ) ;  } yymsp [ - 5 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  322 :  case  324 :  ;  { yylhsminor . yy595  =  ( FrameBound ) ( yymsp [ 0 ] . minor . yy595 ) ;  } yymsp [ 0 ] . minor . yy595  =  ( FrameBound ) ( yylhsminor . yy595 ) ;  break ;  case  323 :  case  325 :  ;  case  327 :  ;  { yylhsminor . yy595 . eType  =  ( int ) ( yymsp [ - 1 ] . major ) ;  yylhsminor . yy595 . pExpr  =  null ;  } yymsp [ - 1 ] . minor . yy595  =  ( FrameBound ) ( yylhsminor . yy595 ) ;  break ;  case  326 :  { yylhsminor . yy595 . eType  =  ( int ) ( yymsp [ 0 ] . major ) ;  yylhsminor . yy595 . pExpr  =  yymsp [ - 1 ] . minor . yy528 ;  } yymsp [ - 1 ] . minor . yy595  =  ( FrameBound ) ( yylhsminor . yy595 ) ;  break ;  case  328 :  { yymsp [ 1 ] . minor . yy516  =  ( byte ) ( 0 ) ;  } break ;  case  329 :  { yymsp [ - 1 ] . minor . yy516  =  ( byte ) ( yymsp [ 0 ] . minor . yy516 ) ;  } break ;  case  330 :  case  331 :  ;  { yymsp [ - 1 ] . minor . yy516  =  ( byte ) ( yymsp [ - 1 ] . major ) ;  } break ;  case  332 :  { yymsp [ 0 ] . minor . yy516  =  ( byte ) ( yymsp [ 0 ] . major ) ;  } break ;  case  333 :  { yymsp [ - 1 ] . minor . yy41  =  yymsp [ 0 ] . minor . yy41 ;  } break ;  case  334 :  { if  ( ( yymsp [ 0 ] . minor . yy41 ) != null ) { yymsp [ 0 ] . minor . yy41 . pFilter  =  yymsp [ - 1 ] . minor . yy528 ;  } else  { sqlite3ExprDelete ( pParse . db ,  yymsp [ - 1 ] . minor . yy528 ) ;  } yylhsminor . yy41  =  yymsp [ 0 ] . minor . yy41 ;  } yymsp [ - 1 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  336 :  { yylhsminor . yy41  =  ( Window ) ( sqlite3DbMallocZero ( pParse . db ,  ( ulong ) ( sizeof ( Window ) ) ) ) ;  if  ( ( yylhsminor . yy41 ) != null ) { yylhsminor . yy41 . eFrmType  =  ( byte ) ( 166 ) ;  yylhsminor . yy41 . pFilter  =  yymsp [ 0 ] . minor . yy528 ;  } else  { sqlite3ExprDelete ( pParse . db ,  yymsp [ 0 ] . minor . yy528 ) ;  } } yymsp [ 0 ] . minor . yy41  =  yylhsminor . yy41 ;  break ;  case  337 :  { yymsp [ - 3 ] . minor . yy41  =  yymsp [ - 1 ] . minor . yy41 ;  } break ;  case  338 :  { yymsp [ - 1 ] . minor . yy41  =  ( Window ) ( sqlite3DbMallocZero ( pParse . db ,  ( ulong ) ( sizeof ( Window ) ) ) ) ;  if  ( ( yymsp [ - 1 ] . minor . yy41 ) != null ) { yymsp [ - 1 ] . minor . yy41 . zName  =  sqlite3DbStrNDup ( pParse . db ,  yymsp [ 0 ] . minor . yy0 . z ,  ( ulong ) ( yymsp [ 0 ] . minor . yy0 . n ) ) ;  } } break ;  case  339 :  { yymsp [ - 4 ] . minor . yy528  =  yymsp [ - 1 ] . minor . yy528 ;  } break ;  default :  ;  break ;  }

    yygoto = (int)(yyRuleInfoLhs[yyruleno]);
    yysize = (int)(yyRuleInfoNRhs[yyruleno]);
    yyact = (ushort)(yy_find_reduce_action((ushort)(yymsp[yysize].stateno), (ushort)(yygoto)));
    yymsp += yysize + 1;
    yypParser.yytos = yymsp;
    yymsp-&gt;stateno = (ushort)(yyact);
    yymsp-&gt;major = ((ushort)(yygoto));
    return (ushort)(yyact);
}</function>
  <function>public static void yy_shift(yyParser yypParser, ushort yyNewState, ushort yyMajor, Token yyMinor)
{
    yyStackEntry* yytos;
    yypParser.yytos++;
    if ((yypParser.yytos) &gt; (yypParser.yystackEnd))
    {
        yypParser.yytos--;
        yyStackOverflow(yypParser);
        return;
    }

    if ((yyNewState) &gt; (573))
    {
        yyNewState += (ushort)(1236 - 831);
    }

    yytos = yypParser.yytos;
    yytos-&gt;stateno = (ushort)(yyNewState);
    yytos-&gt;major = (ushort)(yyMajor);
    yytos-&gt;minor.yy0 = (Token)(yyMinor);
}</function>
  <function>public static void yy_syntax_error(yyParser yypParser, int yymajor, Token yyminor)
{
    Parse pParse = yypParser.pParse;
    if ((yyminor.z[0]) != 0)
    {
        sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &amp;yyminor);
    }
    else
    {
        sqlite3ErrorMsg(pParse, "incomplete input");
    }

    yypParser.pParse = pParse;
}</function>
  <function>public static void yyStackOverflow(yyParser yypParser)
{
    Parse pParse = yypParser.pParse;
    while ((yypParser.yytos) &gt; (yypParser.yystack))
    {
        yy_pop_parser_stack(yypParser);
    }

    sqlite3ErrorMsg(pParse, "parser stack overflow");
    yypParser.pParse = pParse;
}</function>
  <function>public static void zeroblobFunc(sqlite3_context context, int argc, sqlite3_value argv)
{
    long n = 0;
    int rc = 0;
    n = (long)(sqlite3_value_int64(argv[0]));
    if ((n) &lt; (0))
        n = (long)(0);
    rc = (int)(sqlite3_result_zeroblob64(context, (ulong)(n)));
    if ((rc) != 0)
    {
        sqlite3_result_error_code(context, (int)(rc));
    }
}</function>
  <function>public static int zeroJournalHdr(Pager pPager, int doTruncate)
{
    int rc = (int)(0);
    if ((pPager.journalOff) != 0)
    {
        long iLimit = (long)(pPager.journalSizeLimit);
        if (((doTruncate) != 0) || ((iLimit) == (0)))
        {
            rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(0)));
        }
        else
        {
            rc = (int)(sqlite3OsWrite(pPager.jfd, zeroJournalHdr_zeroHdr, (int)(28 * sizeof(sbyte)), (long)(0)));
        }

        if (((rc) == (0)) &amp;&amp; (pPager.noSync == 0))
        {
            rc = (int)(sqlite3OsSync(pPager.jfd, (int)(0x00010 | pPager.syncFlags)));
        }

        if (((rc) == (0)) &amp;&amp; ((iLimit) &gt; (0)))
        {
            long sz = 0;
            rc = (int)(sqlite3OsFileSize(pPager.jfd, &amp;sz));
            if (((rc) == (0)) &amp;&amp; ((sz) &gt; (iLimit)))
            {
                rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(iLimit)));
            }
        }
    }

    return (int)(rc);
}</function>
  <function>public static void zeroPage(MemPage pPage, int flags)
{
    byte* data = pPage.aData;
    BtShared pBt = pPage.pBt;
    byte hdr = (byte)(pPage.hdrOffset);
    ushort first = 0;
    if ((pBt.btsFlags &amp; 0x000c) != 0)
    {
        CRuntime.memset(&amp;data[hdr], (int)(0), (ulong)(pBt.usableSize - hdr));
    }

    data[hdr] = (byte)((sbyte)(flags));
    first = (ushort)(hdr + ((flags &amp; 0x08) == (0) ? 12 : 8));
    CRuntime.memset(&amp;data[hdr + 1], (int)(0), (ulong)(4));
    data[hdr + 7] = (byte)(0);
    ((&amp;data[hdr + 5])[0] = ((byte)((pBt.usableSize) &gt;&gt; 8)), (&amp;data[hdr + 5])[1] = ((byte)(pBt.usableSize)));
    pPage.nFree = (int)((ushort)(pBt.usableSize - first));
    decodeFlags(pPage, (int)(flags));
    pPage.cellOffset = (ushort)(first);
    pPage.aDataEnd = &amp;data[pBt.pageSize];
    pPage.aCellIdx = &amp;data[first];
    pPage.aDataOfst = &amp;data[pPage.childPtrSize];
    pPage.nOverflow = (byte)(0);
    pPage.maskPage = ((ushort)(pBt.pageSize - 1));
    pPage.nCell = (ushort)(0);
    pPage.isInit = (byte)(1);
}</function>
</functions>