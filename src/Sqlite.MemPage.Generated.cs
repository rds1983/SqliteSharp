// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int allocateSpace(MemPage pPage, int nByte, int* pIdx)
		{
			int hdr = (int)(pPage.hdrOffset);
			byte* data = pPage.aData;
			int top = 0;
			int rc = (int)(0);
			int gap = 0;
			gap = (int)(pPage.cellOffset + 2 * pPage.nCell);
			top = (int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
			if ((gap) > (top))
			{
				if (((top) == (0)) && ((pPage.pBt.usableSize) == (65536)))
				{
					top = (int)(65536);
				}
				else
				{
					return (int)(sqlite3CorruptError((int)(67844)));
				}
			}

			if ((((data[hdr + 2]) != 0) || ((data[hdr + 1]) != 0)) && ((gap + 2) <= (top)))
			{
				byte* pSpace = pageFindSlot(pPage, (int)(nByte), &rc);
				if ((pSpace) != null)
				{
					int g2 = 0;
					*pIdx = (int)(g2 = ((int)(pSpace - data)));
					if ((g2) <= (gap))
					{
						return (int)(sqlite3CorruptError((int)(67862)));
					}
					else
					{
						return (int)(0);
					}
				}
				else if ((rc) != 0)
				{
					return (int)(rc);
				}
			}

			if ((gap + 2 + nByte) > (top))
			{
				rc = (int)(defragmentPage(pPage, (int)((4) < (pPage.nFree - (2 + nByte)) ? (4) : (pPage.nFree - (2 + nByte)))));
				if ((rc) != 0)
					return (int)(rc);
				top = (int)(((((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]) - 1) & 0xffff) + 1);
			}

			top -= (int)(nByte);
			((&data[hdr + 5])[0] = ((byte)((top) >> 8)), (&data[hdr + 5])[1] = ((byte)(top)));
			*pIdx = (int)(top);
			return (int)(0);
		}
		public static int balance_deeper(MemPage pRoot, MemPage ppChild)
		{
			int rc = 0;
			MemPage pChild = null;
			uint pgnoChild = (uint)(0);
			BtShared pBt = pRoot.pBt;
			rc = (int)(sqlite3PagerWrite(pRoot.pDbPage));
			if ((rc) == (0))
			{
				rc = (int)(allocateBtreePage(pBt, pChild, &pgnoChild, (uint)(pRoot.pgno), (byte)(0)));
				copyNodeContent(pRoot, pChild, &rc);
				if ((pBt.autoVacuum) != 0)
				{
					ptrmapPut(pBt, (uint)(pgnoChild), (byte)(5), (uint)(pRoot.pgno), &rc);
				}
			}

			if ((rc) != 0)
			{
				ppChild = null;
				releasePage(pChild);
				return (int)(rc);
			}

			CRuntime.memcpy(pChild.aiOvfl, pRoot.aiOvfl, (ulong)(pRoot.nOverflow * sizeof(ushort)));
			CRuntime.memcpy(pChild.apOvfl, pRoot.apOvfl, (ulong)(pRoot.nOverflow * sizeof(byte*)));
			pChild.nOverflow = (byte)(pRoot.nOverflow);
			zeroPage(pRoot, (int)(pChild.aData[0] & ~0x08));
			sqlite3Put4byte(&pRoot.aData[pRoot.hdrOffset + 8], (uint)(pgnoChild));
			ppChild = pChild;
			return (int)(0);
		}
		public static int balance_nonroot(MemPage pParent, int iParentIdx, byte* aOvflSpace, int isRoot, int bBulk)
		{
			BtShared pBt;
			int nMaxCells = (int)(0);
			int nNew = (int)(0);
			int nOld = 0;
			int i = 0; int j = 0; int k = 0;
			int nxDiv = 0;
			int rc = (int)(0);
			ushort leafCorrection = 0;
			int leafData = 0;
			int usableSpace = 0;
			int pageFlags = 0;
			int iSpace1 = (int)(0);
			int iOvflSpace = (int)(0);
			int szScratch = 0;
			var apOld = new MemPage[3]; apOld[0] = new MemPage(); apOld[1] = new MemPage(); apOld[2] = new MemPage();
			var apNew = new MemPage[5]; apNew[0] = new MemPage(); apNew[1] = new MemPage(); apNew[2] = new MemPage(); apNew[3] = new MemPage(); apNew[4] = new MemPage();
			byte* pRight;
			byte** apDiv = stackalloc byte[2];
			int* cntNew = stackalloc int[5];
			int* cntOld = stackalloc int[5];
			int* szNew = stackalloc int[5];
			byte* aSpace1;
			uint pgno = 0;
			byte* abDone = stackalloc byte[5];
			uint* aPgno = stackalloc uint[5];
			uint* aPgOrder = stackalloc uint[5];
			ushort* aPgFlags = stackalloc ushort[5];
			CellArray b = new CellArray();
			CRuntime.memset(abDone, (int)(0), (ulong)(5 * sizeof(byte)));
			CRuntime.memset(b, (int)(0), (ulong)(sizeof(CellArray)));
			pBt = pParent.pBt;
			if (aOvflSpace == null)
			{
				return (int)(7);
			}

			i = (int)(pParent.nOverflow + pParent.nCell);
			if ((i) < (2))
			{
				nxDiv = (int)(0);
			}
			else
			{
				if ((iParentIdx) == (0))
				{
					nxDiv = (int)(0);
				}
				else if ((iParentIdx) == (i))
				{
					nxDiv = (int)(i - 2 + bBulk);
				}
				else
				{
					nxDiv = (int)(iParentIdx - 1);
				}

				i = (int)(2 - bBulk);
			}

			nOld = (int)(i + 1);
			if ((i + nxDiv - pParent.nOverflow) == (pParent.nCell))
			{
				pRight = &pParent.aData[pParent.hdrOffset + 8];
			}
			else
			{
				pRight = ((pParent).aData + ((pParent).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pParent).aCellIdx[2 * (i + nxDiv - pParent.nOverflow)])))));
			}

			pgno = (uint)(sqlite3Get4byte(pRight));
			while ((1) != 0)
			{
				if ((rc) == (0))
				{
					rc = (int)(getAndInitPage(pBt, (uint)(pgno), apOld[i], null, (int)(0)));
				}

				if ((rc) != 0)
				{
					CRuntime.memset(apOld, (int)(0), (ulong)((i + 1) * sizeof(MemPage)));
					goto balance_cleanup;
				}

				if ((apOld[i].nFree) < (0))
				{
					rc = (int)(btreeComputeFreeSpace(apOld[i]));
					if ((rc) != 0)
					{
						CRuntime.memset(apOld, (int)(0), (ulong)((i) * sizeof(MemPage)));
						goto balance_cleanup;
					}
				}

				nMaxCells += (int)(apOld[i].nCell + ((int)(4 * sizeof(byte) / sizeof(byte*))));
				if ((i--) == (0))
					break;
				if (((pParent.nOverflow) != 0) && ((i + nxDiv) == (pParent.aiOvfl[0])))
				{
					apDiv[i] = pParent.apOvfl[0];
					pgno = (uint)(sqlite3Get4byte(apDiv[i]));
					szNew[i] = (int)(pParent.xCellSize(pParent, apDiv[i]));
					pParent.nOverflow = (byte)(0);
				}
				else
				{
					apDiv[i] = ((pParent).aData + ((pParent).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pParent).aCellIdx[2 * (i + nxDiv - pParent.nOverflow)])))));
					pgno = (uint)(sqlite3Get4byte(apDiv[i]));
					szNew[i] = (int)(pParent.xCellSize(pParent, apDiv[i]));
					if ((pBt.btsFlags & 0x000c) != 0)
					{
						int iOff = 0;
						iOff = (int)(((int)((long)(apDiv[i]))) - ((int)((long)(pParent.aData))));
						if ((iOff + szNew[i]) <= ((int)(pBt.usableSize)))
						{
							CRuntime.memcpy(&aOvflSpace[iOff], apDiv[i], (ulong)(szNew[i]));
							apDiv[i] = &aOvflSpace[apDiv[i] - pParent.aData];
						}
					}

					dropCell(pParent, (int)(i + nxDiv - pParent.nOverflow), (int)(szNew[i]), &rc);
				}
			}

			nMaxCells = (int)((nMaxCells + 3) & ~3);
			szScratch = (int)(nMaxCells * sizeof(byte) + nMaxCells * sizeof(ushort) + pBt.pageSize);
			b.apCell = sqlite3DbMallocRaw(null, (ulong)(szScratch));
			if ((b.apCell) == (null))
			{
				rc = (int)(7);
				goto balance_cleanup;
			}

			b.szCell = (ushort*)(&b.apCell[nMaxCells]);
			aSpace1 = (byte*)(&b.szCell[nMaxCells]);
			b.pRef = apOld[0];
			leafCorrection = (ushort)(b.pRef.leaf * 4);
			leafData = (int)(b.pRef.intKeyLeaf);
			for (i = (int)(0); (i) < (nOld); i++)
			{
				MemPage pOld = apOld[i];
				int limit = (int)(pOld.nCell);
				byte* aData = pOld.aData;
				ushort maskPage = (ushort)(pOld.maskPage);
				byte* piCell = aData + pOld.cellOffset;
				byte* piEnd;
				if (pOld.aData[0] != apOld[0].aData[0])
				{
					rc = (int)(sqlite3CorruptError((int)(74064)));
					goto balance_cleanup;
				}

				CRuntime.memset(&b.szCell[b.nCell], (int)(0), (ulong)(sizeof(ushort) * (limit + pOld.nOverflow)));
				if ((pOld.nOverflow) > (0))
				{
					if (((limit) < (pOld.aiOvfl[0])))
					{
						rc = (int)(sqlite3CorruptError((int)(74088)));
						goto balance_cleanup;
					}

					limit = (int)(pOld.aiOvfl[0]);
					for (j = (int)(0); (j) < (limit); j++)
					{
						b.apCell[b.nCell] = aData + (maskPage & _byteswap_ushort((ushort)(*(ushort*)(piCell))));
						piCell += 2;
						b.nCell++;
					}

					for (k = (int)(0); (k) < (pOld.nOverflow); k++)
					{
						b.apCell[b.nCell] = pOld.apOvfl[k];
						b.nCell++;
					}
				}

				piEnd = aData + pOld.cellOffset + 2 * pOld.nCell;
				while ((piCell) < (piEnd))
				{
					b.apCell[b.nCell] = aData + (maskPage & _byteswap_ushort((ushort)(*(ushort*)(piCell))));
					piCell += 2;
					b.nCell++;
				}

				cntOld[i] = (int)(b.nCell);
				if (((i) < (nOld - 1)) && (leafData == 0))
				{
					ushort sz = (ushort)(szNew[i]);
					byte* pTemp;
					b.szCell[b.nCell] = (ushort)(sz);
					pTemp = &aSpace1[iSpace1];
					iSpace1 += (int)(sz);
					CRuntime.memcpy(pTemp, apDiv[i], (ulong)(sz));
					b.apCell[b.nCell] = pTemp + leafCorrection;
					b.szCell[b.nCell] = (ushort)(b.szCell[b.nCell] - leafCorrection);
					if (pOld.leaf == 0)
					{
						CRuntime.memcpy(b.apCell[b.nCell], &pOld.aData[8], (ulong)(4));
					}
					else
					{
						while ((b.szCell[b.nCell]) < (4))
						{
							aSpace1[iSpace1++] = (byte)(0x00);
							b.szCell[b.nCell]++;
						}
					}

					b.nCell++;
				}
			}

			usableSpace = (int)(pBt.usableSize - 12 + leafCorrection);
			for (i = (int)(k = (int)(0)); (i) < (nOld); i++, k++)
			{
				MemPage p = apOld[i];
				b.apEnd[k] = p.aDataEnd;
				b.ixNx[k] = (int)(cntOld[i]);
				if (((k) != 0) && ((b.ixNx[k]) == (b.ixNx[k - 1])))
				{
					k--;
				}

				if (leafData == 0)
				{
					k++;
					b.apEnd[k] = pParent.aDataEnd;
					b.ixNx[k] = (int)(cntOld[i] + 1);
				}

				szNew[i] = (int)(usableSpace - p.nFree);
				for (j = (int)(0); (j) < (p.nOverflow); j++)
				{
					szNew[i] += (int)(2 + p.xCellSize(p, p.apOvfl[j]));
				}

				cntNew[i] = (int)(cntOld[i]);
			}

			k = (int)(nOld);
			for (i = (int)(0); (i) < (k); i++)
			{
				int sz = 0;
				while ((szNew[i]) > (usableSpace))
				{
					if ((i + 1) >= (k))
					{
						k = (int)(i + 2);
						if ((k) > (3 + 2))
						{
							rc = (int)(sqlite3CorruptError((int)(74189)));
							goto balance_cleanup;
						}

						szNew[k - 1] = (int)(0);
						cntNew[k - 1] = (int)(b.nCell);
					}

					sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i] - 1)));
					szNew[i] -= (int)(sz);
					if (leafData == 0)
					{
						if ((cntNew[i]) < (b.nCell))
						{
							sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
						}
						else
						{
							sz = (int)(0);
						}
					}

					szNew[i + 1] += (int)(sz);
					cntNew[i]--;
				}

				while ((cntNew[i]) < (b.nCell))
				{
					sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
					if ((szNew[i] + sz) > (usableSpace))
						break;
					szNew[i] += (int)(sz);
					cntNew[i]++;
					if (leafData == 0)
					{
						if ((cntNew[i]) < (b.nCell))
						{
							sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
						}
						else
						{
							sz = (int)(0);
						}
					}

					szNew[i + 1] -= (int)(sz);
				}

				if ((cntNew[i]) >= (b.nCell))
				{
					k = (int)(i + 1);
				}
				else if ((cntNew[i]) <= ((i) > (0) ? cntNew[i - 1] : 0))
				{
					rc = (int)(sqlite3CorruptError((int)(74222)));
					goto balance_cleanup;
				}
			}

			for (i = (int)(k - 1); (i) > (0); i--)
			{
				int szRight = (int)(szNew[i]);
				int szLeft = (int)(szNew[i - 1]);
				int r = 0;
				int d = 0;
				r = (int)(cntNew[i - 1] - 1);
				d = (int)(r + 1 - leafData);
				(void)(cachedCellSize(b, (int)(d)));
				do
				{
					(void)(cachedCellSize(b, (int)(r)));
					if ((szRight != 0) && (((bBulk) != 0) || ((szRight + b.szCell[d] + 2) > (szLeft - (b.szCell[r] + ((i) == (k - 1) ? 0 : 2))))))
					{
						break;
					}

					szRight += (int)(b.szCell[d] + 2);
					szLeft -= (int)(b.szCell[r] + 2);
					cntNew[i - 1] = (int)(r);
					r--;
					d--;
				}
				while ((r) >= (0));
				szNew[i] = (int)(szRight);
				szNew[i - 1] = (int)(szLeft);
				if ((cntNew[i - 1]) <= ((i) > (1) ? cntNew[i - 2] : 0))
				{
					rc = (int)(sqlite3CorruptError((int)(74264)));
					goto balance_cleanup;
				}
			}

			pageFlags = (int)(apOld[0].aData[0]);
			for (i = (int)(0); (i) < (k); i++)
			{
				MemPage pNew;
				if ((i) < (nOld))
				{
					pNew = apNew[i] = apOld[i];
					apOld[i] = null;
					rc = (int)(sqlite3PagerWrite(pNew.pDbPage));
					nNew++;
					if ((sqlite3PagerPageRefcount(pNew.pDbPage) != 1 + ((i) == (iParentIdx - nxDiv))) && ((rc) == (0)))
					{
						rc = (int)(sqlite3CorruptError((int)(74297)));
					}

					if ((rc) != 0)
						goto balance_cleanup;
				}
				else
				{
					rc = (int)(allocateBtreePage(pBt, pNew, &pgno, (uint)((bBulk) != 0 ? 1 : pgno), (byte)(0)));
					if ((rc) != 0)
						goto balance_cleanup;
					zeroPage(pNew, (int)(pageFlags));
					apNew[i] = pNew;
					nNew++;
					cntOld[i] = (int)(b.nCell);
					if ((pBt.autoVacuum) != 0)
					{
						ptrmapPut(pBt, (uint)(pNew.pgno), (byte)(5), (uint)(pParent.pgno), &rc);
						if (rc != 0)
						{
							goto balance_cleanup;
						}
					}
				}
			}

			for (i = (int)(0); (i) < (nNew); i++)
			{
				aPgOrder[i] = (uint)(aPgno[i] = (uint)(apNew[i].pgno));
				aPgFlags[i] = (ushort)(apNew[i].pDbPage.flags);
				for (j = (int)(0); (j) < (i); j++)
				{
					if (((aPgno[j]) == (aPgno[i])))
					{
						rc = (int)(sqlite3CorruptError((int)(74343)));
						goto balance_cleanup;
					}
				}
			}

			for (i = (int)(0); (i) < (nNew); i++)
			{
				int iBest = (int)(0);
				for (j = (int)(1); (j) < (nNew); j++)
				{
					if ((aPgOrder[j]) < (aPgOrder[iBest]))
						iBest = (int)(j);
				}

				pgno = (uint)(aPgOrder[iBest]);
				aPgOrder[iBest] = (uint)(0xffffffff);
				if (iBest != i)
				{
					if ((iBest) > (i))
					{
						sqlite3PagerRekey(apNew[iBest].pDbPage, (uint)(pBt.nPage + iBest + 1), (ushort)(0));
					}

					sqlite3PagerRekey(apNew[i].pDbPage, (uint)(pgno), (ushort)(aPgFlags[iBest]));
					apNew[i].pgno = (uint)(pgno);
				}
			}

			sqlite3Put4byte(pRight, (uint)(apNew[nNew - 1].pgno));
			if (((pageFlags & 0x08) == (0)) && (nOld != nNew))
			{
				MemPage pOld = ((nNew) > (nOld) ? apNew : apOld)[nOld - 1];
				CRuntime.memcpy(&apNew[nNew - 1].aData[8], &pOld.aData[8], (ulong)(4));
			}

			if ((pBt.autoVacuum) != 0)
			{
				MemPage pOld;
				MemPage pNew = pOld = apNew[0];
				int cntOldNext = (int)(pNew.nCell + pNew.nOverflow);
				int iNew = (int)(0);
				int iOld = (int)(0);
				for (i = (int)(0); (i) < (b.nCell); i++)
				{
					byte* pCell = b.apCell[i];
					while ((i) == (cntOldNext))
					{
						iOld++;
						pOld = (iOld) < (nNew) ? apNew[iOld] : apOld[iOld];
						cntOldNext += (int)(pOld.nCell + pOld.nOverflow + !leafData);
					}

					if ((i) == (cntNew[iNew]))
					{
						pNew = apNew[++iNew];
						if (leafData == 0)
							continue;
					}

					if ((((iOld) >= (nNew)) || (pNew.pgno != aPgno[iOld])) || (!((((ulong)(pCell)) >= ((ulong)(pOld.aData))) && (((ulong)(pCell)) < ((ulong)(pOld.aDataEnd))))))
					{
						if (leafCorrection == 0)
						{
							ptrmapPut(pBt, (uint)(sqlite3Get4byte(pCell)), (byte)(5), (uint)(pNew.pgno), &rc);
						}

						if ((cachedCellSize(b, (int)(i))) > (pNew.minLocal))
						{
							ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);
						}

						if ((rc) != 0)
							goto balance_cleanup;
					}
				}
			}

			for (i = (int)(0); (i) < (nNew - 1); i++)
			{
				byte* pCell;
				byte* pTemp;
				int sz = 0;
				byte* pSrcEnd;
				MemPage pNew = apNew[i];
				j = (int)(cntNew[i]);
				pCell = b.apCell[j];
				sz = (int)(b.szCell[j] + leafCorrection);
				pTemp = &aOvflSpace[iOvflSpace];
				if (pNew.leaf == 0)
				{
					CRuntime.memcpy(&pNew.aData[8], pCell, (ulong)(4));
				}
				else if ((leafData) != 0)
				{
					CellInfo info = new CellInfo();
					j--;
					pNew.xParseCell(pNew, b.apCell[j], &info);
					pCell = pTemp;
					sz = (int)(4 + sqlite3PutVarint(&pCell[4], (ulong)(info.nKey)));
					pTemp = null;
				}
				else
				{
					pCell -= 4;
					if ((b.szCell[j]) == (4))
					{
						sz = (int)(pParent.xCellSize(pParent, pCell));
					}
				}

				iOvflSpace += (int)(sz);
				for (k = (int)(0); ((b.ixNx[k]) <= (i)) && ((k) < (3 * 2)); k++)
				{
				}

				pSrcEnd = b.apEnd[k];
				if (((((ulong)(pSrcEnd)) >= ((ulong)(pCell))) && (((ulong)(pSrcEnd)) < ((ulong)(pCell + sz)))))
				{
					rc = (int)(sqlite3CorruptError((int)(74500)));
					goto balance_cleanup;
				}

				insertCell(pParent, (int)(nxDiv + i), pCell, (int)(sz), pTemp, (uint)(pNew.pgno), &rc);
				if (rc != 0)
					goto balance_cleanup;
			}

			for (i = (int)(1 - nNew); (i) < (nNew); i++)
			{
				int iPg = (int)((i) < (0) ? -i : i);
				if ((abDone[iPg]) != 0)
					continue;
				if (((i) >= (0)) || ((cntOld[iPg - 1]) >= (cntNew[iPg - 1])))
				{
					int iNew = 0;
					int iOld = 0;
					int nNewCell = 0;
					if ((iPg) == (0))
					{
						iNew = (int)(iOld = (int)(0));
						nNewCell = (int)(cntNew[0]);
					}
					else
					{
						iOld = (int)((iPg) < (nOld) ? (cntOld[iPg - 1] + !leafData) : b.nCell);
						iNew = (int)(cntNew[iPg - 1] + !leafData);
						nNewCell = (int)(cntNew[iPg] - iNew);
					}

					rc = (int)(editPage(apNew[iPg], (int)(iOld), (int)(iNew), (int)(nNewCell), b));
					if ((rc) != 0)
						goto balance_cleanup;
					abDone[iPg]++;
					apNew[iPg].nFree = (int)(usableSpace - szNew[iPg]);
				}
			}

			if ((((isRoot) != 0) && ((pParent.nCell) == (0))) && ((pParent.hdrOffset) <= (apNew[0].nFree)))
			{
				rc = (int)(defragmentPage(apNew[0], (int)(-1)));
				copyNodeContent(apNew[0], pParent, &rc);
				freePage(apNew[0], &rc);
			}
			else if (((pBt.autoVacuum) != 0) && (leafCorrection == 0))
			{
				for (i = (int)(0); (i) < (nNew); i++)
				{
					uint key = (uint)(sqlite3Get4byte(&apNew[i].aData[8]));
					ptrmapPut(pBt, (uint)(key), (byte)(5), (uint)(apNew[i].pgno), &rc);
				}
			}

			for (i = (int)(nNew); (i) < (nOld); i++)
			{
				freePage(apOld[i], &rc);
			}

		balance_cleanup:
			; sqlite3DbFree(null, b.apCell);
			for (i = (int)(0); (i) < (nOld); i++)
			{
				releasePage(apOld[i]);
			}

			for (i = (int)(0); (i) < (nNew); i++)
			{
				releasePage(apNew[i]);
			}

			return (int)(rc);
		}
		public static int balance_quick(MemPage pParent, MemPage pPage, byte* pSpace)
		{
			BtShared pBt = pPage.pBt;
			MemPage pNew;
			int rc = 0;
			uint pgnoNew = 0;
			if ((pPage.nCell) == (0))
				return (int)(sqlite3CorruptError((int)(73641)));
			rc = (int)(allocateBtreePage(pBt, pNew, &pgnoNew, (uint)(0), (byte)(0)));
			if ((rc) == (0))
			{
				byte* pOut = &pSpace[4];
				byte* pCell = pPage.apOvfl[0];
				ushort szCell = (ushort)(pPage.xCellSize(pPage, pCell));
				byte* pStop;
				CellArray b = new CellArray();
				zeroPage(pNew, (int)(0x01 | 0x04 | 0x08));
				b.nCell = (int)(1);
				b.pRef = pPage;
				b.apCell = &pCell;
				b.szCell = &szCell;
				b.apEnd[0] = pPage.aDataEnd;
				b.ixNx[0] = (int)(2);
				rc = (int)(rebuildPage(b, (int)(0), (int)(1), pNew));
				if ((rc) != 0)
				{
					releasePage(pNew);
					return (int)(rc);
				}

				pNew.nFree = (int)(pBt.usableSize - pNew.cellOffset - 2 - szCell);
				if ((pBt.autoVacuum) != 0)
				{
					ptrmapPut(pBt, (uint)(pgnoNew), (byte)(5), (uint)(pParent.pgno), &rc);
					if ((szCell) > (pNew.minLocal))
					{
						ptrmapPutOvflPtr(pNew, pNew, pCell, &rc);
					}
				}

				pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (pPage.nCell - 1)])))));
				pStop = &pCell[9];
				while (((*(pCell++) & 0x80) != 0) && ((pCell) < (pStop)))
				{
				}

				pStop = &pCell[9];
				while ((((*(pOut++) = (byte)(*(pCell++))) & 0x80) != 0) && ((pCell) < (pStop)))
				{
				}

				if ((rc) == (0))
				{
					insertCell(pParent, (int)(pParent.nCell), pSpace, (int)(pOut - pSpace), null, (uint)(pPage.pgno), &rc);
				}

				sqlite3Put4byte(&pParent.aData[pParent.hdrOffset + 8], (uint)(pgnoNew));
				releasePage(pNew);
			}

			return (int)(rc);
		}
		public static int btreeCellSizeCheck(MemPage pPage)
		{
			int iCellFirst = 0;
			int iCellLast = 0;
			int i = 0;
			int sz = 0;
			int pc = 0;
			byte* data;
			int usableSize = 0;
			int cellOffset = 0;
			iCellFirst = (int)(pPage.cellOffset + 2 * pPage.nCell);
			usableSize = (int)(pPage.pBt.usableSize);
			iCellLast = (int)(usableSize - 4);
			data = pPage.aData;
			cellOffset = (int)(pPage.cellOffset);
			if (pPage.leaf == 0)
				iCellLast--;
			for (i = (int)(0); (i) < (pPage.nCell); i++)
			{
				pc = (int)(_byteswap_ushort((ushort)(*(ushort*)(&data[cellOffset + i * 2]))));
				if (((pc) < (iCellFirst)) || ((pc) > (iCellLast)))
				{
					return (int)(sqlite3CorruptError((int)(68174)));
				}

				sz = (int)(pPage.xCellSize(pPage, &data[pc]));
				if ((pc + sz) > (usableSize))
				{
					return (int)(sqlite3CorruptError((int)(68179)));
				}
			}

			return (int)(0);
		}
		public static int btreeComputeFreeSpace(MemPage pPage)
		{
			int pc = 0;
			byte hdr = 0;
			byte* data;
			int usableSize = 0;
			int nFree = 0;
			int top = 0;
			int iCellFirst = 0;
			int iCellLast = 0;
			usableSize = (int)(pPage.pBt.usableSize);
			hdr = (byte)(pPage.hdrOffset);
			data = pPage.aData;
			top = (int)(((((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]) - 1) & 0xffff) + 1);
			iCellFirst = (int)(hdr + 8 + pPage.childPtrSize + 2 * pPage.nCell);
			iCellLast = (int)(usableSize - 4);
			pc = (int)((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);
			nFree = (int)(data[hdr + 7] + top);
			if ((pc) > (0))
			{
				uint next = 0;
				uint size = 0;
				if ((pc) < (top))
				{
					return (int)(sqlite3CorruptError((int)(68112)));
				}

				while ((1) != 0)
				{
					if ((pc) > (iCellLast))
					{
						return (int)(sqlite3CorruptError((int)(68117)));
					}

					next = (uint)((&data[pc])[0] << 8 | (&data[pc])[1]);
					size = (uint)((&data[pc + 2])[0] << 8 | (&data[pc + 2])[1]);
					nFree = (int)(nFree + size);
					if ((next) <= (pc + size + 3))
						break;
					pc = (int)(next);
				}

				if ((next) > (0))
				{
					return (int)(sqlite3CorruptError((int)(68127)));
				}

				if ((pc + size) > ((uint)(usableSize)))
				{
					return (int)(sqlite3CorruptError((int)(68131)));
				}
			}

			if (((nFree) > (usableSize)) || ((nFree) < (iCellFirst)))
			{
				return (int)(sqlite3CorruptError((int)(68143)));
			}

			pPage.nFree = (int)((ushort)(nFree - iCellFirst));
			return (int)(0);
		}
		public static int btreeInitPage(MemPage pPage)
		{
			byte* data;
			BtShared pBt;
			pBt = pPage.pBt;
			data = pPage.aData + pPage.hdrOffset;
			if ((decodeFlags(pPage, (int)(data[0]))) != 0)
			{
				return (int)(sqlite3CorruptError((int)(68211)));
			}

			pPage.maskPage = ((ushort)(pBt.pageSize - 1));
			pPage.nOverflow = (byte)(0);
			pPage.cellOffset = (ushort)(pPage.hdrOffset + 8 + pPage.childPtrSize);
			pPage.aCellIdx = data + pPage.childPtrSize + 8;
			pPage.aDataEnd = pPage.aData + pBt.pageSize;
			pPage.aDataOfst = pPage.aData + pPage.childPtrSize;
			pPage.nCell = (ushort)((&data[3])[0] << 8 | (&data[3])[1]);
			if ((pPage.nCell) > ((pBt.pageSize - 8) / 6))
			{
				return (int)(sqlite3CorruptError((int)(68225)));
			}

			pPage.nFree = (int)(-1);
			pPage.isInit = (byte)(1);
			if ((pBt.db.flags & 0x00200000) != 0)
			{
				return (int)(btreeCellSizeCheck(pPage));
			}

			return (int)(0);
		}
		public static int btreeOverwriteContent(MemPage pPage, byte* pDest, BtreePayload pX, int iOffset, int iAmt)
		{
			int nData = (int)(pX.nData - iOffset);
			if ((nData) <= (0))
			{
				int i = 0;
				for (i = (int)(0); ((i) < (iAmt)) && ((pDest[i]) == (0)); i++)
				{
				}

				if ((i) < (iAmt))
				{
					int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
					if ((rc) != 0)
						return (int)(rc);
					CRuntime.memset(pDest + i, (int)(0), (ulong)(iAmt - i));
				}
			}
			else
			{
				if ((nData) < (iAmt))
				{
					int rc = (int)(btreeOverwriteContent(pPage, pDest + nData, pX, (int)(iOffset + nData), (int)(iAmt - nData)));
					if ((rc) != 0)
						return (int)(rc);
					iAmt = (int)(nData);
				}

				if (memcmp(pDest, ((byte*)(pX.pData)) + iOffset, (ulong)(iAmt)) != 0)
				{
					int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
					if ((rc) != 0)
						return (int)(rc);
					CRuntime.memmove(pDest, ((byte*)(pX.pData)) + iOffset, (ulong)(iAmt));
				}
			}

			return (int)(0);
		}
		public static void btreeParseCell(MemPage pPage, int iCell, CellInfo* pInfo)
		{
			pPage.xParseCell(pPage, ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (iCell)]))))), pInfo);
		}
		public static void btreeParseCellAdjustSizeForOverflow(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			int minLocal = 0;
			int maxLocal = 0;
			int surplus = 0;
			minLocal = (int)(pPage.minLocal);
			maxLocal = (int)(pPage.maxLocal);
			surplus = (int)(minLocal + (pInfo->nPayload - minLocal) % (pPage.pBt.usableSize - 4));
			if ((surplus) <= (maxLocal))
			{
				pInfo->nLocal = ((ushort)(surplus));
			}
			else
			{
				pInfo->nLocal = ((ushort)(minLocal));
			}

			pInfo->nSize = (ushort)((ushort)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4);
		}
		public static void btreeParseCellPtr(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			byte* pIter;
			uint nPayload = 0;
			ulong iKey = 0;
			pIter = pCell;
			nPayload = (uint)(*pIter);
			if ((nPayload) >= (0x80))
			{
				byte* pEnd = &pIter[8];
				nPayload &= (uint)(0x7f);
				do
				{
					nPayload = (uint)((nPayload << 7) | (*++pIter & 0x7f));
				}
				while (((*pIter) >= (0x80)) && ((pIter) < (pEnd)));
			}

			pIter++;
			iKey = (ulong)(*pIter);
			if ((iKey) >= (0x80))
			{
				byte x = 0;
				iKey = (ulong)(((iKey & 0x7f) << 7) | ((x = (byte)(*++pIter)) & 0x7f));
				if ((x) >= (0x80))
				{
					iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
					if ((x) >= (0x80))
					{
						iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
						if ((x) >= (0x80))
						{
							iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
							if ((x) >= (0x80))
							{
								iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
								if ((x) >= (0x80))
								{
									iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
									if ((x) >= (0x80))
									{
										iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
										if ((x) >= (0x80))
										{
											iKey = (ulong)((iKey << 8) | (*++pIter));
										}
									}
								}
							}
						}
					}
				}
			}

			pIter++;
			pInfo->nKey = (long)(*(long*)(&iKey));
			pInfo->nPayload = (uint)(nPayload);
			pInfo->pPayload = pIter;
			if ((nPayload) <= (pPage.maxLocal))
			{
				pInfo->nSize = (ushort)(nPayload + (ushort)(pIter - pCell));
				if ((pInfo->nSize) < (4))
					pInfo->nSize = (ushort)(4);
				pInfo->nLocal = ((ushort)(nPayload));
			}
			else
			{
				btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
			}
		}
		public static void btreeParseCellPtrIndex(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			byte* pIter;
			uint nPayload = 0;
			pIter = pCell + pPage.childPtrSize;
			nPayload = (uint)(*pIter);
			if ((nPayload) >= (0x80))
			{
				byte* pEnd = &pIter[8];
				nPayload &= (uint)(0x7f);
				do
				{
					nPayload = (uint)((nPayload << 7) | (*++pIter & 0x7f));
				}
				while (((*(pIter)) >= (0x80)) && ((pIter) < (pEnd)));
			}

			pIter++;
			pInfo->nKey = (long)(nPayload);
			pInfo->nPayload = (uint)(nPayload);
			pInfo->pPayload = pIter;
			if ((nPayload) <= (pPage.maxLocal))
			{
				pInfo->nSize = (ushort)(nPayload + (ushort)(pIter - pCell));
				if ((pInfo->nSize) < (4))
					pInfo->nSize = (ushort)(4);
				pInfo->nLocal = ((ushort)(nPayload));
			}
			else
			{
				btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
			}
		}
		public static void btreeParseCellPtrNoPayload(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			pInfo->nSize = (ushort)(4 + sqlite3GetVarint(&pCell[4], (ulong*)(&pInfo->nKey)));
			pInfo->nPayload = (uint)(0);
			pInfo->nLocal = (ushort)(0);
			pInfo->pPayload = null;
			return;
		}
		public static int btreePayloadToLocal(MemPage pPage, long nPayload)
		{
			int maxLocal = 0;
			maxLocal = (int)(pPage.maxLocal);
			if ((nPayload) <= (maxLocal))
			{
				return (int)(nPayload);
			}
			else
			{
				int minLocal = 0;
				int surplus = 0;
				minLocal = (int)(pPage.minLocal);
				surplus = (int)(minLocal + (nPayload - minLocal) % (pPage.pBt.usableSize - 4));
				return (int)(((surplus) <= (maxLocal)) ? surplus : minLocal);
			}
		}
		public static ushort cellSizePtr(MemPage pPage, byte* pCell)
		{
			byte* pIter = pCell + pPage.childPtrSize;
			byte* pEnd;
			uint nSize = 0;
			nSize = (uint)(*pIter);
			if ((nSize) >= (0x80))
			{
				pEnd = &pIter[8];
				nSize &= (uint)(0x7f);
				do
				{
					nSize = (uint)((nSize << 7) | (*++pIter & 0x7f));
				}
				while (((*(pIter)) >= (0x80)) && ((pIter) < (pEnd)));
			}

			pIter++;
			if ((pPage.intKey) != 0)
			{
				pEnd = &pIter[9];
				while ((((*pIter++) & 0x80) != 0) && ((pIter) < (pEnd)))
				{
				}
			}

			if ((nSize) <= (pPage.maxLocal))
			{
				nSize += ((uint)(pIter - pCell));
				if ((nSize) < (4))
					nSize = (uint)(4);
			}
			else
			{
				int minLocal = (int)(pPage.minLocal);
				nSize = (uint)(minLocal + (nSize - minLocal) % (pPage.pBt.usableSize - 4));
				if ((nSize) > (pPage.maxLocal))
				{
					nSize = (uint)(minLocal);
				}

				nSize += (uint)(4 + (ushort)(pIter - pCell));
			}

			return (ushort)(nSize);
		}
		public static ushort cellSizePtrNoPayload(MemPage pPage, byte* pCell)
		{
			byte* pIter = pCell + 4;
			byte* pEnd;
			pEnd = pIter + 9;
			while ((((*pIter++) & 0x80) != 0) && ((pIter) < (pEnd)))
			{
			}

			return (ushort)(pIter - pCell);
		}
		public static int clearCellOverflow(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			BtShared pBt;
			uint ovflPgno = 0;
			int rc = 0;
			int nOvfl = 0;
			uint ovflPageSize = 0;
			if ((pCell + pInfo->nSize) > (pPage.aDataEnd))
			{
				return (int)(sqlite3CorruptError((int)(72724)));
			}

			ovflPgno = (uint)(sqlite3Get4byte(pCell + pInfo->nSize - 4));
			pBt = pPage.pBt;
			ovflPageSize = (uint)(pBt.usableSize - 4);
			nOvfl = (int)((pInfo->nPayload - pInfo->nLocal + ovflPageSize - 1) / ovflPageSize);
			while ((nOvfl--) != 0)
			{
				uint iNext = (uint)(0);
				MemPage pOvfl = null;
				if (((ovflPgno) < (2)) || ((ovflPgno) > (btreePagecount(pBt))))
				{
					return (int)(sqlite3CorruptError((int)(72741)));
				}

				if ((nOvfl) != 0)
				{
					rc = (int)(getOverflowPage(pBt, (uint)(ovflPgno), pOvfl, &iNext));
					if ((rc) != 0)
						return (int)(rc);
				}

				if ((((pOvfl) != null) || ((pOvfl = btreePageLookup(pBt, (uint)(ovflPgno))) != null)) && (sqlite3PagerPageRefcount(pOvfl.pDbPage) != 1))
				{
					rc = (int)(sqlite3CorruptError((int)(72761)));
				}
				else
				{
					rc = (int)(freePage2(pBt, pOvfl, (uint)(ovflPgno)));
				}

				if ((pOvfl) != null)
				{
					sqlite3PagerUnref(pOvfl.pDbPage);
				}

				if ((rc) != 0)
					return (int)(rc);
				ovflPgno = (uint)(iNext);
			}

			return (int)(0);
		}
		public static void copyNodeContent(MemPage pFrom, MemPage pTo, int* pRC)
		{
			if ((*pRC) == (0))
			{
				BtShared pBt = pFrom.pBt;
				byte* aFrom = pFrom.aData;
				byte* aTo = pTo.aData;
				int iFromHdr = (int)(pFrom.hdrOffset);
				int iToHdr = (int)(((pTo.pgno) == (1)) ? 100 : 0);
				int rc = 0;
				int iData = 0;
				iData = (int)((&aFrom[iFromHdr + 5])[0] << 8 | (&aFrom[iFromHdr + 5])[1]);
				CRuntime.memcpy(&aTo[iData], &aFrom[iData], (ulong)(pBt.usableSize - iData));
				CRuntime.memcpy(&aTo[iToHdr], &aFrom[iFromHdr], (ulong)(pFrom.cellOffset + 2 * pFrom.nCell));
				pTo.isInit = (byte)(0);
				rc = (int)(btreeInitPage(pTo));
				if ((rc) == (0))
					rc = (int)(btreeComputeFreeSpace(pTo));
				if (rc != 0)
				{
					*pRC = (int)(rc);
					return;
				}

				if ((pBt.autoVacuum) != 0)
				{
					*pRC = (int)(setChildPtrmaps(pTo));
				}
			}
		}
		public static int decodeFlags(MemPage pPage, int flagByte)
		{
			BtShared pBt;
			pPage.leaf = ((byte)(flagByte >> 3));
			flagByte &= (int)(~0x08);
			pPage.childPtrSize = (byte)(4 - 4 * pPage.leaf);
			pPage.xCellSize = cellSizePtr;
			pBt = pPage.pBt;
			if ((flagByte) == (0x04 | 0x01))
			{
				pPage.intKey = (byte)(1);
				if ((pPage.leaf) != 0)
				{
					pPage.intKeyLeaf = (byte)(1);
					pPage.xParseCell = btreeParseCellPtr;
				}
				else
				{
					pPage.intKeyLeaf = (byte)(0);
					pPage.xCellSize = cellSizePtrNoPayload;
					pPage.xParseCell = btreeParseCellPtrNoPayload;
				}

				pPage.maxLocal = (ushort)(pBt.maxLeaf);
				pPage.minLocal = (ushort)(pBt.minLeaf);
			}
			else if ((flagByte) == (0x02))
			{
				pPage.intKey = (byte)(0);
				pPage.intKeyLeaf = (byte)(0);
				pPage.xParseCell = btreeParseCellPtrIndex;
				pPage.maxLocal = (ushort)(pBt.maxLocal);
				pPage.minLocal = (ushort)(pBt.minLocal);
			}
			else
			{
				return (int)(sqlite3CorruptError((int)(68061)));
			}

			pPage.max1bytePayload = (byte)(pBt.max1bytePayload);
			return (int)(0);
		}
		public static int defragmentPage(MemPage pPage, int nMaxFrag)
		{
			int i = 0;
			int pc = 0;
			int hdr = 0;
			int size = 0;
			int usableSize = 0;
			int cellOffset = 0;
			int cbrk = 0;
			int nCell = 0;
			byte* data;
			byte* temp;
			byte* src;
			int iCellFirst = 0;
			int iCellLast = 0;
			int iCellStart = 0;
			temp = null;
			src = data = pPage.aData;
			hdr = (int)(pPage.hdrOffset);
			cellOffset = (int)(pPage.cellOffset);
			nCell = (int)(pPage.nCell);
			iCellFirst = (int)(cellOffset + 2 * nCell);
			usableSize = (int)(pPage.pBt.usableSize);
			if (((int)(data[hdr + 7])) <= (nMaxFrag))
			{
				int iFree = (int)((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);
				if ((iFree) > (usableSize - 4))
					return (int)(sqlite3CorruptError((int)(67648)));
				if ((iFree) != 0)
				{
					int iFree2 = (int)((&data[iFree])[0] << 8 | (&data[iFree])[1]);
					if ((iFree2) > (usableSize - 4))
						return (int)(sqlite3CorruptError((int)(67651)));
					if (((0) == (iFree2)) || (((data[iFree2]) == (0)) && ((data[iFree2 + 1]) == (0))))
					{
						byte* pEnd = &data[cellOffset + nCell * 2];
						byte* pAddr;
						int sz2 = (int)(0);
						int sz = (int)((&data[iFree + 2])[0] << 8 | (&data[iFree + 2])[1]);
						int top = (int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
						if ((top) >= (iFree))
						{
							return (int)(sqlite3CorruptError((int)(67659)));
						}

						if ((iFree2) != 0)
						{
							if ((iFree + sz) > (iFree2))
								return (int)(sqlite3CorruptError((int)(67662)));
							sz2 = (int)((&data[iFree2 + 2])[0] << 8 | (&data[iFree2 + 2])[1]);
							if ((iFree2 + sz2) > (usableSize))
								return (int)(sqlite3CorruptError((int)(67664)));
							CRuntime.memmove(&data[iFree + sz + sz2], &data[iFree + sz], (ulong)(iFree2 - (iFree + sz)));
							sz += (int)(sz2);
						}
						else if (((iFree + sz) > (usableSize)))
						{
							return (int)(sqlite3CorruptError((int)(67668)));
						}

						cbrk = (int)(top + sz);
						CRuntime.memmove(&data[cbrk], &data[top], (ulong)(iFree - top));
						for (pAddr = &data[cellOffset]; (pAddr) < (pEnd); pAddr += 2)
						{
							pc = (int)((pAddr)[0] << 8 | (pAddr)[1]);
							if ((pc) < (iFree))
							{
								((pAddr)[0] = ((byte)((pc + sz) >> 8)), (pAddr)[1] = ((byte)(pc + sz)));
							}
							else if ((pc) < (iFree2))
							{
								((pAddr)[0] = ((byte)((pc + sz2) >> 8)), (pAddr)[1] = ((byte)(pc + sz2)));
							}
						}

						goto defragment_out;
					}
				}
			}

			cbrk = (int)(usableSize);
			iCellLast = (int)(usableSize - 4);
			iCellStart = (int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
			for (i = (int)(0); (i) < (nCell); i++)
			{
				byte* pAddr;
				pAddr = &data[cellOffset + i * 2];
				pc = (int)((pAddr)[0] << 8 | (pAddr)[1]);
				if (((pc) < (iCellStart)) || ((pc) > (iCellLast)))
				{
					return (int)(sqlite3CorruptError((int)(67697)));
				}

				size = (int)(pPage.xCellSize(pPage, &src[pc]));
				cbrk -= (int)(size);
				if (((cbrk) < (iCellStart)) || ((pc + size) > (usableSize)))
				{
					return (int)(sqlite3CorruptError((int)(67703)));
				}

				((pAddr)[0] = ((byte)((cbrk) >> 8)), (pAddr)[1] = ((byte)(cbrk)));
				if ((temp) == (null))
				{
					if ((cbrk) == (pc))
						continue;
					temp = sqlite3PagerTempSpace(pPage.pBt.pPager);
					CRuntime.memcpy(&temp[iCellStart], &data[iCellStart], (ulong)(usableSize - iCellStart));
					src = temp;
				}

				CRuntime.memcpy(&data[cbrk], &src[pc], (ulong)(size));
			}

			data[hdr + 7] = (byte)(0);
		defragment_out:
			;
			if (data[hdr + 7] + cbrk - iCellFirst != pPage.nFree)
			{
				return (int)(sqlite3CorruptError((int)(67722)));
			}

			((&data[hdr + 5])[0] = ((byte)((cbrk) >> 8)), (&data[hdr + 5])[1] = ((byte)(cbrk)));
			data[hdr + 1] = (byte)(0);
			data[hdr + 2] = (byte)(0);
			CRuntime.memset(&data[iCellFirst], (int)(0), (ulong)(cbrk - iCellFirst));
			return (int)(0);
		}
		public static void dropCell(MemPage pPage, int idx, int sz, int* pRC)
		{
			uint pc = 0;
			byte* data;
			byte* ptr;
			int rc = 0;
			int hdr = 0;
			if ((*pRC) != 0)
				return;
			data = pPage.aData;
			ptr = &pPage.aCellIdx[2 * idx];
			pc = (uint)((ptr)[0] << 8 | (ptr)[1]);
			hdr = (int)(pPage.hdrOffset);
			if ((pc + sz) > (pPage.pBt.usableSize))
			{
				*pRC = (int)(sqlite3CorruptError((int)(73020)));
				return;
			}

			rc = (int)(freeSpace(pPage, (ushort)(pc), (ushort)(sz)));
			if ((rc) != 0)
			{
				*pRC = (int)(rc);
				return;
			}

			pPage.nCell--;
			if ((pPage.nCell) == (0))
			{
				CRuntime.memset(&data[hdr + 1], (int)(0), (ulong)(4));
				data[hdr + 7] = (byte)(0);
				((&data[hdr + 5])[0] = ((byte)((pPage.pBt.usableSize) >> 8)), (&data[hdr + 5])[1] = ((byte)(pPage.pBt.usableSize)));
				pPage.nFree = (int)(pPage.pBt.usableSize - pPage.hdrOffset - pPage.childPtrSize - 8);
			}
			else
			{
				CRuntime.memmove(ptr, ptr + 2, (ulong)(2 * (pPage.nCell - idx)));
				((&data[hdr + 3])[0] = ((byte)((pPage.nCell) >> 8)), (&data[hdr + 3])[1] = ((byte)(pPage.nCell)));
				pPage.nFree += (int)(2);
			}
		}
		public static int editPage(MemPage pPg, int iOld, int iNew, int nNew, CellArray pCArray)
		{
			byte* aData = pPg.aData;
			int hdr = (int)(pPg.hdrOffset);
			byte* pBegin = &pPg.aCellIdx[nNew * 2];
			int nCell = (int)(pPg.nCell);
			byte* pData;
			byte* pCellptr;
			int i = 0;
			int iOldEnd = (int)(iOld + pPg.nCell + pPg.nOverflow);
			int iNewEnd = (int)(iNew + nNew);
			if ((iOld) < (iNew))
			{
				int nShift = (int)(pageFreeArray(pPg, (int)(iOld), (int)(iNew - iOld), pCArray));
				if (((nShift) > (nCell)))
					return (int)(sqlite3CorruptError((int)(73528)));
				CRuntime.memmove(pPg.aCellIdx, &pPg.aCellIdx[nShift * 2], (ulong)(nCell * 2));
				nCell -= (int)(nShift);
			}

			if ((iNewEnd) < (iOldEnd))
			{
				int nTail = (int)(pageFreeArray(pPg, (int)(iNewEnd), (int)(iOldEnd - iNewEnd), pCArray));
				nCell -= (int)(nTail);
			}

			pData = &aData[(((((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1]) - 1) & 0xffff) + 1)];
			if ((pData) < (pBegin))
				goto editpage_fail;
			if ((pData) > (pPg.aDataEnd))
				goto editpage_fail;
			if ((iNew) < (iOld))
			{
				int nAdd = (int)((nNew) < (iOld - iNew) ? (nNew) : (iOld - iNew));
				pCellptr = pPg.aCellIdx;
				CRuntime.memmove(&pCellptr[nAdd * 2], pCellptr, (ulong)(nCell * 2));
				if ((pageInsertArray(pPg, pBegin, &pData, pCellptr, (int)(iNew), (int)(nAdd), pCArray)) != 0)
					goto editpage_fail;
				nCell += (int)(nAdd);
			}

			for (i = (int)(0); (i) < (pPg.nOverflow); i++)
			{
				int iCell = (int)((iOld + pPg.aiOvfl[i]) - iNew);
				if (((iCell) >= (0)) && ((iCell) < (nNew)))
				{
					pCellptr = &pPg.aCellIdx[iCell * 2];
					if ((nCell) > (iCell))
					{
						CRuntime.memmove(&pCellptr[2], pCellptr, (ulong)((nCell - iCell) * 2));
					}

					nCell++;
					cachedCellSize(pCArray, (int)(iCell + iNew));
					if ((pageInsertArray(pPg, pBegin, &pData, pCellptr, (int)(iCell + iNew), (int)(1), pCArray)) != 0)
						goto editpage_fail;
				}
			}

			pCellptr = &pPg.aCellIdx[nCell * 2];
			if ((pageInsertArray(pPg, pBegin, &pData, pCellptr, (int)(iNew + nCell), (int)(nNew - nCell), pCArray)) != 0)
				goto editpage_fail;
			pPg.nCell = (ushort)(nNew);
			pPg.nOverflow = (byte)(0);
			((&aData[hdr + 3])[0] = ((byte)((pPg.nCell) >> 8)), (&aData[hdr + 3])[1] = ((byte)(pPg.nCell)));
			((&aData[hdr + 5])[0] = ((byte)((pData - aData) >> 8)), (&aData[hdr + 5])[1] = ((byte)(pData - aData)));
			return (int)(0);
		editpage_fail:
			; populateCellCache(pCArray, (int)(iNew), (int)(nNew));
			return (int)(rebuildPage(pCArray, (int)(iNew), (int)(nNew), pPg));
		}
		public static int fillInCell(MemPage pPage, byte* pCell, BtreePayload pX, int* pnSize)
		{
			int nPayload = 0;
			byte* pSrc;
			int nSrc = 0; int n = 0; int rc = 0; int mn = 0;
			int spaceLeft = 0;
			MemPage pToRelease;
			byte* pPrior;
			byte* pPayload;
			BtShared pBt;
			uint pgnoOvfl = 0;
			int nHeader = 0;
			nHeader = (int)(pPage.childPtrSize);
			if ((pPage.intKey) != 0)
			{
				nPayload = (int)(pX.nData + pX.nZero);
				pSrc = pX.pData;
				nSrc = (int)(pX.nData);
				nHeader += (int)((byte)((((uint)(nPayload)) < ((uint)(0x80))) ? (*(&pCell[nHeader]) = ((byte)(nPayload))), 1 : 
        sqlite3PutVarint((&pCell[nHeader]), (ulong)(nPayload)) ) )
        ;
				nHeader += (int)(sqlite3PutVarint(&pCell[nHeader], (ulong)(*(ulong*)(&pX.nKey))));
			}
			else
			{
				nSrc = (int)(nPayload = ((int)(pX.nKey)));
				pSrc = pX.pKey;
				nHeader += (int)((byte)((((uint)(nPayload)) < ((uint)(0x80))) ? (*(&pCell[nHeader]) = ((byte)(nPayload))), 1 : 
        sqlite3PutVarint((&pCell[nHeader]), (ulong)(nPayload)) ) )
        ;
			}

			pPayload = &pCell[nHeader];
			if ((nPayload) <= (pPage.maxLocal))
			{
				n = (int)(nHeader + nPayload);
				if ((n) < (4))
					n = (int)(4);
				*pnSize = (int)(n);
				CRuntime.memcpy(pPayload, pSrc, (ulong)(nSrc));
				CRuntime.memset(pPayload + nSrc, (int)(0), (ulong)(nPayload - nSrc));
				return (int)(0);
			}

			mn = (int)(pPage.minLocal);
			n = (int)(mn + (nPayload - mn) % (pPage.pBt.usableSize - 4));
			if ((n) > (pPage.maxLocal))
				n = (int)(mn);
			spaceLeft = (int)(n);
			*pnSize = (int)(n + nHeader + 4);
			pPrior = &pCell[nHeader + n];
			pToRelease = null;
			pgnoOvfl = (uint)(0);
			pBt = pPage.pBt;
			while ((1) != 0)
			{
				n = (int)(nPayload);
				if ((n) > (spaceLeft))
					n = (int)(spaceLeft);
				if ((nSrc) >= (n))
				{
					CRuntime.memcpy(pPayload, pSrc, (ulong)(n));
				}
				else if ((nSrc) > (0))
				{
					n = (int)(nSrc);
					CRuntime.memcpy(pPayload, pSrc, (ulong)(n));
				}
				else
				{
					CRuntime.memset(pPayload, (int)(0), (ulong)(n));
				}

				nPayload -= (int)(n);
				if ((nPayload) <= (0))
					break;
				pPayload += n;
				pSrc += n;
				nSrc -= (int)(n);
				spaceLeft -= (int)(n);
				if ((spaceLeft) == (0))
				{
					MemPage pOvfl = null;
					uint pgnoPtrmap = (uint)(pgnoOvfl);
					if ((pBt.autoVacuum) != 0)
					{
						do
						{
							pgnoOvfl++;
						}
						while (((ptrmapPageno((pBt), (uint)(pgnoOvfl))) == (pgnoOvfl)) || ((pgnoOvfl) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)));
					}

					rc = (int)(allocateBtreePage(pBt, pOvfl, &pgnoOvfl, (uint)(pgnoOvfl), (byte)(0)));
					if (((pBt.autoVacuum) != 0) && ((rc) == (0)))
					{
						byte eType = (byte)((pgnoPtrmap) != 0 ? 4 : 3);
						ptrmapPut(pBt, (uint)(pgnoOvfl), (byte)(eType), (uint)(pgnoPtrmap), &rc);
						if ((rc) != 0)
						{
							releasePage(pOvfl);
						}
					}

					if ((rc) != 0)
					{
						releasePage(pToRelease);
						return (int)(rc);
					}

					sqlite3Put4byte(pPrior, (uint)(pgnoOvfl));
					releasePage(pToRelease);
					pToRelease = pOvfl;
					pPrior = pOvfl.aData;
					sqlite3Put4byte(pPrior, (uint)(0));
					pPayload = &pOvfl.aData[4];
					spaceLeft = (int)(pBt.usableSize - 4);
				}
			}

			releasePage(pToRelease);
			return (int)(0);
		}
		public static void freePage(MemPage pPage, int* pRC)
		{
			if ((*pRC) == (0))
			{
				*pRC = (int)(freePage2(pPage.pBt, pPage, (uint)(pPage.pgno)));
			}
		}
		public static int freeSpace(MemPage pPage, ushort iStart, ushort iSize)
		{
			ushort iPtr = 0;
			ushort iFreeBlk = 0;
			byte hdr = 0;
			byte nFrag = (byte)(0);
			ushort iOrigSize = (ushort)(iSize);
			ushort x = 0;
			uint iEnd = (uint)(iStart + iSize);
			byte* data = pPage.aData;
			hdr = (byte)(pPage.hdrOffset);
			iPtr = (ushort)(hdr + 1);
			if (((data[iPtr + 1]) == (0)) && ((data[iPtr]) == (0)))
			{
				iFreeBlk = (ushort)(0);
			}
			else
			{
				while ((iFreeBlk = (ushort)((&data[iPtr])[0] << 8 | (&data[iPtr])[1])) < (iStart))
				{
					if ((iFreeBlk) < (iPtr + 4))
					{
						if ((iFreeBlk) == (0))
							break;
						return (int)(sqlite3CorruptError((int)(67940)));
					}

					iPtr = (ushort)(iFreeBlk);
				}

				if ((iFreeBlk) > (pPage.pBt.usableSize - 4))
				{
					return (int)(sqlite3CorruptError((int)(67945)));
				}

				if (((iFreeBlk) != 0) && ((iEnd + 3) >= (iFreeBlk)))
				{
					nFrag = (byte)(iFreeBlk - iEnd);
					if ((iEnd) > (iFreeBlk))
						return (int)(sqlite3CorruptError((int)(67957)));
					iEnd = (uint)(iFreeBlk + ((&data[iFreeBlk + 2])[0] << 8 | (&data[iFreeBlk + 2])[1]));
					if ((iEnd) > (pPage.pBt.usableSize))
					{
						return (int)(sqlite3CorruptError((int)(67960)));
					}

					iSize = (ushort)(iEnd - iStart);
					iFreeBlk = (ushort)((&data[iFreeBlk])[0] << 8 | (&data[iFreeBlk])[1]);
				}

				if ((iPtr) > (hdr + 1))
				{
					int iPtrEnd = (int)(iPtr + ((&data[iPtr + 2])[0] << 8 | (&data[iPtr + 2])[1]));
					if ((iPtrEnd + 3) >= (iStart))
					{
						if ((iPtrEnd) > (iStart))
							return (int)(sqlite3CorruptError((int)(67973)));
						nFrag += (byte)(iStart - iPtrEnd);
						iSize = (ushort)(iEnd - iPtr);
						iStart = (ushort)(iPtr);
					}
				}

				if ((nFrag) > (data[hdr + 7]))
					return (int)(sqlite3CorruptError((int)(67979)));
				data[hdr + 7] -= (byte)(nFrag);
			}

			x = (ushort)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
			if ((iStart) <= (x))
			{
				if ((iStart) < (x))
					return (int)(sqlite3CorruptError((int)(67987)));
				if (iPtr != hdr + 1)
					return (int)(sqlite3CorruptError((int)(67988)));
				((&data[hdr + 1])[0] = ((byte)((iFreeBlk) >> 8)), (&data[hdr + 1])[1] = ((byte)(iFreeBlk)));
				((&data[hdr + 5])[0] = ((byte)((iEnd) >> 8)), (&data[hdr + 5])[1] = ((byte)(iEnd)));
			}
			else
			{
				((&data[iPtr])[0] = ((byte)((iStart) >> 8)), (&data[iPtr])[1] = ((byte)(iStart)));
			}

			if ((pPage.pBt.btsFlags & 0x000c) != 0)
			{
				CRuntime.memset(&data[iStart], (int)(0), (ulong)(iSize));
			}

			((&data[iStart])[0] = ((byte)((iFreeBlk) >> 8)), (&data[iStart])[1] = ((byte)(iFreeBlk)));
			((&data[iStart + 2])[0] = ((byte)((iSize) >> 8)), (&data[iStart + 2])[1] = ((byte)(iSize)));
			pPage.nFree += (int)(iOrigSize);
			return (int)(0);
		}
		public static void insertCell(MemPage pPage, int i, byte* pCell, int sz, byte* pTemp, uint iChild, int* pRC)
		{
			int idx = (int)(0);
			int j = 0;
			byte* data;
			byte* pIns;
			if (((pPage.nOverflow) != 0) || ((sz + 2) > (pPage.nFree)))
			{
				if ((pTemp) != null)
				{
					CRuntime.memcpy(pTemp, pCell, (ulong)(sz));
					pCell = pTemp;
				}

				if ((iChild) != 0)
				{
					sqlite3Put4byte(pCell, (uint)(iChild));
				}

				j = (int)(pPage.nOverflow++);
				pPage.apOvfl[j] = pCell;
				pPage.aiOvfl[j] = ((ushort)(i));
			}
			else
			{
				int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
				if (rc != 0)
				{
					*pRC = (int)(rc);
					return;
				}

				data = pPage.aData;
				rc = (int)(allocateSpace(pPage, (int)(sz), &idx));
				if ((rc) != 0)
				{
					*pRC = (int)(rc);
					return;
				}

				pPage.nFree -= (int)((ushort)(2 + sz));
				if ((iChild) != 0)
				{
					CRuntime.memcpy(&data[idx + 4], pCell + 4, (ulong)(sz - 4));
					sqlite3Put4byte(&data[idx], (uint)(iChild));
				}
				else
				{
					CRuntime.memcpy(&data[idx], pCell, (ulong)(sz));
				}

				pIns = pPage.aCellIdx + i * 2;
				CRuntime.memmove(pIns + 2, pIns, (ulong)(2 * (pPage.nCell - i)));
				((pIns)[0] = ((byte)((idx) >> 8)), (pIns)[1] = ((byte)(idx)));
				pPage.nCell++;
				if ((++data[pPage.hdrOffset + 4]) == (0))
					data[pPage.hdrOffset + 3]++;
				if ((pPage.pBt.autoVacuum) != 0)
				{
					ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);
				}
			}
		}
		public static int modifyPagePointer(MemPage pPage, uint iFrom, uint iTo, byte eType)
		{
			if ((eType) == (4))
			{
				if (sqlite3Get4byte(pPage.aData) != iFrom)
				{
					return (int)(sqlite3CorruptError((int)(69823)));
				}

				sqlite3Put4byte(pPage.aData, (uint)(iTo));
			}
			else
			{
				int i = 0;
				int nCell = 0;
				int rc = 0;
				rc = (int)((pPage.isInit) != 0 ? 0 : btreeInitPage(pPage));
				if ((rc) != 0)
					return (int)(rc);
				nCell = (int)(pPage.nCell);
				for (i = (int)(0); (i) < (nCell); i++)
				{
					byte* pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (i)])))));
					if ((eType) == (3))
					{
						CellInfo info = new CellInfo();
						pPage.xParseCell(pPage, pCell, &info);
						if ((info.nLocal) < (info.nPayload))
						{
							if ((pCell + info.nSize) > (pPage.aData + pPage.pBt.usableSize))
							{
								return (int)(sqlite3CorruptError((int)(69842)));
							}

							if ((iFrom) == (sqlite3Get4byte(pCell + info.nSize - 4)))
							{
								sqlite3Put4byte(pCell + info.nSize - 4, (uint)(iTo));
								break;
							}
						}
					}
					else
					{
						if ((sqlite3Get4byte(pCell)) == (iFrom))
						{
							sqlite3Put4byte(pCell, (uint)(iTo));
							break;
						}
					}
				}

				if ((i) == (nCell))
				{
					if ((eType != 5) || (sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]) != iFrom))
					{
						return (int)(sqlite3CorruptError((int)(69860)));
					}

					sqlite3Put4byte(&pPage.aData[pPage.hdrOffset + 8], (uint)(iTo));
				}
			}

			return (int)(0);
		}
		public static int pageFreeArray(MemPage pPg, int iFirst, int nCell, CellArray pCArray)
		{
			byte* aData = pPg.aData;
			byte* pEnd = &aData[pPg.pBt.usableSize];
			byte* pStart = &aData[pPg.hdrOffset + 8 + pPg.childPtrSize];
			int nRet = (int)(0);
			int i = 0;
			int iEnd = (int)(iFirst + nCell);
			byte* pFree = null;
			int szFree = (int)(0);
			for (i = (int)(iFirst); (i) < (iEnd); i++)
			{
				byte* pCell = pCArray.apCell[i];
				if (((((ulong)(pCell)) >= ((ulong)(pStart))) && (((ulong)(pCell)) < ((ulong)(pEnd)))))
				{
					int sz = 0;
					sz = (int)(pCArray.szCell[i]);
					if (pFree != (pCell + sz))
					{
						if ((pFree) != null)
						{
							freeSpace(pPg, (ushort)(pFree - aData), (ushort)(szFree));
						}

						pFree = pCell;
						szFree = (int)(sz);
						if ((pFree + sz) > (pEnd))
						{
							return (int)(0);
						}
					}
					else
					{
						pFree = pCell;
						szFree += (int)(sz);
					}

					nRet++;
				}
			}

			if ((pFree) != null)
			{
				freeSpace(pPg, (ushort)(pFree - aData), (ushort)(szFree));
			}

			return (int)(nRet);
		}
		public static int pageInsertArray(MemPage pPg, byte* pBegin, byte** ppData, byte* pCellptr, int iFirst, int nCell, CellArray pCArray)
		{
			int i = (int)(iFirst);
			byte* aData = pPg.aData;
			byte* pData = *ppData;
			int iEnd = (int)(iFirst + nCell);
			int k = 0;
			byte* pEnd;
			if ((iEnd) <= (iFirst))
				return (int)(0);
			for (k = (int)(0); ((pCArray.ixNx[k]) <= (i)) && ((k) < (3 * 2)); k++)
			{
			}

			pEnd = pCArray.apEnd[k];
			while ((1) != 0)
			{
				int sz = 0;
				int rc = 0;
				byte* pSlot;
				sz = (int)(pCArray.szCell[i]);
				if ((((aData[1]) == (0)) && ((aData[2]) == (0))) || ((pSlot = pageFindSlot(pPg, (int)(sz), &rc)) == (null)))
				{
					if ((pData - pBegin) < (sz))
						return (int)(1);
					pData -= sz;
					pSlot = pData;
				}

				if ((((ulong)(pCArray.apCell[i] + sz)) > ((ulong)(pEnd))) && (((ulong)(pCArray.apCell[i])) < ((ulong)(pEnd))))
				{
					(void)(sqlite3CorruptError((int)(73417)));
					return (int)(1);
				}

				CRuntime.memmove(pSlot, pCArray.apCell[i], (ulong)(sz));
				((pCellptr)[0] = ((byte)((pSlot - aData) >> 8)), (pCellptr)[1] = ((byte)(pSlot - aData)));
				pCellptr += 2;
				i++;
				if ((i) >= (iEnd))
					break;
				if ((pCArray.ixNx[k]) <= (i))
				{
					k++;
					pEnd = pCArray.apEnd[k];
				}
			}

			*ppData = pData;
			return (int)(0);
		}
		public static void ptrmapPutOvflPtr(MemPage pPage, MemPage pSrc, byte* pCell, int* pRC)
		{
			CellInfo info = new CellInfo();
			if ((*pRC) != 0)
				return;
			pPage.xParseCell(pPage, pCell, &info);
			if ((info.nLocal) < (info.nPayload))
			{
				uint ovfl = 0;
				if (((((ulong)(pSrc.aDataEnd)) >= ((ulong)(pCell))) && (((ulong)(pSrc.aDataEnd)) < ((ulong)(pCell + info.nLocal)))))
				{
					*pRC = (int)(sqlite3CorruptError((int)(67589)));
					return;
				}

				ovfl = (uint)(sqlite3Get4byte(&pCell[info.nSize - 4]));
				ptrmapPut(pPage.pBt, (uint)(ovfl), (byte)(3), (uint)(pPage.pgno), pRC);
			}
		}
		public static void releasePage(MemPage pPage)
		{
			if ((pPage) != null)
				releasePageNotNull(pPage);
		}
		public static void releasePageNotNull(MemPage pPage)
		{
			sqlite3PagerUnrefNotNull(pPage.pDbPage);
		}
		public static void releasePageOne(MemPage pPage)
		{
			sqlite3PagerUnrefPageOne(pPage.pDbPage);
		}
		public static int setChildPtrmaps(MemPage pPage)
		{
			int i = 0;
			int nCell = 0;
			int rc = 0;
			BtShared pBt = pPage.pBt;
			uint pgno = (uint)(pPage.pgno);
			rc = (int)((pPage.isInit) != 0 ? 0 : btreeInitPage(pPage));
			if (rc != 0)
				return (int)(rc);
			nCell = (int)(pPage.nCell);
			for (i = (int)(0); (i) < (nCell); i++)
			{
				byte* pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (i)])))));
				ptrmapPutOvflPtr(pPage, pPage, pCell, &rc);
				if (pPage.leaf == 0)
				{
					uint childPgno = (uint)(sqlite3Get4byte(pCell));
					ptrmapPut(pBt, (uint)(childPgno), (byte)(5), (uint)(pgno), &rc);
				}
			}

			if (pPage.leaf == 0)
			{
				uint childPgno = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				ptrmapPut(pBt, (uint)(childPgno), (byte)(5), (uint)(pgno), &rc);
			}

			return (int)(rc);
		}
		public static void zeroPage(MemPage pPage, int flags)
		{
			byte* data = pPage.aData;
			BtShared pBt = pPage.pBt;
			byte hdr = (byte)(pPage.hdrOffset);
			ushort first = 0;
			if ((pBt.btsFlags & 0x000c) != 0)
			{
				CRuntime.memset(&data[hdr], (int)(0), (ulong)(pBt.usableSize - hdr));
			}

			data[hdr] = (byte)((sbyte)(flags));
			first = (ushort)(hdr + ((flags & 0x08) == (0) ? 12 : 8));
			CRuntime.memset(&data[hdr + 1], (int)(0), (ulong)(4));
			data[hdr + 7] = (byte)(0);
			((&data[hdr + 5])[0] = ((byte)((pBt.usableSize) >> 8)), (&data[hdr + 5])[1] = ((byte)(pBt.usableSize)));
			pPage.nFree = (int)((ushort)(pBt.usableSize - first));
			decodeFlags(pPage, (int)(flags));
			pPage.cellOffset = (ushort)(first);
			pPage.aDataEnd = &data[pBt.pageSize];
			pPage.aCellIdx = &data[first];
			pPage.aDataOfst = &data[pPage.childPtrSize];
			pPage.nOverflow = (byte)(0);
			pPage.maskPage = ((ushort)(pBt.pageSize - 1));
			pPage.nCell = (ushort)(0);
			pPage.isInit = (byte)(1);
		}
	}
}