// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void estimateIndexWidth(Index pIdx)
		{
			uint wIndex = (uint)(0);
			int i = 0;
			Column* aCol = pIdx.pTable.aCol;
			for (i = (int)(0); (i) < (pIdx.nColumn); i++)
			{
				short x = (short)(pIdx.aiColumn[i]);
				wIndex += (uint)((x) < (0) ? 1 : aCol[pIdx.aiColumn[i]].szEst);
			}

			pIdx.szIdxRow = (short)(sqlite3LogEst((ulong)(wIndex * 4)));
		}
		public static int indexColumnIsBeingUpdated(Index pIdx, int iCol, int* aXRef, int chngRowid)
		{
			short iIdxCol = (short)(pIdx.aiColumn[iCol]);
			if ((iIdxCol) >= (0))
			{
				return ((aXRef[iIdxCol]) >= (0) ? 1 : 0);
			}

			return (int)(sqlite3ExprReferencesUpdatedColumn(pIdx.aColExpr.a[iCol].pExpr, aXRef, (int)(chngRowid)));
		}
		public static int indexColumnNotNull(Index pIdx, int iCol)
		{
			int j = 0;
			j = (int)(pIdx.aiColumn[iCol]);
			if ((j) >= (0))
			{
				return (int)(pIdx.pTable.aCol[j].notNull);
			}
			else if ((j) == (-1))
			{
				return (int)(1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static int indexWhereClauseMightChange(Index pIdx, int* aXRef, int chngRowid)
		{
			if ((pIdx.pPartIdxWhere) == (null))
				return (int)(0);
			return (int)(sqlite3ExprReferencesUpdatedColumn(pIdx.pPartIdxWhere, aXRef, (int)(chngRowid)));
		}
		public static int isDupColumn(Index pIdx, int nKey, Index pPk, int iCol)
		{
			int i = 0; int j = 0;
			j = (int)(pPk.aiColumn[iCol]);
			for (i = (int)(0); (i) < (nKey); i++)
			{
				if (((pIdx.aiColumn[i]) == (j)) && ((sqlite3StrICmp(pIdx.azColl[i], pPk.azColl[iCol])) == (0)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static void recomputeColumnsNotIndexed(Index pIdx)
		{
			ulong m = (ulong)(0);
			int j = 0;
			Table pTab = pIdx.pTable;
			for (j = (int)(pIdx.nColumn - 1); (j) >= (0); j--)
			{
				int x = (int)(pIdx.aiColumn[j]);
				if (((x) >= (0)) && ((pTab.aCol[x].colFlags & 0x0020) == (0)))
				{
					if ((x) < (((int)(sizeof(ulong) * 8)) - 1))
						m |= (ulong)(((ulong)(1)) << (x));
				}
			}

			pIdx.colNotIdxed = (ulong)(~m);
		}
		public static void sqlite3DefaultRowEst(Index pIdx)
		{
			short* a = pIdx.aiRowLogEst;
			short x = 0;
			int nCopy = (int)(((int)(5 * sizeof(short) / sizeof(short))) < (pIdx.nKeyCol) ? ((int)(5 * sizeof(short) / sizeof(short))) : (pIdx.nKeyCol));
			int i = 0;
			x = (short)(pIdx.pTable.nRowLogEst);
			if ((x) < (99))
			{
				pIdx.pTable.nRowLogEst = (short)(x = (short)(99));
			}

			if (pIdx.pPartIdxWhere != null)
			{
				x -= (short)(10);
			}

			a[0] = (short)(x);
			CRuntime.memcpy(&a[1], sqlite3DefaultRowEst_aVal, (ulong)(nCopy * sizeof(short)));
			for (i = (int)(nCopy + 1); (i) <= (pIdx.nKeyCol); i++)
			{
				a[i] = (short)(23);
			}

			if (((pIdx).onError != 0))
				a[pIdx.nKeyCol] = (short)(0);
		}
		public static int sqlite3IndexHasDuplicateRootPage(Index pIndex)
		{
			Index p;
			for (p = pIndex.pTable.pIndex; p; p = p.pNext)
			{
				if (((p.tnum) == (pIndex.tnum)) && (p != pIndex))
					return (int)(1);
			}

			return (int)(0);
		}
		public static short sqlite3TableColumnToIndex(Index pIdx, short iCol)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pIdx.nColumn); i++)
			{
				if ((iCol) == (pIdx.aiColumn[i]))
					return (short)(i);
			}

			return (short)(-1);
		}
		public static void whereIndexExprTrans(Index pIdx, int iTabCur, int iIdxCur, WhereInfo pWInfo)
		{
			int iIdxCol = 0;
			ExprList aColExpr;
			Table pTab;
			Walker w = new Walker();
			IdxExprTrans x = new IdxExprTrans();
			aColExpr = pIdx.aColExpr;
			if (((aColExpr) == (null)) && (pIdx.bHasVCol == 0))
			{
				return;
			}

			pTab = pIdx.pTable;
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			w.u.pIdxTrans = x;
			x.iTabCur = (int)(iTabCur);
			x.iIdxCur = (int)(iIdxCur);
			x.pWInfo = pWInfo;
			x.db = pWInfo.pParse.db;
			for (iIdxCol = (int)(0); (iIdxCol) < (pIdx.nColumn); iIdxCol++)
			{
				short iRef = (short)(pIdx.aiColumn[iIdxCol]);
				if ((iRef) == (-2))
				{
					x.pIdxExpr = aColExpr.a[iIdxCol].pExpr;
					if ((sqlite3ExprIsConstant(x.pIdxExpr)) != 0)
						continue;
					w.xExprCallback = whereIndexExprTransNode;
				}
				else if ((((iRef) >= (0)) && ((pTab.aCol[iRef].colFlags & 0x0020) != 0)) && (((pTab.aCol[iRef].colFlags & 0x0200) == (0)) || ((sqlite3StrICmp(sqlite3ColumnColl(&pTab.aCol[iRef]), sqlite3StrBINARY)) == (0))))
				{
					x.iTabCol = (int)(iRef);
					w.xExprCallback = whereIndexExprTransColumn;
				}
				else
				{
					continue;
				}

				x.iIdxCol = (int)(iIdxCol);
				sqlite3WalkExpr(w, pWInfo.pWhere);
				sqlite3WalkExprList(w, pWInfo.pOrderBy);
				sqlite3WalkExprList(w, pWInfo.pResultSet);
			}
		}
		public static int xferCompatibleIndex(Index pDest, Index pSrc)
		{
			int i = 0;
			if ((pDest.nKeyCol != pSrc.nKeyCol) || (pDest.nColumn != pSrc.nColumn))
			{
				return (int)(0);
			}

			if (pDest.onError != pSrc.onError)
			{
				return (int)(0);
			}

			for (i = (int)(0); (i) < (pSrc.nKeyCol); i++)
			{
				if (pSrc.aiColumn[i] != pDest.aiColumn[i])
				{
					return (int)(0);
				}

				if ((pSrc.aiColumn[i]) == (-2))
				{
					if (sqlite3ExprCompare(null, pSrc.aColExpr.a[i].pExpr, pDest.aColExpr.a[i].pExpr, (int)(-1)) != 0)
					{
						return (int)(0);
					}
				}

				if (pSrc.aSortOrder[i] != pDest.aSortOrder[i])
				{
					return (int)(0);
				}

				if (sqlite3_stricmp(pSrc.azColl[i], pDest.azColl[i]) != 0)
				{
					return (int)(0);
				}
			}

			if ((sqlite3ExprCompare(null, pSrc.pPartIdxWhere, pDest.pPartIdxWhere, (int)(-1))) != 0)
			{
				return (int)(0);
			}

			return (int)(1);
		}
	}
}