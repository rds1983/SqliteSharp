// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void sqlite3RowSetInsert(RowSet p, long rowid)
		{
			RowSetEntry* pEntry;
			RowSetEntry* pLast;
			pEntry = rowSetEntryAlloc(p);
			if ((pEntry) == (null))
				return;
			pEntry->v = (long)(rowid);
			pEntry->pRight = null;
			pLast = p.pLast;
			if ((pLast) != null)
			{
				if ((rowid) <= (pLast->v))
				{
					p.rsFlags &= (ushort)(~0x01);
				}

				pLast->pRight = pEntry;
			}
			else
			{
				p.pEntry = pEntry;
			}

			p.pLast = pEntry;
		}
		public static int sqlite3RowSetNext(RowSet p, long* pRowid)
		{
			if ((p.rsFlags & 0x02) == (0))
			{
				if ((p.rsFlags & 0x01) == (0))
				{
					p.pEntry = rowSetEntrySort(p.pEntry);
				}

				p.rsFlags |= (ushort)(0x01 | 0x02);
			}

			if ((p.pEntry) != null)
			{
				*pRowid = (long)(p.pEntry->v);
				p.pEntry = p.pEntry->pRight;
				if ((p.pEntry) == (null))
				{
					sqlite3RowSetClear(p);
				}

				return (int)(1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static int sqlite3RowSetTest(RowSet pRowSet, int iBatch, long iRowid)
		{
			RowSetEntry* p; RowSetEntry* pTree;
			if (iBatch != pRowSet.iBatch)
			{
				p = pRowSet.pEntry;
				if ((p) != null)
				{
					RowSetEntry** ppPrevTree = &pRowSet.pForest;
					if ((pRowSet.rsFlags & 0x01) == (0))
					{
						p = rowSetEntrySort(p);
					}

					for (pTree = pRowSet.pForest; pTree; pTree = pTree->pRight)
					{
						ppPrevTree = &pTree->pRight;
						if ((pTree->pLeft) == (null))
						{
							pTree->pLeft = rowSetListToTree(p);
							break;
						}
						else
						{
							RowSetEntry* pAux;
							RowSetEntry* pTail;
							rowSetTreeToList(pTree->pLeft, &pAux, &pTail);
							pTree->pLeft = null;
							p = rowSetEntryMerge(pAux, p);
						}
					}

					if ((pTree) == (null))
					{
						*ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);
						if ((pTree) != null)
						{
							pTree->v = (long)(0);
							pTree->pRight = null;
							pTree->pLeft = rowSetListToTree(p);
						}
					}

					pRowSet.pEntry = null;
					pRowSet.pLast = null;
					pRowSet.rsFlags |= (ushort)(0x01);
				}

				pRowSet.iBatch = (int)(iBatch);
			}

			for (pTree = pRowSet.pForest; pTree; pTree = pTree->pRight)
			{
				p = pTree->pLeft;
				while ((p) != null)
				{
					if ((p->v) < (iRowid))
					{
						p = p->pRight;
					}
					else if ((p->v) > (iRowid))
					{
						p = p->pLeft;
					}
					else
					{
						return (int)(1);
					}
				}
			}

			return (int)(0);
		}
	}
}