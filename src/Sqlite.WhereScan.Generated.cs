// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static WhereTerm whereScanInit(WhereScan pScan, WhereClause pWC, int iCur, int iColumn, uint opMask, Index pIdx)
		{
			pScan.pOrigWC = pWC;
			pScan.pWC = pWC;
			pScan.pIdxExpr = null;
			pScan.idxaff = (sbyte)(0);
			pScan.zCollName = null;
			pScan.opMask = (uint)(opMask);
			pScan.k = (int)(0);
			pScan.aiCur[0] = (int)(iCur);
			pScan.nEquiv = (byte)(1);
			pScan.iEquiv = (byte)(1);
			if ((pIdx) != null)
			{
				int j = (int)(iColumn);
				iColumn = (int)(pIdx.aiColumn[j]);
				if ((iColumn) == (pIdx.pTable.iPKey))
				{
					iColumn = (int)(-1);
				}
				else if ((iColumn) >= (0))
				{
					pScan.idxaff = (sbyte)(pIdx.pTable.aCol[iColumn].affinity);
					pScan.zCollName = pIdx.azColl[j];
				}
				else if ((iColumn) == (-2))
				{
					pScan.pIdxExpr = pIdx.aColExpr.a[j].pExpr;
					pScan.zCollName = pIdx.azColl[j];
					pScan.aiColumn[0] = (short)(-2);
					return whereScanInitIndexExpr(pScan);
				}
			}
			else if ((iColumn) == (-2))
			{
				return null;
			}

			pScan.aiColumn[0] = (short)(iColumn);
			return whereScanNext(pScan);
		}
		public static WhereTerm whereScanInitIndexExpr(WhereScan pScan)
		{
			pScan.idxaff = (sbyte)(sqlite3ExprAffinity(pScan.pIdxExpr));
			return whereScanNext(pScan);
		}
		public static WhereTerm whereScanNext(WhereScan pScan)
		{
			int iCur = 0;
			short iColumn = 0;
			Expr pX;
			WhereClause pWC;
			WhereTerm pTerm;
			int k = (int)(pScan.k);
			pWC = pScan.pWC;
			while ((1) != 0)
			{
				iColumn = (short)(pScan.aiColumn[pScan.iEquiv - 1]);
				iCur = (int)(pScan.aiCur[pScan.iEquiv - 1]);
				do
				{
					for (pTerm = pWC.a[k]; (k) < (pWC.nTerm); k++, pTerm++)
					{
						if (((((pTerm.leftCursor) == (iCur)) && ((pTerm.u.x.leftColumn) == (iColumn))) && ((iColumn != (-2)) || ((sqlite3ExprCompareSkip(pTerm.pExpr.pLeft, pScan.pIdxExpr, (int)(iCur))) == (0)))) && (((pScan.iEquiv) <= (1)) || (!(((pTerm.pExpr).flags & (0x000001)) != 0))))
						{
							if ((((pTerm.eOperator & 0x0800) != 0) && ((pScan.nEquiv) < ((int)(11 * sizeof(int) / sizeof(int))))) && ((pX = whereRightSubexprIsColumn(pTerm.pExpr)) != null))
							{
								int j = 0;
								for (j = (int)(0); (j) < (pScan.nEquiv); j++)
								{
									if (((pScan.aiCur[j]) == (pX.iTable)) && ((pScan.aiColumn[j]) == (pX.iColumn)))
									{
										break;
									}
								}

								if ((j) == (pScan.nEquiv))
								{
									pScan.aiCur[j] = (int)(pX.iTable);
									pScan.aiColumn[j] = (short)(pX.iColumn);
									pScan.nEquiv++;
								}
							}

							if ((pTerm.eOperator & pScan.opMask) != 0)
							{
								if (((pScan.zCollName) != null) && ((pTerm.eOperator & 0x0100) == (0)))
								{
									CollSeq pColl;
									Parse pParse = pWC.pWInfo.pParse;
									pX = pTerm.pExpr;
									if (sqlite3IndexAffinityOk(pX, (sbyte)(pScan.idxaff)) == 0)
									{
										continue;
									}

									pColl = sqlite3ExprCompareCollSeq(pParse, pX);
									if ((pColl) == (null))
										pColl = pParse.db.pDfltColl;
									if ((sqlite3StrICmp(pColl.zName, pScan.zCollName)) != 0)
									{
										continue;
									}
								}

								if ((((((pTerm.eOperator & (0x0002 | 0x0080)) != 0) && (pX = pTerm.pExpr.pRight, (pX != null))) && ((pX.op) == (167))) && ((pX.iTable) == (pScan.aiCur[0]))) && ((pX.iColumn) == (pScan.aiColumn[0])))
								{
									continue;
								}

								pScan.pWC = pWC;
								pScan.k = (int)(k + 1);
								return pTerm;
							}
						}
					}

					pWC = pWC.pOuter;
					k = (int)(0);
				}
				while (pWC != null);
				if ((pScan.iEquiv) >= (pScan.nEquiv))
					break;
				pWC = pScan.pOrigWC;
				k = (int)(0);
				pScan.iEquiv++;
			}

			return null;
		}
	}
}