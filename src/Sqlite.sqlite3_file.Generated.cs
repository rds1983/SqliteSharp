// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int backupTruncateFile(sqlite3_file pFile, long iSize)
		{
			long iCurrent = 0;
			int rc = (int)(sqlite3OsFileSize(pFile, &iCurrent));
			if (((rc) == (0)) && ((iCurrent) > (iSize)))
			{
				rc = (int)(sqlite3OsTruncate(pFile, (long)(iSize)));
			}

			return (int)(rc);
		}
		public static int memdbClose(sqlite3_file pFile)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			if ((p->zFName) != null)
			{
				int i = 0;
				sqlite3_mutex* pVfsMutex = sqlite3MutexAlloc((int)(11));
				sqlite3_mutex_enter(pVfsMutex);
				for (i = (int)(0); ((i) < (memdb_g.nMemStore)); i++)
				{
					if ((memdb_g.apMemStore[i]) == (p))
					{
						memdbEnter(p);
						if ((p->nRef) == (1))
						{
							memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];
							if ((memdb_g.nMemStore) == (0))
							{
								sqlite3_free(memdb_g.apMemStore);
								memdb_g.apMemStore = null;
							}
						}

						break;
					}
				}

				sqlite3_mutex_leave(pVfsMutex);
			}
			else
			{
				memdbEnter(p);
			}

			p->nRef--;
			if ((p->nRef) <= (0))
			{
				if ((p->mFlags & 1) != 0)
				{
					sqlite3_free(p->aData);
				}

				memdbLeave(p);
				sqlite3_mutex_free(p->pMutex);
				sqlite3_free(p);
			}
			else
			{
				memdbLeave(p);
			}

			return (int)(0);
		}
		public static int memdbDeviceCharacteristics(sqlite3_file pFile)
		{
			return (int)(0x00000001 | 0x00001000 | 0x00000200 | 0x00000400);
		}
		public static int memdbFetch(sqlite3_file pFile, long iOfst, int iAmt, void** pp)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			if (((iOfst + iAmt) > (p->sz)) || ((p->mFlags & 2) != 0))
			{
				*pp = null;
			}
			else
			{
				p->nMmap++;
				*pp = (void*)(p->aData + iOfst);
			}

			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbFileControl(sqlite3_file pFile, int op, void* pArg)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			int rc = (int)(12);
			memdbEnter(p);
			if ((op) == (12))
			{
				*(sbyte**)(pArg) = sqlite3_mprintf("memdb(%p,%lld)", p->aData, (long)(p->sz));
				rc = (int)(0);
			}

			if ((op) == (36))
			{
				long iLimit = (long)(*(long*)(pArg));
				if ((iLimit) < (p->sz))
				{
					if ((iLimit) < (0))
					{
						iLimit = (long)(p->szMax);
					}
					else
					{
						iLimit = (long)(p->sz);
					}
				}

				p->szMax = (long)(iLimit);
				*(long*)(pArg) = (long)(iLimit);
				rc = (int)(0);
			}

			memdbLeave(p);
			return (int)(rc);
		}
		public static int memdbFileSize(sqlite3_file pFile, long* pSize)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			*pSize = (long)(p->sz);
			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbLock(sqlite3_file pFile, int eLock)
		{
			MemFile pThis = (MemFile)(pFile);
			MemStore* p = pThis.pStore;
			int rc = (int)(0);
			if ((eLock) == (pThis.eLock))
				return (int)(0);
			memdbEnter(p);
			if ((eLock) > (1))
			{
				if ((p->mFlags & 4) != 0)
				{
					rc = (int)(8);
				}
				else if ((pThis.eLock) <= (1))
				{
					if ((p->nWrLock) != 0)
					{
						rc = (int)(5);
					}
					else
					{
						p->nWrLock = (int)(1);
					}
				}
			}
			else if ((eLock) == (1))
			{
				if ((pThis.eLock) > (1))
				{
					p->nWrLock = (int)(0);
				}
				else if ((p->nWrLock) != 0)
				{
					rc = (int)(5);
				}
				else
				{
					p->nRdLock++;
				}
			}
			else
			{
				if ((pThis.eLock) > (1))
				{
					p->nWrLock = (int)(0);
				}

				p->nRdLock--;
			}

			if ((rc) == (0))
				pThis.eLock = (int)(eLock);
			memdbLeave(p);
			return (int)(rc);
		}
		public static int memdbRead(sqlite3_file pFile, void* zBuf, int iAmt, long iOfst)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			if ((iOfst + iAmt) > (p->sz))
			{
				CRuntime.memset(zBuf, (int)(0), (ulong)(iAmt));
				if ((iOfst) < (p->sz))
					CRuntime.memcpy(zBuf, p->aData + iOfst, (ulong)(p->sz - iOfst));
				memdbLeave(p);
				return (int)(10 | (2 << 8));
			}

			CRuntime.memcpy(zBuf, p->aData + iOfst, (ulong)(iAmt));
			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbSync(sqlite3_file pFile, int flags)
		{
			return (int)(0);
		}
		public static int memdbTruncate(sqlite3_file pFile, long size)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			int rc = (int)(0);
			memdbEnter(p);
			if ((size) > (p->sz))
			{
				rc = (int)(11);
			}
			else
			{
				p->sz = (long)(size);
			}

			memdbLeave(p);
			return (int)(rc);
		}
		public static int memdbUnfetch(sqlite3_file pFile, long iOfst, void* pPage)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			p->nMmap--;
			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbWrite(sqlite3_file pFile, void* z, int iAmt, long iOfst)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			if ((p->mFlags & 4) != 0)
			{
				memdbLeave(p);
				return (int)(10 | (3 << 8));
			}

			if ((iOfst + iAmt) > (p->sz))
			{
				int rc = 0;
				if (((iOfst + iAmt) > (p->szAlloc)) && ((rc = (int)(memdbEnlarge(p, (long)(iOfst + iAmt)))) != 0))
				{
					memdbLeave(p);
					return (int)(rc);
				}

				if ((iOfst) > (p->sz))
					CRuntime.memset(p->aData + p->sz, (int)(0), (ulong)(iOfst - p->sz));
				p->sz = (long)(iOfst + iAmt);
			}

			CRuntime.memcpy(p->aData + iOfst, z, (ulong)(iAmt));
			memdbLeave(p);
			return (int)(0);
		}
		public static int memjrnlClose(sqlite3_file pJfd)
		{
			MemJournal p = (MemJournal)(pJfd);
			memjrnlFreeChunks(p.pFirst);
			return (int)(0);
		}
		public static int memjrnlFileSize(sqlite3_file pJfd, long* pSize)
		{
			MemJournal p = (MemJournal)(pJfd);
			*pSize = (long)(p.endpoint.iOffset);
			return (int)(0);
		}
		public static int memjrnlRead(sqlite3_file pJfd, void* zBuf, int iAmt, long iOfst)
		{
			MemJournal p = (MemJournal)(pJfd);
			byte* zOut = zBuf;
			int nRead = (int)(iAmt);
			int iChunkOffset = 0;
			FileChunk* pChunk;
			if ((iAmt + iOfst) > (p.endpoint.iOffset))
			{
				return (int)(10 | (2 << 8));
			}

			if ((p.readpoint.iOffset != iOfst) || ((iOfst) == (0)))
			{
				long iOff = (long)(0);
				for (pChunk = p.pFirst; ((pChunk) != null) && ((iOff + p.nChunkSize) <= (iOfst)); pChunk = pChunk->pNext)
				{
					iOff += (long)(p.nChunkSize);
				}
			}
			else
			{
				pChunk = p.readpoint.pChunk;
			}

			iChunkOffset = ((int)(iOfst % p.nChunkSize));
			do
			{
				int iSpace = (int)(p.nChunkSize - iChunkOffset);
				int nCopy = (int)((nRead) < (p.nChunkSize - iChunkOffset) ? (nRead) : (p.nChunkSize - iChunkOffset));
				CRuntime.memcpy(zOut, pChunk->zChunk + iChunkOffset, (ulong)(nCopy));
				zOut += nCopy;
				nRead -= (int)(iSpace);
				iChunkOffset = (int)(0);
			}
			while ((((nRead) >= (0)) && ((pChunk = pChunk->pNext) != null)) && ((nRead) > (0)));
			p.readpoint.iOffset = (long)(pChunk ? iOfst + iAmt : 0);
			p.readpoint.pChunk = pChunk;
			return (int)(0);
		}
		public static int memjrnlSync(sqlite3_file pJfd, int flags)
		{
			return (int)(0);
		}
		public static int memjrnlTruncate(sqlite3_file pJfd, long size)
		{
			MemJournal p = (MemJournal)(pJfd);
			if ((size) < (p.endpoint.iOffset))
			{
				FileChunk* pIter = null;
				if ((size) == (0))
				{
					memjrnlFreeChunks(p.pFirst);
					p.pFirst = null;
				}
				else
				{
					long iOff = (long)(p.nChunkSize);
					for (pIter = p.pFirst; ((pIter) != null) && ((iOff) < (size)); pIter = pIter->pNext)
					{
						iOff += (long)(p.nChunkSize);
					}

					if ((pIter) != null)
					{
						memjrnlFreeChunks(pIter->pNext);
						pIter->pNext = null;
					}
				}

				p.endpoint.pChunk = pIter;
				p.endpoint.iOffset = (long)(size);
				p.readpoint.pChunk = null;
				p.readpoint.iOffset = (long)(0);
			}

			return (int)(0);
		}
		public static int memjrnlWrite(sqlite3_file pJfd, void* zBuf, int iAmt, long iOfst)
		{
			MemJournal p = (MemJournal)(pJfd);
			int nWrite = (int)(iAmt);
			byte* zWrite = (byte*)(zBuf);
			if (((p.nSpill) > (0)) && ((iAmt + iOfst) > (p.nSpill)))
			{
				int rc = (int)(memjrnlCreateFile(p));
				if ((rc) == (0))
				{
					rc = (int)(sqlite3OsWrite(pJfd, zBuf, (int)(iAmt), (long)(iOfst)));
				}

				return (int)(rc);
			}
			else
			{
				if (((iOfst) > (0)) && (iOfst != p.endpoint.iOffset))
				{
					memjrnlTruncate(pJfd, (long)(iOfst));
				}

				if (((iOfst) == (0)) && ((p.pFirst) != null))
				{
					CRuntime.memcpy(p.pFirst->zChunk, zBuf, (ulong)(iAmt));
				}
				else
				{
					while ((nWrite) > (0))
					{
						FileChunk* pChunk = p.endpoint.pChunk;
						int iChunkOffset = (int)(p.endpoint.iOffset % p.nChunkSize);
						int iSpace = (int)((nWrite) < (p.nChunkSize - iChunkOffset) ? (nWrite) : (p.nChunkSize - iChunkOffset));
						if ((iChunkOffset) == (0))
						{
							FileChunk* pNew = sqlite3_malloc((int)(sizeof(FileChunk) + ((p.nChunkSize) - 8)));
							if (pNew == null)
							{
								return (int)(10 | (12 << 8));
							}

							pNew->pNext = null;
							if ((pChunk) != null)
							{
								pChunk->pNext = pNew;
							}
							else
							{
								p.pFirst = pNew;
							}

							pChunk = p.endpoint.pChunk = pNew;
						}

						CRuntime.memcpy(pChunk->zChunk + iChunkOffset, zWrite, (ulong)(iSpace));
						zWrite += iSpace;
						nWrite -= (int)(iSpace);
						p.endpoint.iOffset += (long)(iSpace);
					}
				}
			}

			return (int)(0);
		}
		public static int read32bits(sqlite3_file fd, long offset, uint* pRes)
		{
			byte* ac = stackalloc byte[4];
			int rc = (int)(sqlite3OsRead(fd, ac, (int)(4 * sizeof(byte)), (long)(offset)));
			if ((rc) == (0))
			{
				*pRes = (uint)(sqlite3Get4byte(ac));
			}

			return (int)(rc);
		}
		public static int readSuperJournal(sqlite3_file pJrnl, sbyte* zSuper, uint nSuper)
		{
			int rc = 0;
			uint len = 0;
			long szJ = 0;
			uint cksum = 0;
			uint u = 0;
			byte* aMagic = stackalloc byte[8];
			zSuper[0] = (sbyte)(0);
			if ((((((((((0 != (rc = (int)(sqlite3OsFileSize(pJrnl, &szJ)))) || ((szJ) < (16))) || (0 != (rc = (int)(read32bits(pJrnl, (long)(szJ - 16), &len))))) || ((len) >= (nSuper))) || ((len) > (szJ - 16))) || ((len) == (0))) || (0 != (rc = (int)(read32bits(pJrnl, (long)(szJ - 12), &cksum))))) || (0 != (rc = (int)(sqlite3OsRead(pJrnl, aMagic, (int)(8), (long)(szJ - 8)))))) || ((memcmp(aMagic, aJournalMagic, (ulong)(8))) != 0)) || (0 != (rc = (int)(sqlite3OsRead(pJrnl, zSuper, (int)(len), (long)(szJ - 16 - len))))))
			{
				return (int)(rc);
			}

			for (u = (uint)(0); (u) < (len); u++)
			{
				cksum -= (uint)(zSuper[u]);
			}

			if ((cksum) != 0)
			{
				len = (uint)(0);
			}

			zSuper[len] = (sbyte)(0);
			zSuper[len + 1] = (sbyte)(0);
			return (int)(0);
		}
		public static int sqlite3JournalIsInMemory(sqlite3_file p)
		{
			return ((p.pMethods) == (MemJournalMethods) ? 1 : 0);
		}
		public static void sqlite3MemJournalOpen(sqlite3_file pJfd)
		{
			sqlite3JournalOpen(null, null, pJfd, (int)(0), (int)(-1));
		}
		public static int sqlite3OsCheckReservedLock(sqlite3_file id, int* pResOut)
		{
			return (int)(id.pMethods.xCheckReservedLock(id, pResOut));
		}
		public static void sqlite3OsClose(sqlite3_file pId)
		{
			if ((pId.pMethods) != null)
			{
				pId.pMethods.xClose(pId);
				pId.pMethods = null;
			}
		}
		public static void sqlite3OsCloseFree(sqlite3_file pFile)
		{
			sqlite3OsClose(pFile);
			sqlite3_free(pFile);
		}
		public static int sqlite3OsDeviceCharacteristics(sqlite3_file id)
		{
			if (((id.pMethods) == (null)))
				return (int)(0);
			return (int)(id.pMethods.xDeviceCharacteristics(id));
		}
		public static int sqlite3OsFetch(sqlite3_file id, long iOff, int iAmt, void** pp)
		{
			return (int)(id.pMethods.xFetch(id, (long)(iOff), (int)(iAmt), pp));
		}
		public static int sqlite3OsFileControl(sqlite3_file id, int op, void* pArg)
		{
			if ((id.pMethods) == (null))
				return (int)(12);
			return (int)(id.pMethods.xFileControl(id, (int)(op), pArg));
		}
		public static void sqlite3OsFileControlHint(sqlite3_file id, int op, void* pArg)
		{
			if ((id.pMethods) != null)
				(void)(id.pMethods.xFileControl(id, (int)(op), pArg));
		}
		public static int sqlite3OsFileSize(sqlite3_file id, long* pSize)
		{
			return (int)(id.pMethods.xFileSize(id, pSize));
		}
		public static int sqlite3OsLock(sqlite3_file id, int lockType)
		{
			return (int)(id.pMethods.xLock(id, (int)(lockType)));
		}
		public static int sqlite3OsRead(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			return (int)(id.pMethods.xRead(id, pBuf, (int)(amt), (long)(offset)));
		}
		public static int sqlite3OsSectorSize(sqlite3_file id)
		{
			delegate0 xSectorSize = id.pMethods.xSectorSize;
			return (int)(xSectorSize ? xSectorSize(id) : 4096);
		}
		public static void sqlite3OsShmBarrier(sqlite3_file id)
		{
			id.pMethods.xShmBarrier(id);
		}
		public static int sqlite3OsShmLock(sqlite3_file id, int offset, int n, int flags)
		{
			return (int)(id.pMethods.xShmLock(id, (int)(offset), (int)(n), (int)(flags)));
		}
		public static int sqlite3OsShmMap(sqlite3_file id, int iPage, int pgsz, int bExtend, void** pp)
		{
			return (int)(id.pMethods.xShmMap(id, (int)(iPage), (int)(pgsz), (int)(bExtend), pp));
		}
		public static int sqlite3OsShmUnmap(sqlite3_file id, int deleteFlag)
		{
			return (int)(id.pMethods.xShmUnmap(id, (int)(deleteFlag)));
		}
		public static int sqlite3OsSync(sqlite3_file id, int flags)
		{
			return (int)((flags) != 0 ? id.pMethods.xSync(id, (int)(flags)) : 0);
		}
		public static int sqlite3OsTruncate(sqlite3_file id, long size)
		{
			return (int)(id.pMethods.xTruncate(id, (long)(size)));
		}
		public static int sqlite3OsUnfetch(sqlite3_file id, long iOff, void* p)
		{
			return (int)(id.pMethods.xUnfetch(id, (long)(iOff), p));
		}
		public static int sqlite3OsUnlock(sqlite3_file id, int lockType)
		{
			return (int)(id.pMethods.xUnlock(id, (int)(lockType)));
		}
		public static int sqlite3OsWrite(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			return (int)(id.pMethods.xWrite(id, pBuf, (int)(amt), (long)(offset)));
		}
		public static int sqlite3SectorSize(sqlite3_file pFile)
		{
			int iRet = (int)(sqlite3OsSectorSize(pFile));
			if ((iRet) < (32))
			{
				iRet = (int)(512);
			}
			else if ((iRet) > (0x10000))
			{
				iRet = (int)(0x10000);
			}

			return (int)(iRet);
		}
		public static void vdbePmaWriterInit(sqlite3_file pFd, PmaWriter p, int nBuf, long iStart)
		{
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(PmaWriter)));
			p.aBuffer = (byte*)(sqlite3Malloc((ulong)(nBuf)));
			if (p.aBuffer == null)
			{
				p.eFWErr = (int)(7);
			}
			else
			{
				p.iBufEnd = (int)(p.iBufStart = (int)(iStart % nBuf));
				p.iWriteOff = (long)(iStart - p.iBufStart);
				p.nBuffer = (int)(nBuf);
				p.pFd = pFd;
			}
		}
		public static int winCheckReservedLock(sqlite3_file id, int* pResOut)
		{
			int res = 0;
			winFile pFile = (winFile)(id);
			if ((pFile.locktype) >= (2))
			{
				res = (int)(1);
			}
			else
			{
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001), (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0)));
				if ((res) != 0)
				{
					winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0));
				}

				res = (int)(!res);
			}

			*pResOut = (int)(res);
			return (int)(0);
		}
		public static int winClose(sqlite3_file id)
		{
			int rc = 0; int cnt = (int)(0);
			winFile pFile = (winFile)(id);
			winUnmapfile(pFile);
			do
			{
				rc = (int)((Int(Void * ))(aSyscall[3].pCurrent)(pFile.h));
			}
			while ((((rc) == (0)) && ((++cnt) < (3))) && (sqlite3_win32_sleep((uint)(100)), 1));
			if ((rc) != 0)
			{
				pFile.h = null;
			}

			return (int)((rc) != 0 ? 0 : winLogErrorAtLine((int)(10 | (16 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winClose", pFile.zPath, (int)(45631)));
		}
		public static int winDeviceCharacteristics(sqlite3_file id)
		{
			winFile p = (winFile)(id);
			return (int)(0x00000800 | ((p.ctrlFlags & 0x10) ? 0x00001000 : 0));
		}
		public static int winFetch(sqlite3_file fd, long iOff, int nAmt, void** pp)
		{
			winFile pFd = (winFile)(fd);
			*pp = null;
			if ((pFd.mmapSizeMax) > (0))
			{
				if ((pFd.pMapRegion) == (null))
				{
					int rc = (int)(winMapfile(pFd, (long)(-1)));
					if (rc != 0)
					{
						return (int)(rc);
					}
				}

				if ((pFd.mmapSize) >= (iOff + nAmt))
				{
					*pp = &((byte*)(pFd.pMapRegion))[iOff];
					pFd.nFetchOut++;
				}
			}

			return (int)(0);
		}
		public static int winFileControl(sqlite3_file id, int op, void* pArg)
		{
			winFile pFile = (winFile)(id);
			switch (op)
			{
				case 1:
					{
						*(int*)(pArg) = (int)(pFile.locktype);
						return (int)(0);
					}

				case 4:
					{
						*(int*)(pArg) = ((int)(pFile.lastErrno));
						return (int)(0);
					}

				case 6:
					{
						pFile.szChunk = (int)(*(int*)(pArg));
						return (int)(0);
					}

				case 5:
					{
						if ((pFile.szChunk) > (0))
						{
							long oldSz = 0;
							int rc = (int)(winFileSize(id, &oldSz));
							if ((rc) == (0))
							{
								long newSz = (long)(*(long*)(pArg));
								if ((newSz) > (oldSz))
								{
									rc = (int)(winTruncate(id, (long)(newSz)));
								}
							}

							return (int)(rc);
						}

						return (int)(0);
					}

				case 10:
					{
						winModeBit(pFile, (byte)(0x04), (int*)(pArg));
						return (int)(0);
					}

				case 13:
					{
						winModeBit(pFile, (byte)(0x10), (int*)(pArg));
						return (int)(0);
					}

				case 12:
					{
						*(sbyte**)(pArg) = sqlite3_mprintf("%s", pFile.pVfs.zName);
						return (int)(0);
					}

				case 9:
					{
						int* a = (int*)(pArg);
						if ((a[0]) > (0))
						{
							winIoerrRetry = (int)(a[0]);
						}
						else
						{
							a[0] = (int)(winIoerrRetry);
						}

						if ((a[1]) > (0))
						{
							winIoerrRetryDelay = (int)(a[1]);
						}
						else
						{
							a[1] = (int)(winIoerrRetryDelay);
						}

						return (int)(0);
					}

				case 29:
					{
						void** phFile = (void**)(pArg);
						*phFile = pFile.h;
						return (int)(0);
					}

				case 16:
					{
						sbyte* zTFile = null;
						int rc = (int)(winGetTempname(pFile.pVfs, &zTFile));
						if ((rc) == (0))
						{
							*(sbyte**)(pArg) = zTFile;
						}

						return (int)(rc);
					}

				case 18:
					{
						long newLimit = (long)(*(long*)(pArg));
						int rc = (int)(0);
						if ((newLimit) > (sqlite3Config.mxMmap))
						{
							newLimit = (long)(sqlite3Config.mxMmap);
						}

						if (((newLimit) > (0)) && ((sizeof(ulong)) < (8)))
						{
							newLimit = (long)(newLimit & 0x7FFFFFFF);
						}

						*(long*)(pArg) = (long)(pFile.mmapSizeMax);
						if ((((newLimit) >= (0)) && (newLimit != pFile.mmapSizeMax)) && ((pFile.nFetchOut) == (0)))
						{
							pFile.mmapSizeMax = (long)(newLimit);
							if ((pFile.mmapSize) > (0))
							{
								winUnmapfile(pFile);
								rc = (int)(winMapfile(pFile, (long)(-1)));
							}
						}

						return (int)(rc);
					}
			}

			return (int)(12);
		}
		public static int winFileSize(sqlite3_file id, long* pSize)
		{
			winFile pFile = (winFile)(id);
			int rc = (int)(0);
			{
				uint upperBits = 0;
				uint lowerBits = 0;
				uint lastErrno = 0;
				lowerBits = (uint)((Uint(Void * , Void * ))(aSyscall[23].pCurrent)(pFile.h, &upperBits));
				*pSize = (long)((((long)(upperBits)) << 32) + lowerBits);
				if (((lowerBits) == (0xFFFFFFFF)) && ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 0L))
				{
					pFile.lastErrno = (uint)(lastErrno);
					rc = (int)(winLogErrorAtLine((int)(10 | (7 << 8)), (uint)(pFile.lastErrno), "winFileSize", pFile.zPath, (int)(46035)));
				}
			}

			return (int)(rc);
		}
		public static int winLock(sqlite3_file id, int locktype)
		{
			int rc = (int)(0);
			int res = (int)(1);
			int newLocktype = 0;
			int gotPendingLock = (int)(0);
			winFile pFile = (winFile)(id);
			uint lastErrno = (uint)(0L);
			if ((pFile.locktype) >= (locktype))
			{
				return (int)(0);
			}

			if (((pFile.ctrlFlags & 0x02) != 0) && ((locktype) >= (2)))
			{
				return (int)(10 | (15 << 8));
			}

			newLocktype = (int)(pFile.locktype);
			if (((pFile.locktype) == (0)) || (((locktype) == (4)) && ((pFile.locktype) <= (2))))
			{
				int cnt = (int)(3);
				while (((cnt--) > (0)) && ((res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0)))) == (0)))
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					if ((lastErrno) == (6L))
					{
						pFile.lastErrno = (uint)(lastErrno);
						rc = (int)(10 | (15 << 8));
						return (int)(rc);
					}

					if ((cnt) != 0)
						sqlite3_win32_sleep((uint)(1));
				}

				gotPendingLock = (int)(res);
				if (res == 0)
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				}
			}

			if (((locktype) == (1)) && ((res) != 0))
			{
				res = (int)(winGetReadLock(pFile));
				if ((res) != 0)
				{
					newLocktype = (int)(1);
				}
				else
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				}
			}

			if (((locktype) == (2)) && ((res) != 0))
			{
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0)));
				if ((res) != 0)
				{
					newLocktype = (int)(2);
				}
				else
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				}
			}

			if (((locktype) == (4)) && ((res) != 0))
			{
				newLocktype = (int)(3);
				gotPendingLock = (int)(0);
			}

			if (((locktype) == (4)) && ((res) != 0))
			{
				res = (int)(winUnlockReadLock(pFile));
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
				if ((res) != 0)
				{
					newLocktype = (int)(4);
				}
				else
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					winGetReadLock(pFile);
				}
			}

			if (((gotPendingLock) != 0) && ((locktype) == (1)))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0));
			}

			if ((res) != 0)
			{
				rc = (int)(0);
			}
			else
			{
				pFile.lastErrno = (uint)(lastErrno);
				rc = (int)(5);
			}

			pFile.locktype = ((byte)(newLocktype));
			return (int)(rc);
		}
		public static int winNolockCheckReservedLock(sqlite3_file id, int* pResOut)
		{
			return (int)(0);
		}
		public static int winNolockLock(sqlite3_file id, int locktype)
		{
			return (int)(0);
		}
		public static int winNolockUnlock(sqlite3_file id, int locktype)
		{
			return (int)(0);
		}
		public static int winRead(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			_OVERLAPPED overlapped = new _OVERLAPPED();
			winFile pFile = (winFile)(id);
			uint nRead = 0;
			int nRetry = (int)(0);
			if ((offset) < (pFile.mmapSize))
			{
				if ((offset + amt) <= (pFile.mmapSize))
				{
					CRuntime.memcpy(pBuf, &((byte*)(pFile.pMapRegion))[offset], (ulong)(amt));
					return (int)(0);
				}
				else
				{
					int nCopy = (int)(pFile.mmapSize - offset);
					CRuntime.memcpy(pBuf, &((byte*)(pFile.pMapRegion))[offset], (ulong)(nCopy));
					pBuf = &((byte*)(pBuf))[nCopy];
					amt -= (int)(nCopy);
					offset += (long)(nCopy);
				}
			}

			CRuntime.memset(&overlapped, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
			overlapped..Offset = (uint)((int)(offset & 0xffffffff));
			overlapped..OffsetHigh = (uint)((int)((offset >> 32) & 0x7fffffff));
			while (((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[52].pCurrent)(pFile.h, pBuf, (uint)(amt), &nRead, &overlapped) == 0) && ((Uint())(aSyscall[26].pCurrent)() != 38L))
			{
				uint lastErrno = 0;
				if ((winRetryIoerr(&nRetry, &lastErrno)) != 0)
					continue;
				pFile.lastErrno = (uint)(lastErrno);
				return (int)(winLogErrorAtLine((int)(10 | (1 << 8)), (uint)(pFile.lastErrno), "winRead", pFile.zPath, (int)(45699)));
			}

			winLogIoerr((int)(nRetry), (int)(45701));
			if ((nRead) < ((uint)(amt)))
			{
				CRuntime.memset(&((sbyte*)(pBuf))[nRead], (int)(0), (ulong)(amt - nRead));
				return (int)(10 | (2 << 8));
			}

			return (int)(0);
		}
		public static int winSectorSize(sqlite3_file id)
		{
			(void)(id);
			return (int)(4096);
		}
		public static void winShmBarrier(sqlite3_file fd)
		{
			sqlite3MemoryBarrier();
			winShmEnterMutex();
			winShmLeaveMutex();
		}
		public static int winShmLock(sqlite3_file fd, int ofst, int n, int flags)
		{
			winFile pDbFd = (winFile)(fd);
			winShm p = pDbFd.pShm;
			winShm pX;
			winShmNode pShmNode;
			int rc = (int)(0);
			ushort mask = 0;
			if ((p) == (null))
				return (int)(10 | (20 << 8));
			pShmNode = p.pShmNode;
			if (((pShmNode) == (null)))
				return (int)(10 | (20 << 8));
			mask = ((ushort)((1U << (ofst + n)) - (1U << ofst)));
			sqlite3_mutex_enter(pShmNode.mutex);
			if ((flags & 1) != 0)
			{
				ushort allMask = (ushort)(0);
				for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
				{
					if ((pX) == (p))
						continue;
					allMask |= (ushort)(pX.sharedMask);
				}

				if ((mask & allMask) == (0))
				{
					rc = (int)(winShmSystemLock(pShmNode, (int)(1), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
				}
				else
				{
					rc = (int)(0);
				}

				if ((rc) == (0))
				{
					p.exclMask &= (ushort)(~mask);
					p.sharedMask &= (ushort)(~mask);
				}
			}
			else if ((flags & 4) != 0)
			{
				ushort allShared = (ushort)(0);
				for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
				{
					if ((pX.exclMask & mask) != 0)
					{
						rc = (int)(5);
						break;
					}

					allShared |= (ushort)(pX.sharedMask);
				}

				if ((rc) == (0))
				{
					if ((allShared & mask) == (0))
					{
						rc = (int)(winShmSystemLock(pShmNode, (int)(2), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
					}
					else
					{
						rc = (int)(0);
					}
				}

				if ((rc) == (0))
				{
					p.sharedMask |= (ushort)(mask);
				}
			}
			else
			{
				for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
				{
					if (((pX.exclMask & mask) != 0) || ((pX.sharedMask & mask) != 0))
					{
						rc = (int)(5);
						break;
					}
				}

				if ((rc) == (0))
				{
					rc = (int)(winShmSystemLock(pShmNode, (int)(3), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
					if ((rc) == (0))
					{
						p.exclMask |= (ushort)(mask);
					}
				}
			}

			sqlite3_mutex_leave(pShmNode.mutex);
			return (int)(rc);
		}
		public static int winShmMap(sqlite3_file fd, int iRegion, int szRegion, int isWrite, void** pp)
		{
			winFile pDbFd = (winFile)(fd);
			winShm pShm = pDbFd.pShm;
			winShmNode pShmNode;
			uint protect = (uint)(0x04);
			uint flags = (uint)(0x0002 | 0x0004);
			int rc = (int)(0);
			if (pShm == null)
			{
				rc = (int)(winOpenSharedMemory(pDbFd));
				if (rc != 0)
					return (int)(rc);
				pShm = pDbFd.pShm;
			}

			pShmNode = pShm.pShmNode;
			sqlite3_mutex_enter(pShmNode.mutex);
			if ((pShmNode.isUnlocked) != 0)
			{
				rc = (int)(winLockSharedMemory(pShmNode));
				if (rc != 0)
					goto shmpage_out;
				pShmNode.isUnlocked = (byte)(0);
			}

			if ((pShmNode.nRegion) <= (iRegion))
			{
				ShmRegion* apNew;
				int nByte = (int)((iRegion + 1) * szRegion);
				long sz = 0;
				pShmNode.szRegion = (int)(szRegion);
				rc = (int)(winFileSize((sqlite3_file)(pShmNode.hFile), &sz));
				if (rc != 0)
				{
					rc = (int)(winLogErrorAtLine((int)(10 | (19 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winShmMap1", pDbFd.zPath, (int)(47175)));
					goto shmpage_out;
				}

				if ((sz) < (nByte))
				{
					if (isWrite == 0)
						goto shmpage_out;
					rc = (int)(winTruncate((sqlite3_file)(pShmNode.hFile), (long)(nByte)));
					if (rc != 0)
					{
						rc = (int)(winLogErrorAtLine((int)(10 | (19 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winShmMap2", pDbFd.zPath, (int)(47190)));
						goto shmpage_out;
					}
				}

				apNew = (ShmRegion*)(sqlite3_realloc64(pShmNode.aRegion, (ulong)((iRegion + 1) * sizeof(ShmRegion))));
				if (apNew == null)
				{
					rc = (int)(10 | (12 << 8));
					goto shmpage_out;
				}

				pShmNode.aRegion = apNew;
				if ((pShmNode.isReadonly) != 0)
				{
					protect = (uint)(0x02);
					flags = (uint)(0x0004);
				}

				while ((pShmNode.nRegion) <= (iRegion))
				{
					void* hMap = null;
					void* pMap = null;
					hMap = (Void * (Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[7].pCurrent)(pShmNode.hFile.h, null, (uint)(protect), (uint)(0), (uint)(nByte), null);
					if ((hMap) != null)
					{
						int iOffset = (int)(pShmNode.nRegion * szRegion);
						int iOffsetShift = (int)(iOffset % winSysInfo.dwAllocationGranularity);
						pMap = (Void * (Void * , Void * , Void * , Void * , Void * ))(aSyscall[49].pCurrent)(hMap, (uint)(flags), (uint)(0), (uint)(iOffset - iOffsetShift), (ulong)(szRegion + iOffsetShift));
					}

					if (pMap == null)
					{
						pShmNode.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
						rc = (int)(winLogErrorAtLine((int)(10 | (21 << 8)), (uint)(pShmNode.lastErrno), "winShmMap3", pDbFd.zPath, (int)(47249)));
						if ((hMap) != null)
							(Int(Void * ))(aSyscall[3].pCurrent)(hMap);
						goto shmpage_out;
					}

					pShmNode.aRegion[pShmNode.nRegion].pMap = pMap;
					pShmNode.aRegion[pShmNode.nRegion].hMap = hMap;
					pShmNode.nRegion++;
				}
			}

		shmpage_out:
			; if ((pShmNode.nRegion) > (iRegion)) { int iOffset = (int)(iRegion * szRegion); int iOffsetShift = (int)(iOffset % winSysInfo.dwAllocationGranularity); sbyte* p = (sbyte*)(pShmNode.aRegion[iRegion].pMap); *pp = (void*)(&p[iOffsetShift]); } else { *pp = null; }
			if (((pShmNode.isReadonly) != 0) && ((rc) == (0)))
				rc = (int)(8);
			sqlite3_mutex_leave(pShmNode.mutex);
			return (int)(rc);
		}
		public static int winShmUnmap(sqlite3_file fd, int deleteFlag)
		{
			winFile pDbFd;
			winShm p;
			winShmNode pShmNode;
			winShm pp;
			pDbFd = (winFile)(fd);
			p = pDbFd.pShm;
			if ((p) == (null))
				return (int)(0);
			pShmNode = p.pShmNode;
			sqlite3_mutex_enter(pShmNode.mutex);
			for (pp = pShmNode.pFirst; (pp) != p; pp = (pp).pNext)
			{
			}

			pp = p.pNext;
			sqlite3_free(p);
			pDbFd.pShm = null;
			sqlite3_mutex_leave(pShmNode.mutex);
			winShmEnterMutex();
			pShmNode.nRef--;
			if ((pShmNode.nRef) == (0))
			{
				winShmPurge(pDbFd.pVfs, (int)(deleteFlag));
			}

			winShmLeaveMutex();
			return (int)(0);
		}
		public static int winSync(sqlite3_file id, int flags)
		{
			int rc = 0;
			winFile pFile = (winFile)(id);
			if ((pFile.pMapRegion) != null)
			{
				if (((Int(Void * , Void * ))(aSyscall[79].pCurrent)(pFile.pMapRegion, (ulong)(0))) != 0)
				{
				}
				else
				{
					pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					return (int)(winLogErrorAtLine((int)(10 | (24 << 8)), (uint)(pFile.lastErrno), "winSync1", pFile.zPath, (int)(45979)));
				}
			}

			rc = (int)((Int(Void * ))(aSyscall[13].pCurrent)(pFile.h));
			if ((rc) != 0)
			{
				return (int)(0);
			}
			else
			{
				pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				return (int)(winLogErrorAtLine((int)(10 | (4 << 8)), (uint)(pFile.lastErrno), "winSync2", pFile.zPath, (int)(45994)));
			}
		}
		public static int winTruncate(sqlite3_file id, long nByte)
		{
			winFile pFile = (winFile)(id);
			int rc = (int)(0);
			uint lastErrno = 0;
			long oldMmapSize = 0;
			if ((pFile.nFetchOut) > (0))
			{
				return (int)(0);
			}

			if ((pFile.szChunk) > (0))
			{
				nByte = (long)(((nByte + pFile.szChunk - 1) / pFile.szChunk) * pFile.szChunk);
			}

			if ((pFile.pMapRegion) != null)
			{
				oldMmapSize = (long)(pFile.mmapSize);
			}
			else
			{
				oldMmapSize = (long)(0);
			}

			winUnmapfile(pFile);
			if ((winSeekFile(pFile, (long)(nByte))) != 0)
			{
				rc = (int)(winLogErrorAtLine((int)(10 | (6 << 8)), (uint)(pFile.lastErrno), "winTruncate1", pFile.zPath, (int)(45882)));
			}
			else if (((0) == ((Int(Void * ))(aSyscall[53].pCurrent)(pFile.h))) && ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 1224L))
			{
				pFile.lastErrno = (uint)(lastErrno);
				rc = (int)(winLogErrorAtLine((int)(10 | (6 << 8)), (uint)(pFile.lastErrno), "winTruncate2", pFile.zPath, (int)(45887)));
			}

			if (((rc) == (0)) && ((oldMmapSize) > (0)))
			{
				if ((oldMmapSize) > (nByte))
				{
					winMapfile(pFile, (long)(-1));
				}
				else
				{
					winMapfile(pFile, (long)(oldMmapSize));
				}
			}

			return (int)(rc);
		}
		public static int winUnfetch(sqlite3_file fd, long iOff, void* p)
		{
			winFile pFd = (winFile)(fd);
			if ((p) != null)
			{
				pFd.nFetchOut--;
			}
			else
			{
				winUnmapfile(pFd);
			}

			return (int)(0);
		}
		public static int winUnlock(sqlite3_file id, int locktype)
		{
			int type = 0;
			winFile pFile = (winFile)(id);
			int rc = (int)(0);
			type = (int)(pFile.locktype);
			if ((type) >= (4))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0));
				if (((locktype) == (1)) && (winGetReadLock(pFile) == 0))
				{
					rc = (int)(winLogErrorAtLine((int)(10 | (8 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winUnlock", pFile.zPath, (int)(46356)));
				}
			}

			if ((type) >= (2))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0));
			}

			if (((locktype) == (0)) && ((type) >= (1)))
			{
				winUnlockReadLock(pFile);
			}

			if ((type) >= (3))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0));
			}

			pFile.locktype = ((byte)(locktype));
			return (int)(rc);
		}
		public static int winWrite(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			int rc = (int)(0);
			winFile pFile = (winFile)(id);
			int nRetry = (int)(0);
			{
				_OVERLAPPED overlapped = new _OVERLAPPED();
				byte* aRem = (byte*)(pBuf);
				int nRem = (int)(amt);
				uint nWrite = 0;
				uint lastErrno = (uint)(0L);
				CRuntime.memset(&overlapped, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
				overlapped..Offset = (uint)((int)(offset & 0xffffffff));
				overlapped..OffsetHigh = (uint)((int)((offset >> 32) & 0x7fffffff));
				while ((nRem) > (0))
				{
					if ((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[61].pCurrent)(pFile.h, aRem, (uint)(nRem), &nWrite, &overlapped) == 0)
					{
						if ((winRetryIoerr(&nRetry, &lastErrno)) != 0)
							continue;
						break;
					}

					if (((nWrite) == (0)) || ((nWrite) > ((uint)(nRem))))
					{
						lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
						break;
					}

					offset += (long)(nWrite);
					overlapped..Offset = (uint)((int)(offset & 0xffffffff));
					overlapped..OffsetHigh = (uint)((int)((offset >> 32) & 0x7fffffff));
					aRem += nWrite;
					nRem -= (int)(nWrite);
				}

				if ((nRem) > (0))
				{
					pFile.lastErrno = (uint)(lastErrno);
					rc = (int)(1);
				}
			}

			if ((rc) != 0)
			{
				if (((pFile.lastErrno) == (39L)) || ((pFile.lastErrno) == (112L)))
				{
					return (int)(winLogErrorAtLine((int)(13), (uint)(pFile.lastErrno), "winWrite1", pFile.zPath, (int)(45811)));
				}

				return (int)(winLogErrorAtLine((int)(10 | (3 << 8)), (uint)(pFile.lastErrno), "winWrite2", pFile.zPath, (int)(45816)));
			}
			else
			{
				winLogIoerr((int)(nRetry), (int)(45818));
			}

			return (int)(0);
		}
		public static int write32bits(sqlite3_file fd, long offset, uint val)
		{
			sbyte* ac = stackalloc sbyte[4];
			sqlite3Put4byte((byte*)(ac), (uint)(val));
			return (int)(sqlite3OsWrite(fd, ac, (int)(4), (long)(offset)));
		}
	}
}