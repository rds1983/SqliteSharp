// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int agginfoPersistExprCb(Walker pWalker, Expr pExpr)
		{
			if (((!(((pExpr).flags & (0x004000 | 0x002000)) != 0)) != 0) && (pExpr.pAggInfo != null))
			{
				AggInfo pAggInfo = pExpr.pAggInfo;
				int iAgg = (int)(pExpr.iAgg);
				Parse pParse = pWalker.pParse;
				sqlite3 db = pParse.db;
				if ((pExpr.op) == (169))
				{
					if ((pAggInfo.aCol[iAgg].pCExpr) == (pExpr))
					{
						pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
						if ((pExpr) != null)
						{
							pAggInfo.aCol[iAgg].pCExpr = pExpr;
							sqlite3ExprDeferredDelete(pParse, pExpr);
						}
					}
				}
				else
				{
					if ((pAggInfo.aFunc[iAgg].pFExpr) == (pExpr))
					{
						pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
						if ((pExpr) != null)
						{
							pAggInfo.aFunc[iAgg].pFExpr = pExpr;
							sqlite3ExprDeferredDelete(pParse, pExpr);
						}
					}
				}
			}

			return (int)(0);
		}
		public static int analyzeAggregate(Walker pWalker, Expr pExpr)
		{
			int i = 0;
			NameContext pNC = pWalker.u.pNC;
			Parse pParse = pNC.pParse;
			SrcList pSrcList = pNC.pSrcList;
			AggInfo pAggInfo = pNC.uNC.pAggInfo;
			switch (pExpr.op)
			{
				case 169:
				case 167:
					{
						if ((pSrcList != null))
						{
							SrcItem pItem = pSrcList.a;
							for (i = (int)(0); (i) < (pSrcList.nSrc); i++, pItem++)
							{
								AggInfo_col pCol;
								if ((pExpr.iTable) == (pItem.iCursor))
								{
									int k = 0;
									pCol = pAggInfo.aCol;
									for (k = (int)(0); (k) < (pAggInfo.nColumn); k++, pCol++)
									{
										if (((pCol.iTable) == (pExpr.iTable)) && ((pCol.iColumn) == (pExpr.iColumn)))
										{
											break;
										}
									}

									if (((k) >= (pAggInfo.nColumn)) && ((k = (int)(addAggInfoColumn(pParse.db, pAggInfo))) >= (0)))
									{
										pCol = pAggInfo.aCol[k];
										pCol.pTab = pExpr.y.pTab;
										pCol.iTable = (int)(pExpr.iTable);
										pCol.iColumn = (short)(pExpr.iColumn);
										pCol.iMem = (int)(++pParse.nMem);
										pCol.iSorterColumn = (short)(-1);
										pCol.pCExpr = pExpr;
										if ((pAggInfo.pGroupBy) != null)
										{
											int j = 0;
											int n = 0;
											ExprList pGB = pAggInfo.pGroupBy;
											ExprList_item* pTerm = pGB.a;
											n = (int)(pGB.nExpr);
											for (j = (int)(0); (j) < (n); j++, pTerm++)
											{
												Expr pE = pTerm->pExpr;
												if ((((pE.op) == (167)) && ((pE.iTable) == (pExpr.iTable))) && ((pE.iColumn) == (pExpr.iColumn)))
												{
													pCol.iSorterColumn = (short)(j);
													break;
												}
											}
										}

										if ((pCol.iSorterColumn) < (0))
										{
											pCol.iSorterColumn = (short)(pAggInfo.nSortingColumn++);
										}
									}

									pExpr.pAggInfo = pAggInfo;
									pExpr.op = (byte)(169);
									pExpr.iAgg = ((short)(k));
									break;
								}
							}
						}

						return (int)(1);
					}

				case 168:
					{
						if (((pNC.ncFlags & 0x020000) == (0)) && ((pWalker.walkerDepth) == (pExpr.op2)))
						{
							AggInfo_func pItem = pAggInfo.aFunc;
							for (i = (int)(0); (i) < (pAggInfo.nFunc); i++, pItem++)
							{
								if ((pItem.pFExpr) == (pExpr))
									break;
								if ((sqlite3ExprCompare(null, pItem.pFExpr, pExpr, (int)(-1))) == (0))
								{
									break;
								}
							}

							if ((i) >= (pAggInfo.nFunc))
							{
								byte enc = (byte)((pParse.db).enc);
								i = (int)(addAggInfoFunc(pParse.db, pAggInfo));
								if ((i) >= (0))
								{
									pItem = pAggInfo.aFunc[i];
									pItem.pFExpr = pExpr;
									pItem.iMem = (int)(++pParse.nMem);
									pItem.pFunc = sqlite3FindFunction(pParse.db, pExpr.u.zToken, (int)(pExpr.x.pList ? pExpr.x.pList.nExpr : 0), (byte)(enc), (byte)(0));
									if ((pExpr.flags & 0x000002) != 0)
									{
										pItem.iDistinct = (int)(pParse.nTab++);
									}
									else
									{
										pItem.iDistinct = (int)(-1);
									}
								}
							}

							pExpr.iAgg = ((short)(i));
							pExpr.pAggInfo = pAggInfo;
							return (int)(1);
						}
						else
						{
							return (int)(0);
						}
					}
			}

			return (int)(0);
		}
		public static int checkConstraintExprNode(Walker pWalker, Expr pExpr)
		{
			if ((pExpr.op) == (167))
			{
				if ((pExpr.iColumn) >= (0))
				{
					if ((pWalker.u.aiCol[pExpr.iColumn]) >= (0))
					{
						pWalker.eCode |= (ushort)(0x01);
					}
				}
				else
				{
					pWalker.eCode |= (ushort)(0x02);
				}
			}

			return (int)(0);
		}
		public static int convertCompoundSelectToSubquery(Walker pWalker, Select p)
		{
			int i = 0;
			Select pNew;
			Select pX;
			sqlite3 db;
			ExprList_item* a;
			SrcList pNewSrc;
			Parse pParse;
			Token dummy = new Token();
			if ((p.pPrior) == (null))
				return (int)(0);
			if ((p.pOrderBy) == (null))
				return (int)(0);
			for (pX = p; ((pX) != null) && (((pX.op) == (135)) || ((pX.op) == (138))); pX = pX.pPrior)
			{
			}

			if ((pX) == (null))
				return (int)(0);
			a = p.pOrderBy.a;
			if ((a[0].u.x.iOrderByCol) != 0)
				return (int)(0);
			for (i = (int)(p.pOrderBy.nExpr - 1); (i) >= (0); i--)
			{
				if ((a[i].pExpr.flags & 0x000100) != 0)
					break;
			}

			if ((i) < (0))
				return (int)(0);
			pParse = pWalker.pParse;
			db = pParse.db;
			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Select)));
			if ((pNew) == (null))
				return (int)(2);
			CRuntime.memset(&dummy, (int)(0), (ulong)(sizeof(Token)));
			pNewSrc = sqlite3SrcListAppendFromTerm(pParse, null, null, null, &dummy, pNew, null, null);
			if ((pNewSrc) == (null))
				return (int)(2);
			pNew = (Select)(p);
			p.pSrc = pNewSrc;
			p.pEList = sqlite3ExprListAppend(pParse, null, sqlite3Expr(db, (int)(180), null));
			p.op = (byte)(138);
			p.pWhere = null;
			pNew.pGroupBy = null;
			pNew.pHaving = null;
			pNew.pOrderBy = null;
			p.pPrior = null;
			p.pNext = null;
			p.pWith = null;
			p.pWinDefn = null;
			p.selFlags &= (uint)(~0x0000100);
			p.selFlags |= (uint)(0x0010000);
			pNew.pPrior.pNext = pNew;
			pNew.pLimit = null;
			return (int)(0);
		}
		public static int disallowAggregatesInOrderByCb(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (168)) && ((pExpr.pAggInfo) == (null)))
			{
				sqlite3ErrorMsg(pWalker.pParse, "misuse of aggregate: %s()", pExpr.u.zToken);
			}

			return (int)(0);
		}
		public static int exprColumnFlagUnion(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (167)) && ((pExpr.iColumn) >= (0)))
			{
				pWalker.eCode |= (ushort)(pWalker.u.pTab.aCol[pExpr.iColumn].colFlags);
			}

			return (int)(0);
		}
		public static int exprIdxCover(Walker pWalker, Expr pExpr)
		{
			if ((((pExpr.op) == (167)) && ((pExpr.iTable) == (pWalker.u.pIdxCover.iCur))) && ((sqlite3TableColumnToIndex(pWalker.u.pIdxCover.pIdx, (short)(pExpr.iColumn))) < (0)))
			{
				pWalker.eCode = (ushort)(1);
				return (int)(2);
			}

			return (int)(0);
		}
		public static int exprNodeIsConstant(Walker pWalker, Expr pExpr)
		{
			if (((pWalker.eCode) == (2)) && (((pExpr).flags & (0x000001)) != 0))
			{
				pWalker.eCode = (ushort)(0);
				return (int)(2);
			}

			switch (pExpr.op)
			{
				case 172:
					if ((((pWalker.eCode) >= (4)) || (((pExpr).flags & (0x080000)) != 0)) && (!(((pExpr).flags & (0x1000000)) != 0)))
					{
						if ((pWalker.eCode) == (5))
							(pExpr).flags |= (uint)(0x40000000);
						return (int)(0);
					}
					else
					{
						pWalker.eCode = (ushort)(0);
						return (int)(2);
					}

				case 59:
					if ((sqlite3ExprIdToTrueFalse(pExpr)) != 0)
					{
						return (int)(1);
					}

				case 167:
				case 168:
				case 169:
					;
					if ((((pExpr).flags & (0x000008)) != 0) && (pWalker.eCode != 2))
					{
						return (int)(0);
					}

					if (((pWalker.eCode) == (3)) && ((pExpr.iTable) == (pWalker.u.iCur)))
					{
						return (int)(0);
					}

				case 179:
				case 176:
				case 141:
					;
					pWalker.eCode = (ushort)(0);
					return (int)(2);
				case 156:
					if ((pWalker.eCode) == (5))
					{
						pExpr.op = (byte)(121);
					}
					else if ((pWalker.eCode) == (4))
					{
						pWalker.eCode = (ushort)(0);
						return (int)(2);
					}

				default:
					;
					return (int)(0);
			}
		}
		public static int exprNodeIsConstantOrGroupBy(Walker pWalker, Expr pExpr)
		{
			ExprList pGroupBy = pWalker.u.pGroupBy;
			int i = 0;
			for (i = (int)(0); (i) < (pGroupBy.nExpr); i++)
			{
				Expr p = pGroupBy.a[i].pExpr;
				if ((sqlite3ExprCompare(null, pExpr, p, (int)(-1))) < (2))
				{
					CollSeq pColl = sqlite3ExprNNCollSeq(pWalker.pParse, p);
					if ((sqlite3IsBinary(pColl)) != 0)
					{
						return (int)(1);
					}
				}
			}

			if ((((pExpr).flags & 0x000800) != 0))
			{
				pWalker.eCode = (ushort)(0);
				return (int)(2);
			}

			return (int)(exprNodeIsConstant(pWalker, pExpr));
		}
		public static int exprNodeIsDeterministic(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (172)) && ((((pExpr).flags & (0x080000)) != 0) == (0)))
			{
				pWalker.eCode = (ushort)(0);
				return (int)(2);
			}

			return (int)(0);
		}
		public static int exprRefToSrcList(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (167)) || ((pExpr.op) == (169)))
			{
				int i = 0;
				RefSrcList p = pWalker.u.pRefSrcList;
				SrcList pSrc = p.pRef;
				int nSrc = (int)(pSrc ? pSrc.nSrc : 0);
				for (i = (int)(0); (i) < (nSrc); i++)
				{
					if ((pExpr.iTable) == (pSrc.a[i].iCursor))
					{
						pWalker.eCode |= (ushort)(1);
						return (int)(0);
					}
				}

				for (i = (int)(0); ((i) < (p.nExclude)) && (p.aiExclude[i] != pExpr.iTable); i++)
				{
				}

				if ((i) >= (p.nExclude))
				{
					pWalker.eCode |= (ushort)(2);
				}
			}

			return (int)(0);
		}
		public static int fixExprCb(Walker p, Expr pExpr)
		{
			DbFixer pFix = p.u.pFix;
			if (pFix.bTemp == 0)
				(pExpr).flags |= (uint)(0x40000000);
			if ((pExpr.op) == (156))
			{
				if ((pFix.pParse.db.init.busy) != 0)
				{
					pExpr.op = (byte)(121);
				}
				else
				{
					sqlite3ErrorMsg(pFix.pParse, "%s cannot use variables", pFix.zType);
					return (int)(2);
				}
			}

			return (int)(0);
		}
		public static int fixSelectCb(Walker p, Select pSelect)
		{
			DbFixer pFix = p.u.pFix;
			int i = 0;
			SrcItem pItem;
			sqlite3 db = pFix.pParse.db;
			int iDb = (int)(sqlite3FindDbName(db, pFix.zDb));
			SrcList pList = pSelect.pSrc;
			if (((pList) == (null)))
				return (int)(0);
			for (i = (int)(0), pItem = pList.a; (i) < (pList.nSrc); i++, pItem++)
			{
				if ((pFix.bTemp) == (0))
				{
					if ((pItem.zDatabase) != null)
					{
						if (iDb != sqlite3FindDbName(db, pItem.zDatabase))
						{
							sqlite3ErrorMsg(pFix.pParse, "%s %T cannot reference objects in database %s", pFix.zType, pFix.pName, pItem.zDatabase);
							return (int)(2);
						}

						sqlite3DbFree(db, pItem.zDatabase);
						pItem.zDatabase = null;
						pItem.fg.notCte = (uint)(1);
					}

					pItem.pSchema = pFix.pSchema;
					pItem.fg.fromDDL = (uint)(1);
				}

				if ((sqlite3WalkExpr(pFix.w, pList.a[i].pOn)) != 0)
					return (int)(2);
			}

			if ((pSelect.pWith) != null)
			{
				for (i = (int)(0); (i) < (pSelect.pWith.nCte); i++)
				{
					if ((sqlite3WalkSelect(p, pSelect.pWith.a[i].pSelect)) != 0)
					{
						return (int)(2);
					}
				}
			}

			return (int)(0);
		}
		public static int gatherSelectWindowsCallback(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (172)) && (((pExpr).flags & (0x1000000)) != 0))
			{
				Select pSelect = pWalker.u.pSelect;
				Window pWin = pExpr.y.pWin;
				sqlite3WindowLink(pSelect, pWin);
			}

			return (int)(0);
		}
		public static int gatherSelectWindowsSelectCallback(Walker pWalker, Select p)
		{
			return (int)((p) == (pWalker.u.pSelect) ? 0 : 1);
		}
		public static int havingToWhereExprCb(Walker pWalker, Expr pExpr)
		{
			if (pExpr.op != 44)
			{
				Select pS = pWalker.u.pSelect;
				if ((((sqlite3ExprIsConstantOrGroupBy(pWalker.pParse, pExpr, pS.pGroupBy)) != 0) && ((((pExpr).flags & (0x000001 | 0x20000000)) == (0x20000000)) == (0))) && ((pExpr.pAggInfo) == (null)))
				{
					sqlite3 db = pWalker.pParse.db;
					Expr pNew = sqlite3Expr(db, (int)(155), "1");
					if ((pNew) != null)
					{
						Expr pWhere = pS.pWhere;
						{
							Expr t = (Expr)(pNew);
							pNew = (Expr)(pExpr);
							pExpr = (Expr)(t);
						}

						pNew = sqlite3ExprAnd(pWalker.pParse, pWhere, pNew);
						pS.pWhere = pNew;
						pWalker.eCode = (ushort)(1);
					}
				}

				return (int)(1);
			}

			return (int)(0);
		}
		public static int impliesNotNullRow(Walker pWalker, Expr pExpr)
		{
			if ((((pExpr).flags & (0x000001)) != 0))
				return (int)(1);
			switch (pExpr.op)
			{
				case 171:
				case 50:
				case 51:
				case 45:
				case 43:
				case 177:
				case 157:
				case 49:
				case 172:
				case 175:
					;
					return (int)(1);
				case 167:
					if ((pWalker.u.iCur) == (pExpr.iTable))
					{
						pWalker.eCode = (ushort)(1);
						return (int)(2);
					}

					return (int)(1);
				case 44:
					if ((pWalker.eCode) == (0))
					{
						sqlite3WalkExpr(pWalker, pExpr.pLeft);
						if ((pWalker.eCode) != 0)
						{
							pWalker.eCode = (ushort)(0);
							sqlite3WalkExpr(pWalker, pExpr.pRight);
						}
					}

					return (int)(1);
				case 48:
					if ((sqlite3WalkExpr(pWalker, pExpr.pLeft)) == (2))
					{
						return (int)(2);
					}

					return (int)(1);
				case 53:
				case 52:
				case 56:
				case 55:
				case 54:
				case 57:
					{
						Expr pLeft = pExpr.pLeft;
						Expr pRight = pExpr.pRight;
						if (((((pLeft.op) == (167)) && (pLeft.y.pTab != null)) && (((pLeft.y.pTab).eTabType) == (1))) || ((((pRight.op) == (167)) && (pRight.y.pTab != null)) && (((pRight.y.pTab).eTabType) == (1))))
						{
							return (int)(1);
						}
					}

				default:
					return (int)(0);
			}
		}
		public static int incrAggDepth(Walker pWalker, Expr pExpr)
		{
			if ((pExpr.op) == (168))
				pExpr.op2 += (byte)(pWalker.u.n);
			return (int)(0);
		}
		public static int propagateConstantExprRewrite(Walker pWalker, Expr pExpr)
		{
			WhereConst pConst = pWalker.u.pConst;
			if ((pConst.bHasAffBlob) != 0)
			{
				if ((((pExpr.op) >= (53)) && ((pExpr.op) <= (57))) || ((pExpr.op) == (45)))
				{
					propagateConstantExprRewriteOne(pConst, pExpr.pLeft, (int)(0));
					if ((pConst.pOomFault[0]) != 0)
						return (int)(1);
					if (sqlite3ExprAffinity(pExpr.pLeft) != 0x42)
					{
						propagateConstantExprRewriteOne(pConst, pExpr.pRight, (int)(0));
					}
				}
			}

			return (int)(propagateConstantExprRewriteOne(pConst, pExpr, (int)(pConst.bHasAffBlob)));
		}
		public static int recomputeColumnsUsedExpr(Walker pWalker, Expr pExpr)
		{
			SrcItem pItem;
			if (pExpr.op != 167)
				return (int)(0);
			pItem = pWalker.u.pSrcItem;
			if (pItem.iCursor != pExpr.iTable)
				return (int)(0);
			if ((pExpr.iColumn) < (0))
				return (int)(0);
			pItem.colUsed |= (ulong)(sqlite3ExprColUsed(pExpr));
			return (int)(0);
		}
		public static int renameColumnExprCb(Walker pWalker, Expr pExpr)
		{
			RenameCtx p = pWalker.u.pRename;
			if ((((pExpr.op) == (77)) && ((pExpr.iColumn) == (p.iCol))) && ((pWalker.pParse.pTriggerTab) == (p.pTab)))
			{
				renameTokenFind(pWalker.pParse, p, (void*)(pExpr));
			}
			else if (((((pExpr.op) == (167)) && ((pExpr.iColumn) == (p.iCol))) && ((((pExpr).flags & (0x1000000 | 0x2000000)) == (0)) != 0)) && ((p.pTab) == (pExpr.y.pTab)))
			{
				renameTokenFind(pWalker.pParse, p, (void*)(pExpr));
			}

			return (int)(0);
		}
		public static int renameColumnSelectCb(Walker pWalker, Select p)
		{
			if ((p.selFlags & (0x0200000 | 0x4000000)) != 0)
			{
				return (int)(1);
			}

			renameWalkWith(pWalker, p);
			return (int)(0);
		}
		public static int renameQuotefixExprCb(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (117)) && ((pExpr.flags & 0x000040) != 0))
			{
				renameTokenFind(pWalker.pParse, pWalker.u.pRename, (void*)(pExpr));
			}

			return (int)(0);
		}
		public static int renameTableExprCb(Walker pWalker, Expr pExpr)
		{
			RenameCtx p = pWalker.u.pRename;
			if ((((pExpr.op) == (167)) && ((((pExpr).flags & (0x1000000 | 0x2000000)) == (0)) != 0)) && ((p.pTab) == (pExpr.y.pTab)))
			{
				renameTokenFind(pWalker.pParse, p, (void*)(pExpr.y.pTab));
			}

			return (int)(0);
		}
		public static int renameTableSelectCb(Walker pWalker, Select pSelect)
		{
			int i = 0;
			RenameCtx p = pWalker.u.pRename;
			SrcList pSrc = pSelect.pSrc;
			if ((pSelect.selFlags & (0x0200000 | 0x4000000)) != 0)
			{
				return (int)(1);
			}

			if (((pSrc) == (null)))
			{
				return (int)(2);
			}

			for (i = (int)(0); (i) < (pSrc.nSrc); i++)
			{
				SrcItem pItem = pSrc.a[i];
				if ((pItem.pTab) == (p.pTab))
				{
					renameTokenFind(pWalker.pParse, p, pItem.zName);
				}
			}

			renameWalkWith(pWalker, pSelect);
			return (int)(0);
		}
		public static int renameUnmapExprCb(Walker pWalker, Expr pExpr)
		{
			Parse pParse = pWalker.pParse;
			sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr));
			if ((((pExpr).flags & (0x1000000 | 0x2000000)) == (0)))
			{
				sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr.y.pTab));
			}

			return (int)(0);
		}
		public static int renameUnmapSelectCb(Walker pWalker, Select p)
		{
			Parse pParse = pWalker.pParse;
			int i = 0;
			if ((pParse.nErr) != 0)
				return (int)(2);
			if ((p.selFlags & (0x0200000 | 0x4000000)) != 0)
			{
				return (int)(1);
			}

			if ((p.pEList) != null)
			{
				ExprList pList = p.pEList;
				for (i = (int)(0); (i) < (pList.nExpr); i++)
				{
					if (((pList.a[i].zEName) != null) && ((pList.a[i].eEName) == (0)))
					{
						sqlite3RenameTokenRemap(pParse, null, (void*)(pList.a[i].zEName));
					}
				}
			}

			if ((p.pSrc) != null)
			{
				SrcList pSrc = p.pSrc;
				for (i = (int)(0); (i) < (pSrc.nSrc); i++)
				{
					sqlite3RenameTokenRemap(pParse, null, (void*)(pSrc.a[i].zName));
					sqlite3WalkExpr(pWalker, pSrc.a[i].pOn);
					unmapColumnIdlistNames(pParse, pSrc.a[i].pUsing);
				}
			}

			renameWalkWith(pWalker, p);
			return (int)(0);
		}
		public static void renameWalkTrigger(Walker pWalker, Trigger pTrigger)
		{
			TriggerStep pStep;
			sqlite3WalkExpr(pWalker, pTrigger.pWhen);
			for (pStep = pTrigger.step_list; pStep; pStep = pStep.pNext)
			{
				sqlite3WalkSelect(pWalker, pStep.pSelect);
				sqlite3WalkExpr(pWalker, pStep.pWhere);
				sqlite3WalkExprList(pWalker, pStep.pExprList);
				if ((pStep.pUpsert) != null)
				{
					Upsert pUpsert = pStep.pUpsert;
					sqlite3WalkExprList(pWalker, pUpsert.pUpsertTarget);
					sqlite3WalkExprList(pWalker, pUpsert.pUpsertSet);
					sqlite3WalkExpr(pWalker, pUpsert.pUpsertWhere);
					sqlite3WalkExpr(pWalker, pUpsert.pUpsertTargetWhere);
				}

				if ((pStep.pFrom) != null)
				{
					int i = 0;
					for (i = (int)(0); (i) < (pStep.pFrom.nSrc); i++)
					{
						sqlite3WalkSelect(pWalker, pStep.pFrom.a[i].pSelect);
					}
				}
			}
		}
		public static void renameWalkWith(Walker pWalker, Select pSelect)
		{
			With pWith = pSelect.pWith;
			if ((pWith) != null)
			{
				Parse pParse = pWalker.pParse;
				int i = 0;
				With pCopy = null;
				if ((pWith.a[0].pSelect.selFlags & 0x0000040) == (0))
				{
					pCopy = sqlite3WithDup(pParse.db, pWith);
					pCopy = sqlite3WithPush(pParse, pCopy, (byte)(1));
				}

				for (i = (int)(0); (i) < (pWith.nCte); i++)
				{
					Select p = pWith.a[i].pSelect;
					NameContext sNC = new NameContext();
					CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
					sNC.pParse = pParse;
					if ((pCopy) != null)
						sqlite3SelectPrep(sNC.pParse, p, sNC);
					if ((sNC.pParse.db.mallocFailed) != 0)
						return;
					sqlite3WalkSelect(pWalker, p);
					sqlite3RenameExprlistUnmap(pParse, pWith.a[i].pCols);
				}

				if (((pCopy) != null) && ((pParse.pWith) == (pCopy)))
				{
					pParse.pWith = pCopy.pOuter;
				}
			}
		}
		public static void renumberCursorDoMapping(Walker pWalker, int* piCursor)
		{
			int* aCsrMap = pWalker.u.aiCol;
			int iCsr = (int)(*piCursor);
			if (((iCsr) < (aCsrMap[0])) && ((aCsrMap[iCsr + 1]) > (0)))
			{
				*piCursor = (int)(aCsrMap[iCsr + 1]);
			}
		}
		public static int renumberCursorsCb(Walker pWalker, Expr pExpr)
		{
			int op = (int)(pExpr.op);
			if (((op) == (167)) || ((op) == (179)))
			{
				renumberCursorDoMapping(pWalker, &pExpr.iTable);
			}

			if ((((pExpr).flags & (0x000001)) != 0))
			{
				renumberCursorDoMapping(pWalker, &pExpr.w.iRightJoinTable);
			}

			return (int)(0);
		}
		public static int resolveExprStep(Walker pWalker, Expr pExpr)
		{
			NameContext pNC;
			Parse pParse;
			pNC = pWalker.u.pNC;
			pParse = pNC.pParse;
			switch (pExpr.op)
			{
				case 75:
					{
						SrcList pSrcList = pNC.pSrcList;
						SrcItem pItem;
						pItem = pSrcList.a;
						pExpr.op = (byte)(167);
						pExpr.y.pTab = pItem.pTab;
						pExpr.iTable = (int)(pItem.iCursor);
						pExpr.iColumn--;
						pExpr.affExpr = (sbyte)(0x44);
						break;
					}

				case 51:
				case 50:
					{
						int* anRef = stackalloc int[8];
						NameContext p;
						int i = 0;
						for (i = (int)(0), p = pNC; ((p) != null) && ((i) < ((int)(8 * sizeof(int) / sizeof(int)))); p = p.pNext, i++)
						{
							anRef[i] = (int)(p.nRef);
						}

						sqlite3WalkExpr(pWalker, pExpr.pLeft);
						if (((0) == (sqlite3ExprCanBeNull(pExpr.pLeft))) && (!((pParse.eParseMode) >= (2))))
						{
							if ((pExpr.op) == (51))
							{
								pExpr.u.zToken = "true";
								(pExpr).flags |= (uint)(0x10000000);
							}
							else
							{
								pExpr.u.zToken = "false";
								(pExpr).flags |= (uint)(0x20000000);
							}

							pExpr.op = (byte)(170);
							for (i = (int)(0), p = pNC; ((p) != null) && ((i) < ((int)(8 * sizeof(int) / sizeof(int)))); p = p.pNext, i++)
							{
								p.nRef = (int)(anRef[i]);
							}

							sqlite3ExprDelete(pParse.db, pExpr.pLeft);
							pExpr.pLeft = null;
						}

						return (int)(1);
					}

				case 59:
				case 141:
					{
						sbyte* zColumn;
						sbyte* zTable;
						sbyte* zDb;
						Expr pRight;
						if ((pExpr.op) == (59))
						{
							zDb = null;
							zTable = null;
							zColumn = pExpr.u.zToken;
						}
						else
						{
							Expr pLeft = pExpr.pLeft;
							if (((pNC).ncFlags & (0x000020 | 0x000008)) != 0)
								notValidImpl(pParse, pNC, "the \".\" operator", null, pExpr);
							pRight = pExpr.pRight;
							if ((pRight.op) == (59))
							{
								zDb = null;
							}
							else
							{
								zDb = pLeft.u.zToken;
								pLeft = pRight.pLeft;
								pRight = pRight.pRight;
							}

							zTable = pLeft.u.zToken;
							zColumn = pRight.u.zToken;
							if (((pParse.eParseMode) >= (2)))
							{
								sqlite3RenameTokenRemap(pParse, (void*)(pExpr), (void*)(pRight));
								sqlite3RenameTokenRemap(pParse, (void*)(pExpr.y.pTab), (void*)(pLeft));
							}
						}

						return (int)(lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr));
					}

				case 172:
					{
						ExprList pList = pExpr.x.pList;
						int n = (int)(pList ? pList.nExpr : 0);
						int no_such_func = (int)(0);
						int wrong_num_args = (int)(0);
						int is_agg = (int)(0);
						sbyte* zId;
						FuncDef pDef;
						byte enc = (byte)((pParse.db).enc);
						int savedAllowFlags = (int)(pNC.ncFlags & (0x000001 | 0x004000));
						Window pWin = (((((pExpr).flags & (0x1000000)) != 0) && (pExpr.y.pWin.eFrmType != 166)) ? pExpr.y.pWin : null);
						zId = pExpr.u.zToken;
						pDef = sqlite3FindFunction(pParse.db, zId, (int)(n), (byte)(enc), (byte)(0));
						if ((pDef) == (null))
						{
							pDef = sqlite3FindFunction(pParse.db, zId, (int)(-2), (byte)(enc), (byte)(0));
							if ((pDef) == (null))
							{
								no_such_func = (int)(1);
							}
							else
							{
								wrong_num_args = (int)(1);
							}
						}
						else
						{
							is_agg = (int)(pDef.xFinalize != null);
							if ((pDef.funcFlags & 0x0400) != 0)
							{
								(pExpr).flags |= (uint)(0x040000);
								if ((n) == (2))
								{
									pExpr.iTable = (int)(exprProbability(pList.a[1].pExpr));
									if ((pExpr.iTable) < (0))
									{
										sqlite3ErrorMsg(pParse, "second argument to %#T() must be a constant between 0.0 and 1.0", pExpr);
										pNC.nNcErr++;
									}
								}
								else
								{
									pExpr.iTable = (int)((pDef.zName[0]) == (117) ? 8388608 : 125829120);
								}
							}

							{
								int auth = (int)(sqlite3AuthCheck(pParse, (int)(31), null, pDef.zName, null));
								if (auth != 0)
								{
									if ((auth) == (1))
									{
										sqlite3ErrorMsg(pParse, "not authorized to use function: %#T", pExpr);
										pNC.nNcErr++;
									}

									pExpr.op = (byte)(121);
									return (int)(1);
								}
							}

							if ((pDef.funcFlags & (0x0800 | 0x2000)) != 0)
							{
								(pExpr).flags |= (uint)(0x080000);
							}

							if ((pDef.funcFlags & 0x0800) == (0))
							{
								if (((pNC).ncFlags & (0x000020 | 0x000002 | 0x000008)) != 0)
									notValidImpl(pParse, pNC, "non-deterministic functions", null, pExpr);
							}
							else
							{
								pExpr.op2 = (byte)(pNC.ncFlags & 0x00002e);
								if ((pNC.ncFlags & 0x040000) != 0)
									(pExpr).flags |= (uint)(0x40000000);
							}

							if ((((pDef.funcFlags & 0x00040000) != 0) && ((pParse.nested) == (0))) && ((pParse.db.mDbFlags & 0x0020) == (0)))
							{
								no_such_func = (int)(1);
								pDef = null;
							}
							else if (((pDef.funcFlags & (0x00080000 | 0x00200000)) != 0) && (!((pParse.eParseMode) >= (2))))
							{
								sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
							}
						}

						if ((0) == ((pParse.eParseMode) >= (2)))
						{
							if ((((pDef) != null) && ((pDef.xValue) == (null))) && ((pWin) != null))
							{
								sqlite3ErrorMsg(pParse, "%#T() may not be used as a window function", pExpr);
								pNC.nNcErr++;
							}
							else if (((((is_agg) != 0) && ((pNC.ncFlags & 0x000001) == (0))) || ((((is_agg) != 0) && ((pDef.funcFlags & 0x00010000) != 0)) && (pWin == null))) || ((((is_agg) != 0) && ((pWin) != null)) && ((pNC.ncFlags & 0x004000) == (0))))
							{
								sbyte* zType;
								if (((pDef.funcFlags & 0x00010000) != 0) || ((pWin) != null))
								{
									zType = "window";
								}
								else
								{
									zType = "aggregate";
								}

								sqlite3ErrorMsg(pParse, "misuse of %s function %#T()", zType, pExpr);
								pNC.nNcErr++;
								is_agg = (int)(0);
							}
							else if (((no_such_func) != 0) && ((pParse.db.init.busy) == (0)))
							{
								sqlite3ErrorMsg(pParse, "no such function: %#T", pExpr);
								pNC.nNcErr++;
							}
							else if ((wrong_num_args) != 0)
							{
								sqlite3ErrorMsg(pParse, "wrong number of arguments to function %#T()", pExpr);
								pNC.nNcErr++;
							}
							else if (((is_agg) == (0)) && (((pExpr).flags & (0x1000000)) != 0))
							{
								sqlite3ErrorMsg(pParse, "FILTER may not be used with non-aggregate %#T()", pExpr);
								pNC.nNcErr++;
							}

							if ((is_agg) != 0)
							{
								pNC.ncFlags &= (int)(~(0x004000 | ((!pWin) != 0 ? 0x000001 : 0)));
							}
						}
						else if ((((pExpr).flags & (0x1000000)) != 0))
						{
							is_agg = (int)(1);
						}

						sqlite3WalkExprList(pWalker, pList);
						if ((is_agg) != 0)
						{
							if ((pWin) != null)
							{
								Select pSel = pNC.pWinSelect;
								if (((pParse.eParseMode) >= (2)) == (0))
								{
									sqlite3WindowUpdate(pParse, pSel ? pSel.pWinDefn : null, pWin, pDef);
									if ((pParse.db.mallocFailed) != 0)
										break;
								}

								sqlite3WalkExprList(pWalker, pWin.pPartition);
								sqlite3WalkExprList(pWalker, pWin.pOrderBy);
								sqlite3WalkExpr(pWalker, pWin.pFilter);
								sqlite3WindowLink(pSel, pWin);
								pNC.ncFlags |= (int)(0x008000);
							}
							else
							{
								NameContext pNC2;
								pExpr.op = (byte)(168);
								pExpr.op2 = (byte)(0);
								if ((((pExpr).flags & (0x1000000)) != 0))
								{
									sqlite3WalkExpr(pWalker, pExpr.y.pWin.pFilter);
								}

								pNC2 = pNC;
								while (((pNC2) != null) && ((sqlite3ReferencesSrcList(pParse, pExpr, pNC2.pSrcList)) == (0)))
								{
									pExpr.op2++;
									pNC2 = pNC2.pNext;
								}

								if (((pNC2) != null) && ((pDef) != null))
								{
									pNC2.ncFlags |= (int)(0x000010 | ((pDef.funcFlags ^ 0x08000000) & (0x1000 | 0x08000000)));
								}
							}

							pNC.ncFlags |= (int)(savedAllowFlags);
						}

						return (int)(1);
					}

				case 138:
				case 20:
					;
				case 49:
					{
						if ((((pExpr).flags & 0x000800) != 0))
						{
							int nRef = (int)(pNC.nRef);
							if ((pNC.ncFlags & 0x00002e) != 0)
							{
								notValidImpl(pParse, pNC, "subqueries", pExpr, pExpr);
							}
							else
							{
								sqlite3WalkSelect(pWalker, pExpr.x.pSelect);
							}

							if (nRef != pNC.nRef)
							{
								(pExpr).flags |= (uint)(0x000020);
								pNC.ncFlags |= (int)(0x000040);
							}
						}

						break;
					}

				case 156:
					{
						if (((pNC).ncFlags & (0x000004 | 0x000002 | 0x000020 | 0x000008)) != 0)
							notValidImpl(pParse, pNC, "parameters", pExpr, pExpr);
						break;
					}

				case 45:
				case 171:
					{
						Expr pRight = sqlite3ExprSkipCollateAndLikely(pExpr.pRight);
						if (((pRight) != null) && (((pRight.op) == (59)) || ((pRight.op) == (170))))
						{
							int rc = (int)(resolveExprStep(pWalker, pRight));
							if ((rc) == (2))
								return (int)(2);
							if ((pRight.op) == (170))
							{
								pExpr.op2 = (byte)(pExpr.op);
								pExpr.op = (byte)(175);
								return (int)(0);
							}
						}
					}

				case 48:
				case 53:
				case 52:
				case 56:
				case 55:
				case 54:
				case 57:
					{
						int nLeft = 0;
						int nRight = 0;
						if ((pParse.db.mallocFailed) != 0)
							break;
						nLeft = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
						if ((pExpr.op) == (48))
						{
							nRight = (int)(sqlite3ExprVectorSize(pExpr.x.pList.a[0].pExpr));
							if ((nRight) == (nLeft))
							{
								nRight = (int)(sqlite3ExprVectorSize(pExpr.x.pList.a[1].pExpr));
							}
						}
						else
						{
							nRight = (int)(sqlite3ExprVectorSize(pExpr.pRight));
						}

						if (nLeft != nRight)
						{
							sqlite3ErrorMsg(pParse, "row value misused");
							sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
						}

						break;
					}
			}

			return (int)((pParse.nErr) != 0 ? 2 : 0);
		}
		public static int resolveRemoveWindowsCb(Walker pWalker, Expr pExpr)
		{
			if ((((pExpr).flags & (0x1000000)) != 0))
			{
				Window pWin = pExpr.y.pWin;
				sqlite3WindowUnlinkFromSelect(pWin);
			}

			return (int)(0);
		}
		public static int resolveSelectStep(Walker pWalker, Select p)
		{
			NameContext pOuterNC;
			NameContext sNC = new NameContext();
			int isCompound = 0;
			int nCompound = 0;
			Parse pParse;
			int i = 0;
			ExprList pGroupBy;
			Select pLeftmost;
			sqlite3 db;
			if ((p.selFlags & 0x0000004) != 0)
			{
				return (int)(1);
			}

			pOuterNC = pWalker.u.pNC;
			pParse = pWalker.pParse;
			db = pParse.db;
			if ((p.selFlags & 0x0000040) == (0))
			{
				sqlite3SelectPrep(pParse, p, pOuterNC);
				return (int)((pParse.nErr) != 0 ? 2 : 1);
			}

			isCompound = (int)(p.pPrior != null);
			nCompound = (int)(0);
			pLeftmost = p;
			while ((p) != null)
			{
				p.selFlags |= (uint)(0x0000004);
				CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
				sNC.pParse = pParse;
				sNC.pWinSelect = p;
				if ((sqlite3ResolveExprNames(sNC, p.pLimit)) != 0)
				{
					return (int)(2);
				}

				if ((p.selFlags & 0x0010000) != 0)
				{
					Select pSub = p.pSrc.a[0].pSelect;
					pSub.pOrderBy = p.pOrderBy;
					p.pOrderBy = null;
				}

				for (i = (int)(0); (i) < (p.pSrc.nSrc); i++)
				{
					SrcItem pItem = p.pSrc.a[i];
					if (((pItem.pSelect) != null) && ((pItem.pSelect.selFlags & 0x0000004) == (0)))
					{
						int nRef = (int)(pOuterNC ? pOuterNC.nRef : 0);
						sbyte* zSavedContext = pParse.zAuthContext;
						if ((pItem.zName) != null)
							pParse.zAuthContext = pItem.zName;
						sqlite3ResolveSelectNames(pParse, pItem.pSelect, pOuterNC);
						pParse.zAuthContext = zSavedContext;
						if ((pParse.nErr) != 0)
							return (int)(2);
						if ((pOuterNC) != null)
						{
							pItem.fg.isCorrelated = (uint)((pOuterNC.nRef) > (nRef));
						}
					}
				}

				sNC.ncFlags = (int)(0x000001 | 0x004000);
				sNC.pSrcList = p.pSrc;
				sNC.pNext = pOuterNC;
				if ((sqlite3ResolveExprListNames(sNC, p.pEList)) != 0)
					return (int)(2);
				sNC.ncFlags &= (int)(~0x004000);
				pGroupBy = p.pGroupBy;
				if (((pGroupBy) != null) || ((sNC.ncFlags & 0x000010) != 0))
				{
					p.selFlags |= (uint)(0x0000008 | (sNC.ncFlags & (0x001000 | 0x8000000)));
				}
				else
				{
					sNC.ncFlags &= (int)(~0x000001);
				}

				sNC.uNC.pEList = p.pEList;
				sNC.ncFlags |= (int)(0x000080);
				if ((p.pHaving) != null)
				{
					if (pGroupBy == null)
					{
						sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
						return (int)(2);
					}

					if ((sqlite3ResolveExprNames(sNC, p.pHaving)) != 0)
						return (int)(2);
				}

				if ((sqlite3ResolveExprNames(sNC, p.pWhere)) != 0)
					return (int)(2);
				for (i = (int)(0); (i) < (p.pSrc.nSrc); i++)
				{
					SrcItem pItem = p.pSrc.a[i];
					if (((pItem.fg.isTabFunc) != 0) && ((sqlite3ResolveExprListNames(sNC, pItem.u1.pFuncArg)) != 0))
					{
						return (int)(2);
					}
				}

				if (((pParse.eParseMode) >= (2)))
				{
					Window pWin;
					for (pWin = p.pWinDefn; pWin; pWin = pWin.pNextWin)
					{
						if (((sqlite3ResolveExprListNames(sNC, pWin.pOrderBy)) != 0) || ((sqlite3ResolveExprListNames(sNC, pWin.pPartition)) != 0))
						{
							return (int)(2);
						}
					}
				}

				sNC.pNext = null;
				sNC.ncFlags |= (int)(0x000001 | 0x004000);
				if ((p.selFlags & 0x0010000) != 0)
				{
					Select pSub = p.pSrc.a[0].pSelect;
					p.pOrderBy = pSub.pOrderBy;
					pSub.pOrderBy = null;
				}

				if (((p.pOrderBy != null) && ((isCompound) <= (nCompound))) && ((resolveOrderGroupBy(sNC, p, p.pOrderBy, "ORDER")) != 0))
				{
					return (int)(2);
				}

				if ((db.mallocFailed) != 0)
				{
					return (int)(2);
				}

				sNC.ncFlags &= (int)(~0x004000);
				if ((pGroupBy) != null)
				{
					ExprList_item* pItem;
					if (((resolveOrderGroupBy(sNC, p, pGroupBy, "GROUP")) != 0) || ((db.mallocFailed) != 0))
					{
						return (int)(2);
					}

					for (i = (int)(0), pItem = pGroupBy.a; (i) < (pGroupBy.nExpr); i++, pItem++)
					{
						if ((((pItem->pExpr).flags & (0x000010)) != 0))
						{
							sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in the GROUP BY clause");
							return (int)(2);
						}
					}
				}

				if (((p.pNext) != null) && (p.pEList.nExpr != p.pNext.pEList.nExpr))
				{
					sqlite3SelectWrongNumTermsError(pParse, p.pNext);
					return (int)(2);
				}

				p = p.pPrior;
				nCompound++;
			}

			if (((isCompound) != 0) && ((resolveCompoundOrderBy(pParse, pLeftmost)) != 0))
			{
				return (int)(2);
			}

			return (int)(1);
		}
		public static void selectAddSubqueryTypeInfo(Walker pWalker, Select p)
		{
			Parse pParse;
			int i = 0;
			SrcList pTabList;
			SrcItem pFrom;
			if ((p.selFlags & 0x0000080) != 0)
				return;
			p.selFlags |= (uint)(0x0000080);
			pParse = pWalker.pParse;
			pTabList = p.pSrc;
			for (i = (int)(0), pFrom = pTabList.a; (i) < (pTabList.nSrc); i++, pFrom++)
			{
				Table pTab = pFrom.pTab;
				if ((pTab.tabFlags & 0x00004000) != 0)
				{
					Select pSel = pFrom.pSelect;
					if ((pSel) != null)
					{
						while ((pSel.pPrior) != null)
						{
							pSel = pSel.pPrior;
						}

						sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel, (sbyte)(0x40));
					}
				}
			}
		}
		public static int selectExpander(Walker pWalker, Select p)
		{
			Parse pParse = pWalker.pParse;
			int i = 0; int j = 0; int k = 0; int rc = 0;
			SrcList pTabList;
			ExprList pEList;
			SrcItem pFrom;
			sqlite3 db = pParse.db;
			Expr pE; Expr pRight; Expr pExpr;
			ushort selFlags = (ushort)(p.selFlags);
			uint elistFlags = (uint)(0);
			p.selFlags |= (uint)(0x0000040);
			if ((db.mallocFailed) != 0)
			{
				return (int)(2);
			}

			if ((selFlags & 0x0000040) != 0)
			{
				return (int)(1);
			}

			if ((pWalker.eCode) != 0)
			{
				p.selId = (uint)(++pParse.nSelect);
			}

			pTabList = p.pSrc;
			pEList = p.pEList;
			if (((pParse.pWith) != null) && ((p.selFlags & 0x0200000) != 0))
			{
				if ((p.pWith) == (null))
				{
					p.pWith = (With)(sqlite3DbMallocZero(db, (ulong)(sizeof(With))));
					if ((p.pWith) == (null))
					{
						return (int)(2);
					}
				}

				p.pWith.bView = (int)(1);
			}

			sqlite3WithPush(pParse, p.pWith, (byte)(0));
			sqlite3SrcListAssignCursors(pParse, pTabList);
			for (i = (int)(0), pFrom = pTabList.a; (i) < (pTabList.nSrc); i++, pFrom++)
			{
				Table pTab;
				if ((pFrom.pTab) != null)
					continue;
				if ((pFrom.zName) == (null))
				{
					Select pSel = pFrom.pSelect;
					if ((sqlite3WalkSelect(pWalker, pSel)) != 0)
						return (int)(2);
					if ((sqlite3ExpandSubquery(pParse, pFrom)) != 0)
						return (int)(2);
				}
				else if ((rc = (int)(resolveFromTermToCte(pParse, pWalker, pFrom))) != 0)
				{
					if ((rc) > (1))
						return (int)(2);
					pTab = pFrom.pTab;
				}
				else
				{
					pFrom.pTab = pTab = sqlite3LocateTableItem(pParse, (uint)(0), pFrom);
					if ((pTab) == (null))
						return (int)(2);
					if ((pTab.nTabRef) >= (0xffff))
					{
						sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535", pTab.zName);
						pFrom.pTab = null;
						return (int)(2);
					}

					pTab.nTabRef++;
					if ((!(((pTab).eTabType) == (1))) && ((cannotBeFunction(pParse, pFrom)) != 0))
					{
						return (int)(2);
					}

					if (!(((pTab).eTabType) == (0)))
					{
						short nCol = 0;
						byte eCodeOrig = (byte)(pWalker.eCode);
						if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
							return (int)(2);
						if ((((pTab).eTabType) == (2)))
						{
							if (((db.flags & 0x80000000) == (0)) && (pTab.pSchema != db.aDb[1].pSchema))
							{
								sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited", pTab.zName);
							}

							pFrom.pSelect = sqlite3SelectDup(db, pTab.u.view.pSelect, (int)(0));
						}
						else if (((((((pTab).eTabType) == (1)) != 0) && ((pFrom.fg.fromDDL) != 0)) && (pTab.u.vtab.p != null)) && ((pTab.u.vtab.p.eVtabRisk) > ((db.flags & 0x00000080) != 0)))
						{
							sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"", pTab.zName);
						}

						nCol = (short)(pTab.nCol);
						pTab.nCol = (short)(-1);
						pWalker.eCode = (ushort)(1);
						sqlite3WalkSelect(pWalker, pFrom.pSelect);
						pWalker.eCode = (ushort)(eCodeOrig);
						pTab.nCol = (short)(nCol);
					}
				}

				if (((pFrom.fg.isIndexedBy) != 0) && ((sqlite3IndexedByLookup(pParse, pFrom)) != 0))
				{
					return (int)(2);
				}
			}

			if (((pParse.nErr) != 0) || ((sqliteProcessJoin(pParse, p)) != 0))
			{
				return (int)(2);
			}

			for (k = (int)(0); (k) < (pEList.nExpr); k++)
			{
				pE = pEList.a[k].pExpr;
				if ((pE.op) == (180))
					break;
				if (((pE.op) == (141)) && ((pE.pRight.op) == (180)))
					break;
				elistFlags |= (uint)(pE.flags);
			}

			if ((k) < (pEList.nExpr))
			{
				ExprList_item* a = pEList.a;
				ExprList pNew = null;
				int flags = (int)(pParse.db.flags);
				int longNames = (int)(((flags & 0x00000004) != 0) && ((flags & 0x00000040) == (0)) ? 1 : 0);
				for (k = (int)(0); (k) < (pEList.nExpr); k++)
				{
					pE = a[k].pExpr;
					elistFlags |= (uint)(pE.flags);
					pRight = pE.pRight;
					if ((pE.op != 180) && ((pE.op != 141) || (pRight.op != 180)))
					{
						pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
						if ((pNew) != null)
						{
							pNew.a[pNew.nExpr - 1].zEName = a[k].zEName;
							pNew.a[pNew.nExpr - 1].eEName = (uint)(a[k].eEName);
							a[k].zEName = null;
						}

						a[k].pExpr = null;
					}
					else
					{
						int tableSeen = (int)(0);
						sbyte* zTName = null;
						if ((pE.op) == (141))
						{
							zTName = pE.pLeft.u.zToken;
						}

						for (i = (int)(0), pFrom = pTabList.a; (i) < (pTabList.nSrc); i++, pFrom++)
						{
							Table pTab = pFrom.pTab;
							Select pSub = pFrom.pSelect;
							sbyte* zTabName = pFrom.zAlias;
							sbyte* zSchemaName = null;
							int iDb = 0;
							if ((zTabName) == (null))
							{
								zTabName = pTab.zName;
							}

							if ((db.mallocFailed) != 0)
								break;
							if (((pSub) == (null)) || ((pSub.selFlags & 0x0000800) == (0)))
							{
								pSub = null;
								if (((zTName) != null) && (sqlite3StrICmp(zTName, zTabName) != 0))
								{
									continue;
								}

								iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
								zSchemaName = (iDb) >= (0) ? db.aDb[iDb].zDbSName : "*";
							}

							for (j = (int)(0); (j) < (pTab.nCol); j++)
							{
								sbyte* zName = pTab.aCol[j].zCnName;
								sbyte* zColname;
								sbyte* zToFree;
								Token sColname = new Token();
								if ((((zTName) != null) && ((pSub) != null)) && ((sqlite3MatchEName(&pSub.pEList.a[j], null, zTName, null)) == (0)))
								{
									continue;
								}

								if (((p.selFlags & 0x0020000) == (0)) && (((&pTab.aCol[j])->colFlags & 0x0002) != 0))
								{
									continue;
								}

								tableSeen = (int)(1);
								if (((i) > (0)) && ((zTName) == (null)))
								{
									if (((pFrom.fg.jointype & 0x0004) != 0) && ((tableAndColumnIndex(pTabList, (int)(i), zName, null, null, (int)(1))) != 0))
									{
										continue;
									}

									if ((sqlite3IdListIndex(pFrom.pUsing, zName)) >= (0))
									{
										continue;
									}
								}

								pRight = sqlite3Expr(db, (int)(59), zName);
								zColname = zName;
								zToFree = null;
								if (((longNames) != 0) || ((pTabList.nSrc) > (1)))
								{
									Expr pLeft;
									pLeft = sqlite3Expr(db, (int)(59), zTabName);
									pExpr = sqlite3PExpr(pParse, (int)(141), pLeft, pRight);
									if ((zSchemaName) != null)
									{
										pLeft = sqlite3Expr(db, (int)(59), zSchemaName);
										pExpr = sqlite3PExpr(pParse, (int)(141), pLeft, pExpr);
									}

									if ((longNames) != 0)
									{
										zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
										zToFree = zColname;
									}
								}
								else
								{
									pExpr = pRight;
								}

								pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
								sqlite3TokenInit(&sColname, zColname);
								sqlite3ExprListSetName(pParse, pNew, &sColname, (int)(0));
								if ((((pNew) != null) && ((p.selFlags & 0x0000800) != 0)) && (!((pParse.eParseMode) >= (2))))
								{
									ExprList_item* pX = &pNew.a[pNew.nExpr - 1];
									sqlite3DbFree(db, pX->zEName);
									if ((pSub) != null)
									{
										pX->zEName = sqlite3DbStrDup(db, pSub.pEList.a[j].zEName);
									}
									else
									{
										pX->zEName = sqlite3MPrintf(db, "%s.%s.%s", zSchemaName, zTabName, zColname);
									}

									pX->eEName = (uint)(2);
								}

								sqlite3DbFree(db, zToFree);
							}
						}

						if (tableSeen == 0)
						{
							if ((zTName) != null)
							{
								sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
							}
							else
							{
								sqlite3ErrorMsg(pParse, "no tables specified");
							}
						}
					}
				}

				sqlite3ExprListDelete(db, pEList);
				p.pEList = pNew;
			}

			if ((p.pEList) != null)
			{
				if ((p.pEList.nExpr) > (db.aLimit[2]))
				{
					sqlite3ErrorMsg(pParse, "too many columns in result set");
					return (int)(2);
				}

				if ((elistFlags & (0x000004 | 0x200000)) != 0)
				{
					p.selFlags |= (uint)(0x0040000);
				}
			}

			return (int)(0);
		}
		public static int selectRefEnter(Walker pWalker, Select pSelect)
		{
			RefSrcList p = pWalker.u.pRefSrcList;
			SrcList pSrc = pSelect.pSrc;
			long i = 0; long j = 0;
			int* piNew;
			if ((pSrc.nSrc) == (0))
				return (int)(0);
			j = (long)(p.nExclude);
			p.nExclude += (long)(pSrc.nSrc);
			piNew = sqlite3DbRealloc(p.db, p.aiExclude, (ulong)(p.nExclude * sizeof(int)));
			if ((piNew) == (null))
			{
				p.nExclude = (long)(0);
				return (int)(2);
			}
			else
			{
				p.aiExclude = piNew;
			}

			for (i = (long)(0); (i) < (pSrc.nSrc); i++, j++)
			{
				p.aiExclude[j] = (int)(pSrc.a[i].iCursor);
			}

			return (int)(0);
		}
		public static void selectRefLeave(Walker pWalker, Select pSelect)
		{
			RefSrcList p = pWalker.u.pRefSrcList;
			SrcList pSrc = pSelect.pSrc;
			if ((p.nExclude) != 0)
			{
				p.nExclude -= (long)(pSrc.nSrc);
			}
		}
		public static int selectWindowRewriteExprCb(Walker pWalker, Expr pExpr)
		{
			WindowRewrite p = pWalker.u.pRewrite;
			Parse pParse = pWalker.pParse;
			if ((p.pSubSelect) != null)
			{
				if (pExpr.op != 167)
				{
					return (int)(0);
				}
				else
				{
					int nSrc = (int)(p.pSrc.nSrc);
					int i = 0;
					for (i = (int)(0); (i) < (nSrc); i++)
					{
						if ((pExpr.iTable) == (p.pSrc.a[i].iCursor))
							break;
					}

					if ((i) == (nSrc))
						return (int)(0);
				}
			}

			switch (pExpr.op)
			{
				case 172:
					if (!(((pExpr).flags & (0x1000000)) != 0))
					{
						break;
					}
					else
					{
						Window pWin;
						for (pWin = p.pWin; pWin; pWin = pWin.pNextWin)
						{
							if ((pExpr.y.pWin) == (pWin))
							{
								return (int)(1);
							}
						}
					}

				case 168:
				case 167:
					{
						int iCol = (int)(-1);
						if ((pParse.db.mallocFailed) != 0)
							return (int)(2);
						if ((p.pSub) != null)
						{
							int i = 0;
							for (i = (int)(0); (i) < (p.pSub.nExpr); i++)
							{
								if ((0) == (sqlite3ExprCompare(null, p.pSub.a[i].pExpr, pExpr, (int)(-1))))
								{
									iCol = (int)(i);
									break;
								}
							}
						}

						if ((iCol) < (0))
						{
							Expr pDup = sqlite3ExprDup(pParse.db, pExpr, (int)(0));
							if (((pDup) != null) && ((pDup.op) == (168)))
								pDup.op = (byte)(172);
							p.pSub = sqlite3ExprListAppend(pParse, p.pSub, pDup);
						}

						if ((p.pSub) != null)
						{
							int f = (int)(pExpr.flags & 0x000100);
							(pExpr).flags |= (uint)(0x8000000);
							sqlite3ExprDelete(pParse.db, pExpr);
							(pExpr).flags &= (uint)(~(0x8000000));
							CRuntime.memset(pExpr, (int)(0), (ulong)(sizeof(Expr)));
							pExpr.op = (byte)(167);
							pExpr.iColumn = (short)((iCol) < (0) ? p.pSub.nExpr - 1 : iCol);
							pExpr.iTable = (int)(p.pWin.iEphCsr);
							pExpr.y.pTab = p.pTab;
							pExpr.flags = (uint)(f);
						}

						if ((pParse.db.mallocFailed) != 0)
							return (int)(2);
						break;
					}

				default:
					break;
			}

			return (int)(0);
		}
		public static int selectWindowRewriteSelectCb(Walker pWalker, Select pSelect)
		{
			WindowRewrite p = pWalker.u.pRewrite;
			Select pSave = p.pSubSelect;
			if ((pSave) == (pSelect))
			{
				return (int)(0);
			}
			else
			{
				p.pSubSelect = pSelect;
				sqlite3WalkSelect(pWalker, pSelect);
				p.pSubSelect = pSave;
			}

			return (int)(1);
		}
		public static void sqlite3AggInfoPersistWalkerInit(Walker pWalker, Parse pParse)
		{
			CRuntime.memset(pWalker, (int)(0), (ulong)(sizeof(Walker)));
			pWalker.pParse = pParse;
			pWalker.xExprCallback = agginfoPersistExprCb;
			pWalker.xSelectCallback = sqlite3SelectWalkNoop;
		}
		public static int sqlite3ExprWalkNoop(Walker NotUsed, Expr NotUsed2)
		{
			return (int)(0);
		}
		public static void sqlite3SelectPopWith(Walker pWalker, Select p)
		{
			Parse pParse = pWalker.pParse;
			if (((pParse.pWith) != null) && ((p.pPrior) == (null)))
			{
				With pWith = findRightmost(p).pWith;
				if (pWith != null)
				{
					pParse.pWith = pWith.pOuter;
				}
			}
		}
		public static int sqlite3SelectWalkFail(Walker pWalker, Select NotUsed)
		{
			pWalker.eCode = (ushort)(0);
			return (int)(2);
		}
		public static int sqlite3SelectWalkNoop(Walker NotUsed, Select NotUsed2)
		{
			return (int)(0);
		}
		public static void sqlite3WalkerDepthDecrease(Walker pWalker, Select pSelect)
		{
			pWalker.walkerDepth--;
		}
		public static int sqlite3WalkerDepthIncrease(Walker pWalker, Select pSelect)
		{
			pWalker.walkerDepth++;
			return (int)(0);
		}
		public static int sqlite3WalkExpr(Walker pWalker, Expr pExpr)
		{
			return (int)(pExpr ? walkExpr(pWalker, pExpr) : 0);
		}
		public static int sqlite3WalkExprList(Walker pWalker, ExprList p)
		{
			int i = 0;
			ExprList_item* pItem;
			if ((p) != null)
			{
				for (i = (int)(p.nExpr), pItem = p.a; (i) > (0); i--, pItem++)
				{
					if ((sqlite3WalkExpr(pWalker, pItem->pExpr)) != 0)
						return (int)(2);
				}
			}

			return (int)(0);
		}
		public static int sqlite3WalkSelect(Walker pWalker, Select p)
		{
			int rc = 0;
			if ((p) == (null))
				return (int)(0);
			if ((pWalker.xSelectCallback) == (null))
				return (int)(0);
			do
			{
				rc = (int)(pWalker.xSelectCallback(pWalker, p));
				if ((rc) != 0)
					return (int)(rc & 2);
				if (((sqlite3WalkSelectExpr(pWalker, p)) != 0) || ((sqlite3WalkSelectFrom(pWalker, p)) != 0))
				{
					return (int)(2);
				}

				if ((pWalker.xSelectCallback2) != null)
				{
					pWalker.xSelectCallback2(pWalker, p);
				}

				p = p.pPrior;
			}
			while (p != null);
			return (int)(0);
		}
		public static int sqlite3WalkSelectExpr(Walker pWalker, Select p)
		{
			if ((sqlite3WalkExprList(pWalker, p.pEList)) != 0)
				return (int)(2);
			if ((sqlite3WalkExpr(pWalker, p.pWhere)) != 0)
				return (int)(2);
			if ((sqlite3WalkExprList(pWalker, p.pGroupBy)) != 0)
				return (int)(2);
			if ((sqlite3WalkExpr(pWalker, p.pHaving)) != 0)
				return (int)(2);
			if ((sqlite3WalkExprList(pWalker, p.pOrderBy)) != 0)
				return (int)(2);
			if ((sqlite3WalkExpr(pWalker, p.pLimit)) != 0)
				return (int)(2);
			if ((p.pWinDefn) != null)
			{
				Parse pParse;
				if ((((pWalker.xSelectCallback2) == (sqlite3WalkWinDefnDummyCallback)) || (((pParse = pWalker.pParse) != null) && ((pParse.eParseMode) >= (2)))) || ((pWalker.xSelectCallback2) == (sqlite3SelectPopWith)))
				{
					int rc = (int)(walkWindowList(pWalker, p.pWinDefn, (int)(0)));
					return (int)(rc);
				}
			}

			return (int)(0);
		}
		public static int sqlite3WalkSelectFrom(Walker pWalker, Select p)
		{
			SrcList pSrc;
			int i = 0;
			SrcItem pItem;
			pSrc = p.pSrc;
			if ((pSrc) != null)
			{
				for (i = (int)(pSrc.nSrc), pItem = pSrc.a; (i) > (0); i--, pItem++)
				{
					if (((pItem.pSelect) != null) && ((sqlite3WalkSelect(pWalker, pItem.pSelect)) != 0))
					{
						return (int)(2);
					}

					if (((pItem.fg.isTabFunc) != 0) && ((sqlite3WalkExprList(pWalker, pItem.u1.pFuncArg)) != 0))
					{
						return (int)(2);
					}
				}
			}

			return (int)(0);
		}
		public static void sqlite3WalkWinDefnDummyCallback(Walker pWalker, Select p)
		{
		}
		public static int sqlite3WindowExtraAggFuncDepth(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (168)) && ((pExpr.op2) >= (pWalker.walkerDepth)))
			{
				pExpr.op2++;
			}

			return (int)(0);
		}
		public static int walkExpr(Walker pWalker, Expr pExpr)
		{
			int rc = 0;
			while ((1) != 0)
			{
				rc = (int)(pWalker.xExprCallback(pWalker, pExpr));
				if ((rc) != 0)
					return (int)(rc & 2);
				if (!(((pExpr).flags & (0x004000 | 0x800000)) != 0))
				{
					if (((pExpr.pLeft) != null) && ((walkExpr(pWalker, pExpr.pLeft)) != 0))
						return (int)(2);
					if ((pExpr.pRight) != null)
					{
						pExpr = pExpr.pRight;
						continue;
					}
					else if ((((pExpr).flags & 0x000800) != 0))
					{
						if ((sqlite3WalkSelect(pWalker, pExpr.x.pSelect)) != 0)
							return (int)(2);
					}
					else
					{
						if ((pExpr.x.pList) != null)
						{
							if ((sqlite3WalkExprList(pWalker, pExpr.x.pList)) != 0)
								return (int)(2);
						}

						if ((((pExpr).flags & (0x1000000)) != 0))
						{
							if ((walkWindowList(pWalker, pExpr.y.pWin, (int)(1))) != 0)
								return (int)(2);
						}
					}
				}

				break;
			}

			return (int)(0);
		}
		public static int walkWindowList(Walker pWalker, Window pList, int bOneOnly)
		{
			Window pWin;
			for (pWin = pList; pWin; pWin = pWin.pNextWin)
			{
				int rc = 0;
				rc = (int)(sqlite3WalkExprList(pWalker, pWin.pOrderBy));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExprList(pWalker, pWin.pPartition));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExpr(pWalker, pWin.pFilter));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExpr(pWalker, pWin.pStart));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExpr(pWalker, pWin.pEnd));
				if ((rc) != 0)
					return (int)(2);
				if ((bOneOnly) != 0)
					break;
			}

			return (int)(0);
		}
		public static int whereIndexExprTransColumn(Walker p, Expr pExpr)
		{
			if ((pExpr.op) == (167))
			{
				IdxExprTrans pX = p.u.pIdxTrans;
				if (((pExpr.iTable) == (pX.iTabCur)) && ((pExpr.iColumn) == (pX.iTabCol)))
				{
					preserveExpr(pX, pExpr);
					pExpr.affExpr = (sbyte)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
					pExpr.iTable = (int)(pX.iIdxCur);
					pExpr.iColumn = (short)(pX.iIdxCol);
					pExpr.y.pTab = null;
				}
			}

			return (int)(0);
		}
		public static int whereIndexExprTransNode(Walker p, Expr pExpr)
		{
			IdxExprTrans pX = p.u.pIdxTrans;
			if ((sqlite3ExprCompare(null, pExpr, pX.pIdxExpr, (int)(pX.iTabCur))) == (0))
			{
				preserveExpr(pX, pExpr);
				pExpr.affExpr = (sbyte)(sqlite3ExprAffinity(pExpr));
				pExpr.op = (byte)(167);
				pExpr.iTable = (int)(pX.iIdxCur);
				pExpr.iColumn = (short)(pX.iIdxCol);
				(pExpr).flags &= (uint)(~(0x001000 | 0x040000 | 0x1000000 | 0x2000000));
				pExpr.y.pTab = null;
				return (int)(1);
			}
			else
			{
				return (int)(0);
			}
		}
	}
}