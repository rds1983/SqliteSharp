// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void pcache1EnforceMaxPage(PCache1* pCache)
		{
			PGroup* pGroup = pCache->pGroup;
			PgHdr1* p;
			while (((pGroup->nPurgeable) > (pGroup->nMaxPage)) && (((p = pGroup->lru.pLruPrev)->isAnchor) == (0)))
			{
				pcache1PinPage(p);
				pcache1RemoveFromHash(p, (int)(1));
			}

			if (((pCache->nPage) == (0)) && ((pCache->pBulk) != null))
			{
				sqlite3_free(pCache->pBulk);
				pCache->pBulk = pCache->pFree = null;
			}
		}
		public static int pcache1InitBulk(PCache1* pCache)
		{
			long szBulk = 0;
			sbyte* zBulk;
			if (((pcache1_g).nInitPage) == (0))
				return (int)(0);
			if ((pCache->nMax) < (3))
				return (int)(0);
			sqlite3BeginBenignMalloc();
			if (((pcache1_g).nInitPage) > (0))
			{
				szBulk = (long)(pCache->szAlloc * (long)((pcache1_g).nInitPage));
			}
			else
			{
				szBulk = (long)(-1024 * (long)((pcache1_g).nInitPage));
			}

			if ((szBulk) > (pCache->szAlloc * (long)(pCache->nMax)))
			{
				szBulk = (long)(pCache->szAlloc * (long)(pCache->nMax));
			}

			zBulk = pCache->pBulk = sqlite3Malloc((ulong)(szBulk));
			sqlite3EndBenignMalloc();
			if ((zBulk) != null)
			{
				int nBulk = (int)(sqlite3MallocSize(zBulk) / pCache->szAlloc);
				do
				{
					PgHdr1* pX = (PgHdr1*)(&zBulk[pCache->szPage]);
					pX->page.pBuf = zBulk;
					pX->page.pExtra = &pX[1];
					pX->isBulkLocal = (ushort)(1);
					pX->isAnchor = (ushort)(0);
					pX->pNext = pCache->pFree;
					pX->pLruPrev = null;
					pCache->pFree = pX;
					zBulk += pCache->szAlloc;
				}
				while ((--nBulk) != 0);
			}

			return (int)(pCache->pFree != null);
		}
		public static void pcache1ResizeHash(PCache1* p)
		{
			PgHdr1** apNew;
			uint nNew = 0;
			uint i = 0;
			nNew = (uint)(p->nHash * 2);
			if ((nNew) < (256))
			{
				nNew = (uint)(256);
			}

			if ((p->nHash) != 0)
			{
				sqlite3BeginBenignMalloc();
			}

			apNew = (PgHdr1**)(sqlite3MallocZero((ulong)(sizeof(PgHdr1) * nNew)));
			if ((p->nHash) != 0)
			{
				sqlite3EndBenignMalloc();
			}

			if ((apNew) != null)
			{
				for (i = (uint)(0); (i) < (p->nHash); i++)
				{
					PgHdr1* pPage;
					PgHdr1* pNext = p->apHash[i];
					while ((pPage = pNext) != null)
					{
						uint h = (uint)(pPage->iKey % nNew);
						pNext = pPage->pNext;
						pPage->pNext = apNew[h];
						apNew[h] = pPage;
					}
				}

				sqlite3_free(p->apHash);
				p->apHash = apNew;
				p->nHash = (uint)(nNew);
			}
		}
		public static void pcache1TruncateUnsafe(PCache1* pCache, uint iLimit)
		{
			uint h = 0; uint iStop = 0;
			if ((pCache->iMaxKey - iLimit) < (pCache->nHash))
			{
				h = (uint)(iLimit % pCache->nHash);
				iStop = (uint)(pCache->iMaxKey % pCache->nHash);
			}
			else
			{
				h = (uint)(pCache->nHash / 2);
				iStop = (uint)(h - 1);
			}

			for (; ; )
			{
				PgHdr1** pp;
				PgHdr1* pPage;
				pp = &pCache->apHash[h];
				while ((pPage = *pp) != null)
				{
					if ((pPage->iKey) >= (iLimit))
					{
						pCache->nPage--;
						*pp = pPage->pNext;
						if (((pPage)->pLruNext != null))
							pcache1PinPage(pPage);
						pcache1FreePage(pPage);
					}
					else
					{
						pp = &pPage->pNext;
					}
				}

				if ((h) == (iStop))
					break;
				h = (uint)((h + 1) % pCache->nHash);
			}
		}
		public static int pcache1UnderMemoryPressure(PCache1* pCache)
		{
			if ((((pcache1_g).nSlot) != 0) && ((pCache->szPage + pCache->szExtra) <= ((pcache1_g).szSlot)))
			{
				return (int)((pcache1_g).bUnderPressure);
			}
			else
			{
				return (int)(sqlite3HeapNearlyFull());
			}
		}
	}
}