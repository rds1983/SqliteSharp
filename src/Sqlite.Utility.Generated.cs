// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static sbyte* actionName(byte action)
		{
			sbyte* zName;
			switch (action)
			{
				case 8:
					zName = "SET NULL";
					break;
				case 9:
					zName = "SET DEFAULT";
					break;
				case 10:
					zName = "CASCADE";
					break;
				case 7:
					zName = "RESTRICT";
					break;
				default:
					zName = "NO ACTION";
					break;
			}

			return zName;
		}
		public static sqlite3_index_info* allocateIndexInfo(WhereInfo pWInfo, WhereClause pWC, ulong mUnusable, SrcItem pSrc, ushort* pmNoOmit)
		{
			int i = 0; int j = 0;
			int nTerm = 0;
			Parse pParse = pWInfo.pParse;
			sqlite3_index_constraint* pIdxCons;
			sqlite3_index_orderby* pIdxOrderBy;
			sqlite3_index_constraint_usage* pUsage;
			HiddenIndexInfo pHidden;
			WhereTerm pTerm;
			int nOrderBy = 0;
			sqlite3_index_info* pIdxInfo;
			ushort mNoOmit = (ushort)(0);
			Table pTab;
			int eDistinct = (int)(0);
			ExprList pOrderBy = pWInfo.pOrderBy;
			pTab = pSrc.pTab;
			for (i = (int)(nTerm = (int)(0)), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				pTerm.wtFlags &= (ushort)(~0x0040);
				if (pTerm.leftCursor != pSrc.iCursor)
					continue;
				if ((pTerm.prereqRight & mUnusable) != 0)
					continue;
				if ((pTerm.eOperator & ~(0x0800)) == (0))
					continue;
				if ((pTerm.wtFlags & 0x0080) != 0)
					continue;
				if (((pSrc.fg.jointype & 0x0008) != 0) && (!(((pTerm.pExpr).flags & (0x000001)) != 0)))
				{
					continue;
				}

				nTerm++;
				pTerm.wtFlags |= (ushort)(0x0040);
			}

			nOrderBy = (int)(0);
			if ((pOrderBy) != null)
			{
				int n = (int)(pOrderBy.nExpr);
				for (i = (int)(0); (i) < (n); i++)
				{
					Expr pExpr = pOrderBy.a[i].pExpr;
					Expr pE2;
					if ((sqlite3ExprIsConstant(pExpr)) != 0)
					{
						continue;
					}

					if ((pOrderBy.a[i].sortFlags & 0x02) != 0)
						break;
					if (((pExpr.op) == (167)) && ((pExpr.iTable) == (pSrc.iCursor)))
					{
						continue;
					}

					if ((((pExpr.op) == (113)) && (((pE2 = pExpr.pLeft).op) == (167))) && ((pE2.iTable) == (pSrc.iCursor)))
					{
						sbyte* zColl;
						pExpr.iColumn = (short)(pE2.iColumn);
						if ((pE2.iColumn) < (0))
							continue;
						zColl = sqlite3ColumnColl(&pTab.aCol[pE2.iColumn]);
						if ((zColl) == (null))
							zColl = sqlite3StrBINARY;
						if ((sqlite3_stricmp(pExpr.u.zToken, zColl)) == (0))
							continue;
					}

					break;
				}

				if ((i) == (n))
				{
					nOrderBy = (int)(n);
					if ((pWInfo.wctrlFlags & (0x0040 | 0x0080)) != 0)
					{
						eDistinct = (int)(1 + ((pWInfo.wctrlFlags & 0x0080) != 0));
					}
				}
			}

			pIdxInfo = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(sqlite3_index_info) + (sizeof(sqlite3_index_constraint) + sizeof(sqlite3_index_constraint_usage)) * nTerm + sizeof(sqlite3_index_orderby) * nOrderBy + sizeof(HiddenIndexInfo) + sizeof(sqlite3_value) * nTerm));
			if ((pIdxInfo) == (null))
			{
				sqlite3ErrorMsg(pParse, "out of memory");
				return null;
			}

			pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			pIdxCons = (sqlite3_index_constraint*)(pHidden.aRhs[nTerm]);
			pIdxOrderBy = (sqlite3_index_orderby*)(&pIdxCons[nTerm]);
			pUsage = (sqlite3_index_constraint_usage*)(&pIdxOrderBy[nOrderBy]);
			pIdxInfo->aConstraint = pIdxCons;
			pIdxInfo->aOrderBy = pIdxOrderBy;
			pIdxInfo->aConstraintUsage = pUsage;
			pHidden.pWC = pWC;
			pHidden.pParse = pParse;
			pHidden.eDistinct = (int)(eDistinct);
			pHidden.mIn = (uint)(0);
			for (i = (int)(j = (int)(0)), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				ushort op = 0;
				if ((pTerm.wtFlags & 0x0040) == (0))
					continue;
				pIdxCons[j].iColumn = (int)(pTerm.u.x.leftColumn);
				pIdxCons[j].iTermOffset = (int)(i);
				op = (ushort)(pTerm.eOperator & 0x1fff);
				if ((op) == (0x0001))
				{
					if ((pTerm.wtFlags & 0x8000) == (0))
					{
						pHidden.mIn |= (uint)((j) <= (31) ? ((uint)(1)) << (j) : 0);
					}

					op = (ushort)(0x0002);
				}

				if ((op) == (0x0040))
				{
					pIdxCons[j].op = (byte)(pTerm.eMatchOp);
				}
				else if ((op & (0x0100 | 0x0080)) != 0)
				{
					if ((op) == (0x0100))
					{
						pIdxCons[j].op = (byte)(71);
					}
					else
					{
						pIdxCons[j].op = (byte)(72);
					}
				}
				else
				{
					pIdxCons[j].op = ((byte)(op));
					if (((op & ((0x0002 << (56 - 53)) | (0x0002 << (55 - 53)) | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) != 0) && ((sqlite3ExprIsVector(pTerm.pExpr.pRight)) != 0))
					{
						if ((j) < (16))
							mNoOmit |= (ushort)(1 << j);
						if ((op) == (0x0002 << (56 - 53)))
							pIdxCons[j].op = (byte)(0x0002 << (55 - 53));
						if ((op) == (0x0002 << (54 - 53)))
							pIdxCons[j].op = (byte)(0x0002 << (57 - 53));
					}
				}

				j++;
			}

			pIdxInfo->nConstraint = (int)(j);
			for (i = (int)(j = (int)(0)); (i) < (nOrderBy); i++)
			{
				Expr pExpr = pOrderBy.a[i].pExpr;
				if ((sqlite3ExprIsConstant(pExpr)) != 0)
					continue;
				pIdxOrderBy[j].iColumn = (int)(pExpr.iColumn);
				pIdxOrderBy[j].desc = (byte)(pOrderBy.a[i].sortFlags & 0x01);
				j++;
			}

			pIdxInfo->nOrderBy = (int)(j);
			*pmNoOmit = (ushort)(mNoOmit);
			return pIdxInfo;
		}
		public static void* allocSpace(ReusableSpace* p, void* pBuf, long nByte)
		{
			if ((pBuf) == (null))
			{
				nByte = (long)(((nByte) + 7) & ~7);
				if ((nByte) <= (p->nFree))
				{
					p->nFree -= (long)(nByte);
					pBuf = &p->pSpace[p->nFree];
				}
				else
				{
					p->nNeeded += (long)(nByte);
				}
			}

			return pBuf;
		}
		public static int allowedOp(int op)
		{
			return (((((op) == (49)) || (((op) >= (53)) && ((op) <= (57)))) || ((op) == (50))) || ((op) == (45)) ? 1 : 0);
		}
		public static int analysisLoader(void* pData, int argc, sbyte** argv, sbyte** NotUsed)
		{
			analysisInfo pInfo = (analysisInfo)(pData);
			Index pIndex;
			Table pTable;
			sbyte* z;
			if ((((argv) == (null)) || ((argv[0]) == (null))) || ((argv[2]) == (null)))
			{
				return (int)(0);
			}

			pTable = sqlite3FindTable(pInfo.db, argv[0], pInfo.zDatabase);
			if ((pTable) == (null))
			{
				return (int)(0);
			}

			if ((argv[1]) == (null))
			{
				pIndex = null;
			}
			else if ((sqlite3_stricmp(argv[0], argv[1])) == (0))
			{
				pIndex = sqlite3PrimaryKeyIndex(pTable);
			}
			else
			{
				pIndex = sqlite3FindIndex(pInfo.db, argv[1], pInfo.zDatabase);
			}

			z = argv[2];
			if ((pIndex) != null)
			{
				uint* aiRowEst = null;
				int nCol = (int)(pIndex.nKeyCol + 1);
				pIndex.bUnordered = (uint)(0);
				decodeIntArray(z, (int)(nCol), aiRowEst, pIndex.aiRowLogEst, pIndex);
				pIndex.hasStat1 = (uint)(1);
				if ((pIndex.pPartIdxWhere) == (null))
				{
					pTable.nRowLogEst = (short)(pIndex.aiRowLogEst[0]);
					pTable.tabFlags |= (uint)(0x00000010);
				}
			}
			else
			{
				Index fakeIdx = new Index();
				fakeIdx.szIdxRow = (short)(pTable.szTabRow);
				decodeIntArray(z, (int)(1), null, &pTable.nRowLogEst, fakeIdx);
				pTable.szTabRow = (short)(fakeIdx.szIdxRow);
				pTable.tabFlags |= (uint)(0x00000010);
			}

			return (int)(0);
		}
		public static int analyzeFilterKeyword(byte* z, int lastToken)
		{
			if (((lastToken) == (23)) && ((getToken(&z)) == (22)))
			{
				return (int)(166);
			}

			return (int)(59);
		}
		public static int analyzeOverKeyword(byte* z, int lastToken)
		{
			if ((lastToken) == (23))
			{
				int t = (int)(getToken(&z));
				if (((t) == (22)) || ((t) == (59)))
					return (int)(165);
			}

			return (int)(59);
		}
		public static int analyzeWindowKeyword(byte* z)
		{
			int t = 0;
			t = (int)(getToken(&z));
			if (t != 59)
				return (int)(59);
			t = (int)(getToken(&z));
			if (t != 24)
				return (int)(59);
			return (int)(164);
		}
		public static sbyte* appendText(sbyte* p, sbyte* z)
		{
			ulong n = (ulong)(CRuntime.strlen(z));
			CRuntime.memcpy(p, z, (ulong)(n + 1));
			return p + n + 1;
		}
		public static int binCollFunc(void* NotUsed, int nKey1, void* pKey1, int nKey2, void* pKey2)
		{
			int rc = 0; int n = 0;
			n = (int)((nKey1) < (nKey2) ? nKey1 : nKey2);
			rc = (int)(memcmp(pKey1, pKey2, (ulong)(n)));
			if ((rc) == (0))
			{
				rc = (int)(nKey1 - nKey2);
			}

			return (int)(rc);
		}
		public static void btreeHeapInsert(uint* aHeap, uint x)
		{
			uint j = 0; uint i = (uint)(++aHeap[0]);
			aHeap[i] = (uint)(x);
			while (((j = (uint)(i / 2)) > (0)) && ((aHeap[j]) > (aHeap[i])))
			{
				x = (uint)(aHeap[j]);
				aHeap[j] = (uint)(aHeap[i]);
				aHeap[i] = (uint)(x);
				i = (uint)(j);
			}
		}
		public static int btreeHeapPull(uint* aHeap, uint* pOut)
		{
			uint j = 0; uint i = 0; uint x = 0;
			if ((x = (uint)(aHeap[0])) == (0))
				return (int)(0);
			*pOut = (uint)(aHeap[1]);
			aHeap[1] = (uint)(aHeap[x]);
			aHeap[x] = (uint)(0xffffffff);
			aHeap[0]--;
			i = (uint)(1);
			while ((j = (uint)(i * 2)) <= (aHeap[0]))
			{
				if ((aHeap[j]) > (aHeap[j + 1]))
					j++;
				if ((aHeap[i]) < (aHeap[j]))
					break;
				x = (uint)(aHeap[i]);
				aHeap[i] = (uint)(aHeap[j]);
				aHeap[j] = (uint)(x);
				i = (uint)(j);
			}

			return (int)(1);
		}
		public static int btreeInvokeBusyHandler(void* pArg)
		{
			BtShared pBt = (BtShared)(pArg);
			return (int)(sqlite3InvokeBusyHandler(pBt.db.busyHandler));
		}
		public static int collationMatch(sbyte* zColl, Index pIndex)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pIndex.nColumn); i++)
			{
				sbyte* z = pIndex.azColl[i];
				if (((pIndex.aiColumn[i]) >= (0)) && ((0) == (sqlite3StrICmp(z, zColl))))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static void* columnName(sqlite3_stmt* pStmt, int N, int useUtf16, int useType)
		{
			void* ret;
			Vdbe p;
			int n = 0;
			sqlite3 db;
			ret = null;
			p = (Vdbe)(pStmt);
			db = p.db;
			n = (int)(sqlite3_column_count(pStmt));
			if (((N) < (n)) && ((N) >= (0)))
			{
				N += (int)(useType * n);
				sqlite3_mutex_enter(db.mutex);
				if ((useUtf16) != 0)
				{
					ret = sqlite3_value_text16(p.aColName[N]);
				}
				else
				{
					ret = sqlite3_value_text(p.aColName[N]);
				}

				if ((db.mallocFailed) != 0)
				{
					sqlite3OomClear(db);
					ret = null;
				}

				sqlite3_mutex_leave(db.mutex);
			}

			return ret;
		}
		public static sqlite3_value columnNullValue()
		{
			return columnNullValue_nullMem;
		}
		public static sbyte* columnTypeImpl(NameContext pNC, Expr pExpr)
		{
			sbyte* zType = null;
			int j = 0;
			switch (pExpr.op)
			{
				case 167:
					{
						Table pTab = null;
						Select pS = null;
						int iCol = (int)(pExpr.iColumn);
						while (((pNC) != null) && (pTab == null))
						{
							SrcList pTabList = pNC.pSrcList;
							for (j = (int)(0); ((j) < (pTabList.nSrc)) && (pTabList.a[j].iCursor != pExpr.iTable); j++)
							{
							}

							if ((j) < (pTabList.nSrc))
							{
								pTab = pTabList.a[j].pTab;
								pS = pTabList.a[j].pSelect;
							}
							else
							{
								pNC = pNC.pNext;
							}
						}

						if ((pTab) == (null))
						{
							break;
						}

						if ((pS) != null)
						{
							if (((iCol) < (pS.pEList.nExpr)) && ((iCol) >= (0)))
							{
								NameContext sNC = new NameContext();
								Expr p = pS.pEList.a[iCol].pExpr;
								sNC.pSrcList = pS.pSrc;
								sNC.pNext = pNC;
								sNC.pParse = pNC.pParse;
								zType = columnTypeImpl(sNC, p);
							}
						}
						else
						{
							if ((iCol) < (0))
							{
								zType = "INTEGER";
							}
							else
							{
								zType = sqlite3ColumnType(&pTab.aCol[iCol], null);
							}
						}

						break;
					}

				case 138:
					{
						NameContext sNC = new NameContext();
						Select pS;
						Expr p;
						pS = pExpr.x.pSelect;
						p = pS.pEList.a[0].pExpr;
						sNC.pSrcList = pS.pSrc;
						sNC.pNext = pNC;
						sNC.pParse = pNC.pParse;
						zType = columnTypeImpl(sNC, p);
						break;
					}
			}

			return zType;
		}
		public static int compare2pow63(sbyte* zNum, int incr)
		{
			int c = (int)(0);
			int i = 0;
			sbyte* pow63 = "922337203685477580";
			for (i = (int)(0); ((c) == (0)) && ((i) < (18)); i++)
			{
				c = (int)((zNum[i * incr] - pow63[i]) * 10);
			}

			if ((c) == (0))
			{
				c = (int)(zNum[18 * incr] - 56);
			}

			return (int)(c);
		}
		public static void* contextMalloc(sqlite3_context context, long nByte)
		{
			sbyte* z;
			sqlite3 db = sqlite3_context_db_handle(context);
			if ((nByte) > (db.aLimit[0]))
			{
				sqlite3_result_error_toobig(context);
				z = null;
			}
			else
			{
				z = sqlite3Malloc((ulong)(nByte));
				if (z == null)
				{
					sqlite3_result_error_nomem(context);
				}
			}

			return z;
		}
		public static int copyPayload(void* pPayload, void* pBuf, int nByte, int eOp, PgHdr pDbPage)
		{
			if ((eOp) != 0)
			{
				int rc = (int)(sqlite3PagerWrite(pDbPage));
				if (rc != 0)
				{
					return (int)(rc);
				}

				CRuntime.memcpy(pPayload, pBuf, (ulong)(nByte));
			}
			else
			{
				CRuntime.memcpy(pBuf, pPayload, (ulong)(nByte));
			}

			return (int)(0);
		}
		public static void* createAggContext(sqlite3_context p, int nByte)
		{
			sqlite3_value pMem = p.pMem;
			if ((nByte) <= (0))
			{
				sqlite3VdbeMemSetNull(pMem);
				pMem.z = null;
			}
			else
			{
				sqlite3VdbeMemClearAndResize(pMem, (int)(nByte));
				pMem.flags = (ushort)(0x2000);
				pMem.u.pDef = p.pFunc;
				if ((pMem.z) != null)
				{
					CRuntime.memset(pMem.z, (int)(0), (ulong)(nByte));
				}
			}

			return (void*)(pMem.z);
		}
		public static sbyte* createTableStmt(sqlite3 db, Table p)
		{
			int i = 0; int k = 0; int n = 0;
			sbyte* zStmt;
			sbyte* zSep; sbyte* zSep2; sbyte* zEnd;
			Column* pCol;
			n = (int)(0);
			for (pCol = p.aCol, i = (int)(0); (i) < (p.nCol); i++, pCol++)
			{
				n += (int)(identLength(pCol->zCnName) + 5);
			}

			n += (int)(identLength(p.zName));
			if ((n) < (50))
			{
				zSep = "";
				zSep2 = ",";
				zEnd = ")";
			}
			else
			{
				zSep = "\n  ";
				zSep2 = ",\n  ";
				zEnd = "\n)";
			}

			n += (int)(35 + 6 * p.nCol);
			zStmt = sqlite3DbMallocRaw(null, (ulong)(n));
			if ((zStmt) == (null))
			{
				sqlite3OomFault(db);
				return null;
			}

			sqlite3_snprintf((int)(n), zStmt, "CREATE TABLE ");
			k = (int)(sqlite3Strlen30(zStmt));
			identPut(zStmt, &k, p.zName);
			zStmt[k++] = (sbyte)(40);
			for (pCol = p.aCol, i = (int)(0); (i) < (p.nCol); i++, pCol++)
			{
				int len = 0;
				sbyte* zType;
				sqlite3_snprintf((int)(n - k), &zStmt[k], zSep);
				k += (int)(sqlite3Strlen30(&zStmt[k]));
				zSep = zSep2;
				identPut(zStmt, &k, pCol->zCnName);
				zType = createTableStmt_azType[pCol->affinity - 0x41];
				len = (int)(sqlite3Strlen30(zType));
				CRuntime.memcpy(&zStmt[k], zType, (ulong)(len));
				k += (int)(len);
			}

			sqlite3_snprintf((int)(n - k), &zStmt[k], "%s", zEnd);
			return zStmt;
		}
		public static sbyte* databaseName(sbyte* zName)
		{
			while ((((zName[-1] != 0) || (zName[-2] != 0)) || (zName[-3] != 0)) || (zName[-4] != 0))
			{
				zName--;
			}

			return zName;
		}
		public static void* dbMallocRawFinish(sqlite3 db, ulong n)
		{
			void* p;
			p = sqlite3Malloc((ulong)(n));
			if (p == null)
				sqlite3OomFault(db);
			return p;
		}
		public static void* dbReallocFinish(sqlite3 db, void* p, ulong n)
		{
			void* pNew = null;
			if ((db.mallocFailed) == (0))
			{
				if ((isLookaside(db, p)) != 0)
				{
					pNew = sqlite3DbMallocRawNN(db, (ulong)(n));
					if ((pNew) != null)
					{
						CRuntime.memcpy(pNew, p, (ulong)(lookasideMallocSize(db, p)));
						sqlite3DbFree(db, p);
					}
				}
				else
				{
					pNew = sqlite3Realloc(p, (ulong)(n));
					if (pNew == null)
					{
						sqlite3OomFault(db);
					}
				}
			}

			return pNew;
		}
		public static void decodeIntArray(sbyte* zIntArray, int nOut, uint* aOut, short* aLog, Index pIndex)
		{
			sbyte* z = zIntArray;
			int c = 0;
			int i = 0;
			uint v = 0;
			for (i = (int)(0); ((*z) != 0) && ((i) < (nOut)); i++)
			{
				v = (uint)(0);
				while (((c = (int)(z[0])) >= (48)) && ((c) <= (57)))
				{
					v = (uint)(v * 10 + c - 48);
					z++;
				}

				aLog[i] = (short)(sqlite3LogEst((ulong)(v)));
				if ((*z) == (32))
					z++;
			}

			{
				pIndex.bUnordered = (uint)(0);
				pIndex.noSkipScan = (uint)(0);
				while ((z[0]) != 0)
				{
					if ((sqlite3_strglob("unordered*", z)) == (0))
					{
						pIndex.bUnordered = (uint)(1);
					}
					else if ((sqlite3_strglob("sz=[0-9]*", z)) == (0))
					{
						int sz = (int)(sqlite3Atoi(z + 3));
						if ((sz) < (2))
							sz = (int)(2);
						pIndex.szIdxRow = (short)(sqlite3LogEst((ulong)(sz)));
					}
					else if ((sqlite3_strglob("noskipscan*", z)) == (0))
					{
						pIndex.noSkipScan = (uint)(1);
					}

					while ((z[0] != 0) && (z[0] != 32))
					{
						z++;
					}

					while ((z[0]) == (32))
					{
						z++;
					}
				}
			}
		}
		public static long doubleToInt64(double r)
		{
			if ((r) <= ((double)(doubleToInt64_minInt)))
			{
				return (long)(doubleToInt64_minInt);
			}
			else if ((r) >= ((double)(doubleToInt64_maxInt)))
			{
				return (long)(doubleToInt64_maxInt);
			}
			else
			{
				return (long)(r);
			}
		}
		public static short estLog(short N)
		{
			return (short)((N) <= (10) ? 0 : sqlite3LogEst((ulong)(N)) - 33);
		}
		public static sbyte et_getdigit(double* val, int* cnt)
		{
			int digit = 0;
			double d = 0;
			if ((*cnt) <= (0))
				return (sbyte)(48);
			(*cnt)--;
			digit = ((int)(*val));
			d = (double)(digit);
			digit += (int)(48);
			*val = (double)((*val - d) * 10.0);
			return (sbyte)(digit);
		}
		public static sbyte* explainIndexColumnName(Index pIdx, int i)
		{
			i = (int)(pIdx.aiColumn[i]);
			if ((i) == (-2))
				return "<expr>";
			if ((i) == (-1))
				return "rowid";
			return pIdx.pTable.aCol[i].zCnName;
		}
		public static sbyte* exprINAffinity(Parse pParse, Expr pExpr)
		{
			Expr pLeft = pExpr.pLeft;
			int nVal = (int)(sqlite3ExprVectorSize(pLeft));
			Select pSelect = (((pExpr).flags & 0x000800) != 0) ? pExpr.x.pSelect : null;
			sbyte* zRet;
			zRet = sqlite3DbMallocRaw(pParse.db, (ulong)(nVal + 1));
			if ((zRet) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (nVal); i++)
				{
					Expr pA = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
					sbyte a = (sbyte)(sqlite3ExprAffinity(pA));
					if ((pSelect) != null)
					{
						zRet[i] = (sbyte)(sqlite3CompareAffinity(pSelect.pEList.a[i].pExpr, (sbyte)(a)));
					}
					else
					{
						zRet[i] = (sbyte)(a);
					}
				}

				zRet[nVal] = (sbyte)(0);
			}

			return zRet;
		}
		public static void* fetchPayload(BtCursor pCur, uint* pAmt)
		{
			int amt = 0;
			amt = (int)(pCur.info.nLocal);
			if ((amt) > ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)))
			{
				amt = (int)((0) > ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)) ? (0) : ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)));
			}

			*pAmt = ((uint)(amt));
			return (void*)(pCur.info.pPayload);
		}
		public static HashElem* findElementWithHash(Hash* pH, sbyte* pKey, uint* pHash)
		{
			HashElem* elem;
			uint count = 0;
			uint h = 0;
			if ((pH->ht) != null)
			{
				_ht* pEntry;
				h = (uint)(strHash(pKey) % pH->htsize);
				pEntry = &pH->ht[h];
				elem = pEntry->chain;
				count = (uint)(pEntry->count);
			}
			else
			{
				h = (uint)(0);
				elem = pH->first;
				count = (uint)(pH->count);
			}

			if ((pHash) != null)
				*pHash = (uint)(h);
			while ((count--) != 0)
			{
				if ((sqlite3StrICmp(elem->pKey, pKey)) == (0))
				{
					return elem;
				}

				elem = elem->next;
			}

			return &findElementWithHash_nullElement;
		}
		public static int findNextHostParameter(sbyte* zSql, int* pnToken)
		{
			int tokenType = 0;
			int nTotal = (int)(0);
			int n = 0;
			*pnToken = (int)(0);
			while ((zSql[0]) != 0)
			{
				n = (int)(sqlite3GetToken((byte*)(zSql), &tokenType));
				if ((tokenType) == (156))
				{
					*pnToken = (int)(n);
					break;
				}

				nTotal += (int)(n);
				zSql += n;
			}

			return (int)(nTotal);
		}
		public static int getAutoVacuum(sbyte* z)
		{
			int i = 0;
			if ((0) == (sqlite3StrICmp(z, "none")))
				return (int)(0);
			if ((0) == (sqlite3StrICmp(z, "full")))
				return (int)(1);
			if ((0) == (sqlite3StrICmp(z, "incremental")))
				return (int)(2);
			i = (int)(sqlite3Atoi(z));
			return (int)((byte)((((i) >= (0)) && ((i) <= (2))) ? i : 0));
		}
		public static int getDigits(sbyte* zDate, sbyte* zFormat)
		{
			sbyte* ap;
			int cnt = (int)(0);
			sbyte nextC = 0;
			(__va_start(&ap, zFormat));
			do
			{
				sbyte N = (sbyte)(zFormat[0] - 48);
				sbyte min = (sbyte)(zFormat[1] - 48);
				int val = (int)(0);
				ushort max = 0;
				max = (ushort)(getDigits_aMx[zFormat[2] - 97]);
				nextC = (sbyte)(zFormat[3]);
				val = (int)(0);
				while ((N--) != 0)
				{
					if ((sqlite3CtypeMap[(byte)(*zDate)] & 0x04) == 0)
					{
						goto end_getDigits;
					}

					val = (int)(val * 10 + *zDate - 48);
					zDate++;
				}

				if ((((val) < ((int)(min))) || ((val) > ((int)(max)))) || ((nextC != 0) && (nextC != *zDate)))
				{
					goto end_getDigits;
				}

				*(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(val);
				zDate++;
				cnt++;
				zFormat += 4;
			}
			while ((nextC) != 0);
		end_getDigits:
			; ((void)(ap = null));
			return (int)(cnt);
		}
		public static int getLockingMode(sbyte* z)
		{
			if ((z) != null)
			{
				if ((0) == (sqlite3StrICmp(z, "exclusive")))
					return (int)(1);
				if ((0) == (sqlite3StrICmp(z, "normal")))
					return (int)(0);
			}

			return (int)(-1);
		}
		public static byte getSafetyLevel(sbyte* z, int omitFull, byte dflt)
		{
			int i = 0; int n = 0;
			if ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0)
			{
				return (byte)(sqlite3Atoi(z));
			}

			n = (int)(sqlite3Strlen30(z));
			for (i = (int)(0); (i) < ((int)(8 * sizeof(byte) / sizeof(byte))); i++)
			{
				if ((((getSafetyLevel_iLength[i]) == (n)) && ((sqlite3_strnicmp(&getSafetyLevel_zText[getSafetyLevel_iOffset[i]], z, (int)(n))) == (0))) && ((omitFull == 0) || ((getSafetyLevel_iValue[i]) <= (1))))
				{
					return (byte)(getSafetyLevel_iValue[i]);
				}
			}

			return (byte)(dflt);
		}
		public static int getTempStore(sbyte* z)
		{
			if (((z[0]) >= (48)) && ((z[0]) <= (50)))
			{
				return (int)(z[0] - 48);
			}
			else if ((sqlite3StrICmp(z, "file")) == (0))
			{
				return (int)(1);
			}
			else if ((sqlite3StrICmp(z, "memory")) == (0))
			{
				return (int)(2);
			}
			else
			{
				return (int)(0);
			}
		}
		public static sbyte* getTextArg(PrintfArguments p)
		{
			if ((p.nArg) <= (p.nUsed))
				return null;
			return (sbyte*)(sqlite3_value_text(p.apArg[p.nUsed++]));
		}
		public static int getToken(byte** pz)
		{
			byte* z = *pz;
			int t = 0;
			do
			{
				z += sqlite3GetToken(z, &t);
			}
			while ((t) == (183));
			if (((((((t) == (59)) || ((t) == (117))) || ((t) == (118))) || ((t) == (164))) || ((t) == (165))) || ((sqlite3ParserFallback((int)(t))) == (59)))
			{
				t = (int)(59);
			}

			*pz = z;
			return (int)(t);
		}
		public static int hasColumn(short* aiCol, int nCol, int x)
		{
			while ((nCol--) > (0))
			{
				if ((x) == (*(aiCol++)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int identLength(sbyte* z)
		{
			int n = 0;
			for (n = (int)(0); *z; n++, z++)
			{
				if ((*z) == (34))
				{
					n++;
				}
			}

			return (int)(n + 2);
		}
		public static void identPut(sbyte* z, int* pIdx, sbyte* zSignedIdent)
		{
			byte* zIdent = (byte*)(zSignedIdent);
			int i = 0; int j = 0; int needQuote = 0;
			i = (int)(*pIdx);
			for (j = (int)(0); zIdent[j]; j++)
			{
				if (((sqlite3CtypeMap[(zIdent[j])] & 0x06) == 0) && (zIdent[j] != 95))
					break;
			}

			needQuote = (int)(((((sqlite3CtypeMap[(zIdent[0])] & 0x04) != 0) || (sqlite3KeywordCode(zIdent, (int)(j)) != 59)) || (zIdent[j] != 0)) || ((j) == (0)) ? 1 : 0);
			if ((needQuote) != 0)
				z[i++] = (sbyte)(34);
			for (j = (int)(0); zIdent[j]; j++)
			{
				z[i++] = (sbyte)(zIdent[j]);
				if ((zIdent[j]) == (34))
					z[i++] = (sbyte)(34);
			}

			if ((needQuote) != 0)
				z[i++] = (sbyte)(34);
			z[i] = (sbyte)(0);
			*pIdx = (int)(i);
		}
		public static int invokeValueDestructor(void* p, delegate17 xDel, sqlite3_context pCtx)
		{
			if ((xDel) == (null))
			{
			}
			else if ((xDel) == ((Void(Void * ))(-1)))
			{
			}
			else
			{
				xDel(p);
			}

			sqlite3_result_error_toobig(pCtx);
			return (int)(18);
		}
		public static int isAllZero(sbyte* z, int n)
		{
			int i = 0;
			for (i = (int)(0); (i) < (n); i++)
			{
				if ((z[i]) != 0)
					return (int)(0);
			}

			return (int)(1);
		}
		public static int isFatalError(int rc)
		{
			return ((((rc != 0) && (rc != 5)) && (rc != 6)) ? 1 : 0);
		}
		public static byte jsonHexToInt(int h)
		{
			h += (int)(9 * (1 & (h >> 6)));
			return (byte)(h & 0xf);
		}
		public static uint jsonHexToInt4(sbyte* z)
		{
			uint v = 0;
			v = (uint)((jsonHexToInt((int)(z[0])) << 12) + (jsonHexToInt((int)(z[1])) << 8) + (jsonHexToInt((int)(z[2])) << 4) + jsonHexToInt((int)(z[3])));
			return (uint)(v);
		}
		public static int jsonIs4Hex(sbyte* z)
		{
			int i = 0;
			for (i = (int)(0); (i) < (4); i++)
			{
				if ((sqlite3CtypeMap[(byte)(z[i])] & 0x08) == 0)
					return (int)(0);
			}

			return (int)(1);
		}
		public static JsonNode* jsonLookup(JsonParse* pParse, sbyte* zPath, int* pApnd, sqlite3_context pCtx)
		{
			sbyte* zErr = null;
			JsonNode* pNode = null;
			sbyte* zMsg;
			if ((zPath) == (null))
				return null;
			if (zPath[0] != 36)
			{
				zErr = zPath;
				goto lookup_err;
			}

			zPath++;
			pNode = jsonLookupStep(pParse, (uint)(0), zPath, pApnd, &zErr);
			if ((zErr) == (null))
				return pNode;
			lookup_err:
			; pParse->nErr++;
			zMsg = jsonPathSyntaxError(zErr);
			if ((zMsg) != null)
			{
				sqlite3_result_error(pCtx, zMsg, (int)(-1));
				sqlite3_free(zMsg);
			}
			else
			{
				sqlite3_result_error_nomem(pCtx);
			}

			return null;
		}
		public static JsonNode* jsonLookupAppend(JsonParse* pParse, sbyte* zPath, int* pApnd, sbyte** pzErr)
		{
			*pApnd = (int)(1);
			if ((zPath[0]) == (0))
			{
				jsonParseAddNode(pParse, (uint)(0), (uint)(0), null);
				return (pParse->oom) != 0 ? null : &pParse->aNode[pParse->nNode - 1];
			}

			if ((zPath[0]) == (46))
			{
				jsonParseAddNode(pParse, (uint)(7), (uint)(0), null);
			}
			else if ((CRuntime.strncmp(zPath, "[0]", (ulong)(3))) == (0))
			{
				jsonParseAddNode(pParse, (uint)(6), (uint)(0), null);
			}
			else
			{
				return null;
			}

			if ((pParse->oom) != 0)
				return null;
			return jsonLookupStep(pParse, (uint)(pParse->nNode - 1), zPath, pApnd, pzErr);
		}
		public static JsonNode* jsonLookupStep(JsonParse* pParse, uint iRoot, sbyte* zPath, int* pApnd, sbyte** pzErr)
		{
			uint i = 0; uint j = 0; uint nKey = 0;
			sbyte* zKey;
			JsonNode* pRoot = &pParse->aNode[iRoot];
			if ((zPath[0]) == (0))
				return pRoot;
			if ((pRoot->jnFlags & 0x08) != 0)
				return null;
			if ((zPath[0]) == (46))
			{
				if (pRoot->eType != 7)
					return null;
				zPath++;
				if ((zPath[0]) == (34))
				{
					zKey = zPath + 1;
					for (i = (uint)(1); ((zPath[i]) != 0) && (zPath[i] != 34); i++)
					{
					}

					nKey = (uint)(i - 1);
					if ((zPath[i]) != 0)
					{
						i++;
					}
					else
					{
						*pzErr = zPath;
						return null;
					}
				}
				else
				{
					zKey = zPath;
					for (i = (uint)(0); (((zPath[i]) != 0) && (zPath[i] != 46)) && (zPath[i] != 91); i++)
					{
					}

					nKey = (uint)(i);
				}

				if ((nKey) == (0))
				{
					*pzErr = zPath;
					return null;
				}

				j = (uint)(1);
				for (; ; )
				{
					while ((j) <= (pRoot->n))
					{
						if ((jsonLabelCompare(pRoot + j, zKey, (uint)(nKey))) != 0)
						{
							return jsonLookupStep(pParse, (uint)(iRoot + j + 1), &zPath[i], pApnd, pzErr);
						}

						j++;
						j += (uint)(jsonNodeSize(&pRoot[j]));
					}

					if ((pRoot->jnFlags & 0x20) == (0))
						break;
					iRoot += (uint)(pRoot->u.iAppend);
					pRoot = &pParse->aNode[iRoot];
					j = (uint)(1);
				}

				if ((pApnd) != null)
				{
					uint iStart = 0;
					uint iLabel = 0;
					JsonNode* pNode;
					iStart = (uint)(jsonParseAddNode(pParse, (uint)(7), (uint)(2), null));
					iLabel = (uint)(jsonParseAddNode(pParse, (uint)(5), (uint)(nKey), zKey));
					zPath += i;
					pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
					if ((pParse->oom) != 0)
						return null;
					if ((pNode) != null)
					{
						pRoot = &pParse->aNode[iRoot];
						pRoot->u.iAppend = (uint)(iStart - iRoot);
						pRoot->jnFlags |= (byte)(0x20);
						pParse->aNode[iLabel].jnFlags |= (byte)(0x01);
					}

					return pNode;
				}
			}
			else if ((zPath[0]) == (91))
			{
				i = (uint)(0);
				j = (uint)(1);
				while ((sqlite3CtypeMap[(byte)(zPath[j])] & 0x04) != 0)
				{
					i = (uint)(i * 10 + zPath[j] - 48);
					j++;
				}

				if (((j) < (2)) || (zPath[j] != 93))
				{
					if ((zPath[1]) == (35))
					{
						JsonNode* pBase = pRoot;
						int iBase = (int)(iRoot);
						if (pRoot->eType != 6)
							return null;
						for (; ; )
						{
							while ((j) <= (pBase->n))
							{
								if ((pBase[j].jnFlags & 0x04) == (0))
									i++;
								j += (uint)(jsonNodeSize(&pBase[j]));
							}

							if ((pBase->jnFlags & 0x20) == (0))
								break;
							iBase += (int)(pBase->u.iAppend);
							pBase = &pParse->aNode[iBase];
							j = (uint)(1);
						}

						j = (uint)(2);
						if (((zPath[2]) == (45)) && ((sqlite3CtypeMap[(byte)(zPath[3])] & 0x04) != 0))
						{
							uint x = (uint)(0);
							j = (uint)(3);
							do
							{
								x = (uint)(x * 10 + zPath[j] - 48);
								j++;
							}
							while ((sqlite3CtypeMap[(byte)(zPath[j])] & 0x04) != 0);
							if ((x) > (i))
								return null;
							i -= (uint)(x);
						}

						if (zPath[j] != 93)
						{
							*pzErr = zPath;
							return null;
						}
					}
					else
					{
						*pzErr = zPath;
						return null;
					}
				}

				if (pRoot->eType != 6)
					return null;
				zPath += j + 1;
				j = (uint)(1);
				for (; ; )
				{
					while (((j) <= (pRoot->n)) && (((i) > (0)) || ((pRoot[j].jnFlags & 0x04) != 0)))
					{
						if ((pRoot[j].jnFlags & 0x04) == (0))
							i--;
						j += (uint)(jsonNodeSize(&pRoot[j]));
					}

					if ((pRoot->jnFlags & 0x20) == (0))
						break;
					iRoot += (uint)(pRoot->u.iAppend);
					pRoot = &pParse->aNode[iRoot];
					j = (uint)(1);
				}

				if ((j) <= (pRoot->n))
				{
					return jsonLookupStep(pParse, (uint)(iRoot + j), zPath, pApnd, pzErr);
				}

				if (((i) == (0)) && ((pApnd) != null))
				{
					uint iStart = 0;
					JsonNode* pNode;
					iStart = (uint)(jsonParseAddNode(pParse, (uint)(6), (uint)(1), null));
					pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
					if ((pParse->oom) != 0)
						return null;
					if ((pNode) != null)
					{
						pRoot = &pParse->aNode[iRoot];
						pRoot->u.iAppend = (uint)(iStart - iRoot);
						pRoot->jnFlags |= (byte)(0x20);
					}

					return pNode;
				}
			}
			else
			{
				*pzErr = zPath;
			}

			return null;
		}
		public static JsonNode* jsonMergePatch(JsonParse* pParse, uint iTarget, JsonNode* pPatch)
		{
			uint i = 0; uint j = 0;
			uint iRoot = 0;
			JsonNode* pTarget;
			if (pPatch->eType != 7)
			{
				return pPatch;
			}

			pTarget = &pParse->aNode[iTarget];
			if (pTarget->eType != 7)
			{
				jsonRemoveAllNulls(pPatch);
				return pPatch;
			}

			iRoot = (uint)(iTarget);
			for (i = (uint)(1); (i) < (pPatch->n); i += (uint)(jsonNodeSize(&pPatch[i + 1]) + 1))
			{
				uint nKey = 0;
				sbyte* zKey;
				nKey = (uint)(pPatch[i].n);
				zKey = pPatch[i].u.zJContent;
				for (j = (uint)(1); (j) < (pTarget->n); j += (uint)(jsonNodeSize(&pTarget[j + 1]) + 1))
				{
					if (((pTarget[j].n) == (nKey)) && ((CRuntime.strncmp(pTarget[j].u.zJContent, zKey, (ulong)(nKey))) == (0)))
					{
						if ((pTarget[j + 1].jnFlags & (0x04 | 0x10)) != 0)
							break;
						if ((pPatch[i + 1].eType) == (0))
						{
							pTarget[j + 1].jnFlags |= (byte)(0x04);
						}
						else
						{
							JsonNode* pNew = jsonMergePatch(pParse, (uint)(iTarget + j + 1), &pPatch[i + 1]);
							if ((pNew) == (null))
								return null;
							pTarget = &pParse->aNode[iTarget];
							if (pNew != &pTarget[j + 1])
							{
								pTarget[j + 1].u.pPatch = pNew;
								pTarget[j + 1].jnFlags |= (byte)(0x10);
							}
						}

						break;
					}
				}

				if (((j) >= (pTarget->n)) && (pPatch[i + 1].eType != 0))
				{
					int iStart = 0;
					int iPatch = 0;
					iStart = (int)(jsonParseAddNode(pParse, (uint)(7), (uint)(2), null));
					jsonParseAddNode(pParse, (uint)(5), (uint)(nKey), zKey);
					iPatch = (int)(jsonParseAddNode(pParse, (uint)(1), (uint)(0), null));
					if ((pParse->oom) != 0)
						return null;
					jsonRemoveAllNulls(pPatch);
					pTarget = &pParse->aNode[iTarget];
					pParse->aNode[iRoot].jnFlags |= (byte)(0x20);
					pParse->aNode[iRoot].u.iAppend = (uint)(iStart - iRoot);
					iRoot = (uint)(iStart);
					pParse->aNode[iPatch].jnFlags |= (byte)(0x10);
					pParse->aNode[iPatch].u.pPatch = &pPatch[i + 1];
				}
			}

			return pTarget;
		}
		public static JsonParse* jsonParseCached(sqlite3_context pCtx, sqlite3_value argv, sqlite3_context pErrCtx)
		{
			sbyte* zJson = (sbyte*)(sqlite3_value_text(argv[0]));
			int nJson = (int)(sqlite3_value_bytes(argv[0]));
			JsonParse* p;
			JsonParse* pMatch = null;
			int iKey = 0;
			int iMinKey = (int)(0);
			uint iMinHold = (uint)(0xffffffff);
			uint iMaxHold = (uint)(0);
			if ((zJson) == (null))
				return null;
			for (iKey = (int)(0); (iKey) < (4); iKey++)
			{
				p = (JsonParse*)(sqlite3_get_auxdata(pCtx, (int)((-429938) + iKey)));
				if ((p) == (null))
				{
					iMinKey = (int)(iKey);
					break;
				}

				if ((((pMatch) == (null)) && ((p->nJson) == (nJson))) && ((memcmp(p->zJson, zJson, (ulong)(nJson))) == (0)))
				{
					p->nErr = (byte)(0);
					pMatch = p;
				}
				else if ((p->iHold) < (iMinHold))
				{
					iMinHold = (uint)(p->iHold);
					iMinKey = (int)(iKey);
				}

				if ((p->iHold) > (iMaxHold))
				{
					iMaxHold = (uint)(p->iHold);
				}
			}

			if ((pMatch) != null)
			{
				pMatch->nErr = (byte)(0);
				pMatch->iHold = (uint)(iMaxHold + 1);
				return pMatch;
			}

			p = sqlite3_malloc64((ulong)(sizeof(JsonParse) + nJson + 1));
			if ((p) == (null))
			{
				sqlite3_result_error_nomem(pCtx);
				return null;
			}

			CRuntime.memset(p, (int)(0), (ulong)(sizeof(JsonParse)));
			p->zJson = (sbyte*)(&p[1]);
			CRuntime.memcpy(p->zJson, zJson, (ulong)(nJson + 1));
			if ((jsonParse(p, pErrCtx, p->zJson)) != 0)
			{
				sqlite3_free(p);
				return null;
			}

			p->nJson = (int)(nJson);
			p->iHold = (uint)(iMaxHold + 1);
			sqlite3_set_auxdata(pCtx, (int)((-429938) + iMinKey), p, (Void(Void * ))(jsonParseFree));
			return (JsonParse*)(sqlite3_get_auxdata(pCtx, (int)((-429938) + iMinKey)));
		}
		public static sbyte* jsonPathSyntaxError(sbyte* zErr)
		{
			return sqlite3_mprintf("JSON path error near '%q'", zErr);
		}
		public static void jsonPrintf(int N, JsonString p, sbyte* zFormat)
		{
			sbyte* ap;
			if (((p.nUsed + N) >= (p.nAlloc)) && ((jsonGrow(p, (uint)(N))) != 0))
				return;
			(__va_start(&ap, zFormat));
			sqlite3_vsnprintf((int)(N), p.zBuf + p.nUsed, zFormat, ap);
			((void)(ap = null));
			p.nUsed += (ulong)((int)(CRuntime.strlen(p.zBuf + p.nUsed)));
		}
		public static int keywordCode(sbyte* z, int n, int* pType)
		{
			int i = 0; int j = 0;
			sbyte* zKW;
			if ((n) >= (2))
			{
				i = (int)(((sqlite3UpperToLower[(byte)(z[0])] * 4) ^ (sqlite3UpperToLower[(byte)(z[n - 1])] * 3) ^ n * 1) % 127);
				for (i = (int)(((int)(aKWHash[i])) - 1); (i) >= (0); i = (int)(((int)(aKWNext[i])) - 1))
				{
					if (aKWLen[i] != n)
						continue;
					zKW = &zKWText[aKWOffset[i]];
					if ((z[0] & ~0x20) != zKW[0])
						continue;
					if ((z[1] & ~0x20) != zKW[1])
						continue;
					j = (int)(2);
					while (((j) < (n)) && ((z[j] & ~0x20) == (zKW[j])))
					{
						j++;
					}

					if ((j) < (n))
						continue;
					*pType = (int)(aKWCode[i]);
					break;
				}
			}

			return (int)(n);
		}
		public static void logBadConnection(sbyte* zType)
		{
			sqlite3_log((int)(21), "API call with %s database connection pointer", zType);
		}
		public static void mallocWithAlarm(int n, void** pp)
		{
			void* p;
			int nFull = 0;
			nFull = (int)(sqlite3Config.m.xRoundup((int)(n)));
			sqlite3StatusHighwater((int)(5), (int)(n));
			if ((mem0.alarmThreshold) > (0))
			{
				long nUsed = (long)(sqlite3StatusValue((int)(0)));
				if ((nUsed) >= (mem0.alarmThreshold - nFull))
				{
					(1);
					sqlite3MallocAlarm((int)(nFull));
					if ((mem0.hardLimit) != 0)
					{
						nUsed = (long)(sqlite3StatusValue((int)(0)));
						if ((nUsed) >= (mem0.hardLimit - nFull))
						{
							*pp = null;
							return;
						}
					}
				}
				else
				{
					(0);
				}
			}

			p = sqlite3Config.m.xMalloc((int)(nFull));
			if ((p) != null)
			{
				nFull = (int)(sqlite3MallocSize(p));
				sqlite3StatusUp((int)(0), (int)(nFull));
				sqlite3StatusUp((int)(9), (int)(1));
			}

			*pp = p;
		}
		public static void* memdbDlOpen(sqlite3_vfs pVfs, sbyte* zPath)
		{
			return ((sqlite3_vfs)((pVfs).pAppData)).xDlOpen(((sqlite3_vfs)((pVfs).pAppData)), zPath);
		}
		public static Void()memdbDlSym(sqlite3_vfs pVfs, void* p, sbyte* zSym)
		{
			return ((sqlite3_vfs)((pVfs).pAppData)).xDlSym(((sqlite3_vfs)((pVfs).pAppData)), p, zSym);
		}
		public static int nocaseCollatingFunc(void* NotUsed, int nKey1, void* pKey1, int nKey2, void* pKey2)
		{
			int r = (int)(sqlite3_strnicmp((sbyte*)(pKey1), (sbyte*)(pKey2), (int)(((nKey1) < (nKey2)) ? nKey1 : nKey2)));
			if ((0) == (r))
			{
				r = (int)(nKey1 - nKey2);
			}

			return (int)(r);
		}
		public static sqlite3_mutex* noopMutexAlloc(int id)
		{
			return (sqlite3_mutex*)(8);
		}
		public static int noopMutexEnd()
		{
			return (int)(0);
		}
		public static int noopMutexInit()
		{
			return (int)(0);
		}
		public static int openDatabase(sbyte* zFilename, sqlite3 ppDb, uint flags, sbyte* zVfs)
		{
			sqlite3 db;
			int rc = 0;
			int isThreadsafe = 0;
			sbyte* zOpen = null;
			sbyte* zErrMsg = null;
			int i = 0;
			ppDb = null;
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			if ((sqlite3Config.bCoreMutex) == (0))
			{
				isThreadsafe = (int)(0);
			}
			else if ((flags & 0x00008000) != 0)
			{
				isThreadsafe = (int)(0);
			}
			else if ((flags & 0x00010000) != 0)
			{
				isThreadsafe = (int)(1);
			}
			else
			{
				isThreadsafe = (int)(sqlite3Config.bFullMutex);
			}

			if ((flags & 0x00040000) != 0)
			{
				flags &= (uint)(~0x00020000);
			}
			else if ((sqlite3Config.sharedCacheEnabled) != 0)
			{
				flags |= (uint)(0x00020000);
			}

			flags &= (uint)(~(0x00000008 | 0x00000010 | 0x00000100 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00001000 | 0x00002000 | 0x00004000 | 0x00008000 | 0x00010000 | 0x00080000));
			db = sqlite3MallocZero((ulong)(sizeof(sqlite3)));
			if ((db) == (null))
				goto opendb_out;
			if ((isThreadsafe) != 0)
			{
				db.mutex = sqlite3MutexAlloc((int)(1));
				if ((db.mutex) == (null))
				{
					sqlite3_free(db);
					db = null;
					goto opendb_out;
				}

				if ((isThreadsafe) == (0))
				{
				}
			}

			sqlite3_mutex_enter(db.mutex);
			db.errMask = (int)((flags & 0x02000000) != 0 ? 0xffffffff : 0xff);
			db.nDb = (int)(2);
			db.eOpenState = (byte)(0x6d);
			db.aDb = db.aDbStatic;
			db.lookaside.bDisable = (uint)(1);
			db.lookaside.sz = (ushort)(0);
			CRuntime.memcpy(db.aLimit, aHardLimit, (ulong)(12 * sizeof(int)));
			db.aLimit[11] = (int)(0);
			db.autoCommit = (byte)(1);
			db.nextAutovac = (sbyte)(-1);
			db.szMmap = (long)(sqlite3Config.szMmap);
			db.nextPagesize = (int)(0);
			db.init.azInit = sqlite3StdType;
			db.flags |= (ulong)(0x00000040 | 0x00040000 | 0x80000000 | 0x00000020 | 0x00000080 | 0x40000000 | 0x20000000 | 0x00008000);
			sqlite3HashInit(&db.aCollSeq);
			sqlite3HashInit(&db.aModule);
			createCollation(db, sqlite3StrBINARY, (byte)(1), null, binCollFunc, null);
			createCollation(db, sqlite3StrBINARY, (byte)(3), null, binCollFunc, null);
			createCollation(db, sqlite3StrBINARY, (byte)(2), null, binCollFunc, null);
			createCollation(db, "NOCASE", (byte)(1), null, nocaseCollatingFunc, null);
			createCollation(db, "RTRIM", (byte)(1), null, rtrimCollFunc, null);
			if ((db.mallocFailed) != 0)
			{
				goto opendb_out;
			}

			db.openFlags = (uint)(flags);
			if (((1 << (flags & 7)) & 0x46) == (0))
			{
				rc = (int)(sqlite3MisuseError((int)(171858)));
			}
			else
			{
				rc = (int)(sqlite3ParseUri(zVfs, zFilename, &flags, db.pVfs, &zOpen, &zErrMsg));
			}

			if (rc != 0)
			{
				if ((rc) == (7))
					sqlite3OomFault(db);
				sqlite3ErrorWithMsg(db, (int)(rc), (zErrMsg) != 0 ? "%s" : null, zErrMsg);
				sqlite3_free(zErrMsg);
				goto opendb_out;
			}

			rc = (int)(sqlite3BtreeOpen(db.pVfs, zOpen, db, db.aDb[0].pBt, (int)(0), (int)(flags | 0x00000100)));
			if (rc != 0)
			{
				if ((rc) == (10 | (12 << 8)))
				{
					rc = (int)(7);
				}

				sqlite3Error(db, (int)(rc));
				goto opendb_out;
			}

			sqlite3BtreeEnter(db.aDb[0].pBt);
			db.aDb[0].pSchema = sqlite3SchemaGet(db, db.aDb[0].pBt);
			if (db.mallocFailed == 0)
			{
				sqlite3SetTextEncoding(db, (byte)((db).aDb[0].pSchema.enc));
			}

			sqlite3BtreeLeave(db.aDb[0].pBt);
			db.aDb[1].pSchema = sqlite3SchemaGet(db, null);
			db.aDb[0].zDbSName = "main";
			db.aDb[0].safety_level = (byte)(2 + 1);
			db.aDb[1].zDbSName = "temp";
			db.aDb[1].safety_level = (byte)(0x01);
			db.eOpenState = (byte)(0x76);
			if ((db.mallocFailed) != 0)
			{
				goto opendb_out;
			}

			sqlite3Error(db, (int)(0));
			sqlite3RegisterPerConnectionBuiltinFunctions(db);
			rc = (int)(sqlite3_errcode(db));
			for (i = (int)(0); ((rc) == (0)) && ((i) < ((int)(2 * sizeof(Int(sqlite3 * )) / sizeof(Int(sqlite3 * ))))
         ) ; i++ ) { rc = (int)(sqlite3BuiltinExtensions[i](db)); }
			if ((rc) == (0))
			{
				sqlite3AutoLoadExtensions(db);
				rc = (int)(sqlite3_errcode(db));
				if (rc != 0)
				{
					goto opendb_out;
				}
			}

			if ((rc) != 0)
				sqlite3Error(db, (int)(rc));
			setupLookaside(db, null, (int)(sqlite3Config.szLookaside), (int)(sqlite3Config.nLookaside));
			sqlite3_wal_autocheckpoint(db, (int)(1000));
		opendb_out:
			; if ((db) != null) { sqlite3_mutex_leave(db.mutex); }
			rc = (int)(sqlite3_errcode(db));
			if ((rc & 0xff) == (7))
			{
				sqlite3_close(db);
				db = null;
			}
			else if (rc != 0)
			{
				db.eOpenState = (byte)(0xba);
			}

			ppDb = db;
			sqlite3_free_filename(zOpen);
			return (int)(rc);
		}
		public static ushort operatorMask(int op)
		{
			ushort c = 0;
			if ((op) == (49))
			{
				c = (ushort)(0x0001);
			}
			else if ((op) == (50))
			{
				c = (ushort)(0x0100);
			}
			else if ((op) == (45))
			{
				c = (ushort)(0x0080);
			}
			else
			{
				c = ((ushort)(0x0002 << (op - 53)));
			}

			return (ushort)(c);
		}
		public static int osLocaltime(long* t, tm* pTm)
		{
			int rc = 0;
			if ((sqlite3Config.bLocaltimeFault) != 0)
			{
				if (sqlite3Config.xAltLocaltime != null)
				{
					return (int)(sqlite3Config.xAltLocaltime((void*)(t), (void*)(pTm)));
				}
				else
				{
					return (int)(1);
				}
			}

			rc = (int)(localtime_s(pTm, t));
			return (int)(rc);
		}
		public static byte* pageFindSlot(MemPage pPg, int nByte, int* pRc)
		{
			int hdr = (int)(pPg.hdrOffset);
			byte* aData = pPg.aData;
			int iAddr = (int)(hdr + 1);
			int pc = (int)((&aData[iAddr])[0] << 8 | (&aData[iAddr])[1]);
			int x = 0;
			int maxPC = (int)(pPg.pBt.usableSize - nByte);
			int size = 0;
			while ((pc) <= (maxPC))
			{
				size = (int)((&aData[pc + 2])[0] << 8 | (&aData[pc + 2])[1]);
				if ((x = (int)(size - nByte)) >= (0))
				{
					if ((x) < (4))
					{
						if ((aData[hdr + 7]) > (57))
							return null;
						CRuntime.memcpy(&aData[iAddr], &aData[pc], (ulong)(2));
						aData[hdr + 7] += ((byte)(x));
					}
					else if ((x + pc) > (maxPC))
					{
						*pRc = (int)(sqlite3CorruptError((int)(67776)));
						return null;
					}
					else
					{
						((&aData[pc + 2])[0] = ((byte)((x) >> 8)), (&aData[pc + 2])[1] = ((byte)(x)));
					}

					return &aData[pc + x];
				}

				iAddr = (int)(pc);
				pc = (int)((&aData[pc])[0] << 8 | (&aData[pc])[1]);
				if ((pc) <= (iAddr + size))
				{
					if ((pc) != 0)
					{
						*pRc = (int)(sqlite3CorruptError((int)(67790)));
					}

					return null;
				}
			}

			if ((pc) > (maxPC + nByte - 4))
			{
				*pRc = (int)(sqlite3CorruptError((int)(67797)));
			}

			return null;
		}
		public static int pagerStress(void* p, PgHdr pPg)
		{
			Pager pPager = (Pager)(p);
			int rc = (int)(0);
			if ((pPager.errCode) != 0)
				return (int)(0);
			if (((pPager.doNotSpill) != 0) && (((pPager.doNotSpill & (0x02 | 0x01)) != 0) || ((pPg.flags & 0x008) != 0)))
			{
				return (int)(0);
			}

			pPager.aStat[3]++;
			pPg.pDirty = null;
			if (((pPager).pWal != null))
			{
				rc = (int)(subjournalPageIfRequired(pPg));
				if ((rc) == (0))
				{
					rc = (int)(pagerWalFrames(pPager, pPg, (uint)(0), (int)(0)));
				}
			}
			else
			{
				if (((pPg.flags & 0x008) != 0) || ((pPager.eState) == (3)))
				{
					rc = (int)(syncJournal(pPager, (int)(1)));
				}

				if ((rc) == (0))
				{
					rc = (int)(pager_write_pagelist(pPager, pPg));
				}
			}

			if ((rc) == (0))
			{
				sqlite3PcacheMakeClean(pPg);
			}

			return (int)(pager_error(pPager, (int)(rc)));
		}
		public static int pagerUndoCallback(void* pCtx, uint iPg)
		{
			int rc = (int)(0);
			Pager pPager = (Pager)(pCtx);
			PgHdr pPg;
			pPg = sqlite3PagerLookup(pPager, (uint)(iPg));
			if ((pPg) != null)
			{
				if ((sqlite3PcachePageRefcount(pPg)) == (1))
				{
					sqlite3PcacheDrop(pPg);
				}
				else
				{
					rc = (int)(readDbPage(pPg));
					if ((rc) == (0))
					{
						pPager.xReiniter(pPg);
					}

					sqlite3PagerUnrefNotNull(pPg);
				}
			}

			sqlite3BackupRestart(pPager.pBackup);
			return (int)(rc);
		}
		public static int parseHhMmSs(sbyte* zDate, DateTime* p)
		{
			int h = 0; int m = 0; int s = 0;
			double ms = (double)(0.0);
			if (getDigits(zDate, "20c:20e", &h, &m) != 2)
			{
				return (int)(1);
			}

			zDate += 5;
			if ((*zDate) == (58))
			{
				zDate++;
				if (getDigits(zDate, "20e", &s) != 1)
				{
					return (int)(1);
				}

				zDate += 2;
				if (((*zDate) == (46)) && ((sqlite3CtypeMap[(byte)(zDate[1])] & 0x04) != 0))
				{
					double rScale = (double)(1.0);
					zDate++;
					while ((sqlite3CtypeMap[(byte)(*zDate)] & 0x04) != 0)
					{
						ms = (double)(ms * 10.0 + *zDate - 48);
						rScale *= (double)(10.0);
						zDate++;
					}

					ms /= (double)(rScale);
				}
			}
			else
			{
				s = (int)(0);
			}

			p->validJD = (sbyte)(0);
			p->rawS = (sbyte)(0);
			p->validHMS = (sbyte)(1);
			p->h = (int)(h);
			p->m = (int)(m);
			p->s = (double)(s + ms);
			if ((parseTimezone(zDate, p)) != 0)
				return (int)(1);
			p->validTZ = (sbyte)((p->tz != 0) ? 1 : 0);
			return (int)(0);
		}
		public static int parseTimezone(sbyte* zDate, DateTime* p)
		{
			int sgn = (int)(0);
			int nHr = 0; int nMn = 0;
			int c = 0;
			while ((sqlite3CtypeMap[(byte)(*zDate)] & 0x01) != 0)
			{
				zDate++;
			}

			p->tz = (int)(0);
			c = (int)(*zDate);
			if ((c) == (45))
			{
				sgn = (int)(-1);
			}
			else if ((c) == (43))
			{
				sgn = (int)(+1);
			}
			else if (((c) == (90)) || ((c) == (122)))
			{
				zDate++;
				goto zulu_time;
			}
			else
			{
				return (int)(c != 0);
			}

			zDate++;
			if (getDigits(zDate, "20b:20e", &nHr, &nMn) != 2)
			{
				return (int)(1);
			}

			zDate += 5;
			p->tz = (int)(sgn * (nMn + nHr * 60));
		zulu_time:
			; while ((sqlite3CtypeMap[(byte)(*zDate)] & 0x01) != 0) { zDate++; }
			p->tzSet = (sbyte)(1);
			return (int)(*zDate != 0);
		}
		public static int parseYyyyMmDd(sbyte* zDate, DateTime* p)
		{
			int Y = 0; int M = 0; int D = 0; int neg = 0;
			if ((zDate[0]) == (45))
			{
				zDate++;
				neg = (int)(1);
			}
			else
			{
				neg = (int)(0);
			}

			if (getDigits(zDate, "40f-21a-21d", &Y, &M, &D) != 3)
			{
				return (int)(1);
			}

			zDate += 10;
			while (((sqlite3CtypeMap[(byte)(*zDate)] & 0x01) != 0) || ((84) == (*(byte*)(zDate))))
			{
				zDate++;
			}

			if ((parseHhMmSs(zDate, p)) == (0))
			{
			}
			else if ((*zDate) == (0))
			{
				p->validHMS = (sbyte)(0);
			}
			else
			{
				return (int)(1);
			}

			p->validJD = (sbyte)(0);
			p->validYMD = (sbyte)(1);
			p->Y = (int)((neg) != 0 ? -Y : Y);
			p->M = (int)(M);
			p->D = (int)(D);
			if ((p->validTZ) != 0)
			{
				computeJD(p);
			}

			return (int)(0);
		}
		public static int patternCompare(byte* zPattern, byte* zString, compareInfo* pInfo, uint matchOther)
		{
			uint c = 0; uint c2 = 0;
			uint matchOne = (uint)(pInfo->matchOne);
			uint matchAll = (uint)(pInfo->matchAll);
			byte noCase = (byte)(pInfo->noCase);
			byte* zEscaped = null;
			while ((c = (uint)((zPattern[0]) < (0x80) ? *(zPattern++) : sqlite3Utf8Read(&zPattern))) != 0)
			{
				if ((c) == (matchAll))
				{
					while (((c = (uint)((zPattern[0]) < (0x80) ? *(zPattern++) : sqlite3Utf8Read(&zPattern))) == (matchAll)) || (((c) == (matchOne)) && (matchOne != 0)))
					{
						if (((c) == (matchOne)) && ((sqlite3Utf8Read(&zString)) == (0)))
						{
							return (int)(2);
						}
					}

					if ((c) == (0))
					{
						return (int)(0);
					}
					else if ((c) == (matchOther))
					{
						if ((pInfo->matchSet) == (0))
						{
							c = (uint)(sqlite3Utf8Read(&zPattern));
							if ((c) == (0))
								return (int)(2);
						}
						else
						{
							while ((*zString) != 0)
							{
								int bMatch = (int)(patternCompare(&zPattern[-1], zString, pInfo, (uint)(matchOther)));
								if (bMatch != 1)
									return (int)(bMatch);
								{
									if ((*(zString++)) >= (0xc0))
									{
										while ((*zString & 0xc0) == (0x80))
										{
											zString++;
										}
									}
								}
							}

							return (int)(2);
						}
					}

					if ((c) <= (0x80))
					{
						sbyte* zStop = stackalloc sbyte[3];
						int bMatch = 0;
						if ((noCase) != 0)
						{
							zStop[0] = (sbyte)((c) & ~(sqlite3CtypeMap[(byte)(c)] & 0x20));
							zStop[1] = (sbyte)(sqlite3UpperToLower[(byte)(c)]);
							zStop[2] = (sbyte)(0);
						}
						else
						{
							zStop[0] = (sbyte)(c);
							zStop[1] = (sbyte)(0);
						}

						while ((1) != 0)
						{
							zString += strcspn((sbyte*)(zString), zStop);
							if ((zString[0]) == (0))
								break;
							zString++;
							bMatch = (int)(patternCompare(zPattern, zString, pInfo, (uint)(matchOther)));
							if (bMatch != 1)
								return (int)(bMatch);
						}
					}
					else
					{
						int bMatch = 0;
						while ((c2 = (uint)((zString[0]) < (0x80) ? *(zString++) : sqlite3Utf8Read(&zString))) != 0)
						{
							if (c2 != c)
								continue;
							bMatch = (int)(patternCompare(zPattern, zString, pInfo, (uint)(matchOther)));
							if (bMatch != 1)
								return (int)(bMatch);
						}
					}

					return (int)(2);
				}

				if ((c) == (matchOther))
				{
					if ((pInfo->matchSet) == (0))
					{
						c = (uint)(sqlite3Utf8Read(&zPattern));
						if ((c) == (0))
							return (int)(1);
						zEscaped = zPattern;
					}
					else
					{
						uint prior_c = (uint)(0);
						int seen = (int)(0);
						int invert = (int)(0);
						c = (uint)(sqlite3Utf8Read(&zString));
						if ((c) == (0))
							return (int)(1);
						c2 = (uint)(sqlite3Utf8Read(&zPattern));
						if ((c2) == (94))
						{
							invert = (int)(1);
							c2 = (uint)(sqlite3Utf8Read(&zPattern));
						}

						if ((c2) == (93))
						{
							if ((c) == (93))
								seen = (int)(1);
							c2 = (uint)(sqlite3Utf8Read(&zPattern));
						}

						while (((c2) != 0) && (c2 != 93))
						{
							if (((((c2) == (45)) && (zPattern[0] != 93)) && (zPattern[0] != 0)) && ((prior_c) > (0)))
							{
								c2 = (uint)(sqlite3Utf8Read(&zPattern));
								if (((c) >= (prior_c)) && ((c) <= (c2)))
									seen = (int)(1);
								prior_c = (uint)(0);
							}
							else
							{
								if ((c) == (c2))
								{
									seen = (int)(1);
								}

								prior_c = (uint)(c2);
							}

							c2 = (uint)(sqlite3Utf8Read(&zPattern));
						}

						if (((c2) == (0)) || ((seen ^ invert) == (0)))
						{
							return (int)(1);
						}

						continue;
					}
				}

				c2 = (uint)((zString[0]) < (0x80) ? *(zString++) : sqlite3Utf8Read(&zString));
				if ((c) == (c2))
					continue;
				if (((((noCase) != 0) && ((sqlite3UpperToLower[(byte)(c)]) == (sqlite3UpperToLower[(byte)(c2)]))) && ((c) < (0x80))) && ((c2) < (0x80)))
				{
					continue;
				}

				if ((((c) == (matchOne)) && (zPattern != zEscaped)) && (c2 != 0))
					continue;
				return (int)(1);
			}

			return (int)((*zString) == (0) ? 0 : 1);
		}
		public static void* pcache1Alloc(int nByte)
		{
			void* p = null;
			if ((nByte) <= ((pcache1_g).szSlot))
			{
				sqlite3_mutex_enter((pcache1_g).mutex);
				p = (PgHdr1*)((pcache1_g).pFree);
				if ((p) != null)
				{
					(pcache1_g).pFree = (pcache1_g).pFree->pNext;
					(pcache1_g).nFreeSlot--;
					(pcache1_g).bUnderPressure = (int)(((pcache1_g).nFreeSlot) < ((pcache1_g).nReserve) ? 1 : 0);
					sqlite3StatusHighwater((int)(7), (int)(nByte));
					sqlite3StatusUp((int)(1), (int)(1));
				}

				sqlite3_mutex_leave((pcache1_g).mutex);
			}

			if ((p) == (null))
			{
				p = sqlite3Malloc((ulong)(nByte));
				if ((p) != null)
				{
					int sz = (int)(sqlite3MallocSize(p));
					sqlite3_mutex_enter((pcache1_g).mutex);
					sqlite3StatusHighwater((int)(7), (int)(nByte));
					sqlite3StatusUp((int)(2), (int)(sz));
					sqlite3_mutex_leave((pcache1_g).mutex);
				}
			}

			return p;
		}
		public static PgHdr1* pcache1AllocPage(PCache1* pCache, int benignMalloc)
		{
			PgHdr1* p = null;
			void* pPg;
			if (((pCache->pFree) != null) || (((pCache->nPage) == (0)) && ((pcache1InitBulk(pCache)) != 0)))
			{
				p = pCache->pFree;
				pCache->pFree = p->pNext;
				p->pNext = null;
			}
			else
			{
				if ((benignMalloc) != 0)
				{
					sqlite3BeginBenignMalloc();
				}

				pPg = pcache1Alloc((int)(pCache->szAlloc));
				if ((benignMalloc) != 0)
				{
					sqlite3EndBenignMalloc();
				}

				if ((pPg) == (null))
					return null;
				p = (PgHdr1*)(&((byte*)(pPg))[pCache->szPage]);
				p->page.pBuf = pPg;
				p->page.pExtra = &p[1];
				p->isBulkLocal = (ushort)(0);
				p->isAnchor = (ushort)(0);
				p->pLruPrev = null;
			}

			(*pCache->pnPurgeable)++;
			return p;
		}
		public static sqlite3_pcache* pcache1Create(int szPage, int szExtra, int bPurgeable)
		{
			PCache1* pCache;
			PGroup* pGroup;
			int sz = 0;
			sz = (int)(sizeof(PCache1) + sizeof(PGroup) * (pcache1_g).separateCache);
			pCache = (PCache1*)(sqlite3MallocZero((ulong)(sz)));
			if ((pCache) != null)
			{
				if (((pcache1_g).separateCache) != 0)
				{
					pGroup = (PGroup*)(&pCache[1]);
					pGroup->mxPinned = (uint)(10);
				}
				else
				{
					pGroup = &(pcache1_g).grp;
				}

				if ((pGroup->lru.isAnchor) == (0))
				{
					pGroup->lru.isAnchor = (ushort)(1);
					pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
				}

				pCache->pGroup = pGroup;
				pCache->szPage = (int)(szPage);
				pCache->szExtra = (int)(szExtra);
				pCache->szAlloc = (int)(szPage + szExtra + (((sizeof(PgHdr1)) + 7) & ~7));
				pCache->bPurgeable = (int)((bPurgeable) != 0 ? 1 : 0);
				pcache1ResizeHash(pCache);
				if ((bPurgeable) != 0)
				{
					pCache->nMin = (uint)(10);
					pGroup->nMinPage += (uint)(pCache->nMin);
					pGroup->mxPinned = (uint)(pGroup->nMaxPage + 10 - pGroup->nMinPage);
					pCache->pnPurgeable = &pGroup->nPurgeable;
				}
				else
				{
					pCache->pnPurgeable = &pCache->nPurgeableDummy;
				}

				if ((pCache->nHash) == (0))
				{
					pcache1Destroy((sqlite3_pcache*)(pCache));
					pCache = null;
				}
			}

			return (sqlite3_pcache*)(pCache);
		}
		public static sqlite3_pcache_page* pcache1Fetch(sqlite3_pcache* p, uint iKey, int createFlag)
		{
			{
				return (sqlite3_pcache_page*)(pcache1FetchNoMutex(p, (uint)(iKey), (int)(createFlag)));
			}
		}
		public static PgHdr1* pcache1FetchNoMutex(sqlite3_pcache* p, uint iKey, int createFlag)
		{
			PCache1* pCache = (PCache1*)(p);
			PgHdr1* pPage = null;
			pPage = pCache->apHash[iKey % pCache->nHash];
			while (((pPage) != null) && (pPage->iKey != iKey))
			{
				pPage = pPage->pNext;
			}

			if ((pPage) != null)
			{
				if (((pPage)->pLruNext != null))
				{
					return pcache1PinPage(pPage);
				}
				else
				{
					return pPage;
				}
			}
			else if ((createFlag) != 0)
			{
				return pcache1FetchStage2(pCache, (uint)(iKey), (int)(createFlag));
			}
			else
			{
				return null;
			}
		}
		public static PgHdr1* pcache1FetchStage2(PCache1* pCache, uint iKey, int createFlag)
		{
			uint nPinned = 0;
			PGroup* pGroup = pCache->pGroup;
			PgHdr1* pPage = null;
			nPinned = (uint)(pCache->nPage - pCache->nRecyclable);
			if (((createFlag) == (1)) && ((((nPinned) >= (pGroup->mxPinned)) || ((nPinned) >= (pCache->n90pct))) || (((pcache1UnderMemoryPressure(pCache)) != 0) && ((pCache->nRecyclable) < (nPinned)))))
			{
				return null;
			}

			if ((pCache->nPage) >= (pCache->nHash))
				pcache1ResizeHash(pCache);
			if ((((pCache->bPurgeable) != 0) && (pGroup->lru.pLruPrev->isAnchor == 0)) && (((pCache->nPage + 1) >= (pCache->nMax)) || ((pcache1UnderMemoryPressure(pCache)) != 0)))
			{
				PCache1* pOther;
				pPage = pGroup->lru.pLruPrev;
				pcache1RemoveFromHash(pPage, (int)(0));
				pcache1PinPage(pPage);
				pOther = pPage->pCache;
				if (pOther->szAlloc != pCache->szAlloc)
				{
					pcache1FreePage(pPage);
					pPage = null;
				}
				else
				{
					pGroup->nPurgeable -= (uint)(pOther->bPurgeable - pCache->bPurgeable);
				}
			}

			if (pPage == null)
			{
				pPage = pcache1AllocPage(pCache, ((createFlag) == (1) ? 1 : 0));
			}

			if ((pPage) != null)
			{
				uint h = (uint)(iKey % pCache->nHash);
				pCache->nPage++;
				pPage->iKey = (uint)(iKey);
				pPage->pNext = pCache->apHash[h];
				pPage->pCache = pCache;
				pPage->pLruNext = null;
				*(void**)(pPage->page.pExtra) = null;
				pCache->apHash[h] = pPage;
				if ((iKey) > (pCache->iMaxKey))
				{
					pCache->iMaxKey = (uint)(iKey);
				}
			}

			return pPage;
		}
		public static void pcache1Free(void* p)
		{
			if ((p) == (null))
				return;
			if (((((ulong)(p)) >= ((ulong)((pcache1_g).pStart))) && (((ulong)(p)) < ((ulong)((pcache1_g).pEnd)))))
			{
				PgFreeslot* pSlot;
				sqlite3_mutex_enter((pcache1_g).mutex);
				sqlite3StatusDown((int)(1), (int)(1));
				pSlot = (PgFreeslot*)(p);
				pSlot->pNext = (pcache1_g).pFree;
				(pcache1_g).pFree = pSlot;
				(pcache1_g).nFreeSlot++;
				(pcache1_g).bUnderPressure = (int)(((pcache1_g).nFreeSlot) < ((pcache1_g).nReserve) ? 1 : 0);
				sqlite3_mutex_leave((pcache1_g).mutex);
			}
			else
			{
				{
					int nFreed = (int)(0);
					nFreed = (int)(sqlite3MallocSize(p));
					sqlite3_mutex_enter((pcache1_g).mutex);
					sqlite3StatusDown((int)(2), (int)(nFreed));
					sqlite3_mutex_leave((pcache1_g).mutex);
				}

				sqlite3_free(p);
			}
		}
		public static int pcache1Init(void* NotUsed)
		{
			CRuntime.memset(&(pcache1_g), (int)(0), (ulong)(sizeof(PCacheGlobal)));
			(pcache1_g).separateCache = (int)(((sqlite3Config.pPage) == (null)) || ((sqlite3Config.bCoreMutex) > (0)) ? 1 : 0);
			if ((sqlite3Config.bCoreMutex) != 0)
			{
				(pcache1_g).grp.mutex = sqlite3MutexAlloc((int)(6));
				(pcache1_g).mutex = sqlite3MutexAlloc((int)(7));
			}

			if (((((pcache1_g).separateCache) != 0) && (sqlite3Config.nPage != 0)) && ((sqlite3Config.pPage) == (null)))
			{
				(pcache1_g).nInitPage = (int)(sqlite3Config.nPage);
			}
			else
			{
				(pcache1_g).nInitPage = (int)(0);
			}

			(pcache1_g).grp.mxPinned = (uint)(10);
			(pcache1_g).isInit = (int)(1);
			return (int)(0);
		}
		public static PgHdr1* pcache1PinPage(PgHdr1* pPage)
		{
			pPage->pLruPrev->pLruNext = pPage->pLruNext;
			pPage->pLruNext->pLruPrev = pPage->pLruPrev;
			pPage->pLruNext = null;
			pPage->pCache->nRecyclable--;
			return pPage;
		}
		public static void pcache1Shutdown(void* NotUsed)
		{
			CRuntime.memset(&(pcache1_g), (int)(0), (ulong)(sizeof(PCacheGlobal)));
		}
		public static PragmaName* pragmaLocate(sbyte* zName)
		{
			int upr = 0; int lwr = 0; int mid = (int)(0); int rc = 0;
			lwr = (int)(0);
			upr = (int)(((int)(67 * sizeof(PragmaName) / sizeof(PragmaName))) - 1);
			while ((lwr) <= (upr))
			{
				mid = (int)((lwr + upr) / 2);
				rc = (int)(sqlite3_stricmp(zName, aPragmaName[mid].zName));
				if ((rc) == (0))
					break;
				if ((rc) < (0))
				{
					upr = (int)(mid - 1);
				}
				else
				{
					lwr = (int)(mid + 1);
				}
			}

			return (lwr) > (upr) ? null : &aPragmaName[mid];
		}
		public static sbyte* printfTempBuf(sqlite3_str pAccum, long n)
		{
			sbyte* z;
			if ((pAccum.accError) != 0)
				return null;
			if (((n) > (pAccum.nAlloc)) && ((n) > (pAccum.mxAlloc)))
			{
				sqlite3StrAccumSetError(pAccum, (byte)(18));
				return null;
			}

			z = sqlite3DbMallocRaw(pAccum.db, (ulong)(n));
			if ((z) == (null))
			{
				sqlite3StrAccumSetError(pAccum, (byte)(7));
			}

			return z;
		}
		public static int putVarint64(byte* p, ulong v)
		{
			int i = 0; int j = 0; int n = 0;
			byte* buf = stackalloc byte[10];
			if ((v & (((ulong)(0xff000000)) << 32)) != 0)
			{
				p[8] = ((byte)(v));
				v >>= 8;
				for (i = (int)(7); (i) >= (0); i--)
				{
					p[i] = ((byte)((v & 0x7f) | 0x80));
					v >>= 7;
				}

				return (int)(9);
			}

			n = (int)(0);
			do
			{
				buf[n++] = ((byte)((v & 0x7f) | 0x80));
				v >>= 7;
			}
			while (v != 0);
			buf[0] &= (byte)(0x7f);
			for (i = (int)(0), j = (int)(n - 1); (j) >= (0); j--, i++)
			{
				p[i] = (byte)(buf[j]);
			}

			return (int)(n);
		}
		public static RenameToken* renameColumnTokenNext(RenameCtx pCtx)
		{
			RenameToken* pBest = pCtx.pList;
			RenameToken* pToken;
			RenameToken** pp;
			for (pToken = pBest->pNext; pToken; pToken = pToken->pNext)
			{
				if ((pToken->t.z) > (pBest->t.z))
					pBest = pToken;
			}

			for (pp = &pCtx.pList; *pp != pBest; pp = &(*pp)->pNext)
			{
			}

			*pp = pBest->pNext;
			return pBest;
		}
		public static RenameToken* renameTokenFind(Parse pParse, RenameCtx pCtx, void* pPtr)
		{
			RenameToken** pp;
			if (((pPtr) == (null)))
			{
				return null;
			}

			for (pp = &pParse.pRename; (*pp); pp = &(*pp)->pNext)
			{
				if (((*pp)->p) == (pPtr))
				{
					RenameToken* pToken = *pp;
					if ((pCtx) != null)
					{
						*pp = pToken->pNext;
						pToken->pNext = pCtx.pList;
						pCtx.pList = pToken;
						pCtx.nList++;
					}

					return pToken;
				}
			}

			return null;
		}
		public static void renderLogMsg(int iErrCode, sbyte* zFormat, sbyte* ap)
		{
			sqlite3_str acc = new sqlite3_str();
			sbyte* zMsg = stackalloc sbyte[210];
			sqlite3StrAccumInit(acc, null, zMsg, (int)(210 * sizeof(sbyte)), (int)(0));
			sqlite3_str_vappendf(acc, zFormat, ap);
			sqlite3Config.xLog(sqlite3Config.pLogArg, (int)(iErrCode), sqlite3StrAccumFinish(acc));
		}
		public static RowSetEntry* rowSetEntryAlloc(RowSet p)
		{
			if ((p.nFresh) == (0))
			{
				RowSetChunk pNew;
				pNew = sqlite3DbMallocRawNN(p.db, (ulong)(sizeof(RowSetChunk)));
				if ((pNew) == (null))
				{
					return null;
				}

				pNew.pNextChunk = p.pChunk;
				p.pChunk = pNew;
				p.pFresh = pNew.aEntry;
				p.nFresh = (ushort)((1024 - 8) / sizeof(RowSetEntry));
			}

			p.nFresh--;
			return p.pFresh++;
		}
		public static RowSetEntry* rowSetEntryMerge(RowSetEntry* pA, RowSetEntry* pB)
		{
			RowSetEntry head = new RowSetEntry();
			RowSetEntry* pTail;
			pTail = &head;
			for (; ; )
			{
				if ((pA->v) <= (pB->v))
				{
					if ((pA->v) < (pB->v))
						pTail = pTail->pRight = pA;
					pA = pA->pRight;
					if ((pA) == (null))
					{
						pTail->pRight = pB;
						break;
					}
				}
				else
				{
					pTail = pTail->pRight = pB;
					pB = pB->pRight;
					if ((pB) == (null))
					{
						pTail->pRight = pA;
						break;
					}
				}
			}

			return head.pRight;
		}
		public static RowSetEntry* rowSetEntrySort(RowSetEntry* pIn)
		{
			uint i = 0;
			RowSetEntry* pNext; RowSetEntry** aBucket = stackalloc RowSetEntry[40];
			CRuntime.memset(aBucket, (int)(0), (ulong)(40 * sizeof(RowSetEntry)));
			while ((pIn) != null)
			{
				pNext = pIn->pRight;
				pIn->pRight = null;
				for (i = (uint)(0); aBucket[i]; i++)
				{
					pIn = rowSetEntryMerge(aBucket[i], pIn);
					aBucket[i] = null;
				}

				aBucket[i] = pIn;
				pIn = pNext;
			}

			pIn = aBucket[0];
			for (i = (uint)(1); (i) < (40 * sizeof(RowSetEntry) / sizeof(RowSetEntry*)); i++)
			{
				if ((aBucket[i]) == (null))
					continue;
				pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];
			}

			return pIn;
		}
		public static RowSetEntry* rowSetListToTree(RowSetEntry* pList)
		{
			int iDepth = 0;
			RowSetEntry* p;
			RowSetEntry* pLeft;
			p = pList;
			pList = p->pRight;
			p->pLeft = p->pRight = null;
			for (iDepth = (int)(1); pList; iDepth++)
			{
				pLeft = p;
				p = pList;
				pList = p->pRight;
				p->pLeft = pLeft;
				p->pRight = rowSetNDeepTree(&pList, (int)(iDepth));
			}

			return p;
		}
		public static RowSetEntry* rowSetNDeepTree(RowSetEntry** ppList, int iDepth)
		{
			RowSetEntry* p;
			RowSetEntry* pLeft;
			if ((*ppList) == (null))
			{
				return null;
			}

			if ((iDepth) > (1))
			{
				pLeft = rowSetNDeepTree(ppList, (int)(iDepth - 1));
				p = *ppList;
				if ((p) == (null))
				{
					return pLeft;
				}

				p->pLeft = pLeft;
				*ppList = p->pRight;
				p->pRight = rowSetNDeepTree(ppList, (int)(iDepth - 1));
			}
			else
			{
				p = *ppList;
				*ppList = p->pRight;
				p->pLeft = p->pRight = null;
			}

			return p;
		}
		public static int rtrimCollFunc(void* pUser, int nKey1, void* pKey1, int nKey2, void* pKey2)
		{
			byte* pK1 = (byte*)(pKey1);
			byte* pK2 = (byte*)(pKey2);
			while (((nKey1) != 0) && ((pK1[nKey1 - 1]) == (32)))
			{
				nKey1--;
			}

			while (((nKey2) != 0) && ((pK2[nKey2 - 1]) == (32)))
			{
				nKey2--;
			}

			return (int)(binCollFunc(pUser, (int)(nKey1), pKey1, (int)(nKey2), pKey2));
		}
		public static void serialGet(byte* buf, uint serial_type, sqlite3_value pMem)
		{
			ulong x = (ulong)(((uint)((buf)[0]) << 24) | ((buf)[1] << 16) | ((buf)[2] << 8) | (buf)[3]);
			uint y = (uint)(((uint)((buf + 4)[0]) << 24) | ((buf + 4)[1] << 16) | ((buf + 4)[2] << 8) | (buf + 4)[3]);
			x = (ulong)((x << 32) + y);
			if ((serial_type) == (6))
			{
				pMem.u.i = (long)(*(long*)(&x));
				pMem.flags = (ushort)(0x0004);
			}
			else
			{
				CRuntime.memcpy(&pMem.u.r, &x, (ulong)(sizeof(ulong)));
				pMem.flags = (ushort)(((((x) & (((ulong)(0x7ff)) << 52)) == (((ulong)(0x7ff)) << 52)) && (((x) & ((((ulong)(1)) << 52) - 1)) != 0)) ? 0x0001 : 0x0008);
			}
		}
		public static void* sqlite3_aggregate_context(sqlite3_context p, int nByte)
		{
			if ((p.pMem.flags & 0x2000) == (0))
			{
				return createAggContext(p, (int)(nByte));
			}
			else
			{
				return (void*)(p.pMem.z);
			}
		}
		public static sbyte* sqlite3_bind_parameter_name(sqlite3_stmt* pStmt, int i)
		{
			Vdbe p = (Vdbe)(pStmt);
			if ((p) == (null))
				return null;
			return sqlite3VListNumToName(p.pVList, (int)(i));
		}
		public static void* sqlite3_column_blob(sqlite3_stmt* pStmt, int i)
		{
			void* val;
			val = sqlite3_value_blob(columnMem(pStmt, (int)(i)));
			columnMallocFailure(pStmt);
			return val;
		}
		public static sbyte* sqlite3_column_decltype(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(0), (int)(1));
		}
		public static void* sqlite3_column_decltype16(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(1), (int)(1));
		}
		public static sbyte* sqlite3_column_name(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(0), (int)(0));
		}
		public static void* sqlite3_column_name16(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(1), (int)(0));
		}
		public static byte* sqlite3_column_text(sqlite3_stmt* pStmt, int i)
		{
			byte* val = sqlite3_value_text(columnMem(pStmt, (int)(i)));
			columnMallocFailure(pStmt);
			return val;
		}
		public static void* sqlite3_column_text16(sqlite3_stmt* pStmt, int i)
		{
			void* val = sqlite3_value_text16(columnMem(pStmt, (int)(i)));
			columnMallocFailure(pStmt);
			return val;
		}
		public static void* sqlite3_commit_hook(sqlite3 db, delegate19 xCallback, void* pArg)
		{
			void* pOld;
			sqlite3_mutex_enter(db.mutex);
			pOld = db.pCommitArg;
			db.xCommitCallback = xCallback;
			db.pCommitArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pOld;
		}
		public static sbyte* sqlite3_compileoption_get(int N)
		{
			int nOpt = 0;
			sbyte** azCompileOpt;
			azCompileOpt = sqlite3CompileOptions(&nOpt);
			if (((N) >= (0)) && ((N) < (nOpt)))
			{
				return azCompileOpt[N];
			}

			return null;
		}
		public static int sqlite3_compileoption_used(sbyte* zOptName)
		{
			int i = 0; int n = 0;
			int nOpt = 0;
			sbyte** azCompileOpt;
			azCompileOpt = sqlite3CompileOptions(&nOpt);
			if ((sqlite3_strnicmp(zOptName, "SQLITE_", (int)(7))) == (0))
				zOptName += 7;
			n = (int)(sqlite3Strlen30(zOptName));
			for (i = (int)(0); (i) < (nOpt); i++)
			{
				if (((sqlite3_strnicmp(zOptName, azCompileOpt[i], (int)(n))) == (0)) && ((sqlite3IsIdChar((byte)(azCompileOpt[i][n]))) == (0)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int sqlite3_complete(sbyte* zSql)
		{
			byte state = (byte)(0);
			byte token = 0;
			while ((*zSql) != 0)
			{
				switch (*zSql)
				{
					case 59:
						{
							token = (byte)(0);
							break;
						}

					case 32:
					case 13:
					case 9:
					case 10:
					case 12:
						{
							token = (byte)(1);
							break;
						}

					case 47:
						{
							if (zSql[1] != 42)
							{
								token = (byte)(2);
								break;
							}

							zSql += 2;
							while (((zSql[0]) != 0) && ((zSql[0] != 42) || (zSql[1] != 47)))
							{
								zSql++;
							}

							if ((zSql[0]) == (0))
								return (int)(0);
							zSql++;
							token = (byte)(1);
							break;
						}

					case 45:
						{
							if (zSql[1] != 45)
							{
								token = (byte)(2);
								break;
							}

							while (((*zSql) != 0) && (*zSql != 10))
							{
								zSql++;
							}

							if ((*zSql) == (0))
								return ((state) == (1) ? 1 : 0);
							token = (byte)(1);
							break;
						}

					case 91:
						{
							zSql++;
							while (((*zSql) != 0) && (*zSql != 93))
							{
								zSql++;
							}

							if ((*zSql) == (0))
								return (int)(0);
							token = (byte)(2);
							break;
						}

					case 96:
					case 34:
					case 39:
						{
							int c = (int)(*zSql);
							zSql++;
							while (((*zSql) != 0) && (*zSql != c))
							{
								zSql++;
							}

							if ((*zSql) == (0))
								return (int)(0);
							token = (byte)(2);
							break;
						}

					default:
						{
							if (((sqlite3CtypeMap[(byte)(*zSql)] & 0x46) != 0))
							{
								int nId = 0;
								for (nId = (int)(1); ((sqlite3CtypeMap[(byte)(zSql[nId])] & 0x46) != 0); nId++)
								{
								}

								switch (*zSql)
								{
									case 99:
									case 67:
										{
											if (((nId) == (6)) && ((sqlite3_strnicmp(zSql, "create", (int)(6))) == (0)))
											{
												token = (byte)(4);
											}
											else
											{
												token = (byte)(2);
											}

											break;
										}

									case 116:
									case 84:
										{
											if (((nId) == (7)) && ((sqlite3_strnicmp(zSql, "trigger", (int)(7))) == (0)))
											{
												token = (byte)(6);
											}
											else if (((nId) == (4)) && ((sqlite3_strnicmp(zSql, "temp", (int)(4))) == (0)))
											{
												token = (byte)(5);
											}
											else if (((nId) == (9)) && ((sqlite3_strnicmp(zSql, "temporary", (int)(9))) == (0)))
											{
												token = (byte)(5);
											}
											else
											{
												token = (byte)(2);
											}

											break;
										}

									case 101:
									case 69:
										{
											if (((nId) == (3)) && ((sqlite3_strnicmp(zSql, "end", (int)(3))) == (0)))
											{
												token = (byte)(7);
											}
											else if (((nId) == (7)) && ((sqlite3_strnicmp(zSql, "explain", (int)(7))) == (0)))
											{
												token = (byte)(3);
											}
											else
											{
												token = (byte)(2);
											}

											break;
										}

									default:
										{
											token = (byte)(2);
											break;
										}
								}

								zSql += nId - 1;
							}
							else
							{
								token = (byte)(2);
							}

							break;
						}
				}

				state = (byte)(sqlite3_complete_trans[state][token]);
				zSql++;
			}

			return ((state) == (1) ? 1 : 0);
		}
		public static int sqlite3_complete16(void* zSql)
		{
			sqlite3_value pVal;
			sbyte* zSql8;
			int rc = 0;
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			pVal = sqlite3ValueNew(null);
			sqlite3ValueSetStr(pVal, (int)(-1), zSql, (byte)(2), null);
			zSql8 = sqlite3ValueText(pVal, (byte)(1));
			if ((zSql8) != null)
			{
				rc = (int)(sqlite3_complete(zSql8));
			}
			else
			{
				rc = (int)(7);
			}

			sqlite3ValueFree(pVal);
			return (int)(rc & 0xff);
		}
		public static int sqlite3_config(int op)
		{
			sbyte* ap;
			int rc = (int)(0);
			if ((sqlite3Config.isInit) != 0)
				return (int)(sqlite3MisuseError((int)(168919)));
			(__va_start(&ap, (int)(op)));
			switch (op)
			{
				case 1:
					{
						sqlite3Config.bCoreMutex = (byte)(0);
						sqlite3Config.bFullMutex = (byte)(0);
						break;
					}

				case 2:
					{
						sqlite3Config.bCoreMutex = (byte)(1);
						sqlite3Config.bFullMutex = (byte)(0);
						break;
					}

				case 3:
					{
						sqlite3Config.bCoreMutex = (byte)(1);
						sqlite3Config.bFullMutex = (byte)(1);
						break;
					}

				case 10:
					{
						sqlite3Config.mutex = (sqlite3_mutex_methods)((((sizeof(sqlite3_mutex_methods)) > ()) || ((sizeof(sqlite3_mutex_methods) & (sizeof(sqlite3_mutex_methods) - 1)) != 0)) ? (sqlite3_mutex_methods)((ap += ) - ) : (sqlite3_mutex_methods)((ap += ) - ));
						break;
					}

				case 11:
					{
						((((sizeof(sqlite3_mutex_methods)) > ()) || ((sizeof(sqlite3_mutex_methods) & (sizeof(sqlite3_mutex_methods) - 1)) != 0)) ? (sqlite3_mutex_methods)((ap += ) - ) : (sqlite3_mutex_methods)((ap += ) - )) = (sqlite3_mutex_methods)(sqlite3Config.mutex);
						break;
					}

				case 4:
					{
						sqlite3Config.m = (sqlite3_mem_methods)((((sizeof(sqlite3_mem_methods)) > ()) || ((sizeof(sqlite3_mem_methods) & (sizeof(sqlite3_mem_methods) - 1)) != 0)) ? (sqlite3_mem_methods)((ap += ) - ) : (sqlite3_mem_methods)((ap += ) - ));
						break;
					}

				case 5:
					{
						if ((sqlite3Config.m.xMalloc) == (null))
							sqlite3MemSetDefault();
						((((sizeof(sqlite3_mem_methods)) > ()) || ((sizeof(sqlite3_mem_methods) & (sizeof(sqlite3_mem_methods) - 1)) != 0)) ? (sqlite3_mem_methods)((ap += ) - ) : (sqlite3_mem_methods)((ap += ) - )) = (sqlite3_mem_methods)(sqlite3Config.m);
						break;
					}

				case 9:
					{
						sqlite3Config.bMemstat = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 27:
					{
						sqlite3Config.bSmallMalloc = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 7:
					{
						sqlite3Config.pPage = (((() > ()) || ((&(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
						sqlite3Config.szPage = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						sqlite3Config.nPage = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 24:
					{
						*(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(sqlite3HeaderSizeBtree() + sqlite3HeaderSizePcache() + sqlite3HeaderSizePcache1());
						break;
					}

				case 14:
					{
						break;
					}

				case 15:
					{
						rc = (int)(1);
						break;
					}

				case 18:
					{
						sqlite3Config.pcache2 = (sqlite3_pcache_methods2)((((sizeof(sqlite3_pcache_methods2)) > ()) || ((sizeof(sqlite3_pcache_methods2) & (sizeof(sqlite3_pcache_methods2) - 1)) != 0)) ? (sqlite3_pcache_methods2)((ap += ) - ) : (sqlite3_pcache_methods2)((ap += ) - ));
						break;
					}

				case 19:
					{
						if ((sqlite3Config.pcache2.xInit) == (null))
						{
							sqlite3PCacheSetDefault();
						}

					((((sizeof(sqlite3_pcache_methods2)) > ()) || ((sizeof(sqlite3_pcache_methods2) & (sizeof(sqlite3_pcache_methods2) - 1)) != 0)) ? (sqlite3_pcache_methods2)((ap += ) - ) : (sqlite3_pcache_methods2)((ap += ) - )) = (sqlite3_pcache_methods2)(sqlite3Config.pcache2);
						break;
					}

				case 13:
					{
						sqlite3Config.szLookaside = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						sqlite3Config.nLookaside = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 16:
					{
						sqlite3Config.xLog = ((((sizeof(Void(Void * , Void * , Void * ))) > ()) || ((sizeof(Void(Void * , Void * , Void * )) & (sizeof(Void(Void * , Void * , Void * )) - 1)) != 0 ) ) ?
            **(Void(Void * , Void * , Void * ))((ap += ) - ) : 
            *(Void(Void * , Void * , Void * ))((ap += ) - ) )
            ;
						sqlite3Config.pLogArg = (((() > ()) || ((&(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
						break;
					}

				case 17:
					{
						sqlite3Config.bOpenUri = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 20:
					{
						sqlite3Config.bUseCis = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 22:
					{
						long szMmap = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
						long mxMmap = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
						if (((mxMmap) < (0)) || ((mxMmap) > (0x7fff0000)))
						{
							mxMmap = (long)(0x7fff0000);
						}

						if ((szMmap) < (0))
							szMmap = (long)(0);
						if ((szMmap) > (mxMmap))
							szMmap = (long)(mxMmap);
						sqlite3Config.mxMmap = (long)(mxMmap);
						sqlite3Config.szMmap = (long)(szMmap);
						break;
					}

				case 25:
					{
						sqlite3Config.szPma = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
						break;
					}

				case 26:
					{
						sqlite3Config.nStmtSpill = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 29:
					{
						sqlite3Config.mxMemdbSize = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
						break;
					}

				default:
					{
						rc = (int)(1);
						break;
					}
			}

			((void)(ap = null));
			return (int)(rc);
		}
		public static sbyte* sqlite3_create_filename(sbyte* zDatabase, sbyte* zJournal, sbyte* zWal, int nParam, sbyte** azParam)
		{
			long nByte = 0;
			int i = 0;
			sbyte* pResult; sbyte* p;
			nByte = (long)(CRuntime.strlen(zDatabase) + CRuntime.strlen(zJournal) + CRuntime.strlen(zWal) + 10);
			for (i = (int)(0); (i) < (nParam * 2); i++)
			{
				nByte += (long)(CRuntime.strlen(azParam[i]) + 1);
			}

			pResult = p = sqlite3_malloc64((ulong)(nByte));
			if ((p) == (null))
				return null;
			CRuntime.memset(p, (int)(0), (ulong)(4));
			p += 4;
			p = appendText(p, zDatabase);
			for (i = (int)(0); (i) < (nParam * 2); i++)
			{
				p = appendText(p, azParam[i]);
			}

			*(p++) = (sbyte)(0);
			p = appendText(p, zJournal);
			p = appendText(p, zWal);
			*(p++) = (sbyte)(0);
			*(p++) = (sbyte)(0);
			return pResult + 4;
		}
		public static sqlite3_file sqlite3_database_file_object(sbyte* zName)
		{
			Pager pPager;
			while ((((zName[-1] != 0) || (zName[-2] != 0)) || (zName[-3] != 0)) || (zName[-4] != 0))
			{
				zName--;
			}

			pPager = (Pager)(zName - 4 - sizeof(Pager));
			return pPager.fd;
		}
		public static sbyte* sqlite3_db_filename(sqlite3 db, sbyte* zDbName)
		{
			Btree pBt;
			pBt = sqlite3DbNameToBtree(db, zDbName);
			return pBt ? sqlite3BtreeGetFilename(pBt) : null;
		}
		public static sqlite3_mutex* sqlite3_db_mutex(sqlite3 db)
		{
			return db.mutex;
		}
		public static int sqlite3_enable_shared_cache(int enable)
		{
			sqlite3Config.sharedCacheEnabled = (int)(enable);
			return (int)(0);
		}
		public static sbyte* sqlite3_errmsg(sqlite3 db)
		{
			sbyte* z;
			if (db == null)
			{
				return sqlite3ErrStr((int)(7));
			}

			if (sqlite3SafetyCheckSickOrOk(db) == 0)
			{
				return sqlite3ErrStr((int)(sqlite3MisuseError((int)(171066))));
			}

			sqlite3_mutex_enter(db.mutex);
			if ((db.mallocFailed) != 0)
			{
				z = sqlite3ErrStr((int)(7));
			}
			else
			{
				z = (db.errCode) != 0 ? (sbyte*)(sqlite3_value_text(db.pErr)) : null;
				if ((z) == (null))
				{
					z = sqlite3ErrStr((int)(db.errCode));
				}
			}

			sqlite3_mutex_leave(db.mutex);
			return z;
		}
		public static void* sqlite3_errmsg16(sqlite3 db)
		{
			void* z;
			if (db == null)
			{
				return (void*)(sqlite3_errmsg16_outOfMem);
			}

			if (sqlite3SafetyCheckSickOrOk(db) == 0)
			{
				return (void*)(sqlite3_errmsg16_misuse);
			}

			sqlite3_mutex_enter(db.mutex);
			if ((db.mallocFailed) != 0)
			{
				z = (void*)(sqlite3_errmsg16_outOfMem);
			}
			else
			{
				z = sqlite3_value_text16(db.pErr);
				if ((z) == (null))
				{
					sqlite3ErrorWithMsg(db, (int)(db.errCode), sqlite3ErrStr((int)(db.errCode)));
					z = sqlite3_value_text16(db.pErr);
				}

				sqlite3OomClear(db);
			}

			sqlite3_mutex_leave(db.mutex);
			return z;
		}
		public static sbyte* sqlite3_errstr(int rc)
		{
			return sqlite3ErrStr((int)(rc));
		}
		public static sbyte* sqlite3_expanded_sql(sqlite3_stmt* pStmt)
		{
			sbyte* z = null;
			sbyte* zSql = sqlite3_sql(pStmt);
			if ((zSql) != null)
			{
				Vdbe p = (Vdbe)(pStmt);
				sqlite3_mutex_enter(p.db.mutex);
				z = sqlite3VdbeExpandSql(p, zSql);
				sqlite3_mutex_leave(p.db.mutex);
			}

			return z;
		}
		public static sbyte* sqlite3_filename_database(sbyte* zFilename)
		{
			if ((zFilename) == (null))
				return null;
			return databaseName(zFilename);
		}
		public static sbyte* sqlite3_filename_journal(sbyte* zFilename)
		{
			if ((zFilename) == (null))
				return null;
			zFilename = databaseName(zFilename);
			zFilename += sqlite3Strlen30(zFilename) + 1;
			while (((zFilename) != null) && ((zFilename[0]) != 0))
			{
				zFilename += sqlite3Strlen30(zFilename) + 1;
				zFilename += sqlite3Strlen30(zFilename) + 1;
			}

			return zFilename + 1;
		}
		public static sbyte* sqlite3_filename_wal(sbyte* zFilename)
		{
			zFilename = sqlite3_filename_journal(zFilename);
			if ((zFilename) != null)
				zFilename += sqlite3Strlen30(zFilename) + 1;
			return zFilename;
		}
		public static void sqlite3_free(void* p)
		{
			if ((p) == (null))
				return;
			if ((sqlite3Config.bMemstat) != 0)
			{
				sqlite3_mutex_enter(mem0.mutex);
				sqlite3StatusDown((int)(0), (int)(sqlite3MallocSize(p)));
				sqlite3StatusDown((int)(9), (int)(1));
				sqlite3Config.m.xFree(p);
				sqlite3_mutex_leave(mem0.mutex);
			}
			else
			{
				sqlite3Config.m.xFree(p);
			}
		}
		public static void sqlite3_free_filename(sbyte* p)
		{
			if ((p) == (null))
				return;
			p = databaseName(p);
			sqlite3_free(p - 4);
		}
		public static void sqlite3_free_table(sbyte** azResult)
		{
			if ((azResult) != null)
			{
				int i = 0;
				int n = 0;
				azResult--;
				n = ((int)((long)(azResult[0])));
				for (i = (int)(1); (i) < (n); i++)
				{
					if ((azResult[i]) != null)
						sqlite3_free(azResult[i]);
				}

				sqlite3_free(azResult);
			}
		}
		public static void* sqlite3_get_auxdata(sqlite3_context pCtx, int iArg)
		{
			AuxData pAuxData;
			for (pAuxData = pCtx.pVdbe.pAuxData; pAuxData; pAuxData = pAuxData.pNextAux)
			{
				if (((pAuxData.iAuxArg) == (iArg)) && (((pAuxData.iAuxOp) == (pCtx.iOp)) || ((iArg) < (0))))
				{
					return pAuxData.pAux;
				}
			}

			return null;
		}
		public static int sqlite3_get_table_cb(void* pArg, int nCol, sbyte** argv, sbyte** colv)
		{
			TabResult* p = (TabResult*)(pArg);
			int need = 0;
			int i = 0;
			sbyte* z;
			if (((p->nRow) == (0)) && (argv != null))
			{
				need = (int)(nCol * 2);
			}
			else
			{
				need = (int)(nCol);
			}

			if ((p->nData + need) > (p->nAlloc))
			{
				sbyte** azNew;
				p->nAlloc = (uint)(p->nAlloc * 2 + need);
				azNew = sqlite3Realloc(p->azResult, (ulong)(sizeof(char*) * p->nAlloc));
				if ((azNew) == (null))
					goto malloc_failed;
				p->azResult = azNew;
			}

			if ((p->nRow) == (0))
			{
				p->nColumn = (uint)(nCol);
				for (i = (int)(0); (i) < (nCol); i++)
				{
					z = sqlite3_mprintf("%s", colv[i]);
					if ((z) == (null))
						goto malloc_failed;
					p->azResult[p->nData++] = z;
				}
			}
			else if ((int)(p->nColumn) != nCol)
			{
				sqlite3_free(p->zErrMsg);
				p->zErrMsg = sqlite3_mprintf("sqlite3_get_table() called with two or more incompatible queries");
				p->rc = (int)(1);
				return (int)(1);
			}

			if (argv != null)
			{
				for (i = (int)(0); (i) < (nCol); i++)
				{
					if ((argv[i]) == (null))
					{
						z = null;
					}
					else
					{
						int n = (int)(sqlite3Strlen30(argv[i]) + 1);
						z = sqlite3_malloc64((ulong)(n));
						if ((z) == (null))
							goto malloc_failed;
						CRuntime.memcpy(z, argv[i], (ulong)(n));
					}

					p->azResult[p->nData++] = z;
				}

				p->nRow++;
			}

			return (int)(0);
		malloc_failed:
			; p->rc = (int)(7);
			return (int)(1);
		}
		public static int sqlite3_global_recover()
		{
			return (int)(0);
		}
		public static long sqlite3_hard_heap_limit64(long n)
		{
			long priorLimit = 0;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (long)(-1);
			sqlite3_mutex_enter(mem0.mutex);
			priorLimit = (long)(mem0.hardLimit);
			if ((n) >= (0))
			{
				mem0.hardLimit = (long)(n);
				if (((n) < (mem0.alarmThreshold)) || ((mem0.alarmThreshold) == (0)))
				{
					mem0.alarmThreshold = (long)(n);
				}
			}

			sqlite3_mutex_leave(mem0.mutex);
			return (long)(priorLimit);
		}
		public static int sqlite3_initialize()
		{
			sqlite3_mutex* pMainMtx;
			int rc = 0;
			if ((sqlite3Config.isInit) != 0)
			{
				sqlite3MemoryBarrier();
				return (int)(0);
			}

			rc = (int)(sqlite3MutexInit());
			if ((rc) != 0)
				return (int)(rc);
			pMainMtx = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(pMainMtx);
			sqlite3Config.isMutexInit = (int)(1);
			if (sqlite3Config.isMallocInit == 0)
			{
				rc = (int)(sqlite3MallocInit());
			}

			if ((rc) == (0))
			{
				sqlite3Config.isMallocInit = (int)(1);
				if (sqlite3Config.pInitMutex == null)
				{
					sqlite3Config.pInitMutex = sqlite3MutexAlloc((int)(1));
					if (((sqlite3Config.bCoreMutex) != 0) && (sqlite3Config.pInitMutex == null))
					{
						rc = (int)(7);
					}
				}
			}

			if ((rc) == (0))
			{
				sqlite3Config.nRefInitMutex++;
			}

			sqlite3_mutex_leave(pMainMtx);
			if (rc != 0)
			{
				return (int)(rc);
			}

			sqlite3_mutex_enter(sqlite3Config.pInitMutex);
			if (((sqlite3Config.isInit) == (0)) && ((sqlite3Config.inProgress) == (0)))
			{
				sqlite3Config.inProgress = (int)(1);
				CRuntime.memset(sqlite3BuiltinFunctions, (int)(0), (ulong)(sizeof(FuncDefHash)));
				sqlite3RegisterBuiltinFunctions();
				if ((sqlite3Config.isPCacheInit) == (0))
				{
					rc = (int)(sqlite3PcacheInitialize());
				}

				if ((rc) == (0))
				{
					sqlite3Config.isPCacheInit = (int)(1);
					rc = (int)(sqlite3OsInit());
				}

				if ((rc) == (0))
				{
					rc = (int)(sqlite3MemdbInit());
				}

				if ((rc) == (0))
				{
					sqlite3PCacheBufferSetup(sqlite3Config.pPage, (int)(sqlite3Config.szPage), (int)(sqlite3Config.nPage));
					sqlite3MemoryBarrier();
					sqlite3Config.isInit = (int)(1);
				}

				sqlite3Config.inProgress = (int)(0);
			}

			sqlite3_mutex_leave(sqlite3Config.pInitMutex);
			sqlite3_mutex_enter(pMainMtx);
			sqlite3Config.nRefInitMutex--;
			if ((sqlite3Config.nRefInitMutex) <= (0))
			{
				sqlite3_mutex_free(sqlite3Config.pInitMutex);
				sqlite3Config.pInitMutex = null;
			}

			sqlite3_mutex_leave(pMainMtx);
			return (int)(rc);
		}
		public static int sqlite3_keyword_check(sbyte* zName, int nName)
		{
			return (int)(59 != sqlite3KeywordCode((byte*)(zName), (int)(nName)));
		}
		public static int sqlite3_keyword_count()
		{
			return (int)(147);
		}
		public static int sqlite3_keyword_name(int i, sbyte** pzName, int* pnName)
		{
			if (((i) < (0)) || ((i) >= (147)))
				return (int)(1);
			*pzName = zKWText + aKWOffset[i];
			*pnName = (int)(aKWLen[i]);
			return (int)(0);
		}
		public static sbyte* sqlite3_libversion()
		{
			return sqlite3_version;
		}
		public static int sqlite3_libversion_number()
		{
			return (int)(3038002);
		}
		public static void sqlite3_log(int iErrCode, sbyte* zFormat)
		{
			sbyte* ap;
			if ((sqlite3Config.xLog) != null)
			{
				(__va_start(&ap, zFormat));
				renderLogMsg((int)(iErrCode), zFormat, ap);
				((void)(ap = null));
			}
		}
		public static void* sqlite3_malloc(int n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return (n) <= (0) ? null : sqlite3Malloc((ulong)(n));
		}
		public static void* sqlite3_malloc64(ulong n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return sqlite3Malloc((ulong)(n));
		}
		public static long sqlite3_memory_highwater(int resetFlag)
		{
			long res = 0; long mx = 0;
			sqlite3_status64((int)(0), &res, &mx, (int)(resetFlag));
			return (long)(mx);
		}
		public static long sqlite3_memory_used()
		{
			long res = 0; long mx = 0;
			sqlite3_status64((int)(0), &res, &mx, (int)(0));
			return (long)(res);
		}
		public static sbyte* sqlite3_mprintf(sbyte* zFormat)
		{
			sbyte* ap;
			sbyte* z;
			if ((sqlite3_initialize()) != 0)
				return null;
			(__va_start(&ap, zFormat));
			z = sqlite3_vmprintf(zFormat, ap);
			((void)(ap = null));
			return z;
		}
		public static ulong sqlite3_msize(void* p)
		{
			return (ulong)(p ? sqlite3Config.m.xSize(p) : 0);
		}
		public static sqlite3_mutex* sqlite3_mutex_alloc(int id)
		{
			if (((id) <= (1)) && ((sqlite3_initialize()) != 0))
				return null;
			if (((id) > (1)) && ((sqlite3MutexInit()) != 0))
				return null;
			return sqlite3Config.mutex.xMutexAlloc((int)(id));
		}
		public static sqlite3_stmt* sqlite3_next_stmt(sqlite3 pDb, sqlite3_stmt* pStmt)
		{
			sqlite3_stmt* pNext;
			sqlite3_mutex_enter(pDb.mutex);
			if ((pStmt) == (null))
			{
				pNext = (sqlite3_stmt*)(pDb.pVdbe);
			}
			else
			{
				pNext = (sqlite3_stmt*)(((Vdbe)(pStmt)).pNext);
			}

			sqlite3_mutex_leave(pDb.mutex);
			return pNext;
		}
		public static int sqlite3_open(sbyte* zFilename, sqlite3 ppDb)
		{
			return (int)(openDatabase(zFilename, ppDb, (uint)(0x00000002 | 0x00000004), null));
		}
		public static int sqlite3_open_v2(sbyte* filename, sqlite3 ppDb, int flags, sbyte* zVfs)
		{
			return (int)(openDatabase(filename, ppDb, (uint)(flags), zVfs));
		}
		public static int sqlite3_open16(void* zFilename, sqlite3 ppDb)
		{
			sbyte* zFilename8;
			sqlite3_value pVal;
			int rc = 0;
			ppDb = null;
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			if ((zFilename) == (null))
				zFilename = "\000\000";
			pVal = sqlite3ValueNew(null);
			sqlite3ValueSetStr(pVal, (int)(-1), zFilename, (byte)(2), null);
			zFilename8 = sqlite3ValueText(pVal, (byte)(1));
			if ((zFilename8) != null)
			{
				rc = (int)(openDatabase(zFilename8, ppDb, (uint)(0x00000002 | 0x00000004), null));
				if (((rc) == (0)) && (!(((ppDb).aDb[0].pSchema.schemaFlags & (0x0001)) == (0x0001))))
				{
					((ppDb).aDb[0].pSchema.enc) = (byte)(((ppDb).enc) = (byte)(2));
				}
			}
			else
			{
				rc = (int)(7);
			}

			sqlite3ValueFree(pVal);
			return (int)(rc & 0xff);
		}
		public static int sqlite3_os_end()
		{
			winBigLock = null;
			return (int)(0);
		}
		public static int sqlite3_os_init()
		{
			CRuntime.memset(&winSysInfo, (int)(0), (ulong)(sizeof(_SYSTEM_INFO)));
			(Void(_SYSTEM_INFO * ))(aSyscall[28].pCurrent)(&winSysInfo);
			sqlite3_vfs_register(sqlite3_os_init_winVfs, (int)(1));
			sqlite3_vfs_register(sqlite3_os_init_winLongPathVfs, (int)(0));
			sqlite3_vfs_register(sqlite3_os_init_winNolockVfs, (int)(0));
			sqlite3_vfs_register(sqlite3_os_init_winLongPathNolockVfs, (int)(0));
			winBigLock = sqlite3MutexAlloc((int)(11));
			return (int)(0);
		}
		public static void* sqlite3_profile(sqlite3 db, delegate63 xProfile, void* pArg)
		{
			void* pOld;
			sqlite3_mutex_enter(db.mutex);
			pOld = db.pProfileArg;
			db.xProfile = xProfile;
			db.pProfileArg = pArg;
			db.mTrace &= (byte)(0x0f);
			if ((db.xProfile) != null)
				db.mTrace |= (byte)(0x80);
			sqlite3_mutex_leave(db.mutex);
			return pOld;
		}
		public static void sqlite3_randomness(int N, void* pBuf)
		{
			byte t = 0;
			byte* zBuf = pBuf;
			sqlite3_mutex* mutex;
			if ((sqlite3_initialize()) != 0)
				return;
			mutex = sqlite3MutexAlloc((int)(5));
			sqlite3_mutex_enter(mutex);
			if (((N) <= (0)) || ((pBuf) == (null)))
			{
				sqlite3Prng.isInit = (byte)(0);
				sqlite3_mutex_leave(mutex);
				return;
			}

			if (sqlite3Prng.isInit == 0)
			{
				sqlite3_vfs pVfs = sqlite3_vfs_find(null);
				int i = 0;
				sbyte* k = stackalloc sbyte[256];
				sqlite3Prng.j = (byte)(0);
				sqlite3Prng.i = (byte)(0);
				if (((pVfs) == (null)))
				{
					CRuntime.memset(k, (int)(0), (ulong)(256 * sizeof(sbyte)));
				}
				else
				{
					sqlite3OsRandomness(pVfs, (int)(256), k);
				}

				for (i = (int)(0); (i) < (256); i++)
				{
					sqlite3Prng.s[i] = ((byte)(i));
				}

				for (i = (int)(0); (i) < (256); i++)
				{
					sqlite3Prng.j += (byte)(sqlite3Prng.s[i] + k[i]);
					t = (byte)(sqlite3Prng.s[sqlite3Prng.j]);
					sqlite3Prng.s[sqlite3Prng.j] = (byte)(sqlite3Prng.s[i]);
					sqlite3Prng.s[i] = (byte)(t);
				}

				sqlite3Prng.isInit = (byte)(1);
			}

			do
			{
				sqlite3Prng.i++;
				t = (byte)(sqlite3Prng.s[sqlite3Prng.i]);
				sqlite3Prng.j += (byte)(t);
				sqlite3Prng.s[sqlite3Prng.i] = (byte)(sqlite3Prng.s[sqlite3Prng.j]);
				sqlite3Prng.s[sqlite3Prng.j] = (byte)(t);
				t += (byte)(sqlite3Prng.s[sqlite3Prng.i]);
				*(zBuf++) = (byte)(sqlite3Prng.s[t]);
			}
			while ((--N) != 0);
			sqlite3_mutex_leave(mutex);
		}
		public static void* sqlite3_realloc(void* pOld, int n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			if ((n) < (0))
				n = (int)(0);
			return sqlite3Realloc(pOld, (ulong)(n));
		}
		public static void* sqlite3_realloc64(void* pOld, ulong n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return sqlite3Realloc(pOld, (ulong)(n));
		}
		public static int sqlite3_release_memory(int n)
		{
			return (int)(0);
		}
		public static void sqlite3_reset_auto_extension()
		{
			if ((sqlite3_initialize()) == (0))
			{
				sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
				sqlite3_mutex_enter(mutex);
				sqlite3_free(sqlite3Autoext.aExt);
				sqlite3Autoext.aExt = null;
				sqlite3Autoext.nExt = (uint)(0);
				sqlite3_mutex_leave(mutex);
			}
		}
		public static void* sqlite3_rollback_hook(sqlite3 db, delegate17 xCallback, void* pArg)
		{
			void* pRet;
			sqlite3_mutex_enter(db.mutex);
			pRet = db.pRollbackArg;
			db.xRollbackCallback = xCallback;
			db.pRollbackArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pRet;
		}
		public static byte* sqlite3_serialize(sqlite3 db, sbyte* zSchema, long* piSize, uint mFlags)
		{
			MemFile p;
			int iDb = 0;
			Btree pBt;
			long sz = 0;
			int szPage = (int)(0);
			sqlite3_stmt* pStmt = null;
			byte* pOut;
			sbyte* zSql;
			int rc = 0;
			if ((zSchema) == (null))
				zSchema = db.aDb[0].zDbSName;
			p = memdbFromDbSchema(db, zSchema);
			iDb = (int)(sqlite3FindDbName(db, zSchema));
			if ((piSize) != null)
				*piSize = (long)(-1);
			if ((iDb) < (0))
				return null;
			if ((p) != null)
			{
				MemStore* pStore = p.pStore;
				if ((piSize) != null)
					*piSize = (long)(pStore->sz);
				if ((mFlags & 0x001) != 0)
				{
					pOut = pStore->aData;
				}
				else
				{
					pOut = sqlite3_malloc64((ulong)(pStore->sz));
					if ((pOut) != null)
						CRuntime.memcpy(pOut, pStore->aData, (ulong)(pStore->sz));
				}

				return pOut;
			}

			pBt = db.aDb[iDb].pBt;
			if ((pBt) == (null))
				return null;
			szPage = (int)(sqlite3BtreeGetPageSize(pBt));
			zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);
			rc = (int)((zSql) != 0 ? sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, null) : 7);
			sqlite3_free(zSql);
			if ((rc) != 0)
				return null;
			rc = (int)(sqlite3_step(pStmt));
			if (rc != 100)
			{
				pOut = null;
			}
			else
			{
				sz = (long)(sqlite3_column_int64(pStmt, (int)(0)) * szPage);
				if ((piSize) != null)
					*piSize = (long)(sz);
				if ((mFlags & 0x001) != 0)
				{
					pOut = null;
				}
				else
				{
					pOut = sqlite3_malloc64((ulong)(sz));
					if ((pOut) != null)
					{
						int nPage = (int)(sqlite3_column_int(pStmt, (int)(0)));
						Pager pPager = sqlite3BtreePager(pBt);
						int pgno = 0;
						for (pgno = (int)(1); (pgno) <= (nPage); pgno++)
						{
							PgHdr pPage = null;
							byte* pTo = pOut + szPage * (long)(pgno - 1);
							rc = (int)(sqlite3PagerGet(pPager, (uint)(pgno), pPage, (int)(0)));
							if ((rc) == (0))
							{
								CRuntime.memcpy(pTo, sqlite3PagerGetData(pPage), (ulong)(szPage));
							}
							else
							{
								CRuntime.memset(pTo, (int)(0), (ulong)(szPage));
							}

							sqlite3PagerUnref(pPage);
						}
					}
				}
			}

			sqlite3_finalize(pStmt);
			return pOut;
		}
		public static int sqlite3_shutdown()
		{
			if ((sqlite3Config.isInit) != 0)
			{
				sqlite3_os_end();
				sqlite3_reset_auto_extension();
				sqlite3Config.isInit = (int)(0);
			}

			if ((sqlite3Config.isPCacheInit) != 0)
			{
				sqlite3PcacheShutdown();
				sqlite3Config.isPCacheInit = (int)(0);
			}

			if ((sqlite3Config.isMallocInit) != 0)
			{
				sqlite3MallocEnd();
				sqlite3Config.isMallocInit = (int)(0);
				sqlite3_data_directory = null;
				sqlite3_temp_directory = null;
			}

			if ((sqlite3Config.isMutexInit) != 0)
			{
				sqlite3MutexEnd();
				sqlite3Config.isMutexInit = (int)(0);
			}

			return (int)(0);
		}
		public static int sqlite3_sleep(int ms)
		{
			sqlite3_vfs pVfs;
			int rc = 0;
			pVfs = sqlite3_vfs_find(null);
			if ((pVfs) == (null))
				return (int)(0);
			rc = (int)(sqlite3OsSleep(pVfs, (int)(1000 * ms)) / 1000);
			return (int)(rc);
		}
		public static sbyte* sqlite3_snprintf(int n, sbyte* zBuf, sbyte* zFormat)
		{
			sbyte* z;
			sbyte* ap;
			(__va_start(&ap, zFormat));
			z = sqlite3_vsnprintf((int)(n), zBuf, zFormat, ap);
			((void)(ap = null));
			return z;
		}
		public static void sqlite3_soft_heap_limit(int n)
		{
			if ((n) < (0))
				n = (int)(0);
			sqlite3_soft_heap_limit64((long)(n));
		}
		public static long sqlite3_soft_heap_limit64(long n)
		{
			long priorLimit = 0;
			long excess = 0;
			long nUsed = 0;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (long)(-1);
			sqlite3_mutex_enter(mem0.mutex);
			priorLimit = (long)(mem0.alarmThreshold);
			if ((n) < (0))
			{
				sqlite3_mutex_leave(mem0.mutex);
				return (long)(priorLimit);
			}

			if (((mem0.hardLimit) > (0)) && (((n) > (mem0.hardLimit)) || ((n) == (0))))
			{
				n = (long)(mem0.hardLimit);
			}

			mem0.alarmThreshold = (long)(n);
			nUsed = (long)(sqlite3StatusValue((int)(0)));
			(((n) > (0)) && ((n) <= (nUsed)));
			sqlite3_mutex_leave(mem0.mutex);
			excess = (long)(sqlite3_memory_used() - n);
			if ((excess) > (0))
				sqlite3_release_memory((int)(excess & 0x7fffffff));
			return (long)(priorLimit);
		}
		public static sbyte* sqlite3_sourceid()
		{
			return "2022-03-26 13:51:10 d33c709cc0af66bc5b6dc6216eba9f1f0b40960b9ae83694c986fbf4c1d6f08f";
		}
		public static sbyte* sqlite3_sql(sqlite3_stmt* pStmt)
		{
			Vdbe p = (Vdbe)(pStmt);
			return p ? p.zSql : null;
		}
		public static int sqlite3_status(int op, int* pCurrent, int* pHighwater, int resetFlag)
		{
			long iCur = (long)(0); long iHwtr = (long)(0);
			int rc = 0;
			rc = (int)(sqlite3_status64((int)(op), &iCur, &iHwtr, (int)(resetFlag)));
			if ((rc) == (0))
			{
				*pCurrent = ((int)(iCur));
				*pHighwater = ((int)(iHwtr));
			}

			return (int)(rc);
		}
		public static int sqlite3_status64(int op, long* pCurrent, long* pHighwater, int resetFlag)
		{
			sqlite3_mutex* pMutex;
			if (((op) < (0)) || ((op) >= ((int)(10 * sizeof(long) / sizeof(long)))))
			{
				return (int)(sqlite3MisuseError((int)(22813)));
			}

			pMutex = (statMutex[op]) != 0 ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
			sqlite3_mutex_enter(pMutex);
			*pCurrent = (long)(sqlite3Stat.nowValue[op]);
			*pHighwater = (long)(sqlite3Stat.mxValue[op]);
			if ((resetFlag) != 0)
			{
				sqlite3Stat.mxValue[op] = (long)(sqlite3Stat.nowValue[op]);
			}

			sqlite3_mutex_leave(pMutex);
			(void)(pMutex);
			return (int)(0);
		}
		public static sbyte* sqlite3_str_finish(sqlite3_str p)
		{
			sbyte* z;
			if ((p != null) && (p != sqlite3OomStr))
			{
				z = sqlite3StrAccumFinish(p);
				sqlite3_free(p);
			}
			else
			{
				z = null;
			}

			return z;
		}
		public static sbyte* sqlite3_str_value(sqlite3_str p)
		{
			if (((p) == (null)) || ((p.nChar) == (0)))
				return null;
			p.zText[p.nChar] = (sbyte)(0);
			return p.zText;
		}
		public static int sqlite3_strglob(sbyte* zGlobPattern, sbyte* zString)
		{
			return (int)(patternCompare((byte*)(zGlobPattern), (byte*)(zString), &globInfo, (uint)(91)));
		}
		public static int sqlite3_stricmp(sbyte* zLeft, sbyte* zRight)
		{
			if ((zLeft) == (null))
			{
				return (int)((zRight) != 0 ? -1 : 0);
			}
			else if ((zRight) == (null))
			{
				return (int)(1);
			}

			return (int)(sqlite3StrICmp(zLeft, zRight));
		}
		public static int sqlite3_strlike(sbyte* zPattern, sbyte* zStr, uint esc)
		{
			return (int)(patternCompare((byte*)(zPattern), (byte*)(zStr), &likeInfoNorm, (uint)(esc)));
		}
		public static int sqlite3_strnicmp(sbyte* zLeft, sbyte* zRight, int N)
		{
			byte* a; byte* b;
			if ((zLeft) == (null))
			{
				return (int)((zRight) != 0 ? -1 : 0);
			}
			else if ((zRight) == (null))
			{
				return (int)(1);
			}

			a = (byte*)(zLeft);
			b = (byte*)(zRight);
			while ((((N--) > (0)) && (*a != 0)) && ((sqlite3UpperToLower[*a]) == (sqlite3UpperToLower[*b])))
			{
				a++;
				b++;
			}

			return (int)((N) < (0) ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b]);
		}
		public static int sqlite3_test_control(int op)
		{
			int rc = (int)(0);
			sbyte* ap;
			(__va_start(&ap, (int)(op)));
			switch (op)
			{
				case 5:
					{
						sqlite3PrngSaveState();
						break;
					}

				case 6:
					{
						sqlite3PrngRestoreState();
						break;
					}

				case 28:
					{
						int x = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						int y = 0;
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						if (((db) != null) && ((y = (int)(db.aDb[0].pSchema.schema_cookie)) != 0))
						{
							x = (int)(y);
						}

						sqlite3Config.iPrngSeed = (uint)(x);
						sqlite3_randomness((int)(0), null);
						break;
					}

				case 8:
					{
						int sz = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						int* aProg = (((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ));
						rc = (int)(sqlite3BitvecBuiltinTest((int)(sz), aProg));
						break;
					}

				case 9:
					{
						sqlite3Config.xTestCallback = ((((sizeof(Int(Int))) > ()) || ((sizeof(Int(Int)) & (sizeof(Int(Int)) - 1)) != 0 ) ) ?
            **(Int(Int))((ap += ) - ) : 
            *(Int(Int))((ap += ) - ) )
            ;
						rc = (int)(sqlite3FaultSim((int)(0)));
						break;
					}

				case 10:
					{
						delegate74 xBenignBegin;
						delegate74 xBenignEnd;
						xBenignBegin = ((((sizeof(Void())) > ()) || ((sizeof(Void()) & (sizeof(Void()) - 1)) != 0 ) ) ?
            **(Void())((ap += ) - ) : 
            *(Void())((ap += ) - ) )
            ;
						xBenignEnd = ((((sizeof(Void())) > ()) || ((sizeof(Void()) & (sizeof(Void()) - 1)) != 0 ) ) ?
            **(Void())((ap += ) - ) : 
            *(Void())((ap += ) - ) )
            ;
						sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
						break;
					}

				case 11:
					{
						rc = (int)(sqlite3PendingByte);
						{
							uint newVal = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
							if ((newVal) != 0)
								sqlite3PendingByte = (int)(newVal);
						}

						break;
					}

				case 12:
					{
						int x = (int)(0);
						rc = (int)(x);
						break;
					}

				case 13:
					{
						int x = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						rc = (int)((x) != 0 ? (x) : 0);
						break;
					}

				case 22:
					{
						rc = (int)(1234 * 100 + 1 * 10 + 0);
						break;
					}

				case 15:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						db.dbOptFlags = (uint)((((sizeof(uint)) > ()) || ((sizeof(uint) & (sizeof(uint) - 1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
						break;
					}

				case 18:
					{
						sqlite3Config.bLocaltimeFault = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						if ((sqlite3Config.bLocaltimeFault) == (2))
						{
							sqlite3Config.xAltLocaltime = ((((sizeof(Int(Void * , Void * ))) > ()) || ((sizeof(Int(Void * , Void * )) & (sizeof(Int(Void * , Void * )) - 1)) != 0 ) ) ?
                **(Int(Void * , Void * ))((ap += ) - ) : 
                *(Int(Void * , Void * ))((ap += ) - ) )
                ;
						}
						else
						{
							sqlite3Config.xAltLocaltime = null;
						}

						break;
					}

				case 17:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						db.mDbFlags ^= (uint)(0x0020);
						break;
					}

				case 20:
					{
						sqlite3Config.neverCorrupt = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 29:
					{
						sqlite3Config.bExtraSchemaChecks = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 19:
					{
						sqlite3Config.iOnceResetThreshold = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 21:
					{
						break;
					}

				case 24:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						db.nMaxSorterMmap = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 23:
					{
						if ((sqlite3Config.isInit) == (0))
							rc = (int)(1);
						break;
					}

				case 25:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						int iDb = 0;
						sqlite3_mutex_enter(db.mutex);
						iDb = (int)(sqlite3FindDbName(db, (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ))));
						if ((iDb) >= (0))
						{
							db.init.iDb = (byte)(iDb);
							db.init.busy = (byte)(db.init.imposterTable = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )));
							db.init.newTnum = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
							if (((db.init.busy) == (0)) && ((db.init.newTnum) > (0)))
							{
								sqlite3ResetAllSchemasOfConnection(db);
							}
						}

						sqlite3_mutex_leave(db.mutex);
						break;
					}

				case 27:
					{
						sqlite3_context pCtx = ((((sizeof(sqlite3_context)) > ()) || ((sizeof(sqlite3_context) & (sizeof(sqlite3_context) - 1)) != 0)) ? (sqlite3_context)((ap += ) - ) : (sqlite3_context)((ap += ) - ));
						sqlite3ResultIntReal(pCtx);
						break;
					}

				case 30:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						ulong* pn = ((((sizeof(ulong)) > ()) || ((sizeof(ulong) & (sizeof(ulong) - 1)) != 0)) ? **(ulong***)((ap += ) - ) : *(ulong**)((ap += ) - ));
						*pn = (ulong)(0);
						(void)(db);
						break;
					}

				case 31:
					{
						int opTrace = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						uint* ptr = ((((sizeof(uint)) > ()) || ((sizeof(uint) & (sizeof(uint) - 1)) != 0)) ? **(uint***)((ap += ) - ) : *(uint**)((ap += ) - ));
						switch (opTrace)
						{
							case 0:
								*ptr = (uint)(sqlite3SelectTrace);
								break;
							case 1:
								sqlite3SelectTrace = (uint)(*ptr);
								break;
							case 2:
								*ptr = (uint)(sqlite3WhereTrace);
								break;
							case 3:
								sqlite3WhereTrace = (uint)(*ptr);
								break;
						}

						break;
					}

				case 33:
					{
						double rIn = (double)(((() > ()) || ((&(-1)) != 0)) ? **(double**)((ap += ) - ) : *(double*)((ap += ) - ));
						short rLogEst = (short)(sqlite3LogEstFromDouble((double)(rIn)));
						ulong iInt = (ulong)(sqlite3LogEstToInt((short)(rLogEst)));
						(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ))[0] = (int)(rLogEst);
						((((sizeof(ulong)) > ()) || ((sizeof(ulong) & (sizeof(ulong) - 1)) != 0)) ? **(ulong***)((ap += ) - ) : *(ulong**)((ap += ) - ))[0] = (ulong)(iInt);
						(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ))[0] = (int)(sqlite3LogEst((ulong)(iInt)));
						break;
					}
			}

			((void)(ap = null));
			return (int)(rc);
		}
		public static void sqlite3_thread_cleanup()
		{
		}
		public static int sqlite3_threadsafe()
		{
			return (int)(1);
		}
		public static void* sqlite3_trace(sqlite3 db, delegate61 xTrace, void* pArg)
		{
			void* pOld;
			sqlite3_mutex_enter(db.mutex);
			pOld = db.pTraceArg;
			db.mTrace = (byte)(xTrace ? 0x40 : 0);
			db.trace.xLegacy = xTrace;
			db.pTraceArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pOld;
		}
		public static void* sqlite3_update_hook(sqlite3 db, delegate64 xCallback, void* pArg)
		{
			void* pRet;
			sqlite3_mutex_enter(db.mutex);
			pRet = db.pUpdateArg;
			db.xUpdateCallback = xCallback;
			db.pUpdateArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pRet;
		}
		public static int sqlite3_uri_boolean(sbyte* zFilename, sbyte* zParam, int bDflt)
		{
			sbyte* z = sqlite3_uri_parameter(zFilename, zParam);
			bDflt = (int)(bDflt != 0);
			return (int)((z) != 0 ? sqlite3GetBoolean(z, (byte)(bDflt)) : bDflt);
		}
		public static long sqlite3_uri_int64(sbyte* zFilename, sbyte* zParam, long bDflt)
		{
			sbyte* z = sqlite3_uri_parameter(zFilename, zParam);
			long v = 0;
			if (((z) != null) && ((sqlite3DecOrHexToI64(z, &v)) == (0)))
			{
				bDflt = (long)(v);
			}

			return (long)(bDflt);
		}
		public static sbyte* sqlite3_uri_key(sbyte* zFilename, int N)
		{
			if (((zFilename) == (null)) || ((N) < (0)))
				return null;
			zFilename = databaseName(zFilename);
			zFilename += sqlite3Strlen30(zFilename) + 1;
			while ((((zFilename) != null) && ((zFilename[0]) != 0)) && ((N--) > (0)))
			{
				zFilename += sqlite3Strlen30(zFilename) + 1;
				zFilename += sqlite3Strlen30(zFilename) + 1;
			}

			return (zFilename[0]) != 0 ? zFilename : null;
		}
		public static sbyte* sqlite3_uri_parameter(sbyte* zFilename, sbyte* zParam)
		{
			if (((zFilename) == (null)) || ((zParam) == (null)))
				return null;
			zFilename = databaseName(zFilename);
			return uriParameter(zFilename, zParam);
		}
		public static void* sqlite3_user_data(sqlite3_context p)
		{
			return p.pFunc.pUserData;
		}
		public static void* sqlite3_value_blob(sqlite3_value pVal)
		{
			sqlite3_value p = pVal;
			if ((p.flags & (0x0010 | 0x0002)) != 0)
			{
				if ((((p).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(p) : 0) != 0)
				{
					return null;
				}

				p.flags |= (ushort)(0x0010);
				return (p.n) != 0 ? p.z : null;
			}
			else
			{
				return sqlite3_value_text(pVal);
			}
		}
		public static void* sqlite3_value_pointer(sqlite3_value pVal, sbyte* zPType)
		{
			sqlite3_value p = pVal;
			if (((((p.flags & (0xc1bf | 0x0200 | 0x8000)) == (0x0001 | 0x0200 | 0x8000)) && (zPType != null)) && ((p.eSubtype) == (112))) && ((CRuntime.strcmp(p.u.zPType, zPType)) == (0)))
			{
				return (void*)(p.z);
			}
			else
			{
				return null;
			}
		}
		public static byte* sqlite3_value_text(sqlite3_value pVal)
		{
			return (byte*)(sqlite3ValueText(pVal, (byte)(1)));
		}
		public static void* sqlite3_value_text16(sqlite3_value pVal)
		{
			return sqlite3ValueText(pVal, (byte)(2));
		}
		public static void* sqlite3_value_text16be(sqlite3_value pVal)
		{
			return sqlite3ValueText(pVal, (byte)(3));
		}
		public static void* sqlite3_value_text16le(sqlite3_value pVal)
		{
			return sqlite3ValueText(pVal, (byte)(2));
		}
		public static sqlite3_vfs sqlite3_vfs_find(sbyte* zVfs)
		{
			sqlite3_vfs pVfs = null;
			sqlite3_mutex* mutex;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return null;
			mutex = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(mutex);
			for (pVfs = vfsList; pVfs; pVfs = pVfs.pNext)
			{
				if ((zVfs) == (null))
					break;
				if ((CRuntime.strcmp(zVfs, pVfs.zName)) == (0))
					break;
			}

			sqlite3_mutex_leave(mutex);
			return pVfs;
		}
		public static sbyte* sqlite3_vmprintf(sbyte* zFormat, sbyte* ap)
		{
			sbyte* z;
			sbyte* zBase = stackalloc sbyte[70];
			sqlite3_str acc = new sqlite3_str();
			if ((sqlite3_initialize()) != 0)
				return null;
			sqlite3StrAccumInit(acc, null, zBase, (int)(70 * sizeof(sbyte)), (int)(1000000000));
			sqlite3_str_vappendf(acc, zFormat, ap);
			z = sqlite3StrAccumFinish(acc);
			return z;
		}
		public static sbyte* sqlite3_vsnprintf(int n, sbyte* zBuf, sbyte* zFormat, sbyte* ap)
		{
			sqlite3_str acc = new sqlite3_str();
			if ((n) <= (0))
				return zBuf;
			sqlite3StrAccumInit(acc, null, zBuf, (int)(n), (int)(0));
			sqlite3_str_vappendf(acc, zFormat, ap);
			zBuf[acc.nChar] = (sbyte)(0);
			return zBuf;
		}
		public static sbyte* sqlite3_vtab_collation(sqlite3_index_info* pIdxInfo, int iCons)
		{
			HiddenIndexInfo pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			sbyte* zRet = null;
			if (((iCons) >= (0)) && ((iCons) < (pIdxInfo->nConstraint)))
			{
				CollSeq pC = null;
				int iTerm = (int)(pIdxInfo->aConstraint[iCons].iTermOffset);
				Expr pX = pHidden.pWC.a[iTerm].pExpr;
				if ((pX.pLeft) != null)
				{
					pC = sqlite3ExprCompareCollSeq(pHidden.pParse, pX);
				}

				zRet = (pC ? pC.zName : sqlite3StrBINARY);
			}

			return zRet;
		}
		public static void* sqlite3_wal_hook(sqlite3 db, delegate54 xCallback, void* pArg)
		{
			void* pRet;
			sqlite3_mutex_enter(db.mutex);
			pRet = db.pWalArg;
			db.xWalCallback = xCallback;
			db.pWalArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pRet;
		}
		public static int sqlite3_win32_is_nt()
		{
			return (int)(1);
		}
		public static sbyte* sqlite3_win32_mbcs_to_utf8(sbyte* zText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winMbcsToUtf8(zText, (int)((Int())(aSyscall[0].pCurrent)()));
		}
		public static sbyte* sqlite3_win32_mbcs_to_utf8_v2(sbyte* zText, int useAnsi)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winMbcsToUtf8(zText, (int)(useAnsi));
		}
		public static int sqlite3_win32_set_directory(uint type, void* zValue)
		{
			return (int)(sqlite3_win32_set_directory16((uint)(type), zValue));
		}
		public static int sqlite3_win32_set_directory16(uint type, void* zValue)
		{
			int rc = 0;
			sbyte* zUtf8 = null;
			if ((zValue) != null)
			{
				zUtf8 = sqlite3_win32_unicode_to_utf8(zValue);
				if ((zUtf8) == (null))
					return (int)(7);
			}

			rc = (int)(sqlite3_win32_set_directory8((uint)(type), zUtf8));
			if ((zUtf8) != null)
				sqlite3_free(zUtf8);
			return (int)(rc);
		}
		public static int sqlite3_win32_set_directory8(uint type, sbyte* zValue)
		{
			sbyte** ppDirectory = null;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			if ((type) == (1))
			{
				ppDirectory = &sqlite3_data_directory;
			}
			else if ((type) == (2))
			{
				ppDirectory = &sqlite3_temp_directory;
			}

			if ((ppDirectory) != null)
			{
				sbyte* zCopy = null;
				if (((zValue) != null) && ((zValue[0]) != 0))
				{
					zCopy = sqlite3_mprintf("%s", zValue);
					if ((zCopy) == (null))
					{
						return (int)(7);
					}
				}

				sqlite3_free(*ppDirectory);
				*ppDirectory = zCopy;
				return (int)(0);
			}

			return (int)(1);
		}
		public static void sqlite3_win32_sleep(uint milliseconds)
		{
			(Void(Uint))(aSyscall[55].pCurrent)((uint)(milliseconds));
		}
		public static sbyte* sqlite3_win32_unicode_to_utf8(ushort* zWideText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUnicodeToUtf8(zWideText);
		}
		public static sbyte* sqlite3_win32_utf8_to_mbcs(sbyte* zText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUtf8ToMbcs(zText, (int)((Int())(aSyscall[0].pCurrent)()));
		}
		public static sbyte* sqlite3_win32_utf8_to_mbcs_v2(sbyte* zText, int useAnsi)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUtf8ToMbcs(zText, (int)(useAnsi));
		}
		public static ushort* sqlite3_win32_utf8_to_unicode(sbyte* zText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUtf8ToUnicode(zText);
		}
		public static void sqlite3_win32_write_debug(sbyte* zBuf, int nBuf)
		{
			sbyte* zDbgBuf = stackalloc sbyte[4092];
			int nMin = (int)((nBuf) < (((int)(4096 - sizeof(uint))) - 1) ? (nBuf) : (((int)(4096 - sizeof(uint))) - 1));
			if ((nMin) < (-1))
				nMin = (int)(-1);
			if ((nMin) > (0))
			{
				CRuntime.memset(zDbgBuf, (int)(0), (ulong)((int)(4096 - sizeof(uint))));
				CRuntime.memcpy(zDbgBuf, zBuf, (ulong)(nMin));
				(Void(Sbyte * ))(aSyscall[72].pCurrent)(zDbgBuf);
			}
			else
			{
				(Void(Sbyte * ))(aSyscall[72].pCurrent)(zBuf);
			}
		}
		public static int sqlite3AbsInt32(int x)
		{
			if ((x) >= (0))
				return (int)(x);
			if ((x) == ((int)(0x80000000)))
				return (int)(0x7fffffff);
			return (int)(-x);
		}
		public static int sqlite3AddInt64(long* pA, long iB)
		{
			long iA = (long)(*pA);
			if ((iB) >= (0))
			{
				if (((iA) > (0)) && (((0xffffffff | (((long)(0x7fffffff)) << 32)) - iA) < (iB)))
					return (int)(1);
			}
			else
			{
				if (((iA) < (0)) && ((-(iA + (0xffffffff | (((long)(0x7fffffff)) << 32)))) > (iB + 1)))
					return (int)(1);
			}

			*pA += (long)(iB);
			return (int)(0);
		}
		public static sbyte sqlite3AffinityType(sbyte* zIn, Column* pCol)
		{
			uint h = (uint)(0);
			sbyte aff = (sbyte)(0x43);
			sbyte* zChar = null;
			while ((zIn[0]) != 0)
			{
				h = (uint)((h << 8) + sqlite3UpperToLower[(*zIn) & 0xff]);
				zIn++;
				if ((h) == ((99 << 24) + (104 << 16) + (97 << 8) + 114))
				{
					aff = (sbyte)(0x42);
					zChar = zIn;
				}
				else if ((h) == ((99 << 24) + (108 << 16) + (111 << 8) + 98))
				{
					aff = (sbyte)(0x42);
				}
				else if ((h) == ((116 << 24) + (101 << 16) + (120 << 8) + 116))
				{
					aff = (sbyte)(0x42);
				}
				else if (((h) == ((98 << 24) + (108 << 16) + (111 << 8) + 98)) && (((aff) == (0x43)) || ((aff) == (0x45))))
				{
					aff = (sbyte)(0x41);
					if ((zIn[0]) == (40))
						zChar = zIn;
				}
				else if (((h) == ((114 << 24) + (101 << 16) + (97 << 8) + 108)) && ((aff) == (0x43)))
				{
					aff = (sbyte)(0x45);
				}
				else if (((h) == ((102 << 24) + (108 << 16) + (111 << 8) + 97)) && ((aff) == (0x43)))
				{
					aff = (sbyte)(0x45);
				}
				else if (((h) == ((100 << 24) + (111 << 16) + (117 << 8) + 98)) && ((aff) == (0x43)))
				{
					aff = (sbyte)(0x45);
				}
				else if ((h & 0x00FFFFFF) == ((105 << 16) + (110 << 8) + 116))
				{
					aff = (sbyte)(0x44);
					break;
				}
			}

			if ((pCol) != null)
			{
				int v = (int)(0);
				if ((aff) < (0x43))
				{
					if ((zChar) != null)
					{
						while ((zChar[0]) != 0)
						{
							if ((sqlite3CtypeMap[(byte)(zChar[0])] & 0x04) != 0)
							{
								sqlite3GetInt32(zChar, &v);
								break;
							}

							zChar++;
						}
					}
					else
					{
						v = (int)(16);
					}
				}

				v = (int)(v / 4 + 1);
				if ((v) > (255))
					v = (int)(255);
				pCol->szEst = (byte)(v);
			}

			return (sbyte)(aff);
		}
		public static void sqlite3AlterFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3AlterFunctions_aAlterTableFuncs, ((int)(5 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void* sqlite3ArrayAllocate(sqlite3 db, void* pArray, int szEntry, int* pnEntry, int* pIdx)
		{
			sbyte* z;
			long n = (long)(*pIdx = (int)(*pnEntry));
			if ((n & (n - 1)) == (0))
			{
				long sz = (long)(((n) == (0)) ? 1 : 2 * n);
				void* pNew = sqlite3DbRealloc(db, pArray, (ulong)(sz * szEntry));
				if ((pNew) == (null))
				{
					*pIdx = (int)(-1);
					return pArray;
				}

				pArray = pNew;
			}

			z = (sbyte*)(pArray);
			CRuntime.memset(&z[n * szEntry], (int)(0), (ulong)(szEntry));
			++*pnEntry;
			return pArray;
		}
		public static int sqlite3AtoF(sbyte* z, double* pResult, int length, byte enc)
		{
			int incr = 0;
			sbyte* zEnd;
			int sign = (int)(1);
			long s = (long)(0);
			int d = (int)(0);
			int esign = (int)(1);
			int e = (int)(0);
			int eValid = (int)(1);
			double result = 0;
			int nDigit = (int)(0);
			int eType = (int)(1);
			*pResult = (double)(0.0);
			if ((length) == (0))
				return (int)(0);
			if ((enc) == (1))
			{
				incr = (int)(1);
				zEnd = z + length;
			}
			else
			{
				int i = 0;
				incr = (int)(2);
				length &= (int)(~1);
				for (i = (int)(3 - enc); ((i) < (length)) && ((z[i]) == (0)); i += (int)(2))
				{
				}

				if ((i) < (length))
					eType = (int)(-100);
				zEnd = &z[i ^ 1];
				z += (enc & 1);
			}

			while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x01) != 0))
			{
				z += incr;
			}

			if ((z) >= (zEnd))
				return (int)(0);
			if ((*z) == (45))
			{
				sign = (int)(-1);
				z += incr;
			}
			else if ((*z) == (43))
			{
				z += incr;
			}

			while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
			{
				s = (long)(s * 10 + (*z - 48));
				z += incr;
				nDigit++;
				if ((s) >= (((0xffffffff | (((long)(0x7fffffff)) << 32)) - 9) / 10))
				{
					while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
					{
						z += incr;
						d++;
					}
				}
			}

			if ((z) >= (zEnd))
				goto do_atof_calc;
			if ((*z) == (46))
			{
				z += incr;
				eType++;
				while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
				{
					if ((s) < (((0xffffffff | (((long)(0x7fffffff)) << 32)) - 9) / 10))
					{
						s = (long)(s * 10 + (*z - 48));
						d--;
						nDigit++;
					}

					z += incr;
				}
			}

			if ((z) >= (zEnd))
				goto do_atof_calc;
			if (((*z) == (101)) || ((*z) == (69)))
			{
				z += incr;
				eValid = (int)(0);
				eType++;
				if ((z) >= (zEnd))
					goto do_atof_calc;
				if ((*z) == (45))
				{
					esign = (int)(-1);
					z += incr;
				}
				else if ((*z) == (43))
				{
					z += incr;
				}

				while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
				{
					e = (int)((e) < (10000) ? (e * 10 + (*z - 48)) : 10000);
					z += incr;
					eValid = (int)(1);
				}
			}

			while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x01) != 0))
			{
				z += incr;
			}

		do_atof_calc:
			; e = (int)((e * esign) + d);
			if ((e) < (0))
			{
				esign = (int)(-1);
				e *= (int)(-1);
			}
			else
			{
				esign = (int)(1);
			}

			if ((s) == (0))
			{
				result = (double)((sign) < (0) ? -(double)(0) : (double)(0));
			}
			else
			{
				while ((e) > (0))
				{
					if ((esign) > (0))
					{
						if ((s) >= ((0xffffffff | (((long)(0x7fffffff)) << 32)) / 10))
							break;
						s *= (long)(10);
					}
					else
					{
						if (s % 10 != 0)
							break;
						s /= (long)(10);
					}

					e--;
				}

				s = (long)((sign) < (0) ? -s : s);
				if ((e) == (0))
				{
					result = ((double)(s));
				}
				else
				{
					if ((e) > (307))
					{
						if ((e) < (342))
						{
							double scale = (double)(sqlite3Pow10((int)(e - 308)));
							if ((esign) < (0))
							{
								result = (double)(s / scale);
								result /= (double)(1.0e+308);
							}
							else
							{
								result = (double)(s * scale);
								result *= (double)(1.0e+308);
							}
						}
						else
						{
							if ((esign) < (0))
							{
								result = (double)(0.0 * s);
							}
							else
							{
								result = (double)(((float)(1e+300 * 1e+300)) * s);
							}
						}
					}
					else
					{
						double scale = (double)(sqlite3Pow10((int)(e)));
						if ((esign) < (0))
						{
							result = (double)(s / scale);
						}
						else
						{
							result = (double)(s * scale);
						}
					}
				}
			}

			*pResult = (double)(result);
			if (((((z) == (zEnd)) && ((nDigit) > (0))) && ((eValid) != 0)) && ((eType) > (0)))
			{
				return (int)(eType);
			}
			else if ((((eType) >= (2)) && (((eType) == (3)) || ((eValid) != 0))) && ((nDigit) > (0)))
			{
				return (int)(-1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static int sqlite3Atoi(sbyte* z)
		{
			int x = (int)(0);
			sqlite3GetInt32(z, &x);
			return (int)(x);
		}
		public static int sqlite3Atoi64(sbyte* zNum, long* pNum, int length, byte enc)
		{
			int incr = 0;
			ulong u = (ulong)(0);
			int neg = (int)(0);
			int i = 0;
			int c = (int)(0);
			int nonNum = (int)(0);
			int rc = 0;
			sbyte* zStart;
			sbyte* zEnd = zNum + length;
			if ((enc) == (1))
			{
				incr = (int)(1);
			}
			else
			{
				incr = (int)(2);
				length &= (int)(~1);
				for (i = (int)(3 - enc); ((i) < (length)) && ((zNum[i]) == (0)); i += (int)(2))
				{
				}

				nonNum = (int)((i) < (length) ? 1 : 0);
				zEnd = &zNum[i ^ 1];
				zNum += (enc & 1);
			}

			while (((zNum) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*zNum)] & 0x01) != 0))
			{
				zNum += incr;
			}

			if ((zNum) < (zEnd))
			{
				if ((*zNum) == (45))
				{
					neg = (int)(1);
					zNum += incr;
				}
				else if ((*zNum) == (43))
				{
					zNum += incr;
				}
			}

			zStart = zNum;
			while (((zNum) < (zEnd)) && ((zNum[0]) == (48)))
			{
				zNum += incr;
			}

			for (i = (int)(0); (((&zNum[i]) < (zEnd)) && ((c = (int)(zNum[i])) >= (48))) && ((c) <= (57)); i += (int)(incr))
			{
				u = (ulong)(u * 10 + c - 48);
			}

			if ((u) > (0xffffffff | (((long)(0x7fffffff)) << 32)))
			{
				*pNum = (long)((neg) != 0 ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) : (0xffffffff | (((long)(0x7fffffff)) << 32)));
			}
			else if ((neg) != 0)
			{
				*pNum = (long)(-(long)(u));
			}
			else
			{
				*pNum = ((long)(u));
			}

			rc = (int)(0);
			if (((i) == (0)) && ((zStart) == (zNum)))
			{
				rc = (int)(-1);
			}
			else if ((nonNum) != 0)
			{
				rc = (int)(1);
			}
			else if ((&zNum[i]) < (zEnd))
			{
				int jj = (int)(i);
				do
				{
					if ((sqlite3CtypeMap[(byte)(zNum[jj])] & 0x01) == 0)
					{
						rc = (int)(1);
						break;
					}

					jj += (int)(incr);
				}
				while ((&zNum[jj]) < (zEnd));
			}

			if ((i) < (19 * incr))
			{
				return (int)(rc);
			}
			else
			{
				c = (int)((i) > (19 * incr) ? 1 : compare2pow63(zNum, (int)(incr)));
				if ((c) < (0))
				{
					return (int)(rc);
				}
				else
				{
					*pNum = (long)((neg) != 0 ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) : (0xffffffff | (((long)(0x7fffffff)) << 32)));
					if ((c) > (0))
					{
						return (int)(2);
					}
					else
					{
						return (int)((neg) != 0 ? rc : 3);
					}
				}
			}
		}
		public static void sqlite3BeginBenignMalloc()
		{
			if ((sqlite3Hooks.xBenignBegin) != null)
			{
				sqlite3Hooks.xBenignBegin();
			}
		}
		public static int sqlite3BitvecBuiltinTest(int sz, int* aOp)
		{
			Bitvec* pBitvec = null;
			byte* pV = null;
			int rc = (int)(-1);
			int i = 0; int nx = 0; int pc = 0; int op = 0;
			void* pTmpSpace;
			pBitvec = sqlite3BitvecCreate((uint)(sz));
			pV = sqlite3MallocZero((ulong)((sz + 7) / 8 + 1));
			pTmpSpace = sqlite3_malloc64((ulong)(512));
			if ((((pBitvec) == (null)) || ((pV) == (null))) || ((pTmpSpace) == (null)))
				goto bitvec_end;
			sqlite3BitvecSet(null, (uint)(1));
			sqlite3BitvecClear(null, (uint)(1), pTmpSpace);
			pc = (int)(i = (int)(0));
			while ((op = (int)(aOp[pc])) != 0)
			{
				switch (op)
				{
					case 1:
					case 2:
					case 5:
						{
							nx = (int)(4);
							i = (int)(aOp[pc + 2] - 1);
							aOp[pc + 2] += (int)(aOp[pc + 3]);
							break;
						}

					case 3:
					case 4:
					default:
						{
							nx = (int)(2);
							sqlite3_randomness((int)(sizeof(int)), &i);
							break;
						}
				}

				if ((--aOp[pc + 1]) > (0))
					nx = (int)(0);
				pc += (int)(nx);
				i = (int)((i & 0x7fffffff) % sz);
				if ((op & 1) != 0)
				{
					pV[(i + 1) >> 3] |= (byte)(1 << ((i + 1) & 7));
					if (op != 5)
					{
						if ((sqlite3BitvecSet(pBitvec, (uint)(i + 1))) != 0)
							goto bitvec_end;
					}
				}
				else
				{
					pV[(i + 1) >> 3] &= (byte)(~(1 << ((i + 1) & 7)));
					sqlite3BitvecClear(pBitvec, (uint)(i + 1), pTmpSpace);
				}
			}

			rc = (int)(sqlite3BitvecTest(null, (uint)(0)) + sqlite3BitvecTest(pBitvec, (uint)(sz + 1)) + sqlite3BitvecTest(pBitvec, (uint)(0)) + (sqlite3BitvecSize(pBitvec) - sz));
			for (i = (int)(1); (i) <= (sz); i++)
			{
				if (((pV[i >> 3] & (1 << (i & 7))) != 0) != sqlite3BitvecTest(pBitvec, (uint)(i)))
				{
					rc = (int)(i);
					break;
				}
			}

		bitvec_end:
			; sqlite3_free(pTmpSpace);
			sqlite3_free(pV);
			sqlite3BitvecDestroy(pBitvec);
			return (int)(rc);
		}
		public static Bitvec* sqlite3BitvecCreate(uint iSize)
		{
			Bitvec* p;
			p = sqlite3MallocZero((ulong)(sizeof(Bitvec)));
			if ((p) != null)
			{
				p->iSize = (uint)(iSize);
			}

			return p;
		}
		public static int sqlite3BtreeCursorSize()
		{
			return (int)(((sizeof(BtCursor)) + 7) & ~7);
		}
		public static BtCursor sqlite3BtreeFakeValidCursor()
		{
			return (BtCursor)(&sqlite3BtreeFakeValidCursor_fakeCursor);
		}
		public static sbyte* sqlite3BtreeGetFilename(Btree p)
		{
			return sqlite3PagerFilename(p.pBt.pPager, (int)(1));
		}
		public static sbyte* sqlite3BtreeGetJournalname(Btree p)
		{
			return sqlite3PagerJournalname(p.pBt.pPager);
		}
		public static sbyte* sqlite3BtreeIntegrityCheck(sqlite3 db, Btree p, uint* aRoot, int nRoot, int mxErr, int* pnErr)
		{
			uint i = 0;
			IntegrityCk sCheck = new IntegrityCk();
			BtShared pBt = p.pBt;
			ulong savedDbFlags = (ulong)(pBt.db.flags);
			sbyte* zErr = stackalloc sbyte[100];
			int bPartial = (int)(0);
			int bCkFreelist = (int)(1);
			if ((aRoot[0]) == (0))
			{
				bPartial = (int)(1);
				if (aRoot[1] != 1)
					bCkFreelist = (int)(0);
			}

			sqlite3BtreeEnter(p);
			sCheck.db = db;
			sCheck.pBt = pBt;
			sCheck.pPager = pBt.pPager;
			sCheck.nPage = (uint)(btreePagecount(sCheck.pBt));
			sCheck.mxErr = (int)(mxErr);
			sCheck.nErr = (int)(0);
			sCheck.bOomFault = (int)(0);
			sCheck.zPfx = null;
			sCheck.v1 = (uint)(0);
			sCheck.v2 = (int)(0);
			sCheck.aPgRef = null;
			sCheck.heap = null;
			sqlite3StrAccumInit(sCheck.errMsg, null, zErr, (int)(100 * sizeof(sbyte)), (int)(1000000000));
			sCheck.errMsg.printfFlags = (byte)(0x01);
			if ((sCheck.nPage) == (0))
			{
				goto integrity_ck_cleanup;
			}

			sCheck.aPgRef = sqlite3MallocZero((ulong)((sCheck.nPage / 8) + 1));
			if (sCheck.aPgRef == null)
			{
				sCheck.bOomFault = (int)(1);
				goto integrity_ck_cleanup;
			}

			sCheck.heap = (uint*)(sqlite3PageMalloc((int)(pBt.pageSize)));
			if ((sCheck.heap) == (null))
			{
				sCheck.bOomFault = (int)(1);
				goto integrity_ck_cleanup;
			}

			i = (uint)((sqlite3PendingByte / ((pBt).pageSize)) + 1);
			if ((i) <= (sCheck.nPage))
				setPageReferenced(sCheck, (uint)(i));
			if ((bCkFreelist) != 0)
			{
				sCheck.zPfx = "Main freelist: ";
				checkList(sCheck, (int)(1), (uint)(sqlite3Get4byte(&pBt.pPage1.aData[32])), (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36])));
				sCheck.zPfx = null;
			}

			if (bPartial == 0)
			{
				if ((pBt.autoVacuum) != 0)
				{
					uint mx = (uint)(0);
					uint mxInHdr = 0;
					for (i = (uint)(0); ((int)(i)) < (nRoot); i++)
					{
						if ((mx) < (aRoot[i]))
							mx = (uint)(aRoot[i]);
					}

					mxInHdr = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[52]));
					if (mx != mxInHdr)
					{
						checkAppendMsg(sCheck, "max rootpage (%d) disagrees with header (%d)", (uint)(mx), (uint)(mxInHdr));
					}
				}
				else if (sqlite3Get4byte(&pBt.pPage1.aData[64]) != 0)
				{
					checkAppendMsg(sCheck, "incremental_vacuum enabled with a max rootpage of zero");
				}
			}

			pBt.db.flags &= (ulong)(~(ulong)(0x00200000));
			for (i = (uint)(0); (((int)(i)) < (nRoot)) && ((sCheck.mxErr) != 0); i++)
			{
				long notUsed = 0;
				if ((aRoot[i]) == (0))
					continue;
				if ((((pBt.autoVacuum) != 0) && ((aRoot[i]) > (1))) && (bPartial == 0))
				{
					checkPtrmap(sCheck, (uint)(aRoot[i]), (byte)(1), (uint)(0));
				}

				checkTreePage(sCheck, (uint)(aRoot[i]), &notUsed, (long)(0xffffffff | (((long)(0x7fffffff)) << 32)));
			}

			pBt.db.flags = (ulong)(savedDbFlags);
			if (bPartial == 0)
			{
				for (i = (uint)(1); ((i) <= (sCheck.nPage)) && ((sCheck.mxErr) != 0); i++)
				{
					if (((getPageReferenced(sCheck, (uint)(i))) == (0)) && ((ptrmapPageno(pBt, (uint)(i)) != i) || (pBt.autoVacuum == 0)))
					{
						checkAppendMsg(sCheck, "Page %d is never used", (uint)(i));
					}

					if ((getPageReferenced(sCheck, (uint)(i)) != 0) && (((ptrmapPageno(pBt, (uint)(i))) == (i)) && ((pBt.autoVacuum) != 0)))
					{
						checkAppendMsg(sCheck, "Pointer map page %d is referenced", (uint)(i));
					}
				}
			}

		integrity_ck_cleanup:
			; sqlite3PageFree(sCheck.heap);
			sqlite3_free(sCheck.aPgRef);
			if ((sCheck.bOomFault) != 0)
			{
				sqlite3_str_reset(sCheck.errMsg);
				sCheck.nErr++;
			}

			*pnErr = (int)(sCheck.nErr);
			if ((sCheck.nErr) == (0))
				sqlite3_str_reset(sCheck.errMsg);
			sqlite3BtreeLeave(p);
			return sqlite3StrAccumFinish(sCheck.errMsg);
		}
		public static void* sqlite3BtreePayloadFetch(BtCursor pCur, uint* pAmt)
		{
			return fetchPayload(pCur, pAmt);
		}
		public static void* sqlite3BtreeSchema(Btree p, int nBytes, delegate17 xFree)
		{
			BtShared pBt = p.pBt;
			sqlite3BtreeEnter(p);
			if ((pBt.pSchema == null) && ((nBytes) != 0))
			{
				pBt.pSchema = sqlite3DbMallocZero(null, (ulong)(nBytes));
				pBt.xFreeSchema = xFree;
			}

			sqlite3BtreeLeave(p);
			return pBt.pSchema;
		}
		public static int sqlite3CantopenError(int lineno)
		{
			return (int)(sqlite3ReportError((int)(14), (int)(lineno), "cannot open file"));
		}
		public static sbyte* sqlite3ColumnColl(Column* pCol)
		{
			sbyte* z;
			if ((pCol->colFlags & 0x0200) == (0))
				return null;
			z = pCol->zCnName;
			while ((*z) != 0)
			{
				z++;
			}

			if ((pCol->colFlags & 0x0004) != 0)
			{
				do
				{
					z++;
				}
				while ((*z) != 0);
			}

			return z + 1;
		}
		public static sbyte* sqlite3ColumnType(Column* pCol, sbyte* zDflt)
		{
			if ((pCol->colFlags & 0x0004) != 0)
			{
				return pCol->zCnName + CRuntime.strlen(pCol->zCnName) + 1;
			}
			else if ((pCol->eCType) != 0)
			{
				return sqlite3StdType[pCol->eCType - 1];
			}
			else
			{
				return zDflt;
			}
		}
		public static sbyte** sqlite3CompileOptions(int* pnOpt)
		{
			*pnOpt = (int)(36 * sizeof(sbyte) / sizeof(sbyte*));
			return sqlite3azCompileOpt;
		}
		public static int sqlite3CorruptError(int lineno)
		{
			return (int)(sqlite3ReportError((int)(11), (int)(lineno), "database corruption"));
		}
		public static void* sqlite3DbMallocRaw(sqlite3 db, ulong n)
		{
			void* p;
			if ((db) != null)
				return sqlite3DbMallocRawNN(db, (ulong)(n));
			p = sqlite3Malloc((ulong)(n));
			return p;
		}
		public static void* sqlite3DbMallocRawNN(sqlite3 db, ulong n)
		{
			LookasideSlot* pBuf;
			if ((n) > (db.lookaside.sz))
			{
				if (db.lookaside.bDisable == 0)
				{
					db.lookaside.anStat[1]++;
				}
				else if ((db.mallocFailed) != 0)
				{
					return null;
				}

				return dbMallocRawFinish(db, (ulong)(n));
			}

			if ((n) <= (128))
			{
				if ((pBuf = db.lookaside.pSmallFree) != null)
				{
					db.lookaside.pSmallFree = pBuf->pNext;
					db.lookaside.anStat[0]++;
					return (void*)(pBuf);
				}
				else if ((pBuf = db.lookaside.pSmallInit) != null)
				{
					db.lookaside.pSmallInit = pBuf->pNext;
					db.lookaside.anStat[0]++;
					return (void*)(pBuf);
				}
			}

			if ((pBuf = db.lookaside.pFree) != null)
			{
				db.lookaside.pFree = pBuf->pNext;
				db.lookaside.anStat[0]++;
				return (void*)(pBuf);
			}
			else if ((pBuf = db.lookaside.pInit) != null)
			{
				db.lookaside.pInit = pBuf->pNext;
				db.lookaside.anStat[0]++;
				return (void*)(pBuf);
			}
			else
			{
				db.lookaside.anStat[2]++;
			}

			return dbMallocRawFinish(db, (ulong)(n));
		}
		public static void* sqlite3DbMallocZero(sqlite3 db, ulong n)
		{
			void* p;
			p = sqlite3DbMallocRaw(db, (ulong)(n));
			if ((p) != null)
				CRuntime.memset(p, (int)(0), (ulong)(n));
			return p;
		}
		public static void* sqlite3DbRealloc(sqlite3 db, void* p, ulong n)
		{
			if ((p) == (null))
				return sqlite3DbMallocRawNN(db, (ulong)(n));
			if (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))
			{
				if (((ulong)(p)) >= ((ulong)(db.lookaside.pMiddle)))
				{
					if ((n) <= (128))
						return p;
				}
				else if (((ulong)(p)) >= ((ulong)(db.lookaside.pStart)))
				{
					if ((n) <= (db.lookaside.szTrue))
						return p;
				}
			}

			return dbReallocFinish(db, p, (ulong)(n));
		}
		public static void* sqlite3DbReallocOrFree(sqlite3 db, void* p, ulong n)
		{
			void* pNew;
			pNew = sqlite3DbRealloc(db, p, (ulong)(n));
			if (pNew == null)
			{
				sqlite3DbFree(db, p);
			}

			return pNew;
		}
		public static sbyte* sqlite3DbSpanDup(sqlite3 db, sbyte* zStart, sbyte* zEnd)
		{
			int n = 0;
			while ((sqlite3CtypeMap[(byte)(zStart[0])] & 0x01) != 0)
			{
				zStart++;
			}

			n = ((int)(zEnd - zStart));
			while (((n) > (0)) && ((sqlite3CtypeMap[(byte)(zStart[n - 1])] & 0x01) != 0))
			{
				n--;
			}

			return sqlite3DbStrNDup(db, zStart, (ulong)(n));
		}
		public static sbyte* sqlite3DbStrDup(sqlite3 db, sbyte* z)
		{
			sbyte* zNew;
			ulong n = 0;
			if ((z) == (null))
			{
				return null;
			}

			n = (ulong)(CRuntime.strlen(z) + 1);
			zNew = sqlite3DbMallocRaw(db, (ulong)(n));
			if ((zNew) != null)
			{
				CRuntime.memcpy(zNew, z, (ulong)(n));
			}

			return zNew;
		}
		public static sbyte* sqlite3DbStrNDup(sqlite3 db, sbyte* z, ulong n)
		{
			sbyte* zNew;
			zNew = (z) != 0 ? sqlite3DbMallocRawNN(db, (ulong)(n + 1)) : null;
			if ((zNew) != null)
			{
				CRuntime.memcpy(zNew, z, (ulong)(n));
				zNew[n] = (sbyte)(0);
			}

			return zNew;
		}
		public static int sqlite3DecOrHexToI64(sbyte* z, long* pOut)
		{
			if (((z[0]) == (48)) && (((z[1]) == (120)) || ((z[1]) == (88))))
			{
				ulong u = (ulong)(0);
				int i = 0;
				int k = 0;
				for (i = (int)(2); (z[i]) == (48); i++)
				{
				}

				for (k = (int)(i); (sqlite3CtypeMap[(byte)(z[k])] & 0x08); k++)
				{
					u = (ulong)(u * 16 + sqlite3HexToInt((int)(z[k])));
				}

				CRuntime.memcpy(pOut, &u, (ulong)(8));
				return (int)((((z[k]) == (0)) && ((k - i) <= (16))) ? 0 : 2);
			}
			else
			{
				return (int)(sqlite3Atoi64(z, pOut, (int)(sqlite3Strlen30(z)), (byte)(1)));
			}
		}
		public static sqlite3_mutex_methods sqlite3DefaultMutex()
		{
			return sqlite3DefaultMutex_sMutex;
		}
		public static void sqlite3Dequote(sbyte* z)
		{
			sbyte quote = 0;
			int i = 0; int j = 0;
			if ((z) == (null))
				return;
			quote = (sbyte)(z[0]);
			if ((sqlite3CtypeMap[(byte)(quote)] & 0x80) == 0)
				return;
			if ((quote) == (91))
				quote = (sbyte)(93);
			for (i = (int)(1), j = (int)(0); ; i++)
			{
				if ((z[i]) == (quote))
				{
					if ((z[i + 1]) == (quote))
					{
						z[j++] = (sbyte)(quote);
						i++;
					}
					else
					{
						break;
					}
				}
				else
				{
					z[j++] = (sbyte)(z[i]);
				}
			}

			z[j] = (sbyte)(0);
		}
		public static void sqlite3EndBenignMalloc()
		{
			if ((sqlite3Hooks.xBenignEnd) != null)
			{
				sqlite3Hooks.xBenignEnd();
			}
		}
		public static sbyte* sqlite3ErrStr(int rc)
		{
			sbyte* zErr = "unknown error";
			switch (rc)
			{
				case (4 | (2 << 8)):
					{
						zErr = "abort due to ROLLBACK";
						break;
					}

				case 100:
					{
						zErr = "another row available";
						break;
					}

				case 101:
					{
						zErr = "no more rows available";
						break;
					}

				default:
					{
						rc &= (int)(0xff);
						if ((((rc) >= (0)) && ((rc) < ((int)(29 * sizeof(sbyte) / sizeof(sbyte*))))) && (sqlite3ErrStr_aMsg[rc] != null))
						{
							zErr = sqlite3ErrStr_aMsg[rc];
						}

						break;
					}
			}

			return zErr;
		}
		public static int sqlite3FaultSim(int iTest)
		{
			delegate20 xCallback = sqlite3Config.xTestCallback;
			return (int)(xCallback ? xCallback((int)(iTest)) : 0);
		}
		public static FuncDef sqlite3FunctionSearch(int h, sbyte* zFunc)
		{
			FuncDef p;
			for (p = sqlite3BuiltinFunctions.a[h]; p; p = p.u.pHash)
			{
				if ((sqlite3StrICmp(p.zName, zFunc)) == (0))
				{
					return p;
				}
			}

			return null;
		}
		public static uint sqlite3Get4byte(byte* p)
		{
			uint x = 0;
			CRuntime.memcpy(&x, p, (ulong)(4));
			return (uint)(_byteswap_ulong((uint)(x)));
		}
		public static byte sqlite3GetBoolean(sbyte* z, byte dflt)
		{
			return (byte)(getSafetyLevel(z, (int)(1), (byte)(dflt)) != 0);
		}
		public static int sqlite3GetInt32(sbyte* zNum, int* pValue)
		{
			long v = (long)(0);
			int i = 0; int c = 0;
			int neg = (int)(0);
			if ((zNum[0]) == (45))
			{
				neg = (int)(1);
				zNum++;
			}
			else if ((zNum[0]) == (43))
			{
				zNum++;
			}
			else if ((((zNum[0]) == (48)) && (((zNum[1]) == (120)) || ((zNum[1]) == (88)))) && ((sqlite3CtypeMap[(byte)(zNum[2])] & 0x08) != 0))
			{
				uint u = (uint)(0);
				zNum += 2;
				while ((zNum[0]) == (48))
				{
					zNum++;
				}

				for (i = (int)(0); ((sqlite3CtypeMap[(byte)(zNum[i])] & 0x08) != 0) && ((i) < (8)); i++)
				{
					u = (uint)(u * 16 + sqlite3HexToInt((int)(zNum[i])));
				}

				if (((u & 0x80000000) == (0)) && ((sqlite3CtypeMap[(byte)(zNum[i])] & 0x08) == (0)))
				{
					CRuntime.memcpy(pValue, &u, (ulong)(4));
					return (int)(1);
				}
				else
				{
					return (int)(0);
				}
			}

			if ((sqlite3CtypeMap[(byte)(zNum[0])] & 0x04) == 0)
				return (int)(0);
			while ((zNum[0]) == (48))
			{
				zNum++;
			}

			for (i = (int)(0); (((i) < (11)) && ((c = (int)(zNum[i] - 48)) >= (0))) && ((c) <= (9)); i++)
			{
				v = (long)(v * 10 + c);
			}

			if ((i) > (10))
			{
				return (int)(0);
			}

			if ((v - neg) > (2147483647))
			{
				return (int)(0);
			}

			if ((neg) != 0)
			{
				v = (long)(-v);
			}

			*pValue = ((int)(v));
			return (int)(1);
		}
		public static int sqlite3GetToken(byte* z, int* tokenType)
		{
			int i = 0; int c = 0;
			switch (aiClass[*z])
			{
				case 7:
					{
						for (i = (int)(1); (sqlite3CtypeMap[(z[i])] & 0x01); i++)
						{
						}

						*tokenType = (int)(183);
						return (int)(i);
					}

				case 11:
					{
						if ((z[1]) == (45))
						{
							for (i = (int)(2); ((c = (int)(z[i])) != 0) && (c != 10); i++)
							{
							}

							*tokenType = (int)(183);
							return (int)(i);
						}
						else if ((z[1]) == (62))
						{
							*tokenType = (int)(112);
							return (int)(2 + ((z[2]) == (62)));
						}

						*tokenType = (int)(107);
						return (int)(1);
					}

				case 17:
					{
						*tokenType = (int)(22);
						return (int)(1);
					}

				case 18:
					{
						*tokenType = (int)(23);
						return (int)(1);
					}

				case 19:
					{
						*tokenType = (int)(1);
						return (int)(1);
					}

				case 20:
					{
						*tokenType = (int)(106);
						return (int)(1);
					}

				case 21:
					{
						*tokenType = (int)(108);
						return (int)(1);
					}

				case 16:
					{
						if ((z[1] != 42) || ((z[2]) == (0)))
						{
							*tokenType = (int)(109);
							return (int)(1);
						}

						for (i = (int)(3), c = (int)(z[2]); ((c != 42) || (z[i] != 47)) && ((c = (int)(z[i])) != 0); i++)
						{
						}

						if ((c) != 0)
							i++;
						*tokenType = (int)(183);
						return (int)(i);
					}

				case 22:
					{
						*tokenType = (int)(110);
						return (int)(1);
					}

				case 14:
					{
						*tokenType = (int)(53);
						return (int)(1 + ((z[1]) == (61)));
					}

				case 12:
					{
						if ((c = (int)(z[1])) == (61))
						{
							*tokenType = (int)(55);
							return (int)(2);
						}
						else if ((c) == (62))
						{
							*tokenType = (int)(52);
							return (int)(2);
						}
						else if ((c) == (60))
						{
							*tokenType = (int)(104);
							return (int)(2);
						}
						else
						{
							*tokenType = (int)(56);
							return (int)(1);
						}
					}

				case 13:
					{
						if ((c = (int)(z[1])) == (61))
						{
							*tokenType = (int)(57);
							return (int)(2);
						}
						else if ((c) == (62))
						{
							*tokenType = (int)(105);
							return (int)(2);
						}
						else
						{
							*tokenType = (int)(54);
							return (int)(1);
						}
					}

				case 15:
					{
						if (z[1] != 61)
						{
							*tokenType = (int)(184);
							return (int)(1);
						}
						else
						{
							*tokenType = (int)(52);
							return (int)(2);
						}
					}

				case 10:
					{
						if (z[1] != 124)
						{
							*tokenType = (int)(103);
							return (int)(1);
						}
						else
						{
							*tokenType = (int)(111);
							return (int)(2);
						}
					}

				case 23:
					{
						*tokenType = (int)(25);
						return (int)(1);
					}

				case 24:
					{
						*tokenType = (int)(102);
						return (int)(1);
					}

				case 25:
					{
						*tokenType = (int)(114);
						return (int)(1);
					}

				case 8:
					{
						int delim = (int)(z[0]);
						for (i = (int)(1); (c = (int)(z[i])) != 0; i++)
						{
							if ((c) == (delim))
							{
								if ((z[i + 1]) == (delim))
								{
									i++;
								}
								else
								{
									break;
								}
							}
						}

						if ((c) == (39))
						{
							*tokenType = (int)(117);
							return (int)(i + 1);
						}
						else if (c != 0)
						{
							*tokenType = (int)(59);
							return (int)(i + 1);
						}
						else
						{
							*tokenType = (int)(184);
							return (int)(i);
						}
					}

				case 26:
					{
						if ((sqlite3CtypeMap[(z[1])] & 0x04) == 0)
						{
							*tokenType = (int)(141);
							return (int)(1);
						}
					}

				case 3:
					{
						*tokenType = (int)(155);
						if ((((z[0]) == (48)) && (((z[1]) == (120)) || ((z[1]) == (88)))) && ((sqlite3CtypeMap[(z[2])] & 0x08) != 0))
						{
							for (i = (int)(3); (sqlite3CtypeMap[(z[i])] & 0x08); i++)
							{
							}

							return (int)(i);
						}

						for (i = (int)(0); (sqlite3CtypeMap[(z[i])] & 0x04); i++)
						{
						}

						if ((z[i]) == (46))
						{
							i++;
							while ((sqlite3CtypeMap[(z[i])] & 0x04) != 0)
							{
								i++;
							}

							*tokenType = (int)(153);
						}

						if ((((z[i]) == (101)) || ((z[i]) == (69))) && (((sqlite3CtypeMap[(z[i + 1])] & 0x04) != 0) || ((((z[i + 1]) == (43)) || ((z[i + 1]) == (45))) && ((sqlite3CtypeMap[(z[i + 2])] & 0x04) != 0))))
						{
							i += (int)(2);
							while ((sqlite3CtypeMap[(z[i])] & 0x04) != 0)
							{
								i++;
							}

							*tokenType = (int)(153);
						}

						while (((sqlite3CtypeMap[z[i]] & 0x46) != 0))
						{
							*tokenType = (int)(184);
							i++;
						}

						return (int)(i);
					}

				case 9:
					{
						for (i = (int)(1), c = (int)(z[0]); (c != 93) && ((c = (int)(z[i])) != 0); i++)
						{
						}

						*tokenType = (int)((c) == (93) ? 59 : 184);
						return (int)(i);
					}

				case 6:
					{
						*tokenType = (int)(156);
						for (i = (int)(1); (sqlite3CtypeMap[(z[i])] & 0x04); i++)
						{
						}

						return (int)(i);
					}

				case 4:
				case 5:
					{
						int n = (int)(0);
						*tokenType = (int)(156);
						for (i = (int)(1); (c = (int)(z[i])) != 0; i++)
						{
							if (((sqlite3CtypeMap[(byte)(c)] & 0x46) != 0))
							{
								n++;
							}
							else if (((c) == (40)) && ((n) > (0)))
							{
								do
								{
									i++;
								}
								while ((((c = (int)(z[i])) != 0) && ((sqlite3CtypeMap[(byte)(c)] & 0x01) == 0)) && (c != 41));
								if ((c) == (41))
								{
									i++;
								}
								else
								{
									*tokenType = (int)(184);
								}

								break;
							}
							else if (((c) == (58)) && ((z[i + 1]) == (58)))
							{
								i++;
							}
							else
							{
								break;
							}
						}

						if ((n) == (0))
							*tokenType = (int)(184);
						return (int)(i);
					}

				case 1:
					{
						for (i = (int)(1); (aiClass[z[i]]) <= (2); i++)
						{
						}

						if (((sqlite3CtypeMap[z[i]] & 0x46) != 0))
						{
							i++;
							break;
						}

						*tokenType = (int)(59);
						return (int)(keywordCode((sbyte*)(z), (int)(i), tokenType));
					}

				case 0:
					{
						if ((z[1]) == (39))
						{
							*tokenType = (int)(154);
							for (i = (int)(2); (sqlite3CtypeMap[(z[i])] & 0x08); i++)
							{
							}

							if ((z[i] != 39) || (i % 2))
							{
								*tokenType = (int)(184);
								while (((z[i]) != 0) && (z[i] != 39))
								{
									i++;
								}
							}

							if ((z[i]) != 0)
								i++;
							return (int)(i);
						}
					}

				case 2:
				case 27:
					{
						i = (int)(1);
						break;
					}

				case 30:
					{
						if (((z[1]) == (0xbb)) && ((z[2]) == (0xbf)))
						{
							*tokenType = (int)(183);
							return (int)(3);
						}

						i = (int)(1);
						break;
					}

				case 29:
					{
						*tokenType = (int)(184);
						return (int)(0);
					}

				default:
					{
						*tokenType = (int)(184);
						return (int)(1);
					}
			}

			while (((sqlite3CtypeMap[z[i]] & 0x46) != 0))
			{
				i++;
			}

			*tokenType = (int)(59);
			return (int)(i);
		}
		public static int sqlite3GetUInt32(sbyte* z, uint* pI)
		{
			ulong v = (ulong)(0);
			int i = 0;
			for (i = (int)(0); (sqlite3CtypeMap[(byte)(z[i])] & 0x04); i++)
			{
				v = (ulong)(v * 10 + z[i] - 48);
				if ((v) > (4294967296)) { *pI = (uint)(0); return (int)(0); }
			}

			if (((i) == (0)) || (z[i] != 0))
			{
				*pI = (uint)(0);
				return (int)(0);
			}


			*pI = ((uint)(v));
			return (int)(1);
		}
		public static byte sqlite3GetVarint(byte* p, ulong* v)
		{
			uint a = 0; uint b = 0; uint s = 0;
			if ((((sbyte*)(p))[0]) >= (0))
			{
				*v = (ulong)(*p);
				return (byte)(1);
			}

			if ((((sbyte*)(p))[1]) >= (0))
			{
				*v = (ulong)(((uint)(p[0] & 0x7f) << 7) | p[1]);
				return (byte)(2);
			}

			a = (uint)(((uint)(p[0])) << 14);
			b = (uint)(p[1]);
			p += 2;
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				a &= (uint)(0x001fc07f);
				b &= (uint)(0x7f);
				b = (uint)(b << 7);
				a |= (uint)(b);
				*v = (ulong)(a);
				return (byte)(3);
			}

			a &= (uint)(0x001fc07f);
			p++;
			b = (uint)(b << 14);
			b |= (uint)(*p);
			if ((b & 0x80) == 0)
			{
				b &= (uint)(0x001fc07f);
				a = (uint)(a << 7);
				a |= (uint)(b);
				*v = (ulong)(a);
				return (byte)(4);
			}

			b &= (uint)(0x001fc07f);
			s = (uint)(a);
			p++;
			a = (uint)(a << 14);
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				b = (uint)(b << 7);
				a |= (uint)(b);
				s = (uint)(s >> 18);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(5);
			}

			s = (uint)(s << 7);
			s |= (uint)(b);
			p++;
			b = (uint)(b << 14);
			b |= (uint)(*p);
			if ((b & 0x80) == 0)
			{
				a &= (uint)(0x001fc07f);
				a = (uint)(a << 7);
				a |= (uint)(b);
				s = (uint)(s >> 18);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(6);
			}

			p++;
			a = (uint)(a << 14);
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				a &= (uint)(0xf01fc07f);
				b &= (uint)(0x001fc07f);
				b = (uint)(b << 7);
				a |= (uint)(b);
				s = (uint)(s >> 11);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(7);
			}

			a &= (uint)(0x001fc07f);
			p++;
			b = (uint)(b << 14);
			b |= (uint)(*p);
			if ((b & 0x80) == 0)
			{
				b &= (uint)(0xf01fc07f);
				a = (uint)(a << 7);
				a |= (uint)(b);
				s = (uint)(s >> 4);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(8);
			}

			p++;
			a = (uint)(a << 15);
			a |= (uint)(*p);
			b &= (uint)(0x001fc07f);
			b = (uint)(b << 8);
			a |= (uint)(b);
			s = (uint)(s << 4);
			b = (uint)(p[-4]);
			b &= (uint)(0x7f);
			b = (uint)(b >> 3);
			s |= (uint)(b);
			*v = (ulong)(((ulong)(s)) << 32 | a);
			return (byte)(9);
		}
		public static byte sqlite3GetVarint32(byte* p, uint* v)
		{
			uint a = 0; uint b = 0;
			a = (uint)(*p);
			p++;
			b = (uint)(*p);
			if ((b & 0x80) == 0)
			{
				a &= (uint)(0x7f);
				a = (uint)(a << 7);
				*v = (uint)(a | b);
				return (byte)(2);
			}

			p++;
			a = (uint)(a << 14);
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				a &= (uint)((0x7f << 14) | (0x7f));
				b &= (uint)(0x7f);
				b = (uint)(b << 7);
				*v = (uint)(a | b);
				return (byte)(3);
			}

			{
				ulong v64 = 0;
				byte n = 0;
				n = (byte)(sqlite3GetVarint(p - 2, &v64));
				if ((v64 & ((((ulong)(1)) << 32) - 1)) != v64)
				{
					*v = (uint)(0xffffffff);
				}
				else
				{
					*v = ((uint)(v64));
				}

				return (byte)(n);
			}
		}
		public static void* sqlite3HashFind(Hash* pH, sbyte* pKey)
		{
			return findElementWithHash(pH, pKey, null)->data;
		}
		public static void* sqlite3HashInsert(Hash* pH, sbyte* pKey, void* data)
		{
			uint h = 0;
			HashElem* elem;
			HashElem* new_elem;
			elem = findElementWithHash(pH, pKey, &h);
			if ((elem->data) != null)
			{
				void* old_data = elem->data;
				if ((data) == (null))
				{
					removeElementGivenHash(pH, elem, (uint)(h));
				}
				else
				{
					elem->data = data;
					elem->pKey = pKey;
				}

				return old_data;
			}

			if ((data) == (null))
				return null;
			new_elem = (HashElem*)(sqlite3Malloc((ulong)(sizeof(HashElem))));
			if ((new_elem) == (null))
				return data;
			new_elem->pKey = pKey;
			new_elem->data = data;
			pH->count++;
			if (((pH->count) >= (10)) && ((pH->count) > (2 * pH->htsize)))
			{
				if ((rehash(pH, (uint)(pH->count * 2))) != 0)
				{
					h = (uint)(strHash(pKey) % pH->htsize);
				}
			}

			insertElement(pH, pH->ht ? &pH->ht[h] : null, new_elem);
			return null;
		}
		public static int sqlite3HeaderSizeBtree()
		{
			return (int)(((sizeof(MemPage)) + 7) & ~7);
		}
		public static int sqlite3HeaderSizePcache()
		{
			return (int)(((sizeof(PgHdr)) + 7) & ~7);
		}
		public static int sqlite3HeaderSizePcache1()
		{
			return (int)(((sizeof(PgHdr1)) + 7) & ~7);
		}
		public static int sqlite3HeapNearlyFull()
		{
			return (int)(0);
		}
		public static void* sqlite3HexToBlob(sqlite3 db, sbyte* z, int n)
		{
			sbyte* zBlob;
			int i = 0;
			zBlob = (sbyte*)(sqlite3DbMallocRawNN(db, (ulong)(n / 2 + 1)));
			n--;
			if ((zBlob) != null)
			{
				for (i = (int)(0); (i) < (n); i += (int)(2))
				{
					zBlob[i / 2] = (sbyte)((sqlite3HexToInt((int)(z[i])) << 4) | sqlite3HexToInt((int)(z[i + 1])));
				}

				zBlob[i / 2] = (sbyte)(0);
			}

			return zBlob;
		}
		public static byte sqlite3HexToInt(int h)
		{
			h += (int)(9 * (1 & (h >> 6)));
			return (byte)(h & 0xf);
		}
		public static IdList* sqlite3IdListAppend(Parse pParse, IdList* pList, Token* pToken)
		{
			sqlite3 db = pParse.db;
			int i = 0;
			if ((pList) == (null))
			{
				pList = sqlite3DbMallocZero(db, (ulong)(sizeof(IdList)));
				if ((pList) == (null))
					return null;
			}

			pList->a = sqlite3ArrayAllocate(db, pList->a, (int)(sizeof(IdList_item)), &pList->nId, &i);
			if ((i) < (0))
			{
				sqlite3IdListDelete(db, pList);
				return null;
			}

			pList->a[i].zName = sqlite3NameFromToken(db, pToken);
			if (((pParse.eParseMode) >= (2)) && ((pList->a[i].zName) != null))
			{
				sqlite3RenameTokenMap(pParse, (void*)(pList->a[i].zName), pToken);
			}

			return pList;
		}
		public static IdList* sqlite3IdListDup(sqlite3 db, IdList* p)
		{
			IdList* pNew;
			int i = 0;
			if ((p) == (null))
				return null;
			pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(IdList)));
			if ((pNew) == (null))
				return null;
			pNew->nId = (int)(p->nId);
			pNew->a = sqlite3DbMallocRawNN(db, (ulong)(p->nId * sizeof(IdList_item)));
			if ((pNew->a) == (null))
			{
				sqlite3DbFreeNN(db, pNew);
				return null;
			}

			for (i = (int)(0); (i) < (p->nId); i++)
			{
				IdList_item* pNewItem = &pNew->a[i];
				IdList_item* pOldItem = &p->a[i];
				pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
				pNewItem->idx = (int)(pOldItem->idx);
			}

			return pNew;
		}
		public static sbyte* sqlite3IndexAffinityStr(sqlite3 db, Index pIdx)
		{
			if (pIdx.zColAff == null)
			{
				int n = 0;
				Table pTab = pIdx.pTable;
				pIdx.zColAff = (sbyte*)(sqlite3DbMallocRaw(null, (ulong)(pIdx.nColumn + 1)));
				if (pIdx.zColAff == null)
				{
					sqlite3OomFault(db);
					return null;
				}

				for (n = (int)(0); (n) < (pIdx.nColumn); n++)
				{
					short x = (short)(pIdx.aiColumn[n]);
					sbyte aff = 0;
					if ((x) >= (0))
					{
						aff = (sbyte)(pTab.aCol[x].affinity);
					}
					else if ((x) == (-1))
					{
						aff = (sbyte)(0x44);
					}
					else
					{
						aff = (sbyte)(sqlite3ExprAffinity(pIdx.aColExpr.a[n].pExpr));
					}

					if ((aff) < (0x41))
						aff = (sbyte)(0x41);
					if ((aff) > (0x43))
						aff = (sbyte)(0x43);
					pIdx.zColAff[n] = (sbyte)(aff);
				}

				pIdx.zColAff[n] = (sbyte)(0);
			}

			return pIdx.zColAff;
		}
		public static int sqlite3InitCallback(void* pInit, int argc, sbyte** argv, sbyte** NotUsed)
		{
			InitData pData = (InitData)(pInit);
			sqlite3 db = pData.db;
			int iDb = (int)(pData.iDb);
			db.mDbFlags |= (uint)(0x0040);
			if ((argv) == (null))
				return (int)(0);
			pData.nInitRow++;
			if ((db.mallocFailed) != 0)
			{
				corruptSchema(pData, argv, null);
				return (int)(1);
			}

			if ((argv[3]) == (null))
			{
				corruptSchema(pData, argv, null);
			}
			else if ((((argv[4]) != null) && ((99) == (sqlite3UpperToLower[(byte)(argv[4][0])]))) && ((114) == (sqlite3UpperToLower[(byte)(argv[4][1])])))
			{
				int rc = 0;
				byte saved_iDb = (byte)(db.init.iDb);
				sqlite3_stmt* pStmt;
				db.init.iDb = (byte)(iDb);
				if (((sqlite3GetUInt32(argv[3], &db.init.newTnum)) == (0)) || (((db.init.newTnum) > (pData.mxPage)) && ((pData.mxPage) > (0))))
				{
					if ((sqlite3Config.bExtraSchemaChecks) != 0)
					{
						corruptSchema(pData, argv, "invalid rootpage");
					}
				}

				db.init.orphanTrigger = (uint)(0);
				db.init.azInit = argv;
				pStmt = null;
				sqlite3Prepare(db, argv[4], (int)(-1), (uint)(0), null, &pStmt, null);
				rc = (int)(db.errCode);
				db.init.iDb = (byte)(saved_iDb);
				if (0 != rc)
				{
					if ((db.init.orphanTrigger) != 0)
					{
					}
					else
					{
						if ((rc) > (pData.rc))
							pData.rc = (int)(rc);
						if ((rc) == (7))
						{
							sqlite3OomFault(db);
						}
						else if ((rc != 9) && ((rc & 0xFF) != 6))
						{
							corruptSchema(pData, argv, sqlite3_errmsg(db));
						}
					}
				}

				db.init.azInit = sqlite3StdType;
				sqlite3_finalize(pStmt);
			}
			else if (((argv[1]) == (null)) || ((argv[4] != null) && (argv[4][0] != 0)))
			{
				corruptSchema(pData, argv, null);
			}
			else
			{
				Index pIndex;
				pIndex = sqlite3FindIndex(db, argv[1], db.aDb[iDb].zDbSName);
				if ((pIndex) == (null))
				{
					corruptSchema(pData, argv, "orphan index");
				}
				else if (((((sqlite3GetUInt32(argv[3], &pIndex.tnum)) == (0)) || ((pIndex.tnum) < (2))) || ((pIndex.tnum) > (pData.mxPage))) || ((sqlite3IndexHasDuplicateRootPage(pIndex)) != 0))
				{
					if ((sqlite3Config.bExtraSchemaChecks) != 0)
					{
						corruptSchema(pData, argv, "invalid rootpage");
					}
				}
			}

			return (int)(0);
		}
		public static void sqlite3Int64ToText(long v, sbyte* zOut)
		{
			int i = 0;
			ulong x = 0;
			sbyte* zTemp = stackalloc sbyte[22];
			if ((v) < (0))
			{
				x = (ulong)(((v) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32)))) ? ((ulong)(1)) << 63 : (ulong)(-v));
			}
			else
			{
				x = (ulong)(v);
			}

			i = (int)(22 * sizeof(sbyte) - 2);
			zTemp[22 * sizeof(sbyte) - 1] = (sbyte)(0);
			do
			{
				zTemp[i--] = (sbyte)((x % 10) + 48);
				x = (ulong)(x / 10);
			}
			while ((x) != 0);
			if ((v) < (0))
				zTemp[i--] = (sbyte)(45);
			CRuntime.memcpy(zOut, &zTemp[i + 1], (ulong)(22 * sizeof(sbyte) - 1 - i));
		}
		public static int sqlite3IntFloatCompare(long i, double r)
		{
			if ((sizeof(LONGDOUBLE_TYPE)) > (8))
			{
				double x = (double)(i);
				if ((x) < (r))
					return (int)(-1);
				if ((x) > (r))
					return (int)(+1);
				return (int)(0);
			}
			else
			{
				long y = 0;
				double s = 0;
				if ((r) < (-9223372036854775808.0))
					return (int)(+1);
				if ((r) >= (9223372036854775808.0))
					return (int)(-1);
				y = ((long)(r));
				if ((i) < (y))
					return (int)(-1);
				if ((i) > (y))
					return (int)(+1);
				s = ((double)(i));
				if ((s) < (r))
					return (int)(-1);
				if ((s) > (r))
					return (int)(+1);
				return (int)(0);
			}
		}
		public static int sqlite3IsIdChar(byte c)
		{
			return (int)((sqlite3CtypeMap[c] & 0x46) != 0);
		}
		public static int sqlite3IsNaN(double x)
		{
			int rc = 0;
			ulong y = 0;
			CRuntime.memcpy(&y, &x, (ulong)(sizeof(ulong)));
			rc = (int)((((y) & (((ulong)(0x7ff)) << 52)) == (((ulong)(0x7ff)) << 52)) && (((y) & ((((ulong)(1)) << 52) - 1)) != 0) ? 1 : 0);
			return (int)(rc);
		}
		public static int sqlite3IsRowid(sbyte* z)
		{
			if ((sqlite3StrICmp(z, "_ROWID_")) == (0))
				return (int)(1);
			if ((sqlite3StrICmp(z, "ROWID")) == (0))
				return (int)(1);
			if ((sqlite3StrICmp(z, "OID")) == (0))
				return (int)(1);
			return (int)(0);
		}
		public static uint sqlite3IsTrueOrFalse(sbyte* zIn)
		{
			if ((sqlite3StrICmp(zIn, "true")) == (0))
				return (uint)(0x10000000);
			if ((sqlite3StrICmp(zIn, "false")) == (0))
				return (uint)(0x20000000);
			return (uint)(0);
		}
		public static sbyte* sqlite3JournalModename(int eMode)
		{
			if ((eMode) == ((int)(6 * sizeof(sbyte) / sizeof(sbyte*))))
				return null;
			return sqlite3JournalModename_azModeName[eMode];
		}
		public static int sqlite3KeywordCode(byte* z, int n)
		{
			int id = (int)(59);
			keywordCode((sbyte*)(z), (int)(n), &id);
			return (int)(id);
		}
		public static short sqlite3LogEst(ulong x)
		{
			short y = (short)(40);
			if ((x) < (8))
			{
				if ((x) < (2))
					return (short)(0);
				while ((x) < (8))
				{
					y -= (short)(10);
					x <<= 1;
				}
			}
			else
			{
				while ((x) > (255))
				{
					y += (short)(40);
					x >>= 4;
				}

				while ((x) > (15))
				{
					y += (short)(10);
					x >>= 1;
				}
			}

			return (short)(sqlite3LogEst_a[x & 7] + y - 10);
		}
		public static short sqlite3LogEstAdd(short a, short b)
		{
			if ((a) >= (b))
			{
				if ((a) > (b + 49))
					return (short)(a);
				if ((a) > (b + 31))
					return (short)(a + 1);
				return (short)(a + sqlite3LogEstAdd_x[a - b]);
			}
			else
			{
				if ((b) > (a + 49))
					return (short)(b);
				if ((b) > (a + 31))
					return (short)(b + 1);
				return (short)(b + sqlite3LogEstAdd_x[b - a]);
			}
		}
		public static short sqlite3LogEstFromDouble(double x)
		{
			ulong a = 0;
			short e = 0;
			if ((x) <= (1))
				return (short)(0);
			if ((x) <= (2000000000))
				return (short)(sqlite3LogEst((ulong)(x)));
			CRuntime.memcpy(&a, &x, (ulong)(8));
			e = (short)((a >> 52) - 1022);
			return (short)(e * 10);
		}
		public static ulong sqlite3LogEstToInt(short x)
		{
			ulong n = 0;
			n = (ulong)(x % 10);
			x /= (short)(10);
			if ((n) >= (5))
				n -= (ulong)(2);
			else if ((n) >= (1))
				n -= (ulong)(1);
			if ((x) > (60))
				return (ulong)(0xffffffff | (((long)(0x7fffffff)) << 32));
			return (ulong)((x) >= (3) ? (n + 8) << (x - 3) : (n + 8) >> (3 - x));
		}
		public static void* sqlite3Malloc(ulong n)
		{
			void* p;
			if (((n) == (0)) || ((n) >= (0x7fffff00)))
			{
				p = null;
			}
			else if ((sqlite3Config.bMemstat) != 0)
			{
				sqlite3_mutex_enter(mem0.mutex);
				mallocWithAlarm((int)(n), &p);
				sqlite3_mutex_leave(mem0.mutex);
			}
			else
			{
				p = sqlite3Config.m.xMalloc((int)(n));
			}

			return p;
		}
		public static void sqlite3MallocAlarm(int nByte)
		{
			if ((mem0.alarmThreshold) <= (0))
				return;
			sqlite3_mutex_leave(mem0.mutex);
			sqlite3_release_memory((int)(nByte));
			sqlite3_mutex_enter(mem0.mutex);
		}
		public static void sqlite3MallocEnd()
		{
			if ((sqlite3Config.m.xShutdown) != null)
			{
				sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData);
			}

			CRuntime.memset(&mem0, (int)(0), (ulong)(sizeof(Mem0Global)));
		}
		public static int sqlite3MallocInit()
		{
			int rc = 0;
			if ((sqlite3Config.m.xMalloc) == (null))
			{
				sqlite3MemSetDefault();
			}

			mem0.mutex = sqlite3MutexAlloc((int)(3));
			if ((((sqlite3Config.pPage) == (null)) || ((sqlite3Config.szPage) < (512))) || ((sqlite3Config.nPage) <= (0)))
			{
				sqlite3Config.pPage = null;
				sqlite3Config.szPage = (int)(0);
			}

			rc = (int)(sqlite3Config.m.xInit(sqlite3Config.m.pAppData));
			if (rc != 0)
				CRuntime.memset(&mem0, (int)(0), (ulong)(sizeof(Mem0Global)));
			return (int)(rc);
		}
		public static sqlite3_mutex* sqlite3MallocMutex()
		{
			return mem0.mutex;
		}
		public static int sqlite3MallocSize(void* p)
		{
			return (int)(sqlite3Config.m.xSize(p));
		}
		public static void* sqlite3MallocZero(ulong n)
		{
			void* p = sqlite3Malloc((ulong)(n));
			if ((p) != null)
			{
				CRuntime.memset(p, (int)(0), (ulong)(n));
			}

			return p;
		}
		public static int sqlite3MemdbInit()
		{
			sqlite3_vfs pLower = sqlite3_vfs_find(null);
			uint sz = 0;
			if (((pLower) == (null)))
				return (int)(1);
			sz = (uint)(pLower.szOsFile);
			memdb_vfs.pAppData = pLower;
			if ((sz) < (sizeof(MemFile)))
				sz = (uint)(sizeof(MemFile));
			memdb_vfs.szOsFile = (int)(sz);
			return (int)(sqlite3_vfs_register(memdb_vfs, (int)(0)));
		}
		public static void sqlite3MemFree(void* pPrior)
		{
			CRuntime.free(pPrior);
		}
		public static int sqlite3MemInit(void* NotUsed)
		{
			return (int)(0);
		}
		public static void* sqlite3MemMalloc(int nByte)
		{
			void* p;
			p = CRuntime.malloc((ulong)(nByte));
			if ((p) == (null))
			{
				sqlite3_log((int)(7), "failed to allocate %u bytes of memory", (int)(nByte));
			}

			return p;
		}
		public static void sqlite3MemoryBarrier()
		{
			_ReadWriteBarrier();
		}
		public static void* sqlite3MemRealloc(void* pPrior, int nByte)
		{
			void* p = CRuntime.realloc((pPrior), (ulong)(nByte));
			if ((p) == (null))
			{
				sqlite3_log((int)(7), "failed memory resize %u to %u bytes", (ulong)(_msize(pPrior)), (int)(nByte));
			}

			return p;
		}
		public static int sqlite3MemRoundup(int n)
		{
			return (int)(((n) + 7) & ~7);
		}
		public static void sqlite3MemSetDefault()
		{
			sqlite3_config((int)(4), sqlite3MemSetDefault_defaultMethods);
		}
		public static void sqlite3MemShutdown(void* NotUsed)
		{
			return;
		}
		public static int sqlite3MemSize(void* pPrior)
		{
			return (int)(_msize(pPrior));
		}
		public static int sqlite3MisuseError(int lineno)
		{
			return (int)(sqlite3ReportError((int)(21), (int)(lineno), "misuse"));
		}
		public static sbyte* sqlite3MPrintf(sqlite3 db, sbyte* zFormat)
		{
			sbyte* ap;
			sbyte* z;
			(__va_start(&ap, zFormat));
			z = sqlite3VMPrintf(db, zFormat, ap);
			((void)(ap = null));
			return z;
		}
		public static int sqlite3MulInt64(long* pA, long iB)
		{
			long iA = (long)(*pA);
			if ((iB) > (0))
			{
				if ((iA) > ((0xffffffff | (((long)(0x7fffffff)) << 32)) / iB))
					return (int)(1);
				if ((iA) < ((((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) / iB))
					return (int)(1);
			}
			else if ((iB) < (0))
			{
				if ((iA) > (0))
				{
					if ((iB) < ((((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) / iA))
						return (int)(1);
				}
				else if ((iA) < (0))
				{
					if ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
						return (int)(1);
					if ((iA) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
						return (int)(1);
					if ((-iA) > ((0xffffffff | (((long)(0x7fffffff)) << 32)) / -iB))
						return (int)(1);
				}
			}

			*pA = (long)(iA * iB);
			return (int)(0);
		}
		public static sqlite3_mutex* sqlite3MutexAlloc(int id)
		{
			if (sqlite3Config.bCoreMutex == 0)
			{
				return null;
			}

			return sqlite3Config.mutex.xMutexAlloc((int)(id));
		}
		public static int sqlite3MutexEnd()
		{
			int rc = (int)(0);
			if ((sqlite3Config.mutex.xMutexEnd) != null)
			{
				rc = (int)(sqlite3Config.mutex.xMutexEnd());
			}

			return (int)(rc);
		}
		public static int sqlite3MutexInit()
		{
			int rc = (int)(0);
			if (sqlite3Config.mutex.xMutexAlloc == null)
			{
				sqlite3_mutex_methods pFrom;
				sqlite3_mutex_methods pTo = sqlite3Config.mutex;
				if ((sqlite3Config.bCoreMutex) != 0)
				{
					pFrom = sqlite3DefaultMutex();
				}
				else
				{
					pFrom = sqlite3NoopMutex();
				}

				pTo.xMutexInit = pFrom.xMutexInit;
				pTo.xMutexEnd = pFrom.xMutexEnd;
				pTo.xMutexFree = pFrom.xMutexFree;
				pTo.xMutexEnter = pFrom.xMutexEnter;
				pTo.xMutexTry = pFrom.xMutexTry;
				pTo.xMutexLeave = pFrom.xMutexLeave;
				pTo.xMutexHeld = pFrom.xMutexHeld;
				pTo.xMutexNotheld = pFrom.xMutexNotheld;
				sqlite3MemoryBarrier();
				pTo.xMutexAlloc = pFrom.xMutexAlloc;
			}

			rc = (int)(sqlite3Config.mutex.xMutexInit());
			sqlite3MemoryBarrier();
			return (int)(rc);
		}
		public static sbyte* sqlite3NameFromToken(sqlite3 db, Token* pName)
		{
			sbyte* zName;
			if ((pName) != null)
			{
				zName = sqlite3DbStrNDup(db, pName->z, (ulong)(pName->n));
				sqlite3Dequote(zName);
			}
			else
			{
				zName = null;
			}

			return zName;
		}
		public static void sqlite3NoopDestructor(void* p)
		{
		}
		public static sqlite3_mutex_methods sqlite3NoopMutex()
		{
			return sqlite3NoopMutex_sMutex;
		}
		public static void* sqlite3OomFault(sqlite3 db)
		{
			if (((db.mallocFailed) == (0)) && ((db.bBenignMalloc) == (0)))
			{
				db.mallocFailed = (byte)(1);
				if ((db.nVdbeExec) > (0))
				{
					(1);
				}

				db.lookaside.bDisable++;
				db.lookaside.sz = (ushort)(0);
				if ((db.pParse) != null)
				{
					sqlite3ErrorMsg(db.pParse, "out of memory");
					db.pParse.rc = (int)(7);
				}
			}

			return null;
		}
		public static sbyte* sqlite3OpcodeName(int i)
		{
			return sqlite3OpcodeName_azName[i];
		}
		public static void* sqlite3OsDlOpen(sqlite3_vfs pVfs, sbyte* zPath)
		{
			return pVfs.xDlOpen(pVfs, zPath);
		}
		public static Void()sqlite3OsDlSym(sqlite3_vfs pVfs, void* pHdle, sbyte* zSym)
		{
			return pVfs.xDlSym(pVfs, pHdle, zSym);
		}
		public static int sqlite3OsInit()
		{
			void* p = sqlite3_malloc((int)(10));
			if ((p) == (null))
				return (int)(7);
			sqlite3_free(p);
			return (int)(sqlite3_os_init());
		}
		public static void sqlite3PageFree(void* p)
		{
			pcache1Free(p);
		}
		public static void* sqlite3PageMalloc(int sz)
		{
			return pcache1Alloc((int)(sz));
		}
		public static sbyte* sqlite3PagerFilename(Pager pPager, int nullIfMemDb)
		{
			return (((nullIfMemDb) != 0) && ((pPager.memDb) != 0)) ? &sqlite3PagerFilename_zFake[4] : pPager.zFilename;
		}
		public static void* sqlite3PagerGetData(PgHdr pPg)
		{
			return pPg.pData;
		}
		public static void* sqlite3PagerGetExtra(PgHdr pPg)
		{
			return pPg.pExtra;
		}
		public static sbyte* sqlite3PagerJournalname(Pager pPager)
		{
			return pPager.zJournal;
		}
		public static void* sqlite3PagerTempSpace(Pager pPager)
		{
			return pPager.pTmpSpace;
		}
		public static void sqlite3Parser(void* yyp, int yymajor, Token yyminor)
		{
			YYMINORTYPE yyminorunion = new YYMINORTYPE();
			ushort yyact = 0;
			yyParser yypParser = (yyParser)(yyp);
			Parse pParse = yypParser.pParse;
			yyact = (ushort)(yypParser.yytos->stateno);
			while ((1) != 0)
			{
				yyact = (ushort)(yy_find_shift_action((ushort)(yymajor), (ushort)(yyact)));
				if ((yyact) >= (1236))
				{
					uint yyruleno = (uint)(yyact - 1236);
					if ((yyRuleInfoNRhs[yyruleno]) == (0))
					{
						if ((yypParser.yytos) >= (yypParser.yystackEnd))
						{
							yyStackOverflow(yypParser);
							break;
						}
					}

					yyact = (ushort)(yy_reduce(yypParser, (uint)(yyruleno), (int)(yymajor), (Token)(yyminor), pParse));
				}
				else if ((yyact) <= (1232))
				{
					yy_shift(yypParser, (ushort)(yyact), (ushort)(yymajor), (Token)(yyminor));
					break;
				}
				else if ((yyact) == (1234))
				{
					yypParser.yytos--;
					yy_accept(yypParser);
					return;
				}
				else
				{
					yyminorunion.yy0 = (Token)(yyminor);
					yy_syntax_error(yypParser, (int)(yymajor), (Token)(yyminor));
					yy_destructor(yypParser, (ushort)(yymajor), &yyminorunion);
					break;
				}
			}

			return;
		}
		public static void* sqlite3ParserAddCleanup(Parse pParse, delegate71 xCleanup, void* pPtr)
		{
			ParseCleanup pCleanup = sqlite3DbMallocRaw(pParse.db, (ulong)(sizeof(ParseCleanup)));
			if ((pCleanup) != null)
			{
				pCleanup.pNext = pParse.pCleanup;
				pParse.pCleanup = pCleanup;
				pCleanup.pPtr = pPtr;
				pCleanup.xCleanup = xCleanup;
			}
			else
			{
				xCleanup(pParse.db, pPtr);
				pPtr = null;
			}

			return pPtr;
		}
		public static int sqlite3ParserFallback(int iToken)
		{
			return (int)(yyFallback[iToken]);
		}
		public static void sqlite3ParserFinalize(void* p)
		{
			yyParser pParser = (yyParser)(p);
			while ((pParser.yytos) > (pParser.yystack))
			{
				yy_pop_parser_stack(pParser);
			}
		}
		public static void sqlite3ParserInit(void* yypRawParser, Parse pParse)
		{
			yyParser yypParser = (yyParser)(yypRawParser);
			yypParser.pParse = pParse;
			yypParser.yytos = yypParser.yystack;
			yypParser.yystack[0].stateno = (ushort)(0);
			yypParser.yystack[0].major = (ushort)(0);
			yypParser.yystackEnd = &yypParser.yystack[100 - 1];
		}
		public static int sqlite3ParseUri(sbyte* zDefaultVfs, sbyte* zUri, uint* pFlags, sqlite3_vfs ppVfs, sbyte** pzFile, sbyte** pzErrMsg)
		{
			int rc = (int)(0);
			uint flags = (uint)(*pFlags);
			sbyte* zVfs = zDefaultVfs;
			sbyte* zFile;
			sbyte c = 0;
			int nUri = (int)(sqlite3Strlen30(zUri));
			if (((((flags & 0x00000040) != 0) || ((sqlite3Config.bOpenUri) != 0)) && ((nUri) >= (5))) && ((memcmp(zUri, "file:", (ulong)(5))) == (0)))
			{
				sbyte* zOpt;
				int eState = 0;
				int iIn = 0;
				int iOut = (int)(0);
				ulong nByte = (ulong)(nUri + 8);
				flags |= (uint)(0x00000040);
				for (iIn = (int)(0); (iIn) < (nUri); iIn++)
				{
					nByte += (ulong)((zUri[iIn]) == (38));
				}

				zFile = sqlite3_malloc64((ulong)(nByte));
				if (zFile == null)
					return (int)(7);
				CRuntime.memset(zFile, (int)(0), (ulong)(4));
				zFile += 4;
				iIn = (int)(5);
				if (((zUri[5]) == (47)) && ((zUri[6]) == (47)))
				{
					iIn = (int)(7);
					while (((zUri[iIn]) != 0) && (zUri[iIn] != 47))
					{
						iIn++;
					}

					if ((iIn != 7) && ((iIn != 16) || ((memcmp("localhost", &zUri[7], (ulong)(9))) != 0)))
					{
						*pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s", (int)(iIn - 7), &zUri[7]);
						rc = (int)(1);
						goto parse_uri_out;
					}
				}

				eState = (int)(0);
				while (((c = (sbyte)(zUri[iIn])) != 0) && (c != 35))
				{
					iIn++;
					if ((((c) == (37)) && ((sqlite3CtypeMap[(byte)(zUri[iIn])] & 0x08) != 0)) && ((sqlite3CtypeMap[(byte)(zUri[iIn + 1])] & 0x08) != 0))
					{
						int octet = (int)(sqlite3HexToInt((int)(zUri[iIn++])) << 4);
						octet += (int)(sqlite3HexToInt((int)(zUri[iIn++])));
						if ((octet) == (0))
						{
							while ((((((c = (sbyte)(zUri[iIn])) != 0) && (c != 35)) && ((eState != 0) || (c != 63))) && ((eState != 1) || ((c != 61) && (c != 38)))) && ((eState != 2) || (c != 38)))
							{
								iIn++;
							}

							continue;
						}

						c = (sbyte)(octet);
					}
					else if (((eState) == (1)) && (((c) == (38)) || ((c) == (61))))
					{
						if ((zFile[iOut - 1]) == (0))
						{
							while ((((zUri[iIn]) != 0) && (zUri[iIn] != 35)) && (zUri[iIn - 1] != 38))
							{
								iIn++;
							}

							continue;
						}

						if ((c) == (38))
						{
							zFile[iOut++] = (sbyte)(0);
						}
						else
						{
							eState = (int)(2);
						}

						c = (sbyte)(0);
					}
					else if ((((eState) == (0)) && ((c) == (63))) || (((eState) == (2)) && ((c) == (38))))
					{
						c = (sbyte)(0);
						eState = (int)(1);
					}

					zFile[iOut++] = (sbyte)(c);
				}

				if ((eState) == (1))
					zFile[iOut++] = (sbyte)(0);
				CRuntime.memset(zFile + iOut, (int)(0), (ulong)(4));
				zOpt = &zFile[sqlite3Strlen30(zFile) + 1];
				while ((zOpt[0]) != 0)
				{
					int nOpt = (int)(sqlite3Strlen30(zOpt));
					sbyte* zVal = &zOpt[nOpt + 1];
					int nVal = (int)(sqlite3Strlen30(zVal));
					if (((nOpt) == (3)) && ((memcmp("vfs", zOpt, (ulong)(3))) == (0)))
					{
						zVfs = zVal;
					}
					else
					{
						OpenMode* aMode = null;
						sbyte* zModeType = null;
						int mask = (int)(0);
						int limit = (int)(0);
						if (((nOpt) == (5)) && ((memcmp("cache", zOpt, (ulong)(5))) == (0)))
						{
							mask = (int)(0x00020000 | 0x00040000);
							aMode = sqlite3ParseUri_aCacheMode;
							limit = (int)(mask);
							zModeType = "cache";
						}

						if (((nOpt) == (4)) && ((memcmp("mode", zOpt, (ulong)(4))) == (0)))
						{
							mask = (int)(0x00000001 | 0x00000002 | 0x00000004 | 0x00000080);
							aMode = sqlite3ParseUri_aOpenMode;
							limit = (int)(mask & flags);
							zModeType = "access";
						}

						if ((aMode) != null)
						{
							int i = 0;
							int mode = (int)(0);
							for (i = (int)(0); aMode[i].z; i++)
							{
								sbyte* z = aMode[i].z;
								if (((nVal) == (sqlite3Strlen30(z))) && ((0) == (memcmp(zVal, z, (ulong)(nVal)))))
								{
									mode = (int)(aMode[i].mode);
									break;
								}
							}

							if ((mode) == (0))
							{
								*pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
								rc = (int)(1);
								goto parse_uri_out;
							}

							if ((mode & ~0x00000080) > (limit))
							{
								*pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s", zModeType, zVal);
								rc = (int)(3);
								goto parse_uri_out;
							}

							flags = (uint)((flags & ~mask) | mode);
						}
					}

					zOpt = &zVal[nVal + 1];
				}
			}
			else
			{
				zFile = sqlite3_malloc64((ulong)(nUri + 8));
				if (zFile == null)
					return (int)(7);
				CRuntime.memset(zFile, (int)(0), (ulong)(4));
				zFile += 4;
				if ((nUri) != 0)
				{
					CRuntime.memcpy(zFile, zUri, (ulong)(nUri));
				}

				CRuntime.memset(zFile + nUri, (int)(0), (ulong)(4));
				flags &= (uint)(~0x00000040);
			}

			ppVfs = sqlite3_vfs_find(zVfs);
			if ((ppVfs) == (null))
			{
				*pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
				rc = (int)(1);
			}

		parse_uri_out:
			; if (rc != 0) { sqlite3_free_filename(zFile); zFile = null; }
			*pFlags = (uint)(flags);
			*pzFile = zFile;
			return (int)(rc);
		}
		public static sqlite3_mutex* sqlite3Pcache1Mutex()
		{
			return (pcache1_g).mutex;
		}
		public static void sqlite3PCacheBufferSetup(void* pBuf, int sz, int n)
		{
			if (((pcache1_g).isInit) != 0)
			{
				PgFreeslot* p;
				if ((pBuf) == (null))
					sz = (int)(n = (int)(0));
				if ((n) == (0))
					sz = (int)(0);
				sz = (int)((sz) & ~7);
				(pcache1_g).szSlot = (int)(sz);
				(pcache1_g).nSlot = (int)((pcache1_g).nFreeSlot = (int)(n));
				(pcache1_g).nReserve = (int)((n) > (90) ? 10 : (n / 10 + 1));
				(pcache1_g).pStart = pBuf;
				(pcache1_g).pFree = null;
				(pcache1_g).bUnderPressure = (int)(0);
				while ((n--) != 0)
				{
					p = (PgFreeslot*)(pBuf);
					p->pNext = (pcache1_g).pFree;
					(pcache1_g).pFree = p;
					pBuf = (void*)(&((sbyte*)(pBuf))[sz]);
				}

				(pcache1_g).pEnd = pBuf;
			}
		}
		public static sqlite3_pcache_page* sqlite3PcacheFetch(PCache pCache, uint pgno, int createFlag)
		{
			int eCreate = 0;
			sqlite3_pcache_page* pRes;
			eCreate = (int)(createFlag & pCache.eCreate);
			pRes = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(pgno), (int)(eCreate));
			return pRes;
		}
		public static int sqlite3PcacheInitialize()
		{
			if ((sqlite3Config.pcache2.xInit) == (null))
			{
				sqlite3PCacheSetDefault();
			}

			return (int)(sqlite3Config.pcache2.xInit(sqlite3Config.pcache2.pArg));
		}
		public static int sqlite3PcacheOpen(int szPage, int szExtra, int bPurgeable, delegate59 xStress, void* pStress, PCache p)
		{
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(PCache)));
			p.szPage = (int)(1);
			p.szExtra = (int)(szExtra);
			p.bPurgeable = (byte)(bPurgeable);
			p.eCreate = (byte)(2);
			p.xStress = xStress;
			p.pStress = pStress;
			p.szCache = (int)(100);
			p.szSpill = (int)(1);
			return (int)(sqlite3PcacheSetPageSize(p, (int)(szPage)));
		}
		public static void sqlite3PCacheSetDefault()
		{
			sqlite3_config((int)(18), sqlite3PCacheSetDefault_defaultMethods);
		}
		public static void sqlite3PcacheShutdown()
		{
			if ((sqlite3Config.pcache2.xShutdown) != null)
			{
				sqlite3Config.pcache2.xShutdown(sqlite3Config.pcache2.pArg);
			}
		}
		public static int sqlite3PcacheSize()
		{
			return (int)(sizeof(PCache));
		}
		public static double sqlite3Pow10(int E)
		{
			double r = (double)(1.0);
			int i = 0;
			for (i = (int)(0); E != 0; i++, E >>= 1)
			{
				if ((E & 1) != 0)
					r *= (double)(sqlite3Pow10_x[i]);
			}

			return (double)(r);
		}
		public static sbyte* sqlite3PreferredTableName(sbyte* zName)
		{
			if ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0))
			{
				if ((sqlite3StrICmp(zName + 7, &"sqlite_master"[7])) == (0))
				{
					return "sqlite_schema";
				}

				if ((sqlite3StrICmp(zName + 7, &"sqlite_temp_master"[7])) == (0))
				{
					return "sqlite_temp_schema";
				}
			}

			return zName;
		}
		public static void sqlite3PrngRestoreState()
		{
			CRuntime.memcpy(&sqlite3Prng, &sqlite3SavedPrng, (ulong)(sizeof(sqlite3PrngType)));
		}
		public static void sqlite3PrngSaveState()
		{
			CRuntime.memcpy(&sqlite3SavedPrng, &sqlite3Prng, (ulong)(sizeof(sqlite3PrngType)));
		}
		public static void sqlite3Put4byte(byte* p, uint v)
		{
			uint x = (uint)(_byteswap_ulong((uint)(v)));
			CRuntime.memcpy(p, &x, (ulong)(4));
		}
		public static int sqlite3PutVarint(byte* p, ulong v)
		{
			if ((v) <= (0x7f))
			{
				p[0] = (byte)(v & 0x7f);
				return (int)(1);
			}

			if ((v) <= (0x3fff))
			{
				p[0] = (byte)(((v >> 7) & 0x7f) | 0x80);
				p[1] = (byte)(v & 0x7f);
				return (int)(2);
			}

			return (int)(putVarint64(p, (ulong)(v)));
		}
		public static void* sqlite3Realloc(void* pOld, ulong nBytes)
		{
			int nOld = 0; int nNew = 0; int nDiff = 0;
			void* pNew;
			if ((pOld) == (null))
			{
				return sqlite3Malloc((ulong)(nBytes));
			}

			if ((nBytes) == (0))
			{
				sqlite3_free(pOld);
				return null;
			}

			if ((nBytes) >= (0x7fffff00))
			{
				return null;
			}

			nOld = (int)(sqlite3MallocSize(pOld));
			nNew = (int)(sqlite3Config.m.xRoundup((int)(nBytes)));
			if ((nOld) == (nNew))
			{
				pNew = pOld;
			}
			else if ((sqlite3Config.bMemstat) != 0)
			{
				long nUsed = 0;
				sqlite3_mutex_enter(mem0.mutex);
				sqlite3StatusHighwater((int)(5), (int)(nBytes));
				nDiff = (int)(nNew - nOld);
				if (((nDiff) > (0)) && ((nUsed = (long)(sqlite3StatusValue((int)(0)))) >= (mem0.alarmThreshold - nDiff)))
				{
					sqlite3MallocAlarm((int)(nDiff));
					if (((mem0.hardLimit) > (0)) && ((nUsed) >= (mem0.hardLimit - nDiff)))
					{
						sqlite3_mutex_leave(mem0.mutex);
						return null;
					}
				}

				pNew = sqlite3Config.m.xRealloc(pOld, (int)(nNew));
				if ((pNew) != null)
				{
					nNew = (int)(sqlite3MallocSize(pNew));
					sqlite3StatusUp((int)(0), (int)(nNew - nOld));
				}

				sqlite3_mutex_leave(mem0.mutex);
			}
			else
			{
				pNew = sqlite3Config.m.xRealloc(pOld, (int)(nNew));
			}

			return pNew;
		}
		public static int sqlite3RealSameAsInt(double r1, long i)
		{
			double r2 = (double)(i);
			return (((r1) == (0.0)) || ((((memcmp(&r1, &r2, (ulong)(sizeof(double)))) == (0)) && ((i) >= (-2251799813685248L  L ) ) ) && ((i) < (2251799813685248L  L ) ) ) ? 1 :  0 ) ;
		}
		public static void sqlite3RegisterBuiltinFunctions()
		{
			sqlite3AlterFunctions();
			sqlite3WindowFunctions();
			sqlite3RegisterDateTimeFunctions();
			sqlite3RegisterJsonFunctions();
			sqlite3InsertBuiltinFuncs(sqlite3RegisterBuiltinFunctions_aBuiltinFunc, ((int)(69 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3RegisterDateTimeFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3RegisterDateTimeFunctions_aDateTimeFuncs, ((int)(9 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3RegisterJsonFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3RegisterJsonFunctions_aJsonFunc, ((int)(19 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void* sqlite3RenameTokenMap(Parse pParse, void* pPtr, Token* pToken)
		{
			RenameToken* pNew;
			if ((pParse.eParseMode != 3))
			{
				pNew = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(RenameToken)));
				if ((pNew) != null)
				{
					pNew->p = pPtr;
					pNew->t = (Token)(*pToken);
					pNew->pNext = pParse.pRename;
					pParse.pRename = pNew;
				}
			}

			return pPtr;
		}
		public static int sqlite3ReportError(int iErr, int lineno, sbyte* zType)
		{
			sqlite3_log((int)(iErr), "%s at line %d of [%.10s]", zType, (int)(lineno), 20 + sqlite3_sourceid());
			return (int)(iErr);
		}
		public static void sqlite3RowSetClear(void* pArg)
		{
			RowSet p = (RowSet)(pArg);
			RowSetChunk pChunk; RowSetChunk pNextChunk;
			for (pChunk = p.pChunk; pChunk; pChunk = pNextChunk)
			{
				pNextChunk = pChunk.pNextChunk;
				sqlite3DbFree(p.db, pChunk);
			}

			p.pChunk = null;
			p.nFresh = (ushort)(0);
			p.pEntry = null;
			p.pLast = null;
			p.pForest = null;
			p.rsFlags = (ushort)(0x01);
		}
		public static void sqlite3RowSetDelete(void* pArg)
		{
			sqlite3RowSetClear(pArg);
			sqlite3DbFree(((RowSet)(pArg)).db, pArg);
		}
		public static int sqlite3RunVacuum(sbyte** pzErrMsg, sqlite3 db, int iDb, sqlite3_value pOut)
		{
			int rc = (int)(0);
			Btree pMain;
			Btree pTemp;
			uint saved_mDbFlags = 0;
			ulong saved_flags = 0;
			long saved_nChange = 0;
			long saved_nTotalChange = 0;
			uint saved_openFlags = 0;
			byte saved_mTrace = 0;
			Db pDb = null;
			int isMemDb = 0;
			int nRes = 0;
			int nDb = 0;
			sbyte* zDbMain;
			sbyte* zOut;
			if (db.autoCommit == 0)
			{
				sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
				return (int)(1);
			}

			if ((db.nVdbeActive) > (1))
			{
				sqlite3SetString(pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
				return (int)(1);
			}

			saved_openFlags = (uint)(db.openFlags);
			if ((pOut) != null)
			{
				if (sqlite3_value_type(pOut) != 3)
				{
					sqlite3SetString(pzErrMsg, db, "non-text filename");
					return (int)(1);
				}

				zOut = (sbyte*)(sqlite3_value_text(pOut));
				db.openFlags &= (uint)(~0x00000001);
				db.openFlags |= (uint)(0x00000004 | 0x00000002);
			}
			else
			{
				zOut = "";
			}

			saved_flags = (ulong)(db.flags);
			saved_mDbFlags = (uint)(db.mDbFlags);
			saved_nChange = (long)(db.nChange);
			saved_nTotalChange = (long)(db.nTotalChange);
			saved_mTrace = (byte)(db.mTrace);
			db.flags |= (ulong)(0x00000001 | 0x00000200);
			db.mDbFlags |= (uint)(0x0002 | 0x0004);
			db.flags &= (ulong)(~(0x00004000 | 0x00001000 | 0x10000000 | ((ulong)(0x00001) << 32)));
			db.mTrace = (byte)(0);
			zDbMain = db.aDb[iDb].zDbSName;
			pMain = db.aDb[iDb].pBt;
			isMemDb = (int)(sqlite3PagerIsMemdb(sqlite3BtreePager(pMain)));
			nDb = (int)(db.nDb);
			rc = (int)(execSqlF(db, pzErrMsg, "ATTACH %Q AS vacuum_db", zOut));
			db.openFlags = (uint)(saved_openFlags);
			if (rc != 0)
				goto end_of_vacuum;
			pDb = db.aDb[nDb];
			pTemp = pDb.pBt;
			if ((pOut) != null)
			{
				sqlite3_file id = sqlite3PagerFile(sqlite3BtreePager(pTemp));
				long sz = (long)(0);
				if ((id.pMethods != null) && ((sqlite3OsFileSize(id, &sz) != 0) || ((sz) > (0))))
				{
					rc = (int)(1);
					sqlite3SetString(pzErrMsg, db, "output file already exists");
					goto end_of_vacuum;
				}

				db.mDbFlags |= (uint)(0x0008);
			}

			nRes = (int)(sqlite3BtreeGetRequestedReserve(pMain));
			sqlite3BtreeSetCacheSize(pTemp, (int)(db.aDb[iDb].pSchema.cache_size));
			sqlite3BtreeSetSpillSize(pTemp, (int)(sqlite3BtreeSetSpillSize(pMain, (int)(0))));
			sqlite3BtreeSetPagerFlags(pTemp, (uint)(0x01 | 0x20));
			rc = (int)(execSql(db, pzErrMsg, "BEGIN"));
			if (rc != 0)
				goto end_of_vacuum;
			rc = (int)(sqlite3BtreeBeginTrans(pMain, (int)((pOut) == (null) ? 2 : 0), null));
			if (rc != 0)
				goto end_of_vacuum;
			if (((sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))) == (5)) && ((pOut) == (null)))
			{
				db.nextPagesize = (int)(0);
			}

			if ((((sqlite3BtreeSetPageSize(pTemp, (int)(sqlite3BtreeGetPageSize(pMain)), (int)(nRes), (int)(0))) != 0) || ((isMemDb == 0) && ((sqlite3BtreeSetPageSize(pTemp, (int)(db.nextPagesize), (int)(nRes), (int)(0))) != 0))) || ((db.mallocFailed) != 0))
			{
				rc = (int)(7);
				goto end_of_vacuum;
			}

			sqlite3BtreeSetAutoVacuum(pTemp, (int)((db.nextAutovac) >= (0) ? db.nextAutovac : sqlite3BtreeGetAutoVacuum(pMain)));
			db.init.iDb = (byte)(nDb);
			rc = (int)(execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_schema WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0", zDbMain));
			if (rc != 0)
				goto end_of_vacuum;
			rc = (int)(execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_schema WHERE type='index'", zDbMain));
			if (rc != 0)
				goto end_of_vacuum;
			db.init.iDb = (byte)(0);
			rc = (int)(execSqlF(db, pzErrMsg, "SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM\"%w\".'||quote(name)FROM vacuum_db.sqlite_schema WHERE type='table'AND coalesce(rootpage,1)>0", zDbMain));
			db.mDbFlags &= (uint)(~0x0004);
			if (rc != 0)
				goto end_of_vacuum;
			rc = (int)(execSqlF(db, pzErrMsg, "INSERT INTO vacuum_db.sqlite_schema SELECT*FROM \"%w\".sqlite_schema WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)", zDbMain));
			if ((rc) != 0)
				goto end_of_vacuum;
			{
				uint meta = 0;
				int i = 0;
				for (i = (int)(0); (i) < ((int)(10 * sizeof(byte) / sizeof(byte))); i += (int)(2))
				{
					sqlite3BtreeGetMeta(pMain, (int)(sqlite3RunVacuum_aCopy[i]), &meta);
					rc = (int)(sqlite3BtreeUpdateMeta(pTemp, (int)(sqlite3RunVacuum_aCopy[i]), (uint)(meta + sqlite3RunVacuum_aCopy[i + 1])));
					if ((rc != 0))
						goto end_of_vacuum;
				}

				if ((pOut) == (null))
				{
					rc = (int)(sqlite3BtreeCopyFile(pMain, pTemp));
				}

				if (rc != 0)
					goto end_of_vacuum;
				rc = (int)(sqlite3BtreeCommit(pTemp));
				if (rc != 0)
					goto end_of_vacuum;
				if ((pOut) == (null))
				{
					sqlite3BtreeSetAutoVacuum(pMain, (int)(sqlite3BtreeGetAutoVacuum(pTemp)));
				}
			}

			if ((pOut) == (null))
			{
				rc = (int)(sqlite3BtreeSetPageSize(pMain, (int)(sqlite3BtreeGetPageSize(pTemp)), (int)(nRes), (int)(1)));
			}

		end_of_vacuum:
			; db.init.iDb = (byte)(0);
			db.mDbFlags = (uint)(saved_mDbFlags);
			db.flags = (ulong)(saved_flags);
			db.nChange = (long)(saved_nChange);
			db.nTotalChange = (long)(saved_nTotalChange);
			db.mTrace = (byte)(saved_mTrace);
			sqlite3BtreeSetPageSize(pMain, (int)(-1), (int)(0), (int)(1));
			db.autoCommit = (byte)(1);
			if ((pDb) != null)
			{
				sqlite3BtreeClose(pDb.pBt);
				pDb.pBt = null;
				pDb.pSchema = null;
			}

			sqlite3ResetAllSchemasOfConnection(db);
			return (int)(rc);
		}
		public static void sqlite3SchemaClear(void* p)
		{
			Hash temp1 = new Hash();
			Hash temp2 = new Hash();
			HashElem* pElem;
			Schema pSchema = (Schema)(p);
			temp1 = (Hash)(pSchema.tblHash);
			temp2 = (Hash)(pSchema.trigHash);
			sqlite3HashInit(&pSchema.trigHash);
			sqlite3HashClear(&pSchema.idxHash);
			for (pElem = ((&temp2)->first); pElem; pElem = ((pElem)->next))
			{
				sqlite3DeleteTrigger(null, (Trigger)((pElem)->data));
			}

			sqlite3HashClear(&temp2);
			sqlite3HashInit(&pSchema.tblHash);
			for (pElem = ((&temp1)->first); pElem; pElem = ((pElem)->next))
			{
				Table pTab = ((pElem)->data);
				sqlite3DeleteTable(null, pTab);
			}

			sqlite3HashClear(&temp1);
			sqlite3HashClear(&pSchema.fkeyHash);
			pSchema.pSeqTab = null;
			if ((pSchema.schemaFlags & 0x0001) != 0)
			{
				pSchema.iGeneration++;
			}

			pSchema.schemaFlags &= (ushort)(~(0x0001 | 0x0008));
		}
		public static sbyte* sqlite3SelectOpName(int id)
		{
			sbyte* z;
			switch (id)
			{
				case 135:
					z = "UNION ALL";
					break;
				case 137:
					z = "INTERSECT";
					break;
				case 136:
					z = "EXCEPT";
					break;
				default:
					z = "UNION";
					break;
			}

			return z;
		}
		public static void sqlite3SetString(sbyte** pz, sqlite3 db, sbyte* zNew)
		{
			sqlite3DbFree(db, *pz);
			*pz = sqlite3DbStrDup(db, zNew);
		}
		public static void sqlite3StatusDown(int op, int N)
		{
			sqlite3Stat.nowValue[op] -= (long)(N);
		}
		public static void sqlite3StatusHighwater(int op, int X)
		{
			long newValue = 0;
			newValue = ((long)(X));
			if ((newValue) > (sqlite3Stat.mxValue[op]))
			{
				sqlite3Stat.mxValue[op] = (long)(newValue);
			}
		}
		public static void sqlite3StatusUp(int op, int N)
		{
			sqlite3Stat.nowValue[op] += (long)(N);
			if ((sqlite3Stat.nowValue[op]) > (sqlite3Stat.mxValue[op]))
			{
				sqlite3Stat.mxValue[op] = (long)(sqlite3Stat.nowValue[op]);
			}
		}
		public static long sqlite3StatusValue(int op)
		{
			return (long)(sqlite3Stat.nowValue[op]);
		}
		public static sbyte* sqlite3StrAccumFinish(sqlite3_str p)
		{
			if ((p.zText) != null)
			{
				p.zText[p.nChar] = (sbyte)(0);
				if (((p.mxAlloc) > (0)) && (!(((p).printfFlags & 0x04) != 0)))
				{
					return strAccumFinishRealloc(p);
				}
			}

			return p.zText;
		}
		public static int sqlite3StrICmp(sbyte* zLeft, sbyte* zRight)
		{
			byte* a; byte* b;
			int c = 0; int x = 0;
			a = (byte*)(zLeft);
			b = (byte*)(zRight);
			for (; ; )
			{
				c = (int)(*a);
				x = (int)(*b);
				if ((c) == (x))
				{
					if ((c) == (0))
						break;
				}
				else
				{
					c = (int)((int)(sqlite3UpperToLower[c]) - (int)(sqlite3UpperToLower[x]));
					if ((c) != 0)
						break;
				}

				a++;
				b++;
			}

			return (int)(c);
		}
		public static byte sqlite3StrIHash(sbyte* z)
		{
			byte h = (byte)(0);
			if ((z) == (null))
				return (byte)(0);
			while ((z[0]) != 0)
			{
				h += (byte)(sqlite3UpperToLower[(byte)(z[0])]);
				z++;
			}

			return (byte)(h);
		}
		public static int sqlite3Strlen30(sbyte* z)
		{
			if ((z) == (null))
				return (int)(0);
			return (int)(0x3fffffff & (int)(CRuntime.strlen(z)));
		}
		public static int sqlite3SubInt64(long* pA, long iB)
		{
			if ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
			{
				if ((*pA) >= (0))
					return (int)(1);
				*pA -= (long)(iB);
				return (int)(0);
			}
			else
			{
				return (int)(sqlite3AddInt64(pA, (long)(-iB)));
			}
		}
		public static uint sqlite3ThreadProc(void* pArg)
		{
			SQLiteThread p = (SQLiteThread)(pArg);
			p.pResult = p.xTask(p.pIn);
			_endthreadex((uint)(0));
			return (uint)(0);
		}
		public static int sqlite3Utf16ByteLen(void* zIn, int nChar)
		{
			int c = 0;
			byte* z = zIn;
			int n = (int)(0);
			if ((2) == (2))
				z++;
			while ((n) < (nChar))
			{
				c = (int)(z[0]);
				z += 2;
				if (((((c) >= (0xd8)) && ((c) < (0xdc))) && ((z[0]) >= (0xdc))) && ((z[0]) < (0xe0)))
					z += 2;
				n++;
			}

			return (int)((int)(z - (byte*)(zIn)) - ((2) == (2)));
		}
		public static sbyte* sqlite3Utf16to8(sqlite3 db, void* z, int nByte, byte enc)
		{
			sqlite3_value m = new sqlite3_value();
			CRuntime.memset(m, (int)(0), (ulong)(sizeof(sqlite3_value)));
			m.db = db;
			sqlite3VdbeMemSetStr(m, z, (long)(nByte), (byte)(enc), null);
			sqlite3VdbeChangeEncoding(m, (int)(1));
			if ((db.mallocFailed) != 0)
			{
				sqlite3VdbeMemRelease(m);
				m.z = null;
			}

			return m.z;
		}
		public static int sqlite3Utf8CharLen(sbyte* zIn, int nByte)
		{
			int r = (int)(0);
			byte* z = (byte*)(zIn);
			byte* zTerm;
			if ((nByte) >= (0))
			{
				zTerm = &z[nByte];
			}
			else
			{
				zTerm = (byte*)(-1);
			}

			while ((*z != 0) && ((z) < (zTerm)))
			{
				{
					if ((*(z++)) >= (0xc0))
					{
						while ((*z & 0xc0) == (0x80))
						{
							z++;
						}
					}
				}

				r++;
			}

			return (int)(r);
		}
		public static uint sqlite3Utf8Read(byte** pz)
		{
			uint c = 0;
			c = (uint)(*((*pz)++));
			if ((c) >= (0xc0))
			{
				c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
				while ((*(*pz) & 0xc0) == (0x80))
				{
					c = (uint)((c << 6) + (0x3f & *((*pz)++)));
				}

				if ((((c) < (0x80)) || ((c & 0xFFFFF800) == (0xD800))) || ((c & 0xFFFFFFFE) == (0xFFFE)))
				{
					c = (uint)(0xFFFD);
				}
			}

			return (uint)(c);
		}
		public static void* sqlite3ValueText(sqlite3_value pVal, byte enc)
		{
			if (pVal == null)
				return null;
			if (((pVal.flags & (0x0002 | 0x0200)) == (0x0002 | 0x0200)) && ((pVal.enc) == (enc)))
			{
				return pVal.z;
			}

			if ((pVal.flags & 0x0001) != 0)
			{
				return null;
			}

			return valueToText(pVal, (byte)(enc));
		}
		public static int sqlite3VarintLen(ulong v)
		{
			int i = 0;
			for (i = (int)(1); (v >>= 7) != 0; i++)
			{
			}

			return (int)(i);
		}
		public static VdbeOp* sqlite3VdbeAddOpList(Vdbe p, int nOp, VdbeOpList* aOp, int iLineno)
		{
			int i = 0;
			VdbeOp* pOut; VdbeOp* pFirst;
			if (((p.nOp + nOp) > (p.nOpAlloc)) && ((growOpArray(p, (int)(nOp))) != 0))
			{
				return null;
			}

			pFirst = pOut = &p.aOp[p.nOp];
			for (i = (int)(0); (i) < (nOp); i++, aOp++, pOut++)
			{
				pOut->opcode = (byte)(aOp->opcode);
				pOut->p1 = (int)(aOp->p1);
				pOut->p2 = (int)(aOp->p2);
				if (((sqlite3OpcodeProperty[aOp->opcode] & 0x01) != 0) && ((aOp->p2) > (0)))
				{
					pOut->p2 += (int)(p.nOp);
				}

				pOut->p3 = (int)(aOp->p3);
				pOut->p4type = (sbyte)(0);
				pOut->p4.p = null;
				pOut->p5 = (ushort)(0);
				(void)(iLineno);
			}

			p.nOp += (int)(nOp);
			return pFirst;
		}
		public static sbyte* sqlite3VdbeDisplayP4(sqlite3 db, VdbeOp* pOp)
		{
			sbyte* zP4 = null;
			sqlite3_str x = new sqlite3_str();
			sqlite3StrAccumInit(x, null, null, (int)(0), (int)(1000000000));
			switch (pOp->p4type)
			{
				case (-9):
					{
						int j = 0;
						KeyInfo pKeyInfo = pOp->p4.pKeyInfo;
						sqlite3_str_appendf(x, "k(%d", (int)(pKeyInfo.nKeyField));
						for (j = (int)(0); (j) < (pKeyInfo.nKeyField); j++)
						{
							CollSeq pColl = pKeyInfo.aColl[j];
							sbyte* zColl = pColl ? pColl.zName : "";
							if ((CRuntime.strcmp(zColl, "BINARY")) == (0))
								zColl = "B";
							sqlite3_str_appendf(x, ",%s%s%s", (pKeyInfo.aSortFlags[j] & 0x01) ? "-" : "", (pKeyInfo.aSortFlags[j] & 0x02) ? "N." : "", zColl);
						}

						sqlite3_str_append(x, ")", (int)(1));
						break;
					}

				case (-2):
					{
						CollSeq pColl = pOp->p4.pColl;
						sqlite3_str_appendf(x, "%.18s-%s", pColl.zName, sqlite3VdbeDisplayP4_encnames[pColl.enc]);
						break;
					}

				case (-8):
					{
						FuncDef pDef = pOp->p4.pFunc;
						sqlite3_str_appendf(x, "%s(%d)", pDef.zName, (int)(pDef.nArg));
						break;
					}

				case (-16):
					{
						FuncDef pDef = pOp->p4.pCtx.pFunc;
						sqlite3_str_appendf(x, "%s(%d)", pDef.zName, (int)(pDef.nArg));
						break;
					}

				case (-14):
					{
						sqlite3_str_appendf(x, "%lld", (long)(*pOp->p4.pI64));
						break;
					}

				case (-3):
					{
						sqlite3_str_appendf(x, "%d", (int)(pOp->p4.i));
						break;
					}

				case (-13):
					{
						sqlite3_str_appendf(x, "%.16g", (double)(*pOp->p4.pReal));
						break;
					}

				case (-11):
					{
						sqlite3_value pMem = pOp->p4.pMem;
						if ((pMem.flags & 0x0002) != 0)
						{
							zP4 = pMem.z;
						}
						else if ((pMem.flags & (0x0004 | 0x0020)) != 0)
						{
							sqlite3_str_appendf(x, "%lld", (long)(pMem.u.i));
						}
						else if ((pMem.flags & 0x0008) != 0)
						{
							sqlite3_str_appendf(x, "%.16g", (double)(pMem.u.r));
						}
						else if ((pMem.flags & 0x0001) != 0)
						{
							zP4 = "NULL";
						}
						else
						{
							zP4 = "(blob)";
						}

						break;
					}

				case (-12):
					{
						sqlite3_vtab pVtab = pOp->p4.pVtab.pVtab;
						sqlite3_str_appendf(x, "vtab:%p", pVtab);
						break;
					}

				case (-15):
					{
						uint i = 0;
						uint* ai = pOp->p4.ai;
						uint n = (uint)(ai[0]);
						for (i = (uint)(1); (i) <= (n); i++)
						{
							sqlite3_str_appendf(x, "%c%u", (int)((i) == (1) ? 91 : 44), (uint)(ai[i]));
						}

						sqlite3_str_append(x, "]", (int)(1));
						break;
					}

				case (-4):
					{
						zP4 = "program";
						break;
					}

				case (-17):
				case (-5):
					{
						break;
					}

				case (-6):
					{
						zP4 = pOp->p4.pTab.zName;
						break;
					}

				default:
					{
						zP4 = pOp->p4.z;
					}
			}

			if ((zP4) != null)
				sqlite3_str_appendall(x, zP4);
			if ((x.accError & 7) != 0)
			{
				sqlite3OomFault(db);
			}

			return sqlite3StrAccumFinish(x);
		}
		public static sbyte* sqlite3VdbeExpandSql(Vdbe p, sbyte* zRawSql)
		{
			sqlite3 db;
			int idx = (int)(0);
			int nextIndex = (int)(1);
			int n = 0;
			int nToken = 0;
			int i = 0;
			sqlite3_value pVar;
			sqlite3_str _out_ = new sqlite3_str();
			sqlite3_value utf8 = new sqlite3_value();
			db = p.db;
			sqlite3StrAccumInit(_out_, null, null, (int)(0), (int)(db.aLimit[0]));
			if ((db.nVdbeExec) > (1))
			{
				while ((*zRawSql) != 0)
				{
					sbyte* zStart = zRawSql;
					while ((*(zRawSql++) != 10) && ((*zRawSql) != 0))
					{
					}

					sqlite3_str_append(_out_, "-- ", (int)(3));
					sqlite3_str_append(_out_, zStart, (int)(zRawSql - zStart));
				}
			}
			else if ((p.nVar) == (0))
			{
				sqlite3_str_append(_out_, zRawSql, (int)(sqlite3Strlen30(zRawSql)));
			}
			else
			{
				while ((zRawSql[0]) != 0)
				{
					n = (int)(findNextHostParameter(zRawSql, &nToken));
					sqlite3_str_append(_out_, zRawSql, (int)(n));
					zRawSql += n;
					if ((nToken) == (0))
						break;
					if ((zRawSql[0]) == (63))
					{
						if ((nToken) > (1))
						{
							sqlite3GetInt32(&zRawSql[1], &idx);
						}
						else
						{
							idx = (int)(nextIndex);
						}
					}
					else
					{
						idx = (int)(sqlite3VdbeParameterIndex(p, zRawSql, (int)(nToken)));
					}

					zRawSql += nToken;
					nextIndex = (int)((idx + 1) > (nextIndex) ? (idx + 1) : (nextIndex));
					pVar = p.aVar[idx - 1];
					if ((pVar.flags & 0x0001) != 0)
					{
						sqlite3_str_append(_out_, "NULL", (int)(4));
					}
					else if ((pVar.flags & (0x0004 | 0x0020)) != 0)
					{
						sqlite3_str_appendf(_out_, "%lld", (long)(pVar.u.i));
					}
					else if ((pVar.flags & 0x0008) != 0)
					{
						sqlite3_str_appendf(_out_, "%!.15g", (double)(pVar.u.r));
					}
					else if ((pVar.flags & 0x0002) != 0)
					{
						int nOut = 0;
						byte enc = (byte)((db).enc);
						if (enc != 1)
						{
							CRuntime.memset(utf8, (int)(0), (ulong)(sizeof(sqlite3_value)));
							utf8.db = db;
							sqlite3VdbeMemSetStr(utf8, pVar.z, (long)(pVar.n), (byte)(enc), null);
							if ((7) == (sqlite3VdbeChangeEncoding(utf8, (int)(1))))
							{
								_out_.accError = (byte)(7);
								_out_.nAlloc = (uint)(0);
							}

							pVar = utf8;
						}

						nOut = (int)(pVar.n);
						sqlite3_str_appendf(_out_, "'%.*q'", (int)(nOut), pVar.z);
						if (enc != 1)
							sqlite3VdbeMemRelease(utf8);
					}
					else if ((pVar.flags & 0x4000) != 0)
					{
						sqlite3_str_appendf(_out_, "zeroblob(%d)", (int)(pVar.u.nZero));
					}
					else
					{
						int nOut = 0;
						sqlite3_str_append(_out_, "x'", (int)(2));
						nOut = (int)(pVar.n);
						for (i = (int)(0); (i) < (nOut); i++)
						{
							sqlite3_str_appendf(_out_, "%02x", (int)(pVar.z[i] & 0xff));
						}

						sqlite3_str_append(_out_, "'", (int)(1));
					}
				}
			}

			if ((_out_.accError) != 0)
				sqlite3_str_reset(_out_);
			return sqlite3StrAccumFinish(_out_);
		}
		public static Int(Int , Int , Int )sqlite3VdbeFindCompare(UnpackedRecord p)
		{
			if ((p.pKeyInfo.nAllField) <= (13))
			{
				int flags = (int)(p.aMem[0].flags);
				if ((p.pKeyInfo.aSortFlags[0]) != 0)
				{
					if ((p.pKeyInfo.aSortFlags[0] & 0x02) != 0)
					{
						return sqlite3VdbeRecordCompare;
					}

					p.r1 = (sbyte)(1);
					p.r2 = (sbyte)(-1);
				}
				else
				{
					p.r1 = (sbyte)(-1);
					p.r2 = (sbyte)(1);
				}

				if ((flags & 0x0004) != 0)
				{
					return vdbeRecordCompareInt;
				}

				if (((flags & (0x0008 | 0x0020 | 0x0001 | 0x0010)) == (0)) && ((p.pKeyInfo.aColl[0]) == (null)))
				{
					return vdbeRecordCompareString;
				}
			}

			return sqlite3VdbeRecordCompare;
		}
		public static void sqlite3VdbeFrameMemDel(void* pArg)
		{
			VdbeFrame pFrame = (VdbeFrame)(pArg);
			pFrame.pParent = pFrame.v.pDelFrame;
			pFrame.v.pDelFrame = pFrame;
		}
		public static VdbeOp* sqlite3VdbeGetOp(Vdbe p, int addr)
		{
			if ((addr) < (0))
			{
				addr = (int)(p.nOp - 1);
			}

			if ((p.db.mallocFailed) != 0)
			{
				return &sqlite3VdbeGetOp_dummy;
			}
			else
			{
				return &p.aOp[addr];
			}
		}
		public static byte sqlite3VdbeOneByteSerialTypeLen(byte serial_type)
		{
			return (byte)(sqlite3SmallTypeSizes[serial_type]);
		}
		public static int sqlite3VdbeRecordCompare(int nKey1, void* pKey1, UnpackedRecord pPKey2)
		{
			return (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(0)));
		}
		public static int sqlite3VdbeRecordCompareWithSkip(int nKey1, void* pKey1, UnpackedRecord pPKey2, int bSkip)
		{
			uint d1 = 0;
			int i = 0;
			uint szHdr1 = 0;
			uint idx1 = 0;
			int rc = (int)(0);
			sqlite3_value pRhs = pPKey2.aMem;
			KeyInfo pKeyInfo;
			byte* aKey1 = (byte*)(pKey1);
			sqlite3_value mem1 = new sqlite3_value();
			if ((bSkip) != 0)
			{
				uint s1 = 0;
				idx1 = (uint)(1 + (byte)(((*(&aKey1[1])) < ((byte)(0x80))) ? ((s1) = ((uint)(*(&aKey1[1])))), 1 : 
        sqlite3GetVarint32((&aKey1[1]), &(s1)) ) )
        ;
				szHdr1 = (uint)(aKey1[0]);
				d1 = (uint)(szHdr1 + sqlite3VdbeSerialTypeLen((uint)(s1)));
				i = (int)(1);
				pRhs++;
			}

			else
			{
				idx1 = (uint)((byte)(((*(aKey1)) < ((byte)(0x80))) ? ((szHdr1) = ((uint)(*(aKey1)))), 1 : 
        sqlite3GetVarint32((aKey1), &(szHdr1)) ) )
        ;
				d1 = (uint)(szHdr1);
				i = (int)(0);
			}

			if ((d1) > ((uint)(nKey1)))
			{
				pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84319))));
				return (int)(0);
			}

			do
			{
				uint serial_type = 0;
				if ((pRhs.flags & (0x0004 | 0x0020)) != 0)
				{
					serial_type = (uint)(aKey1[idx1]);
					if ((serial_type) >= (10))
					{
						rc = (int)(+1);
					}
					else if ((serial_type) == (0))
					{
						rc = (int)(-1);
					}
					else if ((serial_type) == (7))
					{
						sqlite3VdbeSerialGet(&aKey1[d1], (uint)(serial_type), mem1);
						rc = (int)(-sqlite3IntFloatCompare((long)(pRhs.u.i), (double)(mem1.u.r)));
					}
					else
					{
						long lhs = (long)(vdbeRecordDecodeInt((uint)(serial_type), &aKey1[d1]));
						long rhs = (long)(pRhs.u.i);
						if ((lhs) < (rhs))
						{
							rc = (int)(-1);
						}
						else if ((lhs) > (rhs))
						{
							rc = (int)(+1);
						}
					}
				}
				else if ((pRhs.flags & 0x0008) != 0)
				{
					serial_type = (uint)(aKey1[idx1]);
					if ((serial_type) >= (10))
					{
						rc = (int)(+1);
					}
					else if ((serial_type) == (0))
					{
						rc = (int)(-1);
					}
					else
					{
						sqlite3VdbeSerialGet(&aKey1[d1], (uint)(serial_type), mem1);
						if ((serial_type) == (7))
						{
							if ((mem1.u.r) < (pRhs.u.r))
							{
								rc = (int)(-1);
							}
							else if ((mem1.u.r) > (pRhs.u.r))
							{
								rc = (int)(+1);
							}
						}
						else
						{
							rc = (int)(sqlite3IntFloatCompare((long)(mem1.u.i), (double)(pRhs.u.r)));
						}
					}
				}
				else if ((pRhs.flags & 0x0002) != 0)
				{
					serial_type = ((uint)(*(&aKey1[idx1])));
					if ((serial_type) >= (0x80))
						sqlite3GetVarint32((&aKey1[idx1]), &(serial_type));
					if ((serial_type) < (12))
					{
						rc = (int)(-1);
					}
					else if ((serial_type & 0x01) == 0)
					{
						rc = (int)(+1);
					}
					else
					{
						mem1.n = (int)((serial_type - 12) / 2);
						if (((d1 + mem1.n) > ((uint)(nKey1))) || (((pKeyInfo = pPKey2.pKeyInfo).nAllField) <= (i)))
						{
							pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84396))));
							return (int)(0);
						}
						else if ((pKeyInfo.aColl[i]) != null)
						{
							mem1.enc = (byte)(pKeyInfo.enc);
							mem1.db = pKeyInfo.db;
							mem1.flags = (ushort)(0x0002);
							mem1.z = (sbyte*)(&aKey1[d1]);
							rc = (int)(vdbeCompareMemString(mem1, pRhs, pKeyInfo.aColl[i], &pPKey2.errCode));
						}
						else
						{
							int nCmp = (int)((mem1.n) < (pRhs.n) ? (mem1.n) : (pRhs.n));
							rc = (int)(memcmp(&aKey1[d1], pRhs.z, (ulong)(nCmp)));
							if ((rc) == (0))
								rc = (int)(mem1.n - pRhs.n);
						}
					}
				}
				else if ((pRhs.flags & 0x0010) != 0)
				{
					serial_type = ((uint)(*(&aKey1[idx1])));
					if ((serial_type) >= (0x80))
						sqlite3GetVarint32((&aKey1[idx1]), &(serial_type));
					if (((serial_type) < (12)) || ((serial_type & 0x01) != 0))
					{
						rc = (int)(-1);
					}
					else
					{
						int nStr = (int)((serial_type - 12) / 2);
						if ((d1 + nStr) > ((uint)(nKey1)))
						{
							pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84426))));
							return (int)(0);
						}
						else if ((pRhs.flags & 0x4000) != 0)
						{
							if (isAllZero((sbyte*)(&aKey1[d1]), (int)(nStr)) == 0)
							{
								rc = (int)(1);
							}
							else
							{
								rc = (int)(nStr - pRhs.u.nZero);
							}
						}
						else
						{
							int nCmp = (int)((nStr) < (pRhs.n) ? (nStr) : (pRhs.n));
							rc = (int)(memcmp(&aKey1[d1], pRhs.z, (ulong)(nCmp)));
							if ((rc) == (0))
								rc = (int)(nStr - pRhs.n);
						}
					}
				}
				else
				{
					serial_type = (uint)(aKey1[idx1]);
					rc = (int)(serial_type != 0);
				}

				if (rc != 0)
				{
					int sortFlags = (int)(pPKey2.pKeyInfo.aSortFlags[i]);
					if ((sortFlags) != 0)
					{
						if (((sortFlags & 0x02) == (0)) || ((sortFlags & 0x01) != (((serial_type) == (0)) || ((pRhs.flags & 0x0001) != 0))))
						{
							rc = (int)(-rc);
						}
					}

					return (int)(rc);
				}

				i++;
				if ((i) == (pPKey2.nField))
					break;
				pRhs++;
				d1 += (uint)(sqlite3VdbeSerialTypeLen((uint)(serial_type)));
				idx1 += (uint)(sqlite3VarintLen((ulong)(serial_type)));
			}
			while (((idx1) < (szHdr1)) && ((d1) <= ((uint)(nKey1))));
			pPKey2.eqSeen = (byte)(1);
			return (int)(pPKey2.default_rc);
		}
		public static void sqlite3VdbeSerialGet(byte* buf, uint serial_type, sqlite3_value pMem)
		{
			switch (serial_type)
			{
				case 10:
					{
						pMem.flags = (ushort)(0x0001 | 0x4000);
						pMem.n = (int)(0);
						pMem.u.nZero = (int)(0);
						return;
					}

				case 11:
				case 0:
					{
						pMem.flags = (ushort)(0x0001);
						return;
					}

				case 1:
					{
						pMem.u.i = (long)((sbyte)((buf)[0]));
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 2:
					{
						pMem.u.i = (long)(256 * (sbyte)((buf)[0]) | (buf)[1]);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 3:
					{
						pMem.u.i = (long)(65536 * (sbyte)((buf)[0]) | ((buf)[1] << 8) | (buf)[2]);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 4:
					{
						pMem.u.i = (long)(16777216 * (sbyte)((buf)[0]) | ((buf)[1] << 16) | ((buf)[2] << 8) | (buf)[3]);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 5:
					{
						pMem.u.i = (long)((((uint)((buf + 2)[0]) << 24) | ((buf + 2)[1] << 16) | ((buf + 2)[2] << 8) | (buf + 2)[3]) + (((long)(1)) << 32) * (256 * (sbyte)((buf)[0]) | (buf)[1]));
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 6:
				case 7:
					{
						serialGet(buf, (uint)(serial_type), pMem);
						return;
					}

				case 8:
				case 9:
					{
						pMem.u.i = (long)(serial_type - 8);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				default:
					{
						pMem.z = (sbyte*)(buf);
						pMem.n = (int)((serial_type - 12) / 2);
						pMem.flags = (ushort)(sqlite3VdbeSerialGet_aFlag[serial_type & 1]);
						return;
					}
			}

			return;
		}
		public static uint sqlite3VdbeSerialPut(byte* buf, sqlite3_value pMem, uint serial_type)
		{
			uint len = 0;
			if (((serial_type) <= (7)) && ((serial_type) > (0)))
			{
				ulong v = 0;
				uint i = 0;
				if ((serial_type) == (7))
				{
					CRuntime.memcpy(&v, &pMem.u.r, (ulong)(sizeof(ulong)));
				}
				else
				{
					v = (ulong)(pMem.u.i);
				}

				len = (uint)(i = (uint)(sqlite3SmallTypeSizes[serial_type]));
				do
				{
					buf[--i] = ((byte)(v & 0xFF));
					v >>= 8;
				}
				while ((i) != 0);
				return (uint)(len);
			}

			if ((serial_type) >= (12))
			{
				len = (uint)(pMem.n);
				if ((len) > (0))
					CRuntime.memcpy(buf, pMem.z, (ulong)(len));
				return (uint)(len);
			}

			return (uint)(0);
		}
		public static uint sqlite3VdbeSerialTypeLen(uint serial_type)
		{
			if ((serial_type) >= (128))
			{
				return (uint)((serial_type - 12) / 2);
			}
			else
			{
				return (uint)(sqlite3SmallTypeSizes[serial_type]);
			}
		}
		public static VdbeOp* sqlite3VdbeTakeOpArray(Vdbe p, int* pnOp, int* pnMaxArg)
		{
			VdbeOp* aOp = p.aOp;
			resolveP2Values(p, pnMaxArg);
			*pnOp = (int)(p.nOp);
			p.aOp = null;
			return aOp;
		}
		public static int* sqlite3VListAdd(sqlite3 db, int* pIn, sbyte* zName, int nName, int iVal)
		{
			int nInt = 0;
			sbyte* z;
			int i = 0;
			nInt = (int)(nName / 4 + 3);
			if (((pIn) == (null)) || ((pIn[1] + nInt) > (pIn[0])))
			{
				long nAlloc = (long)(((pIn) != 0 ? 2 * (long)(pIn[0]) : 10) + nInt);
				int* pOut = sqlite3DbRealloc(db, pIn, (ulong)(nAlloc * sizeof(int)));
				if ((pOut) == (null))
					return pIn;
				if ((pIn) == (null))
					pOut[1] = (int)(2);
				pIn = pOut;
				pIn[0] = (int)(nAlloc);
			}

			i = (int)(pIn[1]);
			pIn[i] = (int)(iVal);
			pIn[i + 1] = (int)(nInt);
			z = (sbyte*)(&pIn[i + 2]);
			pIn[1] = (int)(i + nInt);
			CRuntime.memcpy(z, zName, (ulong)(nName));
			z[nName] = (sbyte)(0);
			return pIn;
		}
		public static int sqlite3VListNameToNum(int* pIn, sbyte* zName, int nName)
		{
			int i = 0; int mx = 0;
			if ((pIn) == (null))
				return (int)(0);
			mx = (int)(pIn[1]);
			i = (int)(2);
			do
			{
				sbyte* z = (sbyte*)(&pIn[i + 2]);
				if (((CRuntime.strncmp(z, zName, (ulong)(nName))) == (0)) && ((z[nName]) == (0)))
					return (int)(pIn[i]);
				i += (int)(pIn[i + 1]);
			}
			while ((i) < (mx));
			return (int)(0);
		}
		public static sbyte* sqlite3VListNumToName(int* pIn, int iVal)
		{
			int i = 0; int mx = 0;
			if ((pIn) == (null))
				return null;
			mx = (int)(pIn[1]);
			i = (int)(2);
			do
			{
				if ((pIn[i]) == (iVal))
					return (sbyte*)(&pIn[i + 2]);
				i += (int)(pIn[i + 1]);
			}
			while ((i) < (mx));
			return null;
		}
		public static sbyte* sqlite3VMPrintf(sqlite3 db, sbyte* zFormat, sbyte* ap)
		{
			sbyte* z;
			sbyte* zBase = stackalloc sbyte[70];
			sqlite3_str acc = new sqlite3_str();
			sqlite3StrAccumInit(acc, db, zBase, (int)(70 * sizeof(sbyte)), (int)(db.aLimit[0]));
			acc.printfFlags = (byte)(0x01);
			sqlite3_str_vappendf(acc, zFormat, ap);
			z = sqlite3StrAccumFinish(acc);
			if ((acc.accError) == (7))
			{
				sqlite3OomFault(db);
			}

			return z;
		}
		public static int sqlite3WalDefaultHook(void* pClientData, sqlite3 db, sbyte* zDb, int nFrame)
		{
			if ((nFrame) >= ((int)((long)(pClientData))))
			{
				sqlite3BeginBenignMalloc();
				sqlite3_wal_checkpoint(db, zDb);
				sqlite3EndBenignMalloc();
			}

			return (int)(0);
		}
		public static uint sqlite3Win32Wait(void* hObject)
		{
			uint rc = 0;
			while ((rc = (uint)((Uint(Void * , Void * , Void * ))(aSyscall[64].pCurrent)(hObject, (uint)(0xFFFFFFFF), (int)(1)))) == ((uint)(0x000000C0L)))
			{
			}

			return (uint)(rc);
		}
		public static void sqlite3WindowFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3WindowFunctions_aWindowFuncs, ((int)(15 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static int sqliteDefaultBusyCallback(void* ptr, int count)
		{
			sqlite3 db = (sqlite3)(ptr);
			int tmout = (int)(db.busyTimeout);
			int delay = 0; int prior = 0;
			if ((count) < ((int)(12 * sizeof(byte) / sizeof(byte))))
			{
				delay = (int)(sqliteDefaultBusyCallback_delays[count]);
				prior = (int)(sqliteDefaultBusyCallback_totals[count]);
			}
			else
			{
				delay = (int)(sqliteDefaultBusyCallback_delays[((int)(12 * sizeof(byte) / sizeof(byte))) - 1]);
				prior = (int)(sqliteDefaultBusyCallback_totals[((int)(12 * sizeof(byte) / sizeof(byte))) - 1] + delay * (count - (((int)(12 * sizeof(byte) / sizeof(byte))) - 1)));
			}

			if ((prior + delay) > (tmout))
			{
				delay = (int)(tmout - prior);
				if ((delay) <= (0))
					return (int)(0);
			}

			sqlite3OsSleep(db.pVfs, (int)(delay * 1000));
			return (int)(1);
		}
		public static void statAccumDestructor(void* pOld)
		{
			StatAccum p = (StatAccum)(pOld);
			sqlite3DbFree(p.db, p);
		}
		public static sbyte* strAccumFinishRealloc(sqlite3_str p)
		{
			sbyte* zText;
			zText = sqlite3DbMallocRaw(p.db, (ulong)(p.nChar + 1));
			if ((zText) != null)
			{
				CRuntime.memcpy(zText, p.zText, (ulong)(p.nChar + 1));
				p.printfFlags |= (byte)(0x04);
			}
			else
			{
				sqlite3StrAccumSetError(p, (byte)(7));
			}

			p.zText = zText;
			return zText;
		}
		public static uint strHash(sbyte* z)
		{
			uint h = (uint)(0);
			byte c = 0;
			while ((c = ((byte)(*z++))) != 0)
			{
				h += (uint)(sqlite3UpperToLower[c]);
				h *= (uint)(0x9e3779b1);
			}

			return (uint)(h);
		}
		public static sbyte* triggerSpanDup(sqlite3 db, sbyte* zStart, sbyte* zEnd)
		{
			sbyte* z = sqlite3DbSpanDup(db, zStart, zEnd);
			int i = 0;
			if ((z) != null)
				for (i = (int)(0); z[i]; i++)
				{
					if ((sqlite3CtypeMap[(byte)(z[i])] & 0x01) != 0)
						z[i] = (sbyte)(32);
				}

			return z;
		}
		public static sbyte* uriParameter(sbyte* zFilename, sbyte* zParam)
		{
			zFilename += sqlite3Strlen30(zFilename) + 1;
			while ((zFilename != null) && ((zFilename[0]) != 0))
			{
				int x = (int)(CRuntime.strcmp(zFilename, zParam));
				zFilename += sqlite3Strlen30(zFilename) + 1;
				if ((x) == (0))
					return zFilename;
				zFilename += sqlite3Strlen30(zFilename) + 1;
			}

			return null;
		}
		public static int validJulianDay(long iJD)
		{
			return (((iJD) >= (0)) && ((iJD) <= ((((long)(0x1a640)) << 32) | 0x1072fdff)) ? 1 : 0);
		}
		public static void* valueToText(sqlite3_value pVal, byte enc)
		{
			if ((pVal.flags & (0x0010 | 0x0002)) != 0)
			{
				if ((((pVal).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pVal) : 0) != 0)
					return null;
				pVal.flags |= (ushort)(0x0002);
				if (pVal.enc != (enc & ~8))
				{
					sqlite3VdbeChangeEncoding(pVal, (int)(enc & ~8));
				}

				if (((enc & 8) != 0) && ((1) == (1 & ((int)((long)(pVal.z))))))
				{
					if (sqlite3VdbeMemMakeWriteable(pVal) != 0)
					{
						return null;
					}
				}

				sqlite3VdbeMemNulTerminate(pVal);
			}
			else
			{
				sqlite3VdbeMemStringify(pVal, (byte)(enc), (byte)(0));
			}

			if ((pVal.enc) == (enc & ~8))
			{
				return pVal.z;
			}
			else
			{
				return null;
			}
		}
		public static void* vdbeIncrPopulateThread(void* pCtx)
		{
			IncrMerger pIncr = (IncrMerger)(pCtx);
			void* pRet = ((void*)((long)(vdbeIncrPopulate(pIncr))));
			pIncr.pTask.bDone = (int)(1);
			return pRet;
		}
		public static void vdbeMemRenderNum(int sz, sbyte* zBuf, sqlite3_value p)
		{
			sqlite3_str acc = new sqlite3_str();
			if ((p.flags & 0x0004) != 0)
			{
				sqlite3Int64ToText((long)(p.u.i), zBuf);
			}
			else
			{
				sqlite3StrAccumInit(acc, null, zBuf, (int)(sz), (int)(0));
				sqlite3_str_appendf(acc, "%!.15g", (double)((p.flags & 0x0020) != 0 ? (double)(p.u.i) : p.u.r));
				zBuf[acc.nChar] = (sbyte)(0);
			}
		}
		public static sbyte* vdbeMemTypeName(sqlite3_value pMem)
		{
			return vdbeMemTypeName_azTypes[sqlite3_value_type(pMem) - 1];
		}
		public static MergeEngine vdbeMergeEngineNew(int nReader)
		{
			int N = (int)(2);
			int nByte = 0;
			MergeEngine pNew;
			while ((N) < (nReader))
			{
				N += (int)(N);
			}

			nByte = (int)(sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader)));
			pNew = (sqlite3FaultSim((int)(100))) != 0 ? null : (MergeEngine)(sqlite3MallocZero((ulong)(nByte)));
			if ((pNew) != null)
			{
				pNew.nTree = (int)(N);
				pNew.pTask = null;
				pNew.aReadr = (PmaReader)(pNew[1]);
				pNew.aTree = (int*)(pNew.aReadr[N]);
			}

			return pNew;
		}
		public static void* vdbePmaReaderBgIncrInit(void* pCtx)
		{
			PmaReader pReader = (PmaReader)(pCtx);
			void* pRet = ((void*)((long)(vdbePmaReaderIncrMergeInit(pReader, (int)(1)))));
			pReader.pIncr.pTask.bDone = (int)(1);
			return pRet;
		}
		public static int vdbeRecordCompareInt(int nKey1, void* pKey1, UnpackedRecord pPKey2)
		{
			byte* aKey = &((byte*)(pKey1))[*(byte*)(pKey1) & 0x3F];
			int serial_type = (int)(((byte*)(pKey1))[1]);
			int res = 0;
			uint y = 0;
			ulong x = 0;
			long v = 0;
			long lhs = 0;
			switch (serial_type)
			{
				case 1:
					{
						lhs = (long)((sbyte)((aKey)[0]));
						break;
					}

				case 2:
					{
						lhs = (long)(256 * (sbyte)((aKey)[0]) | (aKey)[1]);
						break;
					}

				case 3:
					{
						lhs = (long)(65536 * (sbyte)((aKey)[0]) | ((aKey)[1] << 8) | (aKey)[2]);
						break;
					}

				case 4:
					{
						y = (uint)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						lhs = ((long)(*(int*)(&y)));
						break;
					}

				case 5:
					{
						lhs = (long)((((uint)((aKey + 2)[0]) << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((long)(1)) << 32) * (256 * (sbyte)((aKey)[0]) | (aKey)[1]));
						break;
					}

				case 6:
					{
						x = (ulong)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						x = (ulong)((x << 32) | (((uint)((aKey + 4)[0]) << 24) | ((aKey + 4)[1] << 16) | ((aKey + 4)[2] << 8) | (aKey + 4)[3]));
						lhs = (long)(*(long*)(&x));
						break;
					}

				case 8:
					lhs = (long)(0);
					break;
				case 9:
					lhs = (long)(1);
					break;
				case 0:
				case 7:
					return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, pPKey2));
				default:
					return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, pPKey2));
			}

			v = (long)(pPKey2.aMem[0].u.i);
			if ((v) > (lhs))
			{
				res = (int)(pPKey2.r1);
			}
			else if ((v) < (lhs))
			{
				res = (int)(pPKey2.r2);
			}
			else if ((pPKey2.nField) > (1))
			{
				res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(1)));
			}
			else
			{
				res = (int)(pPKey2.default_rc);
				pPKey2.eqSeen = (byte)(1);
			}

			return (int)(res);
		}
		public static int vdbeRecordCompareString(int nKey1, void* pKey1, UnpackedRecord pPKey2)
		{
			byte* aKey1 = (byte*)(pKey1);
			int serial_type = 0;
			int res = 0;
			serial_type = (int)(aKey1[1]);
			if ((serial_type) >= (0x80))
			{
				sqlite3GetVarint32(&aKey1[1], (uint*)(&serial_type));
			}

			if ((serial_type) < (12))
			{
				res = (int)(pPKey2.r1);
			}
			else if ((serial_type & 0x01) == 0)
			{
				res = (int)(pPKey2.r2);
			}
			else
			{
				int nCmp = 0;
				int nStr = 0;
				int szHdr = (int)(aKey1[0]);
				nStr = (int)((serial_type - 12) / 2);
				if ((szHdr + nStr) > (nKey1))
				{
					pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84621))));
					return (int)(0);
				}

				nCmp = (int)((pPKey2.aMem[0].n) < (nStr) ? (pPKey2.aMem[0].n) : (nStr));
				res = (int)(memcmp(&aKey1[szHdr], pPKey2.aMem[0].z, (ulong)(nCmp)));
				if ((res) > (0))
				{
					res = (int)(pPKey2.r2);
				}
				else if ((res) < (0))
				{
					res = (int)(pPKey2.r1);
				}
				else
				{
					res = (int)(nStr - pPKey2.aMem[0].n);
					if ((res) == (0))
					{
						if ((pPKey2.nField) > (1))
						{
							res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(1)));
						}
						else
						{
							res = (int)(pPKey2.default_rc);
							pPKey2.eqSeen = (byte)(1);
						}
					}
					else if ((res) > (0))
					{
						res = (int)(pPKey2.r2);
					}
					else
					{
						res = (int)(pPKey2.r1);
					}
				}
			}

			return (int)(res);
		}
		public static long vdbeRecordDecodeInt(uint serial_type, byte* aKey)
		{
			uint y = 0;
			switch (serial_type)
			{
				case 0:
				case 1:
					;
					return (long)((sbyte)((aKey)[0]));
				case 2:
					;
					return (long)(256 * (sbyte)((aKey)[0]) | (aKey)[1]);
				case 3:
					;
					return (long)(65536 * (sbyte)((aKey)[0]) | ((aKey)[1] << 8) | (aKey)[2]);
				case 4:
					{
						y = (uint)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						return (long)(*(int*)(&y));
					}

				case 5:
					{
						return (long)((((uint)((aKey + 2)[0]) << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((long)(1)) << 32) * (256 * (sbyte)((aKey)[0]) | (aKey)[1]));
					}

				case 6:
					{
						ulong x = (ulong)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						x = (ulong)((x << 32) | (((uint)((aKey + 4)[0]) << 24) | ((aKey + 4)[1] << 16) | ((aKey + 4)[2] << 8) | (aKey + 4)[3]));
						return (long)(*(long*)(&x));
					}
			}

			return (long)(serial_type - 8);
		}
		public static void* vdbeSorterFlushThread(void* pCtx)
		{
			SortSubtask pTask = (SortSubtask)(pCtx);
			int rc = 0;
			rc = (int)(vdbeSorterListToPMA(pTask, &pTask.list));
			pTask.bDone = (int)(1);
			return ((void*)((long)(rc)));
		}
		public static Int(SortSubtask* , SortSubtask* , SortSubtask* , SortSubtask* , SortSubtask* , SortSubtask* )vdbeSorterGetCompare(VdbeSorter p)
		{
			if ((p.typeMask) == (0x01))
			{
				return vdbeSorterCompareInt;
			}
			else if ((p.typeMask) == (0x02))
			{
				return vdbeSorterCompareText;
			}

			return vdbeSorterCompare;
		}
		public static SorterRecord* vdbeSorterMerge(SortSubtask pTask, SorterRecord* p1, SorterRecord* p2)
		{
			SorterRecord* pFinal = null;
			SorterRecord** pp = &pFinal;
			int bCached = (int)(0);
			for (; ; )
			{
				int res = 0;
				res = (int)(pTask.xCompare(pTask, &bCached, ((void*)((p1) + 1)), (int)(p1->nVal), ((void*)((p2) + 1)), (int)(p2->nVal)));
				if ((res) <= (0))
				{
					*pp = p1;
					pp = &p1->u.pNext;
					p1 = p1->u.pNext;
					if ((p1) == (null))
					{
						*pp = p2;
						break;
					}
				}
				else
				{
					*pp = p2;
					pp = &p2->u.pNext;
					p2 = p2->u.pNext;
					bCached = (int)(0);
					if ((p2) == (null))
					{
						*pp = p1;
						break;
					}
				}
			}

			return pFinal;
		}
		public static void* vdbeSorterRowkey(VdbeSorter pSorter, int* pnKey)
		{
			void* pKey;
			if ((pSorter.bUsePMA) != 0)
			{
				PmaReader pReader;
				if ((pSorter.bUseThreads) != 0)
				{
					pReader = pSorter.pReader;
				}
				else
				{
					pReader = pSorter.pMerger.aReadr[pSorter.pMerger.aTree[1]];
				}

				*pnKey = (int)(pReader.nKey);
				pKey = pReader.aKey;
			}
			else
			{
				*pnKey = (int)(pSorter.list.pList->nVal);
				pKey = ((void*)((pSorter.list.pList) + 1));
			}

			return pKey;
		}
		public static int vdbeSorterTreeDepth(int nPMA)
		{
			int nDepth = (int)(0);
			long nDiv = (long)(16);
			while ((nDiv) < ((long)(nPMA)))
			{
				nDiv = (long)(nDiv * 16);
				nDepth++;
			}

			return (int)(nDepth);
		}
		public static void walChecksumBytes(int nativeCksum, byte* a, int nByte, uint* aIn, uint* aOut)
		{
			uint s1 = 0; uint s2 = 0;
			uint* aData = (uint*)(a);
			uint* aEnd = (uint*)(&a[nByte]);
			if ((aIn) != null)
			{
				s1 = (uint)(aIn[0]);
				s2 = (uint)(aIn[1]);
			}
			else
			{
				s1 = (uint)(s2 = (uint)(0));
			}

			if ((nativeCksum) != 0)
			{
				do
				{
					s1 += (uint)(*aData++ + s2);
					s2 += (uint)(*aData++ + s1);
				}
				while ((aData) < (aEnd));
			}
			else
			{
				do
				{
					s1 += (uint)(((((aData[0]) & 0x000000FF) << 24) + (((aData[0]) & 0x0000FF00) << 8) + (((aData[0]) & 0x00FF0000) >> 8) + (((aData[0]) & 0xFF000000) >> 24)) + s2);
					s2 += (uint)(((((aData[1]) & 0x000000FF) << 24) + (((aData[1]) & 0x0000FF00) << 8) + (((aData[1]) & 0x00FF0000) >> 8) + (((aData[1]) & 0xFF000000) >> 24)) + s1);
					aData += 2;
				}
				while ((aData) < (aEnd));
			}

			aOut[0] = (uint)(s1);
			aOut[1] = (uint)(s2);
		}
		public static volatile WalCkptInfo* walCkptInfo(Wal pWal)
		{
			return ( volatile WalCkptInfo* ) (&(pWal.apWiData[0][sizeof(WalIndexHdr) / 2]));
		}
		public static int walFramePage(uint iFrame)
		{
			int iHash = (int)((iFrame + 4096 - (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) - 1) / 4096);
			return (int)(iHash);
		}
		public static int walHash(uint iPage)
		{
			return (int)((iPage * 383) & ((4096 * 2) - 1));
		}
		public static volatile WalIndexHdr* walIndexHdr(Wal pWal)
		{
			return ( volatile WalIndexHdr* ) (pWal.apWiData[0]);
		}
		public static void walMerge(uint* aContent, ushort* aLeft, int nLeft, ushort** paRight, int* pnRight, ushort* aTmp)
		{
			int iLeft = (int)(0);
			int iRight = (int)(0);
			int iOut = (int)(0);
			int nRight = (int)(*pnRight);
			ushort* aRight = *paRight;
			while (((iRight) < (nRight)) || ((iLeft) < (nLeft)))
			{
				ushort logpage = 0;
				uint dbpage = 0;
				if (((iLeft) < (nLeft)) && (((iRight) >= (nRight)) || ((aContent[aLeft[iLeft]]) < (aContent[aRight[iRight]]))))
				{
					logpage = (ushort)(aLeft[iLeft++]);
				}
				else
				{
					logpage = (ushort)(aRight[iRight++]);
				}

				dbpage = (uint)(aContent[logpage]);
				aTmp[iOut++] = (ushort)(logpage);
				if (((iLeft) < (nLeft)) && ((aContent[aLeft[iLeft]]) == (dbpage)))
					iLeft++;
			}

			*paRight = aLeft;
			*pnRight = (int)(iOut);
			CRuntime.memcpy(aLeft, aTmp, (ulong)(sizeof(ushort) * iOut));
		}
		public static void walMergesort(uint* aContent, ushort* aBuffer, ushort* aList, int* pnList)
		{
			int nList = (int)(*pnList);
			int nMerge = (int)(0);
			ushort* aMerge = null;
			int iList = 0;
			uint iSub = (uint)(0);
			Sublist* aSub = stackalloc Sublist[13];
			CRuntime.memset(aSub, (int)(0), (ulong)(13 * sizeof(Sublist)));
			for (iList = (int)(0); (iList) < (nList); iList++)
			{
				nMerge = (int)(1);
				aMerge = &aList[iList];
				for (iSub = (uint)(0); iList & (1 << iSub); iSub++)
				{
					Sublist* p;
					p = &aSub[iSub];
					walMerge(aContent, p->aList, (int)(p->nList), &aMerge, &nMerge, aBuffer);
				}

				aSub[iSub].aList = aMerge;
				aSub[iSub].nList = (int)(nMerge);
			}

			for (iSub++; (iSub) < ((int)(13 * sizeof(Sublist) / sizeof(Sublist))); iSub++)
			{
				if ((nList & (1 << iSub)) != 0)
				{
					Sublist* p;
					p = &aSub[iSub];
					walMerge(aContent, p->aList, (int)(p->nList), &aMerge, &nMerge, aBuffer);
				}
			}

			*pnList = (int)(nMerge);
		}
		public static int walNextHash(int iPriorHash)
		{
			return (int)((iPriorHash + 1) & ((4096 * 2) - 1));
		}
		public static int whereUsablePartialIndex(int iTab, int isLeft, WhereClause pWC, Expr pWhere)
		{
			int i = 0;
			WhereTerm pTerm;
			Parse pParse = pWC.pWInfo.pParse;
			while ((pWhere.op) == (44))
			{
				if (whereUsablePartialIndex((int)(iTab), (int)(isLeft), pWC, pWhere.pLeft) == 0)
					return (int)(0);
				pWhere = pWhere.pRight;
			}

			if ((pParse.db.flags & 0x00800000) != 0)
				pParse = null;
			for (i = (int)(0), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				Expr pExpr;
				pExpr = pTerm.pExpr;
				if (((((!(((pExpr).flags & (0x000001)) != 0)) || ((pExpr.w.iRightJoinTable) == (iTab))) && (((isLeft) == (0)) || (((pExpr).flags & (0x000001)) != 0))) && ((sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, (int)(iTab))) != 0)) && ((pTerm.wtFlags & 0x0080) == (0)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static void* winConvertFromUtf8Filename(sbyte* zFilename)
		{
			void* zConverted = null;
			if ((1) != 0)
			{
				zConverted = winUtf8ToUnicode(zFilename);
			}
			else
			{
				zConverted = winUtf8ToMbcs(zFilename, (int)((Int())(aSyscall[0].pCurrent)()));
			}

			return zConverted;
		}
		public static void* winDlOpen(sqlite3_vfs pVfs, sbyte* zFilename)
		{
			void* h;
			void* zConverted = winConvertFromUtf8Filename(zFilename);
			if ((zConverted) == (null))
			{
				return null;
			}

			if ((1) != 0)
			{
				h = (HINSTANCE__ * (UShort*))(aSyscall[45].pCurrent)((ushort*)(zConverted));
			}
			else
			{
				h = (HINSTANCE__ * (Sbyte*))(aSyscall[44].pCurrent)((sbyte*)(zConverted));
			}

			sqlite3_free(zConverted);
			return h;
		}
		public static Void()winDlSym(sqlite3_vfs pVfs, void* pH, sbyte* zSym)
		{
			long  long() * proc;
			proc = (longlong() * (HINSTANCE__ * , HINSTANCE__ * ))(aSyscall[27].pCurrent)(pH, zSym);
			return (Void())(proc);
		}
		public static int winGetLastErrorMsg(uint lastErrno, int nBuf, sbyte* zBuf)
		{
			uint dwLen = (uint)(0);
			sbyte* zOut = null;
			if ((1) != 0)
			{
				ushort* zTempWide = null;
				dwLen = (uint)((Uint(Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[15].pCurrent)((uint)(0x00000100 | 0x00001000 | 0x00000200), null, (uint)(lastErrno), (uint)(0), (ushort*)(&zTempWide), (uint)(0), null));
				if ((dwLen) > (0))
				{
					sqlite3BeginBenignMalloc();
					zOut = winUnicodeToUtf8(zTempWide);
					sqlite3EndBenignMalloc();
					(Void * (Void*))(aSyscall[46].pCurrent)(zTempWide);
				}
			}
			else
			{
				sbyte* zTemp = null;
				dwLen = (uint)((Uint(Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[14].pCurrent)((uint)(0x00000100 | 0x00001000 | 0x00000200), null, (uint)(lastErrno), (uint)(0), (sbyte*)(&zTemp), (uint)(0), null));
				if ((dwLen) > (0))
				{
					sqlite3BeginBenignMalloc();
					zOut = winMbcsToUtf8(zTemp, (int)((Int())(aSyscall[0].pCurrent)()));
					sqlite3EndBenignMalloc();
					(Void * (Void*))(aSyscall[46].pCurrent)(zTemp);
				}
			}

			if ((0) == (dwLen))
			{
				sqlite3_snprintf((int)(nBuf), zBuf, "OsError 0x%lx (%lu)", (uint)(lastErrno), (uint)(lastErrno));
			}
			else
			{
				sqlite3_snprintf((int)(nBuf), zBuf, "%s", zOut);
				sqlite3_free(zOut);
			}

			return (int)(0);
		}
		public static Void()winGetSystemCall(sqlite3_vfs pNotUsed, sbyte* zName)
		{
			uint i = 0;
			for (i = (uint)(0); (i) < (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
			{
				if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
					return aSyscall[i].pCurrent;
			}

			return null;
		}
		public static int winIsDriveLetterAndColon(sbyte* zPathname)
		{
			return ((((sqlite3CtypeMap[(byte)(zPathname[0])] & 0x02) != 0) && ((zPathname[1]) == (58))) ? 1 : 0);
		}
		public static int winIsLongPathPrefix(sbyte* zPathname)
		{
			return ((((((zPathname[0]) == (92)) && ((zPathname[1]) == (92))) && ((zPathname[2]) == (63))) && ((zPathname[3]) == (92))) ? 1 : 0);
		}
		public static int winIsVerbatimPathname(sbyte* zPathname)
		{
			if ((((zPathname[0]) == (47)) || ((zPathname[0]) == (92))))
			{
				return (int)(1);
			}

			if ((winIsDriveLetterAndColon(zPathname)) != 0)
			{
				return (int)(1);
			}

			return (int)(0);
		}
		public static int winLockFile(void** phFile, uint flags, uint offsetLow, uint offsetHigh, uint numBytesLow, uint numBytesHigh)
		{
			if ((1) != 0)
			{
				_OVERLAPPED ovlp = new _OVERLAPPED();
				CRuntime.memset(&ovlp, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
				ovlp..Offset = (uint)(offsetLow);
				ovlp..OffsetHigh = (uint)(offsetHigh);
				return (int)((Int(Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[48].pCurrent)(*phFile, (uint)(flags), (uint)(0), (uint)(numBytesLow), (uint)(numBytesHigh), &ovlp));
			}
			else
			{
				return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[47].pCurrent)(*phFile, (uint)(offsetLow), (uint)(offsetHigh), (uint)(numBytesLow), (uint)(numBytesHigh)));
			}
		}
		public static int winLogErrorAtLine(int errcode, uint lastErrno, sbyte* zFunc, sbyte* zPath, int iLine)
		{
			sbyte* zMsg = stackalloc sbyte[500];
			int i = 0;
			zMsg[0] = (sbyte)(0);
			winGetLastErrorMsg((uint)(lastErrno), (int)(500 * sizeof(sbyte)), zMsg);
			if ((zPath) == (null))
				zPath = "";
			for (i = (int)(0); (((zMsg[i]) != 0) && (zMsg[i] != 13)) && (zMsg[i] != 10); i++)
			{
			}

			zMsg[i] = (sbyte)(0);
			sqlite3_log((int)(errcode), "os_win.c:%d: (%lu) %s(%s) - %s", (int)(iLine), (uint)(lastErrno), zFunc, zPath, zMsg);
			return (int)(errcode);
		}
		public static void winLogIoerr(int nRetry, int lineno)
		{
			if ((nRetry) != 0)
			{
				sqlite3_log((int)(27), "delayed %dms for lock/sharing conflict at line %d", (int)(winIoerrRetryDelay * nRetry * (nRetry + 1) / 2), (int)(lineno));
			}
		}
		public static int winMakeEndInDirSep(int nBuf, sbyte* zBuf)
		{
			if ((zBuf) != null)
			{
				int nLen = (int)(sqlite3Strlen30(zBuf));
				if ((nLen) > (0))
				{
					if ((((zBuf[nLen - 1]) == (47)) || ((zBuf[nLen - 1]) == (92))))
					{
						return (int)(1);
					}
					else if ((nLen + 1) < (nBuf))
					{
						zBuf[nLen] = (sbyte)(92);
						zBuf[nLen + 1] = (sbyte)(0);
						return (int)(1);
					}
				}
			}

			return (int)(0);
		}
		public static ushort* winMbcsToUnicode(sbyte* zText, int useAnsi)
		{
			int nByte = 0;
			ushort* zMbcsText;
			int codepage = (int)((useAnsi) != 0 ? 0 : 1);
			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(codepage), (uint)(0), zText, (int)(-1), null, (int)(0)) * sizeof(ushort));
			if ((nByte) == (0))
			{
				return null;
			}

			zMbcsText = sqlite3MallocZero((ulong)(nByte * sizeof(ushort)));
			if ((zMbcsText) == (null))
			{
				return null;
			}

			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(codepage), (uint)(0), zText, (int)(-1), zMbcsText, (int)(nByte)));
			if ((nByte) == (0))
			{
				sqlite3_free(zMbcsText);
				zMbcsText = null;
			}

			return zMbcsText;
		}
		public static sbyte* winMbcsToUtf8(sbyte* zText, int useAnsi)
		{
			sbyte* zTextUtf8;
			ushort* zTmpWide;
			zTmpWide = winMbcsToUnicode(zText, (int)(useAnsi));
			if ((zTmpWide) == (null))
			{
				return null;
			}

			zTextUtf8 = winUnicodeToUtf8(zTmpWide);
			sqlite3_free(zTmpWide);
			return zTextUtf8;
		}
		public static sqlite3_mutex* winMutexAlloc(int iType)
		{
			sqlite3_mutex* p;
			switch (iType)
			{
				case 0:
				case 1:
					{
						p = sqlite3MallocZero((ulong)(sizeof(sqlite3_mutex)));
						if ((p) != null)
						{
							p->id = (int)(iType);
							InitializeCriticalSection(&p->mutex);
						}

						break;
					}

				default:
					{
						p = &winMutex_staticMutexes[iType - 2];
						break;
					}
			}

			return p;
		}
		public static int winMutexEnd()
		{
			if ((_InterlockedCompareExchange(&winMutex_lock, (int)(0), (int)(1))) == (1))
			{
				if ((winMutex_isInit) == (1))
				{
					int i = 0;
					for (i = (int)(0); (i) < ((int)(12 * sizeof(sqlite3_mutex) / sizeof(sqlite3_mutex))); i++)
					{
						DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);
					}

					winMutex_isInit = (int)(0);
				}
			}

			return (int)(0);
		}
		public static int winMutexInit()
		{
			if ((_InterlockedCompareExchange(&winMutex_lock, (int)(1), (int)(0))) == (0))
			{
				int i = 0;
				for (i = (int)(0); (i) < ((int)(12 * sizeof(sqlite3_mutex) / sizeof(sqlite3_mutex))); i++)
				{
					InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);
				}

				winMutex_isInit = (int)(1);
			}
			else
			{
				while (winMutex_isInit == 0)
				{
					sqlite3_win32_sleep((uint)(1));
				}
			}

			return (int)(0);
		}
		public static sbyte* winNextSystemCall(sqlite3_vfs p, sbyte* zName)
		{
			int i = (int)(-1);
			if ((zName) != null)
			{
				for (i = (int)(0); (i) < (((int)(80 * sizeof(win_syscall) / sizeof(win_syscall))) - 1); i++)
				{
					if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
						break;
				}
			}

			for (i++; (i) < ((int)(80 * sizeof(win_syscall) / sizeof(win_syscall))); i++)
			{
				if (aSyscall[i].pCurrent != null)
					return aSyscall[i].zName;
			}

			return null;
		}
		public static int winRetryIoerr(int* pnRetry, uint* pError)
		{
			uint e = (uint)((Uint())(aSyscall[26].pCurrent)());
			if ((*pnRetry) >= (winIoerrRetry))
			{
				if ((pError) != null)
				{
					*pError = (uint)(e);
				}

				return (int)(0);
			}

			if (((((((((e) == (5L)) || ((e) == (32L))) || ((e) == (33L))) || ((e) == (55L))) || ((e) == (64L))) || ((e) == (121L))) || ((e) == (1231L))))
			{
				sqlite3_win32_sleep((uint)(winIoerrRetryDelay * (1 + *pnRetry)));
				++*pnRetry;
				return (int)(1);
			}

			if ((pError) != null)
			{
				*pError = (uint)(e);
			}

			return (int)(0);
		}
		public static void winShmEnterMutex()
		{
			sqlite3_mutex_enter(winBigLock);
		}
		public static void winShmLeaveMutex()
		{
			sqlite3_mutex_leave(winBigLock);
		}
		public static sbyte* winUnicodeToMbcs(ushort* zWideText, int useAnsi)
		{
			int nByte = 0;
			sbyte* zText;
			int codepage = (int)((useAnsi) != 0 ? 0 : 1);
			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(codepage), (uint)(0), zWideText, (int)(-1), null, (int)(0), null, null));
			if ((nByte) == (0))
			{
				return null;
			}

			zText = sqlite3MallocZero((ulong)(nByte));
			if ((zText) == (null))
			{
				return null;
			}

			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(codepage), (uint)(0), zWideText, (int)(-1), zText, (int)(nByte), null, null));
			if ((nByte) == (0))
			{
				sqlite3_free(zText);
				zText = null;
			}

			return zText;
		}
		public static sbyte* winUnicodeToUtf8(ushort* zWideText)
		{
			int nByte = 0;
			sbyte* zText;
			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(65001), (uint)(0), zWideText, (int)(-1), null, (int)(0), null, null));
			if ((nByte) == (0))
			{
				return null;
			}

			zText = sqlite3MallocZero((ulong)(nByte));
			if ((zText) == (null))
			{
				return null;
			}

			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(65001), (uint)(0), zWideText, (int)(-1), zText, (int)(nByte), null, null));
			if ((nByte) == (0))
			{
				sqlite3_free(zText);
				zText = null;
			}

			return zText;
		}
		public static int winUnlockFile(void** phFile, uint offsetLow, uint offsetHigh, uint numBytesLow, uint numBytesHigh)
		{
			if ((1) != 0)
			{
				_OVERLAPPED ovlp = new _OVERLAPPED();
				CRuntime.memset(&ovlp, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
				ovlp..Offset = (uint)(offsetLow);
				ovlp..OffsetHigh = (uint)(offsetHigh);
				return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[58].pCurrent)(*phFile, (uint)(0), (uint)(numBytesLow), (uint)(numBytesHigh), &ovlp));
			}
			else
			{
				return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[57].pCurrent)(*phFile, (uint)(offsetLow), (uint)(offsetHigh), (uint)(numBytesLow), (uint)(numBytesHigh)));
			}
		}
		public static sbyte* winUtf8ToMbcs(sbyte* zText, int useAnsi)
		{
			sbyte* zTextMbcs;
			ushort* zTmpWide;
			zTmpWide = winUtf8ToUnicode(zText);
			if ((zTmpWide) == (null))
			{
				return null;
			}

			zTextMbcs = winUnicodeToMbcs(zTmpWide, (int)(useAnsi));
			sqlite3_free(zTmpWide);
			return zTextMbcs;
		}
		public static ushort* winUtf8ToUnicode(sbyte* zText)
		{
			int nChar = 0;
			ushort* zWideText;
			nChar = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(65001), (uint)(0), zText, (int)(-1), null, (int)(0)));
			if ((nChar) == (0))
			{
				return null;
			}

			zWideText = sqlite3MallocZero((ulong)(nChar * sizeof(ushort)));
			if ((zWideText) == (null))
			{
				return null;
			}

			nChar = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(65001), (uint)(0), zText, (int)(-1), zWideText, (int)(nChar)));
			if ((nChar) == (0))
			{
				sqlite3_free(zWideText);
				zWideText = null;
			}

			return zWideText;
		}
		public static ushort yy_find_reduce_action(ushort stateno, ushort iLookAhead)
		{
			int i = 0;
			i = (int)(yy_reduce_ofst[stateno]);
			i += (int)(iLookAhead);
			return (ushort)(yy_action[i]);
		}
		public static ushort yy_find_shift_action(ushort iLookAhead, ushort stateno)
		{
			int i = 0;
			if ((stateno) > (573))
				return (ushort)(stateno);
			do
			{
				i = (int)(yy_shift_ofst[stateno]);
				i += (int)(iLookAhead);
				if (yy_lookahead[i] != iLookAhead)
				{
					ushort iFallback = 0;
					iFallback = (ushort)(yyFallback[iLookAhead]);
					if (iFallback != 0)
					{
						iLookAhead = (ushort)(iFallback);
						continue;
					}

					{
						int j = (int)(i - iLookAhead + 101);
						if (((yy_lookahead[j]) == (101)) && ((iLookAhead) > (0)))
						{
							return (ushort)(yy_action[j]);
						}
					}

					return (ushort)(yy_default[stateno]);
				}
				else
				{
					return (ushort)(yy_action[i]);
				}
			}
			while ((1) != 0);
		}
	}
}