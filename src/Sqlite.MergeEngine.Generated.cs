// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void vdbeMergeEngineCompare(MergeEngine pMerger, int iOut)
		{
			int i1 = 0;
			int i2 = 0;
			int iRes = 0;
			PmaReader p1;
			PmaReader p2;
			if ((iOut) >= (pMerger.nTree / 2))
			{
				i1 = (int)((iOut - pMerger.nTree / 2) * 2);
				i2 = (int)(i1 + 1);
			}
			else
			{
				i1 = (int)(pMerger.aTree[iOut * 2]);
				i2 = (int)(pMerger.aTree[iOut * 2 + 1]);
			}

			p1 = pMerger.aReadr[i1];
			p2 = pMerger.aReadr[i2];
			if ((p1.pFd) == (null))
			{
				iRes = (int)(i2);
			}
			else if ((p2.pFd) == (null))
			{
				iRes = (int)(i1);
			}
			else
			{
				SortSubtask pTask = pMerger.pTask;
				int bCached = (int)(0);
				int res = 0;
				res = (int)(pTask.xCompare(pTask, &bCached, p1.aKey, (int)(p1.nKey), p2.aKey, (int)(p2.nKey)));
				if ((res) <= (0))
				{
					iRes = (int)(i1);
				}
				else
				{
					iRes = (int)(i2);
				}
			}

			pMerger.aTree[iOut] = (int)(iRes);
		}
		public static void vdbeMergeEngineFree(MergeEngine pMerger)
		{
			int i = 0;
			if ((pMerger) != null)
			{
				for (i = (int)(0); (i) < (pMerger.nTree); i++)
				{
					vdbePmaReaderClear(pMerger.aReadr[i]);
				}
			}

			sqlite3_free(pMerger);
		}
		public static int vdbeMergeEngineStep(MergeEngine pMerger, int* pbEof)
		{
			int rc = 0;
			int iPrev = (int)(pMerger.aTree[1]);
			SortSubtask pTask = pMerger.pTask;
			rc = (int)(vdbePmaReaderNext(pMerger.aReadr[iPrev]));
			if ((rc) == (0))
			{
				int i = 0;
				PmaReader pReadr1;
				PmaReader pReadr2;
				int bCached = (int)(0);
				pReadr1 = pMerger.aReadr[(iPrev & 0xFFFE)];
				pReadr2 = pMerger.aReadr[(iPrev | 0x0001)];
				for (i = (int)((pMerger.nTree + iPrev) / 2); (i) > (0); i = (int)(i / 2))
				{
					int iRes = 0;
					if ((pReadr1.pFd) == (null))
					{
						iRes = (int)(+1);
					}
					else if ((pReadr2.pFd) == (null))
					{
						iRes = (int)(-1);
					}
					else
					{
						iRes = (int)(pTask.xCompare(pTask, &bCached, pReadr1.aKey, (int)(pReadr1.nKey), pReadr2.aKey, (int)(pReadr2.nKey)));
					}

					if (((iRes) < (0)) || (((iRes) == (0)) && ((pReadr1) < (pReadr2))))
					{
						pMerger.aTree[i] = ((int)(pReadr1 - pMerger.aReadr));
						pReadr2 = pMerger.aReadr[pMerger.aTree[i ^ 0x0001]];
						bCached = (int)(0);
					}
					else
					{
						if ((pReadr1.pFd) != null)
							bCached = (int)(0);
						pMerger.aTree[i] = ((int)(pReadr2 - pMerger.aReadr));
						pReadr1 = pMerger.aReadr[pMerger.aTree[i ^ 0x0001]];
					}
				}

				*pbEof = (int)((pMerger.aReadr[pMerger.aTree[1]].pFd) == (null) ? 1 : 0);
			}

			return (int)((rc) == (0) ? pTask.pUnpacked.errCode : rc);
		}
	}
}