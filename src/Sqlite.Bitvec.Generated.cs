	// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void sqlite3BitvecClear(Bitvec* p, uint i, void* pBuf)
		{
			if ((p) == (null))
				return;
			i--;
			while ((p->iDivisor) != 0)
			{
				uint bin = (uint)(i / p->iDivisor);
				i = (uint)(i % p->iDivisor);
				p = p->u.apSub[bin];
				if (p == null)
				{
					return;
				}
			}

			if ((p->iSize) <= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
			{
				p->u.aBitmap[i / 8] &= (byte)(~(1 << (i & (8 - 1))));
			}
			else
			{
				uint j = 0;
				uint* aiValues = pBuf;
				CRuntime.memcpy(aiValues, p->u.aHash, (ulong)(124 * sizeof(uint)));
				CRuntime.memset(p->u.aHash, (int)(0), (ulong)(124 * sizeof(uint)));
				p->nSet = (uint)(0);
				for (j = (uint)(0); (j) < ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)); j++)
				{
					if (((aiValues[j]) != 0) && (aiValues[j] != (i + 1)))
					{
						uint h = (uint)(((aiValues[j] - 1) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
						p->nSet++;
						while ((p->u.aHash[h]) != 0)
						{
							h++;
							if ((h) >= ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)))
								h = (uint)(0);
						}

						p->u.aHash[h] = (uint)(aiValues[j]);
					}
				}
			}
		}
		public static void sqlite3BitvecDestroy(Bitvec* p)
		{
			if ((p) == (null))
				return;
			if ((p->iDivisor) != 0)
			{
				uint i = 0;
				for (i = (uint)(0); (i) < ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec)); i++)
				{
					sqlite3BitvecDestroy(p->u.apSub[i]);
				}
			}

			sqlite3_free(p);
		}
		public static int sqlite3BitvecSet(Bitvec* p, uint i)
		{
			uint h = 0;
			if ((p) == (null))
				return (int)(0);
			i--;
			while (((p->iSize) > (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8)) && ((p->iDivisor) != 0))
			{
				uint bin = (uint)(i / p->iDivisor);
				i = (uint)(i % p->iDivisor);
				if ((p->u.apSub[bin]) == (null))
				{
					p->u.apSub[bin] = sqlite3BitvecCreate((uint)(p->iDivisor));
					if ((p->u.apSub[bin]) == (null))
						return (int)(7);
				}

				p = p->u.apSub[bin];
			}

			if ((p->iSize) <= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
			{
				p->u.aBitmap[i / 8] |= (byte)(1 << (i & (8 - 1)));
				return (int)(0);
			}

			h = (uint)(((i++) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
			if (p->u.aHash[h] == 0)
			{
				if ((p->nSet) < (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)) - 1))
				{
					goto bitvec_set_end;
				}
				else
				{
					goto bitvec_set_rehash;
				}
			}

			do
			{
				if ((p->u.aHash[h]) == (i))
					return (int)(0);
				h++;
				if ((h) >= ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)))
					h = (uint)(0);
			}
			while ((p->u.aHash[h]) != 0);
		bitvec_set_rehash:
			; if ((p->nSet) >= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)) / 2)) { uint j = 0; int rc = 0; uint* aiValues = sqlite3DbMallocRaw(null, (ulong)(124 * sizeof(uint))); if ((aiValues) == (null)) { return (int)(7); } else { CRuntime.memcpy(aiValues, p->u.aHash, (ulong)(124 * sizeof(uint))); CRuntime.memset(p->u.apSub, (int)(0), (ulong)(62 * sizeof(Bitvec))); p->iDivisor = (uint)((p->iSize + ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec)) - 1) / ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec))); rc = (int)(sqlite3BitvecSet(p, (uint)(i))); for (j = (uint)(0); (j) < ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)); j++) { if ((aiValues[j]) != 0) rc |= (int)(sqlite3BitvecSet(p, (uint)(aiValues[j]))); } sqlite3DbFree(null, aiValues); return (int)(rc); } }
		bitvec_set_end:
			; p->nSet++;
			p->u.aHash[h] = (uint)(i);
			return (int)(0);
		}
		public static uint sqlite3BitvecSize(Bitvec* p)
		{
			return (uint)(p->iSize);
		}
		public static int sqlite3BitvecTest(Bitvec* p, uint i)
		{
			return ((p != null) && ((sqlite3BitvecTestNotNull(p, (uint)(i))) != 0) ? 1 : 0);
		}
		public static int sqlite3BitvecTestNotNull(Bitvec* p, uint i)
		{
			i--;
			if ((i) >= (p->iSize))
				return (int)(0);
			while ((p->iDivisor) != 0)
			{
				uint bin = (uint)(i / p->iDivisor);
				i = (uint)(i % p->iDivisor);
				p = p->u.apSub[bin];
				if (p == null)
				{
					return (int)(0);
				}
			}

			if ((p->iSize) <= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
			{
				return (int)((p->u.aBitmap[i / 8] & (1 << (i & (8 - 1)))) != 0);
			}
			else
			{
				uint h = (uint)(((i++) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
				while ((p->u.aHash[h]) != 0)
				{
					if ((p->u.aHash[h]) == (i))
						return (int)(1);
					h = (uint)((h + 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
				}

				return (int)(0);
			}
		}
	}
}