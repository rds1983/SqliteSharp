// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void pcache1Cachesize(sqlite3_pcache* p, int nMax)
		{
			PCache1* pCache = (PCache1*)(p);
			uint n = 0;
			if ((pCache->bPurgeable) != 0)
			{
				PGroup* pGroup = pCache->pGroup;
				n = ((uint)(nMax));
				if ((n) > (0x7fff0000 - pGroup->nMaxPage + pCache->nMax))
				{
					n = (uint)(0x7fff0000 - pGroup->nMaxPage + pCache->nMax);
				}

				pGroup->nMaxPage += (uint)(n - pCache->nMax);
				pGroup->mxPinned = (uint)(pGroup->nMaxPage + 10 - pGroup->nMinPage);
				pCache->nMax = (uint)(n);
				pCache->n90pct = (uint)(pCache->nMax * 9 / 10);
				pcache1EnforceMaxPage(pCache);
			}
		}
		public static void pcache1Destroy(sqlite3_pcache* p)
		{
			PCache1* pCache = (PCache1*)(p);
			PGroup* pGroup = pCache->pGroup;
			if ((pCache->nPage) != 0)
				pcache1TruncateUnsafe(pCache, (uint)(0));
			pGroup->nMaxPage -= (uint)(pCache->nMax);
			pGroup->nMinPage -= (uint)(pCache->nMin);
			pGroup->mxPinned = (uint)(pGroup->nMaxPage + 10 - pGroup->nMinPage);
			pcache1EnforceMaxPage(pCache);
			sqlite3_free(pCache->pBulk);
			sqlite3_free(pCache->apHash);
			sqlite3_free(pCache);
		}
		public static int pcache1Pagecount(sqlite3_pcache* p)
		{
			int n = 0;
			PCache1* pCache = (PCache1*)(p);
			n = (int)(pCache->nPage);
			return (int)(n);
		}
		public static void pcache1Rekey(sqlite3_pcache* p, sqlite3_pcache_page* pPg, uint iOld, uint iNew)
		{
			PCache1* pCache = (PCache1*)(p);
			PgHdr1* pPage = (PgHdr1*)(pPg);
			PgHdr1** pp;
			uint h = 0;
			h = (uint)(iOld % pCache->nHash);
			pp = &pCache->apHash[h];
			while ((*pp) != pPage)
			{
				pp = &(*pp)->pNext;
			}

			*pp = pPage->pNext;
			h = (uint)(iNew % pCache->nHash);
			pPage->iKey = (uint)(iNew);
			pPage->pNext = pCache->apHash[h];
			pCache->apHash[h] = pPage;
			if ((iNew) > (pCache->iMaxKey))
			{
				pCache->iMaxKey = (uint)(iNew);
			}
		}
		public static void pcache1Shrink(sqlite3_pcache* p)
		{
			PCache1* pCache = (PCache1*)(p);
			if ((pCache->bPurgeable) != 0)
			{
				PGroup* pGroup = pCache->pGroup;
				uint savedMaxPage = 0;
				savedMaxPage = (uint)(pGroup->nMaxPage);
				pGroup->nMaxPage = (uint)(0);
				pcache1EnforceMaxPage(pCache);
				pGroup->nMaxPage = (uint)(savedMaxPage);
			}
		}
		public static void pcache1Truncate(sqlite3_pcache* p, uint iLimit)
		{
			PCache1* pCache = (PCache1*)(p);
			if ((iLimit) <= (pCache->iMaxKey))
			{
				pcache1TruncateUnsafe(pCache, (uint)(iLimit));
				pCache->iMaxKey = (uint)(iLimit - 1);
			}
		}
		public static void pcache1Unpin(sqlite3_pcache* p, sqlite3_pcache_page* pPg, int reuseUnlikely)
		{
			PCache1* pCache = (PCache1*)(p);
			PgHdr1* pPage = (PgHdr1*)(pPg);
			PGroup* pGroup = pCache->pGroup;
			if (((reuseUnlikely) != 0) || ((pGroup->nPurgeable) > (pGroup->nMaxPage)))
			{
				pcache1RemoveFromHash(pPage, (int)(1));
			}
			else
			{
				PgHdr1** ppFirst = &pGroup->lru.pLruNext;
				pPage->pLruPrev = &pGroup->lru;
				(pPage->pLruNext = *ppFirst)->pLruPrev = pPage;
				*ppFirst = pPage;
				pCache->nRecyclable++;
			}
		}
	}
}