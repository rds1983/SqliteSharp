// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void addArgumentToVtab(Parse pParse)
		{
			if (((pParse.sArg.z) != null) && ((pParse.pNewTable) != null))
			{
				sbyte* z = pParse.sArg.z;
				int n = (int)(pParse.sArg.n);
				sqlite3 db = pParse.db;
				addModuleArgument(pParse, pParse.pNewTable, sqlite3DbStrNDup(db, z, (ulong)(n)));
			}
		}
		public static void addModuleArgument(Parse pParse, Table pTable, sbyte* zArg)
		{
			long nBytes = 0;
			sbyte** azModuleArg;
			sqlite3 db = pParse.db;
			nBytes = (long)(sizeof(char*) * (2 + pTable.u.vtab.nArg));
			if ((pTable.u.vtab.nArg + 3) >= (db.aLimit[2]))
			{
				sqlite3ErrorMsg(pParse, "too many columns on %s", pTable.zName);
			}

			azModuleArg = sqlite3DbRealloc(db, pTable.u.vtab.azArg, (ulong)(nBytes));
			if ((azModuleArg) == (null))
			{
				sqlite3DbFree(db, zArg);
			}
			else
			{
				int i = (int)(pTable.u.vtab.nArg++);
				azModuleArg[i] = zArg;
				azModuleArg[i + 1] = null;
				pTable.u.vtab.azArg = azModuleArg;
			}
		}
		public static void addWhereTerm(Parse pParse, SrcList pSrc, int iLeft, int iColLeft, int iRight, int iColRight, int isOuterJoin, Expr ppWhere)
		{
			sqlite3 db = pParse.db;
			Expr pE1;
			Expr pE2;
			Expr pEq;
			pE1 = sqlite3CreateColumnExpr(db, pSrc, (int)(iLeft), (int)(iColLeft));
			pE2 = sqlite3CreateColumnExpr(db, pSrc, (int)(iRight), (int)(iColRight));
			pEq = sqlite3PExpr(pParse, (int)(53), pE1, pE2);
			if (((pEq) != null) && ((isOuterJoin) != 0))
			{
				(pEq).flags |= (uint)(0x000001);
				pEq.w.iRightJoinTable = (int)(pE2.iTable);
			}

			ppWhere = sqlite3ExprAnd(pParse, ppWhere, pEq);
		}
		public static void analyzeDatabase(Parse pParse, int iDb)
		{
			sqlite3 db = pParse.db;
			Schema pSchema = db.aDb[iDb].pSchema;
			HashElem* k;
			int iStatCur = 0;
			int iMem = 0;
			int iTab = 0;
			sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
			iStatCur = (int)(pParse.nTab);
			pParse.nTab += (int)(3);
			openStatTable(pParse, (int)(iDb), (int)(iStatCur), null, null);
			iMem = (int)(pParse.nMem + 1);
			iTab = (int)(pParse.nTab);
			for (k = ((&pSchema.tblHash)->first); k; k = ((k)->next))
			{
				Table pTab = (Table)((k)->data);
				analyzeOneTable(pParse, pTab, null, (int)(iStatCur), (int)(iMem), (int)(iTab));
			}

			loadAnalysis(pParse, (int)(iDb));
		}
		public static void analyzeOneTable(Parse pParse, Table pTab, Index pOnlyIdx, int iStatCur, int iMem, int iTab)
		{
			sqlite3 db = pParse.db;
			Index pIdx;
			int iIdxCur = 0;
			int iTabCur = 0;
			Vdbe v;
			int i = 0;
			int jZeroRows = (int)(-1);
			int iDb = 0;
			byte needTableCnt = (byte)(1);
			int regNewRowid = (int)(iMem++);
			int regStat = (int)(iMem++);
			int regChng = (int)(iMem++);
			int regRowid = (int)(iMem++);
			int regTemp = (int)(iMem++);
			int regTemp2 = (int)(iMem++);
			int regTabname = (int)(iMem++);
			int regIdxname = (int)(iMem++);
			int regStat1 = (int)(iMem++);
			int regPrev = (int)(iMem);
			pParse.nMem = (int)((pParse.nMem) > (iMem) ? (pParse.nMem) : (iMem));
			v = sqlite3GetVdbe(pParse);
			if (((v) == (null)) || ((pTab) == (null)))
			{
				return;
			}

			if (!(((pTab).eTabType) == (0)))
			{
				return;
			}

			if ((sqlite3_strlike("sqlite\\_%", pTab.zName, (uint)(92))) == (0))
			{
				return;
			}

			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			if ((sqlite3AuthCheck(pParse, (int)(28), pTab.zName, null, db.aDb[iDb].zDbSName)) != 0)
			{
				return;
			}

			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
			iTabCur = (int)(iTab++);
			iIdxCur = (int)(iTab++);
			pParse.nTab = (int)((pParse.nTab) > (iTab) ? (pParse.nTab) : (iTab));
			sqlite3OpenTable(pParse, (int)(iTabCur), (int)(iDb), pTab, (int)(101));
			sqlite3VdbeLoadString(v, (int)(regTabname), pTab.zName);
			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				int nCol = 0;
				int addrRewind = 0;
				int addrNextRow = 0;
				sbyte* zIdxName;
				int nColTest = 0;
				if (((pOnlyIdx) != null) && (pOnlyIdx != pIdx))
					continue;
				if ((pIdx.pPartIdxWhere) == (null))
					needTableCnt = (byte)(0);
				if ((!(((pTab).tabFlags & 0x00000080) == (0))) && (((pIdx).idxType) == (2)))
				{
					nCol = (int)(pIdx.nKeyCol);
					zIdxName = pTab.zName;
					nColTest = (int)(nCol - 1);
				}
				else
				{
					nCol = (int)(pIdx.nColumn);
					zIdxName = pIdx.zName;
					nColTest = (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol - 1 : nCol - 1);
				}

				sqlite3VdbeLoadString(v, (int)(regIdxname), zIdxName);
				pParse.nMem = (int)((pParse.nMem) > (regPrev + nColTest) ? (pParse.nMem) : (regPrev + nColTest));
				sqlite3VdbeAddOp3(v, (int)(101), (int)(iIdxCur), (int)(pIdx.tnum), (int)(iDb));
				sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(nCol), (int)(regStat + 1));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(pIdx.nKeyCol), (int)(regRowid));
				{
					addrRewind = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iIdxCur)));
					sqlite3VdbeAddOp3(v, (int)(97), (int)(iIdxCur), (int)(regTemp), (int)(1));
				}

				sqlite3VdbeAddOp2(v, (int)(71), (int)(db.nAnalysisLimit), (int)(regTemp2));
				sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regStat + 1), (int)(regStat), (int)(4), statInitFuncdef, (int)(0));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regChng));
				addrNextRow = (int)(sqlite3VdbeCurrentAddr(v));
				if ((nColTest) > (0))
				{
					int endDistinctTest = (int)(sqlite3VdbeMakeLabel(pParse));
					int* aGotoChng;
					aGotoChng = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * nColTest));
					if ((aGotoChng) == (null))
						continue;
					sqlite3VdbeAddOp0(v, (int)(11));
					addrNextRow = (int)(sqlite3VdbeCurrentAddr(v));
					if ((((nColTest) == (1)) && ((pIdx.nKeyCol) == (1))) && ((pIdx).onError != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(51), (int)(regPrev), (int)(endDistinctTest));
					}

					for (i = (int)(0); (i) < (nColTest); i++)
					{
						sbyte* pColl = (sbyte*)(sqlite3LocateCollSeq(pParse, pIdx.azColl[i]));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(i), (int)(regChng));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(i), (int)(regTemp));
						aGotoChng[i] = (int)(sqlite3VdbeAddOp4(v, (int)(52), (int)(regTemp), (int)(0), (int)(regPrev + i), pColl, (int)(-2)));
						sqlite3VdbeChangeP5(v, (ushort)(0x80));
					}

					sqlite3VdbeAddOp2(v, (int)(71), (int)(nColTest), (int)(regChng));
					sqlite3VdbeGoto(v, (int)(endDistinctTest));
					sqlite3VdbeJumpHere(v, (int)(addrNextRow - 1));
					for (i = (int)(0); (i) < (nColTest); i++)
					{
						sqlite3VdbeJumpHere(v, (int)(aGotoChng[i]));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(i), (int)(regPrev + i));
					}

					sqlite3VdbeResolveLabel(v, (int)(endDistinctTest));
					sqlite3DbFree(db, aGotoChng);
				}

				{
					sqlite3VdbeAddFunctionCall(pParse, (int)(1), (int)(regStat), (int)(regTemp), (int)(2 + 0), statPushFuncdef, (int)(0));
					if ((db.nAnalysisLimit) != 0)
					{
						int j1 = 0;
						int j2 = 0;
						int j3 = 0;
						j1 = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(regTemp)));
						j2 = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(regTemp)));
						j3 = (int)(sqlite3VdbeAddOp4Int(v, (int)(26), (int)(iIdxCur), (int)(0), (int)(regPrev), (int)(1)));
						sqlite3VdbeJumpHere(v, (int)(j1));
						sqlite3VdbeAddOp2(v, (int)(5), (int)(iIdxCur), (int)(addrNextRow));
						sqlite3VdbeJumpHere(v, (int)(j2));
						sqlite3VdbeJumpHere(v, (int)(j3));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(5), (int)(iIdxCur), (int)(addrNextRow));
					}
				}

				callStatGet(pParse, (int)(regStat), (int)(0), (int)(regStat1));
				sqlite3VdbeAddOp4(v, (int)(96), (int)(regTabname), (int)(3), (int)(regTemp), "BBB", (int)(0));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(iStatCur), (int)(regNewRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(iStatCur), (int)(regTemp), (int)(regNewRowid));
				sqlite3VdbeChangeP5(v, (ushort)(0x08));
				sqlite3VdbeJumpHere(v, (int)(addrRewind));
			}

			if (((pOnlyIdx) == (null)) && ((needTableCnt) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(97), (int)(iTabCur), (int)(regStat1));
				jZeroRows = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regStat1)));
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regIdxname));
				sqlite3VdbeAddOp4(v, (int)(96), (int)(regTabname), (int)(3), (int)(regTemp), "BBB", (int)(0));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(iStatCur), (int)(regNewRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(iStatCur), (int)(regTemp), (int)(regNewRowid));
				sqlite3VdbeChangeP5(v, (ushort)(0x08));
				sqlite3VdbeJumpHere(v, (int)(jZeroRows));
			}
		}
		public static void analyzeTable(Parse pParse, Table pTab, Index pOnlyIdx)
		{
			int iDb = 0;
			int iStatCur = 0;
			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
			sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
			iStatCur = (int)(pParse.nTab);
			pParse.nTab += (int)(3);
			if ((pOnlyIdx) != null)
			{
				openStatTable(pParse, (int)(iDb), (int)(iStatCur), pOnlyIdx.zName, "idx");
			}
			else
			{
				openStatTable(pParse, (int)(iDb), (int)(iStatCur), pTab.zName, "tbl");
			}

			analyzeOneTable(pParse, pTab, pOnlyIdx, (int)(iStatCur), (int)(pParse.nMem + 1), (int)(pParse.nTab));
			loadAnalysis(pParse, (int)(iDb));
		}
		public static Select attachWithToSelect(Parse pParse, Select pSelect, With pWith)
		{
			if ((pSelect) != null)
			{
				pSelect.pWith = pWith;
				parserDoubleLinkSelect(pParse, pSelect);
			}
			else
			{
				sqlite3WithDelete(pParse.db, pWith);
			}

			return pSelect;
		}
		public static int autoIncBegin(Parse pParse, int iDb, Table pTab)
		{
			int memId = (int)(0);
			if (((pTab.tabFlags & 0x00000008) != 0) && ((pParse.db.mDbFlags & 0x0004) == (0)))
			{
				Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
				AutoincInfo pInfo;
				Table pSeqTab = pParse.db.aDb[iDb].pSchema.pSeqTab;
				if (((((pSeqTab) == (null)) || (!(((pSeqTab).tabFlags & 0x00000080) == (0)))) || ((((pSeqTab).eTabType) == (1)) != 0)) || (pSeqTab.nCol != 2))
				{
					pParse.nErr++;
					pParse.rc = (int)(11 | (2 << 8));
					return (int)(0);
				}

				pInfo = pToplevel.pAinc;
				while (((pInfo) != null) && (pInfo.pTab != pTab))
				{
					pInfo = pInfo.pNext;
				}

				if ((pInfo) == (null))
				{
					pInfo = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(AutoincInfo)));
					sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);
					if ((pParse.db.mallocFailed) != 0)
						return (int)(0);
					pInfo.pNext = pToplevel.pAinc;
					pToplevel.pAinc = pInfo;
					pInfo.pTab = pTab;
					pInfo.iDb = (int)(iDb);
					pToplevel.nMem++;
					pInfo.regCtr = (int)(++pToplevel.nMem);
					pToplevel.nMem += (int)(2);
				}

				memId = (int)(pInfo.regCtr);
			}

			return (int)(memId);
		}
		public static void autoIncrementEnd(Parse pParse)
		{
			AutoincInfo p;
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			for (p = pParse.pAinc; p; p = p.pNext)
			{
				VdbeOp* aOp;
				Db pDb = db.aDb[p.iDb];
				int iRec = 0;
				int memId = (int)(p.regCtr);
				iRec = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp3(v, (int)(55), (int)(memId + 2), (int)(sqlite3VdbeCurrentAddr(v) + 7), (int)(memId));
				sqlite3OpenTable(pParse, (int)(0), (int)(p.iDb), pDb.pSchema.pSeqTab, (int)(112));
				aOp = sqlite3VdbeAddOpList(v, ((int)(5 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), autoIncrementEnd_autoIncEnd, (int)(autoIncrementEnd_iLn));
				if ((aOp) == (null))
					break;
				aOp[0].p1 = (int)(memId + 1);
				aOp[1].p2 = (int)(memId + 1);
				aOp[2].p1 = (int)(memId - 1);
				aOp[2].p3 = (int)(iRec);
				aOp[3].p2 = (int)(iRec);
				aOp[3].p3 = (int)(memId + 1);
				aOp[3].p5 = (ushort)(0x08);
				sqlite3ReleaseTempReg(pParse, (int)(iRec));
			}
		}
		public static void autoIncStep(Parse pParse, int memId, int regRowid)
		{
			if ((memId) > (0))
			{
				sqlite3VdbeAddOp2(pParse.pVdbe, (int)(158), (int)(memId), (int)(regRowid));
			}
		}
		public static void binaryToUnaryIfNull(Parse pParse, Expr pY, Expr pA, int op)
		{
			sqlite3 db = pParse.db;
			if (((((pA) != null) && ((pY) != null)) && ((pY.op) == (121))) && (!((pParse.eParseMode) >= (2))))
			{
				pA.op = ((byte)(op));
				sqlite3ExprDelete(db, pA.pRight);
				pA.pRight = null;
			}
		}
		public static void callStatGet(Parse pParse, int regStat, int iParam, int regOut)
		{
			sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regStat), (int)(regOut), (int)(1 + 0), statGetFuncdef, (int)(0));
		}
		public static int cannotBeFunction(Parse pParse, SrcItem pFrom)
		{
			if ((pFrom.fg.isTabFunc) != 0)
			{
				sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom.zName);
				return (int)(1);
			}

			return (int)(0);
		}
		public static int changeTempStorage(Parse pParse, sbyte* zStorageType)
		{
			int ts = (int)(getTempStore(zStorageType));
			sqlite3 db = pParse.db;
			if ((db.temp_store) == (ts))
				return (int)(0);
			if (invalidateTempStorage(pParse) != 0)
			{
				return (int)(1);
			}

			db.temp_store = ((byte)(ts));
			return (int)(0);
		}
		public static int codeAllEqualityTerms(Parse pParse, WhereLevel pLevel, int bRev, int nExtraReg, sbyte** pzAff)
		{
			ushort nEq = 0;
			ushort nSkip = 0;
			Vdbe v = pParse.pVdbe;
			Index pIdx;
			WhereTerm pTerm;
			WhereLoop pLoop;
			int j = 0;
			int regBase = 0;
			int nReg = 0;
			sbyte* zAff;
			pLoop = pLevel.pWLoop;
			nEq = (ushort)(pLoop.u.btree.nEq);
			nSkip = (ushort)(pLoop.nSkip);
			pIdx = pLoop.u.btree.pIndex;
			regBase = (int)(pParse.nMem + 1);
			nReg = (int)(pLoop.u.btree.nEq + nExtraReg);
			pParse.nMem += (int)(nReg);
			zAff = sqlite3DbStrDup(pParse.db, sqlite3IndexAffinityStr(pParse.db, pIdx));
			if ((nSkip) != 0)
			{
				int iIdxCur = (int)(pLevel.iIdxCur);
				sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(regBase), (int)(regBase + nSkip - 1));
				sqlite3VdbeAddOp1(v, (int)((bRev) != 0 ? 34 : 38), (int)(iIdxCur));
				j = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
				pLevel.addrSkip = (int)(sqlite3VdbeAddOp4Int(v, (int)((bRev) != 0 ? 23 : 26), (int)(iIdxCur), (int)(0), (int)(regBase), (int)(nSkip)));
				sqlite3VdbeJumpHere(v, (int)(j));
				for (j = (int)(0); (j) < (nSkip); j++)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(j), (int)(regBase + j));
				}
			}

			for (j = (int)(nSkip); (j) < (nEq); j++)
			{
				int r1 = 0;
				pTerm = pLoop.aLTerm[j];
				r1 = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(j), (int)(bRev), (int)(regBase + j)));
				if (r1 != regBase + j)
				{
					if ((nReg) == (1))
					{
						sqlite3ReleaseTempReg(pParse, (int)(regBase));
						regBase = (int)(r1);
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(79), (int)(r1), (int)(regBase + j));
					}
				}
			}

			for (j = (int)(nSkip); (j) < (nEq); j++)
			{
				pTerm = pLoop.aLTerm[j];
				if ((pTerm.eOperator & 0x0001) != 0)
				{
					if ((pTerm.pExpr.flags & 0x000800) != 0)
					{
						if ((zAff) != null)
							zAff[j] = (sbyte)(0x41);
					}
				}
				else if ((pTerm.eOperator & 0x0100) == (0))
				{
					Expr pRight = pTerm.pExpr.pRight;
					if (((pTerm.wtFlags & 0x0800) == (0)) && ((sqlite3ExprCanBeNull(pRight)) != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + j), (int)(pLevel.addrBrk));
					}

					if ((pParse.nErr) == (0))
					{
						if ((sqlite3CompareAffinity(pRight, (sbyte)(zAff[j]))) == (0x41))
						{
							zAff[j] = (sbyte)(0x41);
						}

						if ((sqlite3ExprNeedsNoAffinityChange(pRight, (sbyte)(zAff[j]))) != 0)
						{
							zAff[j] = (sbyte)(0x41);
						}
					}
				}
			}

			*pzAff = zAff;
			return (int)(regBase);
		}
		public static void codeApplyAffinity(Parse pParse, int _base_, int n, sbyte* zAff)
		{
			Vdbe v = pParse.pVdbe;
			if ((zAff) == (null))
			{
				return;
			}

			while (((n) > (0)) && ((zAff[0]) <= (0x41)))
			{
				n--;
				_base_++;
				zAff++;
			}

			while (((n) > (1)) && ((zAff[n - 1]) <= (0x41)))
			{
				n--;
			}

			if ((n) > (0))
			{
				sqlite3VdbeAddOp4(v, (int)(95), (int)(_base_), (int)(n), (int)(0), zAff, (int)(n));
			}
		}
		public static void codeAttach(Parse pParse, int type, FuncDef pFunc, Expr pAuthArg, Expr pFilename, Expr pDbname, Expr pKey)
		{
			int rc = 0;
			NameContext sName = new NameContext();
			Vdbe v;
			sqlite3 db = pParse.db;
			int regArgs = 0;
			if ((pParse.nErr) != 0)
				goto attach_end;
			CRuntime.memset(sName, (int)(0), (ulong)(sizeof(NameContext)));
			sName.pParse = pParse;
			if (((0 != resolveAttachExpr(sName, pFilename)) || (0 != resolveAttachExpr(sName, pDbname))) || (0 != resolveAttachExpr(sName, pKey)))
			{
				goto attach_end;
			}

			if ((pAuthArg) != null)
			{
				sbyte* zAuthArg;
				if ((pAuthArg.op) == (117))
				{
					zAuthArg = pAuthArg.u.zToken;
				}
				else
				{
					zAuthArg = null;
				}

				rc = (int)(sqlite3AuthCheck(pParse, (int)(type), zAuthArg, null, null));
				if (rc != 0)
				{
					goto attach_end;
				}
			}

			v = sqlite3GetVdbe(pParse);
			regArgs = (int)(sqlite3GetTempRange(pParse, (int)(4)));
			sqlite3ExprCode(pParse, pFilename, (int)(regArgs));
			sqlite3ExprCode(pParse, pDbname, (int)(regArgs + 1));
			sqlite3ExprCode(pParse, pKey, (int)(regArgs + 2));
			if ((v) != null)
			{
				sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regArgs + 3 - pFunc.nArg), (int)(regArgs + 3), (int)(pFunc.nArg), pFunc, (int)(0));
				sqlite3VdbeAddOp1(v, (int)(165), (((type) == (24)) ? 1 : 0));
			}

		attach_end:
			; sqlite3ExprDelete(db, pFilename);
			sqlite3ExprDelete(db, pDbname);
			sqlite3ExprDelete(db, pKey);
		}
		public static int codeCompare(Parse pParse, Expr pLeft, Expr pRight, int opcode, int in1, int in2, int dest, int jumpIfNull, int isCommuted)
		{
			int p5 = 0;
			int addr = 0;
			CollSeq p4;
			if ((pParse.nErr) != 0)
				return (int)(0);
			if ((isCommuted) != 0)
			{
				p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
			}
			else
			{
				p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
			}

			p5 = (int)(binaryCompareP5(pLeft, pRight, (int)(jumpIfNull)));
			addr = (int)(sqlite3VdbeAddOp4(pParse.pVdbe, (int)(opcode), (int)(in2), (int)(dest), (int)(in1), (void*)(p4), (int)(-2)));
			sqlite3VdbeChangeP5(pParse.pVdbe, (ushort)((byte)(p5)));
			return (int)(addr);
		}
		public static int codeDistinct(Parse pParse, int eTnctType, int iTab, int addrRepeat, ExprList pEList, int regElem)
		{
			int iRet = (int)(0);
			int nResultCol = (int)(pEList.nExpr);
			Vdbe v = pParse.pVdbe;
			switch (eTnctType)
			{
				case 2:
					{
						int i = 0;
						int iJump = 0;
						int regPrev = 0;
						iRet = (int)(regPrev = (int)(pParse.nMem + 1));
						pParse.nMem += (int)(nResultCol);
						iJump = (int)(sqlite3VdbeCurrentAddr(v) + nResultCol);
						for (i = (int)(0); (i) < (nResultCol); i++)
						{
							CollSeq pColl = sqlite3ExprCollSeq(pParse, pEList.a[i].pExpr);
							if ((i) < (nResultCol - 1))
							{
								sqlite3VdbeAddOp3(v, (int)(52), (int)(regElem + i), (int)(iJump), (int)(regPrev + i));
							}
							else
							{
								sqlite3VdbeAddOp3(v, (int)(53), (int)(regElem + i), (int)(addrRepeat), (int)(regPrev + i));
							}

							sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pColl), (int)(-2));
							sqlite3VdbeChangeP5(v, (ushort)(0x80));
						}

						sqlite3VdbeAddOp3(v, (int)(79), (int)(regElem), (int)(regPrev), (int)(nResultCol - 1));
						break;
					}

				case 1:
					{
						break;
					}

				default:
					{
						int r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iTab), (int)(addrRepeat), (int)(regElem), (int)(nResultCol));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regElem), (int)(nResultCol), (int)(r1));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iTab), (int)(r1), (int)(regElem), (int)(nResultCol));
						sqlite3VdbeChangeP5(v, (ushort)(0x10));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						iRet = (int)(iTab);
						break;
					}
			}

			return (int)(iRet);
		}
		public static int codeEqualityTerm(Parse pParse, WhereTerm pTerm, WhereLevel pLevel, int iEq, int bRev, int iTarget)
		{
			Expr pX = pTerm.pExpr;
			Vdbe v = pParse.pVdbe;
			int iReg = 0;
			if (((pX.op) == (53)) || ((pX.op) == (45)))
			{
				iReg = (int)(sqlite3ExprCodeTarget(pParse, pX.pRight, (int)(iTarget)));
			}
			else if ((pX.op) == (50))
			{
				iReg = (int)(iTarget);
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(iReg));
			}
			else
			{
				int eType = (int)(5);
				int iTab = 0;
				InLoop* pIn;
				WhereLoop pLoop = pLevel.pWLoop;
				int i = 0;
				int nEq = (int)(0);
				int* aiMap = null;
				if ((((pLoop.wsFlags & 0x00000400) == (0)) && (pLoop.u.btree.pIndex != null)) && ((pLoop.u.btree.pIndex.aSortOrder[iEq]) != 0))
				{
					bRev = (int)(!bRev);
				}

				iReg = (int)(iTarget);
				for (i = (int)(0); (i) < (iEq); i++)
				{
					if (((pLoop.aLTerm[i]) != null) && ((pLoop.aLTerm[i].pExpr) == (pX)))
					{
						disableTerm(pLevel, pTerm);
						return (int)(iTarget);
					}
				}

				for (i = (int)(iEq); (i) < (pLoop.nLTerm); i++)
				{
					if ((pLoop.aLTerm[i].pExpr) == (pX))
						nEq++;
				}

				iTab = (int)(0);
				if ((!(((pX).flags & 0x000800) != 0)) || ((pX.x.pSelect.pEList.nExpr) == (1)))
				{
					eType = (int)(sqlite3FindInIndex(pParse, pX, (uint)(0x0004), null, null, &iTab));
				}
				else
				{
					sqlite3 db = pParse.db;
					pX = removeUnindexableInClauseTerms(pParse, (int)(iEq), pLoop, pX);
					if (db.mallocFailed == 0)
					{
						aiMap = (int*)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(int) * nEq)));
						eType = (int)(sqlite3FindInIndex(pParse, pX, (uint)(0x0004), null, aiMap, &iTab));
						pTerm.pExpr.iTable = (int)(iTab);
					}

					sqlite3ExprDelete(db, pX);
					pX = pTerm.pExpr;
				}

				if ((eType) == (4))
				{
					bRev = (int)(!bRev);
				}

				sqlite3VdbeAddOp2(v, (int)((bRev) != 0 ? 34 : 38), (int)(iTab), (int)(0));
				pLoop.wsFlags |= (uint)(0x00000800);
				if ((pLevel.u._in_.nIn) == (0))
				{
					pLevel.addrNxt = (int)(sqlite3VdbeMakeLabel(pParse));
				}

				if (((iEq) > (0)) && ((pLoop.wsFlags & 0x00100000) == (0)))
				{
					pLoop.wsFlags |= (uint)(0x00040000);
				}

				i = (int)(pLevel.u._in_.nIn);
				pLevel.u._in_.nIn += (int)(nEq);
				pLevel.u._in_.aInLoop = sqlite3DbReallocOrFree(pParse.db, pLevel.u._in_.aInLoop, (ulong)(sizeof(InLoop) * pLevel.u._in_.nIn));
				pIn = pLevel.u._in_.aInLoop;
				if ((pIn) != null)
				{
					int iMap = (int)(0);
					pIn += i;
					for (i = (int)(iEq); (i) < (pLoop.nLTerm); i++)
					{
						if ((pLoop.aLTerm[i].pExpr) == (pX))
						{
							int iOut = (int)(iReg + i - iEq);
							if ((eType) == (1))
							{
								pIn->addrInTop = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iTab), (int)(iOut)));
							}
							else
							{
								int iCol = (int)((aiMap) != 0 ? aiMap[iMap++] : 0);
								pIn->addrInTop = (int)(sqlite3VdbeAddOp3(v, (int)(93), (int)(iTab), (int)(iCol), (int)(iOut)));
							}

							sqlite3VdbeAddOp1(v, (int)(50), (int)(iOut));
							if ((i) == (iEq))
							{
								pIn->iCur = (int)(iTab);
								pIn->eEndLoopOp = (byte)((bRev) != 0 ? 4 : 5);
								if ((iEq) > (0))
								{
									pIn->iBase = (int)(iReg - i);
									pIn->nPrefix = (int)(i);
								}
								else
								{
									pIn->nPrefix = (int)(0);
								}
							}
							else
							{
								pIn->eEndLoopOp = (byte)(182);
							}

							pIn++;
						}
					}

					if (((iEq) > (0)) && ((pLoop.wsFlags & (0x00100000 | 0x00000400)) == (0)))
					{
						sqlite3VdbeAddOp3(v, (int)(124), (int)(pLevel.iIdxCur), (int)(0), (int)(iEq));
					}
				}
				else
				{
					pLevel.u._in_.nIn = (int)(0);
				}

				sqlite3DbFree(pParse.db, aiMap);
			}

			if (((pLevel.pWLoop.wsFlags & 0x00200000) == (0)) || ((pTerm.eOperator & 0x0800) == (0)))
			{
				disableTerm(pLevel, pTerm);
			}

			return (int)(iReg);
		}
		public static void codeExprOrVector(Parse pParse, Expr p, int iReg, int nReg)
		{
			if (((p) != null) && ((sqlite3ExprIsVector(p)) != 0))
			{
				if ((((p).flags & 0x000800) != 0))
				{
					Vdbe v = pParse.pVdbe;
					int iSelect = 0;
					iSelect = (int)(sqlite3CodeSubselect(pParse, p));
					sqlite3VdbeAddOp3(v, (int)(79), (int)(iSelect), (int)(iReg), (int)(nReg - 1));
				}
				else
				{
					int i = 0;
					ExprList pList;
					pList = p.x.pList;
					for (i = (int)(0); (i) < (nReg); i++)
					{
						sqlite3ExprCode(pParse, pList.a[i].pExpr, (int)(iReg + i));
					}
				}
			}
			else
			{
				sqlite3ExprCode(pParse, p, (int)(iReg));
			}
		}
		public static void codeInteger(Parse pParse, Expr pExpr, int negFlag, int iMem)
		{
			Vdbe v = pParse.pVdbe;
			if ((pExpr.flags & 0x000400) != 0)
			{
				int i = (int)(pExpr.u.iValue);
				if ((negFlag) != 0)
					i = (int)(-i);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(i), (int)(iMem));
			}
			else
			{
				int c = 0;
				long value = 0;
				sbyte* z = pExpr.u.zToken;
				c = (int)(sqlite3DecOrHexToI64(z, &value));
				if (((((c) == (3)) && (negFlag == 0)) || ((c) == (2))) || (((negFlag) != 0) && ((value) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))))
				{
					if ((sqlite3_strnicmp(z, "0x", (int)(2))) == (0))
					{
						sqlite3ErrorMsg(pParse, "hex literal too big: %s%#T", (negFlag) != 0 ? "-" : "", pExpr);
					}
					else
					{
						codeReal(v, z, (int)(negFlag), (int)(iMem));
					}
				}
				else
				{
					if ((negFlag) != 0)
					{
						value = (long)((c) == (3) ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) : -value);
					}

					sqlite3VdbeAddOp4Dup8(v, (int)(72), (int)(0), (int)(iMem), (int)(0), (byte*)(&value), (int)(-14));
				}
			}
		}
		public static void codeReturningTrigger(Parse pParse, Trigger pTrigger, Table pTab, int regIn)
		{
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			ExprList pNew;
			Returning pReturning;
			Select sSelect = new Select();
			SrcList sFrom = new SrcList();
			pReturning = pParse.u1.pReturning;
			CRuntime.memset(sSelect, (int)(0), (ulong)(sizeof(Select)));
			CRuntime.memset(sFrom, (int)(0), (ulong)(sizeof(SrcList)));
			sSelect.pEList = sqlite3ExprListDup(db, pReturning.pReturnEL, (int)(0));
			sSelect.pSrc = sFrom;
			sFrom.nSrc = (int)(1);
			sFrom.a[0].pTab = pTab;
			sFrom.a[0].iCursor = (int)(-1);
			sqlite3SelectPrep(pParse, sSelect, null);
			if ((pParse.nErr) == (0))
			{
				sqlite3GenerateColumnNames(pParse, sSelect);
			}

			sqlite3ExprListDelete(db, sSelect.pEList);
			pNew = sqlite3ExpandReturning(pParse, pReturning.pReturnEL, pTab);
			if (db.mallocFailed == 0)
			{
				NameContext sNC = new NameContext();
				CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
				if ((pReturning.nRetCol) == (0))
				{
					pReturning.nRetCol = (int)(pNew.nExpr);
					pReturning.iRetCur = (int)(pParse.nTab++);
				}

				sNC.pParse = pParse;
				sNC.uNC.iBaseReg = (int)(regIn);
				sNC.ncFlags = (int)(0x000400);
				pParse.eTriggerOp = (byte)(pTrigger.op);
				pParse.pTriggerTab = pTab;
				if (((sqlite3ResolveExprListNames(sNC, pNew)) == (0)) && ((!db.mallocFailed) != 0))
				{
					int i = 0;
					int nCol = (int)(pNew.nExpr);
					int reg = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(nCol + 2);
					pReturning.iRetReg = (int)(reg);
					for (i = (int)(0); (i) < (nCol); i++)
					{
						Expr pCol = pNew.a[i].pExpr;
						sqlite3ExprCodeFactorable(pParse, pCol, (int)(reg + i));
						if ((sqlite3ExprAffinity(pCol)) == (0x45))
						{
							sqlite3VdbeAddOp1(v, (int)(86), (int)(reg + i));
						}
					}

					sqlite3VdbeAddOp3(v, (int)(96), (int)(reg), (int)(i), (int)(reg + i));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(pReturning.iRetCur), (int)(reg + i + 1));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(pReturning.iRetCur), (int)(reg + i), (int)(reg + i + 1));
				}
			}

			sqlite3ExprListDelete(db, pNew);
			pParse.eTriggerOp = (byte)(0);
			pParse.pTriggerTab = null;
		}
		public static TriggerPrg codeRowTrigger(Parse pParse, Trigger pTrigger, Table pTab, int orconf)
		{
			Parse pTop = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			sqlite3 db = pParse.db;
			TriggerPrg pPrg;
			Expr pWhen = null;
			Vdbe v;
			NameContext sNC = new NameContext();
			SubProgram* pProgram = null;
			int iEndTrigger = (int)(0);
			Parse sSubParse = new Parse();
			pPrg = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerPrg)));
			if (pPrg == null)
				return null;
			pPrg.pNext = pTop.pTriggerPrg;
			pTop.pTriggerPrg = pPrg;
			pPrg.pProgram = pProgram = sqlite3DbMallocZero(db, (ulong)(sizeof(SubProgram)));
			if (pProgram == null)
				return null;
			sqlite3VdbeLinkSubProgram(pTop.pVdbe, pProgram);
			pPrg.pTrigger = pTrigger;
			pPrg.orconf = (int)(orconf);
			pPrg.aColmask[0] = (uint)(0xffffffff);
			pPrg.aColmask[1] = (uint)(0xffffffff);
			sqlite3ParseObjectInit(sSubParse, db);
			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = sSubParse;
			sSubParse.pTriggerTab = pTab;
			sSubParse.pToplevel = pTop;
			sSubParse.zAuthContext = pTrigger.zName;
			sSubParse.eTriggerOp = (byte)(pTrigger.op);
			sSubParse.nQueryLoop = (uint)(pParse.nQueryLoop);
			sSubParse.disableVtab = (byte)(pParse.disableVtab);
			v = sqlite3GetVdbe(sSubParse);
			if ((v) != null)
			{
				if ((pTrigger.zName) != null)
				{
					sqlite3VdbeChangeP4(v, (int)(-1), sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger.zName), (int)(-7));
				}

				if ((pTrigger.pWhen) != null)
				{
					pWhen = sqlite3ExprDup(db, pTrigger.pWhen, (int)(0));
					if (((db.mallocFailed) == (0)) && ((0) == (sqlite3ResolveExprNames(sNC, pWhen))))
					{
						iEndTrigger = (int)(sqlite3VdbeMakeLabel(sSubParse));
						sqlite3ExprIfFalse(sSubParse, pWhen, (int)(iEndTrigger), (int)(0x10));
					}

					sqlite3ExprDelete(db, pWhen);
				}

				codeTriggerProgram(sSubParse, pTrigger.step_list, (int)(orconf));
				if ((iEndTrigger) != 0)
				{
					sqlite3VdbeResolveLabel(v, (int)(iEndTrigger));
				}

				sqlite3VdbeAddOp0(v, (int)(70));
				transferParseError(pParse, sSubParse);
				if ((pParse.nErr) == (0))
				{
					pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop.nMaxArg);
				}

				pProgram->nMem = (int)(sSubParse.nMem);
				pProgram->nCsr = (int)(sSubParse.nTab);
				pProgram->token = (void*)(pTrigger);
				pPrg.aColmask[0] = (uint)(sSubParse.oldmask);
				pPrg.aColmask[1] = (uint)(sSubParse.newmask);
				sqlite3VdbeDelete(v);
			}
			else
			{
				transferParseError(pParse, sSubParse);
			}

			sqlite3ParseObjectReset(sSubParse);
			return pPrg;
		}
		public static void codeTableLocks(Parse pParse)
		{
			int i = 0;
			Vdbe pVdbe = pParse.pVdbe;
			for (i = (int)(0); (i) < (pParse.nTableLock); i++)
			{
				TableLock* p = &pParse.aTableLock[i];
				int p1 = (int)(p->iDb);
				sqlite3VdbeAddOp4(pVdbe, (int)(168), (int)(p1), (int)(p->iTab), (int)(p->isWriteLock), p->zLockName, (int)(-1));
			}
		}
		public static int codeTriggerProgram(Parse pParse, TriggerStep pStepList, int orconf)
		{
			TriggerStep pStep;
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			for (pStep = pStepList; pStep; pStep = pStep.pNext)
			{
				pParse.eOrconf = (byte)(((orconf) == (11)) ? pStep.orconf : (byte)(orconf));
				if ((pStep.zSpan) != null)
				{
					sqlite3VdbeAddOp4(v, (int)(179), (int)(0x7fffffff), (int)(1), (int)(0), sqlite3MPrintf(db, "-- %s", pStep.zSpan), (int)(-7));
				}

				switch (pStep.op)
				{
					case 129:
						{
							sqlite3Update(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprListDup(db, pStep.pExprList, (int)(0)), sqlite3ExprDup(db, pStep.pWhere, (int)(0)), (int)(pParse.eOrconf), null, null, null);
							sqlite3VdbeAddOp0(v, (int)(130));
							break;
						}

					case 127:
						{
							sqlite3Insert(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3SelectDup(db, pStep.pSelect, (int)(0)), sqlite3IdListDup(db, pStep.pIdList), (int)(pParse.eOrconf), sqlite3UpsertDup(db, pStep.pUpsert));
							sqlite3VdbeAddOp0(v, (int)(130));
							break;
						}

					case 128:
						{
							sqlite3DeleteFrom(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprDup(db, pStep.pWhere, (int)(0)), null, null);
							sqlite3VdbeAddOp0(v, (int)(130));
							break;
						}

					default:
						;
						{
							SelectDest sDest = new SelectDest();
							Select pSelect = sqlite3SelectDup(db, pStep.pSelect, (int)(0));
							sqlite3SelectDestInit(sDest, (int)(4), (int)(0));
							sqlite3Select(pParse, pSelect, sDest);
							sqlite3SelectDelete(db, pSelect);
							break;
						}
				}
			}

			return (int)(0);
		}
		public static void codeVectorCompare(Parse pParse, Expr pExpr, int dest, byte op, byte p5)
		{
			Vdbe v = pParse.pVdbe;
			Expr pLeft = pExpr.pLeft;
			Expr pRight = pExpr.pRight;
			int nLeft = (int)(sqlite3ExprVectorSize(pLeft));
			int i = 0;
			int regLeft = (int)(0);
			int regRight = (int)(0);
			byte opx = (byte)(op);
			int addrCmp = (int)(0);
			int addrDone = (int)(sqlite3VdbeMakeLabel(pParse));
			int isCommuted = (int)(((pExpr).flags & (0x000200)) != 0);
			if ((pParse.nErr) != 0)
				return;
			if (nLeft != sqlite3ExprVectorSize(pRight))
			{
				sqlite3ErrorMsg(pParse, "row value misused");
				return;
			}

			if ((op) == (55))
				opx = (byte)(56);
			if ((op) == (57))
				opx = (byte)(54);
			if ((op) == (52))
				opx = (byte)(53);
			regLeft = (int)(exprCodeSubselect(pParse, pLeft));
			regRight = (int)(exprCodeSubselect(pParse, pRight));
			sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(dest));
			for (i = (int)(0); 1; i++)
			{
				int regFree1 = (int)(0);
				int regFree2 = (int)(0);
				Expr pL = null;
				Expr pR = null;
				int r1 = 0;
				int r2 = 0;
				if ((addrCmp) != 0)
					sqlite3VdbeJumpHere(v, (int)(addrCmp));
				r1 = (int)(exprVectorRegister(pParse, pLeft, (int)(i), (int)(regLeft), pL, &regFree1));
				r2 = (int)(exprVectorRegister(pParse, pRight, (int)(i), (int)(regRight), pR, &regFree2));
				addrCmp = (int)(sqlite3VdbeCurrentAddr(v));
				codeCompare(pParse, pL, pR, (int)(opx), (int)(r1), (int)(r2), (int)(addrDone), (int)(p5), (int)(isCommuted));
				sqlite3ReleaseTempReg(pParse, (int)(regFree1));
				sqlite3ReleaseTempReg(pParse, (int)(regFree2));
				if ((((opx) == (56)) || ((opx) == (54))) && ((i) < (nLeft - 1)))
				{
					addrCmp = (int)(sqlite3VdbeAddOp0(v, (int)(58)));
				}

				if ((p5) == (0x80))
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(dest));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(91), (int)(r1), (int)(dest), (int)(r2));
				}

				if ((i) == (nLeft - 1))
				{
					break;
				}

				if ((opx) == (53))
				{
					sqlite3VdbeAddOp2(v, (int)(51), (int)(dest), (int)(addrDone));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrDone));
					if ((i) == (nLeft - 2))
						opx = (byte)(op);
				}
			}

			sqlite3VdbeJumpHere(v, (int)(addrCmp));
			sqlite3VdbeResolveLabel(v, (int)(addrDone));
			if ((op) == (52))
			{
				sqlite3VdbeAddOp2(v, (int)(19), (int)(dest), (int)(dest));
			}
		}
		public static void computeLimitRegisters(Parse pParse, Select p, int iBreak)
		{
			Vdbe v = null;
			int iLimit = (int)(0);
			int iOffset = 0;
			int n = 0;
			Expr pLimit = p.pLimit;
			if ((p.iLimit) != 0)
				return;
			if ((pLimit) != null)
			{
				p.iLimit = (int)(iLimit = (int)(++pParse.nMem));
				v = sqlite3GetVdbe(pParse);
				if ((sqlite3ExprIsInteger(pLimit.pLeft, &n)) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(n), (int)(iLimit));
					if ((n) == (0))
					{
						sqlite3VdbeGoto(v, (int)(iBreak));
					}
					else if (((n) >= (0)) && ((p.nSelectRow) > (sqlite3LogEst((ulong)(n)))))
					{
						p.nSelectRow = (short)(sqlite3LogEst((ulong)(n)));
						p.selFlags |= (uint)(0x0004000);
					}
				}
				else
				{
					sqlite3ExprCode(pParse, pLimit.pLeft, (int)(iLimit));
					sqlite3VdbeAddOp1(v, (int)(15), (int)(iLimit));
					sqlite3VdbeAddOp2(v, (int)(20), (int)(iLimit), (int)(iBreak));
				}

				if ((pLimit.pRight) != null)
				{
					p.iOffset = (int)(iOffset = (int)(++pParse.nMem));
					pParse.nMem++;
					sqlite3ExprCode(pParse, pLimit.pRight, (int)(iOffset));
					sqlite3VdbeAddOp1(v, (int)(15), (int)(iOffset));
					sqlite3VdbeAddOp3(v, (int)(159), (int)(iLimit), (int)(iOffset + 1), (int)(iOffset));
				}
			}
		}
		public static void constructAutomaticIndex(Parse pParse, WhereClause pWC, SrcItem pSrc, ulong notReady, WhereLevel pLevel)
		{
			int nKeyCol = 0;
			WhereTerm pTerm;
			WhereTerm pWCEnd;
			Index pIdx;
			Vdbe v;
			int addrInit = 0;
			Table pTable;
			int addrTop = 0;
			int regRecord = 0;
			int n = 0;
			int i = 0;
			int mxBitCol = 0;
			CollSeq pColl;
			WhereLoop pLoop;
			sbyte* zNotUsed;
			ulong idxCols = 0;
			ulong extraCols = 0;
			byte sentWarning = (byte)(0);
			Expr pPartial = null;
			int iContinue = (int)(0);
			SrcItem pTabItem;
			int addrCounter = (int)(0);
			int regBase = 0;
			v = pParse.pVdbe;
			addrInit = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			nKeyCol = (int)(0);
			pTable = pSrc.pTab;
			pWCEnd = pWC.a[pWC.nTerm];
			pLoop = pLevel.pWLoop;
			idxCols = (ulong)(0);
			for (pTerm = pWC.a; (pTerm) < (pWCEnd); pTerm++)
			{
				Expr pExpr = pTerm.pExpr;
				if ((((pTerm.wtFlags & 0x0002) == (0)) && (((pSrc.fg.jointype & 0x0008) == (0)) || (((pExpr).flags & (0x000001)) != 0))) && ((sqlite3ExprIsTableConstant(pExpr, (int)(pSrc.iCursor))) != 0))
				{
					pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse.db, pExpr, (int)(0)));
				}

				if ((termCanDriveIndex(pTerm, pSrc, (ulong)(notReady))) != 0)
				{
					int iCol = 0;
					ulong cMask = 0;
					iCol = (int)(pTerm.u.x.leftColumn);
					cMask = (ulong)((iCol) >= ((int)(sizeof(ulong) * 8)) ? (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1)) : (((ulong)(1)) << (iCol)));
					if (sentWarning == 0)
					{
						sqlite3_log((int)(28 | (1 << 8)), "automatic index on %s(%s)", pTable.zName, pTable.aCol[iCol].zCnName);
						sentWarning = (byte)(1);
					}

					if ((idxCols & cMask) == (0))
					{
						if ((whereLoopResize(pParse.db, pLoop, (int)(nKeyCol + 1))) != 0)
						{
							goto end_auto_index_create;
						}

						pLoop.aLTerm[nKeyCol++] = pTerm;
						idxCols |= (ulong)(cMask);
					}
				}
			}

			pLoop.u.btree.nEq = (ushort)(pLoop.nLTerm = (ushort)(nKeyCol));
			pLoop.wsFlags = (uint)(0x00000001 | 0x00000040 | 0x00000200 | 0x00004000);
			extraCols = (ulong)(pSrc.colUsed & (~idxCols | (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1))));
			mxBitCol = (int)((((int)(sizeof(ulong) * 8)) - 1) < (pTable.nCol) ? (((int)(sizeof(ulong) * 8)) - 1) : (pTable.nCol));
			for (i = (int)(0); (i) < (mxBitCol); i++)
			{
				if ((extraCols & (((ulong)(1)) << (i))) != 0)
					nKeyCol++;
			}

			if ((pSrc.colUsed & (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1))) != 0)
			{
				nKeyCol += (int)(pTable.nCol - ((int)(sizeof(ulong) * 8)) + 1);
			}

			pIdx = sqlite3AllocateIndexObject(pParse.db, (short)(nKeyCol + 1), (int)(0), &zNotUsed);
			if ((pIdx) == (null))
				goto end_auto_index_create;
			pLoop.u.btree.pIndex = pIdx;
			pIdx.zName = "auto-index";
			pIdx.pTable = pTable;
			n = (int)(0);
			idxCols = (ulong)(0);
			for (pTerm = pWC.a; (pTerm) < (pWCEnd); pTerm++)
			{
				if ((termCanDriveIndex(pTerm, pSrc, (ulong)(notReady))) != 0)
				{
					int iCol = 0;
					ulong cMask = 0;
					iCol = (int)(pTerm.u.x.leftColumn);
					cMask = (ulong)((iCol) >= ((int)(sizeof(ulong) * 8)) ? (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1)) : (((ulong)(1)) << (iCol)));
					if ((idxCols & cMask) == (0))
					{
						Expr pX = pTerm.pExpr;
						idxCols |= (ulong)(cMask);
						pIdx.aiColumn[n] = (short)(pTerm.u.x.leftColumn);
						pColl = sqlite3ExprCompareCollSeq(pParse, pX);
						pIdx.azColl[n] = pColl ? pColl.zName : sqlite3StrBINARY;
						n++;
					}
				}
			}

			for (i = (int)(0); (i) < (mxBitCol); i++)
			{
				if ((extraCols & (((ulong)(1)) << (i))) != 0)
				{
					pIdx.aiColumn[n] = (short)(i);
					pIdx.azColl[n] = sqlite3StrBINARY;
					n++;
				}
			}

			if ((pSrc.colUsed & (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1))) != 0)
			{
				for (i = (int)(((int)(sizeof(ulong) * 8)) - 1); (i) < (pTable.nCol); i++)
				{
					pIdx.aiColumn[n] = (short)(i);
					pIdx.azColl[n] = sqlite3StrBINARY;
					n++;
				}
			}

			pIdx.aiColumn[n] = (short)(-1);
			pIdx.azColl[n] = sqlite3StrBINARY;
			pLevel.iIdxCur = (int)(pParse.nTab++);
			sqlite3VdbeAddOp2(v, (int)(115), (int)(pLevel.iIdxCur), (int)(nKeyCol + 1));
			sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
			if ((((pParse.db).dbOptFlags & (0x00080000)) == (0)))
			{
				pLevel.regFilter = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(76), (int)(10000), (int)(pLevel.regFilter));
			}

			pTabItem = pWC.pWInfo.pTabList.a[pLevel.iFrom];
			if ((pTabItem.fg.viaCoroutine) != 0)
			{
				int regYield = (int)(pTabItem.regReturn);
				addrCounter = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(0)));
				sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(pTabItem.addrFillSub));
				addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(regYield)));
			}
			else
			{
				addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(pLevel.iTabCur)));
			}

			if ((pPartial) != null)
			{
				iContinue = (int)(sqlite3VdbeMakeLabel(pParse));
				sqlite3ExprIfFalse(pParse, pPartial, (int)(iContinue), (int)(0x10));
				pLoop.wsFlags |= (uint)(0x00020000);
			}

			regRecord = (int)(sqlite3GetTempReg(pParse));
			regBase = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(pLevel.iTabCur), (int)(regRecord), (int)(0), null, null, (int)(0)));
			if ((pLevel.regFilter) != 0)
			{
				sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(regBase), (int)(pLoop.u.btree.nEq));
			}

			sqlite3VdbeAddOp2(v, (int)(137), (int)(pLevel.iIdxCur), (int)(regRecord));
			sqlite3VdbeChangeP5(v, (ushort)(0x10));
			if ((pPartial) != null)
				sqlite3VdbeResolveLabel(v, (int)(iContinue));
			if ((pTabItem.fg.viaCoroutine) != 0)
			{
				sqlite3VdbeChangeP2(v, (int)(addrCounter), (int)(regBase + n));
				translateColumnToCopy(pParse, (int)(addrTop), (int)(pLevel.iTabCur), (int)(pTabItem.regResult), (int)(pLevel.iIdxCur));
				sqlite3VdbeGoto(v, (int)(addrTop));
				pTabItem.fg.viaCoroutine = (uint)(0);
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(pLevel.iTabCur), (int)(addrTop + 1));
				sqlite3VdbeChangeP5(v, (ushort)(3));
			}

			sqlite3VdbeJumpHere(v, (int)(addrTop));
			sqlite3ReleaseTempReg(pParse, (int)(regRecord));
			sqlite3VdbeJumpHere(v, (int)(addrInit));
		end_auto_index_create:
			; sqlite3ExprDelete(pParse.db, pPartial);
		}
		public static void convertToWithoutRowidTable(Parse pParse, Table pTab)
		{
			Index pIdx;
			Index pPk;
			int nPk = 0;
			int nExtra = 0;
			int i = 0; int j = 0;
			sqlite3 db = pParse.db;
			Vdbe v = pParse.pVdbe;
			if (db.init.imposterTable == 0)
			{
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					if (((pTab.aCol[i].colFlags & 0x0001) != 0) && ((pTab.aCol[i].notNull) == (0)))
					{
						pTab.aCol[i].notNull = (uint)(2);
					}
				}

				pTab.tabFlags |= (uint)(0x00000800);
			}

			if ((pParse.u1.addrCrTab) != 0)
			{
				sqlite3VdbeChangeP3(v, (int)(pParse.u1.addrCrTab), (int)(2));
			}

			if ((pTab.iPKey) >= (0))
			{
				ExprList pList;
				Token ipkToken = new Token();
				sqlite3TokenInit(&ipkToken, pTab.aCol[pTab.iPKey].zCnName);
				pList = sqlite3ExprListAppend(pParse, null, sqlite3ExprAlloc(db, (int)(59), &ipkToken, (int)(0)));
				if ((pList) == (null))
				{
					pTab.tabFlags &= (uint)(~0x00000080);
					return;
				}

				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenRemap(pParse, pList.a[0].pExpr, &pTab.iPKey);
				}

				pList.a[0].sortFlags = (byte)(pParse.iPkSortOrder);
				pTab.iPKey = (short)(-1);
				sqlite3CreateIndex(pParse, null, null, null, pList, (int)(pTab.keyConf), null, null, (int)(0), (int)(0), (byte)(2));
				if ((pParse.nErr) != 0)
				{
					pTab.tabFlags &= (uint)(~0x00000080);
					return;
				}

				pPk = sqlite3PrimaryKeyIndex(pTab);
			}
			else
			{
				pPk = sqlite3PrimaryKeyIndex(pTab);
				for (i = (int)(j = (int)(1)); (i) < (pPk.nKeyCol); i++)
				{
					if ((isDupColumn(pPk, (int)(j), pPk, (int)(i))) != 0)
					{
						pPk.nColumn--;
					}
					else
					{
						pPk.azColl[j] = pPk.azColl[i];
						pPk.aSortOrder[j] = (byte)(pPk.aSortOrder[i]);
						pPk.aiColumn[j++] = (short)(pPk.aiColumn[i]);
					}
				}

				pPk.nKeyCol = (ushort)(j);
			}

			pPk.isCovering = (uint)(1);
			if (db.init.imposterTable == 0)
				pPk.uniqNotNull = (uint)(1);
			nPk = (int)(pPk.nColumn = (ushort)(pPk.nKeyCol));
			if (((v) != null) && ((pPk.tnum) > (0)))
			{
				sqlite3VdbeChangeOpcode(v, (int)(pPk.tnum), (byte)(11));
			}

			pPk.tnum = (uint)(pTab.tnum);
			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				int n = 0;
				if ((((pIdx).idxType) == (2)))
					continue;
				for (i = (int)(n = (int)(0)); (i) < (nPk); i++)
				{
					if (isDupColumn(pIdx, (int)(pIdx.nKeyCol), pPk, (int)(i)) == 0)
					{
						n++;
					}
				}

				if ((n) == (0))
				{
					pIdx.nColumn = (ushort)(pIdx.nKeyCol);
					continue;
				}

				if ((resizeIndexObject(db, pIdx, (int)(pIdx.nKeyCol + n))) != 0)
					return;
				for (i = (int)(0), j = (int)(pIdx.nKeyCol); (i) < (nPk); i++)
				{
					if (isDupColumn(pIdx, (int)(pIdx.nKeyCol), pPk, (int)(i)) == 0)
					{
						pIdx.aiColumn[j] = (short)(pPk.aiColumn[i]);
						pIdx.azColl[j] = pPk.azColl[i];
						if ((pPk.aSortOrder[i]) != 0)
						{
							pIdx.bAscKeyBug = (uint)(1);
						}

						j++;
					}
				}
			}

			nExtra = (int)(0);
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((hasColumn(pPk.aiColumn, (int)(nPk), (int)(i)) == 0) && ((pTab.aCol[i].colFlags & 0x0020) == (0)))
					nExtra++;
			}

			if ((resizeIndexObject(db, pPk, (int)(nPk + nExtra))) != 0)
				return;
			for (i = (int)(0), j = (int)(nPk); (i) < (pTab.nCol); i++)
			{
				if ((hasColumn(pPk.aiColumn, (int)(j), (int)(i)) == 0) && ((pTab.aCol[i].colFlags & 0x0020) == (0)))
				{
					pPk.aiColumn[j] = (short)(i);
					pPk.azColl[j] = sqlite3StrBINARY;
					j++;
				}
			}

			recomputeColumnsNotIndexed(pPk);
		}
		public static void destroyRootPage(Parse pParse, int iTable, int iDb)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			int r1 = (int)(sqlite3GetTempReg(pParse));
			if ((iTable) < (2))
				sqlite3ErrorMsg(pParse, "corrupt schema");
			sqlite3VdbeAddOp3(v, (int)(143), (int)(iTable), (int)(r1), (int)(iDb));
			sqlite3MayAbort(pParse);
			sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET rootpage=%d WHERE #%d AND rootpage=#%d", pParse.db.aDb[iDb].zDbSName, (int)(iTable), (int)(r1), (int)(r1));
			sqlite3ReleaseTempReg(pParse, (int)(r1));
		}
		public static void destroyTable(Parse pParse, Table pTab)
		{
			uint iTab = (uint)(pTab.tnum);
			uint iDestroyed = (uint)(0);
			while ((1) != 0)
			{
				Index pIdx;
				uint iLargest = (uint)(0);
				if (((iDestroyed) == (0)) || ((iTab) < (iDestroyed)))
				{
					iLargest = (uint)(iTab);
				}

				for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
				{
					uint iIdx = (uint)(pIdx.tnum);
					if ((((iDestroyed) == (0)) || ((iIdx) < (iDestroyed))) && ((iIdx) > (iLargest)))
					{
						iLargest = (uint)(iIdx);
					}
				}

				if ((iLargest) == (0))
				{
					return;
				}
				else
				{
					int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
					destroyRootPage(pParse, (int)(iLargest), (int)(iDb));
					iDestroyed = (uint)(iLargest);
				}
			}
		}
		public static void disableLookaside(Parse pParse)
		{
			sqlite3 db = pParse.db;
			pParse.disableLookaside++;
			db.lookaside.bDisable++;
			db.lookaside.sz = (ushort)(0);
		}
		public static void explainSimpleCount(Parse pParse, Table pTab, Index pIdx)
		{
			if ((pParse.explain) == (2))
			{
				int bCover = (int)(((pIdx != null) && ((((pTab).tabFlags & 0x00000080) == (0)) || (!(((pIdx).idxType) == (2))))) ? 1 : 0);
				sqlite3VdbeExplain(pParse, (byte)(0), "SCAN %s%s%s", pTab.zName, (bCover) != 0 ? " USING COVERING INDEX " : "", (bCover) != 0 ? pIdx.zName : "");
			}
		}
		public static void explainTempTable(Parse pParse, sbyte* zUsage)
		{
			sqlite3VdbeExplain(pParse, (byte)(0), "USE TEMP B-TREE FOR %s", zUsage);
		}
		public static void exprCodeBetween(Parse pParse, Expr pExpr, int dest, delegate175 xJump, int jumpIfNull)
		{
			Expr exprAnd = new Expr();
			Expr compLeft = new Expr();
			Expr compRight = new Expr();
			int regFree1 = (int)(0);
			Expr pDel = null;
			sqlite3 db = pParse.db;
			CRuntime.memset(compLeft, (int)(0), (ulong)(sizeof(Expr)));
			CRuntime.memset(compRight, (int)(0), (ulong)(sizeof(Expr)));
			CRuntime.memset(exprAnd, (int)(0), (ulong)(sizeof(Expr)));
			pDel = sqlite3ExprDup(db, pExpr.pLeft, (int)(0));
			if ((db.mallocFailed) == (0))
			{
				exprAnd.op = (byte)(44);
				exprAnd.pLeft = compLeft;
				exprAnd.pRight = compRight;
				compLeft.op = (byte)(57);
				compLeft.pLeft = pDel;
				compLeft.pRight = pExpr.x.pList.a[0].pExpr;
				compRight.op = (byte)(55);
				compRight.pLeft = pDel;
				compRight.pRight = pExpr.x.pList.a[1].pExpr;
				exprToRegister(pDel, (int)(exprCodeVector(pParse, pDel, &regFree1)));
				if ((xJump) != null)
				{
					xJump(pParse, exprAnd, (int)(dest), (int)(jumpIfNull));
				}
				else
				{
					pDel.flags |= (uint)(0x000001);
					sqlite3ExprCodeTarget(pParse, exprAnd, (int)(dest));
				}

				sqlite3ReleaseTempReg(pParse, (int)(regFree1));
			}

			sqlite3ExprDelete(db, pDel);
		}
		public static int exprCodeInlineFunction(Parse pParse, ExprList pFarg, int iFuncId, int target)
		{
			int nFarg = 0;
			Vdbe v = pParse.pVdbe;
			nFarg = (int)(pFarg.nExpr);
			switch (iFuncId)
			{
				case 0:
					{
						int endCoalesce = (int)(sqlite3VdbeMakeLabel(pParse));
						int i = 0;
						sqlite3ExprCode(pParse, pFarg.a[0].pExpr, (int)(target));
						for (i = (int)(1); (i) < (nFarg); i++)
						{
							sqlite3VdbeAddOp2(v, (int)(51), (int)(target), (int)(endCoalesce));
							sqlite3ExprCode(pParse, pFarg.a[i].pExpr, (int)(target));
						}

						setDoNotMergeFlagOnCopy(v);
						sqlite3VdbeResolveLabel(v, (int)(endCoalesce));
						break;
					}

				case 5:
					{
						Expr caseExpr = new Expr();
						CRuntime.memset(caseExpr, (int)(0), (ulong)(sizeof(Expr)));
						caseExpr.op = (byte)(157);
						caseExpr.x.pList = pFarg;
						return (int)(sqlite3ExprCodeTarget(pParse, caseExpr, (int)(target)));
					}

				default:
					{
						target = (int)(sqlite3ExprCodeTarget(pParse, pFarg.a[0].pExpr, (int)(target)));
						break;
					}

				case 3:
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprCompare(null, pFarg.a[0].pExpr, pFarg.a[1].pExpr, (int)(-1))), (int)(target));
						break;
					}

				case 2:
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprImpliesExpr(pParse, pFarg.a[0].pExpr, pFarg.a[1].pExpr, (int)(-1))), (int)(target));
						break;
					}

				case 1:
					{
						Expr pA1;
						pA1 = pFarg.a[1].pExpr;
						if ((pA1.op) == (167))
						{
							sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprImpliesNonNullRow(pFarg.a[0].pExpr, (int)(pA1.iTable))), (int)(target));
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
						}

						break;
					}

				case 4:
					{
						sbyte** azAff = stackalloc sbyte*[] { "blob", "text", "numeric", "integer", "real" };
						sbyte aff = 0;
						aff = (sbyte)(sqlite3ExprAffinity(pFarg.a[0].pExpr));
						sqlite3VdbeLoadString(v, (int)(target), ((aff) <= (0x40)) ? "none" : azAff[aff - 0x41]);
						break;
					}
			}

			return (int)(target);
		}
		public static int exprCodeSubselect(Parse pParse, Expr pExpr)
		{
			int reg = (int)(0);
			if ((pExpr.op) == (138))
			{
				reg = (int)(sqlite3CodeSubselect(pParse, pExpr));
			}

			return (int)(reg);
		}
		public static int exprCodeVector(Parse pParse, Expr p, int* piFreeable)
		{
			int iResult = 0;
			int nResult = (int)(sqlite3ExprVectorSize(p));
			if ((nResult) == (1))
			{
				iResult = (int)(sqlite3ExprCodeTemp(pParse, p, piFreeable));
			}
			else
			{
				*piFreeable = (int)(0);
				if ((p.op) == (138))
				{
					iResult = (int)(sqlite3CodeSubselect(pParse, p));
				}
				else
				{
					int i = 0;
					iResult = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(nResult);
					for (i = (int)(0); (i) < (nResult); i++)
					{
						sqlite3ExprCodeFactorable(pParse, p.x.pList.a[i].pExpr, (int)(i + iResult));
					}
				}
			}

			return (int)(iResult);
		}
		public static ushort exprCommute(Parse pParse, Expr pExpr)
		{
			if ((((pExpr.pLeft.op) == (177)) || ((pExpr.pRight.op) == (177))) || (sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pExpr.pRight) != sqlite3BinaryCompareCollSeq(pParse, pExpr.pRight, pExpr.pLeft)))
			{
				pExpr.flags ^= (uint)(0x000200);
			}

			{
				Expr t = pExpr.pRight;
				pExpr.pRight = pExpr.pLeft;
				pExpr.pLeft = t;
			}

			if ((pExpr.op) >= (54))
			{
				pExpr.op = (byte)(((pExpr.op - 54) ^ 2) + 54);
			}

			return (ushort)(0);
		}
		public static int exprCompareVariable(Parse pParse, Expr pVar, Expr pExpr)
		{
			int res = (int)(0);
			int iVar = 0;
			sqlite3_value pL; sqlite3_value pR = null;
			sqlite3ValueFromExpr(pParse.db, pExpr, (byte)(1), (byte)(0x41), pR);
			if ((pR) != null)
			{
				iVar = (int)(pVar.iColumn);
				sqlite3VdbeSetVarmask(pParse.pVdbe, (int)(iVar));
				pL = sqlite3VdbeGetBoundValue(pParse.pReprepare, (int)(iVar), (byte)(0x41));
				if ((pL) != null)
				{
					if ((sqlite3_value_type(pL)) == (3))
					{
						sqlite3_value_text(pL);
					}

					res = (int)((0) == (sqlite3MemCompare(pL, pR, null)) ? 1 : 0);
				}

				sqlite3ValueFree(pR);
				sqlite3ValueFree(pL);
			}

			return (int)(res);
		}
		public static int exprImpliesNotNull(Parse pParse, Expr p, Expr pNN, int iTab, int seenNot)
		{
			if ((sqlite3ExprCompare(pParse, p, pNN, (int)(iTab))) == (0))
			{
				return (int)(pNN.op != 121);
			}

			switch (p.op)
			{
				case 49:
					{
						if (((seenNot) != 0) && (((p).flags & (0x000800)) != 0))
							return (int)(0);
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}

				case 48:
					{
						ExprList pList;
						pList = p.x.pList;
						if ((seenNot) != 0)
							return (int)(0);
						if (((exprImpliesNotNull(pParse, pList.a[0].pExpr, pNN, (int)(iTab), (int)(1))) != 0) || ((exprImpliesNotNull(pParse, pList.a[1].pExpr, pNN, (int)(iTab), (int)(1))) != 0))
						{
							return (int)(1);
						}

						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}

				case 53:
				case 52:
				case 56:
				case 55:
				case 54:
				case 57:
				case 106:
				case 107:
				case 103:
				case 104:
				case 105:
				case 111:
					seenNot = (int)(1);
				case 108:
				case 110:
				case 102:
				case 109:
					{
						if ((exprImpliesNotNull(pParse, p.pRight, pNN, (int)(iTab), (int)(seenNot))) != 0)
							return (int)(1);
					}

				case 181:
				case 113:
				case 174:
				case 173:
					{
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(seenNot)));
					}

				case 175:
					{
						if ((seenNot) != 0)
							return (int)(0);
						if (p.op2 != 45)
							return (int)(0);
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}

				case 114:
				case 19:
					{
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}
			}

			return (int)(0);
		}
		public static ExprList exprListAppendList(Parse pParse, ExprList pList, ExprList pAppend, int bIntToNull)
		{
			if ((pAppend) != null)
			{
				int i = 0;
				int nInit = (int)(pList ? pList.nExpr : 0);
				for (i = (int)(0); (i) < (pAppend.nExpr); i++)
				{
					sqlite3 db = pParse.db;
					Expr pDup = sqlite3ExprDup(db, pAppend.a[i].pExpr, (int)(0));
					if ((db.mallocFailed) != 0)
					{
						sqlite3ExprDelete(db, pDup);
						break;
					}

					if ((bIntToNull) != 0)
					{
						int iDummy = 0;
						Expr pSub;
						pSub = sqlite3ExprSkipCollateAndLikely(pDup);
						if ((sqlite3ExprIsInteger(pSub, &iDummy)) != 0)
						{
							pSub.op = (byte)(121);
							pSub.flags &= (uint)(~(0x000400 | 0x10000000 | 0x20000000));
							pSub.u.zToken = null;
						}
					}

					pList = sqlite3ExprListAppend(pParse, pList, pDup);
					if ((pList) != null)
						pList.a[nInit + i].sortFlags = (byte)(pAppend.a[i].sortFlags);
				}
			}

			return pList;
		}
		public static Expr exprRowColumn(Parse pParse, int iCol)
		{
			Expr pRet = sqlite3PExpr(pParse, (int)(75), null, null);
			if ((pRet) != null)
				pRet.iColumn = (short)(iCol + 1);
			return pRet;
		}
		public static Expr exprTableRegister(Parse pParse, Table pTab, int regBase, short iCol)
		{
			Expr pExpr;
			Column* pCol;
			sbyte* zColl;
			sqlite3 db = pParse.db;
			pExpr = sqlite3Expr(db, (int)(176), null);
			if ((pExpr) != null)
			{
				if (((iCol) >= (0)) && (iCol != pTab.iPKey))
				{
					pCol = &pTab.aCol[iCol];
					pExpr.iTable = (int)(regBase + sqlite3TableColumnToStorage(pTab, (short)(iCol)) + 1);
					pExpr.affExpr = (sbyte)(pCol->affinity);
					zColl = sqlite3ColumnColl(pCol);
					if ((zColl) == (null))
						zColl = db.pDfltColl.zName;
					pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
				}
				else
				{
					pExpr.iTable = (int)(regBase);
					pExpr.affExpr = (sbyte)(0x44);
				}
			}

			return pExpr;
		}
		public static int exprVectorRegister(Parse pParse, Expr pVector, int iField, int regSelect, Expr ppExpr, int* pRegFree)
		{
			byte op = (byte)(pVector.op);
			if ((op) == (176))
			{
				ppExpr = sqlite3VectorFieldSubexpr(pVector, (int)(iField));
				return (int)(pVector.iTable + iField);
			}

			if ((op) == (138))
			{
				ppExpr = pVector.x.pSelect.pEList.a[iField].pExpr;
				return (int)(regSelect + iField);
			}

			if ((op) == (177))
			{
				ppExpr = pVector.x.pList.a[iField].pExpr;
				return (int)(sqlite3ExprCodeTemp(pParse, ppExpr, pRegFree));
			}

			return (int)(0);
		}
		public static void filterPullDown(Parse pParse, WhereInfo pWInfo, int iLevel, int addrNxt, ulong notReady)
		{
			while ((++iLevel) < (pWInfo.nLevel))
			{
				WhereLevel pLevel = pWInfo.a[iLevel];
				WhereLoop pLoop = pLevel.pWLoop;
				if ((pLevel.regFilter) == (0))
					continue;
				if ((pLevel.pWLoop.nSkip) != 0)
					continue;
				if ((pLoop.prereq & notReady) != 0)
					continue;
				if ((pLoop.wsFlags & 0x00000100) != 0)
				{
					WhereTerm pTerm = pLoop.aLTerm[0];
					int regRowid = 0;
					regRowid = (int)(sqlite3GetTempReg(pParse));
					regRowid = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(0), (int)(0), (int)(regRowid)));
					sqlite3VdbeAddOp4Int(pParse.pVdbe, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(regRowid), (int)(1));
				}
				else
				{
					ushort nEq = (ushort)(pLoop.u.btree.nEq);
					int r1 = 0;
					sbyte* zStartAff;
					r1 = (int)(codeAllEqualityTerms(pParse, pLevel, (int)(0), (int)(0), &zStartAff));
					codeApplyAffinity(pParse, (int)(r1), (int)(nEq), zStartAff);
					sqlite3DbFree(pParse.db, zStartAff);
					sqlite3VdbeAddOp4Int(pParse.pVdbe, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(r1), (int)(nEq));
				}

				pLevel.regFilter = (int)(0);
			}
		}
		public static void finalizeAggFunctions(Parse pParse, AggInfo pAggInfo)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			AggInfo_func pF;
			for (i = (int)(0), pF = pAggInfo.aFunc; (i) < (pAggInfo.nFunc); i++, pF++)
			{
				ExprList pList;
				pList = pF.pFExpr.x.pList;
				sqlite3VdbeAddOp2(v, (int)(164), (int)(pF.iMem), (int)(pList ? pList.nExpr : 0));
				sqlite3VdbeAppendP4(v, pF.pFunc, (int)(-8));
			}
		}
		public static int findIndexCol(Parse pParse, ExprList pList, int iBase, Index pIdx, int iCol)
		{
			int i = 0;
			sbyte* zColl = pIdx.azColl[iCol];
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				Expr p = sqlite3ExprSkipCollateAndLikely(pList.a[i].pExpr);
				if ((((p != null) && (((p.op) == (167)) || ((p.op) == (169)))) && ((p.iColumn) == (pIdx.aiColumn[iCol]))) && ((p.iTable) == (iBase)))
				{
					CollSeq pColl = sqlite3ExprNNCollSeq(pParse, pList.a[i].pExpr);
					if ((0) == (sqlite3StrICmp(pColl.zName, zColl)))
					{
						return (int)(i);
					}
				}
			}

			return (int)(-1);
		}
		public static void fixDistinctOpenEph(Parse pParse, int eTnctType, int iVal, int iOpenEphAddr)
		{
			if (((pParse.nErr) == (0)) && (((eTnctType) == (1)) || ((eTnctType) == (2))))
			{
				Vdbe v = pParse.pVdbe;
				sqlite3VdbeChangeToNoop(v, (int)(iOpenEphAddr));
				if ((sqlite3VdbeGetOp(v, (int)(iOpenEphAddr + 1))->opcode) == (183))
				{
					sqlite3VdbeChangeToNoop(v, (int)(iOpenEphAddr + 1));
				}

				if ((eTnctType) == (2))
				{
					VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iOpenEphAddr));
					pOp->opcode = (byte)(74);
					pOp->p1 = (int)(1);
					pOp->p2 = (int)(iVal);
				}
			}
		}
		public static Trigger fkActionTrigger(Parse pParse, Table pTab, FKey pFKey, ExprList pChanges)
		{
			sqlite3 db = pParse.db;
			int action = 0;
			Trigger pTrigger;
			int iAction = (int)(pChanges != null);
			action = (int)(pFKey.aAction[iAction]);
			if (((action) == (7)) && ((db.flags & 0x00080000) != 0))
			{
				return null;
			}

			pTrigger = pFKey.apTrigger[iAction];
			if ((action != 0) && (pTrigger == null))
			{
				sbyte* zFrom;
				int nFrom = 0;
				Index pIdx = null;
				int* aiCol = null;
				TriggerStep pStep = null;
				Expr pWhere = null;
				ExprList pList = null;
				Select pSelect = null;
				int i = 0;
				Expr pWhen = null;
				if ((sqlite3FkLocateIndex(pParse, pTab, pFKey, pIdx, &aiCol)) != 0)
					return null;
				for (i = (int)(0); (i) < (pFKey.nCol); i++)
				{
					Token tOld = (Token)(stackalloc Token[] { "old", 3 };
         )

        ;
				Token tNew = (Token)(stackalloc Token[] { "new", 3 }; )
        ;
				Token tFromCol = new Token();
				Token tToCol = new Token();
				int iFromCol = 0;
				Expr pEq;
				iFromCol = (int)((aiCol) != 0 ? aiCol[i] : pFKey.aCol[0].iFrom);
				sqlite3TokenInit(&tToCol, pTab.aCol[pIdx ? pIdx.aiColumn[i] : pTab.iPKey].zCnName);
				sqlite3TokenInit(&tFromCol, pFKey.pFrom.aCol[iFromCol].zCnName);
				pEq = sqlite3PExpr(pParse, (int)(53), sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &tOld, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &tToCol, (int)(0))), sqlite3ExprAlloc(db, (int)(59), &tFromCol, (int)(0)));
				pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
				if ((pChanges) != null)
				{
					pEq = sqlite3PExpr(pParse, (int)(45), sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &tOld, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &tToCol, (int)(0))), sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &tNew, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &tToCol, (int)(0))));
					pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
				}

				if ((action != 7) && ((action != 10) || ((pChanges) != null)))
				{
					Expr pNew;
					if ((action) == (10))
					{
						pNew = sqlite3PExpr(pParse, (int)(141), sqlite3ExprAlloc(db, (int)(59), &tNew, (int)(0)), sqlite3ExprAlloc(db, (int)(59), &tToCol, (int)(0)));
					}
					else if ((action) == (9))
					{
						Column* pCol = pFKey.pFrom.aCol + iFromCol;
						Expr pDflt;
						if ((pCol->colFlags & 0x0060) != 0)
						{
							pDflt = null;
						}
						else
						{
							pDflt = sqlite3ColumnExpr(pFKey.pFrom, pCol);
						}

						if ((pDflt) != null)
						{
							pNew = sqlite3ExprDup(db, pDflt, (int)(0));
						}
						else
						{
							pNew = sqlite3ExprAlloc(db, (int)(121), null, (int)(0));
						}
					}
					else
					{
						pNew = sqlite3ExprAlloc(db, (int)(121), null, (int)(0));
					}

					pList = sqlite3ExprListAppend(pParse, pList, pNew);
					sqlite3ExprListSetName(pParse, pList, &tFromCol, (int)(0));
				}
			}
			sqlite3DbFree(db, aiCol); zFrom = pFKey.pFrom.zName; nFrom = (int)(sqlite3Strlen30(zFrom)); if ((action) == (7)) { Token tFrom = new Token(); Expr pRaise; tFrom.z = zFrom; tFrom.n = (uint)(nFrom); pRaise = sqlite3Expr(db, (int)(71), "FOREIGN KEY constraint failed"); if ((pRaise) != null) { pRaise.affExpr = (sbyte)(2); } pSelect = sqlite3SelectNew(pParse, sqlite3ExprListAppend(pParse, null, pRaise), sqlite3SrcListAppend(pParse, null, &tFrom, null), pWhere, null, null, null, (uint)(0), null); pWhere = null; 
			}
			db.lookaside.bDisable++; db.lookaside.sz = (ushort)(0); pTrigger = (Trigger)(sqlite3DbMallocZero(db, (ulong)(sizeof(Trigger) + sizeof(TriggerStep) + nFrom + 1))); if ((pTrigger) != null) { pStep = pTrigger.step_list = (TriggerStep)(pTrigger[1]); pStep.zTarget = (sbyte*)(pStep[1]); CRuntime.memcpy(pStep.zTarget, zFrom, (ulong)(nFrom)); pStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001)); pStep.pExprList = sqlite3ExprListDup(db, pList, (int)(0x0001)); pStep.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001)); if ((pWhen) != null) { pWhen = sqlite3PExpr(pParse, (int)(19), pWhen, null); pTrigger.pWhen = sqlite3ExprDup(db, pWhen, (int)(0x0001)); } }
			db.lookaside.bDisable--; db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue); sqlite3ExprDelete(db, pWhere); sqlite3ExprDelete(db, pWhen); sqlite3ExprListDelete(db, pList); sqlite3SelectDelete(db, pSelect); if ((db.mallocFailed) == (1)) { fkTriggerDelete(db, pTrigger); return null; }
			switch (action) { case 7: pStep.op = (byte)(138); break; case 10: if (pChanges == null) { pStep.op = (byte)(128); break; } default: pStep.op = (byte)(129); }
			pStep.pTrig = pTrigger; pTrigger.pSchema = pTab.pSchema; pTrigger.pTabSchema = pTab.pSchema; pFKey.apTrigger[iAction] = pTrigger; pTrigger.op = (byte)(pChanges ? 129 : 128);
		}

    return pTrigger;
}
	public static void fkLookupParent(Parse pParse, int iDb, Table pTab, Index pIdx, FKey pFKey, int* aiCol, int regData, int nIncr, int isIgnore)
	{
		int i = 0;
		Vdbe v = sqlite3GetVdbe(pParse);
		int iCur = (int)(pParse.nTab - 1);
		int iOk = (int)(sqlite3VdbeMakeLabel(pParse));
		if ((nIncr) < (0))
		{
			sqlite3VdbeAddOp2(v, (int)(48), (int)(pFKey.isDeferred), (int)(iOk));
		}

		for (i = (int)(0); (i) < (pFKey.nCol); i++)
		{
			int iReg = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + regData + 1);
			sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(iOk));
		}

		if ((isIgnore) == (0))
		{
			if ((pIdx) == (null))
			{
				int iMustBeInt = 0;
				int regTemp = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp2(v, (int)(80), (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[0])) + 1 + regData), (int)(regTemp));
				iMustBeInt = (int)(sqlite3VdbeAddOp2(v, (int)(15), (int)(regTemp), (int)(0)));
				if (((pTab) == (pFKey.pFrom)) && ((nIncr) == (1)))
				{
					sqlite3VdbeAddOp3(v, (int)(53), (int)(regData), (int)(iOk), (int)(regTemp));
					sqlite3VdbeChangeP5(v, (ushort)(0x90));
				}

				sqlite3OpenTable(pParse, (int)(iCur), (int)(iDb), pTab, (int)(101));
				sqlite3VdbeAddOp3(v, (int)(33), (int)(iCur), (int)(0), (int)(regTemp));
				sqlite3VdbeGoto(v, (int)(iOk));
				sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
				sqlite3VdbeJumpHere(v, (int)(iMustBeInt));
				sqlite3ReleaseTempReg(pParse, (int)(regTemp));
			}
			else
			{
				int nCol = (int)(pFKey.nCol);
				int regTemp = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
				int regRec = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp3(v, (int)(101), (int)(iCur), (int)(pIdx.tnum), (int)(iDb));
				sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
				for (i = (int)(0); (i) < (nCol); i++)
				{
					sqlite3VdbeAddOp2(v, (int)(79), (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + 1 + regData), (int)(regTemp + i));
				}

				if (((pTab) == (pFKey.pFrom)) && ((nIncr) == (1)))
				{
					int iJump = (int)(sqlite3VdbeCurrentAddr(v) + nCol + 1);
					for (i = (int)(0); (i) < (nCol); i++)
					{
						int iChild = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + 1 + regData);
						int iParent = (int)(1 + regData);
						iParent += (int)(sqlite3TableColumnToStorage(pIdx.pTable, (short)(pIdx.aiColumn[i])));
						if ((pIdx.aiColumn[i]) == (pTab.iPKey))
						{
							iParent = (int)(regData);
						}

						sqlite3VdbeAddOp3(v, (int)(52), (int)(iChild), (int)(iJump), (int)(iParent));
						sqlite3VdbeChangeP5(v, (ushort)(0x10));
					}

					sqlite3VdbeGoto(v, (int)(iOk));
				}

				sqlite3VdbeAddOp4(v, (int)(96), (int)(regTemp), (int)(nCol), (int)(regRec), sqlite3IndexAffinityStr(pParse.db, pIdx), (int)(nCol));
				sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iCur), (int)(iOk), (int)(regRec), (int)(0));
				sqlite3ReleaseTempReg(pParse, (int)(regRec));
				sqlite3ReleaseTempRange(pParse, (int)(regTemp), (int)(nCol));
			}
		}

		if ((((pFKey.isDeferred == 0) && ((pParse.db.flags & 0x00080000) == 0)) && (pParse.pToplevel == null)) && (pParse.isMultiWrite == 0))
		{
			sqlite3HaltConstraint(pParse, (int)(19 | (3 << 8)), (int)(2), null, (sbyte)(-1), (byte)(4));
		}
		else
		{
			if (((nIncr) > (0)) && ((pFKey.isDeferred) == (0)))
			{
				sqlite3MayAbort(pParse);
			}

			sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(nIncr));
		}

		sqlite3VdbeResolveLabel(v, (int)(iOk));
		sqlite3VdbeAddOp1(v, (int)(121), (int)(iCur));
	}
	public static void fkScanChildren(Parse pParse, SrcList pSrc, Table pTab, Index pIdx, FKey pFKey, int* aiCol, int regData, int nIncr)
	{
		sqlite3 db = pParse.db;
		int i = 0;
		Expr pWhere = null;
		NameContext sNameContext = new NameContext();
		WhereInfo pWInfo;
		int iFkIfZero = (int)(0);
		Vdbe v = sqlite3GetVdbe(pParse);
		if ((nIncr) < (0))
		{
			iFkIfZero = (int)(sqlite3VdbeAddOp2(v, (int)(48), (int)(pFKey.isDeferred), (int)(0)));
		}

		for (i = (int)(0); (i) < (pFKey.nCol); i++)
		{
			Expr pLeft;
			Expr pRight;
			Expr pEq;
			short iCol = 0;
			sbyte* zCol;
			iCol = (short)(pIdx ? pIdx.aiColumn[i] : -1);
			pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(iCol));
			iCol = (short)((aiCol) != 0 ? aiCol[i] : pFKey.aCol[0].iFrom);
			zCol = pFKey.pFrom.aCol[iCol].zCnName;
			pRight = sqlite3Expr(db, (int)(59), zCol);
			pEq = sqlite3PExpr(pParse, (int)(53), pLeft, pRight);
			pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
		}

		if (((pTab) == (pFKey.pFrom)) && ((nIncr) > (0)))
		{
			Expr pNe;
			Expr pLeft;
			Expr pRight;
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(-1));
				pRight = exprTableColumn(db, pTab, (int)(pSrc.a[0].iCursor), (short)(-1));
				pNe = sqlite3PExpr(pParse, (int)(52), pLeft, pRight);
			}
			else
			{
				Expr pEq;
				Expr pAll = null;
				for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
				{
					short iCol = (short)(pIdx.aiColumn[i]);
					pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(iCol));
					pRight = sqlite3Expr(db, (int)(59), pTab.aCol[iCol].zCnName);
					pEq = sqlite3PExpr(pParse, (int)(45), pLeft, pRight);
					pAll = sqlite3ExprAnd(pParse, pAll, pEq);
				}

				pNe = sqlite3PExpr(pParse, (int)(19), pAll, null);
			}

			pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
		}

		CRuntime.memset(sNameContext, (int)(0), (ulong)(sizeof(NameContext)));
		sNameContext.pSrcList = pSrc;
		sNameContext.pParse = pParse;
		sqlite3ResolveExprNames(sNameContext, pWhere);
		if ((pParse.nErr) == (0))
		{
			pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, null, null, null, (ushort)(0), (int)(0));
			sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(nIncr));
			if ((pWInfo) != null)
			{
				sqlite3WhereEnd(pWInfo);
			}
		}

		sqlite3ExprDelete(db, pWhere);
		if ((iFkIfZero) != 0)
		{
			sqlite3VdbeJumpHereOrPopInst(v, (int)(iFkIfZero));
		}
	}
	public static int flattenSubquery(Parse pParse, Select p, int iFrom, int isAgg)
	{
		sbyte* zSavedAuthContext = pParse.zAuthContext;
		Select pParent;
		Select pSub;
		Select pSub1;
		SrcList pSrc;
		SrcList pSubSrc;
		int iParent = 0;
		int iNewParent = (int)(-1);
		int isLeftJoin = (int)(0);
		int i = 0;
		Expr pWhere;
		SrcItem pSubitem;
		sqlite3 db = pParse.db;
		Walker w = new Walker();
		int* aCsrMap = null;
		if ((((db).dbOptFlags & (0x00000001)) != 0))
			return (int)(0);
		pSrc = p.pSrc;
		pSubitem = pSrc.a[iFrom];
		iParent = (int)(pSubitem.iCursor);
		pSub = pSubitem.pSelect;
		if (((p.pWin) != null) || ((pSub.pWin) != null))
			return (int)(0);
		pSubSrc = pSub.pSrc;
		if (((pSub.pLimit) != null) && ((p.pLimit) != null))
			return (int)(0);
		if (((pSub.pLimit) != null) && ((pSub.pLimit.pRight) != null))
			return (int)(0);
		if (((p.selFlags & 0x0000100) != 0) && ((pSub.pLimit) != null))
		{
			return (int)(0);
		}

		if ((pSubSrc.nSrc) == (0))
			return (int)(0);
		if ((pSub.selFlags & 0x0000001) != 0)
			return (int)(0);
		if (((pSub.pLimit) != null) && (((pSrc.nSrc) > (1)) || ((isAgg) != 0)))
		{
			return (int)(0);
		}

		if (((p.pOrderBy) != null) && ((pSub.pOrderBy) != null))
		{
			return (int)(0);
		}

		if (((isAgg) != 0) && ((pSub.pOrderBy) != null))
			return (int)(0);
		if (((pSub.pLimit) != null) && ((p.pWhere) != null))
			return (int)(0);
		if (((pSub.pLimit) != null) && ((p.selFlags & 0x0000001) != 0))
		{
			return (int)(0);
		}

		if ((pSub.selFlags & (0x0002000)) != 0)
		{
			return (int)(0);
		}

		if ((pSubitem.fg.jointype & 0x0020) != 0)
		{
			isLeftJoin = (int)(1);
			if (((((pSubSrc.nSrc) > (1)) || ((isAgg) != 0)) || (((pSubSrc.a[0].pTab).eTabType) == (1))) || ((p.selFlags & 0x0000001) != 0))
			{
				return (int)(0);
			}
		}

		if ((pSub.pPrior) != null)
		{
			if ((pSub.pOrderBy) != null)
			{
				return (int)(0);
			}

			if ((((isAgg) != 0) || ((p.selFlags & 0x0000001) != 0)) || ((isLeftJoin) > (0)))
			{
				return (int)(0);
			}

			for (pSub1 = pSub; pSub1; pSub1 = pSub1.pPrior)
			{
				if (((((pSub1.selFlags & (0x0000001 | 0x0000008)) != 0) || (((pSub1.pPrior) != null) && (pSub1.op != 135))) || ((pSub1.pSrc.nSrc) < (1))) || ((pSub1.pWin) != null))
				{
					return (int)(0);
				}
			}

			if ((p.pOrderBy) != null)
			{
				int ii = 0;
				for (ii = (int)(0); (ii) < (p.pOrderBy.nExpr); ii++)
				{
					if ((p.pOrderBy.a[ii].u.x.iOrderByCol) == (0))
						return (int)(0);
				}
			}

			if ((p.selFlags & 0x0002000) != 0)
				return (int)(0);
			if ((pSrc.nSrc) > (1))
			{
				if ((pParse.nSelect) > (500))
					return (int)(0);
				aCsrMap = sqlite3DbMallocZero(db, (ulong)(((long)(pParse.nTab) + 1) * sizeof(int)));
				if ((aCsrMap) != null)
					aCsrMap[0] = (int)(pParse.nTab);
			}
		}

		pParse.zAuthContext = pSubitem.zName;
		sqlite3AuthCheck(pParse, (int)(21), null, null, null);
		pParse.zAuthContext = zSavedAuthContext;
		pSub1 = pSubitem.pSelect;
		sqlite3DbFree(db, pSubitem.zDatabase);
		sqlite3DbFree(db, pSubitem.zName);
		sqlite3DbFree(db, pSubitem.zAlias);
		pSubitem.zDatabase = null;
		pSubitem.zName = null;
		pSubitem.zAlias = null;
		pSubitem.pSelect = null;
		for (pSub = pSub.pPrior; pSub; pSub = pSub.pPrior)
		{
			Select pNew;
			ExprList pOrderBy = p.pOrderBy;
			Expr pLimit = p.pLimit;
			Select pPrior = p.pPrior;
			Table pItemTab = pSubitem.pTab;
			pSubitem.pTab = null;
			p.pOrderBy = null;
			p.pPrior = null;
			p.pLimit = null;
			pNew = sqlite3SelectDup(db, p, (int)(0));
			p.pLimit = pLimit;
			p.pOrderBy = pOrderBy;
			p.op = (byte)(135);
			pSubitem.pTab = pItemTab;
			if ((pNew) == (null))
			{
				p.pPrior = pPrior;
			}
			else
			{
				pNew.selId = (uint)(++pParse.nSelect);
				if (((aCsrMap) != null) && ((db.mallocFailed) == (0)))
				{
					renumberCursors(pParse, pNew, (int)(iFrom), aCsrMap);
				}

				pNew.pPrior = pPrior;
				if ((pPrior) != null)
					pPrior.pNext = pNew;
				pNew.pNext = p;
				p.pPrior = pNew;
			}
		}

		sqlite3DbFree(db, aCsrMap);
		if ((db.mallocFailed) != 0)
		{
			pSubitem.pSelect = pSub1;
			return (int)(1);
		}

		if ((pSubitem.pTab != null))
		{
			Table pTabToDel = pSubitem.pTab;
			if ((pTabToDel.nTabRef) == (1))
			{
				Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
				sqlite3ParserAddCleanup(pToplevel, sqlite3DeleteTable, pTabToDel);
			}
			else
			{
				pTabToDel.nTabRef--;
			}

			pSubitem.pTab = null;
		}

		pSub = pSub1;
		for (pParent = p; pParent; pParent = pParent.pPrior, pSub = pSub.pPrior)
		{
			int nSubSrc = 0;
			byte jointype = (byte)(0);
			pSubSrc = pSub.pSrc;
			nSubSrc = (int)(pSubSrc.nSrc);
			pSrc = pParent.pSrc;
			if ((pParent) == (p))
			{
				jointype = (byte)(pSubitem.fg.jointype);
			}

			if ((nSubSrc) > (1))
			{
				pSrc = sqlite3SrcListEnlarge(pParse, pSrc, (int)(nSubSrc - 1), (int)(iFrom + 1));
				if ((pSrc) == (null))
					break;
				pParent.pSrc = pSrc;
			}

			for (i = (int)(0); (i) < (nSubSrc); i++)
			{
				sqlite3IdListDelete(db, pSrc.a[i + iFrom].pUsing);
				pSrc.a[i + iFrom] = (SrcItem)(pSubSrc.a[i]);
				iNewParent = (int)(pSubSrc.a[i].iCursor);
				CRuntime.memset(pSubSrc.a[i], (int)(0), (ulong)(sizeof(SrcItem)));
			}

			pSrc.a[iFrom].fg.jointype = (byte)(jointype);
			if (((pSub.pOrderBy) != null) && ((pParent.selFlags & 0x0400000) == (0)))
			{
				ExprList pOrderBy = pSub.pOrderBy;
				for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
				{
					pOrderBy.a[i].u.x.iOrderByCol = (ushort)(0);
				}

				pParent.pOrderBy = pOrderBy;
				pSub.pOrderBy = null;
			}

			pWhere = pSub.pWhere;
			pSub.pWhere = null;
			if ((isLeftJoin) > (0))
			{
				sqlite3SetJoinExpr(pWhere, (int)(iNewParent));
			}

			if ((pWhere) != null)
			{
				if ((pParent.pWhere) != null)
				{
					pParent.pWhere = sqlite3PExpr(pParse, (int)(44), pWhere, pParent.pWhere);
				}
				else
				{
					pParent.pWhere = pWhere;
				}
			}

			if ((db.mallocFailed) == (0))
			{
				SubstContext x = new SubstContext();
				x.pParse = pParse;
				x.iTable = (int)(iParent);
				x.iNewTable = (int)(iNewParent);
				x.isLeftJoin = (int)(isLeftJoin);
				x.pEList = pSub.pEList;
				substSelect(x, pParent, (int)(0));
			}

			pParent.selFlags |= (uint)(pSub.selFlags & 0x0000100);
			if ((pSub.pLimit) != null)
			{
				pParent.pLimit = pSub.pLimit;
				pSub.pLimit = null;
			}

			for (i = (int)(0); (i) < (nSubSrc); i++)
			{
				recomputeColumnsUsed(pParent, pSrc.a[i + iFrom]);
			}
		}

		sqlite3AggInfoPersistWalkerInit(w, pParse);
		sqlite3WalkSelect(w, pSub1);
		sqlite3SelectDelete(db, pSub1);
		return (int)(1);
	}
	public static void generateColumnTypes(Parse pParse, SrcList pTabList, ExprList pEList)
	{
		Vdbe v = pParse.pVdbe;
		int i = 0;
		NameContext sNC = new NameContext();
		sNC.pSrcList = pTabList;
		sNC.pParse = pParse;
		sNC.pNext = null;
		for (i = (int)(0); (i) < (pEList.nExpr); i++)
		{
			Expr p = pEList.a[i].pExpr;
			sbyte* zType;
			zType = columnTypeImpl(sNC, p);
			sqlite3VdbeSetColName(v, (int)(i), (int)(1), zType, ((Void(Void * ))(-1)));
		}
	}
	public static int generateOutputSubroutine(Parse pParse, Select p, SelectDest pIn, SelectDest pDest, int regReturn, int regPrev, KeyInfo pKeyInfo, int iBreak)
	{
		Vdbe v = pParse.pVdbe;
		int iContinue = 0;
		int addr = 0;
		addr = (int)(sqlite3VdbeCurrentAddr(v));
		iContinue = (int)(sqlite3VdbeMakeLabel(pParse));
		if ((regPrev) != 0)
		{
			int addr1 = 0;
			int addr2 = 0;
			addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regPrev)));
			addr2 = (int)(sqlite3VdbeAddOp4(v, (int)(89), (int)(pIn.iSdst), (int)(regPrev + 1), (int)(pIn.nSdst), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9)));
			sqlite3VdbeAddOp3(v, (int)(16), (int)(addr2 + 2), (int)(iContinue), (int)(addr2 + 2));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			sqlite3VdbeAddOp3(v, (int)(79), (int)(pIn.iSdst), (int)(regPrev + 1), (int)(pIn.nSdst - 1));
			sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regPrev));
		}

		if ((pParse.db.mallocFailed) != 0)
			return (int)(0);
		codeOffset(v, (int)(p.iOffset), (int)(iContinue));
		switch (pDest.eDest)
		{
			case 12:
				{
					int r1 = (int)(sqlite3GetTempReg(pParse));
					int r2 = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(pIn.iSdst), (int)(pIn.nSdst), (int)(r1));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(pDest.iSDParm), (int)(r2));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(pDest.iSDParm), (int)(r1), (int)(r2));
					sqlite3VdbeChangeP5(v, (ushort)(0x08));
					sqlite3ReleaseTempReg(pParse, (int)(r2));
					sqlite3ReleaseTempReg(pParse, (int)(r1));
					break;
				}

			case 11:
				{
					int r1 = 0;
					r1 = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp4(v, (int)(96), (int)(pIn.iSdst), (int)(pIn.nSdst), (int)(r1), pDest.zAffSdst, (int)(pIn.nSdst));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(pDest.iSDParm), (int)(r1), (int)(pIn.iSdst), (int)(pIn.nSdst));
					sqlite3ReleaseTempReg(pParse, (int)(r1));
					break;
				}

			case 10:
				{
					sqlite3ExprCodeMove(pParse, (int)(pIn.iSdst), (int)(pDest.iSDParm), (int)(pIn.nSdst));
					break;
				}

			case 13:
				{
					if ((pDest.iSdst) == (0))
					{
						pDest.iSdst = (int)(sqlite3GetTempRange(pParse, (int)(pIn.nSdst)));
						pDest.nSdst = (int)(pIn.nSdst);
					}

					sqlite3ExprCodeMove(pParse, (int)(pIn.iSdst), (int)(pDest.iSdst), (int)(pIn.nSdst));
					sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
					break;
				}

			default:
				{
					sqlite3VdbeAddOp2(v, (int)(83), (int)(pIn.iSdst), (int)(pIn.nSdst));
					break;
				}
		}

		if ((p.iLimit) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(60), (int)(p.iLimit), (int)(iBreak));
		}

		sqlite3VdbeResolveLabel(v, (int)(iContinue));
		sqlite3VdbeAddOp1(v, (int)(67), (int)(regReturn));
		return (int)(addr);
	}
	public static void generateSortTail(Parse pParse, Select p, SortCtx pSort, int nColumn, SelectDest pDest)
	{
		Vdbe v = pParse.pVdbe;
		int addrBreak = (int)(pSort.labelDone);
		int addrContinue = (int)(sqlite3VdbeMakeLabel(pParse));
		int addr = 0;
		int addrOnce = (int)(0);
		int iTab = 0;
		ExprList pOrderBy = pSort.pOrderBy;
		int eDest = (int)(pDest.eDest);
		int iParm = (int)(pDest.iSDParm);
		int regRow = 0;
		int regRowid = 0;
		int iCol = 0;
		int nKey = 0;
		int iSortTab = 0;
		int i = 0;
		int bSeq = 0;
		int nRefKey = (int)(0);
		ExprList_item* aOutEx = p.pEList.a;
		if ((pSort.labelBkOut) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(12), (int)(pSort.regReturn), (int)(pSort.labelBkOut));
			sqlite3VdbeGoto(v, (int)(addrBreak));
			sqlite3VdbeResolveLabel(v, (int)(pSort.labelBkOut));
		}

		iTab = (int)(pSort.iECursor);
		if ((((eDest) == (9)) || ((eDest) == (13))) || ((eDest) == (10)))
		{
			if (((eDest) == (10)) && ((p.iOffset) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pDest.iSdst));
			}

			regRowid = (int)(0);
			regRow = (int)(pDest.iSdst);
		}
		else
		{
			regRowid = (int)(sqlite3GetTempReg(pParse));
			if (((eDest) == (12)) || ((eDest) == (14)))
			{
				regRow = (int)(sqlite3GetTempReg(pParse));
				nColumn = (int)(0);
			}
			else
			{
				regRow = (int)(sqlite3GetTempRange(pParse, (int)(nColumn)));
			}
		}

		nKey = (int)(pOrderBy.nExpr - pSort.nOBSat);
		if ((pSort.sortFlags & 0x01) != 0)
		{
			int regSortOut = (int)(++pParse.nMem);
			iSortTab = (int)(pParse.nTab++);
			if ((pSort.labelBkOut) != 0)
			{
				addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			}

			sqlite3VdbeAddOp3(v, (int)(120), (int)(iSortTab), (int)(regSortOut), (int)(nKey + 1 + nColumn + nRefKey));
			if ((addrOnce) != 0)
				sqlite3VdbeJumpHere(v, (int)(addrOnce));
			addr = (int)(1 + sqlite3VdbeAddOp2(v, (int)(36), (int)(iTab), (int)(addrBreak)));
			codeOffset(v, (int)(p.iOffset), (int)(addrContinue));
			sqlite3VdbeAddOp3(v, (int)(132), (int)(iTab), (int)(regSortOut), (int)(iSortTab));
			bSeq = (int)(0);
		}
		else
		{
			addr = (int)(1 + sqlite3VdbeAddOp2(v, (int)(37), (int)(iTab), (int)(addrBreak)));
			codeOffset(v, (int)(p.iOffset), (int)(addrContinue));
			iSortTab = (int)(iTab);
			bSeq = (int)(1);
		}

		for (i = (int)(0), iCol = (int)(nKey + bSeq - 1); (i) < (nColumn); i++)
		{
			if ((aOutEx[i].u.x.iOrderByCol) == (0))
				iCol++;
		}

		for (i = (int)(nColumn - 1); (i) >= (0); i--)
		{
			{
				int iRead = 0;
				if ((aOutEx[i].u.x.iOrderByCol) != 0)
				{
					iRead = (int)(aOutEx[i].u.x.iOrderByCol - 1);
				}
				else
				{
					iRead = (int)(iCol--);
				}

				sqlite3VdbeAddOp3(v, (int)(93), (int)(iSortTab), (int)(iRead), (int)(regRow + i));
			}
		}

		switch (eDest)
		{
			case 14:
			case 12:
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iSortTab), (int)(nKey + bSeq), (int)(regRow));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(iParm), (int)(regRowid));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(regRow), (int)(regRowid));
					sqlite3VdbeChangeP5(v, (ushort)(0x08));
					break;
				}

			case 11:
				{
					sqlite3VdbeAddOp4(v, (int)(96), (int)(regRow), (int)(nColumn), (int)(regRowid), pDest.zAffSdst, (int)(nColumn));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(regRowid), (int)(regRow), (int)(nColumn));
					break;
				}

			case 10:
				{
					break;
				}

			case 15:
				{
					int i2 = (int)(pDest.iSDParm2);
					int r1 = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(regRow + ((i2) < (0))), (int)(nColumn - ((i2) < (0))), (int)(r1));
					if ((i2) < (0))
					{
						sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(regRow));
					}
					else
					{
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regRow), (int)(i2));
					}

					break;
				}

			default:
				{
					if ((eDest) == (9))
					{
						sqlite3VdbeAddOp2(v, (int)(83), (int)(pDest.iSdst), (int)(nColumn));
					}
					else
					{
						sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
					}

					break;
				}
		}

		if ((regRowid) != 0)
		{
			if ((eDest) == (11))
			{
				sqlite3ReleaseTempRange(pParse, (int)(regRow), (int)(nColumn));
			}
			else
			{
				sqlite3ReleaseTempReg(pParse, (int)(regRow));
			}

			sqlite3ReleaseTempReg(pParse, (int)(regRowid));
		}

		sqlite3VdbeResolveLabel(v, (int)(addrContinue));
		if ((pSort.sortFlags & 0x01) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(3), (int)(iTab), (int)(addr));
		}
		else
		{
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addr));
		}

		if ((pSort.regReturn) != 0)
			sqlite3VdbeAddOp1(v, (int)(67), (int)(pSort.regReturn));
		sqlite3VdbeResolveLabel(v, (int)(addrBreak));
	}
	public static void generateWithRecursiveQuery(Parse pParse, Select p, SelectDest pDest)
	{
		SrcList pSrc = p.pSrc;
		int nCol = (int)(p.pEList.nExpr);
		Vdbe v = pParse.pVdbe;
		Select pSetup;
		Select pFirstRec;
		int addrTop = 0;
		int addrCont = 0; int addrBreak = 0;
		int iCurrent = (int)(0);
		int regCurrent = 0;
		int iQueue = 0;
		int iDistinct = (int)(0);
		int eDest = (int)(8);
		SelectDest destQueue = new SelectDest();
		int i = 0;
		int rc = 0;
		ExprList pOrderBy;
		Expr pLimit;
		int regLimit = 0; int regOffset = 0;
		if ((p.pWin) != null)
		{
			sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
			return;
		}

		if ((sqlite3AuthCheck(pParse, (int)(33), null, null, null)) != 0)
			return;
		addrBreak = (int)(sqlite3VdbeMakeLabel(pParse));
		p.nSelectRow = (short)(320);
		computeLimitRegisters(pParse, p, (int)(addrBreak));
		pLimit = p.pLimit;
		regLimit = (int)(p.iLimit);
		regOffset = (int)(p.iOffset);
		p.pLimit = null;
		p.iLimit = (int)(p.iOffset = (int)(0));
		pOrderBy = p.pOrderBy;
		for (i = (int)(0); ((i) < (pSrc.nSrc)); i++)
		{
			if ((pSrc.a[i].fg.isRecursive) != 0)
			{
				iCurrent = (int)(pSrc.a[i].iCursor);
				break;
			}
		}

		iQueue = (int)(pParse.nTab++);
		if ((p.op) == (134))
		{
			eDest = (int)(pOrderBy ? 6 : 5);
			iDistinct = (int)(pParse.nTab++);
		}
		else
		{
			eDest = (int)(pOrderBy ? 7 : 8);
		}

		sqlite3SelectDestInit(destQueue, (int)(eDest), (int)(iQueue));
		regCurrent = (int)(++pParse.nMem);
		sqlite3VdbeAddOp3(v, (int)(120), (int)(iCurrent), (int)(regCurrent), (int)(nCol));
		if ((pOrderBy) != null)
		{
			KeyInfo pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, (int)(1));
			sqlite3VdbeAddOp4(v, (int)(116), (int)(iQueue), (int)(pOrderBy.nExpr + 2), (int)(0), (sbyte*)(pKeyInfo), (int)(-9));
			destQueue.pOrderBy = pOrderBy;
		}
		else
		{
			sqlite3VdbeAddOp2(v, (int)(116), (int)(iQueue), (int)(nCol));
		}

		if ((iDistinct) != 0)
		{
			p.addrOpenEphm[0] = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iDistinct), (int)(0)));
			p.selFlags |= (uint)(0x0000020);
		}

		p.pOrderBy = null;
		for (pFirstRec = p; (pFirstRec != null); pFirstRec = pFirstRec.pPrior)
		{
			if ((pFirstRec.selFlags & 0x0000008) != 0)
			{
				sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
				goto end_of_recursive_query;
			}

			pFirstRec.op = (byte)(135);
			if ((pFirstRec.pPrior.selFlags & 0x0002000) == (0))
				break;
		}

		pSetup = pFirstRec.pPrior;
		pSetup.pNext = null;
		sqlite3VdbeExplain(pParse, (byte)(1), "SETUP");
		rc = (int)(sqlite3Select(pParse, pSetup, destQueue));
		pSetup.pNext = p;
		if ((rc) != 0)
			goto end_of_recursive_query;
		addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iQueue), (int)(addrBreak)));
		sqlite3VdbeAddOp1(v, (int)(135), (int)(iCurrent));
		if ((pOrderBy) != null)
		{
			sqlite3VdbeAddOp3(v, (int)(93), (int)(iQueue), (int)(pOrderBy.nExpr + 1), (int)(regCurrent));
		}
		else
		{
			sqlite3VdbeAddOp2(v, (int)(133), (int)(iQueue), (int)(regCurrent));
		}

		sqlite3VdbeAddOp1(v, (int)(129), (int)(iQueue));
		addrCont = (int)(sqlite3VdbeMakeLabel(pParse));
		codeOffset(v, (int)(regOffset), (int)(addrCont));
		selectInnerLoop(pParse, p, (int)(iCurrent), null, null, pDest, (int)(addrCont), (int)(addrBreak));
		if ((regLimit) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(60), (int)(regLimit), (int)(addrBreak));
		}

		sqlite3VdbeResolveLabel(v, (int)(addrCont));
		pFirstRec.pPrior = null;
		sqlite3VdbeExplain(pParse, (byte)(1), "RECURSIVE STEP");
		sqlite3Select(pParse, p, destQueue);
		pFirstRec.pPrior = pSetup;
		sqlite3VdbeGoto(v, (int)(addrTop));
		sqlite3VdbeResolveLabel(v, (int)(addrBreak));
	end_of_recursive_query:
		; sqlite3ExprListDelete(pParse.db, p.pOrderBy);
		p.pOrderBy = pOrderBy;
		p.pLimit = pLimit;
		return;
	}
	public static TriggerPrg getRowTrigger(Parse pParse, Trigger pTrigger, Table pTab, int orconf)
	{
		Parse pRoot = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		TriggerPrg pPrg;
		for (pPrg = pRoot.pTriggerPrg; ((pPrg) != null) && ((pPrg.pTrigger != pTrigger) || (pPrg.orconf != orconf)); pPrg = pPrg.pNext)
		{
		}

		if (pPrg == null)
		{
			pPrg = codeRowTrigger(pParse, pTrigger, pTab, (int)(orconf));
			pParse.db.errByteOffset = (int)(-1);
		}

		return pPrg;
	}
	public static void havingToWhere(Parse pParse, Select p)
	{
		Walker sWalker = new Walker();
		CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
		sWalker.pParse = pParse;
		sWalker.xExprCallback = havingToWhereExprCb;
		sWalker.u.pSelect = p;
		sqlite3WalkExpr(sWalker, p.pHaving);
	}
	public static void innerLoopLoadRow(Parse pParse, Select pSelect, RowLoadInfo* pInfo)
	{
		sqlite3ExprCodeExprList(pParse, pSelect.pEList, (int)(pInfo->regResult), (int)(0), (byte)(pInfo->ecelFlags));
	}
	public static int invalidateTempStorage(Parse pParse)
	{
		sqlite3 db = pParse.db;
		if (db.aDb[1].pBt != null)
		{
			if ((db.autoCommit == 0) || (sqlite3BtreeTxnState(db.aDb[1].pBt) != 0))
			{
				sqlite3ErrorMsg(pParse, "temporary storage cannot be changed from within a transaction");
				return (int)(1);
			}

			sqlite3BtreeClose(db.aDb[1].pBt);
			db.aDb[1].pBt = null;
			sqlite3ResetAllSchemasOfConnection(db);
		}

		return (int)(0);
	}
	public static int isAlterableTable(Parse pParse, Table pTab)
	{
		if ((((0) == (sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7)))) || ((pTab.tabFlags & 0x00008000) != 0)) || (((pTab.tabFlags & 0x00001000) != 0) && ((sqlite3ReadOnlyShadowTables(pParse.db)) != 0)))
		{
			sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab.zName);
			return (int)(1);
		}

		return (int)(0);
	}
	public static int isAsteriskTerm(Parse pParse, Expr pTerm)
	{
		if ((pTerm.op) == (180))
			return (int)(1);
		if (pTerm.op != 141)
			return (int)(0);
		if (pTerm.pRight.op != 180)
			return (int)(0);
		sqlite3ErrorMsg(pParse, "RETURNING may not use \"TABLE.*\" wildcards");
		return (int)(1);
	}
	public static int isDistinctRedundant(Parse pParse, SrcList pTabList, WhereClause pWC, ExprList pDistinct)
	{
		Table pTab;
		Index pIdx;
		int i = 0;
		int iBase = 0;
		if (pTabList.nSrc != 1)
			return (int)(0);
		iBase = (int)(pTabList.a[0].iCursor);
		pTab = pTabList.a[0].pTab;
		for (i = (int)(0); (i) < (pDistinct.nExpr); i++)
		{
			Expr p = sqlite3ExprSkipCollateAndLikely(pDistinct.a[i].pExpr);
			if (((p) == (null)))
				continue;
			if ((p.op != 167) && (p.op != 169))
				continue;
			if (((p.iTable) == (iBase)) && ((p.iColumn) < (0)))
				return (int)(1);
		}

		for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
		{
			if (!((pIdx).onError != 0))
				continue;
			if ((pIdx.pPartIdxWhere) != null)
				continue;
			for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
			{
				if ((null) == (sqlite3WhereFindTerm(pWC, (int)(iBase), (int)(i), (ulong)(~(ulong)(0)), (uint)(0x0002), pIdx)))
				{
					if ((findIndexCol(pParse, pDistinct, (int)(iBase), pIdx, (int)(i))) < (0))
						break;
					if ((indexColumnNotNull(pIdx, (int)(i))) == (0))
						break;
				}
			}

			if ((i) == (pIdx.nKeyCol))
			{
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static int isLikeOrGlob(Parse pParse, Expr pExpr, Expr ppPrefix, int* pisComplete, int* pnoCase)
	{
		byte* z = null;
		Expr pRight; Expr pLeft;
		ExprList pList;
		byte c = 0;
		int cnt = 0;
		byte* wc = stackalloc byte[4];
		sqlite3 db = pParse.db;
		sqlite3_value pVal = null;
		int op = 0;
		int rc = 0;
		if (sqlite3IsLikeFunction(db, pExpr, pnoCase, (sbyte*)(wc)) == 0)
		{
			return (int)(0);
		}

		pList = pExpr.x.pList;
		pLeft = pList.a[1].pExpr;
		pRight = sqlite3ExprSkipCollate(pList.a[0].pExpr);
		op = (int)(pRight.op);
		if (((op) == (156)) && ((db.flags & 0x00800000) == (0)))
		{
			Vdbe pReprepare = pParse.pReprepare;
			int iCol = (int)(pRight.iColumn);
			pVal = sqlite3VdbeGetBoundValue(pReprepare, (int)(iCol), (byte)(0x41));
			if (((pVal) != null) && ((sqlite3_value_type(pVal)) == (3)))
			{
				z = sqlite3_value_text(pVal);
			}

			sqlite3VdbeSetVarmask(pParse.pVdbe, (int)(iCol));
		}
		else if ((op) == (117))
		{
			z = (byte*)(pRight.u.zToken);
		}

		if ((z) != null)
		{
			cnt = (int)(0);
			while (((((c = (byte)(z[cnt])) != 0) && (c != wc[0])) && (c != wc[1])) && (c != wc[2]))
			{
				cnt++;
				if (((c) == (wc[3])) && (z[cnt] != 0))
					cnt++;
			}

			if (((cnt != 0) && (255 != z[cnt - 1])) && (((cnt) > (1)) || (z[0] != wc[3])))
			{
				Expr pPrefix;
				*pisComplete = (int)(((c) == (wc[0])) && ((z[cnt + 1]) == (0)) ? 1 : 0);
				pPrefix = sqlite3Expr(db, (int)(117), (sbyte*)(z));
				if ((pPrefix) != null)
				{
					int iFrom = 0;
					int iTo = 0;
					sbyte* zNew;
					zNew = pPrefix.u.zToken;
					zNew[cnt] = (sbyte)(0);
					for (iFrom = (int)(iTo = (int)(0)); (iFrom) < (cnt); iFrom++)
					{
						if ((zNew[iFrom]) == (wc[3]))
							iFrom++;
						zNew[iTo++] = (sbyte)(zNew[iFrom]);
					}

					zNew[iTo] = (sbyte)(0);
					if (((pLeft.op != 167) || (sqlite3ExprAffinity(pLeft) != 0x42)) || ((((((pLeft).flags & (0x1000000 | 0x2000000)) == (0)) != 0) && ((pLeft.y.pTab) != null)) && (((pLeft.y.pTab).eTabType) == (1))))
					{
						int isNum = 0;
						double rDummy = 0;
						isNum = (int)(sqlite3AtoF(zNew, &rDummy, (int)(iTo), (byte)(1)));
						if ((isNum) <= (0))
						{
							if (((iTo) == (1)) && ((zNew[0]) == (45)))
							{
								isNum = (int)(+1);
							}
							else
							{
								zNew[iTo - 1]++;
								isNum = (int)(sqlite3AtoF(zNew, &rDummy, (int)(iTo), (byte)(1)));
								zNew[iTo - 1]--;
							}
						}

						if ((isNum) > (0))
						{
							sqlite3ExprDelete(db, pPrefix);
							sqlite3ValueFree(pVal);
							return (int)(0);
						}
					}
				}

				ppPrefix = pPrefix;
				if ((op) == (156))
				{
					Vdbe v = pParse.pVdbe;
					sqlite3VdbeSetVarmask(v, (int)(pRight.iColumn));
					if (((*pisComplete) != 0) && ((pRight.u.zToken[1]) != 0))
					{
						int r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3ExprCodeTarget(pParse, pRight, (int)(r1));
						sqlite3VdbeChangeP3(v, (int)(sqlite3VdbeCurrentAddr(v) - 1), (int)(0));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
					}
				}
			}
			else
			{
				z = null;
			}
		}

		rc = (int)(z != null);
		sqlite3ValueFree(pVal);
		return (int)(rc);
	}
	public static int isRealTable(Parse pParse, Table pTab, int bDrop)
	{
		sbyte* zType = null;
		if ((((pTab).eTabType) == (2)))
		{
			zType = "view";
		}

		if ((((pTab).eTabType) == (1)))
		{
			zType = "virtual table";
		}

		if ((zType) != null)
		{
			sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"", ((bDrop) != 0 ? "drop column from" : "rename columns of"), zType, pTab.zName);
			return (int)(1);
		}

		return (int)(0);
	}
	public static int isSetNullAction(Parse pParse, FKey pFKey)
	{
		Parse pTop = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		if ((pTop.pTriggerPrg) != null)
		{
			Trigger p = pTop.pTriggerPrg.pTrigger;
			if ((((p) == (pFKey.apTrigger[0])) && ((pFKey.aAction[0]) == (8))) || (((p) == (pFKey.apTrigger[1])) && ((pFKey.aAction[1]) == (8))))
			{
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static void loadAnalysis(Parse pParse, int iDb)
	{
		Vdbe v = sqlite3GetVdbe(pParse);
		if ((v) != null)
		{
			sqlite3VdbeAddOp1(v, (int)(149), (int)(iDb));
		}
	}
	public static void lockTable(Parse pParse, int iDb, uint iTab, byte isWriteLock, sbyte* zName)
	{
		Parse pToplevel;
		int i = 0;
		int nBytes = 0;
		TableLock* p;
		pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		for (i = (int)(0); (i) < (pToplevel.nTableLock); i++)
		{
			p = &pToplevel.aTableLock[i];
			if (((p->iDb) == (iDb)) && ((p->iTab) == (iTab)))
			{
				p->isWriteLock = (byte)(((p->isWriteLock) != 0) || ((isWriteLock) != 0));
				return;
			}
		}

		nBytes = (int)(sizeof(TableLock) * (pToplevel.nTableLock + 1));
		pToplevel.aTableLock = sqlite3DbReallocOrFree(pToplevel.db, pToplevel.aTableLock, (ulong)(nBytes));
		if ((pToplevel.aTableLock) != null)
		{
			p = &pToplevel.aTableLock[pToplevel.nTableLock++];
			p->iDb = (int)(iDb);
			p->iTab = (uint)(iTab);
			p->isWriteLock = (byte)(isWriteLock);
			p->zLockName = zName;
		}
		else
		{
			pToplevel.nTableLock = (int)(0);
			sqlite3OomFault(pToplevel.db);
		}
	}
	public static int lookupName(Parse pParse, sbyte* zDb, sbyte* zTab, sbyte* zCol, NameContext pNC, Expr pExpr)
	{
		int i = 0; int j = 0;
		int cnt = (int)(0);
		int cntTab = (int)(0);
		int nSubquery = (int)(0);
		sqlite3 db = pParse.db;
		SrcItem pItem;
		SrcItem pMatch = null;
		NameContext pTopNC = pNC;
		Schema pSchema = null;
		int eNewExprOp = (int)(167);
		Table pTab = null;
		Column* pCol;
		pExpr.iTable = (int)(-1);
		if ((zDb) != null)
		{
			if ((pNC.ncFlags & (0x000002 | 0x000004)) != 0)
			{
				zDb = null;
			}
			else
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((sqlite3StrICmp(db.aDb[i].zDbSName, zDb)) == (0))
					{
						pSchema = db.aDb[i].pSchema;
						break;
					}
				}

				if (((i) == (db.nDb)) && ((sqlite3StrICmp("main", zDb)) == (0)))
				{
					pSchema = db.aDb[0].pSchema;
					zDb = db.aDb[0].zDbSName;
				}
			}
		}

		do
		{
			ExprList pEList;
			SrcList pSrcList = pNC.pSrcList;
			if ((pSrcList) != null)
			{
				for (i = (int)(0), pItem = pSrcList.a; (i) < (pSrcList.nSrc); i++, pItem++)
				{
					byte hCol = 0;
					pTab = pItem.pTab;
					if (((pItem.pSelect) != null) && ((pItem.pSelect.selFlags & 0x0000800) != 0))
					{
						int hit = (int)(0);
						pEList = pItem.pSelect.pEList;
						for (j = (int)(0); (j) < (pEList.nExpr); j++)
						{
							if ((sqlite3MatchEName(&pEList.a[j], zCol, zTab, zDb)) != 0)
							{
								cnt++;
								cntTab = (int)(2);
								pMatch = pItem;
								pExpr.iColumn = (short)(j);
								hit = (int)(1);
							}
						}

						if (((hit) != 0) || ((zTab) == (null)))
							continue;
					}

					if ((zDb) != null)
					{
						if (pTab.pSchema != pSchema)
							continue;
						if (((pSchema) == (null)) && (CRuntime.strcmp(zDb, "*") != 0))
							continue;
					}

					if ((zTab) != null)
					{
						sbyte* zTabName = (pItem.zAlias) != 0 ? pItem.zAlias : pTab.zName;
						if (sqlite3StrICmp(zTabName, zTab) != 0)
						{
							continue;
						}

						if (((pParse.eParseMode) >= (2)) && ((pItem.zAlias) != null))
						{
							sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr.y.pTab));
						}
					}

					hCol = (byte)(sqlite3StrIHash(zCol));
					for (j = (int)(0), pCol = pTab.aCol; (j) < (pTab.nCol); j++, pCol++)
					{
						if (((pCol->hName) == (hCol)) && ((sqlite3StrICmp(pCol->zCnName, zCol)) == (0)))
						{
							if ((cnt) == (1))
							{
								if ((pItem.fg.jointype & 0x0004) != 0)
									continue;
								if ((nameInUsingClause(pItem.pUsing, zCol)) != 0)
									continue;
							}

							cnt++;
							pMatch = pItem;
							pExpr.iColumn = (short)((j) == (pTab.iPKey) ? -1 : (short)(j));
							break;
						}
					}

					if (((0) == (cnt)) && (((pTab).tabFlags & 0x00000200) == (0)))
					{
						cntTab++;
						pMatch = pItem;
					}
				}

				if ((pMatch) != null)
				{
					pExpr.iTable = (int)(pMatch.iCursor);
					pExpr.y.pTab = pMatch.pTab;
					if ((pMatch.fg.jointype & 0x0008) != 0)
					{
						(pExpr).flags |= (uint)(0x100000);
					}

					pSchema = pExpr.y.pTab.pSchema;
				}
			}

			if (((cnt) == (0)) && ((zDb) == (null)))
			{
				pTab = null;
				if (pParse.pTriggerTab != null)
				{
					int op = (int)(pParse.eTriggerOp);
					if ((pParse.bReturning) != 0)
					{
						if (((pNC.ncFlags & 0x000400) != 0) && (((zTab) == (null)) || ((sqlite3StrICmp(zTab, pParse.pTriggerTab.zName)) == (0))))
						{
							pExpr.iTable = (int)(op != 128);
							pTab = pParse.pTriggerTab;
						}
					}
					else if (((op != 128) && ((zTab) != null)) && ((sqlite3StrICmp("new", zTab)) == (0)))
					{
						pExpr.iTable = (int)(1);
						pTab = pParse.pTriggerTab;
					}
					else if (((op != 127) && ((zTab) != null)) && ((sqlite3StrICmp("old", zTab)) == (0)))
					{
						pExpr.iTable = (int)(0);
						pTab = pParse.pTriggerTab;
					}
				}

				if (((pNC.ncFlags & 0x000200) != 0) && (zTab != null))
				{
					Upsert pUpsert = pNC.uNC.pUpsert;
					if (((pUpsert) != null) && ((sqlite3StrICmp("excluded", zTab)) == (0)))
					{
						pTab = pUpsert.pUpsertSrc.a[0].pTab;
						pExpr.iTable = (int)(2);
					}
				}

				if ((pTab) != null)
				{
					int iCol = 0;
					byte hCol = (byte)(sqlite3StrIHash(zCol));
					pSchema = pTab.pSchema;
					cntTab++;
					for (iCol = (int)(0), pCol = pTab.aCol; (iCol) < (pTab.nCol); iCol++, pCol++)
					{
						if (((pCol->hName) == (hCol)) && ((sqlite3StrICmp(pCol->zCnName, zCol)) == (0)))
						{
							if ((iCol) == (pTab.iPKey))
							{
								iCol = (int)(-1);
							}

							break;
						}
					}

					if ((((iCol) >= (pTab.nCol)) && ((sqlite3IsRowid(zCol)) != 0)) && (((pTab).tabFlags & 0x00000200) == (0)))
					{
						iCol = (int)(-1);
					}

					if ((iCol) < (pTab.nCol))
					{
						cnt++;
						pMatch = null;
						if ((pExpr.iTable) == (2))
						{
							if (((pParse.eParseMode) >= (2)))
							{
								pExpr.iColumn = (short)(iCol);
								pExpr.y.pTab = pTab;
								eNewExprOp = (int)(167);
							}
							else
							{
								pExpr.iTable = (int)(pNC.uNC.pUpsert.regData + sqlite3TableColumnToStorage(pTab, (short)(iCol)));
								eNewExprOp = (int)(176);
							}
						}
						else
						{
							pExpr.y.pTab = pTab;
							if ((pParse.bReturning) != 0)
							{
								eNewExprOp = (int)(176);
								pExpr.op2 = (byte)(167);
								pExpr.iTable = (int)(pNC.uNC.iBaseReg + (pTab.nCol + 1) * pExpr.iTable + sqlite3TableColumnToStorage(pTab, (short)(iCol)) + 1);
							}
							else
							{
								pExpr.iColumn = ((short)(iCol));
								eNewExprOp = (int)(77);
								if ((iCol) < (0))
								{
									pExpr.affExpr = (sbyte)(0x44);
								}
								else if ((pExpr.iTable) == (0))
								{
									pParse.oldmask |= (uint)((iCol) >= (32) ? 0xffffffff : (((uint)(1)) << iCol));
								}
								else
								{
									pParse.newmask |= (uint)((iCol) >= (32) ? 0xffffffff : (((uint)(1)) << iCol));
								}
							}
						}
					}
				}
			}

			if (((((((cnt) == (0)) && ((cntTab) == (1))) && ((pMatch) != null)) && ((pNC.ncFlags & (0x000020 | 0x000008)) == (0))) && ((sqlite3IsRowid(zCol)) != 0)) && ((((pMatch.pTab).tabFlags & 0x00000200) == (0)) != 0))
			{
				cnt = (int)(1);
				pExpr.iColumn = (short)(-1);
				pExpr.affExpr = (sbyte)(0x44);
			}

			if ((((cnt) == (0)) && ((pNC.ncFlags & 0x000080) != 0)) && ((zTab) == (null)))
			{
				pEList = pNC.uNC.pEList;
				for (j = (int)(0); (j) < (pEList.nExpr); j++)
				{
					sbyte* zAs = pEList.a[j].zEName;
					if (((pEList.a[j].eEName) == (0)) && ((sqlite3_stricmp(zAs, zCol)) == (0)))
					{
						Expr pOrig;
						pOrig = pEList.a[j].pExpr;
						if (((pNC.ncFlags & 0x000001) == (0)) && (((pOrig).flags & (0x000010)) != 0))
						{
							sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
							return (int)(2);
						}

						if ((((pOrig).flags & (0x008000)) != 0) && (((pNC.ncFlags & 0x004000) == (0)) || (pNC != pTopNC)))
						{
							sqlite3ErrorMsg(pParse, "misuse of aliased window function %s", zAs);
							return (int)(2);
						}

						if (sqlite3ExprVectorSize(pOrig) != 1)
						{
							sqlite3ErrorMsg(pParse, "row value misused");
							return (int)(2);
						}

						resolveAlias(pParse, pEList, (int)(j), pExpr, (int)(nSubquery));
						cnt = (int)(1);
						pMatch = null;
						if (((pParse.eParseMode) >= (2)))
						{
							sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr));
						}

						goto lookupname_end;
					}
				}
			}

			if ((cnt) != 0)
				break;
			pNC = pNC.pNext;
			nSubquery++;
		}
		while ((pNC) != null);
		if (((cnt) == (0)) && ((zTab) == (null)))
		{
			if ((((pExpr).flags & (0x000040)) != 0) && ((areDoubleQuotedStringsEnabled(db, pTopNC)) != 0))
			{
				sqlite3_log((int)(28), "double-quoted string literal: \"%w\"", zCol);
				pExpr.op = (byte)(117);
				CRuntime.memset(&pExpr.y, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18103 : 3)) ) )
            ;
				return (int)(1);
			}

			if ((sqlite3ExprIdToTrueFalse(pExpr)) != 0)
			{
				return (int)(1);
			}
		}

		if (cnt != 1)
		{
			sbyte* zErr;
			zErr = (cnt) == (0) ? "no such column" : "ambiguous column name";
			if ((zDb) != null)
			{
				sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
			}
			else if ((zTab) != null)
			{
				sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
			}
			else
			{
				sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
			}

			sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
			pParse.checkSchema = (byte)(1);
			pTopNC.nNcErr++;
		}

		if (((pExpr.iColumn) >= (0)) && (pMatch != null))
		{
			pMatch.colUsed |= (ulong)(sqlite3ExprColUsed(pExpr));
		}

		if (!(((pExpr).flags & (0x004000 | 0x800000)) != 0))
		{
			sqlite3ExprDelete(db, pExpr.pLeft);
			pExpr.pLeft = null;
			sqlite3ExprDelete(db, pExpr.pRight);
			pExpr.pRight = null;
		}

		pExpr.op = (byte)(eNewExprOp);
		(pExpr).flags |= (uint)(0x800000);
	lookupname_end:
		; if ((cnt) == (1)) { if (((pParse.db.xAuth) != null) && (((pExpr.op) == (167)) || ((pExpr.op) == (77)))) { sqlite3AuthRead(pParse, pExpr, pSchema, pNC.pSrcList); } for (; ; ) { pTopNC.nRef++; if ((pTopNC) == (pNC)) break; pTopNC = pTopNC.pNext; } return (int)(1); } else { return (int)(2); }
	}
	public static void makeColumnPartOfPrimaryKey(Parse pParse, Column* pCol)
	{
		pCol->colFlags |= (ushort)(0x0001);
		if ((pCol->colFlags & 0x0060) != 0)
		{
			sqlite3ErrorMsg(pParse, "generated columns cannot be part of the PRIMARY KEY");
		}
	}
	public static int makeSorterRecord(Parse pParse, SortCtx pSort, Select pSelect, int regBase, int nBase)
	{
		int nOBSat = (int)(pSort.nOBSat);
		Vdbe v = pParse.pVdbe;
		int regOut = (int)(++pParse.nMem);
		if ((pSort.pDeferredRowLoad) != null)
		{
			innerLoopLoadRow(pParse, pSelect, pSort.pDeferredRowLoad);
		}

		sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase + nOBSat), (int)(nBase - nOBSat), (int)(regOut));
		return (int)(regOut);
	}
	public static int multiSelect(Parse pParse, Select p, SelectDest pDest)
	{
		int rc = (int)(0);
		Select pPrior;
		Vdbe v;
		SelectDest dest = new SelectDest();
		Select pDelete = null;
		sqlite3 db;
		db = pParse.db;
		pPrior = p.pPrior;
		dest = (SelectDest)(pDest);
		v = sqlite3GetVdbe(pParse);
		if ((dest.eDest) == (12))
		{
			sqlite3VdbeAddOp2(v, (int)(116), (int)(dest.iSDParm), (int)(p.pEList.nExpr));
			dest.eDest = (byte)(14);
		}

		if ((p.selFlags & 0x0000400) != 0)
		{
			rc = (int)(multiSelectValues(pParse, p, dest));
			if ((rc) >= (0))
				goto multi_select_end;
			rc = (int)(0);
		}

		if (((p.selFlags & 0x0002000) != 0) && ((hasAnchor(p)) != 0))
		{
			generateWithRecursiveQuery(pParse, p, dest);
		}
		else if ((p.pOrderBy) != null)
		{
			return (int)(multiSelectOrderBy(pParse, p, pDest));
		}
		else
		{
			if ((pPrior.pPrior) == (null))
			{
				sqlite3VdbeExplain(pParse, (byte)(1), "COMPOUND QUERY");
				sqlite3VdbeExplain(pParse, (byte)(1), "LEFT-MOST SUBQUERY");
			}

			switch (p.op)
			{
				case 135:
					{
						int addr = (int)(0);
						int nLimit = (int)(0);
						pPrior.iLimit = (int)(p.iLimit);
						pPrior.iOffset = (int)(p.iOffset);
						pPrior.pLimit = p.pLimit;
						rc = (int)(sqlite3Select(pParse, pPrior, dest));
						pPrior.pLimit = null;
						if ((rc) != 0)
						{
							goto multi_select_end;
						}

						p.pPrior = null;
						p.iLimit = (int)(pPrior.iLimit);
						p.iOffset = (int)(pPrior.iOffset);
						if ((p.iLimit) != 0)
						{
							addr = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(p.iLimit)));
							if ((p.iOffset) != 0)
							{
								sqlite3VdbeAddOp3(v, (int)(159), (int)(p.iLimit), (int)(p.iOffset + 1), (int)(p.iOffset));
							}
						}

						sqlite3VdbeExplain(pParse, (byte)(1), "UNION ALL");
						rc = (int)(sqlite3Select(pParse, p, dest));
						pDelete = p.pPrior;
						p.pPrior = pPrior;
						p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
						if (((((p.pLimit) != null) && ((sqlite3ExprIsInteger(p.pLimit.pLeft, &nLimit)) != 0)) && ((nLimit) > (0))) && ((p.nSelectRow) > (sqlite3LogEst((ulong)(nLimit)))))
						{
							p.nSelectRow = (short)(sqlite3LogEst((ulong)(nLimit)));
						}

						if ((addr) != 0)
						{
							sqlite3VdbeJumpHere(v, (int)(addr));
						}

						break;
					}

				case 136:
				case 134:
					{
						int unionTab = 0;
						byte op = (byte)(0);
						int priorOp = 0;
						Expr pLimit;
						int addr = 0;
						SelectDest uniondest = new SelectDest();
						priorOp = (int)(1);
						if ((dest.eDest) == (priorOp))
						{
							unionTab = (int)(dest.iSDParm);
						}
						else
						{
							unionTab = (int)(pParse.nTab++);
							addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(unionTab), (int)(0)));
							p.addrOpenEphm[0] = (int)(addr);
							findRightmost(p).selFlags |= (uint)(0x0000020);
						}

						sqlite3SelectDestInit(uniondest, (int)(priorOp), (int)(unionTab));
						rc = (int)(sqlite3Select(pParse, pPrior, uniondest));
						if ((rc) != 0)
						{
							goto multi_select_end;
						}

						if ((p.op) == (136))
						{
							op = (byte)(2);
						}
						else
						{
							op = (byte)(1);
						}

						p.pPrior = null;
						pLimit = p.pLimit;
						p.pLimit = null;
						uniondest.eDest = (byte)(op);
						sqlite3VdbeExplain(pParse, (byte)(1), "%s USING TEMP B-TREE", sqlite3SelectOpName((int)(p.op)));
						rc = (int)(sqlite3Select(pParse, p, uniondest));
						pDelete = p.pPrior;
						p.pPrior = pPrior;
						p.pOrderBy = null;
						if ((p.op) == (134))
						{
							p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
						}

						sqlite3ExprDelete(db, p.pLimit);
						p.pLimit = pLimit;
						p.iLimit = (int)(0);
						p.iOffset = (int)(0);
						if ((dest.eDest != priorOp) && ((db.mallocFailed) == (0)))
						{
							int iCont = 0;
							int iBreak = 0;
							int iStart = 0;
							iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
							iCont = (int)(sqlite3VdbeMakeLabel(pParse));
							computeLimitRegisters(pParse, p, (int)(iBreak));
							sqlite3VdbeAddOp2(v, (int)(38), (int)(unionTab), (int)(iBreak));
							iStart = (int)(sqlite3VdbeCurrentAddr(v));
							selectInnerLoop(pParse, p, (int)(unionTab), null, null, dest, (int)(iCont), (int)(iBreak));
							sqlite3VdbeResolveLabel(v, (int)(iCont));
							sqlite3VdbeAddOp2(v, (int)(5), (int)(unionTab), (int)(iStart));
							sqlite3VdbeResolveLabel(v, (int)(iBreak));
							sqlite3VdbeAddOp2(v, (int)(121), (int)(unionTab), (int)(0));
						}

						break;
					}

				default:
					;
					{
						int tab1 = 0;
						int tab2 = 0;
						int iCont = 0;
						int iBreak = 0;
						int iStart = 0;
						Expr pLimit;
						int addr = 0;
						SelectDest intersectdest = new SelectDest();
						int r1 = 0;
						tab1 = (int)(pParse.nTab++);
						tab2 = (int)(pParse.nTab++);
						addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(tab1), (int)(0)));
						p.addrOpenEphm[0] = (int)(addr);
						findRightmost(p).selFlags |= (uint)(0x0000020);
						sqlite3SelectDestInit(intersectdest, (int)(1), (int)(tab1));
						rc = (int)(sqlite3Select(pParse, pPrior, intersectdest));
						if ((rc) != 0)
						{
							goto multi_select_end;
						}

						addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(tab2), (int)(0)));
						p.addrOpenEphm[1] = (int)(addr);
						p.pPrior = null;
						pLimit = p.pLimit;
						p.pLimit = null;
						intersectdest.iSDParm = (int)(tab2);
						sqlite3VdbeExplain(pParse, (byte)(1), "%s USING TEMP B-TREE", sqlite3SelectOpName((int)(p.op)));
						rc = (int)(sqlite3Select(pParse, p, intersectdest));
						pDelete = p.pPrior;
						p.pPrior = pPrior;
						if ((p.nSelectRow) > (pPrior.nSelectRow))
						{
							p.nSelectRow = (short)(pPrior.nSelectRow);
						}

						sqlite3ExprDelete(db, p.pLimit);
						p.pLimit = pLimit;
						if ((rc) != 0)
							break;
						iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
						iCont = (int)(sqlite3VdbeMakeLabel(pParse));
						computeLimitRegisters(pParse, p, (int)(iBreak));
						sqlite3VdbeAddOp2(v, (int)(38), (int)(tab1), (int)(iBreak));
						r1 = (int)(sqlite3GetTempReg(pParse));
						iStart = (int)(sqlite3VdbeAddOp2(v, (int)(133), (int)(tab1), (int)(r1)));
						sqlite3VdbeAddOp4Int(v, (int)(30), (int)(tab2), (int)(iCont), (int)(r1), (int)(0));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						selectInnerLoop(pParse, p, (int)(tab1), null, null, dest, (int)(iCont), (int)(iBreak));
						sqlite3VdbeResolveLabel(v, (int)(iCont));
						sqlite3VdbeAddOp2(v, (int)(5), (int)(tab1), (int)(iStart));
						sqlite3VdbeResolveLabel(v, (int)(iBreak));
						sqlite3VdbeAddOp2(v, (int)(121), (int)(tab2), (int)(0));
						sqlite3VdbeAddOp2(v, (int)(121), (int)(tab1), (int)(0));
						break;
					}
			}

			if ((p.pNext) == (null))
			{
				sqlite3VdbeExplainPop(pParse);
			}
		}

		if ((pParse.nErr) != 0)
			goto multi_select_end;
		if ((p.selFlags & 0x0000020) != 0)
		{
			int i = 0;
			KeyInfo pKeyInfo;
			Select pLoop;
			CollSeq apColl;
			int nCol = 0;
			nCol = (int)(p.pEList.nExpr);
			pKeyInfo = sqlite3KeyInfoAlloc(db, (int)(nCol), (int)(1));
			if (pKeyInfo == null)
			{
				rc = (int)(7);
				goto multi_select_end;
			}

			for (i = (int)(0), apColl = pKeyInfo.aColl; (i) < (nCol); i++, apColl++)
			{
				apColl = multiSelectCollSeq(pParse, p, (int)(i));
				if ((null) == (apColl))
				{
					apColl = db.pDfltColl;
				}
			}

			for (pLoop = p; pLoop; pLoop = pLoop.pPrior)
			{
				for (i = (int)(0); (i) < (2); i++)
				{
					int addr = (int)(pLoop.addrOpenEphm[i]);
					if ((addr) < (0))
					{
						break;
					}

					sqlite3VdbeChangeP2(v, (int)(addr), (int)(nCol));
					sqlite3VdbeChangeP4(v, (int)(addr), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9));
					pLoop.addrOpenEphm[i] = (int)(-1);
				}
			}

			sqlite3KeyInfoUnref(pKeyInfo);
		}

	multi_select_end:
		; pDest.iSdst = (int)(dest.iSdst);
		pDest.nSdst = (int)(dest.nSdst);
		if ((pDelete) != null)
		{
			sqlite3ParserAddCleanup(pParse, sqlite3SelectDelete, pDelete);
		}

		return (int)(rc);
	}
	public static CollSeq multiSelectCollSeq(Parse pParse, Select p, int iCol)
	{
		CollSeq pRet;
		if ((p.pPrior) != null)
		{
			pRet = multiSelectCollSeq(pParse, p.pPrior, (int)(iCol));
		}
		else
		{
			pRet = null;
		}

		if (((pRet) == (null)) && ((iCol) < (p.pEList.nExpr)))
		{
			pRet = sqlite3ExprCollSeq(pParse, p.pEList.a[iCol].pExpr);
		}

		return pRet;
	}
	public static int multiSelectOrderBy(Parse pParse, Select p, SelectDest pDest)
	{
		int i = 0; int j = 0;
		Select pPrior;
		Select pSplit;
		int nSelect = 0;
		Vdbe v;
		SelectDest destA = new SelectDest();
		SelectDest destB = new SelectDest();
		int regAddrA = 0;
		int regAddrB = 0;
		int addrSelectA = 0;
		int addrSelectB = 0;
		int regOutA = 0;
		int regOutB = 0;
		int addrOutA = 0;
		int addrOutB = (int)(0);
		int addrEofA = 0;
		int addrEofA_noB = 0;
		int addrEofB = 0;
		int addrAltB = 0;
		int addrAeqB = 0;
		int addrAgtB = 0;
		int regLimitA = 0;
		int regLimitB = 0;
		int regPrev = 0;
		int savedLimit = 0;
		int savedOffset = 0;
		int labelCmpr = 0;
		int labelEnd = 0;
		int addr1 = 0;
		int op = 0;
		KeyInfo pKeyDup = null;
		KeyInfo pKeyMerge;
		sqlite3 db;
		ExprList pOrderBy;
		int nOrderBy = 0;
		uint* aPermute;
		db = pParse.db;
		v = pParse.pVdbe;
		labelEnd = (int)(sqlite3VdbeMakeLabel(pParse));
		labelCmpr = (int)(sqlite3VdbeMakeLabel(pParse));
		op = (int)(p.op);
		pOrderBy = p.pOrderBy;
		nOrderBy = (int)(pOrderBy.nExpr);
		if (op != 135)
		{
			for (i = (int)(1); ((db.mallocFailed) == (0)) && ((i) <= (p.pEList.nExpr)); i++)
			{
				ExprList_item* pItem;
				for (j = (int)(0), pItem = pOrderBy.a; (j) < (nOrderBy); j++, pItem++)
				{
					if ((pItem->u.x.iOrderByCol) == (i))
						break;
				}

				if ((j) == (nOrderBy))
				{
					Expr pNew = sqlite3Expr(db, (int)(155), null);
					if ((pNew) == (null))
						return (int)(7);
					pNew.flags |= (uint)(0x000400);
					pNew.u.iValue = (int)(i);
					p.pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
					if ((pOrderBy) != null)
						pOrderBy.a[nOrderBy++].u.x.iOrderByCol = ((ushort)(i));
				}
			}
		}

		aPermute = sqlite3DbMallocRawNN(db, (ulong)(sizeof(uint) * (nOrderBy + 1)));
		if ((aPermute) != null)
		{
			ExprList_item* pItem;
			aPermute[0] = (uint)(nOrderBy);
			for (i = (int)(1), pItem = pOrderBy.a; (i) <= (nOrderBy); i++, pItem++)
			{
				aPermute[i] = (uint)(pItem->u.x.iOrderByCol - 1);
			}

			pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, (int)(1));
		}
		else
		{
			pKeyMerge = null;
		}

		if ((op) == (135))
		{
			regPrev = (int)(0);
		}
		else
		{
			int nExpr = (int)(p.pEList.nExpr);
			regPrev = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nExpr + 1);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regPrev));
			pKeyDup = sqlite3KeyInfoAlloc(db, (int)(nExpr), (int)(1));
			if ((pKeyDup) != null)
			{
				for (i = (int)(0); (i) < (nExpr); i++)
				{
					pKeyDup.aColl[i] = multiSelectCollSeq(pParse, p, (int)(i));
					pKeyDup.aSortFlags[i] = (byte)(0);
				}
			}
		}

		nSelect = (int)(1);
		if ((((op) == (135)) || ((op) == (134))) && (((db).dbOptFlags & (0x00200000)) == (0)))
		{
			for (pSplit = p; (pSplit.pPrior != null) && ((pSplit.op) == (op)); pSplit = pSplit.pPrior)
			{
				nSelect++;
			}
		}

		if ((nSelect) <= (3))
		{
			pSplit = p;
		}
		else
		{
			pSplit = p;
			for (i = (int)(2); (i) < (nSelect); i += (int)(2))
			{
				pSplit = pSplit.pPrior;
			}
		}

		pPrior = pSplit.pPrior;
		pSplit.pPrior = null;
		pPrior.pNext = null;
		pPrior.pOrderBy = sqlite3ExprListDup(pParse.db, pOrderBy, (int)(0));
		sqlite3ResolveOrderGroupBy(pParse, p, p.pOrderBy, "ORDER");
		sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior.pOrderBy, "ORDER");
		computeLimitRegisters(pParse, p, (int)(labelEnd));
		if (((p.iLimit) != 0) && ((op) == (135)))
		{
			regLimitA = (int)(++pParse.nMem);
			regLimitB = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(79), (int)((p.iOffset) != 0 ? p.iOffset + 1 : p.iLimit), (int)(regLimitA));
			sqlite3VdbeAddOp2(v, (int)(79), (int)(regLimitA), (int)(regLimitB));
		}
		else
		{
			regLimitA = (int)(regLimitB = (int)(0));
		}

		sqlite3ExprDelete(db, p.pLimit);
		p.pLimit = null;
		regAddrA = (int)(++pParse.nMem);
		regAddrB = (int)(++pParse.nMem);
		regOutA = (int)(++pParse.nMem);
		regOutB = (int)(++pParse.nMem);
		sqlite3SelectDestInit(destA, (int)(13), (int)(regAddrA));
		sqlite3SelectDestInit(destB, (int)(13), (int)(regAddrB));
		sqlite3VdbeExplain(pParse, (byte)(1), "MERGE (%s)", sqlite3SelectOpName((int)(p.op)));
		addrSelectA = (int)(sqlite3VdbeCurrentAddr(v) + 1);
		addr1 = (int)(sqlite3VdbeAddOp3(v, (int)(13), (int)(regAddrA), (int)(0), (int)(addrSelectA)));
		pPrior.iLimit = (int)(regLimitA);
		sqlite3VdbeExplain(pParse, (byte)(1), "LEFT");
		sqlite3Select(pParse, pPrior, destA);
		sqlite3VdbeEndCoroutine(v, (int)(regAddrA));
		sqlite3VdbeJumpHere(v, (int)(addr1));
		addrSelectB = (int)(sqlite3VdbeCurrentAddr(v) + 1);
		addr1 = (int)(sqlite3VdbeAddOp3(v, (int)(13), (int)(regAddrB), (int)(0), (int)(addrSelectB)));
		savedLimit = (int)(p.iLimit);
		savedOffset = (int)(p.iOffset);
		p.iLimit = (int)(regLimitB);
		p.iOffset = (int)(0);
		sqlite3VdbeExplain(pParse, (byte)(1), "RIGHT");
		sqlite3Select(pParse, p, destB);
		p.iLimit = (int)(savedLimit);
		p.iOffset = (int)(savedOffset);
		sqlite3VdbeEndCoroutine(v, (int)(regAddrB));
		addrOutA = (int)(generateOutputSubroutine(pParse, p, destA, pDest, (int)(regOutA), (int)(regPrev), pKeyDup, (int)(labelEnd)));
		if (((op) == (135)) || ((op) == (134)))
		{
			addrOutB = (int)(generateOutputSubroutine(pParse, p, destB, pDest, (int)(regOutB), (int)(regPrev), pKeyDup, (int)(labelEnd)));
		}

		sqlite3KeyInfoUnref(pKeyDup);
		if (((op) == (136)) || ((op) == (137)))
		{
			addrEofA_noB = (int)(addrEofA = (int)(labelEnd));
		}
		else
		{
			addrEofA = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutB), (int)(addrOutB)));
			addrEofA_noB = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(labelEnd)));
			sqlite3VdbeGoto(v, (int)(addrEofA));
			p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
		}

		if ((op) == (137))
		{
			addrEofB = (int)(addrEofA);
			if ((p.nSelectRow) > (pPrior.nSelectRow))
				p.nSelectRow = (short)(pPrior.nSelectRow);
		}
		else
		{
			addrEofB = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutA), (int)(addrOutA)));
			sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(labelEnd));
			sqlite3VdbeGoto(v, (int)(addrEofB));
		}

		addrAltB = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutA), (int)(addrOutA)));
		sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA));
		sqlite3VdbeGoto(v, (int)(labelCmpr));
		if ((op) == (135))
		{
			addrAeqB = (int)(addrAltB);
		}
		else if ((op) == (137))
		{
			addrAeqB = (int)(addrAltB);
			addrAltB++;
		}
		else
		{
			addrAeqB = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA)));
			sqlite3VdbeGoto(v, (int)(labelCmpr));
		}

		addrAgtB = (int)(sqlite3VdbeCurrentAddr(v));
		if (((op) == (135)) || ((op) == (134)))
		{
			sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutB), (int)(addrOutB));
		}

		sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(addrEofB));
		sqlite3VdbeGoto(v, (int)(labelCmpr));
		sqlite3VdbeJumpHere(v, (int)(addr1));
		sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA_noB));
		sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(addrEofB));
		sqlite3VdbeResolveLabel(v, (int)(labelCmpr));
		sqlite3VdbeAddOp4(v, (int)(88), (int)(0), (int)(0), (int)(0), (sbyte*)(aPermute), (int)(-15));
		sqlite3VdbeAddOp4(v, (int)(89), (int)(destA.iSdst), (int)(destB.iSdst), (int)(nOrderBy), (sbyte*)(pKeyMerge), (int)(-9));
		sqlite3VdbeChangeP5(v, (ushort)(0x01));
		sqlite3VdbeAddOp3(v, (int)(16), (int)(addrAltB), (int)(addrAeqB), (int)(addrAgtB));
		sqlite3VdbeResolveLabel(v, (int)(labelEnd));
		if ((pSplit.pPrior) != null)
		{
			sqlite3SelectDelete(db, pSplit.pPrior);
		}

		pSplit.pPrior = pPrior;
		pPrior.pNext = pSplit;
		sqlite3ExprListDelete(db, pPrior.pOrderBy);
		pPrior.pOrderBy = null;
		sqlite3VdbeExplainPop(pParse);
		return (int)(pParse.nErr != 0);
	}
	public static KeyInfo multiSelectOrderByKeyInfo(Parse pParse, Select p, int nExtra)
	{
		ExprList pOrderBy = p.pOrderBy;
		int nOrderBy = (int)((pOrderBy != null) ? pOrderBy.nExpr : 0);
		sqlite3 db = pParse.db;
		KeyInfo pRet = sqlite3KeyInfoAlloc(db, (int)(nOrderBy + nExtra), (int)(1));
		if ((pRet) != null)
		{
			int i = 0;
			for (i = (int)(0); (i) < (nOrderBy); i++)
			{
				ExprList_item* pItem = &pOrderBy.a[i];
				Expr pTerm = pItem->pExpr;
				CollSeq pColl;
				if ((pTerm.flags & 0x000100) != 0)
				{
					pColl = sqlite3ExprCollSeq(pParse, pTerm);
				}
				else
				{
					pColl = multiSelectCollSeq(pParse, p, (int)(pItem->u.x.iOrderByCol - 1));
					if ((pColl) == (null))
						pColl = db.pDfltColl;
					pOrderBy.a[i].pExpr = sqlite3ExprAddCollateString(pParse, pTerm, pColl.zName);
				}

				pRet.aColl[i] = pColl;
				pRet.aSortFlags[i] = (byte)(pOrderBy.a[i].sortFlags);
			}
		}

		return pRet;
	}
	public static int multiSelectValues(Parse pParse, Select p, SelectDest pDest)
	{
		int nRow = (int)(1);
		int rc = (int)(0);
		int bShowAll = (int)((p.pLimit) == (null) ? 1 : 0);
		do
		{
			if ((p.pWin) != null)
				return (int)(-1);
			if ((p.pPrior) == (null))
				break;
			p = p.pPrior;
			nRow += (int)(bShowAll);
		}
		while ((1) != 0);
		sqlite3VdbeExplain(pParse, (byte)(0), "SCAN %d CONSTANT ROW%s", (int)(nRow), (nRow) == (1) ? "" : "S");
		while ((p) != null)
		{
			selectInnerLoop(pParse, p, (int)(-1), null, null, pDest, (int)(1), (int)(1));
			if (bShowAll == 0)
				break;
			p.nSelectRow = (short)(nRow);
			p = p.pNext;
		}

		return (int)(rc);
	}
	public static void notValidImpl(Parse pParse, NameContext pNC, sbyte* zMsg, Expr pExpr, Expr pError)
	{
		sbyte* zIn = "partial index WHERE clauses";
		if ((pNC.ncFlags & 0x000020) != 0)
			zIn = "index expressions";
		else if ((pNC.ncFlags & 0x000004) != 0)
			zIn = "CHECK constraints";
		else if ((pNC.ncFlags & 0x000008) != 0)
			zIn = "generated columns";
		sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
		if ((pExpr) != null)
			pExpr.op = (byte)(121);
		sqlite3RecordErrorOffsetOfExpr(pParse.db, pError);
	}
	public static void openStatTable(Parse pParse, int iDb, int iStatCur, sbyte* zWhere, sbyte* zWhereType)
	{
		int i = 0;
		sqlite3 db = pParse.db;
		Db pDb;
		Vdbe v = sqlite3GetVdbe(pParse);
		uint* aRoot = stackalloc uint[3];
		byte* aCreateTbl = stackalloc byte[3];
		int nToOpen = (int)(1);
		if ((v) == (null))
			return;
		pDb = db.aDb[iDb];
		for (i = (int)(0); (i) < ((int)(3 * sizeof(aTableType) / sizeof(aTableType))); i++)
		{
			sbyte* zTab = openStatTable_aTable[i].zName;
			Table pStat;
			aCreateTbl[i] = (byte)(0);
			if ((pStat = sqlite3FindTable(db, zTab, pDb.zDbSName)) == (null))
			{
				if ((i) < (nToOpen))
				{
					sqlite3NestedParse(pParse, "CREATE TABLE %Q.%s(%s)", pDb.zDbSName, zTab, openStatTable_aTable[i].zCols);
					aRoot[i] = ((uint)(pParse.regRoot));
					aCreateTbl[i] = (byte)(0x10);
				}
			}
			else
			{
				aRoot[i] = (uint)(pStat.tnum);
				sqlite3TableLock(pParse, (int)(iDb), (uint)(aRoot[i]), (byte)(1), zTab);
				if ((zWhere) != null)
				{
					sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", pDb.zDbSName, zTab, zWhereType, zWhere);
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(144), (int)(aRoot[i]), (int)(iDb));
				}
			}
		}

		for (i = (int)(0); (i) < (nToOpen); i++)
		{
			sqlite3VdbeAddOp4Int(v, (int)(112), (int)(iStatCur + i), (int)(aRoot[i]), (int)(iDb), (int)(3));
			sqlite3VdbeChangeP5(v, (ushort)(aCreateTbl[i]));
		}
	}
	public static ExprList parserAddExprIdListTerm(Parse pParse, ExprList pPrior, Token* pIdToken, int hasCollate, int sortOrder)
	{
		ExprList p = sqlite3ExprListAppend(pParse, pPrior, null);
		if ((((hasCollate) != 0) || (sortOrder != -1)) && ((pParse.db.init.busy) == (0)))
		{
			sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"", (uint)(pIdToken->n), pIdToken->z);
		}

		sqlite3ExprListSetName(pParse, p, pIdToken, (int)(1));
		return p;
	}
	public static void parserDoubleLinkSelect(Parse pParse, Select p)
	{
		if ((p.pPrior) != null)
		{
			Select pNext = null;
			Select pLoop = p;
			int mxSelect = 0;
			int cnt = (int)(1);
			while ((1) != 0)
			{
				pLoop.pNext = pNext;
				pLoop.selFlags |= (uint)(0x0000100);
				pNext = pLoop;
				pLoop = pLoop.pPrior;
				if ((pLoop) == (null))
					break;
				cnt++;
				if (((pLoop.pOrderBy) != null) || ((pLoop.pLimit) != null))
				{
					sqlite3ErrorMsg(pParse, "%s clause should come after %s not before", pLoop.pOrderBy != null ? "ORDER BY" : "LIMIT", sqlite3SelectOpName((int)(pNext.op)));
					break;
				}
			}

			if ((((p.selFlags & 0x0000400) == (0)) && ((mxSelect = (int)(pParse.db.aLimit[4])) > (0))) && ((cnt) > (mxSelect)))
			{
				sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
			}
		}
	}
	public static int propagateConstants(Parse pParse, Select p)
	{
		WhereConst x = new WhereConst();
		Walker w = new Walker();
		int nChng = (int)(0);
		x.pParse = pParse;
		x.pOomFault = &pParse.db.mallocFailed;
		do
		{
			x.nConst = (int)(0);
			x.nChng = (int)(0);
			x.apExpr = null;
			x.bHasAffBlob = (int)(0);
			findConstInWhere(x, p.pWhere);
			if ((x.nConst) != 0)
			{
				CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
				w.pParse = pParse;
				w.xExprCallback = propagateConstantExprRewrite;
				w.xSelectCallback = sqlite3SelectWalkNoop;
				w.xSelectCallback2 = null;
				w.walkerDepth = (int)(0);
				w.u.pConst = x;
				sqlite3WalkExpr(w, p.pWhere);
				sqlite3DbFree(x.pParse.db, x.apExpr);
				nChng += (int)(x.nChng);
			}
		}
		while ((x.nChng) != 0);
		return (int)(nChng);
	}
	public static int pushDownWhereTerms(Parse pParse, Select pSubq, Expr pWhere, int iCursor, int isLeftJoin)
	{
		Expr pNew;
		int nChng = (int)(0);
		if ((pWhere) == (null))
			return (int)(0);
		if ((pSubq.selFlags & (0x0002000 | 0x2000000)) != 0)
			return (int)(0);
		if ((pSubq.pPrior) != null)
		{
			Select pSel;
			for (pSel = pSubq; pSel; pSel = pSel.pPrior)
			{
				if ((pSel.pWin) != null)
					return (int)(0);
			}
		}
		else
		{
			if (((pSubq.pWin) != null) && ((pSubq.pWin.pPartition) == (null)))
				return (int)(0);
		}

		if (pSubq.pLimit != null)
		{
			return (int)(0);
		}

		while ((pWhere.op) == (44))
		{
			nChng += (int)(pushDownWhereTerms(pParse, pSubq, pWhere.pRight, (int)(iCursor), (int)(isLeftJoin)));
			pWhere = pWhere.pLeft;
		}

		if (((isLeftJoin) != 0) && (((((pWhere).flags & (0x000001)) != 0) == (0)) || (pWhere.w.iRightJoinTable != iCursor)))
		{
			return (int)(0);
		}

		if ((((pWhere).flags & (0x000001)) != 0) && (pWhere.w.iRightJoinTable != iCursor))
		{
			return (int)(0);
		}

		if ((sqlite3ExprIsTableConstant(pWhere, (int)(iCursor))) != 0)
		{
			nChng++;
			pSubq.selFlags |= (uint)(0x1000000);
			while ((pSubq) != null)
			{
				SubstContext x = new SubstContext();
				pNew = sqlite3ExprDup(pParse.db, pWhere, (int)(0));
				unsetJoinExpr(pNew, (int)(-1));
				x.pParse = pParse;
				x.iTable = (int)(iCursor);
				x.iNewTable = (int)(iCursor);
				x.isLeftJoin = (int)(0);
				x.pEList = pSubq.pEList;
				pNew = substExpr(x, pNew);
				if (((pSubq.pWin) != null) && ((0) == (pushDownWindowCheck(pParse, pSubq, pNew))))
				{
					sqlite3ExprDelete(pParse.db, pNew);
					nChng--;
					break;
				}

				if ((pSubq.selFlags & 0x0000008) != 0)
				{
					pSubq.pHaving = sqlite3ExprAnd(pParse, pSubq.pHaving, pNew);
				}
				else
				{
					pSubq.pWhere = sqlite3ExprAnd(pParse, pSubq.pWhere, pNew);
				}

				pSubq = pSubq.pPrior;
			}
		}

		return (int)(nChng);
	}
	public static int pushDownWindowCheck(Parse pParse, Select pSubq, Expr pExpr)
	{
		return (int)(sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq.pWin.pPartition));
	}
	public static void pushOntoSorter(Parse pParse, SortCtx pSort, Select pSelect, int regData, int regOrigData, int nData, int nPrefixReg)
	{
		Vdbe v = pParse.pVdbe;
		int bSeq = (int)(((pSort.sortFlags & 0x01) == (0)) ? 1 : 0);
		int nExpr = (int)(pSort.pOrderBy.nExpr);
		int nBase = (int)(nExpr + bSeq + nData);
		int regBase = 0;
		int regRecord = (int)(0);
		int nOBSat = (int)(pSort.nOBSat);
		int op = 0;
		int iLimit = 0;
		int iSkip = (int)(0);
		if ((nPrefixReg) != 0)
		{
			regBase = (int)(regData - nPrefixReg);
		}
		else
		{
			regBase = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nBase);
		}

		iLimit = (int)((pSelect.iOffset) != 0 ? pSelect.iOffset + 1 : pSelect.iLimit);
		pSort.labelDone = (int)(sqlite3VdbeMakeLabel(pParse));
		sqlite3ExprCodeExprList(pParse, pSort.pOrderBy, (int)(regBase), (int)(regOrigData), (byte)(0x01 | ((regOrigData) != 0 ? 0x04 : 0)));
		if ((bSeq) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(125), (int)(pSort.iECursor), (int)(regBase + nExpr));
		}

		if (((nPrefixReg) == (0)) && ((nData) > (0)))
		{
			sqlite3ExprCodeMove(pParse, (int)(regData), (int)(regBase + nExpr + bSeq), (int)(nData));
		}

		if ((nOBSat) > (0))
		{
			int regPrevKey = 0;
			int addrFirst = 0;
			int addrJmp = 0;
			VdbeOp* pOp;
			int nKey = 0;
			KeyInfo pKI;
			regRecord = (int)(makeSorterRecord(pParse, pSort, pSelect, (int)(regBase), (int)(nBase)));
			regPrevKey = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(pSort.nOBSat);
			nKey = (int)(nExpr - pSort.nOBSat + bSeq);
			if ((bSeq) != 0)
			{
				addrFirst = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regBase + nExpr)));
			}
			else
			{
				addrFirst = (int)(sqlite3VdbeAddOp1(v, (int)(119), (int)(pSort.iECursor)));
			}

			sqlite3VdbeAddOp3(v, (int)(89), (int)(regPrevKey), (int)(regBase), (int)(pSort.nOBSat));
			pOp = sqlite3VdbeGetOp(v, (int)(pSort.addrSortIndex));
			if ((pParse.db.mallocFailed) != 0)
				return;
			pOp->p2 = (int)(nKey + nData);
			pKI = pOp->p4.pKeyInfo;
			CRuntime.memset(pKI.aSortFlags, (int)(0), (ulong)(pKI.nKeyField));
			sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pKI), (int)(-9));
			pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pSort.pOrderBy, (int)(nOBSat), (int)(pKI.nAllField - pKI.nKeyField - 1));
			pOp = null;
			addrJmp = (int)(sqlite3VdbeCurrentAddr(v));
			sqlite3VdbeAddOp3(v, (int)(16), (int)(addrJmp + 1), (int)(0), (int)(addrJmp + 1));
			pSort.labelBkOut = (int)(sqlite3VdbeMakeLabel(pParse));
			pSort.regReturn = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(12), (int)(pSort.regReturn), (int)(pSort.labelBkOut));
			sqlite3VdbeAddOp1(v, (int)(145), (int)(pSort.iECursor));
			if ((iLimit) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(20), (int)(iLimit), (int)(pSort.labelDone));
			}

			sqlite3VdbeJumpHere(v, (int)(addrFirst));
			sqlite3ExprCodeMove(pParse, (int)(regBase), (int)(regPrevKey), (int)(pSort.nOBSat));
			sqlite3VdbeJumpHere(v, (int)(addrJmp));
		}

		if ((iLimit) != 0)
		{
			int iCsr = (int)(pSort.iECursor);
			sqlite3VdbeAddOp2(v, (int)(59), (int)(iLimit), (int)(sqlite3VdbeCurrentAddr(v) + 4));
			sqlite3VdbeAddOp2(v, (int)(34), (int)(iCsr), (int)(0));
			iSkip = (int)(sqlite3VdbeAddOp4Int(v, (int)(39), (int)(iCsr), (int)(0), (int)(regBase + nOBSat), (int)(nExpr - nOBSat)));
			sqlite3VdbeAddOp1(v, (int)(129), (int)(iCsr));
		}

		if ((regRecord) == (0))
		{
			regRecord = (int)(makeSorterRecord(pParse, pSort, pSelect, (int)(regBase), (int)(nBase)));
		}

		if ((pSort.sortFlags & 0x01) != 0)
		{
			op = (int)(138);
		}
		else
		{
			op = (int)(137);
		}

		sqlite3VdbeAddOp4Int(v, (int)(op), (int)(pSort.iECursor), (int)(regRecord), (int)(regBase + nOBSat), (int)(nBase - nOBSat));
		if ((iSkip) != 0)
		{
			sqlite3VdbeChangeP2(v, (int)(iSkip), (int)((pSort.labelOBLopt) != 0 ? pSort.labelOBLopt : sqlite3VdbeCurrentAddr(v)));
		}
	}
	public static int readsTable(Parse p, int iDb, Table pTab)
	{
		Vdbe v = sqlite3GetVdbe(p);
		int i = 0;
		int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
		VTable pVTab = (((pTab).eTabType) == (1)) ? sqlite3GetVTable(p.db, pTab) : null;
		for (i = (int)(1); (i) < (iEnd); i++)
		{
			VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(i));
			if (((pOp->opcode) == (101)) && ((pOp->p3) == (iDb)))
			{
				Index pIndex;
				uint tnum = (uint)(pOp->p2);
				if ((tnum) == (pTab.tnum))
				{
					return (int)(1);
				}

				for (pIndex = pTab.pIndex; pIndex; pIndex = pIndex.pNext)
				{
					if ((tnum) == (pIndex.tnum))
					{
						return (int)(1);
					}
				}
			}

			if (((pOp->opcode) == (172)) && ((pOp->p4.pVtab) == (pVTab)))
			{
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static void reindexDatabases(Parse pParse, sbyte* zColl)
	{
		Db pDb;
		int iDb = 0;
		sqlite3 db = pParse.db;
		HashElem* k;
		Table pTab;
		for (iDb = (int)(0), pDb = db.aDb; (iDb) < (db.nDb); iDb++, pDb++)
		{
			for (k = ((&pDb.pSchema.tblHash)->first); k; k = ((k)->next))
			{
				pTab = (Table)((k)->data);
				reindexTable(pParse, pTab, zColl);
			}
		}
	}
	public static void reindexTable(Parse pParse, Table pTab, sbyte* zColl)
	{
		if (!(((pTab).eTabType) == (1)))
		{
			Index pIndex;
			for (pIndex = pTab.pIndex; pIndex; pIndex = pIndex.pNext)
			{
				if (((zColl) == (null)) || ((collationMatch(zColl, pIndex)) != 0))
				{
					int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
					sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
					sqlite3RefillIndex(pParse, pIndex, (int)(-1));
				}
			}
		}
	}
	public static Expr removeUnindexableInClauseTerms(Parse pParse, int iEq, WhereLoop pLoop, Expr pX)
	{
		sqlite3 db = pParse.db;
		Expr pNew;
		pNew = sqlite3ExprDup(db, pX, (int)(0));
		if ((db.mallocFailed) == (0))
		{
			ExprList pOrigRhs;
			ExprList pOrigLhs;
			ExprList pRhs = null;
			ExprList pLhs = null;
			int i = 0;
			Select pSelect;
			pOrigRhs = pNew.x.pSelect.pEList;
			pOrigLhs = pNew.pLeft.x.pList;
			for (i = (int)(iEq); (i) < (pLoop.nLTerm); i++)
			{
				if ((pLoop.aLTerm[i].pExpr) == (pX))
				{
					int iField = 0;
					iField = (int)(pLoop.aLTerm[i].u.x.iField - 1);
					if ((pOrigRhs.a[iField].pExpr) == (null))
						continue;
					pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs.a[iField].pExpr);
					pOrigRhs.a[iField].pExpr = null;
					pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs.a[iField].pExpr);
					pOrigLhs.a[iField].pExpr = null;
				}
			}

			sqlite3ExprListDelete(db, pOrigRhs);
			sqlite3ExprListDelete(db, pOrigLhs);
			pNew.pLeft.x.pList = pLhs;
			pNew.x.pSelect.pEList = pRhs;
			if (((pLhs) != null) && ((pLhs.nExpr) == (1)))
			{
				Expr p = pLhs.a[0].pExpr;
				pLhs.a[0].pExpr = null;
				sqlite3ExprDelete(db, pNew.pLeft);
				pNew.pLeft = p;
			}

			pSelect = pNew.x.pSelect;
			if ((pSelect.pOrderBy) != null)
			{
				ExprList pOrderBy = pSelect.pOrderBy;
				for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
				{
					pOrderBy.a[i].u.x.iOrderByCol = (ushort)(0);
				}
			}
		}

		return pNew;
	}
	public static void renameColumnElistNames(Parse pParse, RenameCtx pCtx, ExprList pEList, sbyte* zOld)
	{
		if ((pEList) != null)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				sbyte* zName = pEList.a[i].zEName;
				if ((((pEList.a[i].eEName) == (0)) && (zName != null)) && ((0) == (sqlite3_stricmp(zName, zOld))))
				{
					renameTokenFind(pParse, pCtx, (void*)(zName));
				}
			}
		}
	}
	public static void renameColumnIdlistNames(Parse pParse, RenameCtx pCtx, IdList* pIdList, sbyte* zOld)
	{
		if ((pIdList) != null)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pIdList->nId); i++)
			{
				sbyte* zName = pIdList->a[i].zName;
				if ((0) == (sqlite3_stricmp(zName, zOld)))
				{
					renameTokenFind(pParse, pCtx, (void*)(zName));
				}
			}
		}
	}
	public static void renameFixQuotes(Parse pParse, sbyte* zDb, int bTemp)
	{
		sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_quotefix(%Q, sql)WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%'", zDb, zDb);
		if ((bTemp) == (0))
		{
			sqlite3NestedParse(pParse, "UPDATE temp.sqlite_master SET sql = sqlite_rename_quotefix('temp', sql)WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%'");
		}
	}
	public static void renameParseCleanup(Parse pParse)
	{
		sqlite3 db = pParse.db;
		Index pIdx;
		if ((pParse.pVdbe) != null)
		{
			sqlite3VdbeFinalize(pParse.pVdbe);
		}

		sqlite3DeleteTable(db, pParse.pNewTable);
		while ((pIdx = pParse.pNewIndex) != null)
		{
			pParse.pNewIndex = pIdx.pNext;
			sqlite3FreeIndex(db, pIdx);
		}

		sqlite3DeleteTrigger(db, pParse.pNewTrigger);
		sqlite3DbFree(db, pParse.zErrMsg);
		renameTokenFree(db, pParse.pRename);
		sqlite3ParseObjectReset(pParse);
	}
	public static int renameParseSql(Parse p, sbyte* zDb, sqlite3 db, sbyte* zSql, int bTemp)
	{
		int rc = 0;
		sqlite3ParseObjectInit(p, db);
		if ((zSql) == (null))
		{
			return (int)(7);
		}

		if (sqlite3_strnicmp(zSql, "CREATE ", (int)(7)) != 0)
		{
			return (int)(sqlite3CorruptError((int)(109974)));
		}

		db.init.iDb = (byte)((bTemp) != 0 ? 1 : sqlite3FindDbName(db, zDb));
		p.eParseMode = (byte)(2);
		p.db = db;
		p.nQueryLoop = (uint)(1);
		rc = (int)(sqlite3RunParser(p, zSql));
		if ((db.mallocFailed) != 0)
			rc = (int)(7);
		if (((rc) == (0)) && ((((p.pNewTable) == (null)) && ((p.pNewIndex) == (null))) && ((p.pNewTrigger) == (null))))
		{
			rc = (int)(sqlite3CorruptError((int)(109985)));
		}

		db.init.iDb = (byte)(0);
		return (int)(rc);
	}
	public static void renameReloadSchema(Parse pParse, int iDb, ushort p5)
	{
		Vdbe v = pParse.pVdbe;
		if ((v) != null)
		{
			sqlite3ChangeCookie(pParse, (int)(iDb));
			sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, (int)(iDb), null, (ushort)(p5));
			if (iDb != 1)
				sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, (int)(1), null, (ushort)(p5));
		}
	}
	public static int renameResolveTrigger(Parse pParse)
	{
		sqlite3 db = pParse.db;
		Trigger pNew = pParse.pNewTrigger;
		TriggerStep pStep;
		NameContext sNC = new NameContext();
		int rc = (int)(0);
		CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
		sNC.pParse = pParse;
		pParse.pTriggerTab = sqlite3FindTable(db, pNew.table, db.aDb[sqlite3SchemaToIndex(db, pNew.pTabSchema)].zDbSName);
		pParse.eTriggerOp = (byte)(pNew.op);
		if ((pParse.pTriggerTab) != null)
		{
			rc = (int)(sqlite3ViewGetColumnNames(pParse, pParse.pTriggerTab));
		}

		if (((rc) == (0)) && ((pNew.pWhen) != null))
		{
			rc = (int)(sqlite3ResolveExprNames(sNC, pNew.pWhen));
		}

		for (pStep = pNew.step_list; ((rc) == (0)) && ((pStep) != null); pStep = pStep.pNext)
		{
			if ((pStep.pSelect) != null)
			{
				sqlite3SelectPrep(pParse, pStep.pSelect, sNC);
				if ((pParse.nErr) != 0)
					rc = (int)(pParse.rc);
			}

			if (((rc) == (0)) && ((pStep.zTarget) != null))
			{
				SrcList pSrc = sqlite3TriggerStepSrc(pParse, pStep);
				if ((pSrc) != null)
				{
					int i = 0;
					for (i = (int)(0); ((i) < (pSrc.nSrc)) && ((rc) == (0)); i++)
					{
						SrcItem p = pSrc.a[i];
						p.iCursor = (int)(pParse.nTab++);
						if ((p.pSelect) != null)
						{
							sqlite3SelectPrep(pParse, p.pSelect, null);
							sqlite3ExpandSubquery(pParse, p);
							sqlite3SelectPrep(pParse, pStep.pFrom.a[i - 1].pSelect, null);
						}
						else
						{
							p.pTab = sqlite3LocateTableItem(pParse, (uint)(0), p);
							if ((p.pTab) == (null))
							{
								rc = (int)(1);
							}
							else
							{
								p.pTab.nTabRef++;
								rc = (int)(sqlite3ViewGetColumnNames(pParse, p.pTab));
							}
						}
					}

					if (((rc) == (0)) && ((db.mallocFailed) != 0))
					{
						rc = (int)(7);
					}

					sNC.pSrcList = pSrc;
					if (((rc) == (0)) && ((pStep.pWhere) != null))
					{
						rc = (int)(sqlite3ResolveExprNames(sNC, pStep.pWhere));
					}

					if ((rc) == (0))
					{
						rc = (int)(sqlite3ResolveExprListNames(sNC, pStep.pExprList));
					}

					if (((pStep.pUpsert) != null) && ((rc) == (0)))
					{
						Upsert pUpsert = pStep.pUpsert;
						pUpsert.pUpsertSrc = pSrc;
						sNC.uNC.pUpsert = pUpsert;
						sNC.ncFlags = (int)(0x000200);
						rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsert.pUpsertTarget));
						if ((rc) == (0))
						{
							ExprList pUpsertSet = pUpsert.pUpsertSet;
							rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsertSet));
						}

						if ((rc) == (0))
						{
							rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertWhere));
						}

						if ((rc) == (0))
						{
							rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertTargetWhere));
						}

						sNC.ncFlags = (int)(0);
					}

					sNC.pSrcList = null;
					sqlite3SrcListDelete(db, pSrc);
				}
				else
				{
					rc = (int)(7);
				}
			}
		}

		return (int)(rc);
	}
	public static void renameTestSchema(Parse pParse, sbyte* zDb, int bTemp, sbyte* zWhen, int bNoDQS)
	{
		pParse.colNamesSet = (byte)(1);
		sqlite3NestedParse(pParse, "SELECT 1 FROM \"%w\".sqlite_master WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%' AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ", zDb, zDb, (int)(bTemp), zWhen, (int)(bNoDQS));
		if ((bTemp) == (0))
		{
			sqlite3NestedParse(pParse, "SELECT 1 FROM temp.sqlite_master WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%' AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ", zDb, zWhen, (int)(bNoDQS));
		}
	}
	public static void renumberCursors(Parse pParse, Select p, int iExcept, int* aCsrMap)
	{
		Walker w = new Walker();
		srclistRenumberCursors(pParse, aCsrMap, p.pSrc, (int)(iExcept));
		CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
		w.u.aiCol = aCsrMap;
		w.xExprCallback = renumberCursorsCb;
		w.xSelectCallback = sqlite3SelectWalkNoop;
		sqlite3WalkSelect(w, p);
	}
	public static void resetAccumulator(Parse pParse, AggInfo pAggInfo)
	{
		Vdbe v = pParse.pVdbe;
		int i = 0;
		AggInfo_func pFunc;
		int nReg = (int)(pAggInfo.nFunc + pAggInfo.nColumn);
		if ((nReg) == (0))
			return;
		if ((pParse.nErr) != 0)
			return;
		sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(pAggInfo.mnReg), (int)(pAggInfo.mxReg));
		for (pFunc = pAggInfo.aFunc, i = (int)(0); (i) < (pAggInfo.nFunc); i++, pFunc++)
		{
			if ((pFunc.iDistinct) >= (0))
			{
				Expr pE = pFunc.pFExpr;
				if (((pE.x.pList) == (null)) || (pE.x.pList.nExpr != 1))
				{
					sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one argument");
					pFunc.iDistinct = (int)(-1);
				}
				else
				{
					KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE.x.pList, (int)(0), (int)(0));
					pFunc.iDistAddr = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(pFunc.iDistinct), (int)(0), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
					sqlite3VdbeExplain(pParse, (byte)(0), "USE TEMP B-TREE FOR %s(DISTINCT)", pFunc.pFunc.zName);
				}
			}
		}
	}
	public static void resizeResolveLabel(Parse p, Vdbe v, int j)
	{
		int nNewSize = (int)(10 - p.nLabel);
		p.aLabel = sqlite3DbReallocOrFree(p.db, p.aLabel, (ulong)(nNewSize * sizeof(int)));
		if ((p.aLabel) == (null))
		{
			p.nLabelAlloc = (int)(0);
		}
		else
		{
			p.nLabelAlloc = (int)(nNewSize);
			p.aLabel[j] = (int)(v.nOp);
		}
	}
	public static void resolveAlias(Parse pParse, ExprList pEList, int iCol, Expr pExpr, int nSubquery)
	{
		Expr pOrig;
		Expr pDup;
		sqlite3 db;
		pOrig = pEList.a[iCol].pExpr;
		db = pParse.db;
		pDup = sqlite3ExprDup(db, pOrig, (int)(0));
		if ((db.mallocFailed) != 0)
		{
			sqlite3ExprDelete(db, pDup);
			pDup = null;
		}
		else
		{
			incrAggFunctionDepth(pDup, (int)(nSubquery));
			if ((pExpr.op) == (113))
			{
				pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr.u.zToken);
			}

			(pExpr).flags |= (uint)(0x8000000);
			sqlite3ExprDelete(db, pExpr);
			CRuntime.memcpy(pExpr, pDup, (ulong)(sizeof(Expr)));
			if ((!(((pExpr).flags & (0x000400)) != 0)) && (pExpr.u.zToken != null))
			{
				pExpr.u.zToken = sqlite3DbStrDup(db, pExpr.u.zToken);
				pExpr.flags |= (uint)(0x010000);
			}

			if ((((pExpr).flags & (0x1000000)) != 0))
			{
				if ((pExpr.y.pWin != null))
				{
					pExpr.y.pWin.pOwner = pExpr;
				}
			}

			sqlite3DbFree(db, pDup);
		}
	}
	public static int resolveAsName(Parse pParse, ExprList pEList, Expr pE)
	{
		int i = 0;
		if ((pE.op) == (59))
		{
			sbyte* zCol;
			zCol = pE.u.zToken;
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				if (((pEList.a[i].eEName) == (0)) && ((sqlite3_stricmp(pEList.a[i].zEName, zCol)) == (0)))
				{
					return (int)(i + 1);
				}
			}
		}

		return (int)(0);
	}
	public static int resolveCompoundOrderBy(Parse pParse, Select pSelect)
	{
		int i = 0;
		ExprList pOrderBy;
		ExprList pEList;
		sqlite3 db;
		int moreToDo = (int)(1);
		pOrderBy = pSelect.pOrderBy;
		if ((pOrderBy) == (null))
			return (int)(0);
		db = pParse.db;
		if ((pOrderBy.nExpr) > (db.aLimit[2]))
		{
			sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
			return (int)(1);
		}

		for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
		{
			pOrderBy.a[i].done = (uint)(0);
		}

		pSelect.pNext = null;
		while ((pSelect.pPrior) != null)
		{
			pSelect.pPrior.pNext = pSelect;
			pSelect = pSelect.pPrior;
		}

		while (((pSelect) != null) && ((moreToDo) != 0))
		{
			ExprList_item* pItem;
			moreToDo = (int)(0);
			pEList = pSelect.pEList;
			for (i = (int)(0), pItem = pOrderBy.a; (i) < (pOrderBy.nExpr); i++, pItem++)
			{
				int iCol = (int)(-1);
				Expr pE;
				Expr pDup;
				if ((pItem->done) != 0)
					continue;
				pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
				if (((pE) == (null)))
					continue;
				if ((sqlite3ExprIsInteger(pE, &iCol)) != 0)
				{
					if (((iCol) <= (0)) || ((iCol) > (pEList.nExpr)))
					{
						resolveOutOfRangeError(pParse, "ORDER", (int)(i + 1), (int)(pEList.nExpr), pE);
						return (int)(1);
					}
				}
				else
				{
					iCol = (int)(resolveAsName(pParse, pEList, pE));
					if ((iCol) == (0))
					{
						pDup = sqlite3ExprDup(db, pE, (int)(0));
						if (db.mallocFailed == 0)
						{
							iCol = (int)(resolveOrderByTermToExprList(pParse, pSelect, pDup));
							if (((pParse.eParseMode) >= (2)) && ((iCol) > (0)))
							{
								resolveOrderByTermToExprList(pParse, pSelect, pE);
							}
						}

						sqlite3ExprDelete(db, pDup);
					}
				}

				if ((iCol) > (0))
				{
					if (!((pParse.eParseMode) >= (2)))
					{
						Expr pNew = sqlite3Expr(db, (int)(155), null);
						if ((pNew) == (null))
							return (int)(1);
						pNew.flags |= (uint)(0x000400);
						pNew.u.iValue = (int)(iCol);
						if ((pItem->pExpr) == (pE))
						{
							pItem->pExpr = pNew;
						}
						else
						{
							Expr pParent = pItem->pExpr;
							while ((pParent.pLeft.op) == (113))
							{
								pParent = pParent.pLeft;
							}

							pParent.pLeft = pNew;
						}

						sqlite3ExprDelete(db, pE);
						pItem->u.x.iOrderByCol = ((ushort)(iCol));
					}

					pItem->done = (uint)(1);
				}
				else
				{
					moreToDo = (int)(1);
				}
			}

			pSelect = pSelect.pNext;
		}

		for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
		{
			if ((pOrderBy.a[i].done) == (0))
			{
				sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any column in the result set", (int)(i + 1));
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static int resolveFromTermToCte(Parse pParse, Walker pWalker, SrcItem pFrom)
	{
		Cte pCte;
		With pWith;
		if ((pParse.pWith) == (null))
		{
			return (int)(0);
		}

		if ((pParse.nErr) != 0)
		{
			return (int)(0);
		}

		if (pFrom.zDatabase != null)
		{
			return (int)(0);
		}

		if ((pFrom.fg.notCte) != 0)
		{
			return (int)(0);
		}

		pCte = searchWith(pParse.pWith, pFrom, pWith);
		if ((pCte) != null)
		{
			sqlite3 db = pParse.db;
			Table pTab;
			ExprList pEList;
			Select pSel;
			Select pLeft;
			Select pRecTerm;
			int bMayRecursive = 0;
			With pSavedWith;
			int iRecTab = (int)(-1);
			CteUse* pCteUse;
			if ((pCte.zCteErr) != null)
			{
				sqlite3ErrorMsg(pParse, pCte.zCteErr, pCte.zName);
				return (int)(2);
			}

			if ((cannotBeFunction(pParse, pFrom)) != 0)
				return (int)(2);
			pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
			if ((pTab) == (null))
				return (int)(2);
			pCteUse = pCte.pUse;
			if ((pCteUse) == (null))
			{
				pCte.pUse = pCteUse = sqlite3DbMallocZero(db, (ulong)(sizeof(CteUse)));
				if (((pCteUse) == (null)) || ((sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pCteUse)) == (null)))
				{
					sqlite3DbFree(db, pTab);
					return (int)(2);
				}

				pCteUse->eM10d = (byte)(pCte.eM10d);
			}

			pFrom.pTab = pTab;
			pTab.nTabRef = (uint)(1);
			pTab.zName = sqlite3DbStrDup(db, pCte.zName);
			pTab.iPKey = (short)(-1);
			pTab.nRowLogEst = (short)(200);
			pTab.tabFlags |= (uint)(0x00004000 | 0x00000200);
			pFrom.pSelect = sqlite3SelectDup(db, pCte.pSelect, (int)(0));
			if ((db.mallocFailed) != 0)
				return (int)(2);
			pFrom.pSelect.selFlags |= (uint)(0x4000000);
			if ((pFrom.fg.isIndexedBy) != 0)
			{
				sqlite3ErrorMsg(pParse, "no such index: \"%s\"", pFrom.u1.zIndexedBy);
				return (int)(2);
			}

			pFrom.fg.isCte = (uint)(1);
			pFrom.u2.pCteUse = pCteUse;
			pCteUse->nUse++;
			if (((pCteUse->nUse) >= (2)) && ((pCteUse->eM10d) == (1)))
			{
				pCteUse->eM10d = (byte)(0);
			}

			pRecTerm = pSel = pFrom.pSelect;
			bMayRecursive = (int)(((pSel.op) == (135)) || ((pSel.op) == (134)) ? 1 : 0);
			while (((bMayRecursive) != 0) && ((pRecTerm.op) == (pSel.op)))
			{
				int i = 0;
				SrcList pSrc = pRecTerm.pSrc;
				for (i = (int)(0); (i) < (pSrc.nSrc); i++)
				{
					SrcItem pItem = pSrc.a[i];
					if ((((pItem.zDatabase) == (null)) && (pItem.zName != null)) && ((0) == (sqlite3StrICmp(pItem.zName, pCte.zName))))
					{
						pItem.pTab = pTab;
						pTab.nTabRef++;
						pItem.fg.isRecursive = (uint)(1);
						if ((pRecTerm.selFlags & 0x0002000) != 0)
						{
							sqlite3ErrorMsg(pParse, "multiple references to recursive table: %s", pCte.zName);
							return (int)(2);
						}

						pRecTerm.selFlags |= (uint)(0x0002000);
						if ((iRecTab) < (0))
							iRecTab = (int)(pParse.nTab++);
						pItem.iCursor = (int)(iRecTab);
					}
				}

				if ((pRecTerm.selFlags & 0x0002000) == (0))
					break;
				pRecTerm = pRecTerm.pPrior;
			}

			pCte.zCteErr = "circular reference: %s";
			pSavedWith = pParse.pWith;
			pParse.pWith = pWith;
			if ((pSel.selFlags & 0x0002000) != 0)
			{
				int rc = 0;
				pRecTerm.pWith = pSel.pWith;
				rc = (int)(sqlite3WalkSelect(pWalker, pRecTerm));
				pRecTerm.pWith = null;
				if ((rc) != 0)
				{
					pParse.pWith = pSavedWith;
					return (int)(2);
				}
			}
			else
			{
				if ((sqlite3WalkSelect(pWalker, pSel)) != 0)
				{
					pParse.pWith = pSavedWith;
					return (int)(2);
				}
			}

			pParse.pWith = pWith;
			for (pLeft = pSel; pLeft.pPrior; pLeft = pLeft.pPrior)
			{
			}

			pEList = pLeft.pEList;
			if ((pCte.pCols) != null)
			{
				if (((pEList) != null) && (pEList.nExpr != pCte.pCols.nExpr))
				{
					sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns", pCte.zName, (int)(pEList.nExpr), (int)(pCte.pCols.nExpr));
					pParse.pWith = pSavedWith;
					return (int)(2);
				}

				pEList = pCte.pCols;
			}

			sqlite3ColumnsFromExprList(pParse, pEList, &pTab.nCol, &pTab.aCol);
			if ((bMayRecursive) != 0)
			{
				if ((pSel.selFlags & 0x0002000) != 0)
				{
					pCte.zCteErr = "multiple recursive references: %s";
				}
				else
				{
					pCte.zCteErr = "recursive reference in a subquery: %s";
				}

				sqlite3WalkSelect(pWalker, pSel);
			}

			pCte.zCteErr = null;
			pParse.pWith = pSavedWith;
			return (int)(1);
		}

		return (int)(0);
	}
	public static int resolveOrderByTermToExprList(Parse pParse, Select pSelect, Expr pE)
	{
		int i = 0;
		ExprList pEList;
		NameContext nc = new NameContext();
		sqlite3 db;
		int rc = 0;
		byte savedSuppErr = 0;
		pEList = pSelect.pEList;
		CRuntime.memset(nc, (int)(0), (ulong)(sizeof(NameContext)));
		nc.pParse = pParse;
		nc.pSrcList = pSelect.pSrc;
		nc.uNC.pEList = pEList;
		nc.ncFlags = (int)(0x000001 | 0x000080 | 0x080000);
		nc.nNcErr = (int)(0);
		db = pParse.db;
		savedSuppErr = (byte)(db.suppressErr);
		db.suppressErr = (byte)(1);
		rc = (int)(sqlite3ResolveExprNames(nc, pE));
		db.suppressErr = (byte)(savedSuppErr);
		if ((rc) != 0)
			return (int)(0);
		for (i = (int)(0); (i) < (pEList.nExpr); i++)
		{
			if ((sqlite3ExprCompare(null, pEList.a[i].pExpr, pE, (int)(-1))) < (2))
			{
				return (int)(i + 1);
			}
		}

		return (int)(0);
	}
	public static void resolveOutOfRangeError(Parse pParse, sbyte* zType, int i, int mx, Expr pError)
	{
		sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be between 1 and %d", (int)(i), zType, (int)(mx));
		sqlite3RecordErrorOffsetOfExpr(pParse.db, pError);
	}
	public static void schemaIsValid(Parse pParse)
	{
		sqlite3 db = pParse.db;
		int iDb = 0;
		int rc = 0;
		int cookie = 0;
		for (iDb = (int)(0); (iDb) < (db.nDb); iDb++)
		{
			int openedTransaction = (int)(0);
			Btree pBt = db.aDb[iDb].pBt;
			if ((pBt) == (null))
				continue;
			if ((sqlite3BtreeTxnState(pBt)) == (0))
			{
				rc = (int)(sqlite3BtreeBeginTrans(pBt, (int)(0), null));
				if (((rc) == (7)) || ((rc) == (10 | (12 << 8))))
				{
					sqlite3OomFault(db);
					pParse.rc = (int)(7);
				}

				if (rc != 0)
					return;
				openedTransaction = (int)(1);
			}

			sqlite3BtreeGetMeta(pBt, (int)(1), (uint*)(&cookie));
			if (cookie != db.aDb[iDb].pSchema.schema_cookie)
			{
				sqlite3ResetOneSchema(db, (int)(iDb));
				pParse.rc = (int)(17);
			}

			if ((openedTransaction) != 0)
			{
				sqlite3BtreeCommit(pBt);
			}
		}
	}
	public static void selectInnerLoop(Parse pParse, Select p, int srcTab, SortCtx pSort, DistinctCtx* pDistinct, SelectDest pDest, int iContinue, int iBreak)
	{
		Vdbe v = pParse.pVdbe;
		int i = 0;
		int hasDistinct = 0;
		int eDest = (int)(pDest.eDest);
		int iParm = (int)(pDest.iSDParm);
		int nResultCol = 0;
		int nPrefixReg = (int)(0);
		RowLoadInfo sRowLoadInfo = new RowLoadInfo();
		int regResult = 0;
		int regOrig = 0;
		hasDistinct = (int)(pDistinct ? pDistinct->eTnctType : 0);
		if (((pSort) != null) && ((pSort.pOrderBy) == (null)))
			pSort = null;
		if (((pSort) == (null)) && (hasDistinct == 0))
		{
			codeOffset(v, (int)(p.iOffset), (int)(iContinue));
		}

		nResultCol = (int)(p.pEList.nExpr);
		if ((pDest.iSdst) == (0))
		{
			if ((pSort) != null)
			{
				nPrefixReg = (int)(pSort.pOrderBy.nExpr);
				if ((pSort.sortFlags & 0x01) == 0)
					nPrefixReg++;
				pParse.nMem += (int)(nPrefixReg);
			}

			pDest.iSdst = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nResultCol);
		}
		else if ((pDest.iSdst + nResultCol) > (pParse.nMem))
		{
			pParse.nMem += (int)(nResultCol);
		}

		pDest.nSdst = (int)(nResultCol);
		regOrig = (int)(regResult = (int)(pDest.iSdst));
		if ((srcTab) >= (0))
		{
			for (i = (int)(0); (i) < (nResultCol); i++)
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(i), (int)(regResult + i));
			}
		}
		else if (eDest != 3)
		{
			byte ecelFlags = 0;
			ExprList pEList;
			if ((((eDest) == (10)) || ((eDest) == (9))) || ((eDest) == (13)))
			{
				ecelFlags = (byte)(0x01);
			}
			else
			{
				ecelFlags = (byte)(0);
			}

			if (((((pSort) != null) && ((hasDistinct) == (0))) && (eDest != 12)) && (eDest != 14))
			{
				ecelFlags |= (byte)(0x08 | 0x04);
				for (i = (int)(pSort.nOBSat); (i) < (pSort.pOrderBy.nExpr); i++)
				{
					int j = 0;
					if ((j = (int)(pSort.pOrderBy.a[i].u.x.iOrderByCol)) > (0))
					{
						p.pEList.a[j - 1].u.x.iOrderByCol = (ushort)(i + 1 - pSort.nOBSat);
					}
				}

				pEList = p.pEList;
				for (i = (int)(0); (i) < (pEList.nExpr); i++)
				{
					if ((pEList.a[i].u.x.iOrderByCol) > (0))
					{
						nResultCol--;
						regOrig = (int)(0);
					}
				}
			}

			sRowLoadInfo.regResult = (int)(regResult);
			sRowLoadInfo.ecelFlags = (byte)(ecelFlags);
			if ((((p.iLimit) != 0) && ((ecelFlags & 0x08) != 0)) && ((nPrefixReg) > (0)))
			{
				pSort.pDeferredRowLoad = &sRowLoadInfo;
				regOrig = (int)(0);
			}
			else
			{
				innerLoopLoadRow(pParse, p, &sRowLoadInfo);
			}
		}

		if ((hasDistinct) != 0)
		{
			int eType = (int)(pDistinct->eTnctType);
			int iTab = (int)(pDistinct->tabTnct);
			iTab = (int)(codeDistinct(pParse, (int)(eType), (int)(iTab), (int)(iContinue), p.pEList, (int)(regResult)));
			fixDistinctOpenEph(pParse, (int)(eType), (int)(iTab), (int)(pDistinct->addrTnct));
			if ((pSort) == (null))
			{
				codeOffset(v, (int)(p.iOffset), (int)(iContinue));
			}
		}

		switch (eDest)
		{
			case 1:
				{
					int r1 = 0;
					r1 = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(nResultCol));
					sqlite3ReleaseTempReg(pParse, (int)(r1));
					break;
				}

			case 2:
				{
					sqlite3VdbeAddOp3(v, (int)(139), (int)(iParm), (int)(regResult), (int)(nResultCol));
					break;
				}

			case 8:
			case 5:
			case 14:
			case 12:
				{
					int r1 = (int)(sqlite3GetTempRange(pParse, (int)(nPrefixReg + 1)));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1 + nPrefixReg));
					if ((eDest) == (5))
					{
						int addr = (int)(sqlite3VdbeCurrentAddr(v) + 4);
						sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iParm + 1), (int)(addr), (int)(r1), (int)(0));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm + 1), (int)(r1), (int)(regResult), (int)(nResultCol));
					}

					if ((pSort) != null)
					{
						pushOntoSorter(pParse, pSort, p, (int)(r1 + nPrefixReg), (int)(regOrig), (int)(1), (int)(nPrefixReg));
					}
					else
					{
						int r2 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp2(v, (int)(126), (int)(iParm), (int)(r2));
						sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(r2));
						sqlite3VdbeChangeP5(v, (ushort)(0x08));
						sqlite3ReleaseTempReg(pParse, (int)(r2));
					}

					sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(nPrefixReg + 1));
					break;
				}

			case 15:
				{
					if ((pSort) != null)
					{
						pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
					}
					else
					{
						int i2 = (int)(pDest.iSDParm2);
						int r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp2(v, (int)(50), (int)(regResult), (int)(iBreak));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult + ((i2) < (0))), (int)(nResultCol - ((i2) < (0))), (int)(r1));
						if ((i2) < (0))
						{
							sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(regResult));
						}
						else
						{
							sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(i2));
						}
					}

					break;
				}

			case 11:
				{
					if ((pSort) != null)
					{
						pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
					}
					else
					{
						int r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp4(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1), pDest.zAffSdst, (int)(nResultCol));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(nResultCol));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
					}

					break;
				}

			case 3:
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iParm));
					break;
				}

			case 10:
				{
					if ((pSort) != null)
					{
						pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
					}
					else
					{
					}

					break;
				}

			case 13:
			case 9:
				{
					if ((pSort) != null)
					{
						pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
					}
					else if ((eDest) == (13))
					{
						sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(83), (int)(regResult), (int)(nResultCol));
					}

					break;
				}

			case 6:
			case 7:
				{
					int nKey = 0;
					int r1 = 0;
					int r2 = 0;
					int r3 = 0;
					int addrTest = (int)(0);
					ExprList pSO;
					pSO = pDest.pOrderBy;
					nKey = (int)(pSO.nExpr);
					r1 = (int)(sqlite3GetTempReg(pParse));
					r2 = (int)(sqlite3GetTempRange(pParse, (int)(nKey + 2)));
					r3 = (int)(r2 + nKey + 1);
					if ((eDest) == (6))
					{
						addrTest = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iParm + 1), (int)(0), (int)(regResult), (int)(nResultCol)));
					}

					sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r3));
					if ((eDest) == (6))
					{
						sqlite3VdbeAddOp2(v, (int)(137), (int)(iParm + 1), (int)(r3));
						sqlite3VdbeChangeP5(v, (ushort)(0x10));
					}

					for (i = (int)(0); (i) < (nKey); i++)
					{
						sqlite3VdbeAddOp2(v, (int)(80), (int)(regResult + pSO.a[i].u.x.iOrderByCol - 1), (int)(r2 + i));
					}

					sqlite3VdbeAddOp2(v, (int)(125), (int)(iParm), (int)(r2 + nKey));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(r2), (int)(nKey + 2), (int)(r1));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(r2), (int)(nKey + 2));
					if ((addrTest) != 0)
						sqlite3VdbeJumpHere(v, (int)(addrTest));
					sqlite3ReleaseTempReg(pParse, (int)(r1));
					sqlite3ReleaseTempRange(pParse, (int)(r2), (int)(nKey + 2));
					break;
				}

			default:
				{
					break;
				}
		}

		if (((pSort) == (null)) && ((p.iLimit) != 0))
		{
			sqlite3VdbeAddOp2(v, (int)(60), (int)(p.iLimit), (int)(iBreak));
		}
	}
	public static void selectWindowRewriteEList(Parse pParse, Window pWin, SrcList pSrc, ExprList pEList, Table pTab, ExprList ppSub)
	{
		Walker sWalker = new Walker();
		WindowRewrite sRewrite = new WindowRewrite();
		CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
		CRuntime.memset(sRewrite, (int)(0), (ulong)(sizeof(WindowRewrite)));
		sRewrite.pSub = ppSub;
		sRewrite.pWin = pWin;
		sRewrite.pSrc = pSrc;
		sRewrite.pTab = pTab;
		sWalker.pParse = pParse;
		sWalker.xExprCallback = selectWindowRewriteExprCb;
		sWalker.xSelectCallback = selectWindowRewriteSelectCb;
		sWalker.u.pRewrite = sRewrite;
		(void)(sqlite3WalkExprList(sWalker, pEList));
		ppSub = sRewrite.pSub;
	}
	public static void sqlite3AddCheckConstraint(Parse pParse, Expr pCheckExpr, sbyte* zStart, sbyte* zEnd)
	{
		Table pTab = pParse.pNewTable;
		sqlite3 db = pParse.db;
		if ((((pTab) != null) && (!((pParse.eParseMode) == (1)))) && (sqlite3BtreeIsReadonly(db.aDb[db.init.iDb].pBt) == 0))
		{
			pTab.pCheck = sqlite3ExprListAppend(pParse, pTab.pCheck, pCheckExpr);
			if ((pParse.constraintName.n) != 0)
			{
				sqlite3ExprListSetName(pParse, pTab.pCheck, &pParse.constraintName, (int)(1));
			}
			else
			{
				Token t = new Token();
				for (zStart++; (sqlite3CtypeMap[(byte)(zStart[0])] & 0x01); zStart++)
				{
				}

				while ((sqlite3CtypeMap[(byte)(zEnd[-1])] & 0x01) != 0)
				{
					zEnd--;
				}

				t.z = zStart;
				t.n = (uint)((int)(zEnd - t.z));
				sqlite3ExprListSetName(pParse, pTab.pCheck, &t, (int)(1));
			}
		}
		else
		{
			sqlite3ExprDelete(pParse.db, pCheckExpr);
		}
	}
	public static void sqlite3AddCollateType(Parse pParse, Token* pToken)
	{
		Table p;
		int i = 0;
		sbyte* zColl;
		sqlite3 db;
		if (((p = pParse.pNewTable) == (null)) || ((pParse.eParseMode) >= (2)))
			return;
		i = (int)(p.nCol - 1);
		db = pParse.db;
		zColl = sqlite3NameFromToken(db, pToken);
		if (zColl == null)
			return;
		if ((sqlite3LocateCollSeq(pParse, zColl)) != null)
		{
			Index pIdx;
			sqlite3ColumnSetColl(db, &p.aCol[i], zColl);
			for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				if ((pIdx.aiColumn[0]) == (i))
				{
					pIdx.azColl[0] = sqlite3ColumnColl(&p.aCol[i]);
				}
			}
		}

		sqlite3DbFree(db, zColl);
	}
	public static void sqlite3AddColumn(Parse pParse, Token sName, Token sType)
	{
		Table p;
		int i = 0;
		sbyte* z;
		sbyte* zType;
		Column* pCol;
		sqlite3 db = pParse.db;
		byte hName = 0;
		Column* aNew;
		byte eType = (byte)(0);
		byte szEst = (byte)(1);
		sbyte affinity = (sbyte)(0x41);
		if ((p = pParse.pNewTable) == (null))
			return;
		if ((p.nCol + 1) > (db.aLimit[2]))
		{
			sqlite3ErrorMsg(pParse, "too many columns on %s", p.zName);
			return;
		}

		if (!((pParse.eParseMode) >= (2)))
			sqlite3DequoteToken(&sName);
		if (((sType.n) >= (16)) && ((sqlite3_strnicmp(sType.z + (sType.n - 6), "always", (int)(6))) == (0)))
		{
			sType.n -= (uint)(6);
			while (((sType.n) > (0)) && ((sqlite3CtypeMap[(byte)(sType.z[sType.n - 1])] & 0x01) != 0))
			{
				sType.n--;
			}

			if (((sType.n) >= (9)) && ((sqlite3_strnicmp(sType.z + (sType.n - 9), "generated", (int)(9))) == (0)))
			{
				sType.n -= (uint)(9);
				while (((sType.n) > (0)) && ((sqlite3CtypeMap[(byte)(sType.z[sType.n - 1])] & 0x01) != 0))
				{
					sType.n--;
				}
			}
		}

		if ((sType.n) >= (3))
		{
			sqlite3DequoteToken(&sType);
			for (i = (int)(0); (i) < (6); i++)
			{
				if (((sType.n) == (sqlite3StdTypeLen[i])) && ((sqlite3_strnicmp(sType.z, sqlite3StdType[i], (int)(sType.n))) == (0)))
				{
					sType.n = (uint)(0);
					eType = (byte)(i + 1);
					affinity = (sbyte)(sqlite3StdTypeAffinity[i]);
					if ((affinity) <= (0x42))
						szEst = (byte)(5);
					break;
				}
			}
		}

		z = sqlite3DbMallocRaw(db, (ulong)((long)(sName.n) + 1 + (long)(sType.n) + ((sType.n) > (0))));
		if ((z) == (null))
			return;
		if (((pParse.eParseMode) >= (2)))
			sqlite3RenameTokenMap(pParse, (void*)(z), &sName);
		CRuntime.memcpy(z, sName.z, (ulong)(sName.n));
		z[sName.n] = (sbyte)(0);
		sqlite3Dequote(z);
		hName = (byte)(sqlite3StrIHash(z));
		for (i = (int)(0); (i) < (p.nCol); i++)
		{
			if (((p.aCol[i].hName) == (hName)) && ((sqlite3StrICmp(z, p.aCol[i].zCnName)) == (0)))
			{
				sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
				sqlite3DbFree(db, z);
				return;
			}
		}

		aNew = sqlite3DbRealloc(db, p.aCol, (ulong)(((long)(p.nCol) + 1) * sizeof(Column)));
		if ((aNew) == (null))
		{
			sqlite3DbFree(db, z);
			return;
		}

		p.aCol = aNew;
		pCol = &p.aCol[p.nCol];
		CRuntime.memset(pCol, (int)(0), (ulong)(sizeof(Column)));
		pCol->zCnName = z;
		pCol->hName = (byte)(hName);
		if ((sType.n) == (0))
		{
			pCol->affinity = (sbyte)(affinity);
			pCol->eCType = (uint)(eType);
			pCol->szEst = (byte)(szEst);
		}
		else
		{
			zType = z + sqlite3Strlen30(z) + 1;
			CRuntime.memcpy(zType, sType.z, (ulong)(sType.n));
			zType[sType.n] = (sbyte)(0);
			sqlite3Dequote(zType);
			pCol->affinity = (sbyte)(sqlite3AffinityType(zType, pCol));
			pCol->colFlags |= (ushort)(0x0004);
		}

		p.nCol++;
		p.nNVCol++;
		pParse.constraintName.n = (uint)(0);
	}
	public static void sqlite3AddDefaultValue(Parse pParse, Expr pExpr, sbyte* zStart, sbyte* zEnd)
	{
		Table p;
		Column* pCol;
		sqlite3 db = pParse.db;
		p = pParse.pNewTable;
		if (p != null)
		{
			int isInit = (int)(((db.init.busy) != 0) && (db.init.iDb != 1) ? 1 : 0);
			pCol = &(p.aCol[p.nCol - 1]);
			if (sqlite3ExprIsConstantOrFunction(pExpr, (byte)(isInit)) == 0)
			{
				sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", pCol->zCnName);
			}
			else if ((pCol->colFlags & 0x0060) != 0)
			{
				sqlite3ErrorMsg(pParse, "cannot use DEFAULT on a generated column");
			}
			else
			{
				Expr x = new Expr();
				Expr pDfltExpr;
				CRuntime.memset(x, (int)(0), (ulong)(sizeof(Expr)));
				x.op = (byte)(181);
				x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
				x.pLeft = pExpr;
				x.flags = (uint)(0x001000);
				pDfltExpr = sqlite3ExprDup(db, x, (int)(0x0001));
				sqlite3DbFree(db, x.u.zToken);
				sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr);
			}
		}

		if (((pParse.eParseMode) >= (2)))
		{
			sqlite3RenameExprUnmap(pParse, pExpr);
		}

		sqlite3ExprDelete(db, pExpr);
	}
	public static void sqlite3AddGenerated(Parse pParse, Expr pExpr, Token* pType)
	{
		byte eType = (byte)(0x0020);
		Table pTab = pParse.pNewTable;
		Column* pCol;
		if ((pTab) == (null))
		{
			goto generated_done;
		}

		pCol = &(pTab.aCol[pTab.nCol - 1]);
		if (((pParse.eParseMode) == (1)))
		{
			sqlite3ErrorMsg(pParse, "virtual tables cannot use computed columns");
			goto generated_done;
		}

		if ((pCol->iDflt) > (0))
			goto generated_error;
		if ((pType) != null)
		{
			if (((pType->n) == (7)) && ((sqlite3_strnicmp("virtual", pType->z, (int)(7))) == (0)))
			{
			}
			else if (((pType->n) == (6)) && ((sqlite3_strnicmp("stored", pType->z, (int)(6))) == (0)))
			{
				eType = (byte)(0x0040);
			}
			else
			{
				goto generated_error;
			}
		}

		if ((eType) == (0x0020))
			pTab.nNVCol--;
		pCol->colFlags |= (ushort)(eType);
		pTab.tabFlags |= (uint)(eType);
		if ((pCol->colFlags & 0x0001) != 0)
		{
			makeColumnPartOfPrimaryKey(pParse, pCol);
		}

		sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);
		pExpr = null;
		goto generated_done;
	generated_error:
		; sqlite3ErrorMsg(pParse, "error in generated column \"%s\"", pCol->zCnName);
	generated_done:
		; sqlite3ExprDelete(pParse.db, pExpr);
	}
	public static void sqlite3AddNotNull(Parse pParse, int onError)
	{
		Table p;
		Column* pCol;
		p = pParse.pNewTable;
		if (((p) == (null)) || ((p.nCol) < (1)))
			return;
		pCol = &p.aCol[p.nCol - 1];
		pCol->notNull = (uint)((byte)(onError));
		p.tabFlags |= (uint)(0x00000800);
		if ((pCol->colFlags & 0x0008) != 0)
		{
			Index pIdx;
			for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				if ((pIdx.aiColumn[0]) == (p.nCol - 1))
				{
					pIdx.uniqNotNull = (uint)(1);
				}
			}
		}
	}
	public static void sqlite3AddPrimaryKey(Parse pParse, ExprList pList, int onError, int autoInc, int sortOrder)
	{
		Table pTab = pParse.pNewTable;
		Column* pCol = null;
		int iCol = (int)(-1); int i = 0;
		int nTerm = 0;
		if ((pTab) == (null))
			goto primary_key_exit;
		if ((pTab.tabFlags & 0x00000004) != 0)
		{
			sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", pTab.zName);
			goto primary_key_exit;
		}

		pTab.tabFlags |= (uint)(0x00000004);
		if ((pList) == (null))
		{
			iCol = (int)(pTab.nCol - 1);
			pCol = &pTab.aCol[iCol];
			makeColumnPartOfPrimaryKey(pParse, pCol);
			nTerm = (int)(1);
		}
		else
		{
			nTerm = (int)(pList.nExpr);
			for (i = (int)(0); (i) < (nTerm); i++)
			{
				Expr pCExpr = sqlite3ExprSkipCollate(pList.a[i].pExpr);
				sqlite3StringToId(pCExpr);
				if ((pCExpr.op) == (59))
				{
					sbyte* zCName;
					zCName = pCExpr.u.zToken;
					for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
					{
						if ((sqlite3StrICmp(zCName, pTab.aCol[iCol].zCnName)) == (0))
						{
							pCol = &pTab.aCol[iCol];
							makeColumnPartOfPrimaryKey(pParse, pCol);
							break;
						}
					}
				}
			}
		}

		if (((((nTerm) == (1)) && ((pCol) != null)) && ((pCol->eCType) == (4))) && (sortOrder != 1))
		{
			if (((pParse.eParseMode) >= (2)) && ((pList) != null))
			{
				Expr pCExpr = sqlite3ExprSkipCollate(pList.a[0].pExpr);
				sqlite3RenameTokenRemap(pParse, &pTab.iPKey, pCExpr);
			}

			pTab.iPKey = (short)(iCol);
			pTab.keyConf = ((byte)(onError));
			pTab.tabFlags |= (uint)(autoInc * 0x00000008);
			if ((pList) != null)
				pParse.iPkSortOrder = (byte)(pList.a[0].sortFlags);
			(void)(sqlite3HasExplicitNulls(pParse, pList));
		}
		else if ((autoInc) != 0)
		{
			sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY");
		}
		else
		{
			sqlite3CreateIndex(pParse, null, null, null, pList, (int)(onError), null, null, (int)(sortOrder), (int)(0), (byte)(2));
			pList = null;
		}

	primary_key_exit:
		; sqlite3ExprListDelete(pParse.db, pList);
		return;
	}
	public static void sqlite3AddReturning(Parse pParse, ExprList pList)
	{
		Returning pRet;
		Hash* pHash;
		sqlite3 db = pParse.db;
		if ((pParse.pNewTrigger) != null)
		{
			sqlite3ErrorMsg(pParse, "cannot use RETURNING in a trigger");
		}
		else
		{
		}

		pParse.bReturning = (byte)(1);
		pRet = sqlite3DbMallocZero(db, (ulong)(sizeof(Returning)));
		if ((pRet) == (null))
		{
			sqlite3ExprListDelete(db, pList);
			return;
		}

		pParse.u1.pReturning = pRet;
		pRet.pParse = pParse;
		pRet.pReturnEL = pList;
		sqlite3ParserAddCleanup(pParse, sqlite3DeleteReturning, pRet);
		if ((db.mallocFailed) != 0)
			return;
		pRet.retTrig.zName = "sqlite_returning";
		pRet.retTrig.op = (byte)(150);
		pRet.retTrig.tr_tm = (byte)(2);
		pRet.retTrig.bReturning = (byte)(1);
		pRet.retTrig.pSchema = db.aDb[1].pSchema;
		pRet.retTrig.pTabSchema = db.aDb[1].pSchema;
		pRet.retTrig.step_list = pRet.retTStep;
		pRet.retTStep.op = (byte)(150);
		pRet.retTStep.pTrig = pRet.retTrig;
		pRet.retTStep.pExprList = pList;
		pHash = &(db.aDb[1].pSchema.trigHash);
		if ((sqlite3HashInsert(pHash, "sqlite_returning", pRet.retTrig)) == (pRet.retTrig))
		{
			sqlite3OomFault(db);
		}
	}
	public static void sqlite3AlterBeginAddColumn(Parse pParse, SrcList pSrc)
	{
		Table pNew;
		Table pTab;
		int iDb = 0;
		int i = 0;
		int nAlloc = 0;
		sqlite3 db = pParse.db;
		if ((db.mallocFailed) != 0)
			goto exit_begin_add_column;
		pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
		if (pTab == null)
			goto exit_begin_add_column;
		if ((((pTab).eTabType) == (1)))
		{
			sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
			goto exit_begin_add_column;
		}

		if ((((pTab).eTabType) == (2)))
		{
			sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
			goto exit_begin_add_column;
		}

		if (0 != isAlterableTable(pParse, pTab))
		{
			goto exit_begin_add_column;
		}

		sqlite3MayAbort(pParse);
		iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		pNew = (Table)(sqlite3DbMallocZero(db, (ulong)(sizeof(Table))));
		if (pNew == null)
			goto exit_begin_add_column;
		pParse.pNewTable = pNew;
		pNew.nTabRef = (uint)(1);
		pNew.nCol = (short)(pTab.nCol);
		nAlloc = (int)((((pNew.nCol - 1) / 8) * 8) + 8);
		pNew.aCol = (Column*)(sqlite3DbMallocZero(db, (ulong)(sizeof(Column) * nAlloc)));
		pNew.zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab.zName);
		if ((pNew.aCol == null) || (pNew.zName == null))
		{
			goto exit_begin_add_column;
		}

		CRuntime.memcpy(pNew.aCol, pTab.aCol, (ulong)(sizeof(Column) * pNew.nCol));
		for (i = (int)(0); (i) < (pNew.nCol); i++)
		{
			Column* pCol = &pNew.aCol[i];
			pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);
			pCol->hName = (byte)(sqlite3StrIHash(pCol->zCnName));
		}

		pNew.u.tab.pDfltList = sqlite3ExprListDup(db, pTab.u.tab.pDfltList, (int)(0));
		pNew.pSchema = db.aDb[iDb].pSchema;
		pNew.u.tab.addColOffset = (int)(pTab.u.tab.addColOffset);
		pNew.nTabRef = (uint)(1);
	exit_begin_add_column:
		; sqlite3SrcListDelete(db, pSrc);
		return;
	}
	public static void sqlite3AlterDropColumn(Parse pParse, SrcList pSrc, Token* pName)
	{
		sqlite3 db = pParse.db;
		Table pTab;
		int iDb = 0;
		sbyte* zDb;
		sbyte* zCol = null;
		int iCol = 0;
		if ((db.mallocFailed) != 0)
			goto exit_drop_column;
		pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
		if (pTab == null)
			goto exit_drop_column;
		if (0 != isAlterableTable(pParse, pTab))
			goto exit_drop_column;
		if (0 != isRealTable(pParse, pTab, (int)(1)))
			goto exit_drop_column;
		zCol = sqlite3NameFromToken(db, pName);
		if ((zCol) == (null))
		{
			goto exit_drop_column;
		}

		iCol = (int)(sqlite3ColumnIndex(pTab, zCol));
		if ((iCol) < (0))
		{
			sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pName);
			goto exit_drop_column;
		}

		if ((pTab.aCol[iCol].colFlags & (0x0001 | 0x0008)) != 0)
		{
			sqlite3ErrorMsg(pParse, "cannot drop %s column: \"%s\"", (pTab.aCol[iCol].colFlags & 0x0001) ? "PRIMARY KEY" : "UNIQUE", zCol);
			goto exit_drop_column;
		}

		if ((pTab.nCol) <= (1))
		{
			sqlite3ErrorMsg(pParse, "cannot drop column \"%s\": no other columns exist", zCol);
			goto exit_drop_column;
		}

		iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		zDb = db.aDb[iDb].zDbSName;
		if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, zCol)) != 0)
		{
			goto exit_drop_column;
		}

		renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "", (int)(0));
		renameFixQuotes(pParse, zDb, ((iDb) == (1) ? 1 : 0));
		sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_drop_column(%d, sql, %d) WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)", zDb, (int)(iDb), (int)(iCol), pTab.zName);
		renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0002));
		renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "after drop column", (int)(1));
		if (((pParse.nErr) == (0)) && ((pTab.aCol[iCol].colFlags & 0x0020) == (0)))
		{
			int i = 0;
			int addr = 0;
			int reg = 0;
			int regRec = 0;
			Index pPk = null;
			int nField = (int)(0);
			int iCur = 0;
			Vdbe v = sqlite3GetVdbe(pParse);
			iCur = (int)(pParse.nTab++);
			sqlite3OpenTable(pParse, (int)(iCur), (int)(iDb), pTab, (int)(112));
			addr = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
			reg = (int)(++pParse.nMem);
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(reg));
				pParse.nMem += (int)(pTab.nCol);
			}
			else
			{
				pPk = sqlite3PrimaryKeyIndex(pTab);
				pParse.nMem += (int)(pPk.nColumn);
				for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(i), (int)(reg + i + 1));
				}

				nField = (int)(pPk.nKeyCol);
			}

			regRec = (int)(++pParse.nMem);
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((i != iCol) && ((pTab.aCol[i].colFlags & 0x0020) == (0)))
				{
					int regOut = 0;
					if ((pPk) != null)
					{
						int iPos = (int)(sqlite3TableColumnToIndex(pPk, (short)(i)));
						int iColPos = (int)(sqlite3TableColumnToIndex(pPk, (short)(iCol)));
						if ((iPos) < (pPk.nKeyCol))
							continue;
						regOut = (int)(reg + 1 + iPos - ((iPos) > (iColPos)));
					}
					else
					{
						regOut = (int)(reg + 1 + nField);
					}

					if ((i) == (pTab.iPKey))
					{
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regOut));
					}
					else
					{
						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(i), (int)(regOut));
					}

					nField++;
				}
			}

			if ((nField) == (0))
			{
				pParse.nMem++;
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(reg + 1));
				nField = (int)(1);
			}

			sqlite3VdbeAddOp3(v, (int)(96), (int)(reg + 1), (int)(nField), (int)(regRec));
			if ((pPk) != null)
			{
				sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iCur), (int)(regRec), (int)(reg + 1), (int)(pPk.nKeyCol));
			}
			else
			{
				sqlite3VdbeAddOp3(v, (int)(127), (int)(iCur), (int)(regRec), (int)(reg));
			}

			sqlite3VdbeChangeP5(v, (ushort)(0x02));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iCur), (int)(addr + 1));
			sqlite3VdbeJumpHere(v, (int)(addr));
		}

	exit_drop_column:
		; sqlite3DbFree(db, zCol);
		sqlite3SrcListDelete(db, pSrc);
	}
	public static void sqlite3AlterFinishAddColumn(Parse pParse, Token* pColDef)
	{
		Table pNew;
		Table pTab;
		int iDb = 0;
		sbyte* zDb;
		sbyte* zTab;
		sbyte* zCol;
		Column* pCol;
		Expr pDflt;
		sqlite3 db;
		Vdbe v;
		int r1 = 0;
		db = pParse.db;
		if ((pParse.nErr) != 0)
			return;
		pNew = pParse.pNewTable;
		iDb = (int)(sqlite3SchemaToIndex(db, pNew.pSchema));
		zDb = db.aDb[iDb].zDbSName;
		zTab = &pNew.zName[16];
		pCol = &pNew.aCol[pNew.nCol - 1];
		pDflt = sqlite3ColumnExpr(pNew, pCol);
		pTab = sqlite3FindTable(db, zTab, zDb);
		if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
		{
			return;
		}

		if ((pCol->colFlags & 0x0001) != 0)
		{
			sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
			return;
		}

		if ((pNew.pIndex) != null)
		{
			sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
			return;
		}

		if ((pCol->colFlags & 0x0060) == (0))
		{
			if (((pDflt) != null) && ((pDflt.pLeft.op) == (121)))
			{
				pDflt = null;
			}

			if ((((db.flags & 0x00004000) != 0) && ((pNew.u.tab.pFKey) != null)) && ((pDflt) != null))
			{
				sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a REFERENCES column with non-NULL default value");
			}

			if (((pCol->notNull) != 0) && (pDflt == null))
			{
				sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a NOT NULL column with default value NULL");
			}

			if ((pDflt) != null)
			{
				sqlite3_value pVal = null;
				int rc = 0;
				rc = (int)(sqlite3ValueFromExpr(db, pDflt, (byte)(1), (byte)(0x41), pVal));
				if (rc != 0)
				{
					return;
				}

				if (pVal == null)
				{
					sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a column with non-constant default");
				}

				sqlite3ValueFree(pVal);
			}
		}
		else if ((pCol->colFlags & 0x0040) != 0)
		{
			sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "cannot add a STORED column");
		}

		zCol = sqlite3DbStrNDup(db, pColDef->z, (ulong)(pColDef->n));
		if ((zCol) != null)
		{
			sbyte* zEnd = &zCol[pColDef->n - 1];
			while (((zEnd) > (zCol)) && (((*zEnd) == (59)) || ((sqlite3CtypeMap[(byte)(*zEnd)] & 0x01) != 0)))
			{
				*zEnd-- = (sbyte)(0);
			}

			sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = printf('%%.%ds, ',sql) || %Q || substr(sql,1+length(printf('%%.%ds',sql))) WHERE type = 'table' AND name = %Q", zDb, (int)(pNew.u.tab.addColOffset), zCol, (int)(pNew.u.tab.addColOffset), zTab);
			sqlite3DbFree(db, zCol);
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) != null)
		{
			r1 = (int)(sqlite3GetTempReg(pParse));
			sqlite3VdbeAddOp3(v, (int)(98), (int)(iDb), (int)(r1), (int)(2));
			sqlite3VdbeUsesBtree(v, (int)(iDb));
			sqlite3VdbeAddOp2(v, (int)(85), (int)(r1), (int)(-2));
			sqlite3VdbeAddOp2(v, (int)(49), (int)(r1), (int)(sqlite3VdbeCurrentAddr(v) + 2));
			sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(2), (int)(3));
			sqlite3ReleaseTempReg(pParse, (int)(r1));
			renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0003));
			if ((pNew.pCheck != null) || (((pCol->notNull) != 0) && ((pCol->colFlags & 0x0060) != 0)))
			{
				sqlite3NestedParse(pParse, "SELECT CASE WHEN quick_check GLOB 'CHECK*' THEN raise(ABORT,'CHECK constraint failed') ELSE raise(ABORT,'NOT NULL constraint failed') END  FROM pragma_quick_check(%Q,%Q) WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'", zTab, zDb);
			}
		}
	}
	public static void sqlite3AlterRenameColumn(Parse pParse, SrcList pSrc, Token* pOld, Token* pNew)
	{
		sqlite3 db = pParse.db;
		Table pTab;
		int iCol = 0;
		sbyte* zOld = null;
		sbyte* zNew = null;
		sbyte* zDb;
		int iSchema = 0;
		int bQuote = 0;
		pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
		if (pTab == null)
			goto exit_rename_column;
		if (0 != isAlterableTable(pParse, pTab))
			goto exit_rename_column;
		if (0 != isRealTable(pParse, pTab, (int)(0)))
			goto exit_rename_column;
		iSchema = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		zDb = db.aDb[iSchema].zDbSName;
		if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
		{
			goto exit_rename_column;
		}

		zOld = sqlite3NameFromToken(db, pOld);
		if (zOld == null)
			goto exit_rename_column;
		for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
		{
			if ((0) == (sqlite3StrICmp(pTab.aCol[iCol].zCnName, zOld)))
				break;
		}

		if ((iCol) == (pTab.nCol))
		{
			sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pOld);
			goto exit_rename_column;
		}

		renameTestSchema(pParse, zDb, ((iSchema) == (1) ? 1 : 0), "", (int)(0));
		renameFixQuotes(pParse, zDb, ((iSchema) == (1) ? 1 : 0));
		sqlite3MayAbort(pParse);
		zNew = sqlite3NameFromToken(db, pNew);
		if (zNew == null)
			goto exit_rename_column;
		bQuote = (int)(sqlite3CtypeMap[(byte)(pNew->z[0])] & 0x80);
		sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'  AND (type != 'index' OR tbl_name = %Q)", zDb, zDb, pTab.zName, (int)(iCol), zNew, (int)(bQuote), ((iSchema) == (1) ? 1 : 0), pTab.zName);
		sqlite3NestedParse(pParse, "UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN ('trigger', 'view')", zDb, pTab.zName, (int)(iCol), zNew, (int)(bQuote));
		renameReloadSchema(pParse, (int)(iSchema), (ushort)(0x0001));
		renameTestSchema(pParse, zDb, ((iSchema) == (1) ? 1 : 0), "after rename", (int)(1));
	exit_rename_column:
		; sqlite3SrcListDelete(db, pSrc);
		sqlite3DbFree(db, zOld);
		sqlite3DbFree(db, zNew);
		return;
	}
	public static void sqlite3AlterRenameTable(Parse pParse, SrcList pSrc, Token* pName)
	{
		int iDb = 0;
		sbyte* zDb;
		Table pTab;
		sbyte* zName = null;
		sqlite3 db = pParse.db;
		int nTabName = 0;
		sbyte* zTabName;
		Vdbe v;
		VTable pVTab = null;
		if ((db.mallocFailed) != 0)
			goto exit_rename_table;
		pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
		if (pTab == null)
			goto exit_rename_table;
		iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
		zDb = db.aDb[iDb].zDbSName;
		zName = sqlite3NameFromToken(db, pName);
		if (zName == null)
			goto exit_rename_table;
		if ((((sqlite3FindTable(db, zName, zDb)) != null) || ((sqlite3FindIndex(db, zName, zDb)) != null)) || ((sqlite3IsShadowTableOf(db, pTab, zName)) != 0))
		{
			sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s", zName);
			goto exit_rename_table;
		}

		if (0 != isAlterableTable(pParse, pTab))
		{
			goto exit_rename_table;
		}

		if (0 != sqlite3CheckObjectName(pParse, zName, "table", zName))
		{
			goto exit_rename_table;
		}

		if ((((pTab).eTabType) == (2)))
		{
			sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab.zName);
			goto exit_rename_table;
		}

		if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
		{
			goto exit_rename_table;
		}

		if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
		{
			goto exit_rename_table;
		}

		if ((((pTab).eTabType) == (1)))
		{
			pVTab = sqlite3GetVTable(db, pTab);
			if ((pVTab.pVtab.pModule.xRename) == (null))
			{
				pVTab = null;
			}
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) == (null))
		{
			goto exit_rename_table;
		}

		sqlite3MayAbort(pParse);
		zTabName = pTab.zName;
		nTabName = (int)(sqlite3Utf8CharLen(zTabName, (int)(-1)));
		sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'", zDb, zDb, zTabName, zName, (((iDb) == (1)) ? 1 : 0), zTabName);
		sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X'      AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type='table' OR type='index' OR type='trigger');", zDb, zName, zName, zName, (int)(nTabName), zTabName);
		if ((sqlite3FindTable(db, "sqlite_sequence", zDb)) != null)
		{
			sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q", zDb, zName, pTab.zName);
		}

		if (iDb != 1)
		{
			sqlite3NestedParse(pParse, "UPDATE sqlite_temp_schema SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND   sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) THEN %Q ELSE tbl_name END WHERE type IN ('view', 'trigger')", zDb, zTabName, zName, zTabName, zDb, zName);
		}

		if ((pVTab) != null)
		{
			int i = (int)(++pParse.nMem);
			sqlite3VdbeLoadString(v, (int)(i), zName);
			sqlite3VdbeAddOp4(v, (int)(175), (int)(i), (int)(0), (int)(0), (sbyte*)(pVTab), (int)(-12));
		}

		renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0001));
		renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "after rename", (int)(0));
	exit_rename_table:
		; sqlite3SrcListDelete(db, pSrc);
		sqlite3DbFree(db, zName);
	}
	public static void sqlite3Analyze(Parse pParse, Token* pName1, Token* pName2)
	{
		sqlite3 db = pParse.db;
		int iDb = 0;
		int i = 0;
		sbyte* z; sbyte* zDb;
		Table pTab;
		Index pIdx;
		Token* pTableName;
		Vdbe v;
		if (0 != sqlite3ReadSchema(pParse))
		{
			return;
		}

		if ((pName1) == (null))
		{
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				if ((i) == (1))
					continue;
				analyzeDatabase(pParse, (int)(i));
			}
		}
		else if (((pName2->n) == (0)) && ((iDb = (int)(sqlite3FindDb(db, pName1))) >= (0)))
		{
			analyzeDatabase(pParse, (int)(iDb));
		}
		else
		{
			iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pTableName));
			if ((iDb) >= (0))
			{
				zDb = (pName2->n) != 0 ? db.aDb[iDb].zDbSName : null;
				z = sqlite3NameFromToken(db, pTableName);
				if ((z) != null)
				{
					if ((pIdx = sqlite3FindIndex(db, z, zDb)) != null)
					{
						analyzeTable(pParse, pIdx.pTable, pIdx);
					}
					else if ((pTab = sqlite3LocateTable(pParse, (uint)(0), z, zDb)) != null)
					{
						analyzeTable(pParse, pTab, null);
					}

					sqlite3DbFree(db, z);
				}
			}
		}

		if (((db.nSqlExec) == (0)) && ((v = sqlite3GetVdbe(pParse)) != null))
		{
			sqlite3VdbeAddOp0(v, (int)(165));
		}
	}
	public static void sqlite3Attach(Parse pParse, Expr p, Expr pDbname, Expr pKey)
	{
		codeAttach(pParse, (int)(24), sqlite3Attach_attach_func, p, p, pDbname, pKey);
	}
	public static int sqlite3AuthCheck(Parse pParse, int code, sbyte* zArg1, sbyte* zArg2, sbyte* zArg3)
	{
		sqlite3 db = pParse.db;
		int rc = 0;
		if ((((db.xAuth) == (null)) || ((db.init.busy) != 0)) || (pParse.eParseMode != 0))
		{
			return (int)(0);
		}

		rc = (int)(db.xAuth(db.pAuthArg, (int)(code), zArg1, zArg2, zArg3, pParse.zAuthContext));
		if ((rc) == (1))
		{
			sqlite3ErrorMsg(pParse, "not authorized");
			pParse.rc = (int)(23);
		}
		else if ((rc != 0) && (rc != 2))
		{
			rc = (int)(1);
			sqliteAuthBadReturnCode(pParse);
		}

		return (int)(rc);
	}
	public static void sqlite3AuthContextPush(Parse pParse, AuthContext pContext, sbyte* zContext)
	{
		pContext.pParse = pParse;
		pContext.zAuthContext = pParse.zAuthContext;
		pParse.zAuthContext = zContext;
	}
	public static void sqlite3AuthRead(Parse pParse, Expr pExpr, Schema pSchema, SrcList pTabList)
	{
		Table pTab = null;
		sbyte* zCol;
		int iSrc = 0;
		int iDb = 0;
		int iCol = 0;
		iDb = (int)(sqlite3SchemaToIndex(pParse.db, pSchema));
		if ((iDb) < (0))
		{
			return;
		}

		if ((pExpr.op) == (77))
		{
			pTab = pParse.pTriggerTab;
		}
		else
		{
			for (iSrc = (int)(0); (iSrc) < (pTabList.nSrc); iSrc++)
			{
				if ((pExpr.iTable) == (pTabList.a[iSrc].iCursor))
				{
					pTab = pTabList.a[iSrc].pTab;
					break;
				}
			}
		}

		iCol = (int)(pExpr.iColumn);
		if ((pTab) == (null))
			return;
		if ((iCol) >= (0))
		{
			zCol = pTab.aCol[iCol].zCnName;
		}
		else if ((pTab.iPKey) >= (0))
		{
			zCol = pTab.aCol[pTab.iPKey].zCnName;
		}
		else
		{
			zCol = "ROWID";
		}

		if ((2) == (sqlite3AuthReadCol(pParse, pTab.zName, zCol, (int)(iDb))))
		{
			pExpr.op = (byte)(121);
		}
	}
	public static int sqlite3AuthReadCol(Parse pParse, sbyte* zTab, sbyte* zCol, int iDb)
	{
		sqlite3 db = pParse.db;
		sbyte* zDb = db.aDb[iDb].zDbSName;
		int rc = 0;
		if ((db.init.busy) != 0)
			return (int)(0);
		rc = (int)(db.xAuth(db.pAuthArg, (int)(20), zTab, zCol, zDb, pParse.zAuthContext));
		if ((rc) == (1))
		{
			sbyte* z = sqlite3_mprintf("%s.%s", zTab, zCol);
			if (((db.nDb) > (2)) || (iDb != 0))
				z = sqlite3_mprintf("%s.%z", zDb, z);
			sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);
			pParse.rc = (int)(23);
		}
		else if ((rc != 2) && (rc != 0))
		{
			sqliteAuthBadReturnCode(pParse);
		}

		return (int)(rc);
	}
	public static void sqlite3AutoincrementBegin(Parse pParse)
	{
		AutoincInfo p;
		sqlite3 db = pParse.db;
		Db pDb;
		int memId = 0;
		Vdbe v = pParse.pVdbe;
		for (p = pParse.pAinc; p; p = p.pNext)
		{
			VdbeOp* aOp;
			pDb = db.aDb[p.iDb];
			memId = (int)(p.regCtr);
			sqlite3OpenTable(pParse, (int)(0), (int)(p.iDb), pDb.pSchema.pSeqTab, (int)(101));
			sqlite3VdbeLoadString(v, (int)(memId - 1), p.pTab.zName);
			aOp = sqlite3VdbeAddOpList(v, ((int)(12 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3AutoincrementBegin_autoInc, (int)(sqlite3AutoincrementBegin_iLn));
			if ((aOp) == (null))
				break;
			aOp[0].p2 = (int)(memId);
			aOp[0].p3 = (int)(memId + 2);
			aOp[2].p3 = (int)(memId);
			aOp[3].p1 = (int)(memId - 1);
			aOp[3].p3 = (int)(memId);
			aOp[3].p5 = (ushort)(0x10);
			aOp[4].p2 = (int)(memId + 1);
			aOp[5].p3 = (int)(memId);
			aOp[6].p1 = (int)(memId);
			aOp[7].p2 = (int)(memId + 2);
			aOp[7].p1 = (int)(memId);
			aOp[10].p2 = (int)(memId);
			if ((pParse.nTab) == (0))
				pParse.nTab = (int)(1);
		}
	}
	public static void sqlite3AutoincrementEnd(Parse pParse)
	{
		if ((pParse.pAinc) != null)
			autoIncrementEnd(pParse);
	}
	public static void sqlite3BeginTransaction(Parse pParse, int type)
	{
		sqlite3 db;
		Vdbe v;
		int i = 0;
		db = pParse.db;
		if ((sqlite3AuthCheck(pParse, (int)(22), "BEGIN", null, null)) != 0)
		{
			return;
		}

		v = sqlite3GetVdbe(pParse);
		if (v == null)
			return;
		if (type != 7)
		{
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				int eTxnType = 0;
				Btree pBt = db.aDb[i].pBt;
				if (((pBt) != null) && ((sqlite3BtreeIsReadonly(pBt)) != 0))
				{
					eTxnType = (int)(0);
				}
				else if ((type) == (9))
				{
					eTxnType = (int)(2);
				}
				else
				{
					eTxnType = (int)(1);
				}

				sqlite3VdbeAddOp2(v, (int)(2), (int)(i), (int)(eTxnType));
				sqlite3VdbeUsesBtree(v, (int)(i));
			}
		}

		sqlite3VdbeAddOp0(v, (int)(1));
	}
	public static void sqlite3BeginTrigger(Parse pParse, Token* pName1, Token* pName2, int tr_tm, int op, IdList* pColumns, SrcList pTableName, Expr pWhen, int isTemp, int noErr)
	{
		Trigger pTrigger = null;
		Table pTab;
		sbyte* zName = null;
		sqlite3 db = pParse.db;
		int iDb = 0;
		Token* pName;
		DbFixer sFix = new DbFixer();
		if ((isTemp) != 0)
		{
			if ((pName2->n) > (0))
			{
				sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
				goto trigger_cleanup;
			}

			iDb = (int)(1);
			pName = pName1;
		}
		else
		{
			iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pName));
			if ((iDb) < (0))
			{
				goto trigger_cleanup;
			}
		}

		if ((pTableName == null) || ((db.mallocFailed) != 0))
		{
			goto trigger_cleanup;
		}

		if (((db.init.busy) != 0) && (iDb != 1))
		{
			sqlite3DbFree(db, pTableName.a[0].zDatabase);
			pTableName.a[0].zDatabase = null;
		}

		pTab = sqlite3SrcListLookup(pParse, pTableName);
		if (((((db.init.busy) == (0)) && ((pName2->n) == (0))) && ((pTab) != null)) && ((pTab.pSchema) == (db.aDb[1].pSchema)))
		{
			iDb = (int)(1);
		}

		if ((db.mallocFailed) != 0)
			goto trigger_cleanup;
		sqlite3FixInit(sFix, pParse, (int)(iDb), "trigger", pName);
		if ((sqlite3FixSrcList(sFix, pTableName)) != 0)
		{
			goto trigger_cleanup;
		}

		pTab = sqlite3SrcListLookup(pParse, pTableName);
		if (pTab == null)
		{
			goto trigger_orphan_error;
		}

		if ((((pTab).eTabType) == (1)))
		{
			sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
			goto trigger_orphan_error;
		}

		zName = sqlite3NameFromToken(db, pName);
		if ((zName) == (null))
		{
			goto trigger_cleanup;
		}

		if ((sqlite3CheckObjectName(pParse, zName, "trigger", pTab.zName)) != 0)
		{
			goto trigger_cleanup;
		}

		if (!((pParse.eParseMode) >= (2)))
		{
			if ((sqlite3HashFind(&(db.aDb[iDb].pSchema.trigHash), zName)) != null)
			{
				if (noErr == 0)
				{
					sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
				}
				else
				{
					sqlite3CodeVerifySchema(pParse, (int)(iDb));
				}

				goto trigger_cleanup;
			}
		}

		if ((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0))
		{
			sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
			goto trigger_cleanup;
		}

		if ((((pTab).eTabType) == (2)) && (tr_tm != 65))
		{
			sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", ((tr_tm) == (33)) ? "BEFORE" : "AFTER", pTableName.a);
			goto trigger_orphan_error;
		}

		if ((!(((pTab).eTabType) == (2))) && ((tr_tm) == (65)))
		{
			sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF trigger on table: %S", pTableName.a);
			goto trigger_orphan_error;
		}

		if (!((pParse.eParseMode) >= (2)))
		{
			int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			int code = (int)(7);
			sbyte* zDb = db.aDb[iTabDb].zDbSName;
			sbyte* zDbTrig = (isTemp) != 0 ? db.aDb[1].zDbSName : zDb;
			if (((iTabDb) == (1)) || ((isTemp) != 0))
				code = (int)(5);
			if ((sqlite3AuthCheck(pParse, (int)(code), zName, pTab.zName, zDbTrig)) != 0)
			{
				goto trigger_cleanup;
			}

			if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) && ((iTabDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
			{
				goto trigger_cleanup;
			}
		}

		if ((tr_tm) == (65))
		{
			tr_tm = (int)(33);
		}

		pTrigger = (Trigger)(sqlite3DbMallocZero(db, (ulong)(sizeof(Trigger))));
		if ((pTrigger) == (null))
			goto trigger_cleanup;
		pTrigger.zName = zName;
		zName = null;
		pTrigger.table = sqlite3DbStrDup(db, pTableName.a[0].zName);
		pTrigger.pSchema = db.aDb[iDb].pSchema;
		pTrigger.pTabSchema = pTab.pSchema;
		pTrigger.op = ((byte)(op));
		pTrigger.tr_tm = (byte)((tr_tm) == (33) ? 1 : 2);
		if (((pParse.eParseMode) >= (2)))
		{
			sqlite3RenameTokenRemap(pParse, pTrigger.table, pTableName.a[0].zName);
			pTrigger.pWhen = pWhen;
			pWhen = null;
		}
		else
		{
			pTrigger.pWhen = sqlite3ExprDup(db, pWhen, (int)(0x0001));
		}

		pTrigger.pColumns = pColumns;
		pColumns = null;
		pParse.pNewTrigger = pTrigger;
	trigger_cleanup:
		; sqlite3DbFree(db, zName);
		sqlite3SrcListDelete(db, pTableName);
		sqlite3IdListDelete(db, pColumns);
		sqlite3ExprDelete(db, pWhen);
		if (pParse.pNewTrigger == null)
		{
			sqlite3DeleteTrigger(db, pTrigger);
		}
		else
		{
		}

		return;
	trigger_orphan_error:
		; if ((db.init.iDb) == (1)) { db.init.orphanTrigger = (uint)(1); }
		goto trigger_cleanup;
	}
	public static void sqlite3BeginWriteOperation(Parse pParse, int setStatement, int iDb)
	{
		Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		sqlite3CodeVerifySchemaAtToplevel(pToplevel, (int)(iDb));
		(pToplevel.writeMask) |= (uint)(((uint)(1)) << (iDb));
		pToplevel.isMultiWrite |= (byte)(setStatement);
	}
	public static CollSeq sqlite3BinaryCompareCollSeq(Parse pParse, Expr pLeft, Expr pRight)
	{
		CollSeq pColl;
		if ((pLeft.flags & 0x000100) != 0)
		{
			pColl = sqlite3ExprCollSeq(pParse, pLeft);
		}
		else if (((pRight) != null) && ((pRight.flags & 0x000100) != 0))
		{
			pColl = sqlite3ExprCollSeq(pParse, pRight);
		}
		else
		{
			pColl = sqlite3ExprCollSeq(pParse, pLeft);
			if (pColl == null)
			{
				pColl = sqlite3ExprCollSeq(pParse, pRight);
			}
		}

		return pColl;
	}
	public static void sqlite3ChangeCookie(Parse pParse, int iDb)
	{
		sqlite3 db = pParse.db;
		Vdbe v = pParse.pVdbe;
		sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(1), (int)(1 + (uint)(db.aDb[iDb].pSchema.schema_cookie)));
	}
	public static int sqlite3CheckCollSeq(Parse pParse, CollSeq pColl)
	{
		if (((pColl) != null) && ((pColl.xCmp) == (null)))
		{
			sbyte* zName = pColl.zName;
			sqlite3 db = pParse.db;
			CollSeq p = sqlite3GetCollSeq(pParse, (byte)((db).enc), pColl, zName);
			if (p == null)
			{
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static int sqlite3CheckObjectName(Parse pParse, sbyte* zName, sbyte* zType, sbyte* zTblName)
	{
		sqlite3 db = pParse.db;
		if ((((sqlite3WritableSchema(db)) != 0) || ((db.init.imposterTable) != 0)) || (sqlite3Config.bExtraSchemaChecks == 0))
		{
			return (int)(0);
		}

		if ((db.init.busy) != 0)
		{
			if ((((sqlite3_stricmp(zType, db.init.azInit[0])) != 0) || ((sqlite3_stricmp(zName, db.init.azInit[1])) != 0)) || ((sqlite3_stricmp(zTblName, db.init.azInit[2])) != 0))
			{
				sqlite3ErrorMsg(pParse, "");
				return (int)(1);
			}
		}
		else
		{
			if ((((pParse.nested) == (0)) && ((0) == (sqlite3_strnicmp(zName, "sqlite_", (int)(7))))) || (((sqlite3ReadOnlyShadowTables(db)) != 0) && ((sqlite3ShadowTableName(db, zName)) != 0)))
			{
				sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static void sqlite3ClearStatTables(Parse pParse, int iDb, sbyte* zType, sbyte* zName)
	{
		int i = 0;
		sbyte* zDbName = pParse.db.aDb[iDb].zDbSName;
		for (i = (int)(1); (i) <= (4); i++)
		{
			sbyte* zTab = stackalloc sbyte[24];
			sqlite3_snprintf((int)(24 * sizeof(sbyte)), zTab, "sqlite_stat%d", (int)(i));
			if ((sqlite3FindTable(pParse.db, zTab, zDbName)) != null)
			{
				sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", zDbName, zTab, zType, zName);
			}
		}
	}
	public static void sqlite3ClearTempRegCache(Parse pParse)
	{
		pParse.nTempReg = (byte)(0);
		pParse.nRangeReg = (int)(0);
	}
	public static void sqlite3CodeDropTable(Parse pParse, Table pTab, int iDb, int isView)
	{
		Vdbe v;
		sqlite3 db = pParse.db;
		Trigger pTrigger;
		Db pDb = db.aDb[iDb];
		v = sqlite3GetVdbe(pParse);
		sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
		if ((((pTab).eTabType) == (1)))
		{
			sqlite3VdbeAddOp0(v, (int)(169));
		}

		pTrigger = sqlite3TriggerList(pParse, pTab);
		while ((pTrigger) != null)
		{
			sqlite3DropTriggerPtr(pParse, pTrigger);
			pTrigger = pTrigger.pNext;
		}

		if ((pTab.tabFlags & 0x00000008) != 0)
		{
			sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_sequence WHERE name=%Q", pDb.zDbSName, pTab.zName);
		}

		sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE tbl_name=%Q and type!='trigger'", pDb.zDbSName, pTab.zName);
		if ((isView == 0) && (!(((pTab).eTabType) == (1))))
		{
			destroyTable(pParse, pTab);
		}

		if ((((pTab).eTabType) == (1)))
		{
			sqlite3VdbeAddOp4(v, (int)(171), (int)(iDb), (int)(0), (int)(0), pTab.zName, (int)(0));
			sqlite3MayAbort(pParse);
		}

		sqlite3VdbeAddOp4(v, (int)(150), (int)(iDb), (int)(0), (int)(0), pTab.zName, (int)(0));
		sqlite3ChangeCookie(pParse, (int)(iDb));
		sqliteViewResetAll(db, (int)(iDb));
	}
	public static void sqlite3CodeRhsOfIN(Parse pParse, Expr pExpr, int iTab)
	{
		int addrOnce = (int)(0);
		int addr = 0;
		Expr pLeft;
		KeyInfo pKeyInfo = null;
		int nVal = 0;
		Vdbe v;
		v = pParse.pVdbe;
		if ((!(((pExpr).flags & (0x000020)) != 0)) && ((pParse.iSelfTab) == (0)))
		{
			if ((((pExpr).flags & (0x2000000)) != 0))
			{
				addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				if ((((pExpr).flags & 0x000800) != 0))
				{
					sqlite3VdbeExplain(pParse, (byte)(0), "REUSE LIST SUBQUERY %d", (uint)(pExpr.x.pSelect.selId));
				}

				sqlite3VdbeAddOp2(v, (int)(12), (int)(pExpr.y.sub.regReturn), (int)(pExpr.y.sub.iAddr));
				sqlite3VdbeAddOp2(v, (int)(113), (int)(iTab), (int)(pExpr.iTable));
				sqlite3VdbeJumpHere(v, (int)(addrOnce));
				return;
			}

			(pExpr).flags |= (uint)(0x2000000);
			pExpr.y.sub.regReturn = (int)(++pParse.nMem);
			pExpr.y.sub.iAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pExpr.y.sub.regReturn)) + 1);
			addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
		}

		pLeft = pExpr.pLeft;
		nVal = (int)(sqlite3ExprVectorSize(pLeft));
		pExpr.iTable = (int)(iTab);
		addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(pExpr.iTable), (int)(nVal)));
		pKeyInfo = sqlite3KeyInfoAlloc(pParse.db, (int)(nVal), (int)(1));
		if ((((pExpr).flags & 0x000800) != 0))
		{
			Select pSelect = pExpr.x.pSelect;
			ExprList pEList = pSelect.pEList;
			sqlite3VdbeExplain(pParse, (byte)(1), "%sLIST SUBQUERY %d", (addrOnce) != 0 ? "" : "CORRELATED ", (uint)(pSelect.selId));
			if (((pEList.nExpr) == (nVal)))
			{
				Select pCopy;
				SelectDest dest = new SelectDest();
				int i = 0;
				int rc = 0;
				sqlite3SelectDestInit(dest, (int)(11), (int)(iTab));
				dest.zAffSdst = exprINAffinity(pParse, pExpr);
				pSelect.iLimit = (int)(0);
				pCopy = sqlite3SelectDup(pParse.db, pSelect, (int)(0));
				rc = (int)((pParse.db.mallocFailed) != 0 ? 1 : sqlite3Select(pParse, pCopy, dest));
				sqlite3SelectDelete(pParse.db, pCopy);
				sqlite3DbFree(pParse.db, dest.zAffSdst);
				if ((rc) != 0)
				{
					sqlite3KeyInfoUnref(pKeyInfo);
					return;
				}

				for (i = (int)(0); (i) < (nVal); i++)
				{
					Expr p = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
					pKeyInfo.aColl[i] = sqlite3BinaryCompareCollSeq(pParse, p, pEList.a[i].pExpr);
				}
			}
		}
		else if ((pExpr.x.pList != null))
		{
			sbyte affinity = 0;
			int i = 0;
			ExprList pList = pExpr.x.pList;
			ExprList_item* pItem;
			int r1 = 0;
			int r2 = 0;
			affinity = (sbyte)(sqlite3ExprAffinity(pLeft));
			if ((affinity) <= (0x40))
			{
				affinity = (sbyte)(0x41);
			}
			else if ((affinity) == (0x45))
			{
				affinity = (sbyte)(0x43);
			}

			if ((pKeyInfo) != null)
			{
				pKeyInfo.aColl[0] = sqlite3ExprCollSeq(pParse, pExpr.pLeft);
			}

			r1 = (int)(sqlite3GetTempReg(pParse));
			r2 = (int)(sqlite3GetTempReg(pParse));
			for (i = (int)(pList.nExpr), pItem = pList.a; (i) > (0); i--, pItem++)
			{
				Expr pE2 = pItem->pExpr;
				if (((addrOnce) != 0) && (sqlite3ExprIsConstant(pE2) == 0))
				{
					sqlite3VdbeChangeToNoop(v, (int)(addrOnce));
					(pExpr).flags &= (uint)(~(0x2000000));
					addrOnce = (int)(0);
				}

				sqlite3ExprCode(pParse, pE2, (int)(r1));
				sqlite3VdbeAddOp4(v, (int)(96), (int)(r1), (int)(1), (int)(r2), &affinity, (int)(1));
				sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iTab), (int)(r2), (int)(r1), (int)(1));
			}

			sqlite3ReleaseTempReg(pParse, (int)(r1));
			sqlite3ReleaseTempReg(pParse, (int)(r2));
		}

		if ((pKeyInfo) != null)
		{
			sqlite3VdbeChangeP4(v, (int)(addr), (void*)(pKeyInfo), (int)(-9));
		}

		if ((addrOnce) != 0)
		{
			sqlite3VdbeJumpHere(v, (int)(addrOnce));
			sqlite3VdbeAddOp1(v, (int)(67), (int)(pExpr.y.sub.regReturn));
			sqlite3VdbeChangeP1(v, (int)(pExpr.y.sub.iAddr - 1), (int)(sqlite3VdbeCurrentAddr(v) - 1));
			sqlite3ClearTempRegCache(pParse);
		}
	}
	public static void sqlite3CodeRowTrigger(Parse pParse, Trigger pTrigger, int op, ExprList pChanges, int tr_tm, Table pTab, int reg, int orconf, int ignoreJump)
	{
		Trigger p;
		for (p = pTrigger; p; p = p.pNext)
		{
			if (((((p.op) == (op)) || ((((p.bReturning) != 0) && ((p.op) == (127))) && ((op) == (129)))) && ((p.tr_tm) == (tr_tm))) && ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
			{
				if (p.bReturning == 0)
				{
					sqlite3CodeRowTriggerDirect(pParse, p, pTab, (int)(reg), (int)(orconf), (int)(ignoreJump));
				}
				else if ((((pParse).pToplevel) == (null)))
				{
					codeReturningTrigger(pParse, p, pTab, (int)(reg));
				}
			}
		}
	}
	public static void sqlite3CodeRowTriggerDirect(Parse pParse, Trigger p, Table pTab, int reg, int orconf, int ignoreJump)
	{
		Vdbe v = sqlite3GetVdbe(pParse);
		TriggerPrg pPrg;
		pPrg = getRowTrigger(pParse, p, pTab, (int)(orconf));
		if ((pPrg) != null)
		{
			int bRecursive = (int)((((p.zName) != null) && ((0) == (pParse.db.flags & 0x00002000))) ? 1 : 0);
			sqlite3VdbeAddOp4(v, (int)(47), (int)(reg), (int)(ignoreJump), (int)(++pParse.nMem), (sbyte*)(pPrg.pProgram), (int)(-4));
			sqlite3VdbeChangeP5(v, (ushort)((byte)(bRecursive)));
		}
	}
	public static int sqlite3CodeSubselect(Parse pParse, Expr pExpr)
	{
		int addrOnce = (int)(0);
		int rReg = (int)(0);
		Select pSel;
		SelectDest dest = new SelectDest();
		int nReg = 0;
		Expr pLimit;
		Vdbe v = pParse.pVdbe;
		if ((pParse.nErr) != 0)
			return (int)(0);
		pSel = pExpr.x.pSelect;
		if ((((pExpr).flags & (0x2000000)) != 0))
		{
			sqlite3VdbeExplain(pParse, (byte)(0), "REUSE SUBQUERY %d", (uint)(pSel.selId));
			sqlite3VdbeAddOp2(v, (int)(12), (int)(pExpr.y.sub.regReturn), (int)(pExpr.y.sub.iAddr));
			return (int)(pExpr.iTable);
		}

		(pExpr).flags |= (uint)(0x2000000);
		pExpr.y.sub.regReturn = (int)(++pParse.nMem);
		pExpr.y.sub.iAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pExpr.y.sub.regReturn)) + 1);
		if (!(((pExpr).flags & (0x000020)) != 0))
		{
			addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
		}

		sqlite3VdbeExplain(pParse, (byte)(1), "%sSCALAR SUBQUERY %d", (addrOnce) != 0 ? "" : "CORRELATED ", (uint)(pSel.selId));
		nReg = (int)((pExpr.op) == (138) ? pSel.pEList.nExpr : 1);
		sqlite3SelectDestInit(dest, (int)(0), (int)(pParse.nMem + 1));
		pParse.nMem += (int)(nReg);
		if ((pExpr.op) == (138))
		{
			dest.eDest = (byte)(10);
			dest.iSdst = (int)(dest.iSDParm);
			dest.nSdst = (int)(nReg);
			sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(dest.iSDParm), (int)(dest.iSDParm + nReg - 1));
		}
		else
		{
			dest.eDest = (byte)(3);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(dest.iSDParm));
		}

		if ((pSel.pLimit) != null)
		{
			sqlite3 db = pParse.db;
			pLimit = sqlite3Expr(db, (int)(155), "0");
			if ((pLimit) != null)
			{
				pLimit.affExpr = (sbyte)(0x43);
				pLimit = sqlite3PExpr(pParse, (int)(52), sqlite3ExprDup(db, pSel.pLimit.pLeft, (int)(0)), pLimit);
			}

			sqlite3ExprDelete(db, pSel.pLimit.pLeft);
			pSel.pLimit.pLeft = pLimit;
		}
		else
		{
			pLimit = sqlite3Expr(pParse.db, (int)(155), "1");
			pSel.pLimit = sqlite3PExpr(pParse, (int)(148), pLimit, null);
		}

		pSel.iLimit = (int)(0);
		if ((sqlite3Select(pParse, pSel, dest)) != 0)
		{
			pExpr.op2 = (byte)(pExpr.op);
			pExpr.op = (byte)(182);
			return (int)(0);
		}

		pExpr.iTable = (int)(rReg = (int)(dest.iSDParm));
		if ((addrOnce) != 0)
		{
			sqlite3VdbeJumpHere(v, (int)(addrOnce));
		}

		sqlite3VdbeAddOp1(v, (int)(67), (int)(pExpr.y.sub.regReturn));
		sqlite3VdbeChangeP1(v, (int)(pExpr.y.sub.iAddr - 1), (int)(sqlite3VdbeCurrentAddr(v) - 1));
		sqlite3ClearTempRegCache(pParse);
		return (int)(rReg);
	}
	public static void sqlite3CodeVerifyNamedSchema(Parse pParse, sbyte* zDb)
	{
		sqlite3 db = pParse.db;
		int i = 0;
		for (i = (int)(0); (i) < (db.nDb); i++)
		{
			Db pDb = db.aDb[i];
			if (((pDb.pBt) != null) && ((zDb == null) || ((0) == (sqlite3StrICmp(zDb, pDb.zDbSName)))))
			{
				sqlite3CodeVerifySchema(pParse, (int)(i));
			}
		}
	}
	public static void sqlite3CodeVerifySchema(Parse pParse, int iDb)
	{
		sqlite3CodeVerifySchemaAtToplevel(((pParse).pToplevel ? (pParse).pToplevel : (pParse)), (int)(iDb));
	}
	public static void sqlite3CodeVerifySchemaAtToplevel(Parse pToplevel, int iDb)
	{
		if ((((pToplevel.cookieMask) & (((uint)(1)) << (iDb))) != 0) == (0))
		{
			(pToplevel.cookieMask) |= (uint)(((uint)(1)) << (iDb));
			if ((0 == 0) && ((iDb) == (1)))
			{
				sqlite3OpenTempDatabase(pToplevel);
			}
		}
	}
	public static void sqlite3ColumnSetExpr(Parse pParse, Table pTab, Column* pCol, Expr pExpr)
	{
		ExprList pList;
		pList = pTab.u.tab.pDfltList;
		if ((((pCol->iDflt) == (0)) || ((pList) == (null))) || ((pList.nExpr) < (pCol->iDflt)))
		{
			pCol->iDflt = (ushort)((pList) == (null) ? 1 : pList.nExpr + 1);
			pTab.u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr);
		}
		else
		{
			sqlite3ExprDelete(pParse.db, pList.a[pCol->iDflt - 1].pExpr);
			pList.a[pCol->iDflt - 1].pExpr = pExpr;
		}
	}
	public static int sqlite3ColumnsFromExprList(Parse pParse, ExprList pEList, short* pnCol, Column** paCol)
	{
		sqlite3 db = pParse.db;
		int i = 0; int j = 0;
		uint cnt = 0;
		Column* aCol; Column* pCol;
		int nCol = 0;
		sbyte* zName;
		int nName = 0;
		Hash ht = new Hash();
		Table pTab;
		sqlite3HashInit(&ht);
		if ((pEList) != null)
		{
			nCol = (int)(pEList.nExpr);
			aCol = sqlite3DbMallocZero(db, (ulong)(sizeof(Column) * nCol));
			if (((nCol) > (32767)))
				nCol = (int)(32767);
		}
		else
		{
			nCol = (int)(0);
			aCol = null;
		}

		*pnCol = (short)(nCol);
		*paCol = aCol;
		for (i = (int)(0), pCol = aCol; ((i) < (nCol)) && (db.mallocFailed == 0); i++, pCol++)
		{
			if (((zName = pEList.a[i].zEName) != null) && ((pEList.a[i].eEName) == (0)))
			{
			}
			else
			{
				Expr pColExpr = sqlite3ExprSkipCollateAndLikely(pEList.a[i].pExpr);
				while ((pColExpr != null) && ((pColExpr.op) == (141)))
				{
					pColExpr = pColExpr.pRight;
				}

				if ((((pColExpr.op) == (167)) && ((((pColExpr).flags & (0x1000000 | 0x2000000)) == (0)) != 0)) && ((pTab = pColExpr.y.pTab) != null))
				{
					int iCol = (int)(pColExpr.iColumn);
					if ((iCol) < (0))
						iCol = (int)(pTab.iPKey);
					zName = (iCol) >= (0) ? pTab.aCol[iCol].zCnName : "rowid";
				}
				else if ((pColExpr.op) == (59))
				{
					zName = pColExpr.u.zToken;
				}
				else
				{
					zName = pEList.a[i].zEName;
				}
			}

			if (((zName) != null) && (sqlite3IsTrueOrFalse(zName) == 0))
			{
				zName = sqlite3DbStrDup(db, zName);
			}
			else
			{
				zName = sqlite3MPrintf(db, "column%d", (int)(i + 1));
			}

			cnt = (uint)(0);
			while (((zName) != null) && (sqlite3HashFind(&ht, zName) != null))
			{
				nName = (int)(sqlite3Strlen30(zName));
				if ((nName) > (0))
				{
					for (j = (int)(nName - 1); ((j) > (0)) && ((sqlite3CtypeMap[(byte)(zName[j])] & 0x04) != 0); j--)
					{
					}

					if ((zName[j]) == (58))
						nName = (int)(j);
				}

				zName = sqlite3MPrintf(db, "%.*z:%u", (int)(nName), zName, (uint)(++cnt));
				if ((cnt) > (3))
					sqlite3_randomness((int)(sizeof(uint)), &cnt);
			}

			pCol->zCnName = zName;
			pCol->hName = (byte)(sqlite3StrIHash(zName));
			if (((zName) != null) && ((sqlite3HashInsert(&ht, zName, pCol)) == (pCol)))
			{
				sqlite3OomFault(db);
			}
		}

		sqlite3HashClear(&ht);
		if ((db.mallocFailed) != 0)
		{
			for (j = (int)(0); (j) < (i); j++)
			{
				sqlite3DbFree(db, aCol[j].zCnName);
			}

			sqlite3DbFree(db, aCol);
			*paCol = null;
			*pnCol = (short)(0);
			return (int)(7);
		}

		return (int)(0);
	}
	public static void sqlite3CompleteInsertion(Parse pParse, Table pTab, int iDataCur, int iIdxCur, int regNewData, int* aRegIdx, int update_flags, int appendBias, int useSeekResult)
	{
		Vdbe v;
		Index pIdx;
		byte pik_flags = 0;
		int i = 0;
		v = pParse.pVdbe;
		for (i = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, i++)
		{
			if ((aRegIdx[i]) == (0))
				continue;
			if ((pIdx.pPartIdxWhere) != null)
			{
				sqlite3VdbeAddOp2(v, (int)(50), (int)(aRegIdx[i]), (int)(sqlite3VdbeCurrentAddr(v) + 2));
			}

			pik_flags = (byte)((useSeekResult) != 0 ? 0x10 : 0);
			if ((((pIdx).idxType) == (2)) && (!(((pTab).tabFlags & 0x00000080) == (0))))
			{
				pik_flags |= (byte)(0x01);
				pik_flags |= (byte)(update_flags & 0x02);
				if ((update_flags) == (0))
				{
				}
			}

			sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iIdxCur + i), (int)(aRegIdx[i]), (int)(aRegIdx[i] + 1), (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol : pIdx.nColumn));
			sqlite3VdbeChangeP5(v, (ushort)(pik_flags));
		}

		if (!(((pTab).tabFlags & 0x00000080) == (0)))
			return;
		if ((pParse.nested) != 0)
		{
			pik_flags = (byte)(0);
		}
		else
		{
			pik_flags = (byte)(0x01);
			pik_flags |= (byte)((update_flags) != 0 ? update_flags : 0x20);
		}

		if ((appendBias) != 0)
		{
			pik_flags |= (byte)(0x08);
		}

		if ((useSeekResult) != 0)
		{
			pik_flags |= (byte)(0x10);
		}

		sqlite3VdbeAddOp3(v, (int)(127), (int)(iDataCur), (int)(aRegIdx[i]), (int)(regNewData));
		if (pParse.nested == 0)
		{
			sqlite3VdbeAppendP4(v, pTab, (int)(-6));
		}

		sqlite3VdbeChangeP5(v, (ushort)(pik_flags));
	}
	public static void sqlite3ComputeGeneratedColumns(Parse pParse, int iRegStore, Table pTab)
	{
		int i = 0;
		Walker w = new Walker();
		Column* pRedo;
		int eProgress = 0;
		VdbeOp* pOp;
		sqlite3TableAffinity(pParse.pVdbe, pTab, (int)(iRegStore));
		if ((pTab.tabFlags & 0x00000040) != 0)
		{
			pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(-1));
			if ((pOp->opcode) == (95))
			{
				int ii = 0;
				int jj = 0;
				sbyte* zP4 = pOp->p4.z;
				for (ii = (int)(jj = (int)(0)); zP4[jj]; ii++)
				{
					if ((pTab.aCol[ii].colFlags & 0x0020) != 0)
					{
						continue;
					}

					if ((pTab.aCol[ii].colFlags & 0x0040) != 0)
					{
						zP4[jj] = (sbyte)(0x40);
					}

					jj++;
				}
			}
			else if ((pOp->opcode) == (94))
			{
				pOp->p3 = (int)(1);
			}
		}

		for (i = (int)(0); (i) < (pTab.nCol); i++)
		{
			if ((pTab.aCol[i].colFlags & 0x0060) != 0)
			{
				pTab.aCol[i].colFlags |= (ushort)(0x0080);
			}
		}

		w.u.pTab = pTab;
		w.xExprCallback = exprColumnFlagUnion;
		w.xSelectCallback = null;
		w.xSelectCallback2 = null;
		pParse.iSelfTab = (int)(-iRegStore);
		do
		{
			eProgress = (int)(0);
			pRedo = null;
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				Column* pCol = pTab.aCol + i;
				if ((pCol->colFlags & 0x0080) != 0)
				{
					int x = 0;
					pCol->colFlags |= (ushort)(0x0100);
					w.eCode = (ushort)(0);
					sqlite3WalkExpr(w, sqlite3ColumnExpr(pTab, pCol));
					pCol->colFlags &= (ushort)(~0x0100);
					if ((w.eCode & 0x0080) != 0)
					{
						pRedo = pCol;
						continue;
					}

					eProgress = (int)(1);
					x = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + iRegStore);
					sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(x));
					pCol->colFlags &= (ushort)(~0x0080);
				}
			}
		}
		while (((pRedo) != null) && ((eProgress) != 0));
		if ((pRedo) != null)
		{
			sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pRedo->zCnName);
		}

		pParse.iSelfTab = (int)(0);
	}
	public static void sqlite3CreateForeignKey(Parse pParse, ExprList pFromCol, Token* pTo, ExprList pToCol, int flags)
	{
		sqlite3 db = pParse.db;
		FKey pFKey = null;
		FKey pNextTo;
		Table p = pParse.pNewTable;
		long nByte = 0;
		int i = 0;
		int nCol = 0;
		sbyte* z;
		if (((p) == (null)) || ((pParse.eParseMode) == (1)))
			goto fk_end;
		if ((pFromCol) == (null))
		{
			int iCol = (int)(p.nCol - 1);
			if (((iCol) < (0)))
				goto fk_end;
			if (((pToCol) != null) && (pToCol.nExpr != 1))
			{
				sqlite3ErrorMsg(pParse, "foreign key on %s should reference only one column of table %T", p.aCol[iCol].zCnName, pTo);
				goto fk_end;
			}

			nCol = (int)(1);
		}
		else if (((pToCol) != null) && (pToCol.nExpr != pFromCol.nExpr))
		{
			sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of columns in the referenced table");
			goto fk_end;
		}
		else
		{
			nCol = (int)(pFromCol.nExpr);
		}

		nByte = (long)(sizeof(FKey) + (nCol - 1) * sizeof(sColMap) + pTo->n + 1);
		if ((pToCol) != null)
		{
			for (i = (int)(0); (i) < (pToCol.nExpr); i++)
			{
				nByte += (long)(sqlite3Strlen30(pToCol.a[i].zEName) + 1);
			}
		}

		pFKey = sqlite3DbMallocZero(db, (ulong)(nByte));
		if ((pFKey) == (null))
		{
			goto fk_end;
		}

		pFKey.pFrom = p;
		pFKey.pNextFrom = p.u.tab.pFKey;
		z = (sbyte*)(&pFKey.aCol[nCol]);
		pFKey.zTo = z;
		if (((pParse.eParseMode) >= (2)))
		{
			sqlite3RenameTokenMap(pParse, (void*)(z), pTo);
		}

		CRuntime.memcpy(z, pTo->z, (ulong)(pTo->n));
		z[pTo->n] = (sbyte)(0);
		sqlite3Dequote(z);
		z += pTo->n + 1;
		pFKey.nCol = (int)(nCol);
		if ((pFromCol) == (null))
		{
			pFKey.aCol[0].iFrom = (int)(p.nCol - 1);
		}
		else
		{
			for (i = (int)(0); (i) < (nCol); i++)
			{
				int j = 0;
				for (j = (int)(0); (j) < (p.nCol); j++)
				{
					if ((sqlite3StrICmp(p.aCol[j].zCnName, pFromCol.a[i].zEName)) == (0))
					{
						pFKey.aCol[i].iFrom = (int)(j);
						break;
					}
				}

				if ((j) >= (p.nCol))
				{
					sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition", pFromCol.a[i].zEName);
					goto fk_end;
				}

				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenRemap(pParse, &pFKey.aCol[i], pFromCol.a[i].zEName);
				}
			}
		}

		if ((pToCol) != null)
		{
			for (i = (int)(0); (i) < (nCol); i++)
			{
				int n = (int)(sqlite3Strlen30(pToCol.a[i].zEName));
				pFKey.aCol[i].zCol = z;
				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenRemap(pParse, z, pToCol.a[i].zEName);
				}

				CRuntime.memcpy(z, pToCol.a[i].zEName, (ulong)(n));
				z[n] = (sbyte)(0);
				z += n + 1;
			}
		}

		pFKey.isDeferred = (byte)(0);
		pFKey.aAction[0] = ((byte)(flags & 0xff));
		pFKey.aAction[1] = ((byte)((flags >> 8) & 0xff));
		pNextTo = (FKey)(sqlite3HashInsert(&p.pSchema.fkeyHash, pFKey.zTo, (void*)(pFKey)));
		if ((pNextTo) == (pFKey))
		{
			sqlite3OomFault(db);
			goto fk_end;
		}

		if ((pNextTo) != null)
		{
			pFKey.pNextTo = pNextTo;
			pNextTo.pPrevTo = pFKey;
		}

		p.u.tab.pFKey = pFKey;
		pFKey = null;
	fk_end:
		; sqlite3DbFree(db, pFKey);
		sqlite3ExprListDelete(db, pFromCol);
		sqlite3ExprListDelete(db, pToCol);
	}
	public static void sqlite3CreateIndex(Parse pParse, Token* pName1, Token* pName2, SrcList pTblName, ExprList pList, int onError, Token* pStart, Expr pPIWhere, int sortOrder, int ifNotExist, byte idxType)
	{
		Table pTab = null;
		Index pIndex = null;
		sbyte* zName = null;
		int nName = 0;
		int i = 0; int j = 0;
		DbFixer sFix = new DbFixer();
		int sortOrderMask = 0;
		sqlite3 db = pParse.db;
		Db pDb;
		int iDb = 0;
		Token* pName = null;
		ExprList_item* pListItem;
		int nExtra = (int)(0);
		int nExtraCol = 0;
		sbyte* zExtra = null;
		Index pPk = null;
		if ((pParse.nErr) != 0)
		{
			goto exit_create_index;
		}

		if (((pParse.eParseMode) == (1)) && (idxType != 2))
		{
			goto exit_create_index;
		}

		if (0 != sqlite3ReadSchema(pParse))
		{
			goto exit_create_index;
		}

		if ((sqlite3HasExplicitNulls(pParse, pList)) != 0)
		{
			goto exit_create_index;
		}

		if (pTblName != null)
		{
			iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pName));
			if ((iDb) < (0))
				goto exit_create_index;
			if (db.init.busy == 0)
			{
				pTab = sqlite3SrcListLookup(pParse, pTblName);
				if ((((pName2->n) == (0)) && ((pTab) != null)) && ((pTab.pSchema) == (db.aDb[1].pSchema)))
				{
					iDb = (int)(1);
				}
			}

			sqlite3FixInit(sFix, pParse, (int)(iDb), "index", pName);
			if ((sqlite3FixSrcList(sFix, pTblName)) != 0)
			{
			}

			pTab = sqlite3LocateTableItem(pParse, (uint)(0), pTblName.a[0]);
			if ((pTab) == (null))
				goto exit_create_index;
			if (((iDb) == (1)) && (db.aDb[iDb].pSchema != pTab.pSchema))
			{
				sqlite3ErrorMsg(pParse, "cannot create a TEMP index on non-TEMP table \"%s\"", pTab.zName);
				goto exit_create_index;
			}

			if (!(((pTab).tabFlags & 0x00000080) == (0)))
				pPk = sqlite3PrimaryKeyIndex(pTab);
		}
		else
		{
			pTab = pParse.pNewTable;
			if (pTab == null)
				goto exit_create_index;
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		}

		pDb = db.aDb[iDb];
		if ((((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0)) && ((db.init.busy) == (0))) && (pTblName != null))
		{
			sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab.zName);
			goto exit_create_index;
		}

		if ((((pTab).eTabType) == (2)))
		{
			sqlite3ErrorMsg(pParse, "views may not be indexed");
			goto exit_create_index;
		}

		if ((((pTab).eTabType) == (1)))
		{
			sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
			goto exit_create_index;
		}

		if ((pName) != null)
		{
			zName = sqlite3NameFromToken(db, pName);
			if ((zName) == (null))
				goto exit_create_index;
			if (0 != sqlite3CheckObjectName(pParse, zName, "index", pTab.zName))
			{
				goto exit_create_index;
			}

			if (!((pParse.eParseMode) >= (2)))
			{
				if (db.init.busy == 0)
				{
					if (sqlite3FindTable(db, zName, null) != null)
					{
						sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
						goto exit_create_index;
					}
				}

				if (sqlite3FindIndex(db, zName, pDb.zDbSName) != null)
				{
					if (ifNotExist == 0)
					{
						sqlite3ErrorMsg(pParse, "index %s already exists", zName);
					}
					else
					{
						sqlite3CodeVerifySchema(pParse, (int)(iDb));
						sqlite3ForceNotReadOnly(pParse);
					}

					goto exit_create_index;
				}
			}
		}
		else
		{
			int n = 0;
			Index pLoop;
			for (pLoop = pTab.pIndex, n = (int)(1); pLoop; pLoop = pLoop.pNext, n++)
			{
			}

			zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab.zName, (int)(n));
			if ((zName) == (null))
			{
				goto exit_create_index;
			}

			if ((pParse.eParseMode != 0))
				zName[7]++;
		}

		if (!((pParse.eParseMode) >= (2)))
		{
			sbyte* zDb = pDb.zDbSName;
			if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
			{
				goto exit_create_index;
			}

			i = (int)(1);
			if ((0 == 0) && ((iDb) == (1)))
				i = (int)(3);
			if ((sqlite3AuthCheck(pParse, (int)(i), zName, pTab.zName, zDb)) != 0)
			{
				goto exit_create_index;
			}
		}

		if ((pList) == (null))
		{
			Token prevCol = new Token();
			Column* pCol = &pTab.aCol[pTab.nCol - 1];
			pCol->colFlags |= (ushort)(0x0008);
			sqlite3TokenInit(&prevCol, pCol->zCnName);
			pList = sqlite3ExprListAppend(pParse, null, sqlite3ExprAlloc(db, (int)(59), &prevCol, (int)(0)));
			if ((pList) == (null))
				goto exit_create_index;
			sqlite3ExprListSetSortOrder(pList, (int)(sortOrder), (int)(-1));
		}
		else
		{
			sqlite3ExprListCheckLength(pParse, pList, "index");
			if ((pParse.nErr) != 0)
				goto exit_create_index;
		}

		for (i = (int)(0); (i) < (pList.nExpr); i++)
		{
			Expr pExpr = pList.a[i].pExpr;
			if ((pExpr.op) == (113))
			{
				nExtra += (int)(1 + sqlite3Strlen30(pExpr.u.zToken));
			}
		}

		nName = (int)(sqlite3Strlen30(zName));
		nExtraCol = (int)(pPk ? pPk.nKeyCol : 1);
		pIndex = sqlite3AllocateIndexObject(db, (short)(pList.nExpr + nExtraCol), (int)(nName + nExtra + 1), &zExtra);
		if ((db.mallocFailed) != 0)
		{
			goto exit_create_index;
		}

		pIndex.zName = zExtra;
		zExtra += nName + 1;
		CRuntime.memcpy(pIndex.zName, zName, (ulong)(nName + 1));
		pIndex.pTable = pTab;
		pIndex.onError = ((byte)(onError));
		pIndex.uniqNotNull = (uint)(onError != 0);
		pIndex.idxType = (uint)(idxType);
		pIndex.pSchema = db.aDb[iDb].pSchema;
		pIndex.nKeyCol = (ushort)(pList.nExpr);
		if ((pPIWhere) != null)
		{
			sqlite3ResolveSelfReference(pParse, pTab, (int)(0x000002), pPIWhere, null);
			pIndex.pPartIdxWhere = pPIWhere;
			pPIWhere = null;
		}

		if ((pDb.pSchema.file_format) >= (4))
		{
			sortOrderMask = (int)(-1);
		}
		else
		{
			sortOrderMask = (int)(0);
		}

		pListItem = pList.a;
		if (((pParse.eParseMode) >= (2)))
		{
			pIndex.aColExpr = pList;
			pList = null;
		}

		for (i = (int)(0); (i) < (pIndex.nKeyCol); i++, pListItem++)
		{
			Expr pCExpr;
			int requestedSortOrder = 0;
			sbyte* zColl;
			sqlite3StringToId(pListItem->pExpr);
			sqlite3ResolveSelfReference(pParse, pTab, (int)(0x000020), pListItem->pExpr, null);
			if ((pParse.nErr) != 0)
				goto exit_create_index;
			pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
			if (pCExpr.op != 167)
			{
				if ((pTab) == (pParse.pNewTable))
				{
					sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and UNIQUE constraints");
					goto exit_create_index;
				}

				if ((pIndex.aColExpr) == (null))
				{
					pIndex.aColExpr = pList;
					pList = null;
				}

				j = (int)(-2);
				pIndex.aiColumn[i] = (short)(-2);
				pIndex.uniqNotNull = (uint)(0);
			}
			else
			{
				j = (int)(pCExpr.iColumn);
				if ((j) < (0))
				{
					j = (int)(pTab.iPKey);
				}
				else
				{
					if ((pTab.aCol[j].notNull) == (0))
					{
						pIndex.uniqNotNull = (uint)(0);
					}

					if ((pTab.aCol[j].colFlags & 0x0020) != 0)
					{
						pIndex.bHasVCol = (uint)(1);
					}
				}

				pIndex.aiColumn[i] = ((short)(j));
			}

			zColl = null;
			if ((pListItem->pExpr.op) == (113))
			{
				int nColl = 0;
				zColl = pListItem->pExpr.u.zToken;
				nColl = (int)(sqlite3Strlen30(zColl) + 1);
				CRuntime.memcpy(zExtra, zColl, (ulong)(nColl));
				zColl = zExtra;
				zExtra += nColl;
				nExtra -= (int)(nColl);
			}
			else if ((j) >= (0))
			{
				zColl = sqlite3ColumnColl(&pTab.aCol[j]);
			}

			if (zColl == null)
				zColl = sqlite3StrBINARY;
			if ((db.init.busy == 0) && (sqlite3LocateCollSeq(pParse, zColl) == null))
			{
				goto exit_create_index;
			}

			pIndex.azColl[i] = zColl;
			requestedSortOrder = (int)(pListItem->sortFlags & sortOrderMask);
			pIndex.aSortOrder[i] = ((byte)(requestedSortOrder));
		}

		if ((pPk) != null)
		{
			for (j = (int)(0); (j) < (pPk.nKeyCol); j++)
			{
				int x = (int)(pPk.aiColumn[j]);
				if ((isDupColumn(pIndex, (int)(pIndex.nKeyCol), pPk, (int)(j))) != 0)
				{
					pIndex.nColumn--;
				}
				else
				{
					pIndex.aiColumn[i] = (short)(x);
					pIndex.azColl[i] = pPk.azColl[j];
					pIndex.aSortOrder[i] = (byte)(pPk.aSortOrder[j]);
					i++;
				}
			}
		}
		else
		{
			pIndex.aiColumn[i] = (short)(-1);
			pIndex.azColl[i] = sqlite3StrBINARY;
		}

		sqlite3DefaultRowEst(pIndex);
		if ((pParse.pNewTable) == (null))
			estimateIndexWidth(pIndex);
		recomputeColumnsNotIndexed(pIndex);
		if ((pTblName != null) && ((pIndex.nColumn) >= (pTab.nCol)))
		{
			pIndex.isCovering = (uint)(1);
			for (j = (int)(0); (j) < (pTab.nCol); j++)
			{
				if ((j) == (pTab.iPKey))
					continue;
				if ((sqlite3TableColumnToIndex(pIndex, (short)(j))) >= (0))
					continue;
				pIndex.isCovering = (uint)(0);
				break;
			}
		}

		if ((pTab) == (pParse.pNewTable))
		{
			Index pIdx;
			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				int k = 0;
				if (pIdx.nKeyCol != pIndex.nKeyCol)
					continue;
				for (k = (int)(0); (k) < (pIdx.nKeyCol); k++)
				{
					sbyte* z1;
					sbyte* z2;
					if (pIdx.aiColumn[k] != pIndex.aiColumn[k])
						break;
					z1 = pIdx.azColl[k];
					z2 = pIndex.azColl[k];
					if ((sqlite3StrICmp(z1, z2)) != 0)
						break;
				}

				if ((k) == (pIdx.nKeyCol))
				{
					if (pIdx.onError != pIndex.onError)
					{
						if (!(((pIdx.onError) == (11)) || ((pIndex.onError) == (11))))
						{
							sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified", (int)(0));
						}

						if ((pIdx.onError) == (11))
						{
							pIdx.onError = (byte)(pIndex.onError);
						}
					}

					if ((idxType) == (2))
						pIdx.idxType = (uint)(idxType);
					if (((pParse.eParseMode) >= (2)))
					{
						pIndex.pNext = pParse.pNewIndex;
						pParse.pNewIndex = pIndex;
						pIndex = null;
					}

					goto exit_create_index;
				}
			}
		}

		if (!((pParse.eParseMode) >= (2)))
		{
			if ((db.init.busy) != 0)
			{
				Index p;
				if (pTblName != null)
				{
					pIndex.tnum = (uint)(db.init.newTnum);
					if ((sqlite3IndexHasDuplicateRootPage(pIndex)) != 0)
					{
						sqlite3ErrorMsg(pParse, "invalid rootpage");
						pParse.rc = (int)(sqlite3CorruptError((int)(118261)));
						goto exit_create_index;
					}
				}

				p = sqlite3HashInsert(&pIndex.pSchema.idxHash, pIndex.zName, pIndex);
				if ((p) != null)
				{
					sqlite3OomFault(db);
					goto exit_create_index;
				}

				db.mDbFlags |= (uint)(0x0001);
			}
			else if ((((pTab).tabFlags & 0x00000080) == (0)) || (pTblName != null))
			{
				Vdbe v;
				sbyte* zStmt;
				int iMem = (int)(++pParse.nMem);
				v = sqlite3GetVdbe(pParse);
				if ((v) == (null))
					goto exit_create_index;
				sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
				pIndex.tnum = ((uint)(sqlite3VdbeAddOp0(v, (int)(182))));
				sqlite3VdbeAddOp3(v, (int)(146), (int)(iDb), (int)(iMem), (int)(2));
				if ((pStart) != null)
				{
					int n = (int)((int)(pParse.sLastToken.z - pName->z) + pParse.sLastToken.n);
					if ((pName->z[n - 1]) == (59))
						n--;
					zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s", (onError) == (0) ? "" : " UNIQUE", (int)(n), pName->z);
				}
				else
				{
					zStmt = null;
				}

				sqlite3NestedParse(pParse, "INSERT INTO %Q.sqlite_master VALUES('index',%Q,%Q,#%d,%Q);", db.aDb[iDb].zDbSName, pIndex.zName, pTab.zName, (int)(iMem), zStmt);
				sqlite3DbFree(db, zStmt);
				if ((pTblName) != null)
				{
					sqlite3RefillIndex(pParse, pIndex, (int)(iMem));
					sqlite3ChangeCookie(pParse, (int)(iDb));
					sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex.zName), (ushort)(0));
					sqlite3VdbeAddOp2(v, (int)(165), (int)(0), (int)(1));
				}

				sqlite3VdbeJumpHere(v, (int)(pIndex.tnum));
			}
		}

		if (((db.init.busy) != 0) || ((pTblName) == (null)))
		{
			pIndex.pNext = pTab.pIndex;
			pTab.pIndex = pIndex;
			pIndex = null;
		}
		else if (((pParse.eParseMode) >= (2)))
		{
			pParse.pNewIndex = pIndex;
			pIndex = null;
		}

	exit_create_index:
		; if ((pIndex) != null) sqlite3FreeIndex(db, pIndex);
		if ((pTab) != null)
		{
			Index ppFrom;
			Index pThis;
			for (ppFrom = pTab.pIndex; (pThis = ppFrom) != null; ppFrom = pThis.pNext)
			{
				Index pNext;
				if (pThis.onError != 5)
					continue;
				while (((pNext = pThis.pNext) != null) && (pNext.onError != 5))
				{
					ppFrom = pNext;
					pThis.pNext = pNext.pNext;
					pNext.pNext = pThis;
					ppFrom = pNext.pNext;
				}

				break;
			}
		}

		sqlite3ExprDelete(db, pPIWhere);
		sqlite3ExprListDelete(db, pList);
		sqlite3SrcListDelete(db, pTblName);
		sqlite3DbFree(db, zName);
	}
	public static void sqlite3CreateView(Parse pParse, Token* pBegin, Token* pName1, Token* pName2, ExprList pCNames, Select pSelect, int isTemp, int noErr)
	{
		Table p;
		int n = 0;
		sbyte* z;
		Token sEnd = new Token();
		DbFixer sFix = new DbFixer();
		Token* pName = null;
		int iDb = 0;
		sqlite3 db = pParse.db;
		if ((pParse.nVar) > (0))
		{
			sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
			goto create_view_fail;
		}

		sqlite3StartTable(pParse, pName1, pName2, (int)(isTemp), (int)(1), (int)(0), (int)(noErr));
		p = pParse.pNewTable;
		if (((p) == (null)) || ((pParse.nErr) != 0))
			goto create_view_fail;
		p.tabFlags |= (uint)(0x00000200);
		sqlite3TwoPartName(pParse, pName1, pName2, &pName);
		iDb = (int)(sqlite3SchemaToIndex(db, p.pSchema));
		sqlite3FixInit(sFix, pParse, (int)(iDb), "view", pName);
		if ((sqlite3FixSelect(sFix, pSelect)) != 0)
			goto create_view_fail;
		pSelect.selFlags |= (uint)(0x0200000);
		if (((pParse.eParseMode) >= (2)))
		{
			p.u.view.pSelect = pSelect;
			pSelect = null;
		}
		else
		{
			p.u.view.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001));
		}

		p.pCheck = sqlite3ExprListDup(db, pCNames, (int)(0x0001));
		p.eTabType = (byte)(2);
		if ((db.mallocFailed) != 0)
			goto create_view_fail;
		sEnd = (Token)(pParse.sLastToken);
		if (sEnd.z[0] != 59)
		{
			sEnd.z += sEnd.n;
		}

		sEnd.n = (uint)(0);
		n = ((int)(sEnd.z - pBegin->z));
		z = pBegin->z;
		while ((sqlite3CtypeMap[(byte)(z[n - 1])] & 0x01) != 0)
		{
			n--;
		}

		sEnd.z = &z[n - 1];
		sEnd.n = (uint)(1);
		sqlite3EndTable(pParse, null, &sEnd, (uint)(0), null);
	create_view_fail:
		; sqlite3SelectDelete(db, pSelect);
		if (((pParse.eParseMode) >= (2)))
		{
			sqlite3RenameExprlistUnmap(pParse, pCNames);
		}

		sqlite3ExprListDelete(db, pCNames);
		return;
	}
	public static Cte sqlite3CteNew(Parse pParse, Token* pName, ExprList pArglist, Select pQuery, byte eM10d)
	{
		Cte pNew;
		sqlite3 db = pParse.db;
		pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Cte)));
		if ((db.mallocFailed) != 0)
		{
			sqlite3ExprListDelete(db, pArglist);
			sqlite3SelectDelete(db, pQuery);
		}
		else
		{
			pNew.pSelect = pQuery;
			pNew.pCols = pArglist;
			pNew.zName = sqlite3NameFromToken(pParse.db, pName);
			pNew.eM10d = (byte)(eM10d);
		}

		return pNew;
	}
	public static void sqlite3DeferForeignKey(Parse pParse, int isDeferred)
	{
		Table pTab;
		FKey pFKey;
		if ((pTab = pParse.pNewTable) == (null))
			return;
		if ((!(((pTab).eTabType) == (0))) != 0)
			return;
		if ((pFKey = pTab.u.tab.pFKey) == (null))
			return;
		pFKey.isDeferred = ((byte)(isDeferred));
	}
	public static void sqlite3DeleteFrom(Parse pParse, SrcList pTabList, Expr pWhere, ExprList pOrderBy, Expr pLimit)
	{
		Vdbe v;
		Table pTab;
		int i = 0;
		WhereInfo pWInfo;
		Index pIdx;
		int iTabCur = 0;
		int iDataCur = (int)(0);
		int iIdxCur = (int)(0);
		int nIdx = 0;
		sqlite3 db;
		AuthContext sContext = new AuthContext();
		NameContext sNC = new NameContext();
		int iDb = 0;
		int memCnt = (int)(0);
		int rcauth = 0;
		int eOnePass = 0;
		int* aiCurOnePass = stackalloc int[2];
		byte* aToOpen = null;
		Index pPk;
		int iPk = (int)(0);
		short nPk = (short)(1);
		int iKey = 0;
		short nKey = 0;
		int iEphCur = (int)(0);
		int iRowSet = (int)(0);
		int addrBypass = (int)(0);
		int addrLoop = (int)(0);
		int addrEphOpen = (int)(0);
		int bComplex = 0;
		int isView = 0;
		Trigger pTrigger;
		CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(AuthContext)));
		db = pParse.db;
		if ((pParse.nErr) != 0)
		{
			goto delete_from_cleanup;
		}

		pTab = sqlite3SrcListLookup(pParse, pTabList);
		if ((pTab) == (null))
			goto delete_from_cleanup;
		pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(128), null, null);
		isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
		bComplex = (int)(((pTrigger) != null) || ((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) ? 1 : 0);
		if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
		{
			goto delete_from_cleanup;
		}

		if ((sqlite3IsReadOnly(pParse, pTab, (int)(pTrigger ? 1 : 0))) != 0)
		{
			goto delete_from_cleanup;
		}

		iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		rcauth = (int)(sqlite3AuthCheck(pParse, (int)(9), pTab.zName, null, db.aDb[iDb].zDbSName));
		if ((rcauth) == (1))
		{
			goto delete_from_cleanup;
		}

		iTabCur = (int)(pTabList.a[0].iCursor = (int)(pParse.nTab++));
		for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
		{
			pParse.nTab++;
		}

		if ((isView) != 0)
		{
			sqlite3AuthContextPush(pParse, sContext, pTab.zName);
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) == (null))
		{
			goto delete_from_cleanup;
		}

		if ((pParse.nested) == (0))
			sqlite3VdbeCountChanges(v);
		sqlite3BeginWriteOperation(pParse, (int)(bComplex), (int)(iDb));
		if ((isView) != 0)
		{
			sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, (int)(iTabCur));
			iDataCur = (int)(iIdxCur = (int)(iTabCur));
			pOrderBy = null;
			pLimit = null;
		}

		CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
		sNC.pParse = pParse;
		sNC.pSrcList = pTabList;
		if ((sqlite3ResolveExprNames(sNC, pWhere)) != 0)
		{
			goto delete_from_cleanup;
		}

		if (((((db.flags & ((ulong)(0x00001) << 32)) != 0) && (pParse.nested == 0)) && (pParse.pTriggerTab == null)) && (pParse.bReturning == 0))
		{
			memCnt = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(memCnt));
		}

		if (((((rcauth) == (0)) && ((pWhere) == (null))) && (bComplex == 0)) && (!(((pTab).eTabType) == (1))))
		{
			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(1), pTab.zName);
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				sqlite3VdbeAddOp4(v, (int)(144), (int)(pTab.tnum), (int)(iDb), (int)((memCnt) != 0 ? memCnt : -1), pTab.zName, (int)(-1));
			}

			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				sqlite3VdbeAddOp2(v, (int)(144), (int)(pIdx.tnum), (int)(iDb));
				if ((((pIdx).idxType) == (2)) && (!(((pTab).tabFlags & 0x00000080) == (0))))
				{
					sqlite3VdbeChangeP3(v, (int)(-1), (int)((memCnt) != 0 ? memCnt : -1));
				}
			}
		}
		else
		{
			ushort wcf = (ushort)(0x0004 | 0x0010);
			if ((sNC.ncFlags & 0x000040) != 0)
				bComplex = (int)(1);
			wcf |= (ushort)((bComplex) != 0 ? 0 : 0x0008);
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				pPk = null;
				nPk = (short)(1);
				iRowSet = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(iRowSet));
			}
			else
			{
				pPk = sqlite3PrimaryKeyIndex(pTab);
				nPk = (short)(pPk.nKeyCol);
				iPk = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPk);
				iEphCur = (int)(pParse.nTab++);
				addrEphOpen = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iEphCur), (int)(nPk)));
				sqlite3VdbeSetP4KeyInfo(pParse, pPk);
			}

			pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, null, null, null, (ushort)(wcf), (int)(iTabCur + 1));
			if ((pWInfo) == (null))
				goto delete_from_cleanup;
			eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aiCurOnePass));
			if (eOnePass != 1)
				sqlite3MultiWrite(pParse);
			if ((sqlite3WhereUsesDeferredSeek(pWInfo)) != 0)
			{
				sqlite3VdbeAddOp1(v, (int)(142), (int)(iTabCur));
			}

			if ((memCnt) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(85), (int)(memCnt), (int)(1));
			}

			if ((pPk) != null)
			{
				for (i = (int)(0); (i) < (nPk); i++)
				{
					sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iTabCur), (int)(pPk.aiColumn[i]), (int)(iPk + i));
				}

				iKey = (int)(iPk);
			}
			else
			{
				iKey = (int)(++pParse.nMem);
				sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iTabCur), (int)(-1), (int)(iKey));
			}

			if (eOnePass != 0)
			{
				nKey = (short)(nPk);
				aToOpen = sqlite3DbMallocRawNN(db, (ulong)(nIdx + 2));
				if ((aToOpen) == (null))
				{
					sqlite3WhereEnd(pWInfo);
					goto delete_from_cleanup;
				}

				CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
				aToOpen[nIdx + 1] = (byte)(0);
				if ((aiCurOnePass[0]) >= (0))
					aToOpen[aiCurOnePass[0] - iTabCur] = (byte)(0);
				if ((aiCurOnePass[1]) >= (0))
					aToOpen[aiCurOnePass[1] - iTabCur] = (byte)(0);
				if ((addrEphOpen) != 0)
					sqlite3VdbeChangeToNoop(v, (int)(addrEphOpen));
				addrBypass = (int)(sqlite3VdbeMakeLabel(pParse));
			}
			else
			{
				if ((pPk) != null)
				{
					iKey = (int)(++pParse.nMem);
					nKey = (short)(0);
					sqlite3VdbeAddOp4(v, (int)(96), (int)(iPk), (int)(nPk), (int)(iKey), sqlite3IndexAffinityStr(pParse.db, pPk), (int)(nPk));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iEphCur), (int)(iKey), (int)(iPk), (int)(nPk));
				}
				else
				{
					nKey = (short)(1);
					sqlite3VdbeAddOp2(v, (int)(155), (int)(iRowSet), (int)(iKey));
				}

				sqlite3WhereEnd(pWInfo);
			}

			if (isView == 0)
			{
				int iAddrOnce = (int)(0);
				if ((eOnePass) == (2))
				{
					iAddrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				}

				sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0x08), (int)(iTabCur), aToOpen, &iDataCur, &iIdxCur);
				if ((eOnePass) == (2))
				{
					sqlite3VdbeJumpHereOrPopInst(v, (int)(iAddrOnce));
				}
			}

			if (eOnePass != 0)
			{
				if ((!(((pTab).eTabType) == (1))) && ((aToOpen[iDataCur - iTabCur]) != 0))
				{
					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(addrBypass), (int)(iKey), (int)(nKey));
				}
			}
			else if ((pPk) != null)
			{
				addrLoop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iEphCur)));
				if ((((pTab).eTabType) == (1)))
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iEphCur), (int)(0), (int)(iKey));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(133), (int)(iEphCur), (int)(iKey));
				}
			}
			else
			{
				addrLoop = (int)(sqlite3VdbeAddOp3(v, (int)(45), (int)(iRowSet), (int)(0), (int)(iKey)));
			}

			if ((((pTab).eTabType) == (1)))
			{
				sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
				sqlite3VtabMakeWritable(pParse, pTab);
				sqlite3MayAbort(pParse);
				if ((eOnePass) == (1))
				{
					sqlite3VdbeAddOp1(v, (int)(121), (int)(iTabCur));
					if ((((pParse).pToplevel) == (null)))
					{
						pParse.isMultiWrite = (byte)(0);
					}
				}

				sqlite3VdbeAddOp4(v, (int)(10), (int)(0), (int)(1), (int)(iKey), pVTab, (int)(-12));
				sqlite3VdbeChangeP5(v, (ushort)(2));
			}
			else
			{
				int count = (int)(((pParse.nested) == (0)) ? 1 : 0);
				sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(iKey), (short)(nKey), (byte)(count), (byte)(11), (byte)(eOnePass), (int)(aiCurOnePass[1]));
			}

			if (eOnePass != 0)
			{
				sqlite3VdbeResolveLabel(v, (int)(addrBypass));
				sqlite3WhereEnd(pWInfo);
			}
			else if ((pPk) != null)
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iEphCur), (int)(addrLoop + 1));
				sqlite3VdbeJumpHere(v, (int)(addrLoop));
			}
			else
			{
				sqlite3VdbeGoto(v, (int)(addrLoop));
				sqlite3VdbeJumpHere(v, (int)(addrLoop));
			}
		}

		if (((pParse.nested) == (0)) && ((pParse.pTriggerTab) == (null)))
		{
			sqlite3AutoincrementEnd(pParse);
		}

		if ((memCnt) != 0)
		{
			sqlite3CodeChangeCount(v, (int)(memCnt), "rows deleted");
		}

	delete_from_cleanup:
		; sqlite3AuthContextPop(sContext);
		sqlite3SrcListDelete(db, pTabList);
		sqlite3ExprDelete(db, pWhere);
		sqlite3DbFree(db, aToOpen);
		return;
	}
	public static void sqlite3Detach(Parse pParse, Expr pDbname)
	{
		codeAttach(pParse, (int)(25), sqlite3Detach_detach_func, pDbname, null, null, pDbname);
	}
	public static void sqlite3DropIndex(Parse pParse, SrcList pName, int ifExists)
	{
		Index pIndex;
		Vdbe v;
		sqlite3 db = pParse.db;
		int iDb = 0;
		if ((db.mallocFailed) != 0)
		{
			goto exit_drop_index;
		}

		if (0 != sqlite3ReadSchema(pParse))
		{
			goto exit_drop_index;
		}

		pIndex = sqlite3FindIndex(db, pName.a[0].zName, pName.a[0].zDatabase);
		if ((pIndex) == (null))
		{
			if (ifExists == 0)
			{
				sqlite3ErrorMsg(pParse, "no such index: %S", pName.a);
			}
			else
			{
				sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
				sqlite3ForceNotReadOnly(pParse);
			}

			pParse.checkSchema = (byte)(1);
			goto exit_drop_index;
		}

		if (pIndex.idxType != 0)
		{
			sqlite3ErrorMsg(pParse, "index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped", (int)(0));
			goto exit_drop_index;
		}

		iDb = (int)(sqlite3SchemaToIndex(db, pIndex.pSchema));
		{
			int code = (int)(10);
			Table pTab = pIndex.pTable;
			sbyte* zDb = db.aDb[iDb].zDbSName;
			sbyte* zTab = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
			if ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0)
			{
				goto exit_drop_index;
			}

			if ((0 == 0) && ((iDb) == (1)))
				code = (int)(12);
			if ((sqlite3AuthCheck(pParse, (int)(code), pIndex.zName, pTab.zName, zDb)) != 0)
			{
				goto exit_drop_index;
			}
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) != null)
		{
			sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
			sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='index'", db.aDb[iDb].zDbSName, pIndex.zName);
			sqlite3ClearStatTables(pParse, (int)(iDb), "idx", pIndex.zName);
			sqlite3ChangeCookie(pParse, (int)(iDb));
			destroyRootPage(pParse, (int)(pIndex.tnum), (int)(iDb));
			sqlite3VdbeAddOp4(v, (int)(151), (int)(iDb), (int)(0), (int)(0), pIndex.zName, (int)(0));
		}

	exit_drop_index:
		; sqlite3SrcListDelete(db, pName);
	}
	public static void sqlite3DropTable(Parse pParse, SrcList pName, int isView, int noErr)
	{
		Table pTab;
		Vdbe v;
		sqlite3 db = pParse.db;
		int iDb = 0;
		if ((db.mallocFailed) != 0)
		{
			goto exit_drop_table;
		}

		if ((sqlite3ReadSchema(pParse)) != 0)
			goto exit_drop_table;
		if ((noErr) != 0)
			db.suppressErr++;
		pTab = sqlite3LocateTableItem(pParse, (uint)(isView), pName.a[0]);
		if ((noErr) != 0)
			db.suppressErr--;
		if ((pTab) == (null))
		{
			if ((noErr) != 0)
			{
				sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
				sqlite3ForceNotReadOnly(pParse);
			}

			goto exit_drop_table;
		}

		iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		if ((((pTab).eTabType) == (1)) && ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0))
		{
			goto exit_drop_table;
		}

		{
			int code = 0;
			sbyte* zTab = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
			sbyte* zDb = db.aDb[iDb].zDbSName;
			sbyte* zArg2 = null;
			if ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0)
			{
				goto exit_drop_table;
			}

			if ((isView) != 0)
			{
				if ((0 == 0) && ((iDb) == (1)))
				{
					code = (int)(15);
				}
				else
				{
					code = (int)(17);
				}
			}
			else if ((((pTab).eTabType) == (1)))
			{
				code = (int)(30);
				zArg2 = sqlite3GetVTable(db, pTab).pMod.zName;
			}
			else
			{
				if ((0 == 0) && ((iDb) == (1)))
				{
					code = (int)(13);
				}
				else
				{
					code = (int)(11);
				}
			}

			if ((sqlite3AuthCheck(pParse, (int)(code), pTab.zName, zArg2, zDb)) != 0)
			{
				goto exit_drop_table;
			}

			if ((sqlite3AuthCheck(pParse, (int)(9), pTab.zName, null, zDb)) != 0)
			{
				goto exit_drop_table;
			}
		}

		if ((tableMayNotBeDropped(db, pTab)) != 0)
		{
			sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab.zName);
			goto exit_drop_table;
		}

		if (((isView) != 0) && (!(((pTab).eTabType) == (2))))
		{
			sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab.zName);
			goto exit_drop_table;
		}

		if ((isView == 0) && (((pTab).eTabType) == (2)))
		{
			sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab.zName);
			goto exit_drop_table;
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) != null)
		{
			sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
			if (isView == 0)
			{
				sqlite3ClearStatTables(pParse, (int)(iDb), "tbl", pTab.zName);
				sqlite3FkDropTable(pParse, pName, pTab);
			}

			sqlite3CodeDropTable(pParse, pTab, (int)(iDb), (int)(isView));
		}

	exit_drop_table:
		; sqlite3SrcListDelete(db, pName);
	}
	public static void sqlite3DropTrigger(Parse pParse, SrcList pName, int noErr)
	{
		Trigger pTrigger = null;
		int i = 0;
		sbyte* zDb;
		sbyte* zName;
		sqlite3 db = pParse.db;
		if ((db.mallocFailed) != 0)
			goto drop_trigger_cleanup;
		if (0 != sqlite3ReadSchema(pParse))
		{
			goto drop_trigger_cleanup;
		}

		zDb = pName.a[0].zDatabase;
		zName = pName.a[0].zName;
		for (i = (int)(0); (i) < (db.nDb); i++)
		{
			int j = (int)(((i) < (2)) ? i ^ 1 : i);
			if (((zDb) != null) && ((sqlite3DbIsNamed(db, (int)(j), zDb)) == (0)))
				continue;
			pTrigger = sqlite3HashFind(&(db.aDb[j].pSchema.trigHash), zName);
			if ((pTrigger) != null)
				break;
		}

		if (pTrigger == null)
		{
			if (noErr == 0)
			{
				sqlite3ErrorMsg(pParse, "no such trigger: %S", pName.a);
			}
			else
			{
				sqlite3CodeVerifyNamedSchema(pParse, zDb);
			}

			pParse.checkSchema = (byte)(1);
			goto drop_trigger_cleanup;
		}

		sqlite3DropTriggerPtr(pParse, pTrigger);
	drop_trigger_cleanup:
		; sqlite3SrcListDelete(db, pName);
	}
	public static void sqlite3DropTriggerPtr(Parse pParse, Trigger pTrigger)
	{
		Table pTable;
		Vdbe v;
		sqlite3 db = pParse.db;
		int iDb = 0;
		iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTrigger.pSchema));
		pTable = tableOfTrigger(pTrigger);
		if ((pTable) != null)
		{
			int code = (int)(16);
			sbyte* zDb = db.aDb[iDb].zDbSName;
			sbyte* zTab = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
			if ((iDb) == (1))
				code = (int)(14);
			if (((sqlite3AuthCheck(pParse, (int)(code), pTrigger.zName, pTable.zName, zDb)) != 0) || ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0))
			{
				return;
			}
		}

		if ((v = sqlite3GetVdbe(pParse)) != null)
		{
			sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='trigger'", db.aDb[iDb].zDbSName, pTrigger.zName);
			sqlite3ChangeCookie(pParse, (int)(iDb));
			sqlite3VdbeAddOp4(v, (int)(152), (int)(iDb), (int)(0), (int)(0), pTrigger.zName, (int)(0));
		}
	}
	public static void sqlite3EndTable(Parse pParse, Token* pCons, Token* pEnd, uint tabOpts, Select pSelect)
	{
		Table p;
		sqlite3 db = pParse.db;
		int iDb = 0;
		Index pIdx;
		if (((pEnd) == (null)) && ((pSelect) == (null)))
		{
			return;
		}

		p = pParse.pNewTable;
		if ((p) == (null))
			return;
		if (((pSelect) == (null)) && ((sqlite3ShadowTableName(db, p.zName)) != 0))
		{
			p.tabFlags |= (uint)(0x00001000);
		}

		if ((db.init.busy) != 0)
		{
			if (((pSelect) != null) || ((!(((p).eTabType) == (0))) && ((db.init.newTnum) != 0)))
			{
				sqlite3ErrorMsg(pParse, "");
				return;
			}

			p.tnum = (uint)(db.init.newTnum);
			if ((p.tnum) == (1))
				p.tabFlags |= (uint)(0x00000001);
		}

		if ((tabOpts & 0x00010000) != 0)
		{
			int ii = 0;
			p.tabFlags |= (uint)(0x00010000);
			for (ii = (int)(0); (ii) < (p.nCol); ii++)
			{
				Column* pCol = &p.aCol[ii];
				if ((pCol->eCType) == (0))
				{
					if ((pCol->colFlags & 0x0004) != 0)
					{
						sqlite3ErrorMsg(pParse, "unknown datatype for %s.%s: \"%s\"", p.zName, pCol->zCnName, sqlite3ColumnType(pCol, ""));
					}
					else
					{
						sqlite3ErrorMsg(pParse, "missing datatype for %s.%s", p.zName, pCol->zCnName);
					}

					return;
				}
				else if ((pCol->eCType) == (1))
				{
					pCol->affinity = (sbyte)(0x41);
				}

				if ((((pCol->colFlags & 0x0001) != 0) && (p.iPKey != ii)) && ((pCol->notNull) == (0)))
				{
					pCol->notNull = (uint)(2);
					p.tabFlags |= (uint)(0x00000800);
				}
			}
		}

		if ((tabOpts & 0x00000080) != 0)
		{
			if ((p.tabFlags & 0x00000008) != 0)
			{
				sqlite3ErrorMsg(pParse, "AUTOINCREMENT not allowed on WITHOUT ROWID tables");
				return;
			}

			if ((p.tabFlags & 0x00000004) == (0))
			{
				sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p.zName);
				return;
			}

			p.tabFlags |= (uint)(0x00000080 | 0x00000200);
			convertToWithoutRowidTable(pParse, p);
		}

		iDb = (int)(sqlite3SchemaToIndex(db, p.pSchema));
		if ((p.pCheck) != null)
		{
			sqlite3ResolveSelfReference(pParse, p, (int)(0x000004), null, p.pCheck);
			if ((pParse.nErr) != 0)
			{
				sqlite3ExprListDelete(db, p.pCheck);
				p.pCheck = null;
			}
			else
			{
			}
		}

		if ((p.tabFlags & 0x00000060) != 0)
		{
			int ii = 0;
			int nNG = (int)(0);
			for (ii = (int)(0); (ii) < (p.nCol); ii++)
			{
				uint colFlags = (uint)(p.aCol[ii].colFlags);
				if ((colFlags & 0x0060) != 0)
				{
					Expr pX = sqlite3ColumnExpr(p, &p.aCol[ii]);
					if ((sqlite3ResolveSelfReference(pParse, p, (int)(0x000008), pX, null)) != 0)
					{
						sqlite3ColumnSetExpr(pParse, p, &p.aCol[ii], sqlite3ExprAlloc(db, (int)(121), null, (int)(0)));
					}
				}
				else
				{
					nNG++;
				}
			}

			if ((nNG) == (0))
			{
				sqlite3ErrorMsg(pParse, "must have at least one non-generated column");
				return;
			}
		}

		estimateTableWidth(p);
		for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
		{
			estimateIndexWidth(pIdx);
		}

		if (db.init.busy == 0)
		{
			int n = 0;
			Vdbe v;
			sbyte* zType;
			sbyte* zType2;
			sbyte* zStmt;
			v = sqlite3GetVdbe(pParse);
			if (((v) == (null)))
				return;
			sqlite3VdbeAddOp1(v, (int)(121), (int)(0));
			if ((((p).eTabType) == (0)))
			{
				zType = "table";
				zType2 = "TABLE";
			}
			else
			{
				zType = "view";
				zType2 = "VIEW";
			}

			if ((pSelect) != null)
			{
				SelectDest dest = new SelectDest();
				int regYield = 0;
				int addrTop = 0;
				int regRec = 0;
				int regRowid = 0;
				int addrInsLoop = 0;
				Table pSelTab;
				if ((pParse.eParseMode != 0))
				{
					pParse.rc = (int)(1);
					pParse.nErr++;
					return;
				}

				regYield = (int)(++pParse.nMem);
				regRec = (int)(++pParse.nMem);
				regRowid = (int)(++pParse.nMem);
				sqlite3MayAbort(pParse);
				sqlite3VdbeAddOp3(v, (int)(112), (int)(1), (int)(pParse.regRoot), (int)(iDb));
				sqlite3VdbeChangeP5(v, (ushort)(0x10));
				pParse.nTab = (int)(2);
				addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
				sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(addrTop));
				if ((pParse.nErr) != 0)
					return;
				pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, (sbyte)(0x41));
				if ((pSelTab) == (null))
					return;
				p.nCol = (short)(p.nNVCol = (short)(pSelTab.nCol));
				p.aCol = pSelTab.aCol;
				pSelTab.nCol = (short)(0);
				pSelTab.aCol = null;
				sqlite3DeleteTable(db, pSelTab);
				sqlite3SelectDestInit(dest, (int)(13), (int)(regYield));
				sqlite3Select(pParse, pSelect, dest);
				if ((pParse.nErr) != 0)
					return;
				sqlite3VdbeEndCoroutine(v, (int)(regYield));
				sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
				addrInsLoop = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm)));
				sqlite3VdbeAddOp3(v, (int)(96), (int)(dest.iSdst), (int)(dest.nSdst), (int)(regRec));
				sqlite3TableAffinity(v, p, (int)(0));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(1), (int)(regRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(1), (int)(regRec), (int)(regRowid));
				sqlite3VdbeGoto(v, (int)(addrInsLoop));
				sqlite3VdbeJumpHere(v, (int)(addrInsLoop));
				sqlite3VdbeAddOp1(v, (int)(121), (int)(1));
			}

			if ((pSelect) != null)
			{
				zStmt = createTableStmt(db, p);
			}
			else
			{
				Token* pEnd2 = (tabOpts) != 0 ? &pParse.sLastToken : pEnd;
				n = ((int)(pEnd2->z - pParse.sNameToken.z));
				if (pEnd2->z[0] != 59)
					n += (int)(pEnd2->n);
				zStmt = sqlite3MPrintf(db, "CREATE %s %.*s", zType2, (int)(n), pParse.sNameToken.z);
			}

			sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q WHERE rowid=#%d", db.aDb[iDb].zDbSName, zType, p.zName, p.zName, (int)(pParse.regRoot), zStmt, (int)(pParse.regRowid));
			sqlite3DbFree(db, zStmt);
			sqlite3ChangeCookie(pParse, (int)(iDb));
			if (((p.tabFlags & 0x00000008) != 0) && (!(pParse.eParseMode != 0)))
			{
				Db pDb = db.aDb[iDb];
				if ((pDb.pSchema.pSeqTab) == (null))
				{
					sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", pDb.zDbSName);
				}
			}

			sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p.zName), (ushort)(0));
		}

		if ((db.init.busy) != 0)
		{
			Table pOld;
			Schema pSchema = p.pSchema;
			pOld = sqlite3HashInsert(&pSchema.tblHash, p.zName, p);
			if ((pOld) != null)
			{
				sqlite3OomFault(db);
				return;
			}

			pParse.pNewTable = null;
			db.mDbFlags |= (uint)(0x0001);
			if ((CRuntime.strcmp(p.zName, "sqlite_sequence")) == (0))
			{
				p.pSchema.pSeqTab = p;
			}
		}

		if ((pSelect == null) && (((p).eTabType) == (0)))
		{
			if ((pCons->z) == (null))
			{
				pCons = pEnd;
			}

			p.u.tab.addColOffset = (int)(13 + (int)(pCons->z - pParse.sNameToken.z));
		}
	}
	public static void sqlite3EndTransaction(Parse pParse, int eType)
	{
		Vdbe v;
		int isRollback = 0;
		isRollback = (int)((eType) == (12) ? 1 : 0);
		if ((sqlite3AuthCheck(pParse, (int)(22), (isRollback) != 0 ? "ROLLBACK" : "COMMIT", null, null)) != 0)
		{
			return;
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) != null)
		{
			sqlite3VdbeAddOp2(v, (int)(1), (int)(1), (int)(isRollback));
		}
	}
	public static void sqlite3ErrorIfNotEmpty(Parse pParse, sbyte* zDb, sbyte* zTab, sbyte* zErr)
	{
		sqlite3NestedParse(pParse, "SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"", zErr, zDb, zTab);
	}
	public static void sqlite3ErrorMsg(Parse pParse, sbyte* zFormat)
	{
		sbyte* zMsg;
		sbyte* ap;
		sqlite3 db = pParse.db;
		db.errByteOffset = (int)(-2);
		(__va_start(&ap, zFormat));
		zMsg = sqlite3VMPrintf(db, zFormat, ap);
		((void)(ap = null));
		if ((db.errByteOffset) < (-1))
			db.errByteOffset = (int)(-1);
		if ((db.suppressErr) != 0)
		{
			sqlite3DbFree(db, zMsg);
			if ((db.mallocFailed) != 0)
			{
				pParse.nErr++;
				pParse.rc = (int)(7);
			}
		}
		else
		{
			pParse.nErr++;
			sqlite3DbFree(db, pParse.zErrMsg);
			pParse.zErrMsg = zMsg;
			pParse.rc = (int)(1);
			pParse.pWith = null;
		}
	}
	public static ExprList sqlite3ExpandReturning(Parse pParse, ExprList pList, Table pTab)
	{
		ExprList pNew = null;
		sqlite3 db = pParse.db;
		int i = 0;
		for (i = (int)(0); (i) < (pList.nExpr); i++)
		{
			Expr pOldExpr = pList.a[i].pExpr;
			if (((pOldExpr) == (null)))
				continue;
			if ((isAsteriskTerm(pParse, pOldExpr)) != 0)
			{
				int jj = 0;
				for (jj = (int)(0); (jj) < (pTab.nCol); jj++)
				{
					Expr pNewExpr;
					if ((((pTab.aCol + jj)->colFlags & 0x0002) != 0))
						continue;
					pNewExpr = sqlite3Expr(db, (int)(59), pTab.aCol[jj].zCnName);
					pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
					if (db.mallocFailed == 0)
					{
						ExprList_item* pItem = &pNew.a[pNew.nExpr - 1];
						pItem->zEName = sqlite3DbStrDup(db, pTab.aCol[jj].zCnName);
						pItem->eEName = (uint)(0);
					}
				}
			}
			else
			{
				Expr pNewExpr = sqlite3ExprDup(db, pOldExpr, (int)(0));
				pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
				if ((db.mallocFailed == 0) && (pList.a[i].zEName != null))
				{
					ExprList_item* pItem = &pNew.a[pNew.nExpr - 1];
					pItem->zEName = sqlite3DbStrDup(db, pList.a[i].zEName);
					pItem->eEName = (uint)(pList.a[i].eEName);
				}
			}
		}

		return pNew;
	}
	public static int sqlite3ExpandSubquery(Parse pParse, SrcItem pFrom)
	{
		Select pSel = pFrom.pSelect;
		Table pTab;
		pFrom.pTab = pTab = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(Table)));
		if ((pTab) == (null))
			return (int)(7);
		pTab.nTabRef = (uint)(1);
		if ((pFrom.zAlias) != null)
		{
			pTab.zName = sqlite3DbStrDup(pParse.db, pFrom.zAlias);
		}
		else
		{
			pTab.zName = sqlite3MPrintf(pParse.db, "subquery_%u", (uint)(pSel.selId));
		}

		while ((pSel.pPrior) != null)
		{
			pSel = pSel.pPrior;
		}

		sqlite3ColumnsFromExprList(pParse, pSel.pEList, &pTab.nCol, &pTab.aCol);
		pTab.iPKey = (short)(-1);
		pTab.nRowLogEst = (short)(200);
		pTab.tabFlags |= (uint)(0x00004000 | 0x00000200);
		return (int)((pParse.nErr) != 0 ? 1 : 0);
	}
	public static Expr sqlite3ExprAddCollateString(Parse pParse, Expr pExpr, sbyte* zC)
	{
		Token s = new Token();
		sqlite3TokenInit(&s, zC);
		return sqlite3ExprAddCollateToken(pParse, pExpr, &s, (int)(0));
	}
	public static Expr sqlite3ExprAddCollateToken(Parse pParse, Expr pExpr, Token* pCollName, int dequote)
	{
		if ((pCollName->n) > (0))
		{
			Expr pNew = sqlite3ExprAlloc(pParse.db, (int)(113), pCollName, (int)(dequote));
			if ((pNew) != null)
			{
				pNew.pLeft = pExpr;
				pNew.flags |= (uint)(0x000100 | 0x001000);
				pExpr = pNew;
			}
		}

		return pExpr;
	}
	public static Expr sqlite3ExprAnd(Parse pParse, Expr pLeft, Expr pRight)
	{
		sqlite3 db = pParse.db;
		if ((pLeft) == (null))
		{
			return pRight;
		}
		else if ((pRight) == (null))
		{
			return pLeft;
		}
		else if (((((pLeft).flags & (0x000001 | 0x20000000)) == (0x20000000)) || (((pRight).flags & (0x000001 | 0x20000000)) == (0x20000000))) && (!((pParse.eParseMode) >= (2))))
		{
			sqlite3ExprDeferredDelete(pParse, pLeft);
			sqlite3ExprDeferredDelete(pParse, pRight);
			return sqlite3Expr(db, (int)(155), "0");
		}
		else
		{
			return sqlite3PExpr(pParse, (int)(44), pLeft, pRight);
		}
	}
	public static void sqlite3ExprAssignVarNumber(Parse pParse, Expr pExpr, uint n)
	{
		sqlite3 db = pParse.db;
		sbyte* z;
		short x = 0;
		if ((pExpr) == (null))
			return;
		z = pExpr.u.zToken;
		if ((z[1]) == (0))
		{
			x = (short)(++pParse.nVar);
		}
		else
		{
			int doAdd = (int)(0);
			if ((z[0]) == (63))
			{
				long i = 0;
				int bOk = 0;
				if ((n) == (2))
				{
					i = (long)(z[1] - 48);
					bOk = (int)(1);
				}
				else
				{
					bOk = (int)((0) == (sqlite3Atoi64(&z[1], &i, (int)(n - 1), (byte)(1))) ? 1 : 0);
				}

				if ((((bOk) == (0)) || ((i) < (1))) || ((i) > (db.aLimit[9])))
				{
					sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", (int)(db.aLimit[9]));
					sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
					return;
				}

				x = ((short)(i));
				if ((x) > (pParse.nVar))
				{
					pParse.nVar = (short)((int)(x));
					doAdd = (int)(1);
				}
				else if ((sqlite3VListNumToName(pParse.pVList, (int)(x))) == (null))
				{
					doAdd = (int)(1);
				}
			}
			else
			{
				x = ((short)(sqlite3VListNameToNum(pParse.pVList, z, (int)(n))));
				if ((x) == (0))
				{
					x = (short)(++pParse.nVar);
					doAdd = (int)(1);
				}
			}

			if ((doAdd) != 0)
			{
				pParse.pVList = sqlite3VListAdd(db, pParse.pVList, z, (int)(n), (int)(x));
			}
		}

		pExpr.iColumn = (short)(x);
		if ((x) > (db.aLimit[9]))
		{
			sqlite3ErrorMsg(pParse, "too many SQL variables");
			sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
		}
	}
	public static int sqlite3ExprCheckHeight(Parse pParse, int nHeight)
	{
		int rc = (int)(0);
		int mxHeight = (int)(pParse.db.aLimit[3]);
		if ((nHeight) > (mxHeight))
		{
			sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", (int)(mxHeight));
			rc = (int)(1);
		}

		return (int)(rc);
	}
	public static int sqlite3ExprCheckIN(Parse pParse, Expr pIn)
	{
		int nVector = (int)(sqlite3ExprVectorSize(pIn.pLeft));
		if ((((pIn).flags & 0x000800) != 0) && (pParse.db.mallocFailed == 0))
		{
			if (nVector != pIn.x.pSelect.pEList.nExpr)
			{
				sqlite3SubselectError(pParse, (int)(pIn.x.pSelect.pEList.nExpr), (int)(nVector));
				return (int)(1);
			}
		}
		else if (nVector != 1)
		{
			sqlite3VectorErrorMsg(pParse, pIn.pLeft);
			return (int)(1);
		}

		return (int)(0);
	}
	public static void sqlite3ExprCode(Parse pParse, Expr pExpr, int target)
	{
		int inReg = 0;
		if ((pParse.pVdbe) == (null))
			return;
		inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(target)));
		if (inReg != target)
		{
			byte op = 0;
			if (((pExpr) != null) && (((pExpr).flags & (0x200000)) != 0))
			{
				op = (byte)(79);
			}
			else
			{
				op = (byte)(80);
			}

			sqlite3VdbeAddOp2(pParse.pVdbe, (int)(op), (int)(inReg), (int)(target));
		}
	}
	public static void sqlite3ExprCodeCopy(Parse pParse, Expr pExpr, int target)
	{
		sqlite3 db = pParse.db;
		pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
		if (db.mallocFailed == 0)
			sqlite3ExprCode(pParse, pExpr, (int)(target));
		sqlite3ExprDelete(db, pExpr);
	}
	public static int sqlite3ExprCodeExprList(Parse pParse, ExprList pList, int target, int srcReg, byte flags)
	{
		ExprList_item* pItem;
		int i = 0; int j = 0; int n = 0;
		byte copyOp = (byte)((flags & 0x01) ? 79 : 80);
		Vdbe v = pParse.pVdbe;
		n = (int)(pList.nExpr);
		if (((pParse).okConstFactor) == 0)
			flags &= (byte)(~0x02);
		for (pItem = pList.a, i = (int)(0); (i) < (n); i++, pItem++)
		{
			Expr pExpr = pItem->pExpr;
			if (((flags & 0x04) != 0) && ((j = (int)(pItem->u.x.iOrderByCol)) > (0)))
			{
				if ((flags & 0x08) != 0)
				{
					i--;
					n--;
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(copyOp), (int)(j + srcReg - 1), (int)(target + i));
				}
			}
			else if (((flags & 0x02) != 0) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
			{
				sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(target + i));
			}
			else
			{
				int inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(target + i)));
				if (inReg != target + i)
				{
					VdbeOp* pOp;
					if ((((((copyOp) == (79)) && (((pOp = sqlite3VdbeGetOp(v, (int)(-1)))->opcode) == (79))) && ((pOp->p1 + pOp->p3 + 1) == (inReg))) && ((pOp->p2 + pOp->p3 + 1) == (target + i))) && ((pOp->p5) == (0)))
					{
						pOp->p3++;
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(copyOp), (int)(inReg), (int)(target + i));
					}
				}
			}
		}

		return (int)(n);
	}
	public static void sqlite3ExprCodeFactorable(Parse pParse, Expr pExpr, int target)
	{
		if (((pParse.okConstFactor) != 0) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
		{
			sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(target));
		}
		else
		{
			sqlite3ExprCodeCopy(pParse, pExpr, (int)(target));
		}
	}
	public static void sqlite3ExprCodeGeneratedColumn(Parse pParse, Table pTab, Column* pCol, int regOut)
	{
		int iAddr = 0;
		Vdbe v = pParse.pVdbe;
		if ((pParse.iSelfTab) > (0))
		{
			iAddr = (int)(sqlite3VdbeAddOp3(v, (int)(22), (int)(pParse.iSelfTab - 1), (int)(0), (int)(regOut)));
		}
		else
		{
			iAddr = (int)(0);
		}

		sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), (int)(regOut));
		if ((pCol->affinity) >= (0x42))
		{
			sqlite3VdbeAddOp4(v, (int)(95), (int)(regOut), (int)(1), (int)(0), &pCol->affinity, (int)(1));
		}

		if ((iAddr) != 0)
			sqlite3VdbeJumpHere(v, (int)(iAddr));
	}
	public static int sqlite3ExprCodeGetColumn(Parse pParse, Table pTab, int iColumn, int iTable, int iReg, byte p5)
	{
		sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pTab, (int)(iTable), (int)(iColumn), (int)(iReg));
		if ((p5) != 0)
		{
			VdbeOp* pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(-1));
			if ((pOp->opcode) == (93))
				pOp->p5 = (ushort)(p5);
		}

		return (int)(iReg);
	}
	public static void sqlite3ExprCodeIN(Parse pParse, Expr pExpr, int destIfFalse, int destIfNull)
	{
		int rRhsHasNull = (int)(0);
		int eType = 0;
		int rLhs = 0;
		int rLhsOrig = 0;
		Vdbe v;
		int* aiMap = null;
		sbyte* zAff = null;
		int nVector = 0;
		int iDummy = 0;
		Expr pLeft;
		int i = 0;
		int destStep2 = 0;
		int destStep6 = (int)(0);
		int addrTruthOp = 0;
		int destNotNull = 0;
		int addrTop = 0;
		int iTab = (int)(0);
		byte okConstFactor = (byte)(pParse.okConstFactor);
		pLeft = pExpr.pLeft;
		if ((sqlite3ExprCheckIN(pParse, pExpr)) != 0)
			return;
		zAff = exprINAffinity(pParse, pExpr);
		nVector = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
		aiMap = (int*)(sqlite3DbMallocZero(pParse.db, (ulong)(nVector * (sizeof(int) + sizeof(char)) + 1)));
		if ((pParse.db.mallocFailed) != 0)
			goto sqlite3ExprCodeIN_oom_error;
		v = pParse.pVdbe;
		eType = (int)(sqlite3FindInIndex(pParse, pExpr, (uint)(0x0002 | 0x0001), (destIfFalse) == (destIfNull) ? null : &rRhsHasNull, aiMap, &iTab));
		pParse.okConstFactor = (byte)(0);
		rLhsOrig = (int)(exprCodeVector(pParse, pLeft, &iDummy));
		pParse.okConstFactor = (byte)(okConstFactor);
		for (i = (int)(0); ((i) < (nVector)) && ((aiMap[i]) == (i)); i++)
		{
		}

		if ((i) == (nVector))
		{
			rLhs = (int)(rLhsOrig);
		}
		else
		{
			rLhs = (int)(sqlite3GetTempRange(pParse, (int)(nVector)));
			for (i = (int)(0); (i) < (nVector); i++)
			{
				sqlite3VdbeAddOp3(v, (int)(79), (int)(rLhsOrig + i), (int)(rLhs + aiMap[i]), (int)(0));
			}
		}

		if ((eType) == (5))
		{
			ExprList pList;
			CollSeq pColl;
			int labelOk = (int)(sqlite3VdbeMakeLabel(pParse));
			int r2 = 0;
			int regToFree = 0;
			int regCkNull = (int)(0);
			int ii = 0;
			pList = pExpr.x.pList;
			pColl = sqlite3ExprCollSeq(pParse, pExpr.pLeft);
			if (destIfNull != destIfFalse)
			{
				regCkNull = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp3(v, (int)(102), (int)(rLhs), (int)(rLhs), (int)(regCkNull));
			}

			for (ii = (int)(0); (ii) < (pList.nExpr); ii++)
			{
				r2 = (int)(sqlite3ExprCodeTemp(pParse, pList.a[ii].pExpr, &regToFree));
				if (((regCkNull) != 0) && ((sqlite3ExprCanBeNull(pList.a[ii].pExpr)) != 0))
				{
					sqlite3VdbeAddOp3(v, (int)(102), (int)(regCkNull), (int)(r2), (int)(regCkNull));
				}

				sqlite3ReleaseTempReg(pParse, (int)(regToFree));
				if (((ii) < (pList.nExpr - 1)) || (destIfNull != destIfFalse))
				{
					int op = (int)(rLhs != r2 ? 53 : 51);
					sqlite3VdbeAddOp4(v, (int)(op), (int)(rLhs), (int)(labelOk), (int)(r2), (void*)(pColl), (int)(-2));
					sqlite3VdbeChangeP5(v, (ushort)(zAff[0]));
				}
				else
				{
					int op = (int)(rLhs != r2 ? 52 : 50);
					sqlite3VdbeAddOp4(v, (int)(op), (int)(rLhs), (int)(destIfFalse), (int)(r2), (void*)(pColl), (int)(-2));
					sqlite3VdbeChangeP5(v, (ushort)(zAff[0] | 0x10));
				}
			}

			if ((regCkNull) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(50), (int)(regCkNull), (int)(destIfNull));
				sqlite3VdbeGoto(v, (int)(destIfFalse));
			}

			sqlite3VdbeResolveLabel(v, (int)(labelOk));
			sqlite3ReleaseTempReg(pParse, (int)(regCkNull));
			goto sqlite3ExprCodeIN_finished;
		}

		if ((destIfNull) == (destIfFalse))
		{
			destStep2 = (int)(destIfFalse);
		}
		else
		{
			destStep2 = (int)(destStep6 = (int)(sqlite3VdbeMakeLabel(pParse)));
		}

		for (i = (int)(0); (i) < (nVector); i++)
		{
			Expr p = sqlite3VectorFieldSubexpr(pExpr.pLeft, (int)(i));
			if ((pParse.nErr) != 0)
				goto sqlite3ExprCodeIN_oom_error;
			if ((sqlite3ExprCanBeNull(p)) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(50), (int)(rLhs + i), (int)(destStep2));
			}
		}

		if ((eType) == (1))
		{
			sqlite3VdbeAddOp3(v, (int)(32), (int)(iTab), (int)(destIfFalse), (int)(rLhs));
			addrTruthOp = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
		}
		else
		{
			sqlite3VdbeAddOp4(v, (int)(95), (int)(rLhs), (int)(nVector), (int)(0), zAff, (int)(nVector));
			if ((destIfFalse) == (destIfNull))
			{
				sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iTab), (int)(destIfFalse), (int)(rLhs), (int)(nVector));
				goto sqlite3ExprCodeIN_finished;
			}

			addrTruthOp = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iTab), (int)(0), (int)(rLhs), (int)(nVector)));
		}

		if (((rRhsHasNull) != 0) && ((nVector) == (1)))
		{
			sqlite3VdbeAddOp2(v, (int)(51), (int)(rRhsHasNull), (int)(destIfFalse));
		}

		if ((destIfFalse) == (destIfNull))
			sqlite3VdbeGoto(v, (int)(destIfFalse));
		if ((destStep6) != 0)
			sqlite3VdbeResolveLabel(v, (int)(destStep6));
		addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iTab), (int)(destIfFalse)));
		if ((nVector) > (1))
		{
			destNotNull = (int)(sqlite3VdbeMakeLabel(pParse));
		}
		else
		{
			destNotNull = (int)(destIfFalse);
		}

		for (i = (int)(0); (i) < (nVector); i++)
		{
			Expr p;
			CollSeq pColl;
			int r3 = (int)(sqlite3GetTempReg(pParse));
			p = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
			pColl = sqlite3ExprCollSeq(pParse, p);
			sqlite3VdbeAddOp3(v, (int)(93), (int)(iTab), (int)(i), (int)(r3));
			sqlite3VdbeAddOp4(v, (int)(52), (int)(rLhs + i), (int)(destNotNull), (int)(r3), (void*)(pColl), (int)(-2));
			sqlite3ReleaseTempReg(pParse, (int)(r3));
		}

		sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(destIfNull));
		if ((nVector) > (1))
		{
			sqlite3VdbeResolveLabel(v, (int)(destNotNull));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addrTop + 1));
			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(destIfFalse));
		}

		sqlite3VdbeJumpHere(v, (int)(addrTruthOp));
	sqlite3ExprCodeIN_finished:
		; if (rLhs != rLhsOrig) sqlite3ReleaseTempReg(pParse, (int)(rLhs));
		sqlite3ExprCodeIN_oom_error:
		; sqlite3DbFree(pParse.db, aiMap);
		sqlite3DbFree(pParse.db, zAff);
	}
	public static void sqlite3ExprCodeLoadIndexColumn(Parse pParse, Index pIdx, int iTabCur, int iIdxCol, int regOut)
	{
		short iTabCol = (short)(pIdx.aiColumn[iIdxCol]);
		if ((iTabCol) == (-2))
		{
			pParse.iSelfTab = (int)(iTabCur + 1);
			sqlite3ExprCodeCopy(pParse, pIdx.aColExpr.a[iIdxCol].pExpr, (int)(regOut));
			pParse.iSelfTab = (int)(0);
		}
		else
		{
			sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pIdx.pTable, (int)(iTabCur), (int)(iTabCol), (int)(regOut));
		}
	}
	public static void sqlite3ExprCodeMove(Parse pParse, int iFrom, int iTo, int nReg)
	{
		sqlite3VdbeAddOp3(pParse.pVdbe, (int)(78), (int)(iFrom), (int)(iTo), (int)(nReg));
	}
	public static int sqlite3ExprCodeRunJustOnce(Parse pParse, Expr pExpr, int regDest)
	{
		ExprList p;
		p = pParse.pConstExpr;
		if (((regDest) < (0)) && ((p) != null))
		{
			ExprList_item* pItem;
			int i = 0;
			for (pItem = p.a, i = (int)(p.nExpr); (i) > (0); pItem++, i--)
			{
				if (((pItem->reusable) != 0) && ((sqlite3ExprCompare(null, pItem->pExpr, pExpr, (int)(-1))) == (0)))
				{
					return (int)(pItem->u.iConstExprReg);
				}
			}
		}

		pExpr = sqlite3ExprDup(pParse.db, pExpr, (int)(0));
		if ((pExpr != null) && (((pExpr).flags & (0x000004)) != 0))
		{
			Vdbe v = pParse.pVdbe;
			int addr = 0;
			addr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			pParse.okConstFactor = (byte)(0);
			if (pParse.db.mallocFailed == 0)
			{
				if ((regDest) < (0))
					regDest = (int)(++pParse.nMem);
				sqlite3ExprCode(pParse, pExpr, (int)(regDest));
			}

			pParse.okConstFactor = (byte)(1);
			sqlite3ExprDelete(pParse.db, pExpr);
			sqlite3VdbeJumpHere(v, (int)(addr));
		}
		else
		{
			p = sqlite3ExprListAppend(pParse, p, pExpr);
			if ((p) != null)
			{
				ExprList_item* pItem = &p.a[p.nExpr - 1];
				pItem->reusable = (uint)((regDest) < (0));
				if ((regDest) < (0))
					regDest = (int)(++pParse.nMem);
				pItem->u.iConstExprReg = (int)(regDest);
			}

			pParse.pConstExpr = p;
		}

		return (int)(regDest);
	}
	public static int sqlite3ExprCodeTarget(Parse pParse, Expr pExpr, int target)
	{
		Vdbe v = pParse.pVdbe;
		int op = 0;
		int inReg = (int)(target);
		int regFree1 = (int)(0);
		int regFree2 = (int)(0);
		int r1 = 0; int r2 = 0;
		Expr tempX = new Expr();
		int p5 = (int)(0);
	expr_code_doover:
		; if ((pExpr) == (null)) { op = (int)(121); } else { op = (int)(pExpr.op); }
		switch (op)
		{
			case 169:
				{
					AggInfo pAggInfo = pExpr.pAggInfo;
					AggInfo_col pCol;
					pCol = pAggInfo.aCol[pExpr.iAgg];
					if (pAggInfo.directMode == 0)
					{
						return (int)(pCol.iMem);
					}
					else if ((pAggInfo.useSortingIdx) != 0)
					{
						Table pTab = pCol.pTab;
						sqlite3VdbeAddOp3(v, (int)(93), (int)(pAggInfo.sortingIdxPTab), (int)(pCol.iSorterColumn), (int)(target));
						if ((pCol.iColumn) < (0))
						{
						}
						else
						{
							if ((pTab.aCol[pCol.iColumn].affinity) == (0x45))
							{
								sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
							}
						}

						return (int)(target);
					}
				}

			case 167:
				{
					int iTab = (int)(pExpr.iTable);
					int iReg = 0;
					if ((((pExpr).flags & (0x000008)) != 0))
					{
						int aff = 0;
						iReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
						if ((pExpr.y.pTab) != null)
						{
							aff = (int)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
						}
						else
						{
							aff = (int)(pExpr.affExpr);
						}

						if ((aff) > (0x41))
						{
							sqlite3VdbeAddOp4(v, (int)(95), (int)(iReg), (int)(1), (int)(0), &sqlite3ExprCodeTarget_zAff[(aff - 66) * 2], (int)(-1));
						}

						return (int)(iReg);
					}

					if ((iTab) < (0))
					{
						if ((pParse.iSelfTab) < (0))
						{
							Column* pCol;
							Table pTab;
							int iSrc = 0;
							int iCol = (int)(pExpr.iColumn);
							pTab = pExpr.y.pTab;
							if ((iCol) < (0))
							{
								return (int)(-1 - pParse.iSelfTab);
							}

							pCol = pTab.aCol + iCol;
							iSrc = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)) - pParse.iSelfTab);
							if ((pCol->colFlags & 0x0060) != 0)
							{
								if ((pCol->colFlags & 0x0100) != 0)
								{
									sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol->zCnName);
									return (int)(0);
								}

								pCol->colFlags |= (ushort)(0x0100);
								if ((pCol->colFlags & 0x0080) != 0)
								{
									sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(iSrc));
								}

								pCol->colFlags &= (ushort)(~(0x0100 | 0x0080));
								return (int)(iSrc);
							}
							else if ((pCol->affinity) == (0x45))
							{
								sqlite3VdbeAddOp2(v, (int)(80), (int)(iSrc), (int)(target));
								sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
								return (int)(target);
							}
							else
							{
								return (int)(iSrc);
							}
						}
						else
						{
							iTab = (int)(pParse.iSelfTab - 1);
						}
					}

					iReg = (int)(sqlite3ExprCodeGetColumn(pParse, pExpr.y.pTab, (int)(pExpr.iColumn), (int)(iTab), (int)(target), (byte)(pExpr.op2)));
					if (((pExpr.y.pTab) == (null)) && ((pExpr.affExpr) == (0x45)))
					{
						sqlite3VdbeAddOp1(v, (int)(86), (int)(iReg));
					}

					return (int)(iReg);
				}

			case 155:
				{
					codeInteger(pParse, pExpr, (int)(0), (int)(target));
					return (int)(target);
				}

			case 170:
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprTruthValue(pExpr)), (int)(target));
					return (int)(target);
				}

			case 153:
				{
					codeReal(v, pExpr.u.zToken, (int)(0), (int)(target));
					return (int)(target);
				}

			case 117:
				{
					sqlite3VdbeLoadString(v, (int)(target), pExpr.u.zToken);
					return (int)(target);
				}

			default:
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
					return (int)(target);
				}

			case 154:
				{
					int n = 0;
					sbyte* z;
					sbyte* zBlob;
					z = &pExpr.u.zToken[2];
					n = (int)(sqlite3Strlen30(z) - 1);
					zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, (int)(n));
					sqlite3VdbeAddOp4(v, (int)(76), (int)(n / 2), (int)(target), (int)(0), zBlob, (int)(-7));
					return (int)(target);
				}

			case 156:
				{
					sqlite3VdbeAddOp2(v, (int)(77), (int)(pExpr.iColumn), (int)(target));
					if (pExpr.u.zToken[1] != 0)
					{
						sbyte* z = sqlite3VListNumToName(pParse.pVList, (int)(pExpr.iColumn));
						pParse.pVList[0] = (int)(0);
						sqlite3VdbeAppendP4(v, z, (int)(-1));
					}

					return (int)(target);
				}

			case 176:
				{
					return (int)(pExpr.iTable);
				}

			case 36:
				{
					inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
					if (inReg != target)
					{
						sqlite3VdbeAddOp2(v, (int)(80), (int)(inReg), (int)(target));
						inReg = (int)(target);
					}

					sqlite3VdbeAddOp2(v, (int)(87), (int)(target), (int)(sqlite3AffinityType(pExpr.u.zToken, null)));
					return (int)(inReg);
				}

			case 45:
			case 171:
				op = (int)(((op) == (45)) ? 53 : 52);
				p5 = (int)(0x80);
			case 56:
			case 55:
			case 54:
			case 57:
			case 52:
			case 53:
				{
					Expr pLeft = pExpr.pLeft;
					if ((sqlite3ExprIsVector(pLeft)) != 0)
					{
						codeVectorCompare(pParse, pExpr, (int)(target), (byte)(op), (byte)(p5));
					}
					else
					{
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pLeft, &regFree1));
						r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(inReg));
						codeCompare(pParse, pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(p5), (int)(((pExpr).flags & (0x000200)) != 0));
						if ((p5) == (0x80))
						{
							sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(inReg));
						}
						else
						{
							sqlite3VdbeAddOp3(v, (int)(91), (int)(r1), (int)(inReg), (int)(r2));
						}
					}

					break;
				}

			case 44:
			case 43:
			case 106:
			case 108:
			case 107:
			case 110:
			case 102:
			case 103:
			case 109:
			case 104:
			case 105:
			case 111:
				{
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
					sqlite3VdbeAddOp3(v, (int)(op), (int)(r2), (int)(r1), (int)(target));
					break;
				}

			case 173:
				{
					Expr pLeft = pExpr.pLeft;
					if ((pLeft.op) == (155))
					{
						codeInteger(pParse, pLeft, (int)(1), (int)(target));
						return (int)(target);
					}
					else if ((pLeft.op) == (153))
					{
						codeReal(v, pLeft.u.zToken, (int)(1), (int)(target));
						return (int)(target);
					}
					else
					{
						tempX.op = (byte)(155);
						tempX.flags = (uint)(0x000400 | 0x004000);
						tempX.u.iValue = (int)(0);
						r1 = (int)(sqlite3ExprCodeTemp(pParse, tempX, &regFree1));
						r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree2));
						sqlite3VdbeAddOp3(v, (int)(107), (int)(r2), (int)(r1), (int)(target));
					}

					break;
				}

			case 114:
			case 19:
				{
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(inReg));
					break;
				}

			case 175:
				{
					int isTrue = 0;
					int bNormal = 0;
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
					bNormal = (int)((pExpr.op2) == (45) ? 1 : 0);
					sqlite3VdbeAddOp4Int(v, (int)(90), (int)(r1), (int)(inReg), (int)(!isTrue), (int)(isTrue ^ bNormal));
					break;
				}

			case 50:
			case 51:
				{
					int addr = 0;
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(target));
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					addr = (int)(sqlite3VdbeAddOp1(v, (int)(op), (int)(r1)));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(target));
					sqlite3VdbeJumpHere(v, (int)(addr));
					break;
				}

			case 168:
				{
					AggInfo pInfo = pExpr.pAggInfo;
					if ((((pInfo) == (null)) || ((pExpr.iAgg) < (0))) || ((pExpr.iAgg) >= (pInfo.nFunc)))
					{
						sqlite3ErrorMsg(pParse, "misuse of aggregate: %#T()", pExpr);
					}
					else
					{
						return (int)(pInfo.aFunc[pExpr.iAgg].iMem);
					}

					break;
				}

			case 172:
				{
					ExprList pFarg;
					int nFarg = 0;
					FuncDef pDef;
					sbyte* zId;
					uint constMask = (uint)(0);
					int i = 0;
					sqlite3 db = pParse.db;
					byte enc = (byte)((db).enc);
					CollSeq pColl = null;
					if ((((pExpr).flags & (0x1000000)) != 0))
					{
						return (int)(pExpr.y.pWin.regResult);
					}

					if ((((pParse).okConstFactor) != 0) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
					{
						return (int)(sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(-1)));
					}

					pFarg = pExpr.x.pList;
					nFarg = (int)(pFarg ? pFarg.nExpr : 0);
					zId = pExpr.u.zToken;
					pDef = sqlite3FindFunction(db, zId, (int)(nFarg), (byte)(enc), (byte)(0));
					if (((pDef) == (null)) || (pDef.xFinalize != null))
					{
						sqlite3ErrorMsg(pParse, "unknown function: %#T()", pExpr);
						break;
					}

					if ((pDef.funcFlags & 0x00400000) != 0)
					{
						return (int)(exprCodeInlineFunction(pParse, pFarg, ((int)((long)(pDef.pUserData))), (int)(target)));
					}
					else if ((pDef.funcFlags & (0x00080000 | 0x00200000)) != 0)
					{
						sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
					}

					for (i = (int)(0); (i) < (nFarg); i++)
					{
						if (((i) < (32)) && ((sqlite3ExprIsConstant(pFarg.a[i].pExpr)) != 0))
						{
							constMask |= (uint)(((uint)(1)) << (i));
						}

						if (((pDef.funcFlags & 0x0020) != 0) && (pColl == null))
						{
							pColl = sqlite3ExprCollSeq(pParse, pFarg.a[i].pExpr);
						}
					}

					if ((pFarg) != null)
					{
						if ((constMask) != 0)
						{
							r1 = (int)(pParse.nMem + 1);
							pParse.nMem += (int)(nFarg);
						}
						else
						{
							r1 = (int)(sqlite3GetTempRange(pParse, (int)(nFarg)));
						}

						if ((pDef.funcFlags & (0x0040 | 0x0080)) != 0)
						{
							byte exprOp = 0;
							exprOp = (byte)(pFarg.a[0].pExpr.op);
							if (((exprOp) == (167)) || ((exprOp) == (169)))
							{
								pFarg.a[0].pExpr.op2 = (byte)(pDef.funcFlags & (0x40 | 0x80));
							}
						}

						sqlite3ExprCodeExprList(pParse, pFarg, (int)(r1), (int)(0), (byte)(0x01 | 0x02));
					}
					else
					{
						r1 = (int)(0);
					}

					if (((nFarg) >= (2)) && (((pExpr).flags & (0x000080)) != 0))
					{
						pDef = sqlite3VtabOverloadFunction(db, pDef, (int)(nFarg), pFarg.a[1].pExpr);
					}
					else if ((nFarg) > (0))
					{
						pDef = sqlite3VtabOverloadFunction(db, pDef, (int)(nFarg), pFarg.a[0].pExpr);
					}

					if ((pDef.funcFlags & 0x0020) != 0)
					{
						if (pColl == null)
							pColl = db.pDfltColl;
						sqlite3VdbeAddOp4(v, (int)(84), (int)(0), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
					}

					{
						sqlite3VdbeAddFunctionCall(pParse, (int)(constMask), (int)(r1), (int)(target), (int)(nFarg), pDef, (int)(pExpr.op2));
					}

					if ((nFarg) != 0)
					{
						if ((constMask) == (0))
						{
							sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(nFarg));
						}
						else
						{
						}
					}

					return (int)(target);
				}

			case 20:
			case 138:
				{
					int nCol = 0;
					if ((pParse.db.mallocFailed) != 0)
					{
						return (int)(0);
					}
					else if ((((op) == (138)) && ((((pExpr).flags & 0x000800) != 0) != 0)) && ((nCol = (int)(pExpr.x.pSelect.pEList.nExpr)) != 1))
					{
						sqlite3SubselectError(pParse, (int)(nCol), (int)(1));
					}
					else
					{
						return (int)(sqlite3CodeSubselect(pParse, pExpr));
					}

					break;
				}

			case 178:
				{
					int n = 0;
					if ((pExpr.pLeft.iTable) == (0))
					{
						pExpr.pLeft.iTable = (int)(sqlite3CodeSubselect(pParse, pExpr.pLeft));
					}

					n = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
					if (pExpr.iTable != n)
					{
						sqlite3ErrorMsg(pParse, "%d columns assigned %d values", (int)(pExpr.iTable), (int)(n));
					}

					return (int)(pExpr.pLeft.iTable + pExpr.iColumn);
				}

			case 49:
				{
					int destIfFalse = (int)(sqlite3VdbeMakeLabel(pParse));
					int destIfNull = (int)(sqlite3VdbeMakeLabel(pParse));
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
					sqlite3ExprCodeIN(pParse, pExpr, (int)(destIfFalse), (int)(destIfNull));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(target));
					sqlite3VdbeResolveLabel(v, (int)(destIfFalse));
					sqlite3VdbeAddOp2(v, (int)(85), (int)(target), (int)(0));
					sqlite3VdbeResolveLabel(v, (int)(destIfNull));
					return (int)(target);
				}

			case 48:
				{
					exprCodeBetween(pParse, pExpr, (int)(target), null, (int)(0));
					return (int)(target);
				}

			case 181:
			case 113:
			case 174:
				{
					pExpr = pExpr.pLeft;
					goto expr_code_doover;
				}

			case 77:
				{
					Table pTab;
					int iCol = 0;
					int p1 = 0;
					pTab = pExpr.y.pTab;
					iCol = (int)(pExpr.iColumn);
					p1 = (int)(pExpr.iTable * (pTab.nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, (short)(iCol)));
					sqlite3VdbeAddOp2(v, (int)(156), (int)(p1), (int)(target));
					if (((iCol) >= (0)) && ((pTab.aCol[iCol].affinity) == (0x45)))
					{
						sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
					}

					break;
				}

			case 177:
				{
					sqlite3ErrorMsg(pParse, "row value misused");
					break;
				}

			case 179:
				{
					int addrINR = 0;
					byte okConstFactor = (byte)(pParse.okConstFactor);
					addrINR = (int)(sqlite3VdbeAddOp1(v, (int)(22), (int)(pExpr.iTable)));
					pParse.okConstFactor = (byte)(0);
					inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
					pParse.okConstFactor = (byte)(okConstFactor);
					sqlite3VdbeJumpHere(v, (int)(addrINR));
					sqlite3VdbeChangeP3(v, (int)(addrINR), (int)(inReg));
					break;
				}

			case 157:
				{
					int endLabel = 0;
					int nextCase = 0;
					int nExpr = 0;
					int i = 0;
					ExprList pEList;
					ExprList_item* aListelem;
					Expr opCompare = new Expr();
					Expr pX;
					Expr pTest = null;
					Expr pDel = null;
					sqlite3 db = pParse.db;
					pEList = pExpr.x.pList;
					aListelem = pEList.a;
					nExpr = (int)(pEList.nExpr);
					endLabel = (int)(sqlite3VdbeMakeLabel(pParse));
					if ((pX = pExpr.pLeft) != null)
					{
						pDel = sqlite3ExprDup(db, pX, (int)(0));
						if ((db.mallocFailed) != 0)
						{
							sqlite3ExprDelete(db, pDel);
							break;
						}

						exprToRegister(pDel, (int)(exprCodeVector(pParse, pDel, &regFree1)));
						CRuntime.memset(opCompare, (int)(0), (ulong)(sizeof(Expr)));
						opCompare.op = (byte)(53);
						opCompare.pLeft = pDel;
						pTest = opCompare;
						regFree1 = (int)(0);
					}

					for (i = (int)(0); (i) < (nExpr - 1); i = (int)(i + 2))
					{
						if ((pX) != null)
						{
							opCompare.pRight = aListelem[i].pExpr;
						}
						else
						{
							pTest = aListelem[i].pExpr;
						}

						nextCase = (int)(sqlite3VdbeMakeLabel(pParse));
						sqlite3ExprIfFalse(pParse, pTest, (int)(nextCase), (int)(0x10));
						sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, (int)(target));
						sqlite3VdbeGoto(v, (int)(endLabel));
						sqlite3VdbeResolveLabel(v, (int)(nextCase));
					}

					if ((nExpr & 1) != 0)
					{
						sqlite3ExprCode(pParse, pEList.a[nExpr - 1].pExpr, (int)(target));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
					}

					sqlite3ExprDelete(db, pDel);
					setDoNotMergeFlagOnCopy(v);
					sqlite3VdbeResolveLabel(v, (int)(endLabel));
					break;
				}

			case 71:
				{
					if ((pParse.pTriggerTab == null) && (pParse.nested == 0))
					{
						sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program");
						return (int)(0);
					}

					if ((pExpr.affExpr) == (2))
					{
						sqlite3MayAbort(pParse);
					}

					if ((pExpr.affExpr) == (4))
					{
						sqlite3VdbeAddOp4(v, (int)(70), (int)(0), (int)(4), (int)(0), pExpr.u.zToken, (int)(0));
					}
					else
					{
						sqlite3HaltConstraint(pParse, (int)(pParse.pTriggerTab ? (19 | (7 << 8)) : 1), (int)(pExpr.affExpr), pExpr.u.zToken, (sbyte)(0), (byte)(0));
					}

					break;
				}
		}

		sqlite3ReleaseTempReg(pParse, (int)(regFree1));
		sqlite3ReleaseTempReg(pParse, (int)(regFree2));
		return (int)(inReg);
	}
	public static int sqlite3ExprCodeTemp(Parse pParse, Expr pExpr, int* pReg)
	{
		int r2 = 0;
		pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
		if ((((((pParse).okConstFactor) != 0) && (pExpr != null)) && (pExpr.op != 176)) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
		{
			*pReg = (int)(0);
			r2 = (int)(sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(-1)));
		}
		else
		{
			int r1 = (int)(sqlite3GetTempReg(pParse));
			r2 = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(r1)));
			if ((r2) == (r1))
			{
				*pReg = (int)(r1);
			}
			else
			{
				sqlite3ReleaseTempReg(pParse, (int)(r1));
				*pReg = (int)(0);
			}
		}

		return (int)(r2);
	}
	public static CollSeq sqlite3ExprCollSeq(Parse pParse, Expr pExpr)
	{
		sqlite3 db = pParse.db;
		CollSeq pColl = null;
		Expr p = pExpr;
		while ((p) != null)
		{
			int op = (int)(p.op);
			if ((op) == (176))
				op = (int)(p.op2);
			if ((((op) == (169)) || ((op) == (167))) || ((op) == (77)))
			{
				if (p.y.pTab != null)
				{
					int j = (int)(p.iColumn);
					if ((j) >= (0))
					{
						sbyte* zColl = sqlite3ColumnColl(&p.y.pTab.aCol[j]);
						pColl = sqlite3FindCollSeq(db, (byte)((db).enc), zColl, (int)(0));
					}

					break;
				}
			}

			if (((op) == (36)) || ((op) == (174)))
			{
				p = p.pLeft;
				continue;
			}

			if ((op) == (177))
			{
				p = p.x.pList.a[0].pExpr;
				continue;
			}

			if ((op) == (113))
			{
				pColl = sqlite3GetCollSeq(pParse, (byte)((db).enc), null, p.u.zToken);
				break;
			}

			if ((p.flags & 0x000100) != 0)
			{
				if (((p.pLeft) != null) && ((p.pLeft.flags & 0x000100) != 0))
				{
					p = p.pLeft;
				}
				else
				{
					Expr pNext = p.pRight;
					if ((p.x.pList != null) && (db.mallocFailed == 0))
					{
						int i = 0;
						for (i = (int)(0); ((i) < (p.x.pList.nExpr)); i++)
						{
							if ((((p.x.pList.a[i].pExpr).flags & (0x000100)) != 0))
							{
								pNext = p.x.pList.a[i].pExpr;
								break;
							}
						}
					}

					p = pNext;
				}
			}
			else
			{
				break;
			}
		}

		if ((sqlite3CheckCollSeq(pParse, pColl)) != 0)
		{
			pColl = null;
		}

		return pColl;
	}
	public static int sqlite3ExprCollSeqMatch(Parse pParse, Expr pE1, Expr pE2)
	{
		CollSeq pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
		CollSeq pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
		return ((sqlite3StrICmp(pColl1.zName, pColl2.zName)) == (0) ? 1 : 0);
	}
	public static int sqlite3ExprCompare(Parse pParse, Expr pA, Expr pB, int iTab)
	{
		uint combinedFlags = 0;
		if (((pA) == (null)) || ((pB) == (null)))
		{
			return (int)((pB) == (pA) ? 0 : 2);
		}

		if ((((pParse) != null) && ((pA.op) == (156))) && ((exprCompareVariable(pParse, pA, pB)) != 0))
		{
			return (int)(0);
		}

		combinedFlags = (uint)(pA.flags | pB.flags);
		if ((combinedFlags & 0x000400) != 0)
		{
			if (((pA.flags & pB.flags & 0x000400) != 0) && ((pA.u.iValue) == (pB.u.iValue)))
			{
				return (int)(0);
			}

			return (int)(2);
		}

		if ((pA.op != pB.op) || ((pA.op) == (71)))
		{
			if (((pA.op) == (113)) && ((sqlite3ExprCompare(pParse, pA.pLeft, pB, (int)(iTab))) < (2)))
			{
				return (int)(1);
			}

			if (((pB.op) == (113)) && ((sqlite3ExprCompare(pParse, pA, pB.pLeft, (int)(iTab))) < (2)))
			{
				return (int)(1);
			}

			return (int)(2);
		}

		if ((pA.u.zToken) != null)
		{
			if (((pA.op) == (172)) || ((pA.op) == (168)))
			{
				if (sqlite3StrICmp(pA.u.zToken, pB.u.zToken) != 0)
					return (int)(2);
				if ((((pA).flags & (0x1000000)) != 0) != (((pB).flags & (0x1000000)) != 0))
				{
					return (int)(2);
				}

				if ((((pA).flags & (0x1000000)) != 0))
				{
					if (sqlite3WindowCompare(pParse, pA.y.pWin, pB.y.pWin, (int)(1)) != 0)
					{
						return (int)(2);
					}
				}
			}
			else if ((pA.op) == (121))
			{
				return (int)(0);
			}
			else if ((pA.op) == (113))
			{
				if (sqlite3_stricmp(pA.u.zToken, pB.u.zToken) != 0)
					return (int)(2);
			}
			else if ((((pB.u.zToken != null) && (pA.op != 167)) && (pA.op != 169)) && (CRuntime.strcmp(pA.u.zToken, pB.u.zToken) != 0))
			{
				return (int)(2);
			}
		}

		if ((pA.flags & (0x000002 | 0x000200)) != (pB.flags & (0x000002 | 0x000200)))
			return (int)(2);
		if (((combinedFlags & 0x004000) == (0)))
		{
			if ((combinedFlags & 0x000800) != 0)
				return (int)(2);
			if (((combinedFlags & 0x000008) == (0)) && ((sqlite3ExprCompare(pParse, pA.pLeft, pB.pLeft, (int)(iTab))) != 0))
				return (int)(2);
			if ((sqlite3ExprCompare(pParse, pA.pRight, pB.pRight, (int)(iTab))) != 0)
				return (int)(2);
			if ((sqlite3ExprListCompare(pA.x.pList, pB.x.pList, (int)(iTab))) != 0)
				return (int)(2);
			if (((pA.op != 117) && (pA.op != 170)) && ((combinedFlags & 0x002000) == (0)))
			{
				if (pA.iColumn != pB.iColumn)
					return (int)(2);
				if ((pA.op2 != pB.op2) && ((pA.op) == (175)))
					return (int)(2);
				if (((pA.op != 49) && (pA.iTable != pB.iTable)) && (pA.iTable != iTab))
				{
					return (int)(2);
				}
			}
		}

		return (int)(0);
	}
	public static CollSeq sqlite3ExprCompareCollSeq(Parse pParse, Expr p)
	{
		if ((((p).flags & (0x000200)) != 0))
		{
			return sqlite3BinaryCompareCollSeq(pParse, p.pRight, p.pLeft);
		}
		else
		{
			return sqlite3BinaryCompareCollSeq(pParse, p.pLeft, p.pRight);
		}
	}
	public static void sqlite3ExprDeferredDelete(Parse pParse, Expr pExpr)
	{
		pParse.pConstExpr = sqlite3ExprListAppend(pParse, pParse.pConstExpr, pExpr);
	}
	public static Expr sqlite3ExprForVectorField(Parse pParse, Expr pVector, int iField, int nField)
	{
		Expr pRet;
		if ((pVector.op) == (138))
		{
			pRet = sqlite3PExpr(pParse, (int)(178), null, null);
			if ((pRet) != null)
			{
				pRet.iTable = (int)(nField);
				pRet.iColumn = (short)(iField);
				pRet.pLeft = pVector;
			}
		}
		else
		{
			if ((pVector.op) == (177))
			{
				Expr ppVector;
				ppVector = pVector.x.pList.a[iField].pExpr;
				pVector = ppVector;
				if (((pParse.eParseMode) >= (2)))
				{
					ppVector = null;
					return pVector;
				}
			}

			pRet = sqlite3ExprDup(pParse.db, pVector, (int)(0));
		}

		return pRet;
	}
	public static Expr sqlite3ExprFunction(Parse pParse, ExprList pList, Token* pToken, int eDistinct)
	{
		Expr pNew;
		sqlite3 db = pParse.db;
		pNew = sqlite3ExprAlloc(db, (int)(172), pToken, (int)(1));
		if ((pNew) == (null))
		{
			sqlite3ExprListDelete(db, pList);
			return null;
		}

		pNew.w.iOfst = ((int)(pToken->z - pParse.zTail));
		if ((((pList) != null) && ((pList.nExpr) > (pParse.db.aLimit[6]))) && (pParse.nested == 0))
		{
			sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
		}

		pNew.x.pList = pList;
		(pNew).flags |= (uint)(0x000004);
		sqlite3ExprSetHeightAndFlags(pParse, pNew);
		if ((eDistinct) == (0x0000001))
			(pNew).flags |= (uint)(0x000002);
		return pNew;
	}
	public static void sqlite3ExprFunctionUsable(Parse pParse, Expr pExpr, FuncDef pDef)
	{
		if ((((pExpr).flags & (0x40000000)) != 0))
		{
			if (((pDef.funcFlags & 0x00080000) != 0) || ((pParse.db.flags & 0x00000080) == (0)))
			{
				sqlite3ErrorMsg(pParse, "unsafe use of %#T()", pExpr);
			}
		}
	}
	public static void sqlite3ExprIfFalse(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
	{
		Vdbe v = pParse.pVdbe;
		int op = (int)(0);
		int regFree1 = (int)(0);
		int regFree2 = (int)(0);
		int r1 = 0; int r2 = 0;
		if (((v) == (null)))
			return;
		if ((pExpr) == (null))
			return;
		op = (int)(((pExpr.op + (50 & 1)) ^ 1) - (50 & 1));
		switch (pExpr.op)
		{
			case 44:
			case 43:
				{
					Expr pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
					if (pAlt != pExpr)
					{
						sqlite3ExprIfFalse(pParse, pAlt, (int)(dest), (int)(jumpIfNull));
					}
					else if ((pExpr.op) == (44))
					{
						sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
						sqlite3ExprIfFalse(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
					}
					else
					{
						int d2 = (int)(sqlite3VdbeMakeLabel(pParse));
						sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(d2), (int)(jumpIfNull ^ 0x10));
						sqlite3ExprIfFalse(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
						sqlite3VdbeResolveLabel(v, (int)(d2));
					}

					break;
				}

			case 19:
				{
					sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
					break;
				}

			case 175:
				{
					int isNot = 0;
					int isTrue = 0;
					isNot = (int)((pExpr.op2) == (171) ? 1 : 0);
					isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
					if (isTrue ^ isNot)
					{
						sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0 : 0x10));
					}
					else
					{
						sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0 : 0x10));
					}

					break;
				}

			case 45:
			case 171:
				;
				op = (int)(((pExpr.op) == (45)) ? 52 : 53);
				jumpIfNull = (int)(0x80);
			case 56:
			case 55:
			case 54:
			case 57:
			case 52:
			case 53:
				{
					if ((sqlite3ExprIsVector(pExpr.pLeft)) != 0)
						goto default_expr;
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
					codeCompare(pParse, pExpr.pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(dest), (int)(jumpIfNull), (int)(((pExpr).flags & (0x000200)) != 0));
					break;
				}

			case 50:
			case 51:
				{
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(dest));
					break;
				}

			case 48:
				{
					exprCodeBetween(pParse, pExpr, (int)(dest), sqlite3ExprIfFalse, (int)(jumpIfNull));
					break;
				}

			case 49:
				{
					if ((jumpIfNull) != 0)
					{
						sqlite3ExprCodeIN(pParse, pExpr, (int)(dest), (int)(dest));
					}
					else
					{
						int destIfNull = (int)(sqlite3VdbeMakeLabel(pParse));
						sqlite3ExprCodeIN(pParse, pExpr, (int)(dest), (int)(destIfNull));
						sqlite3VdbeResolveLabel(v, (int)(destIfNull));
					}

					break;
				}

			default:
				{
				default_expr:
					;
					if ((((pExpr).flags & (0x000001 | 0x20000000)) == (0x20000000)))
					{
						sqlite3VdbeGoto(v, (int)(dest));
					}
					else if ((((pExpr).flags & (0x000001 | 0x10000000)) == (0x10000000)))
					{
					}
					else
					{
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr, &regFree1));
						sqlite3VdbeAddOp3(v, (int)(20), (int)(r1), (int)(dest), (int)(jumpIfNull != 0));
					}

					break;
				}
		}

		sqlite3ReleaseTempReg(pParse, (int)(regFree1));
		sqlite3ReleaseTempReg(pParse, (int)(regFree2));
	}
	public static void sqlite3ExprIfFalseDup(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
	{
		sqlite3 db = pParse.db;
		Expr pCopy = sqlite3ExprDup(db, pExpr, (int)(0));
		if ((db.mallocFailed) == (0))
		{
			sqlite3ExprIfFalse(pParse, pCopy, (int)(dest), (int)(jumpIfNull));
		}

		sqlite3ExprDelete(db, pCopy);
	}
	public static void sqlite3ExprIfTrue(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
	{
		Vdbe v = pParse.pVdbe;
		int op = (int)(0);
		int regFree1 = (int)(0);
		int regFree2 = (int)(0);
		int r1 = 0; int r2 = 0;
		if (((v) == (null)))
			return;
		if (((pExpr) == (null)))
			return;
		op = (int)(pExpr.op);
		switch (op)
		{
			case 44:
			case 43:
				{
					Expr pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
					if (pAlt != pExpr)
					{
						sqlite3ExprIfTrue(pParse, pAlt, (int)(dest), (int)(jumpIfNull));
					}
					else if ((op) == (44))
					{
						int d2 = (int)(sqlite3VdbeMakeLabel(pParse));
						sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(d2), (int)(jumpIfNull ^ 0x10));
						sqlite3ExprIfTrue(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
						sqlite3VdbeResolveLabel(v, (int)(d2));
					}
					else
					{
						sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
						sqlite3ExprIfTrue(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
					}

					break;
				}

			case 19:
				{
					sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
					break;
				}

			case 175:
				{
					int isNot = 0;
					int isTrue = 0;
					isNot = (int)((pExpr.op2) == (171) ? 1 : 0);
					isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
					if (isTrue ^ isNot)
					{
						sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0x10 : 0));
					}
					else
					{
						sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0x10 : 0));
					}

					break;
				}

			case 45:
			case 171:
				;
				op = (int)(((op) == (45)) ? 53 : 52);
				jumpIfNull = (int)(0x80);
			case 56:
			case 55:
			case 54:
			case 57:
			case 52:
			case 53:
				{
					if ((sqlite3ExprIsVector(pExpr.pLeft)) != 0)
						goto default_expr;
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
					codeCompare(pParse, pExpr.pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(dest), (int)(jumpIfNull), (int)(((pExpr).flags & (0x000200)) != 0));
					break;
				}

			case 50:
			case 51:
				{
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
					sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(dest));
					break;
				}

			case 48:
				{
					exprCodeBetween(pParse, pExpr, (int)(dest), sqlite3ExprIfTrue, (int)(jumpIfNull));
					break;
				}

			case 49:
				{
					int destIfFalse = (int)(sqlite3VdbeMakeLabel(pParse));
					int destIfNull = (int)((jumpIfNull) != 0 ? dest : destIfFalse);
					sqlite3ExprCodeIN(pParse, pExpr, (int)(destIfFalse), (int)(destIfNull));
					sqlite3VdbeGoto(v, (int)(dest));
					sqlite3VdbeResolveLabel(v, (int)(destIfFalse));
					break;
				}

			default:
				{
				default_expr:
					;
					if ((((pExpr).flags & (0x000001 | 0x10000000)) == (0x10000000)))
					{
						sqlite3VdbeGoto(v, (int)(dest));
					}
					else if ((((pExpr).flags & (0x000001 | 0x20000000)) == (0x20000000)))
					{
					}
					else
					{
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr, &regFree1));
						sqlite3VdbeAddOp3(v, (int)(18), (int)(r1), (int)(dest), (int)(jumpIfNull != 0));
					}

					break;
				}
		}

		sqlite3ReleaseTempReg(pParse, (int)(regFree1));
		sqlite3ReleaseTempReg(pParse, (int)(regFree2));
	}
	public static int sqlite3ExprImpliesExpr(Parse pParse, Expr pE1, Expr pE2, int iTab)
	{
		if ((sqlite3ExprCompare(pParse, pE1, pE2, (int)(iTab))) == (0))
		{
			return (int)(1);
		}

		if (((pE2.op) == (43)) && (((sqlite3ExprImpliesExpr(pParse, pE1, pE2.pLeft, (int)(iTab))) != 0) || ((sqlite3ExprImpliesExpr(pParse, pE1, pE2.pRight, (int)(iTab))) != 0)))
		{
			return (int)(1);
		}

		if (((pE2.op) == (51)) && ((exprImpliesNotNull(pParse, pE1, pE2.pLeft, (int)(iTab), (int)(0))) != 0))
		{
			return (int)(1);
		}

		return (int)(0);
	}
	public static int sqlite3ExprIsConstantOrGroupBy(Parse pParse, Expr p, ExprList pGroupBy)
	{
		Walker w = new Walker();
		w.eCode = (ushort)(1);
		w.xExprCallback = exprNodeIsConstantOrGroupBy;
		w.xSelectCallback = null;
		w.u.pGroupBy = pGroupBy;
		w.pParse = pParse;
		sqlite3WalkExpr(w, p);
		return (int)(w.eCode);
	}
	public static ExprList sqlite3ExprListAppend(Parse pParse, ExprList pList, Expr pExpr)
	{
		ExprList_item* pItem;
		if ((pList) == (null))
		{
			return sqlite3ExprListAppendNew(pParse.db, pExpr);
		}

		if ((pList.nAlloc) < (pList.nExpr + 1))
		{
			return sqlite3ExprListAppendGrow(pParse.db, pList, pExpr);
		}

		pItem = &pList.a[pList.nExpr++];
		*pItem = (ExprList_item)(zeroItem);
		pItem->pExpr = pExpr;
		return pList;
	}
	public static ExprList sqlite3ExprListAppendVector(Parse pParse, ExprList pList, IdList* pColumns, Expr pExpr)
	{
		sqlite3 db = pParse.db;
		int n = 0;
		int i = 0;
		int iFirst = (int)(pList ? pList.nExpr : 0);
		if (((pColumns) == (null)))
			goto vector_append_error;
		if ((pExpr) == (null))
			goto vector_append_error;
		if ((pExpr.op != 138) && (pColumns->nId != (n = (int)(sqlite3ExprVectorSize(pExpr)))))
		{
			sqlite3ErrorMsg(pParse, "%d columns assigned %d values", (int)(pColumns->nId), (int)(n));
			goto vector_append_error;
		}

		for (i = (int)(0); (i) < (pColumns->nId); i++)
		{
			Expr pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, (int)(i), (int)(pColumns->nId));
			if ((pSubExpr) == (null))
				continue;
			pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
			if ((pList) != null)
			{
				pList.a[pList.nExpr - 1].zEName = pColumns->a[i].zName;
				pColumns->a[i].zName = null;
			}
		}

		if (((db.mallocFailed == 0) && ((pExpr.op) == (138))) && (pList != null))
		{
			Expr pFirst = pList.a[iFirst].pExpr;
			pFirst.pRight = pExpr;
			pExpr = null;
			pFirst.iTable = (int)(pColumns->nId);
		}

	vector_append_error:
		; sqlite3ExprUnmapAndDelete(pParse, pExpr);
		sqlite3IdListDelete(db, pColumns);
		return pList;
	}
	public static void sqlite3ExprListCheckLength(Parse pParse, ExprList pEList, sbyte* zObject)
	{
		int mx = (int)(pParse.db.aLimit[2]);
		if (((pEList) != null) && ((pEList.nExpr) > (mx)))
		{
			sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
		}
	}
	public static void sqlite3ExprListSetName(Parse pParse, ExprList pList, Token* pName, int dequote)
	{
		if ((pList) != null)
		{
			ExprList_item* pItem;
			pItem = &pList.a[pList.nExpr - 1];
			pItem->zEName = sqlite3DbStrNDup(pParse.db, pName->z, (ulong)(pName->n));
			if ((dequote) != 0)
			{
				sqlite3Dequote(pItem->zEName);
				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenMap(pParse, (void*)(pItem->zEName), pName);
				}
			}
		}
	}
	public static void sqlite3ExprListSetSpan(Parse pParse, ExprList pList, sbyte* zStart, sbyte* zEnd)
	{
		sqlite3 db = pParse.db;
		if ((pList) != null)
		{
			ExprList_item* pItem = &pList.a[pList.nExpr - 1];
			if ((pItem->zEName) == (null))
			{
				pItem->zEName = sqlite3DbSpanDup(db, zStart, zEnd);
				pItem->eEName = (uint)(1);
			}
		}
	}
	public static Select sqlite3ExprListToValues(Parse pParse, int nElem, ExprList pEList)
	{
		int ii = 0;
		Select pRet = null;
		for (ii = (int)(0); (ii) < (pEList.nExpr); ii++)
		{
			Select pSel;
			Expr pExpr = pEList.a[ii].pExpr;
			int nExprElem = 0;
			if ((pExpr.op) == (177))
			{
				nExprElem = (int)(pExpr.x.pList.nExpr);
			}
			else
			{
				nExprElem = (int)(1);
			}

			if (nExprElem != nElem)
			{
				sqlite3ErrorMsg(pParse, "IN(...) element has %d term%s - expected %d", (int)(nExprElem), (nExprElem) > (1) ? "s" : "", (int)(nElem));
				break;
			}

			pSel = sqlite3SelectNew(pParse, pExpr.x.pList, null, null, null, null, null, (uint)(0x0000200), null);
			pExpr.x.pList = null;
			if ((pSel) != null)
			{
				if ((pRet) != null)
				{
					pSel.op = (byte)(135);
					pSel.pPrior = pRet;
				}

				pRet = pSel;
			}
		}

		if (((pRet) != null) && ((pRet.pPrior) != null))
		{
			pRet.selFlags |= (uint)(0x0000400);
		}

		sqlite3ExprListDelete(pParse.db, pEList);
		return pRet;
	}
	public static CollSeq sqlite3ExprNNCollSeq(Parse pParse, Expr pExpr)
	{
		CollSeq p = sqlite3ExprCollSeq(pParse, pExpr);
		if ((p) == (null))
			p = pParse.db.pDfltColl;
		return p;
	}
	public static void sqlite3ExprSetHeightAndFlags(Parse pParse, Expr p)
	{
		if ((pParse.nErr) != 0)
			return;
		exprSetHeight(p);
		sqlite3ExprCheckHeight(pParse, (int)(p.nHeight));
	}
	public static void sqlite3ExprUnmapAndDelete(Parse pParse, Expr p)
	{
		if ((p) != null)
		{
			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameExprUnmap(pParse, p);
			}

			sqlite3ExprDeleteNN(pParse.db, p);
		}
	}
	public static int sqlite3FindInIndex(Parse pParse, Expr pX, uint inFlags, int* prRhsHasNull, int* aiMap, int* piTab)
	{
		Select p;
		int eType = (int)(0);
		int iTab = (int)(pParse.nTab++);
		int mustBeUnique = 0;
		Vdbe v = sqlite3GetVdbe(pParse);
		mustBeUnique = (int)((inFlags & 0x0004) != 0);
		if (((prRhsHasNull) != null) && (((pX).flags & 0x000800) != 0))
		{
			int i = 0;
			ExprList pEList = pX.x.pSelect.pEList;
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				if ((sqlite3ExprCanBeNull(pEList.a[i].pExpr)) != 0)
					break;
			}

			if ((i) == (pEList.nExpr))
			{
				prRhsHasNull = null;
			}
		}

		if (((pParse.nErr) == (0)) && ((p = isCandidateForInOpt(pX)) != null))
		{
			sqlite3 db = pParse.db;
			Table pTab;
			int iDb = 0;
			ExprList pEList = p.pEList;
			int nExpr = (int)(pEList.nExpr);
			pTab = p.pSrc.a[0].pTab;
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			sqlite3CodeVerifySchema(pParse, (int)(iDb));
			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
			if (((nExpr) == (1)) && ((pEList.a[0].pExpr.iColumn) < (0)))
			{
				int iAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				sqlite3OpenTable(pParse, (int)(iTab), (int)(iDb), pTab, (int)(101));
				eType = (int)(1);
				sqlite3VdbeExplain(pParse, (byte)(0), "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR", pTab.zName);
				sqlite3VdbeJumpHere(v, (int)(iAddr));
			}
			else
			{
				Index pIdx;
				int affinity_ok = (int)(1);
				int i = 0;
				for (i = (int)(0); ((i) < (nExpr)) && ((affinity_ok) != 0); i++)
				{
					Expr pLhs = sqlite3VectorFieldSubexpr(pX.pLeft, (int)(i));
					int iCol = (int)(pEList.a[i].pExpr.iColumn);
					sbyte idxaff = (sbyte)(sqlite3TableColumnAffinity(pTab, (int)(iCol)));
					sbyte cmpaff = (sbyte)(sqlite3CompareAffinity(pLhs, (sbyte)(idxaff)));
					switch (cmpaff)
					{
						case 0x41:
							break;
						case 0x42:
							;
							break;
						default:
							affinity_ok = (int)((idxaff) >= (0x43) ? 1 : 0);
					}
				}

				if ((affinity_ok) != 0)
				{
					for (pIdx = pTab.pIndex; ((pIdx) != null) && ((eType) == (0)); pIdx = pIdx.pNext)
					{
						ulong colUsed = 0;
						ulong mCol = 0;
						if ((pIdx.nColumn) < (nExpr))
							continue;
						if (pIdx.pPartIdxWhere != null)
							continue;
						if ((pIdx.nColumn) >= (((int)(sizeof(ulong) * 8)) - 1))
							continue;
						if ((mustBeUnique) != 0)
						{
							if (((pIdx.nKeyCol) > (nExpr)) || (((pIdx.nColumn) > (nExpr)) && (!((pIdx).onError != 0))))
							{
								continue;
							}
						}

						colUsed = (ulong)(0);
						for (i = (int)(0); (i) < (nExpr); i++)
						{
							Expr pLhs = sqlite3VectorFieldSubexpr(pX.pLeft, (int)(i));
							Expr pRhs = pEList.a[i].pExpr;
							CollSeq pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
							int j = 0;
							for (j = (int)(0); (j) < (nExpr); j++)
							{
								if (pIdx.aiColumn[j] != pRhs.iColumn)
									continue;
								if ((pReq != null) && (sqlite3StrICmp(pReq.zName, pIdx.azColl[j]) != 0))
								{
									continue;
								}

								break;
							}

							if ((j) == (nExpr))
								break;
							mCol = (ulong)(((ulong)(1)) << (j));
							if ((mCol & colUsed) != 0)
								break;
							colUsed |= (ulong)(mCol);
							if ((aiMap) != null)
								aiMap[i] = (int)(j);
						}

						if ((colUsed) == ((((ulong)(1)) << (nExpr)) - 1))
						{
							int iAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
							sqlite3VdbeExplain(pParse, (byte)(0), "USING INDEX %s FOR IN-OPERATOR", pIdx.zName);
							sqlite3VdbeAddOp3(v, (int)(101), (int)(iTab), (int)(pIdx.tnum), (int)(iDb));
							sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
							eType = (int)(3 + pIdx.aSortOrder[0]);
							if ((prRhsHasNull) != null)
							{
								*prRhsHasNull = (int)(++pParse.nMem);
								if ((nExpr) == (1))
								{
									sqlite3SetHasNullFlag(v, (int)(iTab), (int)(*prRhsHasNull));
								}
							}

							sqlite3VdbeJumpHere(v, (int)(iAddr));
						}
					}
				}
			}
		}

		if (((((eType) == (0)) && ((inFlags & 0x0001) != 0)) && (((pX).flags & 0x000800) == (0))) && ((sqlite3InRhsIsConstant(pX) == 0) || ((pX.x.pList.nExpr) <= (2))))
		{
			eType = (int)(5);
		}

		if ((eType) == (0))
		{
			uint savedNQueryLoop = (uint)(pParse.nQueryLoop);
			int rMayHaveNull = (int)(0);
			eType = (int)(2);
			if ((inFlags & 0x0004) != 0)
			{
				pParse.nQueryLoop = (uint)(0);
			}
			else if ((prRhsHasNull) != null)
			{
				*prRhsHasNull = (int)(rMayHaveNull = (int)(++pParse.nMem));
			}

			sqlite3CodeRhsOfIN(pParse, pX, (int)(iTab));
			if ((rMayHaveNull) != 0)
			{
				sqlite3SetHasNullFlag(v, (int)(iTab), (int)(rMayHaveNull));
			}

			pParse.nQueryLoop = (uint)(savedNQueryLoop);
		}

		if ((((aiMap) != null) && (eType != 3)) && (eType != 4))
		{
			int i = 0;
			int n = 0;
			n = (int)(sqlite3ExprVectorSize(pX.pLeft));
			for (i = (int)(0); (i) < (n); i++)
			{
				aiMap[i] = (int)(i);
			}
		}

		*piTab = (int)(iTab);
		return (int)(eType);
	}
	public static void sqlite3FinishCoding(Parse pParse)
	{
		sqlite3 db;
		Vdbe v;
		db = pParse.db;
		if ((pParse.nested) != 0)
			return;
		if ((pParse.nErr) != 0)
		{
			if ((db.mallocFailed) != 0)
				pParse.rc = (int)(7);
			return;
		}

		v = pParse.pVdbe;
		if ((v) == (null))
		{
			if ((db.init.busy) != 0)
			{
				pParse.rc = (int)(101);
				return;
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
				pParse.rc = (int)(1);
		}

		if ((v) != null)
		{
			if ((pParse.bReturning) != 0)
			{
				Returning pReturning = pParse.u1.pReturning;
				int addrRewind = 0;
				int i = 0;
				int reg = 0;
				if (((pReturning.nRetCol) == (0)))
				{
				}
				else
				{
					sqlite3VdbeAddOp0(v, (int)(82));
					addrRewind = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(pReturning.iRetCur)));
					reg = (int)(pReturning.iRetReg);
					for (i = (int)(0); (i) < (pReturning.nRetCol); i++)
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(pReturning.iRetCur), (int)(i), (int)(reg + i));
					}

					sqlite3VdbeAddOp2(v, (int)(83), (int)(reg), (int)(i));
					sqlite3VdbeAddOp2(v, (int)(5), (int)(pReturning.iRetCur), (int)(addrRewind + 1));
					sqlite3VdbeJumpHere(v, (int)(addrRewind));
				}
			}

			sqlite3VdbeAddOp0(v, (int)(70));
			if (((db.mallocFailed) == (0)) && (((pParse.cookieMask) != 0) || ((pParse.pConstExpr) != null)))
			{
				int iDb = 0;
				int i = 0;
				sqlite3VdbeJumpHere(v, (int)(0));
				for (iDb = (int)(0); (iDb) < (db.nDb); iDb++)
				{
					Schema pSchema;
					if ((((pParse.cookieMask) & (((uint)(1)) << (iDb))) != 0) == (0))
						continue;
					sqlite3VdbeUsesBtree(v, (int)(iDb));
					pSchema = db.aDb[iDb].pSchema;
					sqlite3VdbeAddOp4Int(v, (int)(2), (int)(iDb), (int)(((pParse.writeMask) & (((uint)(1)) << (iDb))) != 0), (int)(pSchema.schema_cookie), (int)(pSchema.iGeneration));
					if ((db.init.busy) == (0))
						sqlite3VdbeChangeP5(v, (ushort)(1));
				}

				for (i = (int)(0); (i) < (pParse.nVtabLock); i++)
				{
					sbyte* vtab = (sbyte*)(sqlite3GetVTable(db, pParse.apVtabLock[i]));
					sqlite3VdbeAddOp4(v, (int)(169), (int)(0), (int)(0), (int)(0), vtab, (int)(-12));
				}

				pParse.nVtabLock = (int)(0);
				codeTableLocks(pParse);
				sqlite3AutoincrementBegin(pParse);
				if ((pParse.pConstExpr) != null)
				{
					ExprList pEL = pParse.pConstExpr;
					pParse.okConstFactor = (byte)(0);
					for (i = (int)(0); (i) < (pEL.nExpr); i++)
					{
						int iReg = (int)(pEL.a[i].u.iConstExprReg);
						if ((iReg) > (0))
						{
							sqlite3ExprCode(pParse, pEL.a[i].pExpr, (int)(iReg));
						}
					}
				}

				if ((pParse.bReturning) != 0)
				{
					Returning pRet = pParse.u1.pReturning;
					if (((pRet.nRetCol) == (0)))
					{
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(116), (int)(pRet.iRetCur), (int)(pRet.nRetCol));
					}
				}

				sqlite3VdbeGoto(v, (int)(1));
			}
		}

		if ((pParse.nErr) == (0))
		{
			sqlite3VdbeMakeReady(v, pParse);
			pParse.rc = (int)(101);
		}
		else
		{
			pParse.rc = (int)(1);
		}
	}
	public static void sqlite3FinishTrigger(Parse pParse, TriggerStep pStepList, Token* pAll)
	{
		Trigger pTrig = pParse.pNewTrigger;
		sbyte* zName;
		sqlite3 db = pParse.db;
		DbFixer sFix = new DbFixer();
		int iDb = 0;
		Token nameToken = new Token();
		pParse.pNewTrigger = null;
		if (((pParse.nErr) != 0) || (pTrig == null))
			goto triggerfinish_cleanup;
		zName = pTrig.zName;
		iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTrig.pSchema));
		pTrig.step_list = pStepList;
		while ((pStepList) != null)
		{
			pStepList.pTrig = pTrig;
			pStepList = pStepList.pNext;
		}

		sqlite3TokenInit(&nameToken, pTrig.zName);
		sqlite3FixInit(sFix, pParse, (int)(iDb), "trigger", &nameToken);
		if (((sqlite3FixTriggerStep(sFix, pTrig.step_list)) != 0) || ((sqlite3FixExpr(sFix, pTrig.pWhen)) != 0))
		{
			goto triggerfinish_cleanup;
		}

		if (((pParse.eParseMode) >= (2)))
		{
			pParse.pNewTrigger = pTrig;
			pTrig = null;
		}
		else if (db.init.busy == 0)
		{
			Vdbe v;
			sbyte* z;
			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
				goto triggerfinish_cleanup;
			sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
			z = sqlite3DbStrNDup(db, pAll->z, (ulong)(pAll->n));
			sqlite3NestedParse(pParse, "INSERT INTO %Q.sqlite_master VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')", db.aDb[iDb].zDbSName, zName, pTrig.table, z);
			sqlite3DbFree(db, z);
			sqlite3ChangeCookie(pParse, (int)(iDb));
			sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName), (ushort)(0));
		}

		if ((db.init.busy) != 0)
		{
			Trigger pLink = pTrig;
			Hash* pHash = &db.aDb[iDb].pSchema.trigHash;
			pTrig = sqlite3HashInsert(pHash, zName, pTrig);
			if ((pTrig) != null)
			{
				sqlite3OomFault(db);
			}
			else if ((pLink.pSchema) == (pLink.pTabSchema))
			{
				Table pTab;
				pTab = sqlite3HashFind(&pLink.pTabSchema.tblHash, pLink.table);
				pLink.pNext = pTab.pTrigger;
				pTab.pTrigger = pLink;
			}
		}

	triggerfinish_cleanup:
		; sqlite3DeleteTrigger(db, pTrig);
		sqlite3DeleteTriggerStep(db, pStepList);
	}
	public static void sqlite3FkActions(Parse pParse, Table pTab, ExprList pChanges, int regOld, int* aChange, int bChngRowid)
	{
		if ((pParse.db.flags & 0x00004000) != 0)
		{
			FKey pFKey;
			for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey.pNextTo)
			{
				if (((aChange) == (null)) || ((fkParentIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) != 0))
				{
					Trigger pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
					if ((pAct) != null)
					{
						sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, (int)(regOld), (int)(2), (int)(0));
					}
				}
			}
		}
	}
	public static void sqlite3FkCheck(Parse pParse, Table pTab, int regOld, int regNew, int* aChange, int bChngRowid)
	{
		sqlite3 db = pParse.db;
		FKey pFKey;
		int iDb = 0;
		sbyte* zDb;
		int isIgnoreErrors = (int)(pParse.disableTriggers);
		if ((db.flags & 0x00004000) == (0))
			return;
		if (!(((pTab).eTabType) == (0)))
			return;
		iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		zDb = db.aDb[iDb].zDbSName;
		for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
		{
			Table pTo;
			Index pIdx = null;
			int* aiFree = null;
			int* aiCol;
			int iCol = 0;
			int i = 0;
			int bIgnore = (int)(0);
			if ((((aChange) != null) && (sqlite3_stricmp(pTab.zName, pFKey.zTo) != 0)) && ((fkChildIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) == (0)))
			{
				continue;
			}

			if ((pParse.disableTriggers) != 0)
			{
				pTo = sqlite3FindTable(db, pFKey.zTo, zDb);
			}
			else
			{
				pTo = sqlite3LocateTable(pParse, (uint)(0), pFKey.zTo, zDb);
			}

			if ((pTo == null) || ((sqlite3FkLocateIndex(pParse, pTo, pFKey, pIdx, &aiFree)) != 0))
			{
				if ((isIgnoreErrors == 0) || ((db.mallocFailed) != 0))
					return;
				if ((pTo) == (null))
				{
					Vdbe v = sqlite3GetVdbe(pParse);
					int iJump = (int)(sqlite3VdbeCurrentAddr(v) + pFKey.nCol + 1);
					for (i = (int)(0); (i) < (pFKey.nCol); i++)
					{
						int iFromCol = 0;
						int iReg = 0;
						iFromCol = (int)(pFKey.aCol[i].iFrom);
						iReg = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(iFromCol)) + regOld + 1);
						sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(iJump));
					}

					sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(-1));
				}

				continue;
			}

			if ((aiFree) != null)
			{
				aiCol = aiFree;
			}
			else
			{
				iCol = (int)(pFKey.aCol[0].iFrom);
				aiCol = &iCol;
			}

			for (i = (int)(0); (i) < (pFKey.nCol); i++)
			{
				if ((aiCol[i]) == (pTab.iPKey))
				{
					aiCol[i] = (int)(-1);
				}

				if ((db.xAuth) != null)
				{
					int rcauth = 0;
					sbyte* zCol = pTo.aCol[pIdx ? pIdx.aiColumn[i] : pTo.iPKey].zCnName;
					rcauth = (int)(sqlite3AuthReadCol(pParse, pTo.zName, zCol, (int)(iDb)));
					bIgnore = (int)((rcauth) == (2) ? 1 : 0);
				}
			}

			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTo.tnum), (byte)(0), pTo.zName);
			pParse.nTab++;
			if (regOld != 0)
			{
				fkLookupParent(pParse, (int)(iDb), pTo, pIdx, pFKey, aiCol, (int)(regOld), (int)(-1), (int)(bIgnore));
			}

			if ((regNew != 0) && (isSetNullAction(pParse, pFKey) == 0))
			{
				fkLookupParent(pParse, (int)(iDb), pTo, pIdx, pFKey, aiCol, (int)(regNew), (int)(+1), (int)(bIgnore));
			}

			sqlite3DbFree(db, aiFree);
		}

		for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey.pNextTo)
		{
			Index pIdx = null;
			SrcList pSrc;
			int* aiCol = null;
			if (((aChange) != null) && ((fkParentIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) == (0)))
			{
				continue;
			}

			if ((((pFKey.isDeferred == 0) && ((db.flags & 0x00080000) == 0)) && (pParse.pToplevel == null)) && (pParse.isMultiWrite == 0))
			{
				continue;
			}

			if ((sqlite3FkLocateIndex(pParse, pTab, pFKey, pIdx, &aiCol)) != 0)
			{
				if ((isIgnoreErrors == 0) || ((db.mallocFailed) != 0))
					return;
				continue;
			}

			pSrc = sqlite3SrcListAppend(pParse, null, null, null);
			if ((pSrc) != null)
			{
				SrcItem pItem = pSrc.a;
				pItem.pTab = pFKey.pFrom;
				pItem.zName = pFKey.pFrom.zName;
				pItem.pTab.nTabRef++;
				pItem.iCursor = (int)(pParse.nTab++);
				if (regNew != 0)
				{
					fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, (int)(regNew), (int)(-1));
				}

				if (regOld != 0)
				{
					int eAction = (int)(pFKey.aAction[aChange != null]);
					fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, (int)(regOld), (int)(1));
					if (((pFKey.isDeferred == 0) && (eAction != 10)) && (eAction != 8))
					{
						sqlite3MayAbort(pParse);
					}
				}

				pItem.zName = null;
				sqlite3SrcListDelete(db, pSrc);
			}

			sqlite3DbFree(db, aiCol);
		}
	}
	public static void sqlite3FkDropTable(Parse pParse, SrcList pName, Table pTab)
	{
		sqlite3 db = pParse.db;
		if (((db.flags & 0x00004000) != 0) && (((pTab).eTabType) == (0)))
		{
			int iSkip = (int)(0);
			Vdbe v = sqlite3GetVdbe(pParse);
			if ((sqlite3FkReferences(pTab)) == (null))
			{
				FKey p;
				for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
				{
					if (((p.isDeferred) != 0) || ((db.flags & 0x00080000) != 0))
						break;
				}

				if (p == null)
					return;
				iSkip = (int)(sqlite3VdbeMakeLabel(pParse));
				sqlite3VdbeAddOp2(v, (int)(48), (int)(1), (int)(iSkip));
			}

			pParse.disableTriggers = (byte)(1);
			sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, (int)(0)), null, null, null);
			pParse.disableTriggers = (byte)(0);
			if ((db.flags & 0x00080000) == (0))
			{
				sqlite3VdbeAddOp2(v, (int)(48), (int)(0), (int)(sqlite3VdbeCurrentAddr(v) + 2));
				sqlite3HaltConstraint(pParse, (int)(19 | (3 << 8)), (int)(2), null, (sbyte)(-1), (byte)(4));
			}

			if ((iSkip) != 0)
			{
				sqlite3VdbeResolveLabel(v, (int)(iSkip));
			}
		}
	}
	public static int sqlite3FkLocateIndex(Parse pParse, Table pParent, FKey pFKey, Index ppIdx, int** paiCol)
	{
		Index pIdx = null;
		int* aiCol = null;
		int nCol = (int)(pFKey.nCol);
		sbyte* zKey = pFKey.aCol[0].zCol;
		if ((nCol) == (1))
		{
			if ((pParent.iPKey) >= (0))
			{
				if (zKey == null)
					return (int)(0);
				if (sqlite3StrICmp(pParent.aCol[pParent.iPKey].zCnName, zKey) == 0)
				{
					return (int)(0);
				}
			}
		}
		else if ((paiCol) != null)
		{
			aiCol = (int*)(sqlite3DbMallocRawNN(pParse.db, (ulong)(nCol * sizeof(int))));
			if (aiCol == null)
				return (int)(1);
			*paiCol = aiCol;
		}

		for (pIdx = pParent.pIndex; pIdx; pIdx = pIdx.pNext)
		{
			if ((((pIdx.nKeyCol) == (nCol)) && ((pIdx).onError != 0)) && ((pIdx.pPartIdxWhere) == (null)))
			{
				if ((zKey) == (null))
				{
					if ((((pIdx).idxType) == (2)))
					{
						if ((aiCol) != null)
						{
							int i = 0;
							for (i = (int)(0); (i) < (nCol); i++)
							{
								aiCol[i] = (int)(pFKey.aCol[i].iFrom);
							}
						}

						break;
					}
				}
				else
				{
					int i = 0;
					int j = 0;
					for (i = (int)(0); (i) < (nCol); i++)
					{
						short iCol = (short)(pIdx.aiColumn[i]);
						sbyte* zDfltColl;
						sbyte* zIdxCol;
						if ((iCol) < (0))
							break;
						zDfltColl = sqlite3ColumnColl(&pParent.aCol[iCol]);
						if (zDfltColl == null)
							zDfltColl = sqlite3StrBINARY;
						if ((sqlite3StrICmp(pIdx.azColl[i], zDfltColl)) != 0)
							break;
						zIdxCol = pParent.aCol[iCol].zCnName;
						for (j = (int)(0); (j) < (nCol); j++)
						{
							if ((sqlite3StrICmp(pFKey.aCol[j].zCol, zIdxCol)) == (0))
							{
								if ((aiCol) != null)
									aiCol[i] = (int)(pFKey.aCol[j].iFrom);
								break;
							}
						}

						if ((j) == (nCol))
							break;
					}

					if ((i) == (nCol))
						break;
				}
			}
		}

		if (pIdx == null)
		{
			if (pParse.disableTriggers == 0)
			{
				sqlite3ErrorMsg(pParse, "foreign key mismatch - \"%w\" referencing \"%w\"", pFKey.pFrom.zName, pFKey.zTo);
			}

			sqlite3DbFree(pParse.db, aiCol);
			return (int)(1);
		}

		ppIdx = pIdx;
		return (int)(0);
	}
	public static uint sqlite3FkOldmask(Parse pParse, Table pTab)
	{
		uint mask = (uint)(0);
		if (((pParse.db.flags & 0x00004000) != 0) && (((pTab).eTabType) == (0)))
		{
			FKey p;
			int i = 0;
			for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
			{
				for (i = (int)(0); (i) < (p.nCol); i++)
				{
					mask |= (uint)(((p.aCol[i].iFrom) > (31)) ? 0xffffffff : ((uint)(1) << (p.aCol[i].iFrom)));
				}
			}

			for (p = sqlite3FkReferences(pTab); p; p = p.pNextTo)
			{
				Index pIdx = null;
				sqlite3FkLocateIndex(pParse, pTab, p, pIdx, null);
				if ((pIdx) != null)
				{
					for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
					{
						mask |= (uint)(((pIdx.aiColumn[i]) > (31)) ? 0xffffffff : ((uint)(1) << (pIdx.aiColumn[i])));
					}
				}
			}
		}

		return (uint)(mask);
	}
	public static int sqlite3FkRequired(Parse pParse, Table pTab, int* aChange, int chngRowid)
	{
		int eRet = (int)(1);
		int bHaveFK = (int)(0);
		if (((pParse.db.flags & 0x00004000) != 0) && (((pTab).eTabType) == (0)))
		{
			if (aChange == null)
			{
				bHaveFK = (int)(((sqlite3FkReferences(pTab)) != null) || ((pTab.u.tab.pFKey) != null) ? 1 : 0);
			}
			else
			{
				FKey p;
				for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
				{
					if ((fkChildIsModified(pTab, p, aChange, (int)(chngRowid))) != 0)
					{
						if ((0) == (sqlite3_stricmp(pTab.zName, p.zTo)))
							eRet = (int)(2);
						bHaveFK = (int)(1);
					}
				}

				for (p = sqlite3FkReferences(pTab); p; p = p.pNextTo)
				{
					if ((fkParentIsModified(pTab, p, aChange, (int)(chngRowid))) != 0)
					{
						if (p.aAction[1] != 0)
							return (int)(2);
						bHaveFK = (int)(1);
					}
				}
			}
		}

		return (int)((bHaveFK) != 0 ? eRet : 0);
	}
	public static void sqlite3ForceNotReadOnly(Parse pParse)
	{
		int iReg = (int)(++pParse.nMem);
		Vdbe v = sqlite3GetVdbe(pParse);
		if ((v) != null)
		{
			sqlite3VdbeAddOp3(v, (int)(7), (int)(0), (int)(iReg), (int)(-1));
			sqlite3VdbeUsesBtree(v, (int)(0));
		}
	}
	public static void sqlite3GenerateColumnNames(Parse pParse, Select pSelect)
	{
		Vdbe v = pParse.pVdbe;
		int i = 0;
		Table pTab;
		SrcList pTabList;
		ExprList pEList;
		sqlite3 db = pParse.db;
		int fullName = 0;
		int srcName = 0;
		if ((pParse.explain) != 0)
		{
			return;
		}

		if ((pParse.colNamesSet) != 0)
			return;
		while ((pSelect.pPrior) != null)
		{
			pSelect = pSelect.pPrior;
		}

		pTabList = pSelect.pSrc;
		pEList = pSelect.pEList;
		pParse.colNamesSet = (byte)(1);
		fullName = (int)((db.flags & 0x00000004) != 0);
		srcName = (int)(((db.flags & 0x00000040) != 0) || ((fullName) != 0) ? 1 : 0);
		sqlite3VdbeSetNumCols(v, (int)(pEList.nExpr));
		for (i = (int)(0); (i) < (pEList.nExpr); i++)
		{
			Expr p = pEList.a[i].pExpr;
			if (((pEList.a[i].zEName) != null) && ((pEList.a[i].eEName) == (0)))
			{
				sbyte* zName = pEList.a[i].zEName;
				sqlite3VdbeSetColName(v, (int)(i), (int)(0), zName, ((Void(Void * ))(-1)));
			}
			else if (((srcName) != 0) && ((p.op) == (167)))
			{
				sbyte* zCol;
				int iCol = (int)(p.iColumn);
				pTab = p.y.pTab;
				if ((iCol) < (0))
					iCol = (int)(pTab.iPKey);
				if ((iCol) < (0))
				{
					zCol = "rowid";
				}
				else
				{
					zCol = pTab.aCol[iCol].zCnName;
				}

				if ((fullName) != 0)
				{
					sbyte* zName = null;
					zName = sqlite3MPrintf(db, "%s.%s", pTab.zName, zCol);
					sqlite3VdbeSetColName(v, (int)(i), (int)(0), zName, ((Void(Void * ))(sqlite3OomFault)));
				}
				else
				{
					sqlite3VdbeSetColName(v, (int)(i), (int)(0), zCol, ((Void(Void * ))(-1)));
				}
			}
			else
			{
				sbyte* z = pEList.a[i].zEName;
				z = (z) == (null) ? sqlite3MPrintf(db, "column%d", (int)(i + 1)) : sqlite3DbStrDup(db, z);
				sqlite3VdbeSetColName(v, (int)(i), (int)(0), z, ((Void(Void * ))(sqlite3OomFault)));
			}
		}

		generateColumnTypes(pParse, pTabList, pEList);
	}
	public static void sqlite3GenerateConstraintChecks(Parse pParse, Table pTab, int* aRegIdx, int iDataCur, int iIdxCur, int regNewData, int regOldData, byte pkChng, byte overrideError, int ignoreDest, int* pbMayReplace, int* aiChng, Upsert pUpsert)
	{
		Vdbe v;
		Index pIdx;
		Index pPk = null;
		sqlite3 db;
		int i = 0;
		int ix = 0;
		int nCol = 0;
		int onError = 0;
		int seenReplace = (int)(0);
		int nPkField = 0;
		Upsert pUpsertClause = null;
		byte isUpdate = 0;
		byte bAffinityDone = (byte)(0);
		int upsertIpkReturn = (int)(0);
		int upsertIpkDelay = (int)(0);
		int ipkTop = (int)(0);
		int ipkBottom = (int)(0);
		int regTrigCnt = 0;
		int addrRecheck = (int)(0);
		int lblRecheckOk = (int)(0);
		Trigger pTrigger;
		int nReplaceTrig = (int)(0);
		IndexIterator sIdxIter = new IndexIterator();
		isUpdate = (byte)(regOldData != 0);
		db = pParse.db;
		v = pParse.pVdbe;
		nCol = (int)(pTab.nCol);
		if ((((pTab).tabFlags & 0x00000080) == (0)))
		{
			pPk = null;
			nPkField = (int)(1);
		}
		else
		{
			pPk = sqlite3PrimaryKeyIndex(pTab);
			nPkField = (int)(pPk.nKeyCol);
		}

		if ((pTab.tabFlags & 0x00000800) != 0)
		{
			int b2ndPass = (int)(0);
			int nSeenReplace = (int)(0);
			int nGenerated = (int)(0);
			while ((1) != 0)
			{
				for (i = (int)(0); (i) < (nCol); i++)
				{
					int iReg = 0;
					Column* pCol = &pTab.aCol[i];
					int isGenerated = 0;
					onError = (int)(pCol->notNull);
					if ((onError) == (0))
						continue;
					if ((i) == (pTab.iPKey))
					{
						continue;
					}

					isGenerated = (int)(pCol->colFlags & 0x0060);
					if (((isGenerated) != 0) && (b2ndPass == 0))
					{
						nGenerated++;
						continue;
					}

					if ((((aiChng) != null) && ((aiChng[i]) < (0))) && (isGenerated == 0))
					{
						continue;
					}

					if (overrideError != 11)
					{
						onError = (int)(overrideError);
					}
					else if ((onError) == (11))
					{
						onError = (int)(2);
					}

					if ((onError) == (5))
					{
						if (((b2ndPass) != 0) || ((pCol->iDflt) == (0)))
						{
							onError = (int)(2);
						}
						else
						{
						}
					}
					else if (((b2ndPass) != 0) && (isGenerated == 0))
					{
						continue;
					}

					iReg = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + regNewData + 1);
					switch (onError)
					{
						case 5:
							{
								int addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(iReg)));
								nSeenReplace++;
								sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), (int)(iReg));
								sqlite3VdbeJumpHere(v, (int)(addr1));
								break;
							}

						case 2:
							sqlite3MayAbort(pParse);
						case 1:
						case 3:
							{
								sbyte* zMsg = sqlite3MPrintf(db, "%s.%s", pTab.zName, pCol->zCnName);
								sqlite3VdbeAddOp3(v, (int)(69), (int)(19 | (5 << 8)), (int)(onError), (int)(iReg));
								sqlite3VdbeAppendP4(v, zMsg, (int)(-7));
								sqlite3VdbeChangeP5(v, (ushort)(1));
								break;
							}

						default:
							{
								sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(ignoreDest));
								break;
							}
					}
				}

				if (((nGenerated) == (0)) && ((nSeenReplace) == (0)))
				{
					break;
				}

				if ((b2ndPass) != 0)
					break;
				b2ndPass = (int)(1);
				if (((nSeenReplace) > (0)) && ((pTab.tabFlags & 0x00000060) != 0))
				{
					sqlite3ComputeGeneratedColumns(pParse, (int)(regNewData + 1), pTab);
				}
			}
		}

		if (((pTab.pCheck) != null) && ((db.flags & 0x00000200) == (0)))
		{
			ExprList pCheck = pTab.pCheck;
			pParse.iSelfTab = (int)(-(regNewData + 1));
			onError = (int)(overrideError != 11 ? overrideError : 2);
			for (i = (int)(0); (i) < (pCheck.nExpr); i++)
			{
				int allOk = 0;
				Expr pCopy;
				Expr pExpr = pCheck.a[i].pExpr;
				if (((aiChng) != null) && (sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, (int)(pkChng)) == 0))
				{
					continue;
				}

				if ((bAffinityDone) == (0))
				{
					sqlite3TableAffinity(v, pTab, (int)(regNewData + 1));
					bAffinityDone = (byte)(1);
				}

				allOk = (int)(sqlite3VdbeMakeLabel(pParse));
				pCopy = sqlite3ExprDup(db, pExpr, (int)(0));
				if (db.mallocFailed == 0)
				{
					sqlite3ExprIfTrue(pParse, pCopy, (int)(allOk), (int)(0x10));
				}

				sqlite3ExprDelete(db, pCopy);
				if ((onError) == (4))
				{
					sqlite3VdbeGoto(v, (int)(ignoreDest));
				}
				else
				{
					sbyte* zName = pCheck.a[i].zEName;
					if ((onError) == (5))
						onError = (int)(2);
					sqlite3HaltConstraint(pParse, (int)(19 | (1 << 8)), (int)(onError), zName, (sbyte)(0), (byte)(3));
				}

				sqlite3VdbeResolveLabel(v, (int)(allOk));
			}

			pParse.iSelfTab = (int)(0);
		}

		sIdxIter.eType = (int)(0);
		sIdxIter.i = (int)(0);
		sIdxIter.u.ax.aIdx = null;
		sIdxIter.u.lx.pIdx = pTab.pIndex;
		if ((pUpsert) != null)
		{
			if ((pUpsert.pUpsertTarget) == (null))
			{
				if ((pUpsert.isDoUpdate) == (0))
				{
					overrideError = (byte)(4);
					pUpsert = null;
				}
				else
				{
					overrideError = (byte)(6);
				}
			}
			else if (pTab.pIndex != null)
			{
				int nIdx = 0;
				int jj = 0;
				ulong nByte = 0;
				Upsert pTerm;
				byte* bUsed;
				for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
				{
				}

				sIdxIter.eType = (int)(1);
				sIdxIter.u.ax.nIdx = (int)(nIdx);
				nByte = (ulong)((sizeof(IndexListTerm) + 1) * nIdx + nIdx);
				sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, (ulong)(nByte));
				if ((sIdxIter.u.ax.aIdx) == (null))
					return;
				bUsed = (byte*)(sIdxIter.u.ax.aIdx[nIdx]);
				pUpsert.pToFree = sIdxIter.u.ax.aIdx;
				for (i = (int)(0), pTerm = pUpsert; pTerm; pTerm = pTerm.pNextUpsert)
				{
					if ((pTerm.pUpsertTarget) == (null))
						break;
					if ((pTerm.pUpsertIdx) == (null))
						continue;
					jj = (int)(0);
					pIdx = pTab.pIndex;
					while ((pIdx != null) && (pIdx != pTerm.pUpsertIdx))
					{
						pIdx = pIdx.pNext;
						jj++;
					}

					if ((bUsed[jj]) != 0)
						continue;
					bUsed[jj] = (byte)(1);
					sIdxIter.u.ax.aIdx[i].p = pIdx;
					sIdxIter.u.ax.aIdx[i].ix = (int)(jj);
					i++;
				}

				for (jj = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, jj++)
				{
					if ((bUsed[jj]) != 0)
						continue;
					sIdxIter.u.ax.aIdx[i].p = pIdx;
					sIdxIter.u.ax.aIdx[i].ix = (int)(jj);
					i++;
				}
			}
		}

		if ((db.flags & (0x00002000 | 0x00004000)) == (0))
		{
			pTrigger = null;
			regTrigCnt = (int)(0);
		}
		else
		{
			if ((db.flags & 0x00002000) != 0)
			{
				pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(128), null, null);
				regTrigCnt = (int)((pTrigger != null) || ((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) ? 1 : 0);
			}
			else
			{
				pTrigger = null;
				regTrigCnt = (int)(sqlite3FkRequired(pParse, pTab, null, (int)(0)));
			}

			if ((regTrigCnt) != 0)
			{
				regTrigCnt = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regTrigCnt));
				lblRecheckOk = (int)(sqlite3VdbeMakeLabel(pParse));
				addrRecheck = (int)(lblRecheckOk);
			}
		}

		if (((pkChng) != 0) && ((pPk) == (null)))
		{
			int addrRowidOk = (int)(sqlite3VdbeMakeLabel(pParse));
			onError = (int)(pTab.keyConf);
			if (overrideError != 11)
			{
				onError = (int)(overrideError);
			}
			else if ((onError) == (11))
			{
				onError = (int)(2);
			}

			if ((pUpsert) != null)
			{
				pUpsertClause = sqlite3UpsertOfIndex(pUpsert, null);
				if (pUpsertClause != null)
				{
					if ((pUpsertClause.isDoUpdate) == (0))
					{
						onError = (int)(4);
					}
					else
					{
						onError = (int)(6);
					}
				}

				if (pUpsertClause != pUpsert)
				{
					upsertIpkDelay = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
				}
			}

			if (((((onError) == (5)) && (onError != overrideError)) && ((pTab.pIndex) != null)) && (upsertIpkDelay == 0))
			{
				ipkTop = (int)(sqlite3VdbeAddOp0(v, (int)(11)) + 1);
			}

			if ((isUpdate) != 0)
			{
				sqlite3VdbeAddOp3(v, (int)(53), (int)(regNewData), (int)(addrRowidOk), (int)(regOldData));
				sqlite3VdbeChangeP5(v, (ushort)(0x90));
			}

			sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(addrRowidOk), (int)(regNewData));
			switch (onError)
			{
				default:
					{
						onError = (int)(2);
					}

				case 1:
				case 2:
				case 3:
					{
						sqlite3RowidConstraint(pParse, (int)(onError), pTab);
						break;
					}

				case 5:
					{
						if ((regTrigCnt) != 0)
						{
							sqlite3MultiWrite(pParse);
							sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(regNewData), (short)(1), (byte)(0), (byte)(5), (byte)(1), (int)(-1));
							sqlite3VdbeAddOp2(v, (int)(85), (int)(regTrigCnt), (int)(1));
							nReplaceTrig++;
						}
						else
						{
							if ((pTab.pIndex) != null)
							{
								sqlite3MultiWrite(pParse);
								sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), null, (int)(-1));
							}
						}

						seenReplace = (int)(1);
						break;
					}

				case 6:
					{
						sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, null, (int)(iDataCur));
					}

				case 4:
					{
						sqlite3VdbeGoto(v, (int)(ignoreDest));
						break;
					}
			}

			sqlite3VdbeResolveLabel(v, (int)(addrRowidOk));
			if (((pUpsert) != null) && (pUpsertClause != pUpsert))
			{
				upsertIpkReturn = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
			}
			else if ((ipkTop) != 0)
			{
				ipkBottom = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
				sqlite3VdbeJumpHere(v, (int)(ipkTop - 1));
			}
		}

		for (pIdx = indexIteratorFirst(&sIdxIter, &ix); pIdx; pIdx = indexIteratorNext(&sIdxIter, &ix))
		{
			int regIdx = 0;
			int regR = 0;
			int iThisCur = 0;
			int addrUniqueOk = 0;
			int addrConflictCk = 0;
			if ((aRegIdx[ix]) == (0))
				continue;
			if ((pUpsert) != null)
			{
				pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);
				if (((upsertIpkDelay) != 0) && ((pUpsertClause) == (pUpsert)))
				{
					sqlite3VdbeJumpHere(v, (int)(upsertIpkDelay));
				}
			}

			addrUniqueOk = (int)(sqlite3VdbeMakeLabel(pParse));
			if ((bAffinityDone) == (0))
			{
				sqlite3TableAffinity(v, pTab, (int)(regNewData + 1));
				bAffinityDone = (byte)(1);
			}

			iThisCur = (int)(iIdxCur + ix);
			if ((pIdx.pPartIdxWhere) != null)
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(aRegIdx[ix]));
				pParse.iSelfTab = (int)(-(regNewData + 1));
				sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, (int)(addrUniqueOk), (int)(0x10));
				pParse.iSelfTab = (int)(0);
			}

			regIdx = (int)(aRegIdx[ix] + 1);
			for (i = (int)(0); (i) < (pIdx.nColumn); i++)
			{
				int iField = (int)(pIdx.aiColumn[i]);
				int x = 0;
				if ((iField) == (-2))
				{
					pParse.iSelfTab = (int)(-(regNewData + 1));
					sqlite3ExprCodeCopy(pParse, pIdx.aColExpr.a[i].pExpr, (int)(regIdx + i));
					pParse.iSelfTab = (int)(0);
				}
				else if (((iField) == (-1)) || ((iField) == (pTab.iPKey)))
				{
					x = (int)(regNewData);
					sqlite3VdbeAddOp2(v, (int)(81), (int)(x), (int)(regIdx + i));
				}
				else
				{
					x = (int)(sqlite3TableColumnToStorage(pTab, (short)(iField)) + regNewData + 1);
					sqlite3VdbeAddOp2(v, (int)(80), (int)(x), (int)(regIdx + i));
				}
			}

			sqlite3VdbeAddOp3(v, (int)(96), (int)(regIdx), (int)(pIdx.nColumn), (int)(aRegIdx[ix]));
			if ((((isUpdate) != 0) && ((pPk) == (pIdx))) && ((pkChng) == (0)))
			{
				sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
				continue;
			}

			onError = (int)(pIdx.onError);
			if ((onError) == (0))
			{
				sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
				continue;
			}

			if (overrideError != 11)
			{
				onError = (int)(overrideError);
			}
			else if ((onError) == (11))
			{
				onError = (int)(2);
			}

			if ((pUpsertClause) != null)
			{
				if ((pUpsertClause.isDoUpdate) == (0))
				{
					onError = (int)(4);
				}
				else
				{
					onError = (int)(6);
				}
			}

			if (((((((ix) == (0)) && ((pIdx.pNext) == (null))) && ((pPk) == (pIdx))) && ((onError) == (5))) && (((0) == (db.flags & 0x00002000)) || ((null) == (sqlite3TriggersExist(pParse, pTab, (int)(128), null, null))))) && (((0) == (db.flags & 0x00004000)) || (((null) == (pTab.u.tab.pFKey)) && ((null) == (sqlite3FkReferences(pTab))))))
			{
				sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
				continue;
			}

			addrConflictCk = (int)(sqlite3VdbeAddOp4Int(v, (int)(29), (int)(iThisCur), (int)(addrUniqueOk), (int)(regIdx), (int)(pIdx.nKeyCol)));
			regR = (int)((pIdx) == (pPk) ? regIdx : sqlite3GetTempRange(pParse, (int)(nPkField)));
			if (((isUpdate) != 0) || ((onError) == (5)))
			{
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					sqlite3VdbeAddOp2(v, (int)(141), (int)(iThisCur), (int)(regR));
					if ((isUpdate) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(53), (int)(regR), (int)(addrUniqueOk), (int)(regOldData));
						sqlite3VdbeChangeP5(v, (ushort)(0x90));
					}
				}
				else
				{
					int x = 0;
					if (pIdx != pPk)
					{
						for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
						{
							x = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[i])));
							sqlite3VdbeAddOp3(v, (int)(93), (int)(iThisCur), (int)(x), (int)(regR + i));
						}
					}

					if ((isUpdate) != 0)
					{
						int addrJump = (int)(sqlite3VdbeCurrentAddr(v) + pPk.nKeyCol);
						int op = (int)(52);
						int regCmp = (int)((((pIdx).idxType) == (2)) ? regIdx : regR);
						for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
						{
							sbyte* p4 = (sbyte*)(sqlite3LocateCollSeq(pParse, pPk.azColl[i]));
							x = (int)(pPk.aiColumn[i]);
							if ((i) == (pPk.nKeyCol - 1))
							{
								addrJump = (int)(addrUniqueOk);
								op = (int)(53);
							}

							x = (int)(sqlite3TableColumnToStorage(pTab, (short)(x)));
							sqlite3VdbeAddOp4(v, (int)(op), (int)(regOldData + 1 + x), (int)(addrJump), (int)(regCmp + i), p4, (int)(-2));
							sqlite3VdbeChangeP5(v, (ushort)(0x90));
						}
					}
				}
			}

			switch (onError)
			{
				case 1:
				case 2:
				case 3:
					{
						sqlite3UniqueConstraint(pParse, (int)(onError), pIdx);
						break;
					}

				case 6:
					{
						sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, (int)(iIdxCur + ix));
					}

				case 4:
					{
						sqlite3VdbeGoto(v, (int)(ignoreDest));
						break;
					}

				default:
					{
						int nConflictCk = 0;
						nConflictCk = (int)(sqlite3VdbeCurrentAddr(v) - addrConflictCk);
						if ((regTrigCnt) != 0)
						{
							sqlite3MultiWrite(pParse);
							nReplaceTrig++;
						}

						if (((pTrigger) != null) && ((isUpdate) != 0))
						{
							sqlite3VdbeAddOp1(v, (int)(166), (int)(iDataCur));
						}

						sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(regR), (short)(nPkField), (byte)(0), (byte)(5), (byte)((pIdx) == (pPk) ? 1 : 0), (int)(iThisCur));
						if (((pTrigger) != null) && ((isUpdate) != 0))
						{
							sqlite3VdbeAddOp1(v, (int)(167), (int)(iDataCur));
						}

						if ((regTrigCnt) != 0)
						{
							int addrBypass = 0;
							sqlite3VdbeAddOp2(v, (int)(85), (int)(regTrigCnt), (int)(1));
							addrBypass = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
							sqlite3VdbeResolveLabel(v, (int)(lblRecheckOk));
							lblRecheckOk = (int)(sqlite3VdbeMakeLabel(pParse));
							if ((pIdx.pPartIdxWhere) != null)
							{
								sqlite3VdbeAddOp2(v, (int)(50), (int)(regIdx - 1), (int)(lblRecheckOk));
							}

							while ((nConflictCk) > (0))
							{
								VdbeOp x = new VdbeOp();
								x = (VdbeOp)(*sqlite3VdbeGetOp(v, (int)(addrConflictCk)));
								if (x.opcode != 141)
								{
									int p2 = 0;
									sbyte* zP4;
									if ((sqlite3OpcodeProperty[x.opcode] & 0x01) != 0)
									{
										p2 = (int)(lblRecheckOk);
									}
									else
									{
										p2 = (int)(x.p2);
									}

									zP4 = (x.p4type) == (-3) ? ((void*)((long)(x.p4.i))) : x.p4.z;
									sqlite3VdbeAddOp4(v, (int)(x.opcode), (int)(x.p1), (int)(p2), (int)(x.p3), zP4, (int)(x.p4type));
									sqlite3VdbeChangeP5(v, (ushort)(x.p5));
								}

								nConflictCk--;
								addrConflictCk++;
							}

							sqlite3UniqueConstraint(pParse, (int)(2), pIdx);
							sqlite3VdbeJumpHere(v, (int)(addrBypass));
						}

						seenReplace = (int)(1);
						break;
					}
			}

			sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
			if (regR != regIdx)
				sqlite3ReleaseTempRange(pParse, (int)(regR), (int)(nPkField));
			if ((((pUpsertClause) != null) && ((upsertIpkReturn) != 0)) && ((sqlite3UpsertNextIsIPK(pUpsertClause)) != 0))
			{
				sqlite3VdbeGoto(v, (int)(upsertIpkDelay + 1));
				sqlite3VdbeJumpHere(v, (int)(upsertIpkReturn));
				upsertIpkReturn = (int)(0);
			}
		}

		if ((ipkTop) != 0)
		{
			sqlite3VdbeGoto(v, (int)(ipkTop));
			sqlite3VdbeJumpHere(v, (int)(ipkBottom));
		}

		if ((nReplaceTrig) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(20), (int)(regTrigCnt), (int)(lblRecheckOk));
			if (pPk == null)
			{
				if ((isUpdate) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(53), (int)(regNewData), (int)(addrRecheck), (int)(regOldData));
					sqlite3VdbeChangeP5(v, (ushort)(0x90));
				}

				sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(addrRecheck), (int)(regNewData));
				sqlite3RowidConstraint(pParse, (int)(2), pTab);
			}
			else
			{
				sqlite3VdbeGoto(v, (int)(addrRecheck));
			}

			sqlite3VdbeResolveLabel(v, (int)(lblRecheckOk));
		}

		if ((((pTab).tabFlags & 0x00000080) == (0)))
		{
			int regRec = (int)(aRegIdx[ix]);
			sqlite3VdbeAddOp3(v, (int)(96), (int)(regNewData + 1), (int)(pTab.nNVCol), (int)(regRec));
			if (bAffinityDone == 0)
			{
				sqlite3TableAffinity(v, pTab, (int)(0));
			}
		}

		*pbMayReplace = (int)(seenReplace);
	}
	public static int sqlite3GenerateIndexKey(Parse pParse, Index pIdx, int iDataCur, int regOut, int prefixOnly, int* piPartIdxLabel, Index pPrior, int regPrior)
	{
		Vdbe v = pParse.pVdbe;
		int j = 0;
		int regBase = 0;
		int nCol = 0;
		if ((piPartIdxLabel) != null)
		{
			if ((pIdx.pPartIdxWhere) != null)
			{
				*piPartIdxLabel = (int)(sqlite3VdbeMakeLabel(pParse));
				pParse.iSelfTab = (int)(iDataCur + 1);
				sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, (int)(*piPartIdxLabel), (int)(0x10));
				pParse.iSelfTab = (int)(0);
				pPrior = null;
			}
			else
			{
				*piPartIdxLabel = (int)(0);
			}
		}

		nCol = (int)((((prefixOnly) != 0) && ((pIdx.uniqNotNull) != 0)) ? pIdx.nKeyCol : pIdx.nColumn);
		regBase = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
		if (((pPrior) != null) && ((regBase != regPrior) || ((pPrior.pPartIdxWhere) != null)))
			pPrior = null;
		for (j = (int)(0); (j) < (nCol); j++)
		{
			if ((((pPrior) != null) && ((pPrior.aiColumn[j]) == (pIdx.aiColumn[j]))) && (pPrior.aiColumn[j] != (-2)))
			{
				continue;
			}

			sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, (int)(iDataCur), (int)(j), (int)(regBase + j));
			if ((pIdx.aiColumn[j]) >= (0))
			{
				sqlite3VdbeDeletePriorOpcode(v, (byte)(86));
			}
		}

		if ((regOut) != 0)
		{
			sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase), (int)(nCol), (int)(regOut));
		}

		sqlite3ReleaseTempRange(pParse, (int)(regBase), (int)(nCol));
		return (int)(regBase);
	}
	public static void sqlite3GenerateRowDelete(Parse pParse, Table pTab, Trigger pTrigger, int iDataCur, int iIdxCur, int iPk, short nPk, byte count, byte onconf, byte eMode, int iIdxNoSeek)
	{
		Vdbe v = pParse.pVdbe;
		int iOld = (int)(0);
		int iLabel = 0;
		byte opSeek = 0;
		iLabel = (int)(sqlite3VdbeMakeLabel(pParse));
		opSeek = (byte)((((pTab).tabFlags & 0x00000080) == (0)) ? 33 : 30);
		if ((eMode) == (0))
		{
			sqlite3VdbeAddOp4Int(v, (int)(opSeek), (int)(iDataCur), (int)(iLabel), (int)(iPk), (int)(nPk));
		}

		if (((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) || ((pTrigger) != null))
		{
			uint mask = 0;
			int iCol = 0;
			int addrStart = 0;
			mask = (uint)(sqlite3TriggerColmask(pParse, pTrigger, null, (int)(0), (int)(1 | 2), pTab, (int)(onconf)));
			mask |= (uint)(sqlite3FkOldmask(pParse, pTab));
			iOld = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(1 + pTab.nCol);
			sqlite3VdbeAddOp2(v, (int)(79), (int)(iPk), (int)(iOld));
			for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
			{
				if (((mask) == (0xffffffff)) || (((iCol) <= (31)) && ((mask & (((uint)(1)) << (iCol))) != 0)))
				{
					int kk = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)));
					sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(iCol), (int)(iOld + kk + 1));
				}
			}

			addrStart = (int)(sqlite3VdbeCurrentAddr(v));
			sqlite3CodeRowTrigger(pParse, pTrigger, (int)(128), null, (int)(1), pTab, (int)(iOld), (int)(onconf), (int)(iLabel));
			if ((addrStart) < (sqlite3VdbeCurrentAddr(v)))
			{
				sqlite3VdbeAddOp4Int(v, (int)(opSeek), (int)(iDataCur), (int)(iLabel), (int)(iPk), (int)(nPk));
				iIdxNoSeek = (int)(-1);
			}

			sqlite3FkCheck(pParse, pTab, (int)(iOld), (int)(0), null, (int)(0));
		}

		if (!(((pTab).eTabType) == (2)))
		{
			byte p5 = (byte)(0);
			sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), null, (int)(iIdxNoSeek));
			sqlite3VdbeAddOp2(v, (int)(129), (int)(iDataCur), (int)((count) != 0 ? 0x01 : 0));
			if (((pParse.nested) == (0)) || ((0) == (sqlite3_stricmp(pTab.zName, "sqlite_stat1"))))
			{
				sqlite3VdbeAppendP4(v, (sbyte*)(pTab), (int)(-6));
			}

			if (eMode != 0)
			{
				sqlite3VdbeChangeP5(v, (ushort)(0x04));
			}

			if (((iIdxNoSeek) >= (0)) && (iIdxNoSeek != iDataCur))
			{
				sqlite3VdbeAddOp1(v, (int)(129), (int)(iIdxNoSeek));
			}

			if ((eMode) == (2))
				p5 |= (byte)(0x02);
			sqlite3VdbeChangeP5(v, (ushort)(p5));
		}

		sqlite3FkActions(pParse, pTab, null, (int)(iOld), null, (int)(0));
		sqlite3CodeRowTrigger(pParse, pTrigger, (int)(128), null, (int)(2), pTab, (int)(iOld), (int)(onconf), (int)(iLabel));
		sqlite3VdbeResolveLabel(v, (int)(iLabel));
	}
	public static void sqlite3GenerateRowIndexDelete(Parse pParse, Table pTab, int iDataCur, int iIdxCur, int* aRegIdx, int iIdxNoSeek)
	{
		int i = 0;
		int r1 = (int)(-1);
		int iPartIdxLabel = 0;
		Index pIdx;
		Index pPrior = null;
		Vdbe v;
		Index pPk;
		v = pParse.pVdbe;
		pPk = (((pTab).tabFlags & 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
		for (i = (int)(0), pIdx = pTab.pIndex; pIdx; i++, pIdx = pIdx.pNext)
		{
			if ((aRegIdx != null) && ((aRegIdx[i]) == (0)))
				continue;
			if ((pIdx) == (pPk))
				continue;
			if ((iIdxCur + i) == (iIdxNoSeek))
				continue;
			r1 = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(iDataCur), (int)(0), (int)(1), &iPartIdxLabel, pPrior, (int)(r1)));
			sqlite3VdbeAddOp3(v, (int)(139), (int)(iIdxCur + i), (int)(r1), (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol : pIdx.nColumn));
			sqlite3VdbeChangeP5(v, (ushort)(1));
			sqlite3ResolvePartIdxLabel(pParse, (int)(iPartIdxLabel));
			pPrior = pIdx;
		}
	}
	public static CollSeq sqlite3GetCollSeq(Parse pParse, byte enc, CollSeq pColl, sbyte* zName)
	{
		CollSeq p;
		sqlite3 db = pParse.db;
		p = pColl;
		if (p == null)
		{
			p = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(0));
		}

		if ((p == null) || (p.xCmp == null))
		{
			callCollNeeded(db, (int)(enc), zName);
			p = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(0));
		}

		if ((((p) != null) && (p.xCmp == null)) && ((synthCollSeq(db, p)) != 0))
		{
			p = null;
		}

		if ((p) == (null))
		{
			sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
			pParse.rc = (int)(1 | (1 << 8));
		}

		return p;
	}
	public static int sqlite3GetTempRange(Parse pParse, int nReg)
	{
		int i = 0; int n = 0;
		if ((nReg) == (1))
			return (int)(sqlite3GetTempReg(pParse));
		i = (int)(pParse.iRangeReg);
		n = (int)(pParse.nRangeReg);
		if ((nReg) <= (n))
		{
			pParse.iRangeReg += (int)(nReg);
			pParse.nRangeReg -= (int)(nReg);
		}
		else
		{
			i = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nReg);
		}

		return (int)(i);
	}
	public static int sqlite3GetTempReg(Parse pParse)
	{
		if ((pParse.nTempReg) == (0))
		{
			return (int)(++pParse.nMem);
		}

		return (int)(pParse.aTempReg[--pParse.nTempReg]);
	}
	public static Vdbe sqlite3GetVdbe(Parse pParse)
	{
		if ((pParse.pVdbe) != null)
		{
			return pParse.pVdbe;
		}

		if (((pParse.pToplevel) == (null)) && (((pParse.db).dbOptFlags & (0x00000008)) == (0)))
		{
			pParse.okConstFactor = (byte)(1);
		}

		return sqlite3VdbeCreate(pParse);
	}
	public static void sqlite3HaltConstraint(Parse pParse, int errCode, int onError, sbyte* p4, sbyte p4type, byte p5Errmsg)
	{
		Vdbe v;
		v = sqlite3GetVdbe(pParse);
		if ((onError) == (2))
		{
			sqlite3MayAbort(pParse);
		}

		sqlite3VdbeAddOp4(v, (int)(70), (int)(errCode), (int)(onError), (int)(0), p4, (int)(p4type));
		sqlite3VdbeChangeP5(v, (ushort)(p5Errmsg));
	}
	public static int sqlite3HasExplicitNulls(Parse pParse, ExprList pList)
	{
		if ((pList) != null)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				if ((pList.a[i].bNulls) != 0)
				{
					byte sf = (byte)(pList.a[i].sortFlags);
					sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s", (((sf) == (0)) || ((sf) == (3))) ? "FIRST" : "LAST");
					return (int)(1);
				}
			}
		}

		return (int)(0);
	}
	public static int sqlite3IndexedByLookup(Parse pParse, SrcItem pFrom)
	{
		Table pTab = pFrom.pTab;
		sbyte* zIndexedBy = pFrom.u1.zIndexedBy;
		Index pIdx;
		for (pIdx = pTab.pIndex; ((pIdx) != null) && ((sqlite3StrICmp(pIdx.zName, zIndexedBy)) != 0); pIdx = pIdx.pNext)
		{
		}

		if (pIdx == null)
		{
			sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, (int)(0));
			pParse.checkSchema = (byte)(1);
			return (int)(1);
		}

		pFrom.u2.pIBIndex = pIdx;
		return (int)(0);
	}
	public static void sqlite3Insert(Parse pParse, SrcList pTabList, Select pSelect, IdList* pColumn, int onError, Upsert pUpsert)
	{
		sqlite3 db;
		Table pTab;
		int i = 0; int j = 0;
		Vdbe v;
		Index pIdx;
		int nColumn = 0;
		int nHidden = (int)(0);
		int iDataCur = (int)(0);
		int iIdxCur = (int)(0);
		int ipkColumn = (int)(-1);
		int endOfLoop = 0;
		int srcTab = (int)(0);
		int addrInsTop = (int)(0);
		int addrCont = (int)(0);
		SelectDest dest = new SelectDest();
		int iDb = 0;
		byte useTempTable = (byte)(0);
		byte appendFlag = (byte)(0);
		byte withoutRowid = 0;
		byte bIdListInOrder = 0;
		ExprList pList = null;
		int iRegStore = 0;
		int regFromSelect = (int)(0);
		int regAutoinc = (int)(0);
		int regRowCount = (int)(0);
		int regIns = 0;
		int regRowid = 0;
		int regData = 0;
		int* aRegIdx = null;
		int isView = 0;
		Trigger pTrigger;
		int tmask = 0;
		db = pParse.db;
		if ((pParse.nErr) != 0)
		{
			goto insert_cleanup;
		}

		dest.iSDParm = (int)(0);
		if ((((pSelect) != null) && ((pSelect.selFlags & 0x0000200) != 0)) && ((pSelect.pPrior) == (null)))
		{
			pList = pSelect.pEList;
			pSelect.pEList = null;
			sqlite3SelectDelete(db, pSelect);
			pSelect = null;
		}

		pTab = sqlite3SrcListLookup(pParse, pTabList);
		if ((pTab) == (null))
		{
			goto insert_cleanup;
		}

		iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
		if ((sqlite3AuthCheck(pParse, (int)(18), pTab.zName, null, db.aDb[iDb].zDbSName)) != 0)
		{
			goto insert_cleanup;
		}

		withoutRowid = (byte)(!(((pTab).tabFlags & 0x00000080) == (0)));
		pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(127), null, &tmask);
		isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
		if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
		{
			goto insert_cleanup;
		}

		if ((sqlite3IsReadOnly(pParse, pTab, (int)(tmask))) != 0)
		{
			goto insert_cleanup;
		}

		v = sqlite3GetVdbe(pParse);
		if ((v) == (null))
			goto insert_cleanup;
		if ((pParse.nested) == (0))
			sqlite3VdbeCountChanges(v);
		sqlite3BeginWriteOperation(pParse, (((pSelect) != null) || ((pTrigger) != null) ? 1 : 0), (int)(iDb));
		if (((((pColumn) == (null)) && (pSelect != null)) && ((pTrigger) == (null))) && ((xferOptimization(pParse, pTab, pSelect, (int)(onError), (int)(iDb))) != 0))
		{
			goto insert_end;
		}

		regAutoinc = (int)(autoIncBegin(pParse, (int)(iDb), pTab));
		regRowid = (int)(regIns = (int)(pParse.nMem + 1));
		pParse.nMem += (int)(pTab.nCol + 1);
		if ((((pTab).eTabType) == (1)))
		{
			regRowid++;
			pParse.nMem++;
		}

		regData = (int)(regRowid + 1);
		bIdListInOrder = (byte)((pTab.tabFlags & (0x00000400 | 0x00000040)) == (0));
		if ((pColumn) != null)
		{
			for (i = (int)(0); (i) < (pColumn->nId); i++)
			{
				pColumn->a[i].idx = (int)(-1);
			}

			for (i = (int)(0); (i) < (pColumn->nId); i++)
			{
				for (j = (int)(0); (j) < (pTab.nCol); j++)
				{
					if ((sqlite3StrICmp(pColumn->a[i].zName, pTab.aCol[j].zCnName)) == (0))
					{
						pColumn->a[i].idx = (int)(j);
						if (i != j)
							bIdListInOrder = (byte)(0);
						if ((j) == (pTab.iPKey))
						{
							ipkColumn = (int)(i);
						}

						if ((pTab.aCol[j].colFlags & (0x0040 | 0x0020)) != 0)
						{
							sqlite3ErrorMsg(pParse, "cannot INSERT into generated column \"%s\"", pTab.aCol[j].zCnName);
							goto insert_cleanup;
						}

						break;
					}
				}

				if ((j) >= (pTab.nCol))
				{
					if (((sqlite3IsRowid(pColumn->a[i].zName)) != 0) && (withoutRowid == 0))
					{
						ipkColumn = (int)(i);
						bIdListInOrder = (byte)(0);
					}
					else
					{
						sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList.a, pColumn->a[i].zName);
						pParse.checkSchema = (byte)(1);
						goto insert_cleanup;
					}
				}
			}
		}

		if ((pSelect) != null)
		{
			int regYield = 0;
			int addrTop = 0;
			int rc = 0;
			regYield = (int)(++pParse.nMem);
			addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
			sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(addrTop));
			sqlite3SelectDestInit(dest, (int)(13), (int)(regYield));
			dest.iSdst = (int)((bIdListInOrder) != 0 ? regData : 0);
			dest.nSdst = (int)(pTab.nCol);
			rc = (int)(sqlite3Select(pParse, pSelect, dest));
			regFromSelect = (int)(dest.iSdst);
			if (((rc) != 0) || ((pParse.nErr) != 0))
				goto insert_cleanup;
			sqlite3VdbeEndCoroutine(v, (int)(regYield));
			sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
			nColumn = (int)(pSelect.pEList.nExpr);
			if (((pTrigger) != null) || ((readsTable(pParse, (int)(iDb), pTab)) != 0))
			{
				useTempTable = (byte)(1);
			}

			if ((useTempTable) != 0)
			{
				int regRec = 0;
				int regTempRowid = 0;
				int addrL = 0;
				srcTab = (int)(pParse.nTab++);
				regRec = (int)(sqlite3GetTempReg(pParse));
				regTempRowid = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp2(v, (int)(116), (int)(srcTab), (int)(nColumn));
				addrL = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm)));
				sqlite3VdbeAddOp3(v, (int)(96), (int)(regFromSelect), (int)(nColumn), (int)(regRec));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(srcTab), (int)(regTempRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(srcTab), (int)(regRec), (int)(regTempRowid));
				sqlite3VdbeGoto(v, (int)(addrL));
				sqlite3VdbeJumpHere(v, (int)(addrL));
				sqlite3ReleaseTempReg(pParse, (int)(regRec));
				sqlite3ReleaseTempReg(pParse, (int)(regTempRowid));
			}
		}
		else
		{
			NameContext sNC = new NameContext();
			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = pParse;
			srcTab = (int)(-1);
			if ((pList) != null)
			{
				nColumn = (int)(pList.nExpr);
				if ((sqlite3ResolveExprListNames(sNC, pList)) != 0)
				{
					goto insert_cleanup;
				}
			}
			else
			{
				nColumn = (int)(0);
			}
		}

		if (((pColumn) == (null)) && ((nColumn) > (0)))
		{
			ipkColumn = (int)(pTab.iPKey);
			if (((ipkColumn) >= (0)) && ((pTab.tabFlags & 0x00000060) != 0))
			{
				for (i = (int)(ipkColumn - 1); (i) >= (0); i--)
				{
					if ((pTab.aCol[i].colFlags & 0x0060) != 0)
					{
						ipkColumn--;
					}
				}
			}

			if ((pTab.tabFlags & (0x00000060 | 0x00000002)) != 0)
			{
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					if ((pTab.aCol[i].colFlags & 0x0062) != 0)
						nHidden++;
				}
			}

			if (nColumn != (pTab.nCol - nHidden))
			{
				sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied", pTabList.a, (int)(pTab.nCol - nHidden), (int)(nColumn));
				goto insert_cleanup;
			}
		}

		if ((pColumn != null) && (nColumn != pColumn->nId))
		{
			sqlite3ErrorMsg(pParse, "%d values for %d columns", (int)(nColumn), (int)(pColumn->nId));
			goto insert_cleanup;
		}

		if (((((db.flags & ((ulong)(0x00001) << 32)) != 0) && (pParse.nested == 0)) && (pParse.pTriggerTab == null)) && (pParse.bReturning == 0))
		{
			regRowCount = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regRowCount));
		}

		if (isView == 0)
		{
			int nIdx = 0;
			nIdx = (int)(sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0), (int)(-1), null, &iDataCur, &iIdxCur));
			aRegIdx = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (nIdx + 2)));
			if ((aRegIdx) == (null))
			{
				goto insert_cleanup;
			}

			for (i = (int)(0), pIdx = pTab.pIndex; (i) < (nIdx); pIdx = pIdx.pNext, i++)
			{
				aRegIdx[i] = (int)(++pParse.nMem);
				pParse.nMem += (int)(pIdx.nColumn);
			}

			aRegIdx[i] = (int)(++pParse.nMem);
		}

		if ((pUpsert) != null)
		{
			Upsert pNx;
			if ((((pTab).eTabType) == (1)))
			{
				sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"", pTab.zName);
				goto insert_cleanup;
			}

			if ((((pTab).eTabType) == (2)))
			{
				sqlite3ErrorMsg(pParse, "cannot UPSERT a view");
				goto insert_cleanup;
			}

			if ((sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget)) != 0)
			{
				goto insert_cleanup;
			}

			pTabList.a[0].iCursor = (int)(iDataCur);
			pNx = pUpsert;
			do
			{
				pNx.pUpsertSrc = pTabList;
				pNx.regData = (int)(regData);
				pNx.iDataCur = (int)(iDataCur);
				pNx.iIdxCur = (int)(iIdxCur);
				if ((pNx.pUpsertTarget) != null)
				{
					if ((sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx)) != 0)
					{
						goto insert_cleanup;
					}
				}

				pNx = pNx.pNextUpsert;
			}
			while (pNx != null);
		}

		if ((useTempTable) != 0)
		{
			addrInsTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(srcTab)));
			addrCont = (int)(sqlite3VdbeCurrentAddr(v));
		}
		else if ((pSelect) != null)
		{
			addrInsTop = (int)(addrCont = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm))));
			if ((ipkColumn) >= (0))
			{
				sqlite3VdbeAddOp2(v, (int)(79), (int)(regFromSelect + ipkColumn), (int)(regRowid));
			}
		}

		nHidden = (int)(0);
		iRegStore = (int)(regData);
		for (i = (int)(0); (i) < (pTab.nCol); i++, iRegStore++)
		{
			int k = 0;
			uint colFlags = 0;
			if ((i) == (pTab.iPKey))
			{
				sqlite3VdbeAddOp1(v, (int)(75), (int)(iRegStore));
				continue;
			}

			if (((colFlags = (uint)(pTab.aCol[i].colFlags)) & 0x0062) != 0)
			{
				nHidden++;
				if ((colFlags & 0x0020) != 0)
				{
					iRegStore--;
					continue;
				}
				else if ((colFlags & 0x0040) != 0)
				{
					if ((tmask & 1) != 0)
					{
						sqlite3VdbeAddOp1(v, (int)(75), (int)(iRegStore));
					}

					continue;
				}
				else if ((pColumn) == (null))
				{
					sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab.aCol[i]), (int)(iRegStore));
					continue;
				}
			}

			if ((pColumn) != null)
			{
				for (j = (int)(0); ((j) < (pColumn->nId)) && (pColumn->a[j].idx != i); j++)
				{
				}

				if ((j) >= (pColumn->nId))
				{
					sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab.aCol[i]), (int)(iRegStore));
					continue;
				}

				k = (int)(j);
			}
			else if ((nColumn) == (0))
			{
				sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab.aCol[i]), (int)(iRegStore));
				continue;
			}
			else
			{
				k = (int)(i - nHidden);
			}

			if ((useTempTable) != 0)
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(k), (int)(iRegStore));
			}
			else if ((pSelect) != null)
			{
				if (regFromSelect != regData)
				{
					sqlite3VdbeAddOp2(v, (int)(80), (int)(regFromSelect + k), (int)(iRegStore));
				}
			}
			else
			{
				sqlite3ExprCode(pParse, pList.a[k].pExpr, (int)(iRegStore));
			}
		}

		endOfLoop = (int)(sqlite3VdbeMakeLabel(pParse));
		if ((tmask & 1) != 0)
		{
			int regCols = (int)(sqlite3GetTempRange(pParse, (int)(pTab.nCol + 1)));
			if ((ipkColumn) < (0))
			{
				sqlite3VdbeAddOp2(v, (int)(71), (int)(-1), (int)(regCols));
			}
			else
			{
				int addr1 = 0;
				if ((useTempTable) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(ipkColumn), (int)(regCols));
				}
				else
				{
					sqlite3ExprCode(pParse, pList.a[ipkColumn].pExpr, (int)(regCols));
				}

				addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(regCols)));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(-1), (int)(regCols));
				sqlite3VdbeJumpHere(v, (int)(addr1));
				sqlite3VdbeAddOp1(v, (int)(15), (int)(regCols));
			}

			sqlite3VdbeAddOp3(v, (int)(79), (int)(regRowid + 1), (int)(regCols + 1), (int)(pTab.nNVCol - 1));
			if ((pTab.tabFlags & 0x00000060) != 0)
			{
				sqlite3ComputeGeneratedColumns(pParse, (int)(regCols + 1), pTab);
			}

			if (isView == 0)
			{
				sqlite3TableAffinity(v, pTab, (int)(regCols + 1));
			}

			sqlite3CodeRowTrigger(pParse, pTrigger, (int)(127), null, (int)(1), pTab, (int)(regCols - pTab.nCol - 1), (int)(onError), (int)(endOfLoop));
			sqlite3ReleaseTempRange(pParse, (int)(regCols), (int)(pTab.nCol + 1));
		}

		if (isView == 0)
		{
			if ((((pTab).eTabType) == (1)))
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regIns));
			}

			if ((ipkColumn) >= (0))
			{
				if ((useTempTable) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(ipkColumn), (int)(regRowid));
				}
				else if ((pSelect) != null)
				{
				}
				else
				{
					Expr pIpk = pList.a[ipkColumn].pExpr;
					if (((pIpk.op) == (121)) && (!(((pTab).eTabType) == (1))))
					{
						sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
						appendFlag = (byte)(1);
					}
					else
					{
						sqlite3ExprCode(pParse, pList.a[ipkColumn].pExpr, (int)(regRowid));
					}
				}

				if (appendFlag == 0)
				{
					int addr1 = 0;
					if (!(((pTab).eTabType) == (1)))
					{
						addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(regRowid)));
						sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
						sqlite3VdbeJumpHere(v, (int)(addr1));
					}
					else
					{
						addr1 = (int)(sqlite3VdbeCurrentAddr(v));
						sqlite3VdbeAddOp2(v, (int)(50), (int)(regRowid), (int)(addr1 + 2));
					}

					sqlite3VdbeAddOp1(v, (int)(15), (int)(regRowid));
				}
			}
			else if ((((pTab).eTabType) == (1)) || ((withoutRowid) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regRowid));
			}
			else
			{
				sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
				appendFlag = (byte)(1);
			}

			autoIncStep(pParse, (int)(regAutoinc), (int)(regRowid));
			if ((pTab.tabFlags & 0x00000060) != 0)
			{
				sqlite3ComputeGeneratedColumns(pParse, (int)(regRowid + 1), pTab);
			}

			if ((((pTab).eTabType) == (1)))
			{
				sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
				sqlite3VtabMakeWritable(pParse, pTab);
				sqlite3VdbeAddOp4(v, (int)(10), (int)(1), (int)(pTab.nCol + 2), (int)(regIns), pVTab, (int)(-12));
				sqlite3VdbeChangeP5(v, (ushort)((onError) == (11) ? 2 : onError));
				sqlite3MayAbort(pParse);
			}
			else
			{
				int isReplace = (int)(0);
				int bUseSeek = 0;
				sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, (int)(iDataCur), (int)(iIdxCur), (int)(regIns), (int)(0), (byte)((ipkColumn) >= (0)), (byte)(onError), (int)(endOfLoop), &isReplace, null, pUpsert);
				sqlite3FkCheck(pParse, pTab, (int)(0), (int)(regIns), null, (int)(0));
				bUseSeek = (int)(((isReplace) == (0)) || (sqlite3VdbeHasSubProgram(v) == 0) ? 1 : 0);
				sqlite3CompleteInsertion(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), (int)(regIns), aRegIdx, (int)(0), (int)(appendFlag), (int)(bUseSeek));
			}
		}

		if ((regRowCount) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(85), (int)(regRowCount), (int)(1));
		}

		if ((pTrigger) != null)
		{
			sqlite3CodeRowTrigger(pParse, pTrigger, (int)(127), null, (int)(2), pTab, (int)(regData - 2 - pTab.nCol), (int)(onError), (int)(endOfLoop));
		}

		sqlite3VdbeResolveLabel(v, (int)(endOfLoop));
		if ((useTempTable) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(5), (int)(srcTab), (int)(addrCont));
			sqlite3VdbeJumpHere(v, (int)(addrInsTop));
			sqlite3VdbeAddOp1(v, (int)(121), (int)(srcTab));
		}
		else if ((pSelect) != null)
		{
			sqlite3VdbeGoto(v, (int)(addrCont));
			sqlite3VdbeJumpHere(v, (int)(addrInsTop));
		}

	insert_end:
		; if (((pParse.nested) == (0)) && ((pParse.pTriggerTab) == (null))) { sqlite3AutoincrementEnd(pParse); }
		if ((regRowCount) != 0)
		{
			sqlite3CodeChangeCount(v, (int)(regRowCount), "rows inserted");
		}

	insert_cleanup:
		; sqlite3SrcListDelete(db, pTabList);
		sqlite3ExprListDelete(db, pList);
		sqlite3UpsertDelete(db, pUpsert);
		sqlite3SelectDelete(db, pSelect);
		sqlite3IdListDelete(db, pColumn);
		sqlite3DbFree(db, aRegIdx);
	}
	public static int sqlite3IsReadOnly(Parse pParse, Table pTab, int viewOk)
	{
		if ((tabIsReadOnly(pParse, pTab)) != 0)
		{
			sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab.zName);
			return (int)(1);
		}

		if ((viewOk == 0) && (((pTab).eTabType) == (2)))
		{
			sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", pTab.zName);
			return (int)(1);
		}

		return (int)(0);
	}
	public static int sqlite3JoinType(Parse pParse, Token* pA, Token* pB, Token* pC)
	{
		int jointype = (int)(0);
		Token** apAll = stackalloc Token[3];
		Token* p;
		int i = 0; int j = 0;
		apAll[0] = pA;
		apAll[1] = pB;
		apAll[2] = pC;
		for (i = (int)(0); ((i) < (3)) && ((apAll[i]) != null); i++)
		{
			p = apAll[i];
			for (j = (int)(0); (j) < ((int)(7 * sizeof(aKeywordType) / sizeof(aKeywordType))); j++)
			{
				if (((p->n) == (sqlite3JoinType_aKeyword[j].nChar)) && ((sqlite3_strnicmp(p->z, &sqlite3JoinType_zKeyText[sqlite3JoinType_aKeyword[j].i], (int)(p->n))) == (0)))
				{
					jointype |= (int)(sqlite3JoinType_aKeyword[j].code);
					break;
				}
			}

			if ((j) >= ((int)(7 * sizeof(aKeywordType) / sizeof(aKeywordType))))
			{
				jointype |= (int)(0x0040);
				break;
			}
		}

		if (((jointype & (0x0001 | 0x0020)) == (0x0001 | 0x0020)) || ((jointype & 0x0040) != 0))
		{
			sbyte* zSp = " ";
			if ((pC) == (null))
			{
				zSp++;
			}

			sqlite3ErrorMsg(pParse, "unknown or unsupported join type: %T %T%s%T", pA, pB, zSp, pC);
			jointype = (int)(0x0001);
		}
		else if (((jointype & 0x0020) != 0) && ((jointype & (0x0008 | 0x0010)) != 0x0008))
		{
			sqlite3ErrorMsg(pParse, "RIGHT and FULL OUTER JOINs are not currently supported");
			jointype = (int)(0x0001);
		}

		return (int)(jointype);
	}
	public static KeyInfo sqlite3KeyInfoFromExprList(Parse pParse, ExprList pList, int iStart, int nExtra)
	{
		int nExpr = 0;
		KeyInfo pInfo;
		ExprList_item* pItem;
		sqlite3 db = pParse.db;
		int i = 0;
		nExpr = (int)(pList.nExpr);
		pInfo = sqlite3KeyInfoAlloc(db, (int)(nExpr - iStart), (int)(nExtra + 1));
		if ((pInfo) != null)
		{
			for (i = (int)(iStart), pItem = pList.a + iStart; (i) < (nExpr); i++, pItem++)
			{
				pInfo.aColl[i - iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
				pInfo.aSortFlags[i - iStart] = (byte)(pItem->sortFlags);
			}
		}

		return pInfo;
	}
	public static KeyInfo sqlite3KeyInfoOfIndex(Parse pParse, Index pIdx)
	{
		int i = 0;
		int nCol = (int)(pIdx.nColumn);
		int nKey = (int)(pIdx.nKeyCol);
		KeyInfo pKey;
		if ((pParse.nErr) != 0)
			return null;
		if ((pIdx.uniqNotNull) != 0)
		{
			pKey = sqlite3KeyInfoAlloc(pParse.db, (int)(nKey), (int)(nCol - nKey));
		}
		else
		{
			pKey = sqlite3KeyInfoAlloc(pParse.db, (int)(nCol), (int)(0));
		}

		if ((pKey) != null)
		{
			for (i = (int)(0); (i) < (nCol); i++)
			{
				sbyte* zColl = pIdx.azColl[i];
				pKey.aColl[i] = (zColl) == (sqlite3StrBINARY) ? null : sqlite3LocateCollSeq(pParse, zColl);
				pKey.aSortFlags[i] = (byte)(pIdx.aSortOrder[i]);
			}

			if ((pParse.nErr) != 0)
			{
				if ((pIdx.bNoQuery) == (0))
				{
					pIdx.bNoQuery = (uint)(1);
					pParse.rc = (int)(1 | (2 << 8));
				}

				sqlite3KeyInfoUnref(pKey);
				pKey = null;
			}
		}

		return pKey;
	}
	public static CollSeq sqlite3LocateCollSeq(Parse pParse, sbyte* zName)
	{
		sqlite3 db = pParse.db;
		byte enc = (byte)((db).enc);
		byte initbusy = (byte)(db.init.busy);
		CollSeq pColl;
		pColl = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(initbusy));
		if ((initbusy == 0) && ((pColl == null) || (pColl.xCmp == null)))
		{
			pColl = sqlite3GetCollSeq(pParse, (byte)(enc), pColl, zName);
		}

		return pColl;
	}
	public static Table sqlite3LocateTable(Parse pParse, uint flags, sbyte* zName, sbyte* zDbase)
	{
		Table p;
		sqlite3 db = pParse.db;
		if (((db.mDbFlags & 0x0010) == (0)) && (0 != sqlite3ReadSchema(pParse)))
		{
			return null;
		}

		p = sqlite3FindTable(db, zName, zDbase);
		if ((p) == (null))
		{
			if (((pParse.disableVtab) == (0)) && ((db.init.busy) == (0)))
			{
				Module pMod = (Module)(sqlite3HashFind(&db.aModule, zName));
				if (((pMod) == (null)) && ((sqlite3_strnicmp(zName, "pragma_", (int)(7))) == (0)))
				{
					pMod = sqlite3PragmaVtabRegister(db, zName);
				}

				if (((pMod) != null) && ((sqlite3VtabEponymousTableInit(pParse, pMod)) != 0))
				{
					return pMod.pEpoTab;
				}
			}

			if ((flags & 0x02) != 0)
				return null;
			pParse.checkSchema = (byte)(1);
		}
		else if ((((p).eTabType) == (1)) && ((pParse.disableVtab) != 0))
		{
			p = null;
		}

		if ((p) == (null))
		{
			sbyte* zMsg = (flags & 0x01) != 0 ? "no such view" : "no such table";
			if ((zDbase) != null)
			{
				sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
			}
			else
			{
				sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
			}
		}
		else
		{
		}

		return p;
	}
	public static Table sqlite3LocateTableItem(Parse pParse, uint flags, SrcItem p)
	{
		sbyte* zDb;
		if ((p.pSchema) != null)
		{
			int iDb = (int)(sqlite3SchemaToIndex(pParse.db, p.pSchema));
			zDb = pParse.db.aDb[iDb].zDbSName;
		}
		else
		{
			zDb = p.zDatabase;
		}

		return sqlite3LocateTable(pParse, (uint)(flags), p.zName, zDb);
	}
	public static void sqlite3MaterializeView(Parse pParse, Table pView, Expr pWhere, ExprList pOrderBy, Expr pLimit, int iCur)
	{
		SelectDest dest = new SelectDest();
		Select pSel;
		SrcList pFrom;
		sqlite3 db = pParse.db;
		int iDb = (int)(sqlite3SchemaToIndex(db, pView.pSchema));
		pWhere = sqlite3ExprDup(db, pWhere, (int)(0));
		pFrom = sqlite3SrcListAppend(pParse, null, null, null);
		if ((pFrom) != null)
		{
			pFrom.a[0].zName = sqlite3DbStrDup(db, pView.zName);
			pFrom.a[0].zDatabase = sqlite3DbStrDup(db, db.aDb[iDb].zDbSName);
		}

		pSel = sqlite3SelectNew(pParse, null, pFrom, pWhere, null, null, pOrderBy, (uint)(0x0020000), pLimit);
		sqlite3SelectDestInit(dest, (int)(12), (int)(iCur));
		sqlite3Select(pParse, pSel, dest);
		sqlite3SelectDelete(db, pSel);
	}
	public static void sqlite3MayAbort(Parse pParse)
	{
		Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		pToplevel.mayAbort = (byte)(1);
	}
	public static void sqlite3MultiWrite(Parse pParse)
	{
		Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		pToplevel.isMultiWrite = (byte)(1);
	}
	public static void sqlite3NestedParse(Parse pParse, sbyte* zFormat)
	{
		sbyte* ap;
		sbyte* zSql;
		sqlite3 db = pParse.db;
		uint savedDbFlags = (uint)(db.mDbFlags);
		char[(sizeof(Parse) - ((size_t) & (((Parse*)0)->sLastToken)))] saveBuf = (char[(sizeof(Parse) - ((size_t) & (((Parse*)0)->sLastToken)))])(sizeof(Parse) - ((ulong)(&((0).sLastToken))));
		if ((pParse.nErr) != 0)
			return;
		(__va_start(&ap, zFormat));
		zSql = sqlite3VMPrintf(db, zFormat, ap);
		((void)(ap = null));
		if ((zSql) == (null))
		{
			if (db.mallocFailed == 0)
				pParse.rc = (int)(18);
			pParse.nErr++;
			return;
		}

		pParse.nested++;
		CRuntime.memcpy(saveBuf, (((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
		CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
		db.mDbFlags |= (uint)(0x0002);
		sqlite3RunParser(pParse, zSql);
		sqlite3DbFree(db, pParse.zErrMsg);
		pParse.zErrMsg = null;
		db.mDbFlags = (uint)(savedDbFlags);
		sqlite3DbFree(db, zSql);
		CRuntime.memcpy((((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), saveBuf, (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
		pParse.nested--;
	}
	public static void sqlite3OpenSchemaTable(Parse p, int iDb)
	{
		Vdbe v = sqlite3GetVdbe(p);
		sqlite3TableLock(p, (int)(iDb), (uint)(1), (byte)(1), "sqlite_master");
		sqlite3VdbeAddOp4Int(v, (int)(112), (int)(0), (int)(1), (int)(iDb), (int)(5));
		if ((p.nTab) == (0))
		{
			p.nTab = (int)(1);
		}
	}
	public static void sqlite3OpenTable(Parse pParse, int iCur, int iDb, Table pTab, int opcode)
	{
		Vdbe v;
		v = pParse.pVdbe;
		sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(((opcode) == (112)) ? 1 : 0), pTab.zName);
		if ((((pTab).tabFlags & 0x00000080) == (0)))
		{
			sqlite3VdbeAddOp4Int(v, (int)(opcode), (int)(iCur), (int)(pTab.tnum), (int)(iDb), (int)(pTab.nNVCol));
		}
		else
		{
			Index pPk = sqlite3PrimaryKeyIndex(pTab);
			sqlite3VdbeAddOp3(v, (int)(opcode), (int)(iCur), (int)(pPk.tnum), (int)(iDb));
			sqlite3VdbeSetP4KeyInfo(pParse, pPk);
		}
	}
	public static int sqlite3OpenTableAndIndices(Parse pParse, Table pTab, int op, byte p5, int iBase, byte* aToOpen, int* piDataCur, int* piIdxCur)
	{
		int i = 0;
		int iDb = 0;
		int iDataCur = 0;
		Index pIdx;
		Vdbe v;
		if ((((pTab).eTabType) == (1)))
		{
			*piDataCur = (int)(*piIdxCur = (int)(-999));
			return (int)(0);
		}

		iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
		v = pParse.pVdbe;
		if ((iBase) < (0))
			iBase = (int)(pParse.nTab);
		iDataCur = (int)(iBase++);
		if ((piDataCur) != null)
			*piDataCur = (int)(iDataCur);
		if ((((pTab).tabFlags & 0x00000080) == (0)) && (((aToOpen) == (null)) || ((aToOpen[0]) != 0)))
		{
			sqlite3OpenTable(pParse, (int)(iDataCur), (int)(iDb), pTab, (int)(op));
		}
		else
		{
			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)((op) == (112)), pTab.zName);
		}

		if ((piIdxCur) != null)
			*piIdxCur = (int)(iBase);
		for (i = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, i++)
		{
			int iIdxCur = (int)(iBase++);
			if ((((pIdx).idxType) == (2)) && (!(((pTab).tabFlags & 0x00000080) == (0))))
			{
				if ((piDataCur) != null)
					*piDataCur = (int)(iIdxCur);
				p5 = (byte)(0);
			}

			if (((aToOpen) == (null)) || ((aToOpen[i + 1]) != 0))
			{
				sqlite3VdbeAddOp3(v, (int)(op), (int)(iIdxCur), (int)(pIdx.tnum), (int)(iDb));
				sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
				sqlite3VdbeChangeP5(v, (ushort)(p5));
			}
		}

		if ((iBase) > (pParse.nTab))
			pParse.nTab = (int)(iBase);
		return (int)(i);
	}
	public static int sqlite3OpenTempDatabase(Parse pParse)
	{
		sqlite3 db = pParse.db;
		if (((db.aDb[1].pBt) == (null)) && (pParse.explain == 0))
		{
			int rc = 0;
			Btree pBt;
			rc = (int)(sqlite3BtreeOpen(db.pVfs, null, db, pBt, (int)(0), (int)(sqlite3OpenTempDatabase_flags)));
			if (rc != 0)
			{
				sqlite3ErrorMsg(pParse, "unable to open a temporary database file for storing temporary tables");
				pParse.rc = (int)(rc);
				return (int)(1);
			}

			db.aDb[1].pBt = pBt;
			if ((7) == (sqlite3BtreeSetPageSize(pBt, (int)(db.nextPagesize), (int)(0), (int)(0))))
			{
				sqlite3OomFault(db);
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static void sqlite3ParseObjectInit(Parse pParse, sqlite3 db)
	{
		CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&((0).zErrMsg)))), (int)(0), (ulong)(((ulong)(&((0).aTempReg))) - ((ulong)(&((0).zErrMsg)))));
		CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
		pParse.pOuterParse = db.pParse;
		db.pParse = pParse;
		pParse.db = db;
		if ((db.mallocFailed) != 0)
			sqlite3ErrorMsg(pParse, "out of memory");
	}
	public static void sqlite3ParseObjectReset(Parse pParse)
	{
		sqlite3 db = pParse.db;
		sqlite3DbFree(db, pParse.aTableLock);
		while ((pParse.pCleanup) != null)
		{
			ParseCleanup pCleanup = pParse.pCleanup;
			pParse.pCleanup = pCleanup.pNext;
			pCleanup.xCleanup(db, pCleanup.pPtr);
			sqlite3DbFreeNN(db, pCleanup);
		}

		sqlite3DbFree(db, pParse.aLabel);
		if ((pParse.pConstExpr) != null)
		{
			sqlite3ExprListDelete(db, pParse.pConstExpr);
		}

		db.lookaside.bDisable -= (uint)(pParse.disableLookaside);
		db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
		db.pParse = pParse.pOuterParse;
		pParse.db = null;
		pParse.disableLookaside = (byte)(0);
	}
	public static Expr sqlite3PExpr(Parse pParse, int op, Expr pLeft, Expr pRight)
	{
		Expr p;
		p = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Expr)));
		if ((p) != null)
		{
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(Expr)));
			p.op = (byte)(op & 0xff);
			p.iAgg = (short)(-1);
			sqlite3ExprAttachSubtrees(pParse.db, p, pLeft, pRight);
			sqlite3ExprCheckHeight(pParse, (int)(p.nHeight));
		}
		else
		{
			sqlite3ExprDelete(pParse.db, pLeft);
			sqlite3ExprDelete(pParse.db, pRight);
		}

		return p;
	}
	public static void sqlite3PExprAddSelect(Parse pParse, Expr pExpr, Select pSelect)
	{
		if ((pExpr) != null)
		{
			pExpr.x.pSelect = pSelect;
			(pExpr).flags |= (uint)(0x000800 | 0x200000);
			sqlite3ExprSetHeightAndFlags(pParse, pExpr);
		}
		else
		{
			sqlite3SelectDelete(pParse.db, pSelect);
		}
	}
	public static void sqlite3Pragma(Parse pParse, Token* pId1, Token* pId2, Token* pValue, int minusFlag)
	{
		sbyte* zLeft = null;
		sbyte* zRight = null;
		sbyte* zDb = null;
		Token* pId;
		sbyte** aFcntl = stackalloc sbyte[4];
		int iDb = 0;
		int rc = 0;
		sqlite3 db = pParse.db;
		Db pDb;
		Vdbe v = sqlite3GetVdbe(pParse);
		PragmaName* pPragma;
		if ((v) == (null))
			return;
		sqlite3VdbeRunOnlyOnce(v);
		pParse.nMem = (int)(2);
		iDb = (int)(sqlite3TwoPartName(pParse, pId1, pId2, &pId));
		if ((iDb) < (0))
			return;
		pDb = db.aDb[iDb];
		if (((iDb) == (1)) && ((sqlite3OpenTempDatabase(pParse)) != 0))
		{
			return;
		}

		zLeft = sqlite3NameFromToken(db, pId);
		if (zLeft == null)
			return;
		if ((minusFlag) != 0)
		{
			zRight = sqlite3MPrintf(db, "-%T", pValue);
		}
		else
		{
			zRight = sqlite3NameFromToken(db, pValue);
		}

		zDb = (pId2->n) > (0) ? pDb.zDbSName : null;
		if ((sqlite3AuthCheck(pParse, (int)(19), zLeft, zRight, zDb)) != 0)
		{
			goto pragma_out;
		}

		aFcntl[0] = null;
		aFcntl[1] = zLeft;
		aFcntl[2] = zRight;
		aFcntl[3] = null;
		db.busyHandler.nBusy = (int)(0);
		rc = (int)(sqlite3_file_control(db, zDb, (int)(14), (void*)(aFcntl)));
		if ((rc) == (0))
		{
			sqlite3VdbeSetNumCols(v, (int)(1));
			sqlite3VdbeSetColName(v, (int)(0), (int)(0), aFcntl[0], ((Void(Void * ))(-1)));
			returnSingleText(v, aFcntl[0]);
			sqlite3_free(aFcntl[0]);
			goto pragma_out;
		}

		if (rc != 12)
		{
			if ((aFcntl[0]) != null)
			{
				sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
				sqlite3_free(aFcntl[0]);
			}

			pParse.nErr++;
			pParse.rc = (int)(rc);
			goto pragma_out;
		}

		pPragma = pragmaLocate(zLeft);
		if ((pPragma) == (null))
		{
			goto pragma_out;
		}

		if ((pPragma->mPragFlg & 0x01) != 0)
		{
			if ((sqlite3ReadSchema(pParse)) != 0)
				goto pragma_out;
		}

		if (((pPragma->mPragFlg & 0x02) == (0)) && (((pPragma->mPragFlg & 0x04) == (0)) || ((zRight) == (null))))
		{
			setPragmaResultColumnNames(v, pPragma);
		}

		switch (pPragma->ePragTyp)
		{
			case 13:
				{
					VdbeOp* aOp;
					sqlite3VdbeUsesBtree(v, (int)(iDb));
					if (zRight == null)
					{
						pParse.nMem += (int)(2);
						aOp = sqlite3VdbeAddOpList(v, ((int)(9 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_getCacheSize, (int)(sqlite3Pragma_iLn));
						if ((0) != 0)
							break;
						aOp[0].p1 = (int)(iDb);
						aOp[1].p1 = (int)(iDb);
						aOp[6].p1 = (int)(-2000);
					}
					else
					{
						int size = (int)(sqlite3AbsInt32((int)(sqlite3Atoi(zRight))));
						sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
						sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(3), (int)(size));
						pDb.pSchema.cache_size = (int)(size);
						sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
					}

					break;
				}

			case 31:
				{
					Btree pBt = pDb.pBt;
					if (zRight == null)
					{
						int size = (int)((pBt) ? sqlite3BtreeGetPageSize(pBt) : 0);
						returnSingleInt(v, (long)(size));
					}
					else
					{
						db.nextPagesize = (int)(sqlite3Atoi(zRight));
						if ((7) == (sqlite3BtreeSetPageSize(pBt, (int)(db.nextPagesize), (int)(0), (int)(0))))
						{
							sqlite3OomFault(db);
						}
					}

					break;
				}

			case 33:
				{
					Btree pBt = pDb.pBt;
					int b = (int)(-1);
					if ((zRight) != null)
					{
						if ((sqlite3_stricmp(zRight, "fast")) == (0))
						{
							b = (int)(2);
						}
						else
						{
							b = (int)(sqlite3GetBoolean(zRight, (byte)(0)));
						}
					}

					if (((pId2->n) == (0)) && ((b) >= (0)))
					{
						int ii = 0;
						for (ii = (int)(0); (ii) < (db.nDb); ii++)
						{
							sqlite3BtreeSecureDelete(db.aDb[ii].pBt, (int)(b));
						}
					}

					b = (int)(sqlite3BtreeSecureDelete(pBt, (int)(b)));
					returnSingleInt(v, (long)(b));
					break;
				}

			case 27:
				{
					int iReg = 0;
					long x = (long)(0);
					sqlite3CodeVerifySchema(pParse, (int)(iDb));
					iReg = (int)(++pParse.nMem);
					if ((sqlite3UpperToLower[(byte)(zLeft[0])]) == (112))
					{
						sqlite3VdbeAddOp2(v, (int)(176), (int)(iDb), (int)(iReg));
					}
					else
					{
						if (((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &x)) == (0)))
						{
							if ((x) < (0))
								x = (long)(0);
							else if ((x) > (0xfffffffe))
								x = (long)(0xfffffffe);
						}
						else
						{
							x = (long)(0);
						}

						sqlite3VdbeAddOp3(v, (int)(177), (int)(iDb), (int)(iReg), (int)(x));
					}

					sqlite3VdbeAddOp2(v, (int)(83), (int)(iReg), (int)(1));
					break;
				}

			case 26:
				{
					sbyte* zRet = "normal";
					int eMode = (int)(getLockingMode(zRight));
					if (((pId2->n) == (0)) && ((eMode) == (-1)))
					{
						eMode = (int)(db.dfltLockMode);
					}
					else
					{
						Pager pPager;
						if ((pId2->n) == (0))
						{
							int ii = 0;
							for (ii = (int)(2); (ii) < (db.nDb); ii++)
							{
								pPager = sqlite3BtreePager(db.aDb[ii].pBt);
								sqlite3PagerLockingMode(pPager, (int)(eMode));
							}

							db.dfltLockMode = ((byte)(eMode));
						}

						pPager = sqlite3BtreePager(pDb.pBt);
						eMode = (int)(sqlite3PagerLockingMode(pPager, (int)(eMode)));
					}

					if ((eMode) == (1))
					{
						zRet = "exclusive";
					}

					returnSingleText(v, zRet);
					break;
				}

			case 23:
				{
					int eMode = 0;
					int ii = 0;
					if ((zRight) == (null))
					{
						eMode = (int)(-1);
					}
					else
					{
						sbyte* zMode;
						int n = (int)(sqlite3Strlen30(zRight));
						for (eMode = (int)(0); (zMode = sqlite3JournalModename((int)(eMode))) != null; eMode++)
						{
							if ((sqlite3_strnicmp(zRight, zMode, (int)(n))) == (0))
								break;
						}

						if (zMode == null)
						{
							eMode = (int)(-1);
						}

						if (((eMode) == (2)) && ((db.flags & 0x10000000) != 0))
						{
							eMode = (int)(-1);
						}
					}

					if (((eMode) == (-1)) && ((pId2->n) == (0)))
					{
						iDb = (int)(0);
						pId2->n = (uint)(1);
					}

					for (ii = (int)(db.nDb - 1); (ii) >= (0); ii--)
					{
						if (((db.aDb[ii].pBt) != null) && (((ii) == (iDb)) || ((pId2->n) == (0))))
						{
							sqlite3VdbeUsesBtree(v, (int)(ii));
							sqlite3VdbeAddOp3(v, (int)(7), (int)(ii), (int)(1), (int)(eMode));
						}
					}

					sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
					break;
				}

			case 24:
				{
					Pager pPager = sqlite3BtreePager(pDb.pBt);
					long iLimit = (long)(-2);
					if ((zRight) != null)
					{
						sqlite3DecOrHexToI64(zRight, &iLimit);
						if ((iLimit) < (-1))
							iLimit = (long)(-1);
					}

					iLimit = (long)(sqlite3PagerJournalSizeLimit(pPager, (long)(iLimit)));
					returnSingleInt(v, (long)(iLimit));
					break;
				}

			case 3:
				{
					Btree pBt = pDb.pBt;
					if (zRight == null)
					{
						returnSingleInt(v, (long)(sqlite3BtreeGetAutoVacuum(pBt)));
					}
					else
					{
						int eAuto = (int)(getAutoVacuum(zRight));
						db.nextAutovac = (sbyte)((byte)(eAuto));
						rc = (int)(sqlite3BtreeSetAutoVacuum(pBt, (int)(eAuto)));
						if (((rc) == (0)) && (((eAuto) == (1)) || ((eAuto) == (2))))
						{
							VdbeOp* aOp;
							int iAddr = (int)(sqlite3VdbeCurrentAddr(v));
							aOp = sqlite3VdbeAddOpList(v, ((int)(5 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_setMeta6, (int)(sqlite3Pragma_iLn));
							if ((0) != 0)
								break;
							aOp[0].p1 = (int)(iDb);
							aOp[1].p1 = (int)(iDb);
							aOp[2].p2 = (int)(iAddr + 4);
							aOp[4].p1 = (int)(iDb);
							aOp[4].p3 = (int)(eAuto - 1);
							sqlite3VdbeUsesBtree(v, (int)(iDb));
						}
					}

					break;
				}

			case 19:
				{
					int iLimit = 0;
					int addr = 0;
					if ((((zRight) == (null)) || (sqlite3GetInt32(zRight, &iLimit) == 0)) || ((iLimit) <= (0)))
					{
						iLimit = (int)(0x7fffffff);
					}

					sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(iLimit), (int)(1));
					addr = (int)(sqlite3VdbeAddOp1(v, (int)(61), (int)(iDb)));
					sqlite3VdbeAddOp1(v, (int)(83), (int)(1));
					sqlite3VdbeAddOp2(v, (int)(85), (int)(1), (int)(-1));
					sqlite3VdbeAddOp2(v, (int)(49), (int)(1), (int)(addr));
					sqlite3VdbeJumpHere(v, (int)(addr));
					break;
				}

			case 6:
				{
					if (zRight == null)
					{
						returnSingleInt(v, (long)(pDb.pSchema.cache_size));
					}
					else
					{
						int size = (int)(sqlite3Atoi(zRight));
						pDb.pSchema.cache_size = (int)(size);
						sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
					}

					break;
				}

			case 7:
				{
					if (zRight == null)
					{
						returnSingleInt(v, (long)((db.flags & 0x00000020) == (0) ? 0 : sqlite3BtreeSetSpillSize(pDb.pBt, (int)(0))));
					}
					else
					{
						int size = (int)(1);
						if ((sqlite3GetInt32(zRight, &size)) != 0)
						{
							sqlite3BtreeSetSpillSize(pDb.pBt, (int)(size));
						}

						if ((sqlite3GetBoolean(zRight, (byte)(size != 0))) != 0)
						{
							db.flags |= (ulong)(0x00000020);
						}
						else
						{
							db.flags &= (ulong)(~(ulong)(0x00000020));
						}

						setAllPagerFlags(db);
					}

					break;
				}

			case 28:
				{
					long sz = 0;
					if ((zRight) != null)
					{
						int ii = 0;
						sqlite3DecOrHexToI64(zRight, &sz);
						if ((sz) < (0))
							sz = (long)(sqlite3Config.szMmap);
						if ((pId2->n) == (0))
							db.szMmap = (long)(sz);
						for (ii = (int)(db.nDb - 1); (ii) >= (0); ii--)
						{
							if (((db.aDb[ii].pBt) != null) && (((ii) == (iDb)) || ((pId2->n) == (0))))
							{
								sqlite3BtreeSetMmapLimit(db.aDb[ii].pBt, (long)(sz));
							}
						}
					}

					sz = (long)(-1);
					rc = (int)(sqlite3_file_control(db, zDb, (int)(18), &sz));
					if ((rc) == (0))
					{
						returnSingleInt(v, (long)(sz));
					}
					else if (rc != 12)
					{
						pParse.nErr++;
						pParse.rc = (int)(rc);
					}

					break;
				}

			case 39:
				{
					if (zRight == null)
					{
						returnSingleInt(v, (long)(db.temp_store));
					}
					else
					{
						changeTempStorage(pParse, zRight);
					}

					break;
				}

			case 40:
				{
					if (zRight == null)
					{
						returnSingleText(v, sqlite3_temp_directory);
					}
					else
					{
						if ((zRight[0]) != 0)
						{
							int res = 0;
							rc = (int)(sqlite3OsAccess(db.pVfs, zRight, (int)(1), &res));
							if ((rc != 0) || ((res) == (0)))
							{
								sqlite3ErrorMsg(pParse, "not a writable directory");
								goto pragma_out;
							}
						}

						if ((((1) == (0)) || (((1) == (1)) && ((db.temp_store) <= (1)))) || (((1) == (2)) && ((db.temp_store) == (1))))
						{
							invalidateTempStorage(pParse);
						}

						sqlite3_free(sqlite3_temp_directory);
						if ((zRight[0]) != 0)
						{
							sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
						}
						else
						{
							sqlite3_temp_directory = null;
						}
					}

					break;
				}

			case 11:
				{
					if (zRight == null)
					{
						returnSingleText(v, sqlite3_data_directory);
					}
					else
					{
						if ((zRight[0]) != 0)
						{
							int res = 0;
							rc = (int)(sqlite3OsAccess(db.pVfs, zRight, (int)(1), &res));
							if ((rc != 0) || ((res) == (0)))
							{
								sqlite3ErrorMsg(pParse, "not a writable directory");
								goto pragma_out;
							}
						}

						sqlite3_free(sqlite3_data_directory);
						if ((zRight[0]) != 0)
						{
							sqlite3_data_directory = sqlite3_mprintf("%s", zRight);
						}
						else
						{
							sqlite3_data_directory = null;
						}
					}

					break;
				}

			case 36:
				{
					if (zRight == null)
					{
						returnSingleInt(v, (long)(pDb.safety_level - 1));
					}
					else
					{
						if (db.autoCommit == 0)
						{
							sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction");
						}
						else if (iDb != 1)
						{
							int iLevel = (int)((getSafetyLevel(zRight, (int)(0), (byte)(1)) + 1) & 0x07);
							if ((iLevel) == (0))
								iLevel = (int)(1);
							pDb.safety_level = (byte)(iLevel);
							pDb.bSyncSet = (byte)(1);
							setAllPagerFlags(db);
						}
					}

					break;
				}

			case 4:
				{
					if ((zRight) == (null))
					{
						setPragmaResultColumnNames(v, pPragma);
						returnSingleInt(v, (long)((db.flags & pPragma->iArg) != 0));
					}
					else
					{
						ulong mask = (ulong)(pPragma->iArg);
						if ((db.autoCommit) == (0))
						{
							mask &= (ulong)(~(0x00004000));
						}

						if ((sqlite3GetBoolean(zRight, (byte)(0))) != 0)
						{
							db.flags |= (ulong)(mask);
						}
						else
						{
							db.flags &= (ulong)(~mask);
							if ((mask) == (0x00080000))
								db.nDeferredImmCons = (long)(0);
							if (((mask & 0x00000001) != 0) && ((sqlite3_stricmp(zRight, "reset")) == (0)))
							{
								sqlite3ResetAllSchemasOfConnection(db);
							}
						}

						sqlite3VdbeAddOp0(v, (int)(165));
						setAllPagerFlags(db);
					}

					break;
				}

			case 37:
				if ((zRight) != null)
				{
					Table pTab;
					sqlite3CodeVerifyNamedSchema(pParse, zDb);
					pTab = sqlite3LocateTable(pParse, (uint)(0x02), zRight, zDb);
					if ((pTab) != null)
					{
						int i = 0;
						int k = 0;
						int nHidden = (int)(0);
						Column* pCol;
						Index pPk = sqlite3PrimaryKeyIndex(pTab);
						pParse.nMem = (int)(7);
						sqlite3ViewGetColumnNames(pParse, pTab);
						for (i = (int)(0), pCol = pTab.aCol; (i) < (pTab.nCol); i++, pCol++)
						{
							int isHidden = (int)(0);
							Expr pColExpr;
							if ((pCol->colFlags & 0x0062) != 0)
							{
								if ((pPragma->iArg) == (0))
								{
									nHidden++;
									continue;
								}

								if ((pCol->colFlags & 0x0020) != 0)
								{
									isHidden = (int)(2);
								}
								else if ((pCol->colFlags & 0x0040) != 0)
								{
									isHidden = (int)(3);
								}
								else
								{
									isHidden = (int)(1);
								}
							}

							if ((pCol->colFlags & 0x0001) == (0))
							{
								k = (int)(0);
							}
							else if ((pPk) == (null))
							{
								k = (int)(1);
							}
							else
							{
								for (k = (int)(1); ((k) <= (pTab.nCol)) && (pPk.aiColumn[k - 1] != i); k++)
								{
								}
							}

							pColExpr = sqlite3ColumnExpr(pTab, pCol);
							sqlite3VdbeMultiLoad(v, (int)(1), (pPragma->iArg) != 0 ? "issisii" : "issisi", (int)(i - nHidden), pCol->zCnName, sqlite3ColumnType(pCol, ""), (int)((pCol->notNull) != 0 ? 1 : 0), (((isHidden) >= (2)) || ((pColExpr) == (null))) ? null : pColExpr.u.zToken, (int)(k), (int)(isHidden));
						}
					}
				}

				break;
			case 38:
				{
					int ii = 0;
					pParse.nMem = (int)(6);
					sqlite3CodeVerifyNamedSchema(pParse, zDb);
					for (ii = (int)(0); (ii) < (db.nDb); ii++)
					{
						HashElem* k;
						Hash* pHash;
						int initNCol = 0;
						if (((zDb) != null) && (sqlite3_stricmp(zDb, db.aDb[ii].zDbSName) != 0))
							continue;
						pHash = &db.aDb[ii].pSchema.tblHash;
						initNCol = (int)((pHash)->count);
						while ((initNCol--) != 0)
						{
							for (k = ((pHash)->first); 1; k = ((k)->next))
							{
								Table pTab;
								if ((k) == (null))
								{
									initNCol = (int)(0);
									break;
								}

								pTab = ((k)->data);
								if ((pTab.nCol) == (0))
								{
									sbyte* zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\"", pTab.zName);
									if ((zSql) != null)
									{
										sqlite3_stmt* pDummy = null;
										(void)(sqlite3_prepare(db, zSql, (int)(-1), &pDummy, null));
										(void)(sqlite3_finalize(pDummy));
										sqlite3DbFree(db, zSql);
									}

									if ((db.mallocFailed) != 0)
									{
										sqlite3ErrorMsg(db.pParse, "out of memory");
										db.pParse.rc = (int)(7);
									}

									pHash = &db.aDb[ii].pSchema.tblHash;
									break;
								}
							}
						}

						for (k = ((pHash)->first); k; k = ((k)->next))
						{
							Table pTab = ((k)->data);
							sbyte* zType;
							if (((zRight) != null) && (sqlite3_stricmp(zRight, pTab.zName) != 0))
								continue;
							if ((((pTab).eTabType) == (2)))
							{
								zType = "view";
							}
							else if ((((pTab).eTabType) == (1)))
							{
								zType = "virtual";
							}
							else if ((pTab.tabFlags & 0x00001000) != 0)
							{
								zType = "shadow";
							}
							else
							{
								zType = "table";
							}

							sqlite3VdbeMultiLoad(v, (int)(1), "sssiii", db.aDb[ii].zDbSName, sqlite3PreferredTableName(pTab.zName), zType, (int)(pTab.nCol), (int)((pTab.tabFlags & 0x00000080) != 0), (int)((pTab.tabFlags & 0x00010000) != 0));
						}
					}
				}

				break;
			case 20:
				if ((zRight) != null)
				{
					Index pIdx;
					Table pTab;
					pIdx = sqlite3FindIndex(db, zRight, zDb);
					if ((pIdx) == (null))
					{
						pTab = sqlite3LocateTable(pParse, (uint)(0x02), zRight, zDb);
						if (((pTab) != null) && (!(((pTab).tabFlags & 0x00000080) == (0))))
						{
							pIdx = sqlite3PrimaryKeyIndex(pTab);
						}
					}

					if ((pIdx) != null)
					{
						int iIdxDb = (int)(sqlite3SchemaToIndex(db, pIdx.pSchema));
						int i = 0;
						int mx = 0;
						if ((pPragma->iArg) != 0)
						{
							mx = (int)(pIdx.nColumn);
							pParse.nMem = (int)(6);
						}
						else
						{
							mx = (int)(pIdx.nKeyCol);
							pParse.nMem = (int)(3);
						}

						pTab = pIdx.pTable;
						sqlite3CodeVerifySchema(pParse, (int)(iIdxDb));
						for (i = (int)(0); (i) < (mx); i++)
						{
							short cnum = (short)(pIdx.aiColumn[i]);
							sqlite3VdbeMultiLoad(v, (int)(1), "iisX", (int)(i), (int)(cnum), (cnum) < (0) ? null : pTab.aCol[cnum].zCnName);
							if ((pPragma->iArg) != 0)
							{
								sqlite3VdbeMultiLoad(v, (int)(4), "isiX", (int)(pIdx.aSortOrder[i]), pIdx.azColl[i], ((i) < (pIdx.nKeyCol) ? 1 : 0));
							}

							sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(pParse.nMem));
						}
					}
				}

				break;
			case 21:
				if ((zRight) != null)
				{
					Index pIdx;
					Table pTab;
					int i = 0;
					pTab = sqlite3FindTable(db, zRight, zDb);
					if ((pTab) != null)
					{
						int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
						pParse.nMem = (int)(5);
						sqlite3CodeVerifySchema(pParse, (int)(iTabDb));
						for (pIdx = pTab.pIndex, i = (int)(0); pIdx; pIdx = pIdx.pNext, i++)
						{
							sbyte** azOrigin = stackalloc sbyte*[] { "c", "u", "pk" };
							sqlite3VdbeMultiLoad(v, (int)(1), "isisi", (int)(i), pIdx.zName, (int)((pIdx).onError != 0), azOrigin[pIdx.idxType], (int)(pIdx.pPartIdxWhere != null));
						}
					}
				}

				break;
			case 12:
				{
					int i = 0;
					pParse.nMem = (int)(3);
					for (i = (int)(0); (i) < (db.nDb); i++)
					{
						if ((db.aDb[i].pBt) == (null))
							continue;
						sqlite3VdbeMultiLoad(v, (int)(1), "iss", (int)(i), db.aDb[i].zDbSName, sqlite3BtreeGetFilename(db.aDb[i].pBt));
					}
				}

				break;
			case 9:
				{
					int i = (int)(0);
					HashElem* p;
					pParse.nMem = (int)(2);
					for (p = ((&db.aCollSeq)->first); p; p = ((p)->next))
					{
						CollSeq pColl = (CollSeq)((p)->data);
						sqlite3VdbeMultiLoad(v, (int)(1), "is", (int)(i++), pColl.zName);
					}
				}

				break;
			case 17:
				{
					int i = 0;
					HashElem* j;
					FuncDef p;
					int showInternFunc = (int)((db.mDbFlags & 0x0020) != 0);
					pParse.nMem = (int)(6);
					for (i = (int)(0); (i) < (23); i++)
					{
						for (p = sqlite3BuiltinFunctions.a[i]; p; p = p.u.pHash)
						{
							pragmaFunclistLine(v, p, (int)(1), (int)(showInternFunc));
						}
					}

					for (j = ((&db.aFunc)->first); j; j = ((j)->next))
					{
						p = (FuncDef)((j)->data);
						pragmaFunclistLine(v, p, (int)(0), (int)(showInternFunc));
					}
				}

				break;
			case 29:
				{
					HashElem* j;
					pParse.nMem = (int)(1);
					for (j = ((&db.aModule)->first); j; j = ((j)->next))
					{
						Module pMod = (Module)((j)->data);
						sqlite3VdbeMultiLoad(v, (int)(1), "s", pMod.zName);
					}
				}

				break;
			case 32:
				{
					int i = 0;
					for (i = (int)(0); (i) < ((int)(67 * sizeof(PragmaName) / sizeof(PragmaName))); i++)
					{
						sqlite3VdbeMultiLoad(v, (int)(1), "s", aPragmaName[i].zName);
					}
				}

				break;
			case 16:
				if ((zRight) != null)
				{
					FKey pFK;
					Table pTab;
					pTab = sqlite3FindTable(db, zRight, zDb);
					if (((pTab) != null) && (((pTab).eTabType) == (0)))
					{
						pFK = pTab.u.tab.pFKey;
						if ((pFK) != null)
						{
							int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
							int i = (int)(0);
							pParse.nMem = (int)(8);
							sqlite3CodeVerifySchema(pParse, (int)(iTabDb));
							while ((pFK) != null)
							{
								int j = 0;
								for (j = (int)(0); (j) < (pFK.nCol); j++)
								{
									sqlite3VdbeMultiLoad(v, (int)(1), "iissssss", (int)(i), (int)(j), pFK.zTo, pTab.aCol[pFK.aCol[j].iFrom].zCnName, pFK.aCol[j].zCol, actionName((byte)(pFK.aAction[1])), actionName((byte)(pFK.aAction[0])), "NONE");
								}

								++i;
								pFK = pFK.pNextFrom;
							}
						}
					}
				}

				break;
			case 15:
				{
					FKey pFK;
					Table pTab;
					Table pParent;
					Index pIdx;
					int i = 0;
					int j = 0;
					HashElem* k;
					int x = 0;
					int regResult = 0;
					int regKey = 0;
					int regRow = 0;
					int addrTop = 0;
					int addrOk = 0;
					int* aiCols;
					regResult = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(4);
					regKey = (int)(++pParse.nMem);
					regRow = (int)(++pParse.nMem);
					k = ((&db.aDb[iDb].pSchema.tblHash)->first);
					while ((k) != null)
					{
						if ((zRight) != null)
						{
							pTab = sqlite3LocateTable(pParse, (uint)(0), zRight, zDb);
							k = null;
						}
						else
						{
							pTab = (Table)((k)->data);
							k = ((k)->next);
						}

						if ((((pTab) == (null)) || (!(((pTab).eTabType) == (0)))) || ((pTab.u.tab.pFKey) == (null)))
							continue;
						iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
						zDb = db.aDb[iDb].zDbSName;
						sqlite3CodeVerifySchema(pParse, (int)(iDb));
						sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
						if ((pTab.nCol + regRow) > (pParse.nMem))
							pParse.nMem = (int)(pTab.nCol + regRow);
						sqlite3OpenTable(pParse, (int)(0), (int)(iDb), pTab, (int)(101));
						sqlite3VdbeLoadString(v, (int)(regResult), pTab.zName);
						for (i = (int)(1), pFK = pTab.u.tab.pFKey; pFK; i++, pFK = pFK.pNextFrom)
						{
							pParent = sqlite3FindTable(db, pFK.zTo, zDb);
							if ((pParent) == (null))
								continue;
							pIdx = null;
							sqlite3TableLock(pParse, (int)(iDb), (uint)(pParent.tnum), (byte)(0), pParent.zName);
							x = (int)(sqlite3FkLocateIndex(pParse, pParent, pFK, pIdx, null));
							if ((x) == (0))
							{
								if ((pIdx) == (null))
								{
									sqlite3OpenTable(pParse, (int)(i), (int)(iDb), pParent, (int)(101));
								}
								else
								{
									sqlite3VdbeAddOp3(v, (int)(101), (int)(i), (int)(pIdx.tnum), (int)(iDb));
									sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
								}
							}
							else
							{
								k = null;
								break;
							}
						}

						if ((pFK) != null)
							break;
						if ((pParse.nTab) < (i))
							pParse.nTab = (int)(i);
						addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(0)));
						for (i = (int)(1), pFK = pTab.u.tab.pFKey; pFK; i++, pFK = pFK.pNextFrom)
						{
							pParent = sqlite3FindTable(db, pFK.zTo, zDb);
							pIdx = null;
							aiCols = null;
							if ((pParent) != null)
							{
								x = (int)(sqlite3FkLocateIndex(pParse, pParent, pFK, pIdx, &aiCols));
							}

							addrOk = (int)(sqlite3VdbeMakeLabel(pParse));
							if ((regRow + pFK.nCol) > (pParse.nMem))
								pParse.nMem = (int)(regRow + pFK.nCol);
							for (j = (int)(0); (j) < (pFK.nCol); j++)
							{
								int iCol = (int)((aiCols) != 0 ? aiCols[j] : pFK.aCol[j].iFrom);
								sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(0), (int)(iCol), (int)(regRow + j));
								sqlite3VdbeAddOp2(v, (int)(50), (int)(regRow + j), (int)(addrOk));
							}

							if ((pIdx) != null)
							{
								sqlite3VdbeAddOp4(v, (int)(96), (int)(regRow), (int)(pFK.nCol), (int)(regKey), sqlite3IndexAffinityStr(db, pIdx), (int)(pFK.nCol));
								sqlite3VdbeAddOp4Int(v, (int)(31), (int)(i), (int)(addrOk), (int)(regKey), (int)(0));
							}
							else if ((pParent) != null)
							{
								int jmp = (int)(sqlite3VdbeCurrentAddr(v) + 2);
								sqlite3VdbeAddOp3(v, (int)(32), (int)(i), (int)(jmp), (int)(regRow));
								sqlite3VdbeGoto(v, (int)(addrOk));
							}

							if ((((pTab).tabFlags & 0x00000080) == (0)))
							{
								sqlite3VdbeAddOp2(v, (int)(134), (int)(0), (int)(regResult + 1));
							}
							else
							{
								sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regResult + 1));
							}

							sqlite3VdbeMultiLoad(v, (int)(regResult + 2), "siX", pFK.zTo, (int)(i - 1));
							sqlite3VdbeAddOp2(v, (int)(83), (int)(regResult), (int)(4));
							sqlite3VdbeResolveLabel(v, (int)(addrOk));
							sqlite3DbFree(db, aiCols);
						}

						sqlite3VdbeAddOp2(v, (int)(5), (int)(0), (int)(addrTop + 1));
						sqlite3VdbeJumpHere(v, (int)(addrTop));
					}
				}

				break;
			case 8:
				{
					if ((zRight) != null)
					{
						sqlite3RegisterLikeFunctions(db, (int)(sqlite3GetBoolean(zRight, (byte)(0))));
					}
				}

				break;
			case 22:
				{
					int i = 0;
					int j = 0;
					int addr = 0;
					int mxErr = 0;
					Table pObjTab = null;
					int isQuick = (int)(((sqlite3UpperToLower[(byte)(zLeft[0])]) == (113)) ? 1 : 0);
					if ((pId2->z) == (null))
						iDb = (int)(-1);
					pParse.nMem = (int)(6);
					mxErr = (int)(100);
					if ((zRight) != null)
					{
						if ((sqlite3GetInt32(zRight, &mxErr)) != 0)
						{
							if ((mxErr) <= (0))
							{
								mxErr = (int)(100);
							}
						}
						else
						{
							pObjTab = sqlite3LocateTable(pParse, (uint)(0), zRight, (iDb) >= (0) ? db.aDb[iDb].zDbSName : null);
						}
					}

					sqlite3VdbeAddOp2(v, (int)(71), (int)(mxErr - 1), (int)(1));
					for (i = (int)(0); (i) < (db.nDb); i++)
					{
						HashElem* x;
						Hash* pTbls;
						int* aRoot;
						int cnt = (int)(0);
						int mxIdx = (int)(0);
						if (((0) != 0) && ((i) == (1)))
							continue;
						if (((iDb) >= (0)) && (i != iDb))
							continue;
						sqlite3CodeVerifySchema(pParse, (int)(i));
						pTbls = &db.aDb[i].pSchema.tblHash;
						for (cnt = (int)(0), x = ((pTbls)->first); x; x = ((x)->next))
						{
							Table pTab = ((x)->data);
							Index pIdx;
							int nIdx = 0;
							if (((pObjTab) != null) && (pObjTab != pTab))
								continue;
							if ((((pTab).tabFlags & 0x00000080) == (0)))
								cnt++;
							for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
							{
								cnt++;
							}

							if ((nIdx) > (mxIdx))
								mxIdx = (int)(nIdx);
						}

						if ((cnt) == (0))
							continue;
						if ((pObjTab) != null)
							cnt++;
						aRoot = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (cnt + 1)));
						if ((aRoot) == (null))
							break;
						cnt = (int)(0);
						if ((pObjTab) != null)
							aRoot[++cnt] = (int)(0);
						for (x = ((pTbls)->first); x; x = ((x)->next))
						{
							Table pTab = ((x)->data);
							Index pIdx;
							if (((pObjTab) != null) && (pObjTab != pTab))
								continue;
							if ((((pTab).tabFlags & 0x00000080) == (0)))
								aRoot[++cnt] = (int)(pTab.tnum);
							for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
							{
								aRoot[++cnt] = (int)(pIdx.tnum);
							}
						}

						aRoot[0] = (int)(cnt);
						pParse.nMem = (int)((pParse.nMem) > (8 + mxIdx) ? (pParse.nMem) : (8 + mxIdx));
						sqlite3ClearTempRegCache(pParse);
						sqlite3VdbeAddOp4(v, (int)(154), (int)(2), (int)(cnt), (int)(1), (sbyte*)(aRoot), (int)(-15));
						sqlite3VdbeChangeP5(v, (ushort)((byte)(i)));
						addr = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(2)));
						sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), sqlite3MPrintf(db, "*** in database %s ***\n", db.aDb[i].zDbSName), (int)(-7));
						sqlite3VdbeAddOp3(v, (int)(111), (int)(2), (int)(3), (int)(3));
						integrityCheckResultRow(v);
						sqlite3VdbeJumpHere(v, (int)(addr));
						for (x = ((pTbls)->first); x; x = ((x)->next))
						{
							Table pTab = ((x)->data);
							Index pIdx;
							Index pPk;
							Index pPrior = null;
							int loopTop = 0;
							int iDataCur = 0;
							int iIdxCur = 0;
							int r1 = (int)(-1);
							int bStrict = 0;
							if (!(((pTab).eTabType) == (0)))
								continue;
							if (((pObjTab) != null) && (pObjTab != pTab))
								continue;
							pPk = (((pTab).tabFlags & 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
							sqlite3OpenTableAndIndices(pParse, pTab, (int)(101), (byte)(0), (int)(1), null, &iDataCur, &iIdxCur);
							sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(7));
							for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
							{
								sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(8 + j));
							}

							sqlite3VdbeAddOp2(v, (int)(38), (int)(iDataCur), (int)(0));
							loopTop = (int)(sqlite3VdbeAddOp2(v, (int)(85), (int)(7), (int)(1)));
							if (isQuick == 0)
							{
								sqlite3VdbeAddOp3(v, (int)(93), (int)(iDataCur), (int)(pTab.nNVCol - 1), (int)(3));
								sqlite3VdbeChangeP5(v, (ushort)(0x80));
							}

							bStrict = (int)((pTab.tabFlags & 0x00010000) != 0);
							for (j = (int)(0); (j) < (pTab.nCol); j++)
							{
								sbyte* zErr;
								Column* pCol = pTab.aCol + j;
								int doError = 0;
								int jmp2 = 0;
								if ((j) == (pTab.iPKey))
									continue;
								if (((pCol->notNull) == (0)) && (bStrict == 0))
									continue;
								doError = (int)((bStrict) != 0 ? sqlite3VdbeMakeLabel(pParse) : 0);
								sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(j), (int)(3));
								if ((sqlite3VdbeGetOp(v, (int)(-1))->opcode) == (93))
								{
									sqlite3VdbeChangeP5(v, (ushort)(0x80));
								}

								if ((pCol->notNull) != 0)
								{
									jmp2 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(3)));
									zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab.zName, pCol->zCnName);
									sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
									if (((bStrict) != 0) && (pCol->eCType != 1))
									{
										sqlite3VdbeGoto(v, (int)(doError));
									}
									else
									{
										integrityCheckResultRow(v);
									}

									sqlite3VdbeJumpHere(v, (int)(jmp2));
								}

								if (((pTab.tabFlags & 0x00010000) != 0) && (pCol->eCType != 1))
								{
									jmp2 = (int)(sqlite3VdbeAddOp3(v, (int)(21), (int)(3), (int)(0), (int)(sqlite3StdTypeMap[pCol->eCType - 1])));
									zErr = sqlite3MPrintf(db, "non-%s value in %s.%s", sqlite3StdType[pCol->eCType - 1], pTab.zName, pTab.aCol[j].zCnName);
									sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
									sqlite3VdbeResolveLabel(v, (int)(doError));
									integrityCheckResultRow(v);
									sqlite3VdbeJumpHere(v, (int)(jmp2));
								}
							}

							if (((pTab.pCheck) != null) && ((db.flags & 0x00000200) == (0)))
							{
								ExprList pCheck = sqlite3ExprListDup(db, pTab.pCheck, (int)(0));
								if ((db.mallocFailed) == (0))
								{
									int addrCkFault = (int)(sqlite3VdbeMakeLabel(pParse));
									int addrCkOk = (int)(sqlite3VdbeMakeLabel(pParse));
									sbyte* zErr;
									int k = 0;
									pParse.iSelfTab = (int)(iDataCur + 1);
									for (k = (int)(pCheck.nExpr - 1); (k) > (0); k--)
									{
										sqlite3ExprIfFalse(pParse, pCheck.a[k].pExpr, (int)(addrCkFault), (int)(0));
									}

									sqlite3ExprIfTrue(pParse, pCheck.a[0].pExpr, (int)(addrCkOk), (int)(0x10));
									sqlite3VdbeResolveLabel(v, (int)(addrCkFault));
									pParse.iSelfTab = (int)(0);
									zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s", pTab.zName);
									sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
									integrityCheckResultRow(v);
									sqlite3VdbeResolveLabel(v, (int)(addrCkOk));
								}

								sqlite3ExprListDelete(db, pCheck);
							}

							if (isQuick == 0)
							{
								for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
								{
									int jmp2 = 0;
									int jmp3 = 0;
									int jmp4 = 0;
									int jmp5 = 0;
									int ckUniq = (int)(sqlite3VdbeMakeLabel(pParse));
									if ((pPk) == (pIdx))
										continue;
									r1 = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(iDataCur), (int)(0), (int)(0), &jmp3, pPrior, (int)(r1)));
									pPrior = pIdx;
									sqlite3VdbeAddOp2(v, (int)(85), (int)(8 + j), (int)(1));
									jmp2 = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iIdxCur + j), (int)(ckUniq), (int)(r1), (int)(pIdx.nColumn)));
									sqlite3VdbeLoadString(v, (int)(3), "row ");
									sqlite3VdbeAddOp3(v, (int)(111), (int)(7), (int)(3), (int)(3));
									sqlite3VdbeLoadString(v, (int)(4), " missing from index ");
									sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(3), (int)(3));
									jmp5 = (int)(sqlite3VdbeLoadString(v, (int)(4), pIdx.zName));
									sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(3), (int)(3));
									jmp4 = (int)(integrityCheckResultRow(v));
									sqlite3VdbeJumpHere(v, (int)(jmp2));
									if (((pIdx).onError != 0))
									{
										int uniqOk = (int)(sqlite3VdbeMakeLabel(pParse));
										int jmp6 = 0;
										int kk = 0;
										for (kk = (int)(0); (kk) < (pIdx.nKeyCol); kk++)
										{
											int iCol = (int)(pIdx.aiColumn[kk]);
											if (((iCol) >= (0)) && ((pTab.aCol[iCol].notNull) != 0))
												continue;
											sqlite3VdbeAddOp2(v, (int)(50), (int)(r1 + kk), (int)(uniqOk));
										}

										jmp6 = (int)(sqlite3VdbeAddOp1(v, (int)(5), (int)(iIdxCur + j)));
										sqlite3VdbeGoto(v, (int)(uniqOk));
										sqlite3VdbeJumpHere(v, (int)(jmp6));
										sqlite3VdbeAddOp4Int(v, (int)(40), (int)(iIdxCur + j), (int)(uniqOk), (int)(r1), (int)(pIdx.nKeyCol));
										sqlite3VdbeLoadString(v, (int)(3), "non-unique entry in index ");
										sqlite3VdbeGoto(v, (int)(jmp5));
										sqlite3VdbeResolveLabel(v, (int)(uniqOk));
									}

									sqlite3VdbeJumpHere(v, (int)(jmp4));
									sqlite3ResolvePartIdxLabel(pParse, (int)(jmp3));
								}
							}

							sqlite3VdbeAddOp2(v, (int)(5), (int)(iDataCur), (int)(loopTop));
							sqlite3VdbeJumpHere(v, (int)(loopTop - 1));
							if (isQuick == 0)
							{
								sqlite3VdbeLoadString(v, (int)(2), "wrong # of entries in index ");
								for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
								{
									if ((pPk) == (pIdx))
										continue;
									sqlite3VdbeAddOp2(v, (int)(97), (int)(iIdxCur + j), (int)(3));
									addr = (int)(sqlite3VdbeAddOp3(v, (int)(53), (int)(8 + j), (int)(0), (int)(3)));
									sqlite3VdbeChangeP5(v, (ushort)(0x90));
									sqlite3VdbeLoadString(v, (int)(4), pIdx.zName);
									sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(2), (int)(3));
									integrityCheckResultRow(v);
									sqlite3VdbeJumpHere(v, (int)(addr));
								}
							}
						}
					}

					{
						VdbeOp* aOp;
						aOp = sqlite3VdbeAddOpList(v, ((int)(7 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_endCode, (int)(sqlite3Pragma_iLn));
						if ((aOp) != null)
						{
							aOp[0].p2 = (int)(1 - mxErr);
							aOp[2].p4type = (sbyte)(-1);
							aOp[2].p4.z = "ok";
							aOp[5].p4type = (sbyte)(-1);
							aOp[5].p4.z = sqlite3ErrStr((int)(11));
						}

						sqlite3VdbeChangeP3(v, (int)(0), (int)(sqlite3VdbeCurrentAddr(v) - 2));
					}
				}

				break;
			case 14:
				{
					EncName* pEnc;
					if (zRight == null)
					{
						if ((sqlite3ReadSchema(pParse)) != 0)
							goto pragma_out;
						returnSingleText(v, sqlite3Pragma_encnames[((pParse.db).enc)].zName);
					}
					else
					{
						if ((db.mDbFlags & 0x0040) == (0))
						{
							for (pEnc = &sqlite3Pragma_encnames[0]; pEnc->zName; pEnc++)
							{
								if ((0) == (sqlite3StrICmp(zRight, pEnc->zName)))
								{
									byte enc = (byte)((pEnc->enc) != 0 ? pEnc->enc : 2);
									((db).aDb[0].pSchema.enc) = (byte)(enc);
									sqlite3SetTextEncoding(db, (byte)(enc));
									break;
								}
							}

							if (pEnc->zName == null)
							{
								sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
							}
						}
					}
				}

				break;
			case 2:
				{
					int iCookie = (int)(pPragma->iArg);
					sqlite3VdbeUsesBtree(v, (int)(iDb));
					if (((zRight) != null) && ((pPragma->mPragFlg & 0x08) == (0)))
					{
						VdbeOp* aOp;
						aOp = sqlite3VdbeAddOpList(v, ((int)(2 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_setCookie, (int)(0));
						if ((0) != 0)
							break;
						aOp[0].p1 = (int)(iDb);
						aOp[1].p1 = (int)(iDb);
						aOp[1].p2 = (int)(iCookie);
						aOp[1].p3 = (int)(sqlite3Atoi(zRight));
						aOp[1].p5 = (ushort)(1);
					}
					else
					{
						VdbeOp* aOp;
						aOp = sqlite3VdbeAddOpList(v, ((int)(3 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_readCookie, (int)(0));
						if ((0) != 0)
							break;
						aOp[0].p1 = (int)(iDb);
						aOp[1].p1 = (int)(iDb);
						aOp[1].p3 = (int)(iCookie);
						sqlite3VdbeReusable(v);
					}
				}

				break;
			case 10:
				{
					int i = (int)(0);
					sbyte* zOpt;
					pParse.nMem = (int)(1);
					while ((zOpt = sqlite3_compileoption_get((int)(i++))) != null)
					{
						sqlite3VdbeLoadString(v, (int)(1), zOpt);
						sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
					}

					sqlite3VdbeReusable(v);
				}

				break;
			case 43:
				{
					int iBt = (int)((pId2->z) != 0 ? iDb : (10 + 2));
					int eMode = (int)(0);
					if ((zRight) != null)
					{
						if ((sqlite3StrICmp(zRight, "full")) == (0))
						{
							eMode = (int)(1);
						}
						else if ((sqlite3StrICmp(zRight, "restart")) == (0))
						{
							eMode = (int)(2);
						}
						else if ((sqlite3StrICmp(zRight, "truncate")) == (0))
						{
							eMode = (int)(3);
						}
					}

					pParse.nMem = (int)(3);
					sqlite3VdbeAddOp3(v, (int)(6), (int)(iBt), (int)(eMode), (int)(1));
					sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(3));
				}

				break;
			case 42:
				{
					if ((zRight) != null)
					{
						sqlite3_wal_autocheckpoint(db, (int)(sqlite3Atoi(zRight)));
					}

					returnSingleInt(v, (long)((db.xWalCallback) == (sqlite3WalDefaultHook) ? ((int)((long)(db.pWalArg))) : 0));
				}

				break;
			case 34:
				{
					sqlite3_db_release_memory(db);
					break;
				}

			case 30:
				{
					int iDbLast = 0;
					int iTabCur = 0;
					HashElem* k;
					Schema pSchema;
					Table pTab;
					Index pIdx;
					short szThreshold = 0;
					sbyte* zSubSql;
					uint opMask = 0;
					if ((zRight) != null)
					{
						opMask = ((uint)(sqlite3Atoi(zRight)));
						if ((opMask & 0x02) == (0))
							break;
					}
					else
					{
						opMask = (uint)(0xfffe);
					}

					iTabCur = (int)(pParse.nTab++);
					for (iDbLast = (int)((zDb) != 0 ? iDb : db.nDb - 1); (iDb) <= (iDbLast); iDb++)
					{
						if ((iDb) == (1))
							continue;
						sqlite3CodeVerifySchema(pParse, (int)(iDb));
						pSchema = db.aDb[iDb].pSchema;
						for (k = ((&pSchema.tblHash)->first); k; k = ((k)->next))
						{
							pTab = (Table)((k)->data);
							if ((pTab.tabFlags & 0x00000100) == (0))
								continue;
							szThreshold = (short)(pTab.nRowLogEst + 46);
							for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
							{
								if (pIdx.hasStat1 == 0)
								{
									szThreshold = (short)(0);
									break;
								}
							}

							if ((szThreshold) != 0)
							{
								sqlite3OpenTable(pParse, (int)(iTabCur), (int)(iDb), pTab, (int)(101));
								sqlite3VdbeAddOp3(v, (int)(35), (int)(iTabCur), (int)(sqlite3VdbeCurrentAddr(v) + 2 + (opMask & 1)), (int)(szThreshold));
							}

							zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"", db.aDb[iDb].zDbSName, pTab.zName);
							if ((opMask & 0x01) != 0)
							{
								int r1 = (int)(sqlite3GetTempReg(pParse));
								sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(r1), (int)(0), zSubSql, (int)(-7));
								sqlite3VdbeAddOp2(v, (int)(83), (int)(r1), (int)(1));
							}
							else
							{
								sqlite3VdbeAddOp4(v, (int)(147), (int)(0), (int)(0), (int)(0), zSubSql, (int)(-7));
							}
						}
					}

					sqlite3VdbeAddOp0(v, (int)(165));
					break;
				}

			default:
				{
					if ((zRight) != null)
					{
						sqlite3_busy_timeout(db, (int)(sqlite3Atoi(zRight)));
					}

					returnSingleInt(v, (long)(db.busyTimeout));
					break;
				}

			case 35:
				{
					long N = 0;
					if (((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0)))
					{
						sqlite3_soft_heap_limit64((long)(N));
					}

					returnSingleInt(v, (long)(sqlite3_soft_heap_limit64((long)(-1))));
					break;
				}

			case 18:
				{
					long N = 0;
					if (((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0)))
					{
						long iPrior = (long)(sqlite3_hard_heap_limit64((long)(-1)));
						if (((N) > (0)) && (((iPrior) == (0)) || ((iPrior) > (N))))
							sqlite3_hard_heap_limit64((long)(N));
					}

					returnSingleInt(v, (long)(sqlite3_hard_heap_limit64((long)(-1))));
					break;
				}

			case 41:
				{
					long N = 0;
					if ((((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0))) && ((N) >= (0)))
					{
						sqlite3_limit(db, (int)(11), (int)(N & 0x7fffffff));
					}

					returnSingleInt(v, (long)(sqlite3_limit(db, (int)(11), (int)(-1))));
					break;
				}

			case 1:
				{
					long N = 0;
					if ((((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0))) && ((N) >= (0)))
					{
						db.nAnalysisLimit = ((int)(N & 0x7fffffff));
					}

					returnSingleInt(v, (long)(db.nAnalysisLimit));
					break;
				}
		}

		if (((pPragma->mPragFlg & 0x04) != 0) && ((zRight) != null))
		{
		}

	pragma_out:
		; sqlite3DbFree(db, zLeft);
		sqlite3DbFree(db, zRight);
	}
	public static int sqlite3ReadSchema(Parse pParse)
	{
		int rc = (int)(0);
		sqlite3 db = pParse.db;
		if (db.init.busy == 0)
		{
			rc = (int)(sqlite3Init(db, &pParse.zErrMsg));
			if (rc != 0)
			{
				pParse.rc = (int)(rc);
				pParse.nErr++;
			}
			else if ((db.noSharedCache) != 0)
			{
				db.mDbFlags |= (uint)(0x0010);
			}
		}

		return (int)(rc);
	}
	public static int sqlite3ReferencesSrcList(Parse pParse, Expr pExpr, SrcList pSrcList)
	{
		Walker w = new Walker();
		RefSrcList x = new RefSrcList();
		CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
		CRuntime.memset(x, (int)(0), (ulong)(sizeof(RefSrcList)));
		w.xExprCallback = exprRefToSrcList;
		w.xSelectCallback = selectRefEnter;
		w.xSelectCallback2 = selectRefLeave;
		w.u.pRefSrcList = x;
		x.db = pParse.db;
		x.pRef = pSrcList;
		sqlite3WalkExprList(w, pExpr.x.pList);
		if ((((pExpr).flags & (0x1000000)) != 0))
		{
			sqlite3WalkExpr(w, pExpr.y.pWin.pFilter);
		}

		sqlite3DbFree(pParse.db, x.aiExclude);
		if ((w.eCode & 0x01) != 0)
		{
			return (int)(1);
		}
		else if ((w.eCode) != 0)
		{
			return (int)(0);
		}
		else
		{
			return (int)(-1);
		}
	}
	public static void sqlite3RefillIndex(Parse pParse, Index pIndex, int memRootPage)
	{
		Table pTab = pIndex.pTable;
		int iTab = (int)(pParse.nTab++);
		int iIdx = (int)(pParse.nTab++);
		int iSorter = 0;
		int addr1 = 0;
		int addr2 = 0;
		uint tnum = 0;
		int iPartIdxLabel = 0;
		Vdbe v;
		KeyInfo pKey;
		int regRecord = 0;
		sqlite3 db = pParse.db;
		int iDb = (int)(sqlite3SchemaToIndex(db, pIndex.pSchema));
		if ((sqlite3AuthCheck(pParse, (int)(27), pIndex.zName, null, db.aDb[iDb].zDbSName)) != 0)
		{
			return;
		}

		sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(1), pTab.zName);
		v = sqlite3GetVdbe(pParse);
		if ((v) == (null))
			return;
		if ((memRootPage) >= (0))
		{
			tnum = ((uint)(memRootPage));
		}
		else
		{
			tnum = (uint)(pIndex.tnum);
		}

		pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);
		iSorter = (int)(pParse.nTab++);
		sqlite3VdbeAddOp4(v, (int)(118), (int)(iSorter), (int)(0), (int)(pIndex.nKeyCol), (sbyte*)(sqlite3KeyInfoRef(pKey)), (int)(-9));
		sqlite3OpenTable(pParse, (int)(iTab), (int)(iDb), pTab, (int)(101));
		addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iTab), (int)(0)));
		regRecord = (int)(sqlite3GetTempReg(pParse));
		sqlite3MultiWrite(pParse);
		sqlite3GenerateIndexKey(pParse, pIndex, (int)(iTab), (int)(regRecord), (int)(0), &iPartIdxLabel, null, (int)(0));
		sqlite3VdbeAddOp2(v, (int)(138), (int)(iSorter), (int)(regRecord));
		sqlite3ResolvePartIdxLabel(pParse, (int)(iPartIdxLabel));
		sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addr1 + 1));
		sqlite3VdbeJumpHere(v, (int)(addr1));
		if ((memRootPage) < (0))
			sqlite3VdbeAddOp2(v, (int)(144), (int)(tnum), (int)(iDb));
		sqlite3VdbeAddOp4(v, (int)(112), (int)(iIdx), (int)(tnum), (int)(iDb), (sbyte*)(pKey), (int)(-9));
		sqlite3VdbeChangeP5(v, (ushort)(0x01 | (((memRootPage) >= (0)) ? 0x10 : 0)));
		addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(36), (int)(iSorter), (int)(0)));
		if (((pIndex).onError != 0))
		{
			int j2 = (int)(sqlite3VdbeGoto(v, (int)(1)));
			addr2 = (int)(sqlite3VdbeCurrentAddr(v));
			sqlite3VdbeAddOp4Int(v, (int)(131), (int)(iSorter), (int)(j2), (int)(regRecord), (int)(pIndex.nKeyCol));
			sqlite3UniqueConstraint(pParse, (int)(2), pIndex);
			sqlite3VdbeJumpHere(v, (int)(j2));
		}
		else
		{
			sqlite3MayAbort(pParse);
			addr2 = (int)(sqlite3VdbeCurrentAddr(v));
		}

		sqlite3VdbeAddOp3(v, (int)(132), (int)(iSorter), (int)(regRecord), (int)(iIdx));
		if (pIndex.bAscKeyBug == 0)
		{
			sqlite3VdbeAddOp1(v, (int)(136), (int)(iIdx));
		}

		sqlite3VdbeAddOp2(v, (int)(137), (int)(iIdx), (int)(regRecord));
		sqlite3VdbeChangeP5(v, (ushort)(0x10));
		sqlite3ReleaseTempReg(pParse, (int)(regRecord));
		sqlite3VdbeAddOp2(v, (int)(3), (int)(iSorter), (int)(addr2));
		sqlite3VdbeJumpHere(v, (int)(addr1));
		sqlite3VdbeAddOp1(v, (int)(121), (int)(iTab));
		sqlite3VdbeAddOp1(v, (int)(121), (int)(iIdx));
		sqlite3VdbeAddOp1(v, (int)(121), (int)(iSorter));
	}
	public static void sqlite3Reindex(Parse pParse, Token* pName1, Token* pName2)
	{
		CollSeq pColl;
		sbyte* z;
		sbyte* zDb;
		Table pTab;
		Index pIndex;
		int iDb = 0;
		sqlite3 db = pParse.db;
		Token* pObjName;
		if (0 != sqlite3ReadSchema(pParse))
		{
			return;
		}

		if ((pName1) == (null))
		{
			reindexDatabases(pParse, null);
			return;
		}
		else if (((pName2) == (null)) || ((pName2->z) == (null)))
		{
			sbyte* zColl;
			zColl = sqlite3NameFromToken(pParse.db, pName1);
			if (zColl == null)
				return;
			pColl = sqlite3FindCollSeq(db, (byte)((db).enc), zColl, (int)(0));
			if ((pColl) != null)
			{
				reindexDatabases(pParse, zColl);
				sqlite3DbFree(db, zColl);
				return;
			}

			sqlite3DbFree(db, zColl);
		}

		iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pObjName));
		if ((iDb) < (0))
			return;
		z = sqlite3NameFromToken(db, pObjName);
		if ((z) == (null))
			return;
		zDb = db.aDb[iDb].zDbSName;
		pTab = sqlite3FindTable(db, z, zDb);
		if ((pTab) != null)
		{
			reindexTable(pParse, pTab, null);
			sqlite3DbFree(db, z);
			return;
		}

		pIndex = sqlite3FindIndex(db, z, zDb);
		sqlite3DbFree(db, z);
		if ((pIndex) != null)
		{
			sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
			sqlite3RefillIndex(pParse, pIndex, (int)(-1));
			return;
		}

		sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
	}
	public static void sqlite3ReleaseTempRange(Parse pParse, int iReg, int nReg)
	{
		if ((nReg) == (1))
		{
			sqlite3ReleaseTempReg(pParse, (int)(iReg));
			return;
		}

		if ((nReg) > (pParse.nRangeReg))
		{
			pParse.nRangeReg = (int)(nReg);
			pParse.iRangeReg = (int)(iReg);
		}
	}
	public static void sqlite3ReleaseTempReg(Parse pParse, int iReg)
	{
		if ((iReg) != 0)
		{
			if ((pParse.nTempReg) < ((int)(8 * sizeof(int) / sizeof(int))))
			{
				pParse.aTempReg[pParse.nTempReg++] = (int)(iReg);
			}
		}
	}
	public static void sqlite3RenameExprlistUnmap(Parse pParse, ExprList pEList)
	{
		if ((pEList) != null)
		{
			int i = 0;
			Walker sWalker = new Walker();
			CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
			sWalker.pParse = pParse;
			sWalker.xExprCallback = renameUnmapExprCb;
			sqlite3WalkExprList(sWalker, pEList);
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				if (((pEList.a[i].eEName) == (0)))
				{
					sqlite3RenameTokenRemap(pParse, null, (void*)(pEList.a[i].zEName));
				}
			}
		}
	}
	public static void sqlite3RenameExprUnmap(Parse pParse, Expr pExpr)
	{
		byte eMode = (byte)(pParse.eParseMode);
		Walker sWalker = new Walker();
		CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
		sWalker.pParse = pParse;
		sWalker.xExprCallback = renameUnmapExprCb;
		sWalker.xSelectCallback = renameUnmapSelectCb;
		pParse.eParseMode = (byte)(3);
		sqlite3WalkExpr(sWalker, pExpr);
		pParse.eParseMode = (byte)(eMode);
	}
	public static void sqlite3RenameTokenRemap(Parse pParse, void* pTo, void* pFrom)
	{
		RenameToken* p;
		for (p = pParse.pRename; p; p = p->pNext)
		{
			if ((p->p) == (pFrom))
			{
				p->p = pTo;
				break;
			}
		}
	}
	public static int sqlite3ResolveOrderGroupBy(Parse pParse, Select pSelect, ExprList pOrderBy, sbyte* zType)
	{
		int i = 0;
		sqlite3 db = pParse.db;
		ExprList pEList;
		ExprList_item* pItem;
		if ((((pOrderBy) == (null)) || ((pParse.db.mallocFailed) != 0)) || ((pParse.eParseMode) >= (2)))
			return (int)(0);
		if ((pOrderBy.nExpr) > (db.aLimit[2]))
		{
			sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
			return (int)(1);
		}

		pEList = pSelect.pEList;
		for (i = (int)(0), pItem = pOrderBy.a; (i) < (pOrderBy.nExpr); i++, pItem++)
		{
			if ((pItem->u.x.iOrderByCol) != 0)
			{
				if ((pItem->u.x.iOrderByCol) > (pEList.nExpr))
				{
					resolveOutOfRangeError(pParse, zType, (int)(i + 1), (int)(pEList.nExpr), null);
					return (int)(1);
				}

				resolveAlias(pParse, pEList, (int)(pItem->u.x.iOrderByCol - 1), pItem->pExpr, (int)(0));
			}
		}

		return (int)(0);
	}
	public static void sqlite3ResolvePartIdxLabel(Parse pParse, int iLabel)
	{
		if ((iLabel) != 0)
		{
			sqlite3VdbeResolveLabel(pParse.pVdbe, (int)(iLabel));
		}
	}
	public static void sqlite3ResolveSelectNames(Parse pParse, Select p, NameContext pOuterNC)
	{
		Walker w = new Walker();
		w.xExprCallback = resolveExprStep;
		w.xSelectCallback = resolveSelectStep;
		w.xSelectCallback2 = null;
		w.pParse = pParse;
		w.u.pNC = pOuterNC;
		sqlite3WalkSelect(w, p);
	}
	public static int sqlite3ResolveSelfReference(Parse pParse, Table pTab, int type, Expr pExpr, ExprList pList)
	{
		SrcList sSrc = new SrcList();
		NameContext sNC = new NameContext();
		int rc = 0;
		CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
		CRuntime.memset(sSrc, (int)(0), (ulong)(sizeof(SrcList)));
		if ((pTab) != null)
		{
			sSrc.nSrc = (int)(1);
			sSrc.a[0].zName = pTab.zName;
			sSrc.a[0].pTab = pTab;
			sSrc.a[0].iCursor = (int)(-1);
			if (pTab.pSchema != pParse.db.aDb[1].pSchema)
			{
				type |= (int)(0x040000);
			}
		}

		sNC.pParse = pParse;
		sNC.pSrcList = sSrc;
		sNC.ncFlags = (int)(type | 0x010000);
		if ((rc = (int)(sqlite3ResolveExprNames(sNC, pExpr))) != 0)
			return (int)(rc);
		if ((pList) != null)
			rc = (int)(sqlite3ResolveExprListNames(sNC, pList));
		return (int)(rc);
	}
	public static Table sqlite3ResultSetOfSelect(Parse pParse, Select pSelect, sbyte aff)
	{
		Table pTab;
		sqlite3 db = pParse.db;
		ulong savedFlags = 0;
		savedFlags = (ulong)(db.flags);
		db.flags &= (ulong)(~(ulong)(0x00000004));
		db.flags |= (ulong)(0x00000040);
		sqlite3SelectPrep(pParse, pSelect, null);
		db.flags = (ulong)(savedFlags);
		if ((pParse.nErr) != 0)
			return null;
		while ((pSelect.pPrior) != null)
		{
			pSelect = pSelect.pPrior;
		}

		pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
		if ((pTab) == (null))
		{
			return null;
		}

		pTab.nTabRef = (uint)(1);
		pTab.zName = null;
		pTab.nRowLogEst = (short)(200);
		sqlite3ColumnsFromExprList(pParse, pSelect.pEList, &pTab.nCol, &pTab.aCol);
		sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, (sbyte)(aff));
		pTab.iPKey = (short)(-1);
		if ((db.mallocFailed) != 0)
		{
			sqlite3DeleteTable(db, pTab);
			return null;
		}

		return pTab;
	}
	public static void sqlite3RowidConstraint(Parse pParse, int onError, Table pTab)
	{
		sbyte* zMsg;
		int rc = 0;
		if ((pTab.iPKey) >= (0))
		{
			zMsg = sqlite3MPrintf(pParse.db, "%s.%s", pTab.zName, pTab.aCol[pTab.iPKey].zCnName);
			rc = (int)(19 | (6 << 8));
		}
		else
		{
			zMsg = sqlite3MPrintf(pParse.db, "%s.rowid", pTab.zName);
			rc = (int)(19 | (10 << 8));
		}

		sqlite3HaltConstraint(pParse, (int)(rc), (int)(onError), zMsg, (sbyte)(-7), (byte)(2));
	}
	public static int sqlite3RunParser(Parse pParse, sbyte* zSql)
	{
		int nErr = (int)(0);
		void* pEngine;
		int n = (int)(0);
		int tokenType = 0;
		int lastTokenParsed = (int)(-1);
		sqlite3 db = pParse.db;
		int mxSqlLen = 0;
		Parse pParentParse = null;
		yyParser sEngine = new yyParser();
		mxSqlLen = (int)(db.aLimit[1]);
		if ((db.nVdbeActive) == (0))
		{
			(0);
		}

		pParse.rc = (int)(0);
		pParse.zTail = zSql;
		pEngine = sEngine;
		sqlite3ParserInit(pEngine, pParse);
		pParentParse = db.pParse;
		db.pParse = pParse;
		while ((1) != 0)
		{
			n = (int)(sqlite3GetToken((byte*)(zSql), &tokenType));
			mxSqlLen -= (int)(n);
			if ((mxSqlLen) < (0))
			{
				pParse.rc = (int)(18);
				break;
			}

			if ((tokenType) >= (164))
			{
				if ((0) != 0)
				{
					pParse.rc = (int)(9);
					pParse.nErr++;
					break;
				}

				if ((tokenType) == (183))
				{
					zSql += n;
					continue;
				}

				if ((zSql[0]) == (0))
				{
					if ((lastTokenParsed) == (1))
					{
						tokenType = (int)(0);
					}
					else if ((lastTokenParsed) == (0))
					{
						break;
					}
					else
					{
						tokenType = (int)(1);
					}

					n = (int)(0);
				}
				else if ((tokenType) == (164))
				{
					tokenType = (int)(analyzeWindowKeyword((byte*)(&zSql[6])));
				}
				else if ((tokenType) == (165))
				{
					tokenType = (int)(analyzeOverKeyword((byte*)(&zSql[4]), (int)(lastTokenParsed)));
				}
				else if ((tokenType) == (166))
				{
					tokenType = (int)(analyzeFilterKeyword((byte*)(&zSql[6]), (int)(lastTokenParsed)));
				}
				else
				{
					Token x = new Token();
					x.z = zSql;
					x.n = (uint)(n);
					sqlite3ErrorMsg(pParse, "unrecognized token: \"%T\"", &x);
					break;
				}
			}

			pParse.sLastToken.z = zSql;
			pParse.sLastToken.n = (uint)(n);
			sqlite3Parser(pEngine, (int)(tokenType), (Token)(pParse.sLastToken));
			lastTokenParsed = (int)(tokenType);
			zSql += n;
			if (pParse.rc != 0)
				break;
		}

		sqlite3ParserFinalize(pEngine);
		if ((db.mallocFailed) != 0)
		{
			pParse.rc = (int)(7);
		}

		if (((pParse.zErrMsg) != null) || ((pParse.rc != 0) && (pParse.rc != 101)))
		{
			if ((pParse.zErrMsg) == (null))
			{
				pParse.zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr((int)(pParse.rc)));
			}

			sqlite3_log((int)(pParse.rc), "%s in \"%s\"", pParse.zErrMsg, pParse.zTail);
			nErr++;
		}

		pParse.zTail = zSql;
		sqlite3_free(pParse.apVtabLock);
		if (((pParse.pNewTable) != null) && (!(pParse.eParseMode != 0)))
		{
			sqlite3DeleteTable(db, pParse.pNewTable);
		}

		if (((pParse.pNewTrigger) != null) && (!((pParse.eParseMode) >= (2))))
		{
			sqlite3DeleteTrigger(db, pParse.pNewTrigger);
		}

		sqlite3DbFree(db, pParse.pVList);
		db.pParse = pParentParse;
		return (int)(nErr);
	}
	public static void sqlite3Savepoint(Parse pParse, int op, Token* pName)
	{
		sbyte* zName = sqlite3NameFromToken(pParse.db, pName);
		if ((zName) != null)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			if ((v == null) || ((sqlite3AuthCheck(pParse, (int)(32), sqlite3Savepoint_az[op], zName, null)) != 0))
			{
				sqlite3DbFree(pParse.db, zName);
				return;
			}

			sqlite3VdbeAddOp4(v, (int)(0), (int)(op), (int)(0), (int)(0), zName, (int)(-7));
		}
	}
	public static int sqlite3Select(Parse pParse, Select p, SelectDest pDest)
	{
		int i = 0; int j = 0;
		WhereInfo pWInfo;
		Vdbe v;
		int isAgg = 0;
		ExprList pEList = null;
		SrcList pTabList;
		Expr pWhere;
		ExprList pGroupBy;
		Expr pHaving;
		AggInfo pAggInfo = null;
		int rc = (int)(1);
		DistinctCtx sDistinct = new DistinctCtx();
		SortCtx sSort = new SortCtx();
		int iEnd = 0;
		sqlite3 db;
		ExprList pMinMaxOrderBy = null;
		byte minMaxFlag = 0;
		db = pParse.db;
		v = sqlite3GetVdbe(pParse);
		if (((p) == (null)) || ((pParse.nErr) != 0))
		{
			return (int)(1);
		}

		if ((sqlite3AuthCheck(pParse, (int)(21), null, null, null)) != 0)
			return (int)(1);
		if (((pDest.eDest) <= (6)))
		{
			if ((p.pOrderBy) != null)
			{
				sqlite3ParserAddCleanup(pParse, sqlite3ExprListDelete, p.pOrderBy);
				p.pOrderBy = null;
			}

			p.selFlags &= (uint)(~0x0000001);
			p.selFlags |= (uint)(0x0400000);
		}

		sqlite3SelectPrep(pParse, p, null);
		if ((pParse.nErr) != 0)
		{
			goto select_end;
		}

		if ((p.selFlags & 0x0800000) != 0)
		{
			SrcItem p0 = p.pSrc.a[0];
			for (i = (int)(1); (i) < (p.pSrc.nSrc); i++)
			{
				SrcItem p1 = p.pSrc.a[i];
				if (((p0.pTab) == (p1.pTab)) && ((0) == (sqlite3_stricmp(p0.zAlias, p1.zAlias))))
				{
					sqlite3ErrorMsg(pParse, "target object/alias may not appear in FROM clause: %s", (p0.zAlias) != 0 ? p0.zAlias : p0.pTab.zName);
					goto select_end;
				}
			}

			p.selFlags &= (uint)(~0x0800000);
		}

		if ((pDest.eDest) == (9))
		{
			sqlite3GenerateColumnNames(pParse, p);
		}

		if ((sqlite3WindowRewrite(pParse, p)) != 0)
		{
			goto select_end;
		}

		pTabList = p.pSrc;
		isAgg = (int)((p.selFlags & 0x0000008) != 0);
		CRuntime.memset(sSort, (int)(0), (ulong)(sizeof(SortCtx)));
		sSort.pOrderBy = p.pOrderBy;
		for (i = (int)(0); (p.pPrior == null) && ((i) < (pTabList.nSrc)); i++)
		{
			SrcItem pItem = pTabList.a[i];
			Select pSub = pItem.pSelect;
			Table pTab = pItem.pTab;
			if ((((pItem.fg.jointype & 0x0008) != 0) && ((sqlite3ExprImpliesNonNullRow(p.pWhere, (int)(pItem.iCursor))) != 0)) && (((db).dbOptFlags & (0x00002000)) == (0)))
			{
				pItem.fg.jointype &= (byte)(~(0x0008 | 0x0020));
				unsetJoinExpr(p.pWhere, (int)(pItem.iCursor));
			}

			if ((pSub) == (null))
				continue;
			if (pTab.nCol != pSub.pEList.nExpr)
			{
				sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d", (int)(pTab.nCol), pTab.zName, (int)(pSub.pEList.nExpr));
				goto select_end;
			}

			if ((pSub.selFlags & 0x0000008) != 0)
				continue;
			if ((((((pSub.pOrderBy != null) && ((p.pOrderBy != null) || ((pTabList.nSrc) > (1)))) && ((pSub.pLimit) == (null))) && ((pSub.selFlags & 0x8000000) == (0))) && ((p.selFlags & 0x8000000) == (0))) && (((db).dbOptFlags & (0x00040000)) == (0)))
			{
				sqlite3ExprListDelete(db, pSub.pOrderBy);
				pSub.pOrderBy = null;
			}

			if ((((pSub.pOrderBy != null) && ((i) == (0))) && ((p.selFlags & 0x0040000) != 0)) && (((pTabList.nSrc) == (1)) || ((pTabList.a[1].fg.jointype & (0x0008 | 0x0002)) != 0)))
			{
				continue;
			}

			if ((flattenSubquery(pParse, p, (int)(i), (int)(isAgg))) != 0)
			{
				if ((pParse.nErr) != 0)
					goto select_end;
				i = (int)(-1);
			}

			pTabList = p.pSrc;
			if ((db.mallocFailed) != 0)
				goto select_end;
			if (!((pDest.eDest) <= (8)))
			{
				sSort.pOrderBy = p.pOrderBy;
			}
		}

		if ((p.pPrior) != null)
		{
			rc = (int)(multiSelect(pParse, p, pDest));
			if ((p.pNext) == (null))
				sqlite3VdbeExplainPop(pParse);
			return (int)(rc);
		}

		if ((((p.pWhere != null) && ((p.pWhere.op) == (44))) && (((db).dbOptFlags & (0x00008000)) == (0))) && ((propagateConstants(pParse, p)) != 0))
		{
		}
		else
		{
		}

		for (i = (int)(0); (i) < (pTabList.nSrc); i++)
		{
			SrcItem pItem = pTabList.a[i];
			SrcItem pPrior;
			SelectDest dest = new SelectDest();
			Select pSub;
			sbyte* zSavedAuthContext;
			if (((pItem.colUsed) == (0)) && (pItem.zName != null))
			{
				sqlite3AuthCheck(pParse, (int)(20), pItem.zName, "", pItem.zDatabase);
			}

			pSub = pItem.pSelect;
			if ((pSub) == (null))
				continue;
			pParse.nHeight += (int)(sqlite3SelectExprHeight(p));
			if (((((db).dbOptFlags & (0x00001000)) == (0)) && (((pItem.fg.isCte) == (0)) || ((pItem.u2.pCteUse->eM10d != 0) && ((pItem.u2.pCteUse->nUse) < (2))))) && ((pushDownWhereTerms(pParse, pSub, p.pWhere, (int)(pItem.iCursor), (int)((pItem.fg.jointype & 0x0020) != 0))) != 0))
			{
			}
			else
			{
			}

			zSavedAuthContext = pParse.zAuthContext;
			pParse.zAuthContext = pItem.zName;
			if ((((i) == (0)) && (((pTabList.nSrc) == (1)) || ((pTabList.a[1].fg.jointype & (0x0008 | 0x0002)) != 0))) && (((pItem.fg.isCte) == (0)) || (pItem.u2.pCteUse->eM10d != 0)))
			{
				int addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
				pItem.regReturn = (int)(++pParse.nMem);
				sqlite3VdbeAddOp3(v, (int)(13), (int)(pItem.regReturn), (int)(0), (int)(addrTop));
				pItem.addrFillSub = (int)(addrTop);
				sqlite3SelectDestInit(dest, (int)(13), (int)(pItem.regReturn));
				sqlite3VdbeExplain(pParse, (byte)(1), "CO-ROUTINE %!S", pItem);
				sqlite3Select(pParse, pSub, dest);
				pItem.pTab.nRowLogEst = (short)(pSub.nSelectRow);
				pItem.fg.viaCoroutine = (uint)(1);
				pItem.regResult = (int)(dest.iSdst);
				sqlite3VdbeEndCoroutine(v, (int)(pItem.regReturn));
				sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
				sqlite3ClearTempRegCache(pParse);
			}
			else if (((pItem.fg.isCte) != 0) && ((pItem.u2.pCteUse->addrM9e) > (0)))
			{
				CteUse* pCteUse = pItem.u2.pCteUse;
				sqlite3VdbeAddOp2(v, (int)(12), (int)(pCteUse->regRtn), (int)(pCteUse->addrM9e));
				if (pItem.iCursor != pCteUse->iCur)
				{
					sqlite3VdbeAddOp2(v, (int)(113), (int)(pItem.iCursor), (int)(pCteUse->iCur));
				}

				pSub.nSelectRow = (short)(pCteUse->nRowEst);
			}
			else if ((pPrior = isSelfJoinView(pTabList, pItem)) != null)
			{
				if ((pPrior.addrFillSub) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(12), (int)(pPrior.regReturn), (int)(pPrior.addrFillSub));
				}

				sqlite3VdbeAddOp2(v, (int)(113), (int)(pItem.iCursor), (int)(pPrior.iCursor));
				pSub.nSelectRow = (short)(pPrior.pSelect.nSelectRow);
			}
			else
			{
				int topAddr = 0;
				int onceAddr = (int)(0);
				int retAddr = 0;
				pItem.regReturn = (int)(++pParse.nMem);
				topAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pItem.regReturn)));
				pItem.addrFillSub = (int)(topAddr + 1);
				if ((pItem.fg.isCorrelated) == (0))
				{
					onceAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				}
				else
				{
				}

				sqlite3SelectDestInit(dest, (int)(12), (int)(pItem.iCursor));
				sqlite3VdbeExplain(pParse, (byte)(1), "MATERIALIZE %!S", pItem);
				sqlite3Select(pParse, pSub, dest);
				pItem.pTab.nRowLogEst = (short)(pSub.nSelectRow);
				if ((onceAddr) != 0)
					sqlite3VdbeJumpHere(v, (int)(onceAddr));
				retAddr = (int)(sqlite3VdbeAddOp1(v, (int)(67), (int)(pItem.regReturn)));
				sqlite3VdbeChangeP1(v, (int)(topAddr), (int)(retAddr));
				sqlite3ClearTempRegCache(pParse);
				if (((pItem.fg.isCte) != 0) && ((pItem.fg.isCorrelated) == (0)))
				{
					CteUse* pCteUse = pItem.u2.pCteUse;
					pCteUse->addrM9e = (int)(pItem.addrFillSub);
					pCteUse->regRtn = (int)(pItem.regReturn);
					pCteUse->iCur = (int)(pItem.iCursor);
					pCteUse->nRowEst = (short)(pSub.nSelectRow);
				}
			}

			if ((db.mallocFailed) != 0)
				goto select_end;
			pParse.nHeight -= (int)(sqlite3SelectExprHeight(p));
			pParse.zAuthContext = zSavedAuthContext;
		}

		pEList = p.pEList;
		pWhere = p.pWhere;
		pGroupBy = p.pGroupBy;
		pHaving = p.pHaving;
		sDistinct.isTnct = (byte)((p.selFlags & 0x0000001) != 0);
		if ((((p.selFlags & (0x0000001 | 0x0000008)) == (0x0000001)) && ((sqlite3ExprListCompare(sSort.pOrderBy, pEList, (int)(-1))) == (0))) && ((p.pWin) == (null)))
		{
			p.selFlags &= (uint)(~0x0000001);
			pGroupBy = p.pGroupBy = sqlite3ExprListDup(db, pEList, (int)(0));
			p.selFlags |= (uint)(0x0000008);
		}

		if ((sSort.pOrderBy) != null)
		{
			KeyInfo pKeyInfo;
			pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, (int)(0), (int)(pEList.nExpr));
			sSort.iECursor = (int)(pParse.nTab++);
			sSort.addrSortIndex = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(sSort.iECursor), (int)(sSort.pOrderBy.nExpr + 1 + pEList.nExpr), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
		}
		else
		{
			sSort.addrSortIndex = (int)(-1);
		}

		if ((pDest.eDest) == (12))
		{
			sqlite3VdbeAddOp2(v, (int)(116), (int)(pDest.iSDParm), (int)(pEList.nExpr));
		}

		iEnd = (int)(sqlite3VdbeMakeLabel(pParse));
		if ((p.selFlags & 0x0004000) == (0))
		{
			p.nSelectRow = (short)(320);
		}

		computeLimitRegisters(pParse, p, (int)(iEnd));
		if (((p.iLimit) == (0)) && ((sSort.addrSortIndex) >= (0)))
		{
			sqlite3VdbeChangeOpcode(v, (int)(sSort.addrSortIndex), (byte)(118));
			sSort.sortFlags |= (byte)(0x01);
		}

		if ((p.selFlags & 0x0000001) != 0)
		{
			sDistinct.tabTnct = (int)(pParse.nTab++);
			sDistinct.addrTnct = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(sDistinct.tabTnct), (int)(0), (int)(0), (sbyte*)(sqlite3KeyInfoFromExprList(pParse, p.pEList, (int)(0), (int)(0))), (int)(-9)));
			sqlite3VdbeChangeP5(v, (ushort)(8));
			sDistinct.eTnctType = (byte)(3);
		}
		else
		{
			sDistinct.eTnctType = (byte)(0);
		}

		if ((isAgg == 0) && ((pGroupBy) == (null)))
		{
			ushort wctrlFlags = (ushort)(((sDistinct.isTnct) != 0 ? 0x0100 : 0) | (p.selFlags & 0x0004000));
			Window pWin = p.pWin;
			if ((pWin) != null)
			{
				sqlite3WindowCodeInit(pParse, p);
			}

			pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p.pEList, p, (ushort)(wctrlFlags), (int)(p.nSelectRow));
			if ((pWInfo) == (null))
				goto select_end;
			if ((sqlite3WhereOutputRowCount(pWInfo)) < (p.nSelectRow))
			{
				p.nSelectRow = (short)(sqlite3WhereOutputRowCount(pWInfo));
			}

			if (((sDistinct.isTnct) != 0) && ((sqlite3WhereIsDistinct(pWInfo)) != 0))
			{
				sDistinct.eTnctType = (byte)(sqlite3WhereIsDistinct(pWInfo));
			}

			if ((sSort.pOrderBy) != null)
			{
				sSort.nOBSat = (int)(sqlite3WhereIsOrdered(pWInfo));
				sSort.labelOBLopt = (int)(sqlite3WhereOrderByLimitOptLabel(pWInfo));
				if ((sSort.nOBSat) == (sSort.pOrderBy.nExpr))
				{
					sSort.pOrderBy = null;
				}
			}

			if (((sSort.addrSortIndex) >= (0)) && ((sSort.pOrderBy) == (null)))
			{
				sqlite3VdbeChangeToNoop(v, (int)(sSort.addrSortIndex));
			}

			if ((pWin) != null)
			{
				int addrGosub = (int)(sqlite3VdbeMakeLabel(pParse));
				int iCont = (int)(sqlite3VdbeMakeLabel(pParse));
				int iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
				int regGosub = (int)(++pParse.nMem);
				sqlite3WindowCodeStep(pParse, p, pWInfo, (int)(regGosub), (int)(addrGosub));
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(iBreak));
				sqlite3VdbeResolveLabel(v, (int)(addrGosub));
				sSort.labelOBLopt = (int)(0);
				selectInnerLoop(pParse, p, (int)(-1), sSort, &sDistinct, pDest, (int)(iCont), (int)(iBreak));
				sqlite3VdbeResolveLabel(v, (int)(iCont));
				sqlite3VdbeAddOp1(v, (int)(67), (int)(regGosub));
				sqlite3VdbeResolveLabel(v, (int)(iBreak));
			}
			else
			{
				selectInnerLoop(pParse, p, (int)(-1), sSort, &sDistinct, pDest, (int)(sqlite3WhereContinueLabel(pWInfo)), (int)(sqlite3WhereBreakLabel(pWInfo)));
				sqlite3WhereEnd(pWInfo);
			}
		}
		else
		{
			NameContext sNC = new NameContext();
			int iAMem = 0;
			int iBMem = 0;
			int iUseFlag = 0;
			int iAbortFlag = 0;
			int groupBySort = 0;
			int addrEnd = 0;
			int sortPTab = (int)(0);
			int sortOut = (int)(0);
			int orderByGrp = (int)(0);
			if ((pGroupBy) != null)
			{
				int k = 0;
				ExprList_item* pItem;
				for (k = (int)(p.pEList.nExpr), pItem = p.pEList.a; (k) > (0); k--, pItem++)
				{
					pItem->u.x.iAlias = (ushort)(0);
				}

				for (k = (int)(pGroupBy.nExpr), pItem = pGroupBy.a; (k) > (0); k--, pItem++)
				{
					pItem->u.x.iAlias = (ushort)(0);
				}

				if ((p.nSelectRow) > (66))
					p.nSelectRow = (short)(66);
				if (((sSort.pOrderBy) != null) && ((pGroupBy.nExpr) == (sSort.pOrderBy.nExpr)))
				{
					int ii = 0;
					for (ii = (int)(0); (ii) < (pGroupBy.nExpr); ii++)
					{
						byte sortFlags = (byte)(sSort.pOrderBy.a[ii].sortFlags & 0x01);
						pGroupBy.a[ii].sortFlags = (byte)(sortFlags);
					}

					if ((sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, (int)(-1))) == (0))
					{
						orderByGrp = (int)(1);
					}
				}
			}
			else
			{
				p.nSelectRow = (short)(0);
			}

			addrEnd = (int)(sqlite3VdbeMakeLabel(pParse));
			pAggInfo = sqlite3DbMallocZero(db, (ulong)(sizeof(AggInfo)));
			if ((pAggInfo) != null)
			{
				sqlite3ParserAddCleanup(pParse, agginfoFree, pAggInfo);
			}

			if ((db.mallocFailed) != 0)
			{
				goto select_end;
			}

			pAggInfo.selId = (uint)(p.selId);
			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = pParse;
			sNC.pSrcList = pTabList;
			sNC.uNC.pAggInfo = pAggInfo;
			pAggInfo.mnReg = (int)(pParse.nMem + 1);
			pAggInfo.nSortingColumn = (int)(pGroupBy ? pGroupBy.nExpr : 0);
			pAggInfo.pGroupBy = pGroupBy;
			sqlite3ExprAnalyzeAggList(sNC, pEList);
			sqlite3ExprAnalyzeAggList(sNC, sSort.pOrderBy);
			if ((pHaving) != null)
			{
				if ((pGroupBy) != null)
				{
					havingToWhere(pParse, p);
					pWhere = p.pWhere;
				}

				sqlite3ExprAnalyzeAggregates(sNC, pHaving);
			}

			pAggInfo.nAccumulator = (int)(pAggInfo.nColumn);
			if ((((p.pGroupBy) == (null)) && ((p.pHaving) == (null))) && ((pAggInfo.nFunc) == (1)))
			{
				minMaxFlag = (byte)(minMaxQuery(db, pAggInfo.aFunc[0].pFExpr, pMinMaxOrderBy));
			}
			else
			{
				minMaxFlag = (byte)(0x0000);
			}

			for (i = (int)(0); (i) < (pAggInfo.nFunc); i++)
			{
				Expr pExpr = pAggInfo.aFunc[i].pFExpr;
				sNC.ncFlags |= (int)(0x020000);
				sqlite3ExprAnalyzeAggList(sNC, pExpr.x.pList);
				if ((((pExpr).flags & (0x1000000)) != 0))
				{
					sqlite3ExprAnalyzeAggregates(sNC, pExpr.y.pWin.pFilter);
				}

				sNC.ncFlags &= (int)(~0x020000);
			}

			pAggInfo.mxReg = (int)(pParse.nMem);
			if ((db.mallocFailed) != 0)
				goto select_end;
			if ((pGroupBy) != null)
			{
				KeyInfo pKeyInfo;
				int addr1 = 0;
				int addrOutputRow = 0;
				int regOutputRow = 0;
				int addrSetAbort = 0;
				int addrTopOfLoop = 0;
				int addrSortingIdx = 0;
				int addrReset = 0;
				int regReset = 0;
				ExprList pDistinct = null;
				ushort distFlag = (ushort)(0);
				int eDist = (int)(0);
				if ((((((pAggInfo.nFunc) == (1)) && ((pAggInfo.aFunc[0].iDistinct) >= (0))) && (pAggInfo.aFunc[0].pFExpr != null)) && ((((pAggInfo.aFunc[0].pFExpr).flags & 0x000800) == (0)) != 0)) && (pAggInfo.aFunc[0].pFExpr.x.pList != null))
				{
					Expr pExpr = pAggInfo.aFunc[0].pFExpr.x.pList.a[0].pExpr;
					pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
					pDistinct = sqlite3ExprListDup(db, pGroupBy, (int)(0));
					pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);
					distFlag = (ushort)(pDistinct ? (0x0100 | 0x0400) : 0);
				}

				pAggInfo.sortingIdx = (int)(pParse.nTab++);
				pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, (int)(0), (int)(pAggInfo.nColumn));
				addrSortingIdx = (int)(sqlite3VdbeAddOp4(v, (int)(118), (int)(pAggInfo.sortingIdx), (int)(pAggInfo.nSortingColumn), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
				iUseFlag = (int)(++pParse.nMem);
				iAbortFlag = (int)(++pParse.nMem);
				regOutputRow = (int)(++pParse.nMem);
				addrOutputRow = (int)(sqlite3VdbeMakeLabel(pParse));
				regReset = (int)(++pParse.nMem);
				addrReset = (int)(sqlite3VdbeMakeLabel(pParse));
				iAMem = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(pGroupBy.nExpr);
				iBMem = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(pGroupBy.nExpr);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(iAbortFlag));
				sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(iAMem), (int)(iAMem + pGroupBy.nExpr - 1));
				sqlite3VdbeAddOp2(v, (int)(12), (int)(regReset), (int)(addrReset));
				pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, null, (ushort)(0x0040 | ((orderByGrp) != 0 ? 0x0200 : 0) | distFlag), (int)(0));
				if ((pWInfo) == (null))
				{
					sqlite3ExprListDelete(db, pDistinct);
					goto select_end;
				}

				eDist = (int)(sqlite3WhereIsDistinct(pWInfo));
				if ((sqlite3WhereIsOrdered(pWInfo)) == (pGroupBy.nExpr))
				{
					groupBySort = (int)(0);
				}
				else
				{
					int regBase = 0;
					int regRecord = 0;
					int nCol = 0;
					int nGroupBy = 0;
					explainTempTable(pParse, (((sDistinct.isTnct) != 0) && ((p.selFlags & 0x0000001) == (0))) ? "DISTINCT" : "GROUP BY");
					groupBySort = (int)(1);
					nGroupBy = (int)(pGroupBy.nExpr);
					nCol = (int)(nGroupBy);
					j = (int)(nGroupBy);
					for (i = (int)(0); (i) < (pAggInfo.nColumn); i++)
					{
						if ((pAggInfo.aCol[i].iSorterColumn) >= (j))
						{
							nCol++;
							j++;
						}
					}

					regBase = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
					sqlite3ExprCodeExprList(pParse, pGroupBy, (int)(regBase), (int)(0), (byte)(0));
					j = (int)(nGroupBy);
					for (i = (int)(0); (i) < (pAggInfo.nColumn); i++)
					{
						AggInfo_col pCol = pAggInfo.aCol[i];
						if ((pCol.iSorterColumn) >= (j))
						{
							int r1 = (int)(j + regBase);
							sqlite3ExprCodeGetColumnOfTable(v, pCol.pTab, (int)(pCol.iTable), (int)(pCol.iColumn), (int)(r1));
							j++;
						}
					}

					regRecord = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase), (int)(nCol), (int)(regRecord));
					sqlite3VdbeAddOp2(v, (int)(138), (int)(pAggInfo.sortingIdx), (int)(regRecord));
					sqlite3ReleaseTempReg(pParse, (int)(regRecord));
					sqlite3ReleaseTempRange(pParse, (int)(regBase), (int)(nCol));
					sqlite3WhereEnd(pWInfo);
					pAggInfo.sortingIdxPTab = (int)(sortPTab = (int)(pParse.nTab++));
					sortOut = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(120), (int)(sortPTab), (int)(sortOut), (int)(nCol));
					sqlite3VdbeAddOp2(v, (int)(36), (int)(pAggInfo.sortingIdx), (int)(addrEnd));
					pAggInfo.useSortingIdx = (byte)(1);
				}

				if ((((orderByGrp) != 0) && (((db).dbOptFlags & (0x00000004)) == (0))) && (((groupBySort) != 0) || ((sqlite3WhereIsSorted(pWInfo)) != 0)))
				{
					sSort.pOrderBy = null;
					sqlite3VdbeChangeToNoop(v, (int)(sSort.addrSortIndex));
				}

				addrTopOfLoop = (int)(sqlite3VdbeCurrentAddr(v));
				if ((groupBySort) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(132), (int)(pAggInfo.sortingIdx), (int)(sortOut), (int)(sortPTab));
				}

				for (j = (int)(0); (j) < (pGroupBy.nExpr); j++)
				{
					if ((groupBySort) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(sortPTab), (int)(j), (int)(iBMem + j));
					}
					else
					{
						pAggInfo.directMode = (byte)(1);
						sqlite3ExprCode(pParse, pGroupBy.a[j].pExpr, (int)(iBMem + j));
					}
				}

				sqlite3VdbeAddOp4(v, (int)(89), (int)(iAMem), (int)(iBMem), (int)(pGroupBy.nExpr), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9));
				addr1 = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3VdbeAddOp3(v, (int)(16), (int)(addr1 + 1), (int)(0), (int)(addr1 + 1));
				sqlite3ExprCodeMove(pParse, (int)(iBMem), (int)(iAMem), (int)(pGroupBy.nExpr));
				sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutputRow), (int)(addrOutputRow));
				sqlite3VdbeAddOp2(v, (int)(49), (int)(iAbortFlag), (int)(addrEnd));
				sqlite3VdbeAddOp2(v, (int)(12), (int)(regReset), (int)(addrReset));
				sqlite3VdbeJumpHere(v, (int)(addr1));
				updateAccumulator(pParse, (int)(iUseFlag), pAggInfo, (int)(eDist));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iUseFlag));
				if ((groupBySort) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(3), (int)(pAggInfo.sortingIdx), (int)(addrTopOfLoop));
				}
				else
				{
					sqlite3WhereEnd(pWInfo);
					sqlite3VdbeChangeToNoop(v, (int)(addrSortingIdx));
				}

				sqlite3ExprListDelete(db, pDistinct);
				sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutputRow), (int)(addrOutputRow));
				sqlite3VdbeGoto(v, (int)(addrEnd));
				addrSetAbort = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iAbortFlag));
				sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
				sqlite3VdbeResolveLabel(v, (int)(addrOutputRow));
				addrOutputRow = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3VdbeAddOp2(v, (int)(49), (int)(iUseFlag), (int)(addrOutputRow + 2));
				sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
				finalizeAggFunctions(pParse, pAggInfo);
				sqlite3ExprIfFalse(pParse, pHaving, (int)(addrOutputRow + 1), (int)(0x10));
				selectInnerLoop(pParse, p, (int)(-1), sSort, &sDistinct, pDest, (int)(addrOutputRow + 1), (int)(addrSetAbort));
				sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
				sqlite3VdbeResolveLabel(v, (int)(addrReset));
				resetAccumulator(pParse, pAggInfo);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(iUseFlag));
				sqlite3VdbeAddOp1(v, (int)(67), (int)(regReset));
				if (eDist != 0)
				{
					AggInfo_func pF = pAggInfo.aFunc[0];
					fixDistinctOpenEph(pParse, (int)(eDist), (int)(pF.iDistinct), (int)(pF.iDistAddr));
				}
			}
			else
			{
				Table pTab;
				if ((pTab = isSimpleCount(p, pAggInfo)) != null)
				{
					int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
					int iCsr = (int)(pParse.nTab++);
					Index pIdx;
					KeyInfo pKeyInfo = null;
					Index pBest = null;
					uint iRoot = (uint)(pTab.tnum);
					sqlite3CodeVerifySchema(pParse, (int)(iDb));
					sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
					if (!(((pTab).tabFlags & 0x00000080) == (0)))
						pBest = sqlite3PrimaryKeyIndex(pTab);
					if (p.pSrc.a[0].fg.notIndexed == 0)
					{
						for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
						{
							if (((((pIdx.bUnordered) == (0)) && ((pIdx.szIdxRow) < (pTab.szTabRow))) && ((pIdx.pPartIdxWhere) == (null))) && ((pBest == null) || ((pIdx.szIdxRow) < (pBest.szIdxRow))))
							{
								pBest = pIdx;
							}
						}
					}

					if ((pBest) != null)
					{
						iRoot = (uint)(pBest.tnum);
						pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
					}

					sqlite3VdbeAddOp4Int(v, (int)(101), (int)(iCsr), (int)(iRoot), (int)(iDb), (int)(1));
					if ((pKeyInfo) != null)
					{
						sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pKeyInfo), (int)(-9));
					}

					sqlite3VdbeAddOp2(v, (int)(97), (int)(iCsr), (int)(pAggInfo.aFunc[0].iMem));
					sqlite3VdbeAddOp1(v, (int)(121), (int)(iCsr));
					explainSimpleCount(pParse, pTab, pBest);
				}
				else
				{
					int regAcc = (int)(0);
					ExprList pDistinct = null;
					ushort distFlag = (ushort)(0);
					int eDist = 0;
					if ((pAggInfo.nAccumulator) != 0)
					{
						for (i = (int)(0); (i) < (pAggInfo.nFunc); i++)
						{
							if ((((pAggInfo.aFunc[i].pFExpr).flags & (0x1000000)) != 0))
							{
								continue;
							}

							if ((pAggInfo.aFunc[i].pFunc.funcFlags & 0x0020) != 0)
							{
								break;
							}
						}

						if ((i) == (pAggInfo.nFunc))
						{
							regAcc = (int)(++pParse.nMem);
							sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regAcc));
						}
					}
					else if (((pAggInfo.nFunc) == (1)) && ((pAggInfo.aFunc[0].iDistinct) >= (0)))
					{
						pDistinct = pAggInfo.aFunc[0].pFExpr.x.pList;
						distFlag = (ushort)(pDistinct ? (0x0100 | 0x0400) : 0);
					}

					resetAccumulator(pParse, pAggInfo);
					pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, null, (ushort)(minMaxFlag | distFlag), (int)(0));
					if ((pWInfo) == (null))
					{
						goto select_end;
					}

					eDist = (int)(sqlite3WhereIsDistinct(pWInfo));
					updateAccumulator(pParse, (int)(regAcc), pAggInfo, (int)(eDist));
					if (eDist != 0)
					{
						AggInfo_func pF = pAggInfo.aFunc[0];
						fixDistinctOpenEph(pParse, (int)(eDist), (int)(pF.iDistinct), (int)(pF.iDistAddr));
					}

					if ((regAcc) != 0)
						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regAcc));
					if ((minMaxFlag) != 0)
					{
						sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);
					}

					sqlite3WhereEnd(pWInfo);
					finalizeAggFunctions(pParse, pAggInfo);
				}

				sSort.pOrderBy = null;
				sqlite3ExprIfFalse(pParse, pHaving, (int)(addrEnd), (int)(0x10));
				selectInnerLoop(pParse, p, (int)(-1), null, null, pDest, (int)(addrEnd), (int)(addrEnd));
			}

			sqlite3VdbeResolveLabel(v, (int)(addrEnd));
		}

		if ((sDistinct.eTnctType) == (3))
		{
			explainTempTable(pParse, "DISTINCT");
		}

		if ((sSort.pOrderBy) != null)
		{
			explainTempTable(pParse, (sSort.nOBSat) > (0) ? "RIGHT PART OF ORDER BY" : "ORDER BY");
			generateSortTail(pParse, p, sSort, (int)(pEList.nExpr), pDest);
		}

		sqlite3VdbeResolveLabel(v, (int)(iEnd));
		rc = (int)((pParse.nErr) > (0) ? 1 : 0);
	select_end:
		;
		sqlite3ExprListDelete(db, pMinMaxOrderBy);
		sqlite3VdbeExplainPop(pParse);
		return (int)(rc);
	}
	public static void sqlite3SelectAddColumnTypeAndCollation(Parse pParse, Table pTab, Select pSelect, sbyte aff)
	{
		sqlite3 db = pParse.db;
		NameContext sNC = new NameContext();
		Column* pCol;
		CollSeq pColl;
		int i = 0;
		Expr p;
		ExprList_item* a;
		if ((db.mallocFailed) != 0)
			return;
		CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
		sNC.pSrcList = pSelect.pSrc;
		a = pSelect.pEList.a;
		for (i = (int)(0), pCol = pTab.aCol; (i) < (pTab.nCol); i++, pCol++)
		{
			sbyte* zType;
			long n = 0;
			long m = 0;
			pTab.tabFlags |= (uint)(pCol->colFlags & 0x0062);
			p = a[i].pExpr;
			zType = columnTypeImpl(sNC, p);
			pCol->affinity = (sbyte)(sqlite3ExprAffinity(p));
			if ((zType) != null)
			{
				m = (long)(sqlite3Strlen30(zType));
				n = (long)(sqlite3Strlen30(pCol->zCnName));
				pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, (ulong)(n + m + 2));
				if ((pCol->zCnName) != null)
				{
					CRuntime.memcpy(&pCol->zCnName[n + 1], zType, (ulong)(m + 1));
					pCol->colFlags |= (ushort)(0x0004);
				}
				else
				{
					pCol->colFlags &= (ushort)(~(0x0004 | 0x0200));
				}
			}

			if ((pCol->affinity) <= (0x40))
				pCol->affinity = (sbyte)(aff);
			pColl = sqlite3ExprCollSeq(pParse, p);
			if ((pColl) != null)
			{
				sqlite3ColumnSetColl(db, pCol, pColl.zName);
			}
		}

		pTab.szTabRow = (short)(1);
	}
	public static void sqlite3SelectAddTypeInfo(Parse pParse, Select pSelect)
	{
		Walker w = new Walker();
		w.xSelectCallback = sqlite3SelectWalkNoop;
		w.xSelectCallback2 = selectAddSubqueryTypeInfo;
		w.xExprCallback = sqlite3ExprWalkNoop;
		w.pParse = pParse;
		sqlite3WalkSelect(w, pSelect);
	}
	public static void sqlite3SelectExpand(Parse pParse, Select pSelect)
	{
		Walker w = new Walker();
		w.xExprCallback = sqlite3ExprWalkNoop;
		w.pParse = pParse;
		if ((pParse.hasCompound) != 0)
		{
			w.xSelectCallback = convertCompoundSelectToSubquery;
			w.xSelectCallback2 = null;
			sqlite3WalkSelect(w, pSelect);
		}

		w.xSelectCallback = selectExpander;
		w.xSelectCallback2 = sqlite3SelectPopWith;
		w.eCode = (ushort)(0);
		sqlite3WalkSelect(w, pSelect);
	}
	public static Select sqlite3SelectNew(Parse pParse, ExprList pEList, SrcList pSrc, Expr pWhere, ExprList pGroupBy, Expr pHaving, ExprList pOrderBy, uint selFlags, Expr pLimit)
	{
		Select pNew; Select pAllocated;
		Select standin = new Select();
		pAllocated = pNew = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Select)));
		if ((pNew) == (null))
		{
			pNew = standin;
		}

		if ((pEList) == (null))
		{
			pEList = sqlite3ExprListAppend(pParse, null, sqlite3Expr(pParse.db, (int)(180), null));
		}

		pNew.pEList = pEList;
		pNew.op = (byte)(138);
		pNew.selFlags = (uint)(selFlags);
		pNew.iLimit = (int)(0);
		pNew.iOffset = (int)(0);
		pNew.selId = (uint)(++pParse.nSelect);
		pNew.addrOpenEphm[0] = (int)(-1);
		pNew.addrOpenEphm[1] = (int)(-1);
		pNew.nSelectRow = (short)(0);
		if ((pSrc) == (null))
			pSrc = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(SrcList)));
		pNew.pSrc = pSrc;
		pNew.pWhere = pWhere;
		pNew.pGroupBy = pGroupBy;
		pNew.pHaving = pHaving;
		pNew.pOrderBy = pOrderBy;
		pNew.pPrior = null;
		pNew.pNext = null;
		pNew.pLimit = pLimit;
		pNew.pWith = null;
		pNew.pWin = null;
		pNew.pWinDefn = null;
		if ((pParse.db.mallocFailed) != 0)
		{
			clearSelect(pParse.db, pNew, (int)(pNew != standin));
			pAllocated = null;
		}
		else
		{
		}

		return pAllocated;
	}
	public static void sqlite3SelectPrep(Parse pParse, Select p, NameContext pOuterNC)
	{
		if ((pParse.db.mallocFailed) != 0)
			return;
		if ((p.selFlags & 0x0000080) != 0)
			return;
		sqlite3SelectExpand(pParse, p);
		if ((pParse.nErr) != 0)
			return;
		sqlite3ResolveSelectNames(pParse, p, pOuterNC);
		if ((pParse.nErr) != 0)
			return;
		sqlite3SelectAddTypeInfo(pParse, p);
	}
	public static void sqlite3SelectWrongNumTermsError(Parse pParse, Select p)
	{
		if ((p.selFlags & 0x0000200) != 0)
		{
			sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
		}
		else
		{
			sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s do not have the same number of result columns", sqlite3SelectOpName((int)(p.op)));
		}
	}
	public static SrcList sqlite3SrcListAppend(Parse pParse, SrcList pList, Token* pTable, Token* pDatabase)
	{
		SrcItem pItem;
		sqlite3 db;
		db = pParse.db;
		if ((pList) == (null))
		{
			pList = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(SrcList)));
			if ((pList) == (null))
				return null;
			pList.nAlloc = (uint)(1);
			pList.nSrc = (int)(1);
			CRuntime.memset(pList.a[0], (int)(0), (ulong)(sizeof(SrcItem)));
			pList.a[0].iCursor = (int)(-1);
		}
		else
		{
			SrcList pNew = sqlite3SrcListEnlarge(pParse, pList, (int)(1), (int)(pList.nSrc));
			if ((pNew) == (null))
			{
				sqlite3SrcListDelete(db, pList);
				return null;
			}
			else
			{
				pList = pNew;
			}
		}

		pItem = pList.a[pList.nSrc - 1];
		if (((pDatabase) != null) && ((pDatabase->z) == (null)))
		{
			pDatabase = null;
		}

		if ((pDatabase) != null)
		{
			pItem.zName = sqlite3NameFromToken(db, pDatabase);
			pItem.zDatabase = sqlite3NameFromToken(db, pTable);
		}
		else
		{
			pItem.zName = sqlite3NameFromToken(db, pTable);
			pItem.zDatabase = null;
		}

		return pList;
	}
	public static SrcList sqlite3SrcListAppendFromTerm(Parse pParse, SrcList p, Token* pTable, Token* pDatabase, Token* pAlias, Select pSubquery, Expr pOn, IdList* pUsing)
	{
		SrcItem pItem;
		sqlite3 db = pParse.db;
		if ((p == null) && (((pOn) != null) || ((pUsing) != null)))
		{
			sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s", (pOn ? "ON" : "USING"));
			goto append_from_error;
		}

		p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);
		if ((p) == (null))
		{
			goto append_from_error;
		}

		pItem = p.a[p.nSrc - 1];
		if (((pParse.eParseMode) >= (2)) && ((pItem.zName) != null))
		{
			Token* pToken = (((pDatabase) != null) && ((pDatabase->z) != null)) ? pDatabase : pTable;
			sqlite3RenameTokenMap(pParse, pItem.zName, pToken);
		}

		if ((pAlias->n) != 0)
		{
			pItem.zAlias = sqlite3NameFromToken(db, pAlias);
		}

		pItem.pSelect = pSubquery;
		pItem.pOn = pOn;
		pItem.pUsing = pUsing;
		return p;
	append_from_error:
		;
		sqlite3ExprDelete(db, pOn);
		sqlite3IdListDelete(db, pUsing);
		sqlite3SelectDelete(db, pSubquery);
		return null;
	}
	public static SrcList sqlite3SrcListAppendList(Parse pParse, SrcList p1, SrcList p2)
	{
		if ((p2) != null)
		{
			SrcList pNew = sqlite3SrcListEnlarge(pParse, p1, (int)(p2.nSrc), (int)(1));
			if ((pNew) == (null))
			{
				sqlite3SrcListDelete(pParse.db, p2);
			}
			else
			{
				p1 = pNew;
				CRuntime.memcpy(p1.a[1], p2.a, (ulong)(p2.nSrc * sizeof(SrcItem)));
				sqlite3DbFree(pParse.db, p2);
			}
		}

		return p1;
	}
	public static void sqlite3SrcListAssignCursors(Parse pParse, SrcList pList)
	{
		int i = 0;
		SrcItem pItem;
		if ((pList) != null)
		{
			for (i = (int)(0), pItem = pList.a; (i) < (pList.nSrc); i++, pItem++)
			{
				if ((pItem.iCursor) >= (0))
					continue;
				pItem.iCursor = (int)(pParse.nTab++);
				if ((pItem.pSelect) != null)
				{
					sqlite3SrcListAssignCursors(pParse, pItem.pSelect.pSrc);
				}
			}
		}
	}
	public static SrcList sqlite3SrcListEnlarge(Parse pParse, SrcList pSrc, int nExtra, int iStart)
	{
		int i = 0;
		if (((uint)(pSrc.nSrc) + nExtra) > (pSrc.nAlloc))
		{
			SrcList pNew;
			long nAlloc = (long)(2 * (long)(pSrc.nSrc) + nExtra);
			sqlite3 db = pParse.db;
			if ((pSrc.nSrc + nExtra) >= (200))
			{
				sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d", (int)(200));
				return null;
			}

			if ((nAlloc) > (200))
				nAlloc = (long)(200);
			pNew = sqlite3DbRealloc(db, pSrc, (ulong)(sizeof(SrcList) + (nAlloc - 1) * sizeof(SrcItem)));
			if ((pNew) == (null))
			{
				return null;
			}

			pSrc = pNew;
			pSrc.nAlloc = (uint)(nAlloc);
		}

		for (i = (int)(pSrc.nSrc - 1); (i) >= (iStart); i--)
		{
			pSrc.a[i + nExtra] = (SrcItem)(pSrc.a[i]);
		}

		pSrc.nSrc += (int)(nExtra);
		CRuntime.memset(pSrc.a[iStart], (int)(0), (ulong)(sizeof(SrcItem) * nExtra));
		for (i = (int)(iStart); (i) < (iStart + nExtra); i++)
		{
			pSrc.a[i].iCursor = (int)(-1);
		}

		return pSrc;
	}
	public static void sqlite3SrcListFuncArgs(Parse pParse, SrcList p, ExprList pList)
	{
		if ((p) != null)
		{
			SrcItem pItem = p.a[p.nSrc - 1];
			pItem.u1.pFuncArg = pList;
			pItem.fg.isTabFunc = (uint)(1);
		}
		else
		{
			sqlite3ExprListDelete(pParse.db, pList);
		}
	}
	public static void sqlite3SrcListIndexedBy(Parse pParse, SrcList p, Token* pIndexedBy)
	{
		if (((p) != null) && ((pIndexedBy->n) > (0)))
		{
			SrcItem pItem;
			pItem = p.a[p.nSrc - 1];
			if (((pIndexedBy->n) == (1)) && (pIndexedBy->z == null))
			{
				pItem.fg.notIndexed = (uint)(1);
			}
			else
			{
				pItem.u1.zIndexedBy = sqlite3NameFromToken(pParse.db, pIndexedBy);
				pItem.fg.isIndexedBy = (uint)(1);
			}
		}
	}
	public static Table sqlite3SrcListLookup(Parse pParse, SrcList pSrc)
	{
		SrcItem pItem = pSrc.a;
		Table pTab;
		pTab = sqlite3LocateTableItem(pParse, (uint)(0), pItem);
		sqlite3DeleteTable(pParse.db, pItem.pTab);
		pItem.pTab = pTab;
		if ((pTab) != null)
		{
			pTab.nTabRef++;
			if (((pItem.fg.isIndexedBy) != 0) && ((sqlite3IndexedByLookup(pParse, pItem)) != 0))
			{
				pTab = null;
			}
		}

		return pTab;
	}
	public static void sqlite3StartTable(Parse pParse, Token* pName1, Token* pName2, int isTemp, int isView, int isVirtual, int noErr)
	{
		Table pTable;
		sbyte* zName = null;
		sqlite3 db = pParse.db;
		Vdbe v;
		int iDb = 0;
		Token* pName;
		if (((db.init.busy) != 0) && ((db.init.newTnum) == (1)))
		{
			iDb = (int)(db.init.iDb);
			zName = sqlite3DbStrDup(db, (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"));
			pName = pName1;
		}
		else
		{
			iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pName));
			if ((iDb) < (0))
				return;
			if ((((0 == 0) && ((isTemp) != 0)) && ((pName2->n) > (0))) && (iDb != 1))
			{
				sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
				return;
			}

			if ((0 == 0) && ((isTemp) != 0))
				iDb = (int)(1);
			zName = sqlite3NameFromToken(db, pName);
			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameTokenMap(pParse, (void*)(zName), pName);
			}
		}

		pParse.sNameToken = (Token)(*pName);
		if ((zName) == (null))
			return;
		if ((sqlite3CheckObjectName(pParse, zName, (isView) != 0 ? "view" : "table", zName)) != 0)
		{
			goto begin_table_error;
		}

		if ((db.init.iDb) == (1))
			isTemp = (int)(1);
		{
			sbyte* zDb = db.aDb[iDb].zDbSName;
			if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) && ((isTemp) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
			{
				goto begin_table_error;
			}

			if ((isVirtual == 0) && ((sqlite3AuthCheck(pParse, (int)(sqlite3StartTable_aCode[isTemp + 2 * isView]), zName, null, zDb)) != 0))
			{
				goto begin_table_error;
			}
		}

		if (!(pParse.eParseMode != 0))
		{
			sbyte* zDb = db.aDb[iDb].zDbSName;
			if (0 != sqlite3ReadSchema(pParse))
			{
				goto begin_table_error;
			}

			pTable = sqlite3FindTable(db, zName, zDb);
			if ((pTable) != null)
			{
				if (noErr == 0)
				{
					sqlite3ErrorMsg(pParse, "%s %T already exists", ((((pTable).eTabType) == (2)) ? "view" : "table"), pName);
				}
				else
				{
					sqlite3CodeVerifySchema(pParse, (int)(iDb));
					sqlite3ForceNotReadOnly(pParse);
				}

				goto begin_table_error;
			}

			if (sqlite3FindIndex(db, zName, zDb) != null)
			{
				sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
				goto begin_table_error;
			}
		}

		pTable = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
		if ((pTable) == (null))
		{
			pParse.rc = (int)(7);
			pParse.nErr++;
			goto begin_table_error;
		}

		pTable.zName = zName;
		pTable.iPKey = (short)(-1);
		pTable.pSchema = db.aDb[iDb].pSchema;
		pTable.nTabRef = (uint)(1);
		pTable.nRowLogEst = (short)(200);
		pParse.pNewTable = pTable;
		if ((db.init.busy == 0) && ((v = sqlite3GetVdbe(pParse)) != null))
		{
			int addr1 = 0;
			int fileFormat = 0;
			int reg1 = 0;
			int reg2 = 0;
			int reg3 = 0;
			sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
			if ((isVirtual) != 0)
			{
				sqlite3VdbeAddOp0(v, (int)(169));
			}

			reg1 = (int)(pParse.regRowid = (int)(++pParse.nMem));
			reg2 = (int)(pParse.regRoot = (int)(++pParse.nMem));
			reg3 = (int)(++pParse.nMem);
			sqlite3VdbeAddOp3(v, (int)(98), (int)(iDb), (int)(reg3), (int)(2));
			sqlite3VdbeUsesBtree(v, (int)(iDb));
			addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(reg3)));
			fileFormat = (int)((db.flags & 0x00000002) != 0 ? 1 : 4);
			sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(2), (int)(fileFormat));
			sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(5), (int)((db).enc));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			if (((isView) != 0) || ((isVirtual) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(reg2));
			}
			else
			{
				pParse.u1.addrCrTab = (int)(sqlite3VdbeAddOp3(v, (int)(146), (int)(iDb), (int)(reg2), (int)(1)));
			}

			sqlite3OpenSchemaTable(pParse, (int)(iDb));
			sqlite3VdbeAddOp2(v, (int)(126), (int)(0), (int)(reg1));
			sqlite3VdbeAddOp4(v, (int)(76), (int)(6), (int)(reg3), (int)(0), sqlite3StartTable_nullRow, (int)(-1));
			sqlite3VdbeAddOp3(v, (int)(127), (int)(0), (int)(reg3), (int)(reg1));
			sqlite3VdbeChangeP5(v, (ushort)(0x08));
			sqlite3VdbeAddOp0(v, (int)(121));
		}

		return;
	begin_table_error:
		; pParse.checkSchema = (byte)(1);
		sqlite3DbFree(db, zName);
		return;
	}
	public static void sqlite3SubselectError(Parse pParse, int nActual, int nExpect)
	{
		if ((pParse.nErr) == (0))
		{
			sbyte* zFmt = "sub-select returns %d columns - expected %d";
			sqlite3ErrorMsg(pParse, zFmt, (int)(nActual), (int)(nExpect));
		}
	}
	public static void sqlite3TableLock(Parse pParse, int iDb, uint iTab, byte isWriteLock, sbyte* zName)
	{
		if ((iDb) == (1))
			return;
		if (sqlite3BtreeSharable(pParse.db.aDb[iDb].pBt) == 0)
			return;
		lockTable(pParse, (int)(iDb), (uint)(iTab), (byte)(isWriteLock), zName);
	}
	public static uint sqlite3TriggerColmask(Parse pParse, Trigger pTrigger, ExprList pChanges, int isNew, int tr_tm, Table pTab, int orconf)
	{
		int op = (int)(pChanges ? 129 : 128);
		uint mask = (uint)(0);
		Trigger p;
		for (p = pTrigger; p; p = p.pNext)
		{
			if ((((p.op) == (op)) && ((tr_tm & p.tr_tm) != 0)) && ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
			{
				if ((p.bReturning) != 0)
				{
					mask = (uint)(0xffffffff);
				}
				else
				{
					TriggerPrg pPrg;
					pPrg = getRowTrigger(pParse, p, pTab, (int)(orconf));
					if ((pPrg) != null)
					{
						mask |= (uint)(pPrg.aColmask[isNew]);
					}
				}
			}
		}

		return (uint)(mask);
	}
	public static TriggerStep sqlite3TriggerDeleteStep(Parse pParse, Token* pTableName, Expr pWhere, sbyte* zStart, sbyte* zEnd)
	{
		sqlite3 db = pParse.db;
		TriggerStep pTriggerStep;
		pTriggerStep = triggerStepAllocate(pParse, (byte)(128), pTableName, zStart, zEnd);
		if ((pTriggerStep) != null)
		{
			if (((pParse.eParseMode) >= (2)))
			{
				pTriggerStep.pWhere = pWhere;
				pWhere = null;
			}
			else
			{
				pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001));
			}

			pTriggerStep.orconf = (byte)(11);
		}

		sqlite3ExprDelete(db, pWhere);
		return pTriggerStep;
	}
	public static TriggerStep sqlite3TriggerInsertStep(Parse pParse, Token* pTableName, IdList* pColumn, Select pSelect, byte orconf, Upsert pUpsert, sbyte* zStart, sbyte* zEnd)
	{
		sqlite3 db = pParse.db;
		TriggerStep pTriggerStep;
		pTriggerStep = triggerStepAllocate(pParse, (byte)(127), pTableName, zStart, zEnd);
		if ((pTriggerStep) != null)
		{
			if (((pParse.eParseMode) >= (2)))
			{
				pTriggerStep.pSelect = pSelect;
				pSelect = null;
			}
			else
			{
				pTriggerStep.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001));
			}

			pTriggerStep.pIdList = pColumn;
			pTriggerStep.pUpsert = pUpsert;
			pTriggerStep.orconf = (byte)(orconf);
			if ((pUpsert) != null)
			{
				sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget);
			}
		}
		else
		{
			sqlite3IdListDelete(db, pColumn);
			sqlite3UpsertDelete(db, pUpsert);
		}

		sqlite3SelectDelete(db, pSelect);
		return pTriggerStep;
	}
	public static Trigger sqlite3TriggerList(Parse pParse, Table pTab)
	{
		Schema pTmpSchema;
		Trigger pList;
		HashElem* p;
		if ((pParse.disableTriggers) != 0)
		{
			return null;
		}

		pTmpSchema = pParse.db.aDb[1].pSchema;
		p = ((&pTmpSchema.trigHash)->first);
		pList = pTab.pTrigger;
		while ((p) != null)
		{
			Trigger pTrig = (Trigger)((p)->data);
			if (((((pTrig.pTabSchema) == (pTab.pSchema)) && ((pTrig.table) != null)) && ((0) == (sqlite3StrICmp(pTrig.table, pTab.zName)))) && (pTrig.pTabSchema != pTmpSchema))
			{
				pTrig.pNext = pList;
				pList = pTrig;
			}
			else if (((pTrig.op) == (150)) && ((pParse.db.pVtabCtx) == (null)))
			{
				pTrig.table = pTab.zName;
				pTrig.pTabSchema = pTab.pSchema;
				pTrig.pNext = pList;
				pList = pTrig;
			}

			p = ((p)->next);
		}

		return pList;
	}
	public static Trigger sqlite3TriggersExist(Parse pParse, Table pTab, int op, ExprList pChanges, int* pMask)
	{
		int mask = (int)(0);
		Trigger pList = null;
		Trigger p;
		pList = sqlite3TriggerList(pParse, pTab);
		if (pList != null)
		{
			p = pList;
			if (((pParse.db.flags & 0x00040000) == (0)) && (pTab.pTrigger != null))
			{
				if ((pList) == (pTab.pTrigger))
				{
					pList = null;
					goto exit_triggers_exist;
				}

				while (((p.pNext) != null) && (p.pNext != pTab.pTrigger))
				{
					p = p.pNext;
				}

				p.pNext = null;
				p = pList;
			}

			do
			{
				if (((p.op) == (op)) && ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
				{
					mask |= (int)(p.tr_tm);
				}
				else if ((p.op) == (150))
				{
					p.op = (byte)(op);
					if ((((pTab).eTabType) == (1)))
					{
						if (op != 127)
						{
							sqlite3ErrorMsg(pParse, "%s RETURNING is not available on virtual tables", (op) == (128) ? "DELETE" : "UPDATE");
						}

						p.tr_tm = (byte)(1);
					}
					else
					{
						p.tr_tm = (byte)(2);
					}

					mask |= (int)(p.tr_tm);
				}
				else if (((((p.bReturning) != 0) && ((p.op) == (127))) && ((op) == (129))) && (((pParse).pToplevel) == (null)))
				{
					mask |= (int)(p.tr_tm);
				}

				p = p.pNext;
			}
			while ((p) != null);
		}

	exit_triggers_exist:
		; if ((pMask) != null) { *pMask = (int)(mask); }
		return ((mask) != 0 ? pList : null);
	}
	public static SrcList sqlite3TriggerStepSrc(Parse pParse, TriggerStep pStep)
	{
		sqlite3 db = pParse.db;
		SrcList pSrc;
		sbyte* zName = sqlite3DbStrDup(db, pStep.zTarget);
		pSrc = sqlite3SrcListAppend(pParse, null, null, null);
		if ((pSrc) != null)
		{
			Schema pSchema = pStep.pTrig.pSchema;
			pSrc.a[0].zName = zName;
			if (pSchema != db.aDb[1].pSchema)
			{
				pSrc.a[0].pSchema = pSchema;
			}

			if ((pStep.pFrom) != null)
			{
				SrcList pDup = sqlite3SrcListDup(db, pStep.pFrom, (int)(0));
				pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);
			}
		}
		else
		{
			sqlite3DbFree(db, zName);
		}

		return pSrc;
	}
	public static TriggerStep sqlite3TriggerUpdateStep(Parse pParse, Token* pTableName, SrcList pFrom, ExprList pEList, Expr pWhere, byte orconf, sbyte* zStart, sbyte* zEnd)
	{
		sqlite3 db = pParse.db;
		TriggerStep pTriggerStep;
		pTriggerStep = triggerStepAllocate(pParse, (byte)(129), pTableName, zStart, zEnd);
		if ((pTriggerStep) != null)
		{
			if (((pParse.eParseMode) >= (2)))
			{
				pTriggerStep.pExprList = pEList;
				pTriggerStep.pWhere = pWhere;
				pTriggerStep.pFrom = pFrom;
				pEList = null;
				pWhere = null;
				pFrom = null;
			}
			else
			{
				pTriggerStep.pExprList = sqlite3ExprListDup(db, pEList, (int)(0x0001));
				pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001));
				pTriggerStep.pFrom = sqlite3SrcListDup(db, pFrom, (int)(0x0001));
			}

			pTriggerStep.orconf = (byte)(orconf);
		}

		sqlite3ExprListDelete(db, pEList);
		sqlite3ExprDelete(db, pWhere);
		sqlite3SrcListDelete(db, pFrom);
		return pTriggerStep;
	}
	public static int sqlite3TwoPartName(Parse pParse, Token* pName1, Token* pName2, Token** pUnqual)
	{
		int iDb = 0;
		sqlite3 db = pParse.db;
		if ((pName2->n) > (0))
		{
			if ((db.init.busy) != 0)
			{
				sqlite3ErrorMsg(pParse, "corrupt database");
				return (int)(-1);
			}

			*pUnqual = pName2;
			iDb = (int)(sqlite3FindDb(db, pName1));
			if ((iDb) < (0))
			{
				sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
				return (int)(-1);
			}
		}
		else
		{
			iDb = (int)(db.init.iDb);
			*pUnqual = pName1;
		}

		return (int)(iDb);
	}
	public static void sqlite3UniqueConstraint(Parse pParse, int onError, Index pIdx)
	{
		sbyte* zErr;
		int j = 0;
		sqlite3_str errMsg = new sqlite3_str();
		Table pTab = pIdx.pTable;
		sqlite3StrAccumInit(errMsg, pParse.db, null, (int)(0), (int)(pParse.db.aLimit[0]));
		if ((pIdx.aColExpr) != null)
		{
			sqlite3_str_appendf(errMsg, "index '%q'", pIdx.zName);
		}
		else
		{
			for (j = (int)(0); (j) < (pIdx.nKeyCol); j++)
			{
				sbyte* zCol;
				zCol = pTab.aCol[pIdx.aiColumn[j]].zCnName;
				if ((j) != 0)
					sqlite3_str_append(errMsg, ", ", (int)(2));
				sqlite3_str_appendall(errMsg, pTab.zName);
				sqlite3_str_append(errMsg, ".", (int)(1));
				sqlite3_str_appendall(errMsg, zCol);
			}
		}

		zErr = sqlite3StrAccumFinish(errMsg);
		sqlite3HaltConstraint(pParse, (int)((((pIdx).idxType) == (2)) ? (19 | (6 << 8)) : (19 | (8 << 8))), (int)(onError), zErr, (sbyte)(-7), (byte)(2));
	}
	public static void sqlite3Update(Parse pParse, SrcList pTabList, ExprList pChanges, Expr pWhere, int onError, ExprList pOrderBy, Expr pLimit, Upsert pUpsert)
	{
		int i = 0; int j = 0; int k = 0;
		Table pTab;
		int addrTop = (int)(0);
		WhereInfo pWInfo = null;
		Vdbe v;
		Index pIdx;
		Index pPk;
		int nIdx = 0;
		int nAllIdx = 0;
		int iBaseCur = 0;
		int iDataCur = 0;
		int iIdxCur = 0;
		sqlite3 db;
		int* aRegIdx = null;
		int* aXRef = null;
		byte* aToOpen;
		byte chngPk = 0;
		byte chngRowid = 0;
		byte chngKey = 0;
		Expr pRowidExpr = null;
		int iRowidExpr = (int)(-1);
		AuthContext sContext = new AuthContext();
		NameContext sNC = new NameContext();
		int iDb = 0;
		int eOnePass = 0;
		int hasFK = 0;
		int labelBreak = 0;
		int labelContinue = 0;
		int flags = 0;
		int isView = 0;
		Trigger pTrigger;
		int tmask = 0;
		int newmask = 0;
		int iEph = (int)(0);
		int nKey = (int)(0);
		int* aiCurOnePass = stackalloc int[2];
		int addrOpen = (int)(0);
		int iPk = (int)(0);
		short nPk = (short)(0);
		int bReplace = (int)(0);
		int bFinishSeek = (int)(1);
		int nChangeFrom = (int)(0);
		int regRowCount = (int)(0);
		int regOldRowid = (int)(0);
		int regNewRowid = (int)(0);
		int regNew = (int)(0);
		int regOld = (int)(0);
		int regRowSet = (int)(0);
		int regKey = (int)(0);
		CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(AuthContext)));
		db = pParse.db;
		if ((pParse.nErr) != 0)
		{
			goto update_cleanup;
		}

		pTab = sqlite3SrcListLookup(pParse, pTabList);
		if ((pTab) == (null))
			goto update_cleanup;
		iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
		pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(129), pChanges, &tmask);
		isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
		nChangeFrom = (int)(((pTabList.nSrc) > (1)) ? pChanges.nExpr : 0);
		if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
		{
			goto update_cleanup;
		}

		if ((sqlite3IsReadOnly(pParse, pTab, (int)(tmask))) != 0)
		{
			goto update_cleanup;
		}

		iBaseCur = (int)(iDataCur = (int)(pParse.nTab++));
		iIdxCur = (int)(iDataCur + 1);
		pPk = (((pTab).tabFlags & 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
		for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
		{
			if ((pPk) == (pIdx))
			{
				iDataCur = (int)(pParse.nTab);
			}

			pParse.nTab++;
		}

		if ((pUpsert) != null)
		{
			iDataCur = (int)(pUpsert.iDataCur);
			iIdxCur = (int)(pUpsert.iIdxCur);
			pParse.nTab = (int)(iBaseCur);
		}

		pTabList.a[0].iCursor = (int)(iDataCur);
		aXRef = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (pTab.nCol + nIdx + 1) + nIdx + 2));
		if ((aXRef) == (null))
			goto update_cleanup;
		aRegIdx = aXRef + pTab.nCol;
		aToOpen = (byte*)(aRegIdx + nIdx + 1);
		CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
		aToOpen[nIdx + 1] = (byte)(0);
		for (i = (int)(0); (i) < (pTab.nCol); i++)
		{
			aXRef[i] = (int)(-1);
		}

		CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
		sNC.pParse = pParse;
		sNC.pSrcList = pTabList;
		sNC.uNC.pUpsert = pUpsert;
		sNC.ncFlags = (int)(0x000200);
		v = sqlite3GetVdbe(pParse);
		if ((v) == (null))
			goto update_cleanup;
		chngRowid = (byte)(chngPk = (byte)(0));
		for (i = (int)(0); (i) < (pChanges.nExpr); i++)
		{
			byte hCol = (byte)(sqlite3StrIHash(pChanges.a[i].zEName));
			if (((nChangeFrom) == (0)) && ((sqlite3ResolveExprNames(sNC, pChanges.a[i].pExpr)) != 0))
			{
				goto update_cleanup;
			}

			for (j = (int)(0); (j) < (pTab.nCol); j++)
			{
				if (((pTab.aCol[j].hName) == (hCol)) && ((sqlite3StrICmp(pTab.aCol[j].zCnName, pChanges.a[i].zEName)) == (0)))
				{
					if ((j) == (pTab.iPKey))
					{
						chngRowid = (byte)(1);
						pRowidExpr = pChanges.a[i].pExpr;
						iRowidExpr = (int)(i);
					}
					else if (((pPk) != null) && ((pTab.aCol[j].colFlags & 0x0001) != 0))
					{
						chngPk = (byte)(1);
					}
					else if ((pTab.aCol[j].colFlags & 0x0060) != 0)
					{
						sqlite3ErrorMsg(pParse, "cannot UPDATE generated column \"%s\"", pTab.aCol[j].zCnName);
						goto update_cleanup;
					}

					aXRef[j] = (int)(i);
					break;
				}
			}

			if ((j) >= (pTab.nCol))
			{
				if (((pPk) == (null)) && ((sqlite3IsRowid(pChanges.a[i].zEName)) != 0))
				{
					j = (int)(-1);
					chngRowid = (byte)(1);
					pRowidExpr = pChanges.a[i].pExpr;
					iRowidExpr = (int)(i);
				}
				else
				{
					sqlite3ErrorMsg(pParse, "no such column: %s", pChanges.a[i].zEName);
					pParse.checkSchema = (byte)(1);
					goto update_cleanup;
				}
			}

			{
				int rc = 0;
				rc = (int)(sqlite3AuthCheck(pParse, (int)(23), pTab.zName, (j) < (0) ? "ROWID" : pTab.aCol[j].zCnName, db.aDb[iDb].zDbSName));
				if ((rc) == (1))
				{
					goto update_cleanup;
				}
				else if ((rc) == (2))
				{
					aXRef[j] = (int)(-1);
				}
			}
		}

		chngKey = (byte)(chngRowid + chngPk);
		if ((pTab.tabFlags & 0x00000060) != 0)
		{
			int bProgress = 0;
			do
			{
				bProgress = (int)(0);
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					if ((aXRef[i]) >= (0))
						continue;
					if ((pTab.aCol[i].colFlags & 0x0060) == (0))
						continue;
					if ((sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &pTab.aCol[i]), aXRef, (int)(chngRowid))) != 0)
					{
						aXRef[i] = (int)(99999);
						bProgress = (int)(1);
					}
				}
			}
			while ((bProgress) != 0);
		}

		pTabList.a[0].colUsed = (ulong)((((pTab).eTabType) == (1)) ? ((ulong)(-1)) : 0);
		hasFK = (int)(sqlite3FkRequired(pParse, pTab, aXRef, (int)(chngKey)));
		if ((onError) == (5))
			bReplace = (int)(1);
		for (nAllIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nAllIdx++)
		{
			int reg = 0;
			if (((((chngKey) != 0) || ((hasFK) > (1))) || ((pIdx) == (pPk))) || ((indexWhereClauseMightChange(pIdx, aXRef, (int)(chngRowid))) != 0))
			{
				reg = (int)(++pParse.nMem);
				pParse.nMem += (int)(pIdx.nColumn);
			}
			else
			{
				reg = (int)(0);
				for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
				{
					if ((indexColumnIsBeingUpdated(pIdx, (int)(i), aXRef, (int)(chngRowid))) != 0)
					{
						reg = (int)(++pParse.nMem);
						pParse.nMem += (int)(pIdx.nColumn);
						if (((onError) == (11)) && ((pIdx.onError) == (5)))
						{
							bReplace = (int)(1);
						}

						break;
					}
				}
			}

			if ((reg) == (0))
				aToOpen[nAllIdx + 1] = (byte)(0);
			aRegIdx[nAllIdx] = (int)(reg);
		}

		aRegIdx[nAllIdx] = (int)(++pParse.nMem);
		if ((bReplace) != 0)
		{
			CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
		}

		if ((pParse.nested) == (0))
			sqlite3VdbeCountChanges(v);
		sqlite3BeginWriteOperation(pParse, (((pTrigger) != null) || ((hasFK) != 0) ? 1 : 0), (int)(iDb));
		if (!(((pTab).eTabType) == (1)))
		{
			regRowSet = (int)(aRegIdx[nAllIdx]);
			regOldRowid = (int)(regNewRowid = (int)(++pParse.nMem));
			if ((((chngPk) != 0) || ((pTrigger) != null)) || ((hasFK) != 0))
			{
				regOld = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(pTab.nCol);
			}

			if ((((chngKey) != 0) || ((pTrigger) != null)) || ((hasFK) != 0))
			{
				regNewRowid = (int)(++pParse.nMem);
			}

			regNew = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(pTab.nCol);
		}

		if ((isView) != 0)
		{
			sqlite3AuthContextPush(pParse, sContext, pTab.zName);
		}

		if (((nChangeFrom) == (0)) && ((isView) != 0))
		{
			sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, (int)(iDataCur));
			pOrderBy = null;
			pLimit = null;
		}

		if (((nChangeFrom) == (0)) && ((sqlite3ResolveExprNames(sNC, pWhere)) != 0))
		{
			goto update_cleanup;
		}

		if ((((pTab).eTabType) == (1)))
		{
			updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, (int)(onError));
			goto update_cleanup;
		}

		labelContinue = (int)(labelBreak = (int)(sqlite3VdbeMakeLabel(pParse)));
		if ((((((db.flags & ((ulong)(0x00001) << 32)) != 0) && (pParse.pTriggerTab == null)) && (pParse.nested == 0)) && (pParse.bReturning == 0)) && ((pUpsert) == (null)))
		{
			regRowCount = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regRowCount));
		}

		if (((nChangeFrom) == (0)) && (((pTab).tabFlags & 0x00000080) == (0)))
		{
			sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(regRowSet), (int)(regOldRowid));
			iEph = (int)(pParse.nTab++);
			addrOpen = (int)(sqlite3VdbeAddOp3(v, (int)(116), (int)(iEph), (int)(0), (int)(regRowSet)));
		}
		else
		{
			nPk = (short)(pPk ? pPk.nKeyCol : 0);
			iPk = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nPk);
			pParse.nMem += (int)(nChangeFrom);
			regKey = (int)(++pParse.nMem);
			if ((pUpsert) == (null))
			{
				int nEphCol = (int)(nPk + nChangeFrom + ((isView) != 0 ? pTab.nCol : 0));
				iEph = (int)(pParse.nTab++);
				if ((pPk) != null)
					sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(iPk), (int)(iPk + nPk - 1));
				addrOpen = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iEph), (int)(nEphCol)));
				if ((pPk) != null)
				{
					KeyInfo pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);
					if ((pKeyInfo) != null)
					{
						pKeyInfo.nAllField = (ushort)(nEphCol);
						sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
					}
				}

				if ((nChangeFrom) != 0)
				{
					updateFromSelect(pParse, (int)(iEph), pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit);
					if ((isView) != 0)
						iDataCur = (int)(iEph);
				}
			}
		}

		if ((nChangeFrom) != 0)
		{
			sqlite3MultiWrite(pParse);
			eOnePass = (int)(0);
			nKey = (int)(nPk);
			regKey = (int)(iPk);
		}
		else
		{
			if ((pUpsert) != null)
			{
				pWInfo = null;
				eOnePass = (int)(1);
				sqlite3ExprIfFalse(pParse, pWhere, (int)(labelBreak), (int)(0x10));
				bFinishSeek = (int)(0);
			}
			else
			{
				flags = (int)(0x0004);
				if (((((pParse.nested == 0) && (pTrigger == null)) && (hasFK == 0)) && (chngKey == 0)) && (bReplace == 0))
				{
					flags |= (int)(0x0008);
				}

				pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, null, null, null, (ushort)(flags), (int)(iIdxCur));
				if ((pWInfo) == (null))
					goto update_cleanup;
				eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aiCurOnePass));
				bFinishSeek = (int)(sqlite3WhereUsesDeferredSeek(pWInfo));
				if (eOnePass != 1)
				{
					sqlite3MultiWrite(pParse);
					if ((eOnePass) == (2))
					{
						int iCur = (int)(aiCurOnePass[1]);
						if ((((iCur) >= (0)) && (iCur != iDataCur)) && ((aToOpen[iCur - iBaseCur]) != 0))
						{
							eOnePass = (int)(0);
						}
					}
				}
			}

			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				sqlite3VdbeAddOp2(v, (int)(134), (int)(iDataCur), (int)(regOldRowid));
				if ((eOnePass) == (0))
				{
					aRegIdx[nAllIdx] = (int)(++pParse.nMem);
					sqlite3VdbeAddOp3(v, (int)(127), (int)(iEph), (int)(regRowSet), (int)(regOldRowid));
				}
				else
				{
					if ((addrOpen) != 0)
						sqlite3VdbeChangeToNoop(v, (int)(addrOpen));
				}
			}
			else
			{
				for (i = (int)(0); (i) < (nPk); i++)
				{
					sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(pPk.aiColumn[i]), (int)(iPk + i));
				}

				if ((eOnePass) != 0)
				{
					if ((addrOpen) != 0)
						sqlite3VdbeChangeToNoop(v, (int)(addrOpen));
					nKey = (int)(nPk);
					regKey = (int)(iPk);
				}
				else
				{
					sqlite3VdbeAddOp4(v, (int)(96), (int)(iPk), (int)(nPk), (int)(regKey), sqlite3IndexAffinityStr(db, pPk), (int)(nPk));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iEph), (int)(regKey), (int)(iPk), (int)(nPk));
				}
			}
		}

		if ((pUpsert) == (null))
		{
			if (((nChangeFrom) == (0)) && (eOnePass != 2))
			{
				sqlite3WhereEnd(pWInfo);
			}

			if (isView == 0)
			{
				int addrOnce = (int)(0);
				if (eOnePass != 0)
				{
					if ((aiCurOnePass[0]) >= (0))
						aToOpen[aiCurOnePass[0] - iBaseCur] = (byte)(0);
					if ((aiCurOnePass[1]) >= (0))
						aToOpen[aiCurOnePass[1] - iBaseCur] = (byte)(0);
				}

				if (((eOnePass) == (2)) && ((nIdx - ((aiCurOnePass[1]) >= (0))) > (0)))
				{
					addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				}

				sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0), (int)(iBaseCur), aToOpen, null, null);
				if ((addrOnce) != 0)
				{
					sqlite3VdbeJumpHereOrPopInst(v, (int)(addrOnce));
				}
			}

			if (eOnePass != 0)
			{
				if ((aiCurOnePass[0] != iDataCur) && (aiCurOnePass[1] != iDataCur))
				{
					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelBreak), (int)(regKey), (int)(nKey));
				}

				if (eOnePass != 1)
				{
					labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
				}

				sqlite3VdbeAddOp2(v, (int)(50), (int)(pPk ? regKey : regOldRowid), (int)(labelBreak));
			}
			else if (((pPk) != null) || ((nChangeFrom) != 0))
			{
				labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
				sqlite3VdbeAddOp2(v, (int)(38), (int)(iEph), (int)(labelBreak));
				addrTop = (int)(sqlite3VdbeCurrentAddr(v));
				if ((nChangeFrom) != 0)
				{
					if (isView == 0)
					{
						if ((pPk) != null)
						{
							for (i = (int)(0); (i) < (nPk); i++)
							{
								sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(i), (int)(iPk + i));
							}

							sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(iPk), (int)(nPk));
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(regOldRowid));
							sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
						}
					}
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(133), (int)(iEph), (int)(regKey));
					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(0));
				}
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(38), (int)(iEph), (int)(labelBreak));
				labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
				addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(regOldRowid)));
				sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
			}
		}

		if ((chngRowid) != 0)
		{
			if ((nChangeFrom) == (0))
			{
				sqlite3ExprCode(pParse, pRowidExpr, (int)(regNewRowid));
			}
			else
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(iRowidExpr), (int)(regNewRowid));
			}

			sqlite3VdbeAddOp1(v, (int)(15), (int)(regNewRowid));
		}

		if ((((chngPk) != 0) || ((hasFK) != 0)) || ((pTrigger) != null))
		{
			uint oldmask = (uint)((hasFK) != 0 ? sqlite3FkOldmask(pParse, pTab) : 0);
			oldmask |= (uint)(sqlite3TriggerColmask(pParse, pTrigger, pChanges, (int)(0), (int)(1 | 2), pTab, (int)(onError)));
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				uint colFlags = (uint)(pTab.aCol[i].colFlags);
				k = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + regOld);
				if ((((oldmask) == (0xffffffff)) || (((i) < (32)) && ((oldmask & (((uint)(1)) << (i))) != 0))) || ((colFlags & 0x0001) != 0))
				{
					sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
				}
			}

			if (((chngRowid) == (0)) && ((pPk) == (null)))
			{
				sqlite3VdbeAddOp2(v, (int)(79), (int)(regOldRowid), (int)(regNewRowid));
			}
		}

		newmask = (int)(sqlite3TriggerColmask(pParse, pTrigger, pChanges, (int)(1), (int)(1), pTab, (int)(onError)));
		for (i = (int)(0), k = (int)(regNew); (i) < (pTab.nCol); i++, k++)
		{
			if ((i) == (pTab.iPKey))
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
			}
			else if ((pTab.aCol[i].colFlags & 0x0060) != 0)
			{
				if ((pTab.aCol[i].colFlags & 0x0020) != 0)
					k--;
			}
			else
			{
				j = (int)(aXRef[i]);
				if ((j) >= (0))
				{
					if ((nChangeFrom) != 0)
					{
						int nOff = (int)((isView) != 0 ? pTab.nCol : nPk);
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(nOff + j), (int)(k));
					}
					else
					{
						sqlite3ExprCode(pParse, pChanges.a[j].pExpr, (int)(k));
					}
				}
				else if ((((0) == (tmask & 1)) || ((i) > (31))) || ((newmask & (((uint)(1)) << (i))) != 0))
				{
					sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
					bFinishSeek = (int)(0);
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
				}
			}
		}

		if ((pTab.tabFlags & 0x00000060) != 0)
		{
			sqlite3ComputeGeneratedColumns(pParse, (int)(regNew), pTab);
		}

		if ((tmask & 1) != 0)
		{
			sqlite3TableAffinity(v, pTab, (int)(regNew));
			sqlite3CodeRowTrigger(pParse, pTrigger, (int)(129), pChanges, (int)(1), pTab, (int)(regOldRowid), (int)(onError), (int)(labelContinue));
			if (isView == 0)
			{
				if ((pPk) != null)
				{
					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(nKey));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
				}

				for (i = (int)(0), k = (int)(regNew); (i) < (pTab.nCol); i++, k++)
				{
					if ((pTab.aCol[i].colFlags & 0x0060) != 0)
					{
						if ((pTab.aCol[i].colFlags & 0x0020) != 0)
							k--;
					}
					else if (((aXRef[i]) < (0)) && (i != pTab.iPKey))
					{
						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
					}
				}

				if ((pTab.tabFlags & 0x00000060) != 0)
				{
					sqlite3ComputeGeneratedColumns(pParse, (int)(regNew), pTab);
				}
			}
		}

		if (isView == 0)
		{
			sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, (int)(iDataCur), (int)(iIdxCur), (int)(regNewRowid), (int)(regOldRowid), (byte)(chngKey), (byte)(onError), (int)(labelContinue), &bReplace, aXRef, null);
			if (((bReplace) != 0) || ((chngKey) != 0))
			{
				if ((pPk) != null)
				{
					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(nKey));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
				}
			}

			if ((hasFK) != 0)
			{
				sqlite3FkCheck(pParse, pTab, (int)(regOldRowid), (int)(0), aXRef, (int)(chngKey));
			}

			sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), aRegIdx, (int)(-1));
			if ((bFinishSeek) != 0)
			{
				sqlite3VdbeAddOp1(v, (int)(142), (int)(iDataCur));
			}

			if (((hasFK) > (1)) || ((chngKey) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(129), (int)(iDataCur), (int)(0));
			}

			if ((hasFK) != 0)
			{
				sqlite3FkCheck(pParse, pTab, (int)(0), (int)(regNewRowid), aXRef, (int)(chngKey));
			}

			sqlite3CompleteInsertion(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), (int)(regNewRowid), aRegIdx, (int)(0x04 | ((eOnePass) == (2) ? 0x02 : 0)), (int)(0), (int)(0));
			if ((hasFK) != 0)
			{
				sqlite3FkActions(pParse, pTab, pChanges, (int)(regOldRowid), aXRef, (int)(chngKey));
			}
		}

		if ((regRowCount) != 0)
		{
			sqlite3VdbeAddOp2(v, (int)(85), (int)(regRowCount), (int)(1));
		}

		sqlite3CodeRowTrigger(pParse, pTrigger, (int)(129), pChanges, (int)(2), pTab, (int)(regOldRowid), (int)(onError), (int)(labelContinue));
		if ((eOnePass) == (1))
		{
		}
		else if ((eOnePass) == (2))
		{
			sqlite3VdbeResolveLabel(v, (int)(labelContinue));
			sqlite3WhereEnd(pWInfo);
		}
		else
		{
			sqlite3VdbeResolveLabel(v, (int)(labelContinue));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iEph), (int)(addrTop));
		}

		sqlite3VdbeResolveLabel(v, (int)(labelBreak));
		if ((((pParse.nested) == (0)) && ((pParse.pTriggerTab) == (null))) && ((pUpsert) == (null)))
		{
			sqlite3AutoincrementEnd(pParse);
		}

		if ((regRowCount) != 0)
		{
			sqlite3CodeChangeCount(v, (int)(regRowCount), "rows updated");
		}

	update_cleanup:
		; sqlite3AuthContextPop(sContext);
		sqlite3DbFree(db, aXRef);
		sqlite3SrcListDelete(db, pTabList);
		sqlite3ExprListDelete(db, pChanges);
		sqlite3ExprDelete(db, pWhere);
		return;
	}
	public static int sqlite3UpsertAnalyzeTarget(Parse pParse, SrcList pTabList, Upsert pUpsert)
	{
		Table pTab;
		int rc = 0;
		int iCursor = 0;
		Index pIdx;
		ExprList pTarget;
		Expr pTerm;
		NameContext sNC = new NameContext();
		var sCol = new Expr[2]; sCol[0] = new Expr(); sCol[1] = new Expr();
		int nClause = (int)(0);
		CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
		sNC.pParse = pParse;
		sNC.pSrcList = pTabList;
		for (; ((pUpsert) != null) && ((pUpsert.pUpsertTarget) != null); pUpsert = pUpsert.pNextUpsert, nClause++)
		{
			rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsert.pUpsertTarget));
			if ((rc) != 0)
				return (int)(rc);
			rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertTargetWhere));
			if ((rc) != 0)
				return (int)(rc);
			pTab = pTabList.a[0].pTab;
			pTarget = pUpsert.pUpsertTarget;
			iCursor = (int)(pTabList.a[0].iCursor);
			if ((((((pTab).tabFlags & 0x00000080) == (0)) && ((pTarget.nExpr) == (1))) && (((pTerm = pTarget.a[0].pExpr).op) == (167))) && ((pTerm.iColumn) == (-1)))
			{
				continue;
			}

			CRuntime.memset(sCol, (int)(0), (ulong)(2 * sizeof(Expr)));
			sCol[0].op = (byte)(113);
			sCol[0].pLeft = sCol[1];
			sCol[1].op = (byte)(167);
			sCol[1].iTable = (int)(pTabList.a[0].iCursor);
			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				int ii = 0;
				int jj = 0;
				int nn = 0;
				if (!((pIdx).onError != 0))
					continue;
				if (pTarget.nExpr != pIdx.nKeyCol)
					continue;
				if ((pIdx.pPartIdxWhere) != null)
				{
					if ((pUpsert.pUpsertTargetWhere) == (null))
						continue;
					if (sqlite3ExprCompare(pParse, pUpsert.pUpsertTargetWhere, pIdx.pPartIdxWhere, (int)(iCursor)) != 0)
					{
						continue;
					}
				}

				nn = (int)(pIdx.nKeyCol);
				for (ii = (int)(0); (ii) < (nn); ii++)
				{
					Expr pExpr;
					sCol[0].u.zToken = pIdx.azColl[ii];
					if ((pIdx.aiColumn[ii]) == (-2))
					{
						pExpr = pIdx.aColExpr.a[ii].pExpr;
						if (pExpr.op != 113)
						{
							sCol[0].pLeft = pExpr;
							pExpr = sCol[0];
						}
					}
					else
					{
						sCol[0].pLeft = sCol[1];
						sCol[1].iColumn = (short)(pIdx.aiColumn[ii]);
						pExpr = sCol[0];
					}

					for (jj = (int)(0); (jj) < (nn); jj++)
					{
						if ((sqlite3ExprCompare(pParse, pTarget.a[jj].pExpr, pExpr, (int)(iCursor))) < (2))
						{
							break;
						}
					}

					if ((jj) >= (nn))
					{
						break;
					}
				}

				if ((ii) < (nn))
				{
					continue;
				}

				pUpsert.pUpsertIdx = pIdx;
				break;
			}

			if ((pUpsert.pUpsertIdx) == (null))
			{
				sbyte* zWhich = stackalloc sbyte[16];
				if (((nClause) == (0)) && ((pUpsert.pNextUpsert) == (null)))
				{
					zWhich[0] = (sbyte)(0);
				}
				else
				{
					sqlite3_snprintf((int)(16 * sizeof(sbyte)), zWhich, "%r ", (int)(nClause + 1));
				}

				sqlite3ErrorMsg(pParse, "%sON CONFLICT clause does not match any PRIMARY KEY or UNIQUE constraint", zWhich);
				return (int)(1);
			}
		}

		return (int)(0);
	}
	public static void sqlite3UpsertDoUpdate(Parse pParse, Upsert pUpsert, Table pTab, Index pIdx, int iCur)
	{
		Vdbe v = pParse.pVdbe;
		sqlite3 db = pParse.db;
		SrcList pSrc;
		int iDataCur = 0;
		int i = 0;
		Upsert pTop = pUpsert;
		iDataCur = (int)(pUpsert.iDataCur);
		pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);
		if (((pIdx) != null) && (iCur != iDataCur))
		{
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				int regRowid = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp2(v, (int)(141), (int)(iCur), (int)(regRowid));
				sqlite3VdbeAddOp3(v, (int)(32), (int)(iDataCur), (int)(0), (int)(regRowid));
				sqlite3ReleaseTempReg(pParse, (int)(regRowid));
			}
			else
			{
				Index pPk = sqlite3PrimaryKeyIndex(pTab);
				int nPk = (int)(pPk.nKeyCol);
				int iPk = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPk);
				for (i = (int)(0); (i) < (nPk); i++)
				{
					int k = 0;
					k = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[i])));
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(k), (int)(iPk + i));
				}

				i = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iDataCur), (int)(0), (int)(iPk), (int)(nPk)));
				sqlite3VdbeAddOp4(v, (int)(70), (int)(11), (int)(2), (int)(0), "corrupt database", (int)(-1));
				sqlite3MayAbort(pParse);
				sqlite3VdbeJumpHere(v, (int)(i));
			}
		}

		pSrc = sqlite3SrcListDup(db, pTop.pUpsertSrc, (int)(0));
		for (i = (int)(0); (i) < (pTab.nCol); i++)
		{
			if ((pTab.aCol[i].affinity) == (0x45))
			{
				sqlite3VdbeAddOp1(v, (int)(86), (int)(pTop.regData + i));
			}
		}

		sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db, pUpsert.pUpsertSet, (int)(0)), sqlite3ExprDup(db, pUpsert.pUpsertWhere, (int)(0)), (int)(2), null, null, pUpsert);
	}
	public static void sqlite3Vacuum(Parse pParse, Token* pNm, Expr pInto)
	{
		Vdbe v = sqlite3GetVdbe(pParse);
		int iDb = (int)(0);
		if ((v) == (null))
			goto build_vacuum_end;
		if ((pParse.nErr) != 0)
			goto build_vacuum_end;
		if ((pNm) != null)
		{
			iDb = (int)(sqlite3TwoPartName(pParse, pNm, pNm, &pNm));
			if ((iDb) < (0))
				goto build_vacuum_end;
		}

		if (iDb != 1)
		{
			int iIntoReg = (int)(0);
			if (((pInto) != null) && ((sqlite3ResolveSelfReference(pParse, null, (int)(0), pInto, null)) == (0)))
			{
				iIntoReg = (int)(++pParse.nMem);
				sqlite3ExprCode(pParse, pInto, (int)(iIntoReg));
			}

			sqlite3VdbeAddOp2(v, (int)(8), (int)(iDb), (int)(iIntoReg));
			sqlite3VdbeUsesBtree(v, (int)(iDb));
		}

	build_vacuum_end:
		; sqlite3ExprDelete(pParse.db, pInto);
		return;
	}
	public static int sqlite3VdbeAddFunctionCall(Parse pParse, int p1, int p2, int p3, int nArg, FuncDef pFunc, int eCallCtx)
	{
		Vdbe v = pParse.pVdbe;
		int nByte = 0;
		int addr = 0;
		sqlite3_context pCtx;
		nByte = (int)(sizeof(sqlite3_context) + (nArg - 1) * sizeof(sqlite3_value));
		pCtx = sqlite3DbMallocRawNN(pParse.db, (ulong)(nByte));
		if ((pCtx) == (null))
		{
			freeEphemeralFunction(pParse.db, pFunc);
			return (int)(0);
		}

		pCtx.pOut = null;
		pCtx.pFunc = pFunc;
		pCtx.pVdbe = null;
		pCtx.isError = (int)(0);
		pCtx.argc = (byte)(nArg);
		pCtx.iOp = (int)(sqlite3VdbeCurrentAddr(v));
		addr = (int)(sqlite3VdbeAddOp4(v, (int)((eCallCtx) != 0 ? 65 : 66), (int)(p1), (int)(p2), (int)(p3), (sbyte*)(pCtx), (int)(-16)));
		sqlite3VdbeChangeP5(v, (ushort)(eCallCtx & 0x00002e));
		return (int)(addr);
	}
	public static Vdbe sqlite3VdbeCreate(Parse pParse)
	{
		sqlite3 db = pParse.db;
		Vdbe p;
		p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Vdbe)));
		if ((p) == (null))
			return null;
		CRuntime.memset(&p.aOp, (int)(0), (ulong)(sizeof(Vdbe) - ((ulong)(&((0).aOp)))));
		p.db = db;
		if ((db.pVdbe) != null)
		{
			db.pVdbe.pPrev = p;
		}

		p.pNext = db.pVdbe;
		p.pPrev = null;
		db.pVdbe = p;
		p.iVdbeMagic = (uint)(0x16bceaa5);
		p.pParse = pParse;
		pParse.pVdbe = p;
		sqlite3VdbeAddOp2(p, (int)(64), (int)(0), (int)(1));
		return p;
	}
	public static void sqlite3VdbeExplain(Parse pParse, byte bPush, sbyte* zFmt)
	{
		if ((pParse.explain) == (2))
		{
			sbyte* zMsg;
			Vdbe v;
			sbyte* ap;
			int iThis = 0;
			(__va_start(&ap, zFmt));
			zMsg = sqlite3VMPrintf(pParse.db, zFmt, ap);
			((void)(ap = null));
			v = pParse.pVdbe;
			iThis = (int)(v.nOp);
			sqlite3VdbeAddOp4(v, (int)(183), (int)(iThis), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7));
			if ((bPush) != 0)
			{
				pParse.addrExplain = (int)(iThis);
			}
		}
	}
	public static int sqlite3VdbeExplainParent(Parse pParse)
	{
		VdbeOp* pOp;
		if ((pParse.addrExplain) == (0))
			return (int)(0);
		pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(pParse.addrExplain));
		return (int)(pOp->p2);
	}
	public static void sqlite3VdbeExplainPop(Parse pParse)
	{
		pParse.addrExplain = (int)(sqlite3VdbeExplainParent(pParse));
	}
	public static int sqlite3VdbeMakeLabel(Parse pParse)
	{
		return (int)(--pParse.nLabel);
	}
	public static void sqlite3VdbeSetP4KeyInfo(Parse pParse, Index pIdx)
	{
		Vdbe v = pParse.pVdbe;
		KeyInfo pKeyInfo;
		pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
		if ((pKeyInfo) != null)
			sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
	}
	public static void sqlite3VectorErrorMsg(Parse pParse, Expr pExpr)
	{
		if ((((pExpr).flags & 0x000800) != 0))
		{
			sqlite3SubselectError(pParse, (int)(pExpr.x.pSelect.pEList.nExpr), (int)(1));
		}
		else
		{
			sqlite3ErrorMsg(pParse, "row value misused");
		}
	}
	public static int sqlite3ViewGetColumnNames(Parse pParse, Table pTable)
	{
		Table pSelTab;
		Select pSel;
		int nErr = (int)(0);
		int n = 0;
		sqlite3 db = pParse.db;
		int rc = 0;
		delegate67 xAuth;
		if ((((pTable).eTabType) == (1)))
		{
			db.nSchemaLock++;
			rc = (int)(sqlite3VtabCallConnect(pParse, pTable));
			db.nSchemaLock--;
			return (int)(rc);
		}

		if ((pTable.nCol) > (0))
			return (int)(0);
		if ((pTable.nCol) < (0))
		{
			sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable.zName);
			return (int)(1);
		}

		pSel = sqlite3SelectDup(db, pTable.u.view.pSelect, (int)(0));
		if ((pSel) != null)
		{
			byte eParseMode = (byte)(pParse.eParseMode);
			pParse.eParseMode = (byte)(0);
			n = (int)(pParse.nTab);
			sqlite3SrcListAssignCursors(pParse, pSel.pSrc);
			pTable.nCol = (short)(-1);
			db.lookaside.bDisable++;
			db.lookaside.sz = (ushort)(0);
			xAuth = db.xAuth;
			db.xAuth = null;
			pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, (sbyte)(0x40));
			db.xAuth = xAuth;
			pParse.nTab = (int)(n);
			if ((pSelTab) == (null))
			{
				pTable.nCol = (short)(0);
				nErr++;
			}
			else if ((pTable.pCheck) != null)
			{
				sqlite3ColumnsFromExprList(pParse, pTable.pCheck, &pTable.nCol, &pTable.aCol);
				if (((pParse.nErr) == (0)) && ((pTable.nCol) == (pSel.pEList.nExpr)))
				{
					sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel, (sbyte)(0x40));
				}
			}
			else
			{
				pTable.nCol = (short)(pSelTab.nCol);
				pTable.aCol = pSelTab.aCol;
				pTable.tabFlags |= (uint)(pSelTab.tabFlags & 0x0062);
				pSelTab.nCol = (short)(0);
				pSelTab.aCol = null;
			}

			pTable.nNVCol = (short)(pTable.nCol);
			sqlite3DeleteTable(db, pSelTab);
			sqlite3SelectDelete(db, pSel);
			db.lookaside.bDisable--;
			db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
			pParse.eParseMode = (byte)(eParseMode);
		}
		else
		{
			nErr++;
		}

		pTable.pSchema.schemaFlags |= (ushort)(0x0002);
		if ((db.mallocFailed) != 0)
		{
			sqlite3DeleteColumnNames(db, pTable);
		}

		return (int)(nErr);
	}
	public static void sqlite3VtabArgExtend(Parse pParse, Token* p)
	{
		Token* pArg = &pParse.sArg;
		if ((pArg->z) == (null))
		{
			pArg->z = p->z;
			pArg->n = (uint)(p->n);
		}
		else
		{
			pArg->n = (uint)((int)(&p->z[p->n] - pArg->z));
		}
	}
	public static void sqlite3VtabArgInit(Parse pParse)
	{
		addArgumentToVtab(pParse);
		pParse.sArg.z = null;
		pParse.sArg.n = (uint)(0);
	}
	public static void sqlite3VtabBeginParse(Parse pParse, Token* pName1, Token* pName2, Token* pModuleName, int ifNotExists)
	{
		Table pTable;
		sqlite3 db;
		sqlite3StartTable(pParse, pName1, pName2, (int)(0), (int)(0), (int)(1), (int)(ifNotExists));
		pTable = pParse.pNewTable;
		if ((pTable) == (null))
			return;
		pTable.eTabType = (byte)(1);
		db = pParse.db;
		addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
		addModuleArgument(pParse, pTable, null);
		addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable.zName));
		pParse.sNameToken.n = (uint)((int)(&pModuleName->z[pModuleName->n] - pParse.sNameToken.z));
		if ((pTable.u.vtab.azArg) != null)
		{
			int iDb = (int)(sqlite3SchemaToIndex(db, pTable.pSchema));
			sqlite3AuthCheck(pParse, (int)(29), pTable.zName, pTable.u.vtab.azArg[0], pParse.db.aDb[iDb].zDbSName);
		}
	}
	public static int sqlite3VtabCallConnect(Parse pParse, Table pTab)
	{
		sqlite3 db = pParse.db;
		sbyte* zMod;
		Module pMod;
		int rc = 0;
		if ((sqlite3GetVTable(db, pTab)) != null)
		{
			return (int)(0);
		}

		zMod = pTab.u.vtab.azArg[0];
		pMod = (Module)(sqlite3HashFind(&db.aModule, zMod));
		if (pMod == null)
		{
			sbyte* zModule = pTab.u.vtab.azArg[0];
			sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
			rc = (int)(1);
		}
		else
		{
			sbyte* zErr = null;
			rc = (int)(vtabCallConstructor(db, pTab, pMod, pMod.pModule.xConnect, &zErr));
			if (rc != 0)
			{
				sqlite3ErrorMsg(pParse, "%s", zErr);
				pParse.rc = (int)(rc);
			}

			sqlite3DbFree(db, zErr);
		}

		return (int)(rc);
	}
	public static int sqlite3VtabEponymousTableInit(Parse pParse, Module pMod)
	{
		sqlite3_module pModule = pMod.pModule;
		Table pTab;
		sbyte* zErr = null;
		int rc = 0;
		sqlite3 db = pParse.db;
		if ((pMod.pEpoTab) != null)
			return (int)(1);
		if ((pModule.xCreate != null) && (pModule.xCreate != pModule.xConnect))
			return (int)(0);
		pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
		if ((pTab) == (null))
			return (int)(0);
		pTab.zName = sqlite3DbStrDup(db, pMod.zName);
		if ((pTab.zName) == (null))
		{
			sqlite3DbFree(db, pTab);
			return (int)(0);
		}

		pMod.pEpoTab = pTab;
		pTab.nTabRef = (uint)(1);
		pTab.eTabType = (byte)(1);
		pTab.pSchema = db.aDb[0].pSchema;
		pTab.iPKey = (short)(-1);
		pTab.tabFlags |= (uint)(0x00008000);
		addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName));
		addModuleArgument(pParse, pTab, null);
		addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName));
		rc = (int)(vtabCallConstructor(db, pTab, pMod, pModule.xConnect, &zErr));
		if ((rc) != 0)
		{
			sqlite3ErrorMsg(pParse, "%s", zErr);
			sqlite3DbFree(db, zErr);
			sqlite3VtabEponymousTableClear(db, pMod);
		}

		return (int)(1);
	}
	public static void sqlite3VtabFinishParse(Parse pParse, Token* pEnd)
	{
		Table pTab = pParse.pNewTable;
		sqlite3 db = pParse.db;
		if ((pTab) == (null))
			return;
		addArgumentToVtab(pParse);
		pParse.sArg.z = null;
		if ((pTab.u.vtab.nArg) < (1))
			return;
		if (db.init.busy == 0)
		{
			sbyte* zStmt;
			sbyte* zWhere;
			int iDb = 0;
			int iReg = 0;
			Vdbe v;
			sqlite3MayAbort(pParse);
			if ((pEnd) != null)
			{
				pParse.sNameToken.n = (uint)((int)(pEnd->z - pParse.sNameToken.z) + pEnd->n);
			}

			zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse.sNameToken);
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q WHERE rowid=#%d", db.aDb[iDb].zDbSName, pTab.zName, pTab.zName, zStmt, (int)(pParse.regRowid));
			v = sqlite3GetVdbe(pParse);
			sqlite3ChangeCookie(pParse, (int)(iDb));
			sqlite3VdbeAddOp0(v, (int)(165));
			zWhere = sqlite3MPrintf(db, "name=%Q AND sql=%Q", pTab.zName, zStmt);
			sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), zWhere, (ushort)(0));
			sqlite3DbFree(db, zStmt);
			iReg = (int)(++pParse.nMem);
			sqlite3VdbeLoadString(v, (int)(iReg), pTab.zName);
			sqlite3VdbeAddOp2(v, (int)(170), (int)(iDb), (int)(iReg));
		}
		else
		{
			Table pOld;
			Schema pSchema = pTab.pSchema;
			sbyte* zName = pTab.zName;
			sqlite3MarkAllShadowTablesOf(db, pTab);
			pOld = sqlite3HashInsert(&pSchema.tblHash, zName, pTab);
			if ((pOld) != null)
			{
				sqlite3OomFault(db);
				return;
			}

			pParse.pNewTable = null;
		}
	}
	public static void sqlite3VtabMakeWritable(Parse pParse, Table pTab)
	{
		Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
		int i = 0; int n = 0;
		Table apVtabLock;
		for (i = (int)(0); (i) < (pToplevel.nVtabLock); i++)
		{
			if ((pTab) == (pToplevel.apVtabLock[i]))
				return;
		}

		n = (int)((pToplevel.nVtabLock + 1) * sizeof(Table));
		apVtabLock = sqlite3Realloc(pToplevel.apVtabLock, (ulong)(n));
		if ((apVtabLock) != null)
		{
			pToplevel.apVtabLock = apVtabLock;
			pToplevel.apVtabLock[pToplevel.nVtabLock++] = pTab;
		}
		else
		{
			sqlite3OomFault(pToplevel.db);
		}
	}
	public static WhereInfo sqlite3WhereBegin(Parse pParse, SrcList pTabList, Expr pWhere, ExprList pOrderBy, ExprList pResultSet, Select pLimit, ushort wctrlFlags, int iAuxArg)
	{
		int nByteWInfo = 0;
		int nTabList = 0;
		WhereInfo pWInfo;
		Vdbe v = pParse.pVdbe;
		ulong notReady = 0;
		WhereLoopBuilder sWLB = new WhereLoopBuilder();
		WhereMaskSet* pMaskSet;
		WhereLevel pLevel;
		WhereLoop pLoop;
		int ii = 0;
		sqlite3 db;
		int rc = 0;
		byte bFordelete = (byte)(0);
		db = pParse.db;
		CRuntime.memset(sWLB, (int)(0), (ulong)(sizeof(WhereLoopBuilder)));
		if (((pOrderBy) != null) && ((pOrderBy.nExpr) >= ((int)(sizeof(ulong) * 8))))
			pOrderBy = null;
		if ((pTabList.nSrc) > ((int)(sizeof(ulong) * 8)))
		{
			sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int)(sizeof(ulong) * 8)));
			return null;
		}

		nTabList = (int)((wctrlFlags & 0x0020) ? 1 : pTabList.nSrc);
		nByteWInfo = (int)(((sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel)) + 7) & ~7);
		pWInfo = sqlite3DbMallocRawNN(db, (ulong)(nByteWInfo + sizeof(WhereLoop)));
		if ((db.mallocFailed) != 0)
		{
			sqlite3DbFree(db, pWInfo);
			pWInfo = null;
			goto whereBeginError;
		}

		pWInfo.pParse = pParse;
		pWInfo.pTabList = pTabList;
		pWInfo.pOrderBy = pOrderBy;
		pWInfo.pWhere = pWhere;
		pWInfo.pResultSet = pResultSet;
		pWInfo.aiCurOnePass[0] = (int)(pWInfo.aiCurOnePass[1] = (int)(-1));
		pWInfo.nLevel = (byte)(nTabList);
		pWInfo.iBreak = (int)(pWInfo.iContinue = (int)(sqlite3VdbeMakeLabel(pParse)));
		pWInfo.wctrlFlags = (ushort)(wctrlFlags);
		pWInfo.iLimit = (short)(iAuxArg);
		pWInfo.savedNQueryLoop = (int)(pParse.nQueryLoop);
		pWInfo.pLimit = pLimit;
		CRuntime.memset(&pWInfo.nOBSat, (int)(0), (ulong)(((ulong)((0).sWC)) - ((ulong)(&((0).nOBSat)))));
		CRuntime.memset(pWInfo.a[0], (int)(0), (ulong)(sizeof(WhereLoop) + nTabList * sizeof(WhereLevel)));
		pMaskSet = &pWInfo.sMaskSet;
		pMaskSet->n = (int)(0);
		pMaskSet->ix[0] = (int)(-99);
		sWLB.pWInfo = pWInfo;
		sWLB.pWC = pWInfo.sWC;
		sWLB.pNew = (WhereLoop)(((sbyte*)(pWInfo)) + nByteWInfo);
		whereLoopInit(sWLB.pNew);
		sqlite3WhereClauseInit(pWInfo.sWC, pWInfo);
		sqlite3WhereSplit(pWInfo.sWC, pWhere, (byte)(44));
		if ((nTabList) == (0))
		{
			if ((pOrderBy) != null)
				pWInfo.nOBSat = (sbyte)(pOrderBy.nExpr);
			if (((wctrlFlags & 0x0100) != 0) && (((db).dbOptFlags & (0x00000010)) == (0)))
			{
				pWInfo.eDistinct = (byte)(1);
			}

			sqlite3VdbeExplain(pParse, (byte)(0), "SCAN CONSTANT ROW");
		}
		else
		{
			ii = (int)(0);
			do
			{
				createMask(pMaskSet, (int)(pTabList.a[ii].iCursor));
				sqlite3WhereTabFuncArgs(pParse, pTabList.a[ii], pWInfo.sWC);
			}
			while ((++ii) < (pTabList.nSrc));
		}

		sqlite3WhereExprAnalyze(pTabList, pWInfo.sWC);
		sqlite3WhereAddLimit(pWInfo.sWC, pLimit);
		if ((db.mallocFailed) != 0)
			goto whereBeginError;
		for (ii = (int)(0); (ii) < (sWLB.pWC.nBase); ii++)
		{
			WhereTerm pT = sWLB.pWC.a[ii];
			if ((pT.wtFlags & 0x0002) != 0)
				continue;
			if (((pT.prereqAll) == (0)) && (((nTabList) == (0)) || ((exprIsDeterministic(pT.pExpr)) != 0)))
			{
				sqlite3ExprIfFalse(pParse, pT.pExpr, (int)(pWInfo.iBreak), (int)(0x10));
				pT.wtFlags |= (ushort)(0x0004);
			}
		}

		if ((wctrlFlags & 0x0100) != 0)
		{
			if ((((db).dbOptFlags & (0x00000010)) != 0))
			{
				wctrlFlags &= (ushort)(~0x0100);
				pWInfo.wctrlFlags &= (ushort)(~0x0100);
			}
			else if ((isDistinctRedundant(pParse, pTabList, pWInfo.sWC, pResultSet)) != 0)
			{
				pWInfo.eDistinct = (byte)(1);
			}
			else if ((pOrderBy) == (null))
			{
				pWInfo.wctrlFlags |= (ushort)(0x0080);
				pWInfo.pOrderBy = pResultSet;
			}
		}

		if ((nTabList != 1) || ((whereShortCut(sWLB)) == (0)))
		{
			rc = (int)(whereLoopAddAll(sWLB));
			if ((rc) != 0)
				goto whereBeginError;
			wherePathSolver(pWInfo, (short)(0));
			if ((db.mallocFailed) != 0)
				goto whereBeginError;
			if ((pWInfo.pOrderBy) != null)
			{
				wherePathSolver(pWInfo, (short)(pWInfo.nRowOut + 1));
				if ((db.mallocFailed) != 0)
					goto whereBeginError;
			}
		}

		if (((pWInfo.pOrderBy) == (null)) && ((db.flags & 0x00001000) != 0))
		{
			pWInfo.revMask = ((ulong)(-1));
		}

		if ((pParse.nErr) != 0)
		{
			goto whereBeginError;
		}

		notReady = (ulong)(~(ulong)(0));
		if (((((pWInfo.nLevel) >= (2)) && (pResultSet != null)) && ((0) == (wctrlFlags & 0x0400))) && (((db).dbOptFlags & (0x00000100)) == (0)))
		{
			notReady = (ulong)(whereOmitNoopJoin(pWInfo, (ulong)(notReady)));
			nTabList = (int)(pWInfo.nLevel);
		}

		if (((pWInfo.nLevel) >= (2)) && (((db).dbOptFlags & (0x00080000)) == (0)))
		{
			whereCheckIfBloomFilterIsUseful(pWInfo);
		}

		pWInfo.pParse.nQueryLoop += (uint)(pWInfo.nRowOut);
		if ((wctrlFlags & 0x0004) != 0)
		{
			int wsFlags = (int)(pWInfo.a[0].pWLoop.wsFlags);
			int bOnerow = (int)((wsFlags & 0x00001000) != 0);
			if (((bOnerow) != 0) || (((0 != (wctrlFlags & 0x0008)) && (!(((pTabList.a[0].pTab).eTabType) == (1)))) && (((0) == (wsFlags & 0x00002000)) || ((wctrlFlags & 0x0010) != 0))))
			{
				pWInfo.eOnePass = (byte)((bOnerow) != 0 ? 1 : 2);
				if ((((pTabList.a[0].pTab).tabFlags & 0x00000080) == (0)) && ((wsFlags & 0x00000040) != 0))
				{
					if ((wctrlFlags & 0x0008) != 0)
					{
						bFordelete = (byte)(0x08);
					}

					pWInfo.a[0].pWLoop.wsFlags = (uint)(wsFlags & ~0x00000040);
				}
			}
		}

		for (ii = (int)(0), pLevel = pWInfo.a; (ii) < (nTabList); ii++, pLevel++)
		{
			Table pTab;
			int iDb = 0;
			SrcItem pTabItem;
			pTabItem = pTabList.a[pLevel.iFrom];
			pTab = pTabItem.pTab;
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			pLoop = pLevel.pWLoop;
			if (((pTab.tabFlags & 0x00004000) != 0) || (((pTab).eTabType) == (2)))
			{
			}
			else if ((pLoop.wsFlags & 0x00000400) != 0)
			{
				sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
				int iCur = (int)(pTabItem.iCursor);
				sqlite3VdbeAddOp4(v, (int)(172), (int)(iCur), (int)(0), (int)(0), pVTab, (int)(-12));
			}
			else if ((((pTab).eTabType) == (1)))
			{
			}
			else if (((pLoop.wsFlags & 0x00000040) == (0)) && ((wctrlFlags & 0x0020) == (0)))
			{
				int op = (int)(101);
				if (pWInfo.eOnePass != 0)
				{
					op = (int)(112);
					pWInfo.aiCurOnePass[0] = (int)(pTabItem.iCursor);
				}

				sqlite3OpenTable(pParse, (int)(pTabItem.iCursor), (int)(iDb), pTab, (int)(op));
				if (((((pWInfo.eOnePass) == (0)) && ((pTab.nCol) < ((int)(sizeof(ulong) * 8)))) && ((pTab.tabFlags & (0x00000060 | 0x00000080)) == (0))) && ((pLoop.wsFlags & (0x00004000 | 0x00400000)) == (0)))
				{
					ulong b = (ulong)(pTabItem.colUsed);
					int n = (int)(0);
					for (b; ; b = (ulong)(b >> 1), n++)
					{
					}

					sqlite3VdbeChangeP4(v, (int)(-1), ((void*)((long)(n))), (int)(-3));
				}

				{
					sqlite3VdbeChangeP5(v, (ushort)(bFordelete));
				}
			}
			else
			{
				sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
			}

			if ((pLoop.wsFlags & 0x00000200) != 0)
			{
				Index pIx = pLoop.u.btree.pIndex;
				int iIndexCur = 0;
				int op = (int)(101);
				if (((!(((pTab).tabFlags & 0x00000080) == (0))) && (((pIx).idxType) == (2))) && ((wctrlFlags & 0x0020) != 0))
				{
					iIndexCur = (int)(pLevel.iTabCur);
					op = (int)(0);
				}
				else if (pWInfo.eOnePass != 0)
				{
					Index pJ = pTabItem.pTab.pIndex;
					iIndexCur = (int)(iAuxArg);
					while (((pJ) != null) && (pJ != pIx))
					{
						iIndexCur++;
						pJ = pJ.pNext;
					}

					op = (int)(112);
					pWInfo.aiCurOnePass[1] = (int)(iIndexCur);
				}
				else if (((iAuxArg) != 0) && ((wctrlFlags & 0x0020) != 0))
				{
					iIndexCur = (int)(iAuxArg);
					op = (int)(100);
				}
				else
				{
					iIndexCur = (int)(pParse.nTab++);
				}

				pLevel.iIdxCur = (int)(iIndexCur);
				if ((op) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(op), (int)(iIndexCur), (int)(pIx.tnum), (int)(iDb));
					sqlite3VdbeSetP4KeyInfo(pParse, pIx);
					if (((((((pLoop.wsFlags & 0x0000000f) != 0) && ((pLoop.wsFlags & (0x00000002 | 0x00008000)) == (0))) && ((pLoop.wsFlags & 0x00080000) == (0))) && ((pLoop.wsFlags & 0x00100000) == (0))) && ((pWInfo.wctrlFlags & 0x0001) == (0))) && (pWInfo.eDistinct != 2))
					{
						sqlite3VdbeChangeP5(v, (ushort)(0x02));
					}
				}
			}

			if ((iDb) >= (0))
				sqlite3CodeVerifySchema(pParse, (int)(iDb));
		}

		pWInfo.iTop = (int)(sqlite3VdbeCurrentAddr(v));
		if ((db.mallocFailed) != 0)
			goto whereBeginError;
		for (ii = (int)(0); (ii) < (nTabList); ii++)
		{
			int addrExplain = 0;
			int wsFlags = 0;
			if ((pParse.nErr) != 0)
				goto whereBeginError;
			pLevel = pWInfo.a[ii];
			wsFlags = (int)(pLevel.pWLoop.wsFlags);
			if ((wsFlags & (0x00004000 | 0x00400000)) != 0)
			{
				if ((wsFlags & 0x00004000) != 0)
				{
					constructAutomaticIndex(pParse, pWInfo.sWC, pTabList.a[pLevel.iFrom], (ulong)(notReady), pLevel);
				}
				else
				{
					sqlite3ConstructBloomFilter(pWInfo, (int)(ii), pLevel, (ulong)(notReady));
				}

				if ((db.mallocFailed) != 0)
					goto whereBeginError;
			}

			addrExplain = (int)(sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, (ushort)(wctrlFlags)));
			pLevel.addrBody = (int)(sqlite3VdbeCurrentAddr(v));
			notReady = (ulong)(sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, (int)(ii), pLevel, (ulong)(notReady)));
			pWInfo.iContinue = (int)(pLevel.addrCont);
			if (((wsFlags & 0x00002000) == (0)) && ((wctrlFlags & 0x0020) == (0)))
			{
				((void)(addrExplain));
			}
		}

		pWInfo.iEndWhere = (int)(sqlite3VdbeCurrentAddr(v));
		return pWInfo;
	whereBeginError:
		; if ((pWInfo) != null) { whereUndoExprMods(pWInfo); pParse.nQueryLoop = (uint)(pWInfo.savedNQueryLoop); whereInfoFree(db, pWInfo); }
		return null;
	}
	public static ulong sqlite3WhereCodeOneLoopStart(Parse pParse, Vdbe v, WhereInfo pWInfo, int iLevel, WhereLevel pLevel, ulong notReady)
	{
		int j = 0; int k = 0;
		int iCur = 0;
		int addrNxt = 0;
		int bRev = 0;
		WhereLoop pLoop;
		WhereClause pWC;
		WhereTerm pTerm;
		sqlite3 db;
		SrcItem pTabItem;
		int addrBrk = 0;
		int addrHalt = 0;
		int addrCont = 0;
		int iRowidReg = (int)(0);
		int iReleaseReg = (int)(0);
		Index pIdx = null;
		int iLoop = 0;
		pWC = pWInfo.sWC;
		db = pParse.db;
		pLoop = pLevel.pWLoop;
		pTabItem = pWInfo.pTabList.a[pLevel.iFrom];
		iCur = (int)(pTabItem.iCursor);
		pLevel.notReady = (ulong)(notReady & ~sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(iCur)));
		bRev = (int)((pWInfo.revMask >> iLevel) & 1);
		addrBrk = (int)(pLevel.addrBrk = (int)(pLevel.addrNxt = (int)(sqlite3VdbeMakeLabel(pParse))));
		addrCont = (int)(pLevel.addrCont = (int)(sqlite3VdbeMakeLabel(pParse)));
		if (((pLevel.iFrom) > (0)) && ((pTabItem[0].fg.jointype & 0x0008) != 0))
		{
			pLevel.iLeftJoin = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pLevel.iLeftJoin));
		}

		for (j = (int)(iLevel); ((j) > (0)) && ((pWInfo.a[j].iLeftJoin) == (0)); j--)
		{
		}

		addrHalt = (int)(pWInfo.a[j].addrBrk);
		if ((pTabItem.fg.viaCoroutine) != 0)
		{
			int regYield = (int)(pTabItem.regReturn);
			sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(pTabItem.addrFillSub));
			pLevel.p2 = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regYield), (int)(addrBrk)));
			pLevel.op = (byte)(11);
		}
		else if ((pLoop.wsFlags & 0x00000400) != 0)
		{
			int iReg = 0;
			int addrNotFound = 0;
			int nConstraint = (int)(pLoop.nLTerm);
			iReg = (int)(sqlite3GetTempRange(pParse, (int)(nConstraint + 2)));
			addrNotFound = (int)(pLevel.addrBrk);
			for (j = (int)(0); (j) < (nConstraint); j++)
			{
				int iTarget = (int)(iReg + j + 2);
				pTerm = pLoop.aLTerm[j];
				if (((pTerm) == (null)))
					continue;
				if ((pTerm.eOperator & 0x0001) != 0)
				{
					if ((((j) <= (31) ? ((uint)(1)) << (j) : 0) & pLoop.u.vtab.mHandleIn) != 0)
					{
						int iTab = (int)(pParse.nTab++);
						int iCache = (int)(++pParse.nMem);
						sqlite3CodeRhsOfIN(pParse, pTerm.pExpr, (int)(iTab));
						sqlite3VdbeAddOp3(v, (int)(173), (int)(iTab), (int)(iTarget), (int)(iCache));
					}
					else
					{
						codeEqualityTerm(pParse, pTerm, pLevel, (int)(j), (int)(bRev), (int)(iTarget));
						addrNotFound = (int)(pLevel.addrNxt);
					}
				}
				else
				{
					Expr pRight = pTerm.pExpr.pRight;
					codeExprOrVector(pParse, pRight, (int)(iTarget), (int)(1));
					if (((pTerm.eMatchOp) == (74)) && ((pLoop.u.vtab.bOmitOffset) != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWInfo.pLimit.iOffset));
					}
				}
			}

			sqlite3VdbeAddOp2(v, (int)(71), (int)(pLoop.u.vtab.idxNum), (int)(iReg));
			sqlite3VdbeAddOp2(v, (int)(71), (int)(nConstraint), (int)(iReg + 1));
			sqlite3VdbeAddOp4(v, (int)(9), (int)(iCur), (int)(addrNotFound), (int)(iReg), pLoop.u.vtab.idxStr, (int)((pLoop.u.vtab.needFree) != 0 ? (-7) : (-1)));
			pLoop.u.vtab.needFree = (uint)(0);
			if ((db.mallocFailed) != 0)
				pLoop.u.vtab.idxStr = null;
			pLevel.p1 = (int)(iCur);
			pLevel.op = (byte)((pWInfo.eOnePass) != 0 ? 182 : 62);
			pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
			for (j = (int)(0); (j) < (nConstraint); j++)
			{
				pTerm = pLoop.aLTerm[j];
				if (((j) < (16)) && (((pLoop.u.vtab.omitMask >> j) & 1) != 0))
				{
					disableTerm(pLevel, pTerm);
					continue;
				}

				if ((((pTerm.eOperator & 0x0001) != 0) && ((((j) <= (31) ? ((uint)(1)) << (j) : 0) & pLoop.u.vtab.mHandleIn) == (0))) && (db.mallocFailed == 0))
				{
					Expr pCompare;
					Expr pRight;
					VdbeOp* pOp;
					int iIn = 0;
					for (iIn = (int)(0); ((iIn) < (pLevel.u._in_.nIn)); iIn++)
					{
						pOp = sqlite3VdbeGetOp(v, (int)(pLevel.u._in_.aInLoop[iIn].addrInTop));
						if ((((pOp->opcode) == (93)) && ((pOp->p3) == (iReg + j + 2))) || (((pOp->opcode) == (134)) && ((pOp->p2) == (iReg + j + 2))))
						{
							sqlite3VdbeAddOp3(v, (int)(pOp->opcode), (int)(pOp->p1), (int)(pOp->p2), (int)(pOp->p3));
							break;
						}
					}

					pCompare = sqlite3PExpr(pParse, (int)(53), null, null);
					if (db.mallocFailed == 0)
					{
						int iFld = (int)(pTerm.u.x.iField);
						Expr pLeft = pTerm.pExpr.pLeft;
						if ((iFld) > (0))
						{
							pCompare.pLeft = pLeft.x.pList.a[iFld - 1].pExpr;
						}
						else
						{
							pCompare.pLeft = pLeft;
						}

						pCompare.pRight = pRight = sqlite3Expr(db, (int)(176), null);
						if ((pRight) != null)
						{
							pRight.iTable = (int)(iReg + j + 2);
							sqlite3ExprIfFalse(pParse, pCompare, (int)(pLevel.addrCont), (int)(0x10));
						}

						pCompare.pLeft = null;
					}

					sqlite3ExprDelete(db, pCompare);
				}
			}
		}
		else if (((pLoop.wsFlags & 0x00000100) != 0) && ((pLoop.wsFlags & (0x00000004 | 0x00000001)) != 0))
		{
			pTerm = pLoop.aLTerm[0];
			iReleaseReg = (int)(++pParse.nMem);
			iRowidReg = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(0), (int)(bRev), (int)(iReleaseReg)));
			if (iRowidReg != iReleaseReg)
				sqlite3ReleaseTempReg(pParse, (int)(iReleaseReg));
			addrNxt = (int)(pLevel.addrNxt);
			if ((pLevel.regFilter) != 0)
			{
				sqlite3VdbeAddOp4Int(v, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(iRowidReg), (int)(1));
				filterPullDown(pParse, pWInfo, (int)(iLevel), (int)(addrNxt), (ulong)(notReady));
			}

			sqlite3VdbeAddOp3(v, (int)(32), (int)(iCur), (int)(addrNxt), (int)(iRowidReg));
			pLevel.op = (byte)(182);
		}
		else if (((pLoop.wsFlags & 0x00000100) != 0) && ((pLoop.wsFlags & 0x00000002) != 0))
		{
			int testOp = (int)(182);
			int start = 0;
			int memEndValue = (int)(0);
			WhereTerm pStart;
			WhereTerm pEnd;
			j = (int)(0);
			pStart = pEnd = null;
			if ((pLoop.wsFlags & 0x00000020) != 0)
				pStart = pLoop.aLTerm[j++];
			if ((pLoop.wsFlags & 0x00000010) != 0)
				pEnd = pLoop.aLTerm[j++];
			if ((bRev) != 0)
			{
				pTerm = pStart;
				pStart = pEnd;
				pEnd = pTerm;
			}

			if ((pStart) != null)
			{
				Expr pX;
				int r1 = 0;
				int rTemp = 0;
				int op = 0;
				byte* aMoveOp = stackalloc byte[] { 26, 24, 23, 25 };
				pX = pStart.pExpr;
				if ((sqlite3ExprIsVector(pX.pRight)) != 0)
				{
					r1 = (int)(rTemp = (int)(sqlite3GetTempReg(pParse)));
					codeExprOrVector(pParse, pX.pRight, (int)(r1), (int)(1));
					op = (int)(aMoveOp[((pX.op - 54 - 1) & 0x3) | 0x1]);
				}
				else
				{
					r1 = (int)(sqlite3ExprCodeTemp(pParse, pX.pRight, &rTemp));
					disableTerm(pLevel, pStart);
					op = (int)(aMoveOp[(pX.op - 54)]);
				}

				sqlite3VdbeAddOp3(v, (int)(op), (int)(iCur), (int)(addrBrk), (int)(r1));
				sqlite3ReleaseTempReg(pParse, (int)(rTemp));
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)((bRev) != 0 ? 34 : 38), (int)(iCur), (int)(addrHalt));
			}

			if ((pEnd) != null)
			{
				Expr pX;
				pX = pEnd.pExpr;
				memEndValue = (int)(++pParse.nMem);
				codeExprOrVector(pParse, pX.pRight, (int)(memEndValue), (int)(1));
				if (((0) == (sqlite3ExprIsVector(pX.pRight))) && (((pX.op) == (56)) || ((pX.op) == (54))))
				{
					testOp = (int)((bRev) != 0 ? 55 : 57);
				}
				else
				{
					testOp = (int)((bRev) != 0 ? 56 : 54);
				}

				if ((0) == (sqlite3ExprIsVector(pX.pRight)))
				{
					disableTerm(pLevel, pEnd);
				}
			}

			start = (int)(sqlite3VdbeCurrentAddr(v));
			pLevel.op = (byte)((bRev) != 0 ? 4 : 5);
			pLevel.p1 = (int)(iCur);
			pLevel.p2 = (int)(start);
			if (testOp != 182)
			{
				iRowidReg = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(iRowidReg));
				sqlite3VdbeAddOp3(v, (int)(testOp), (int)(memEndValue), (int)(addrBrk), (int)(iRowidReg));
				sqlite3VdbeChangeP5(v, (ushort)(0x43 | 0x10));
			}
		}
		else if ((pLoop.wsFlags & 0x00000200) != 0)
		{
			ushort nEq = (ushort)(pLoop.u.btree.nEq);
			ushort nBtm = (ushort)(pLoop.u.btree.nBtm);
			ushort nTop = (ushort)(pLoop.u.btree.nTop);
			int regBase = 0;
			WhereTerm pRangeStart = null;
			WhereTerm pRangeEnd = null;
			int startEq = 0;
			int endEq = 0;
			int start_constraints = 0;
			int nConstraint = 0;
			int iIdxCur = 0;
			int nExtraReg = (int)(0);
			int op = 0;
			sbyte* zStartAff;
			sbyte* zEndAff = null;
			byte bSeekPastNull = (byte)(0);
			byte bStopAtNull = (byte)(0);
			int omitTable = 0;
			int regBignull = (int)(0);
			int addrSeekScan = (int)(0);
			pIdx = pLoop.u.btree.pIndex;
			iIdxCur = (int)(pLevel.iIdxCur);
			j = (int)(nEq);
			if ((pLoop.wsFlags & 0x00000020) != 0)
			{
				pRangeStart = pLoop.aLTerm[j++];
				nExtraReg = (int)((nExtraReg) > (pLoop.u.btree.nBtm) ? (nExtraReg) : (pLoop.u.btree.nBtm));
			}

			if ((pLoop.wsFlags & 0x00000010) != 0)
			{
				pRangeEnd = pLoop.aLTerm[j++];
				nExtraReg = (int)((nExtraReg) > (pLoop.u.btree.nTop) ? (nExtraReg) : (pLoop.u.btree.nTop));
				if ((pRangeEnd.wtFlags & 0x0100) != 0)
				{
					pLevel.iLikeRepCntr = ((uint)(++pParse.nMem));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pLevel.iLikeRepCntr));
					pLevel.addrLikeRep = (int)(sqlite3VdbeCurrentAddr(v));
					pLevel.iLikeRepCntr <<= 1;
					pLevel.iLikeRepCntr |= (uint)(bRev ^ ((pIdx.aSortOrder[nEq]) == (1)));
				}

				if ((pRangeStart) == (null))
				{
					j = (int)(pIdx.aiColumn[nEq]);
					if ((((j) >= (0)) && ((pIdx.pTable.aCol[j].notNull) == (0))) || ((j) == (-2)))
					{
						bSeekPastNull = (byte)(1);
					}
				}
			}

			if (((pLoop.wsFlags & (0x00000010 | 0x00000020)) == (0)) && ((pLoop.wsFlags & 0x00080000) != 0))
			{
				nExtraReg = (int)(1);
				bSeekPastNull = (byte)(1);
				pLevel.regBignull = (int)(regBignull = (int)(++pParse.nMem));
				if ((pLevel.iLeftJoin) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regBignull));
				}

				pLevel.addrBignull = (int)(sqlite3VdbeMakeLabel(pParse));
			}

			if ((((nEq) < (pIdx.nColumn)) && ((bRev) == ((pIdx.aSortOrder[nEq]) == (0)))))
			{
				{
					WhereTerm t = pRangeEnd;
					pRangeEnd = pRangeStart;
					pRangeStart = t;
				}

				{
					byte t = (byte)(bSeekPastNull);
					bSeekPastNull = (byte)(bStopAtNull);
					bStopAtNull = (byte)(t);
				}

				{
					byte t = (byte)(nBtm);
					nBtm = (ushort)(nTop);
					nTop = (ushort)(t);
				}
			}

			if (((iLevel) > (0)) && ((pLoop.wsFlags & 0x00100000) != 0))
			{
				sqlite3VdbeAddOp1(v, (int)(135), (int)(iIdxCur));
			}

			regBase = (int)(codeAllEqualityTerms(pParse, pLevel, (int)(bRev), (int)(nExtraReg), &zStartAff));
			if (((zStartAff) != null) && ((nTop) != 0))
			{
				zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
			}

			addrNxt = (int)((regBignull) != 0 ? pLevel.addrBignull : pLevel.addrNxt);
			startEq = (int)((pRangeStart == null) || ((pRangeStart.eOperator & ((0x0002 << (55 - 53)) | (0x0002 << (57 - 53)))) != 0) ? 1 : 0);
			endEq = (int)((pRangeEnd == null) || ((pRangeEnd.eOperator & ((0x0002 << (55 - 53)) | (0x0002 << (57 - 53)))) != 0) ? 1 : 0);
			start_constraints = (int)(((pRangeStart) != null) || ((nEq) > (0)) ? 1 : 0);
			nConstraint = (int)(nEq);
			if ((pRangeStart) != null)
			{
				Expr pRight = pRangeStart.pExpr.pRight;
				codeExprOrVector(pParse, pRight, (int)(regBase + nEq), (int)(nBtm));
				whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
				if (((pRangeStart.wtFlags & 0x0080) == (0)) && ((sqlite3ExprCanBeNull(pRight)) != 0))
				{
					sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + nEq), (int)(addrNxt));
				}

				if ((zStartAff) != null)
				{
					updateRangeAffinityStr(pRight, (int)(nBtm), &zStartAff[nEq]);
				}

				nConstraint += (int)(nBtm);
				if ((sqlite3ExprIsVector(pRight)) == (0))
				{
					disableTerm(pLevel, pRangeStart);
				}
				else
				{
					startEq = (int)(1);
				}

				bSeekPastNull = (byte)(0);
			}
			else if ((bSeekPastNull) != 0)
			{
				startEq = (int)(0);
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
				start_constraints = (int)(1);
				nConstraint++;
			}
			else if ((regBignull) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
				start_constraints = (int)(1);
				nConstraint++;
			}

			codeApplyAffinity(pParse, (int)(regBase), (int)(nConstraint - bSeekPastNull), zStartAff);
			if (((pLoop.nSkip) > (0)) && ((nConstraint) == (pLoop.nSkip)))
			{
			}
			else
			{
				if ((regBignull) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regBignull));
				}

				if ((pLevel.regFilter) != 0)
				{
					sqlite3VdbeAddOp4Int(v, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(regBase), (int)(nEq));
					filterPullDown(pParse, pWInfo, (int)(iLevel), (int)(addrNxt), (ulong)(notReady));
				}

				op = (int)(sqlite3WhereCodeOneLoopStart_aStartOp[(start_constraints << 2) + (startEq << 1) + bRev]);
				if (((pLoop.wsFlags & 0x00100000) != 0) && ((op) == (25)))
				{
					addrSeekScan = (int)(sqlite3VdbeAddOp1(v, (int)(123), (int)((pIdx.aiRowLogEst[0] + 9) / 10)));
				}

				sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint));
				if ((regBignull) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(sqlite3VdbeCurrentAddr(v) + 2));
					op = (int)(sqlite3WhereCodeOneLoopStart_aStartOp[((nConstraint) > (1)) * 4 + 2 + bRev]);
					sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint - startEq));
				}
			}

			nConstraint = (int)(nEq);
			if ((pRangeEnd) != null)
			{
				Expr pRight = pRangeEnd.pExpr.pRight;
				if ((addrSeekScan) != 0)
				{
					pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
				}

				codeExprOrVector(pParse, pRight, (int)(regBase + nEq), (int)(nTop));
				whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
				if (((pRangeEnd.wtFlags & 0x0080) == (0)) && ((sqlite3ExprCanBeNull(pRight)) != 0))
				{
					sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + nEq), (int)(addrNxt));
				}

				if ((zEndAff) != null)
				{
					updateRangeAffinityStr(pRight, (int)(nTop), zEndAff);
					codeApplyAffinity(pParse, (int)(regBase + nEq), (int)(nTop), zEndAff);
				}
				else
				{
				}

				nConstraint += (int)(nTop);
				if ((sqlite3ExprIsVector(pRight)) == (0))
				{
					disableTerm(pLevel, pRangeEnd);
				}
				else
				{
					endEq = (int)(1);
				}
			}
			else if ((bStopAtNull) != 0)
			{
				if ((regBignull) == (0))
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
					endEq = (int)(0);
				}

				nConstraint++;
			}

			sqlite3DbFree(db, zStartAff);
			sqlite3DbFree(db, zEndAff);
			if ((pLevel.p2) == (0))
				pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
			if ((nConstraint) != 0)
			{
				if ((regBignull) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(20), (int)(regBignull), (int)(sqlite3VdbeCurrentAddr(v) + 3));
				}

				op = (int)(sqlite3WhereCodeOneLoopStart_aEndOp[bRev * 2 + endEq]);
				sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint));
				if ((addrSeekScan) != 0)
					sqlite3VdbeJumpHere(v, (int)(addrSeekScan));
			}

			if ((regBignull) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(18), (int)(regBignull), (int)(sqlite3VdbeCurrentAddr(v) + 2));
				op = (int)(sqlite3WhereCodeOneLoopStart_aEndOp[bRev * 2 + bSeekPastNull]);
				sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint + bSeekPastNull));
			}

			if ((pLoop.wsFlags & 0x00040000) != 0)
			{
				sqlite3VdbeAddOp3(v, (int)(124), (int)(iIdxCur), (int)(nEq), (int)(nEq));
			}

			omitTable = (int)(((pLoop.wsFlags & 0x00000040) != 0) && ((pWInfo.wctrlFlags & 0x0020) == (0)) ? 1 : 0);
			if ((omitTable) != 0)
			{
			}
			else if ((((pIdx.pTable).tabFlags & 0x00000080) == (0)))
			{
				codeDeferredSeek(pWInfo, pIdx, (int)(iCur), (int)(iIdxCur));
			}
			else if (iCur != iIdxCur)
			{
				Index pPk = sqlite3PrimaryKeyIndex(pIdx.pTable);
				iRowidReg = (int)(sqlite3GetTempRange(pParse, (int)(pPk.nKeyCol)));
				for (j = (int)(0); (j) < (pPk.nKeyCol); j++)
				{
					k = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[j])));
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(k), (int)(iRowidReg + j));
				}

				sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iCur), (int)(addrCont), (int)(iRowidReg), (int)(pPk.nKeyCol));
			}

			if ((pLevel.iLeftJoin) == (0))
			{
				if ((pWInfo.wctrlFlags & 0x0020) == (0))
				{
					whereIndexExprTrans(pIdx, (int)(iCur), (int)(iIdxCur), pWInfo);
				}

				if ((pIdx.pPartIdxWhere) != null)
				{
					whereApplyPartialIndexConstraints(pIdx.pPartIdxWhere, (int)(iCur), pWC);
				}
			}
			else
			{
			}

			if ((pLoop.wsFlags & 0x00001000) != 0)
			{
				pLevel.op = (byte)(182);
			}
			else if ((bRev) != 0)
			{
				pLevel.op = (byte)(4);
			}
			else
			{
				pLevel.op = (byte)(5);
			}

			pLevel.p1 = (int)(iIdxCur);
			pLevel.p3 = (byte)((pLoop.wsFlags & 0x00010000) != 0 ? 1 : 0);
			if ((pLoop.wsFlags & 0x0000000f) == (0))
			{
				pLevel.p5 = (byte)(1);
			}
			else
			{
			}

			if ((omitTable) != 0)
				pIdx = null;
		}
		else if ((pLoop.wsFlags & 0x00002000) != 0)
		{
			WhereClause pOrWc;
			SrcList pOrTab;
			Index pCov = null;
			int iCovCur = (int)(pParse.nTab++);
			int regReturn = (int)(++pParse.nMem);
			int regRowset = (int)(0);
			int regRowid = (int)(0);
			int iLoopBody = (int)(sqlite3VdbeMakeLabel(pParse));
			int iRetInit = 0;
			int untestedTerms = (int)(0);
			int ii = 0;
			Expr pAndExpr = null;
			Table pTab = pTabItem.pTab;
			pTerm = pLoop.aLTerm[0];
			pOrWc = pTerm.u.pOrInfo.wc;
			pLevel.op = (byte)(67);
			pLevel.p1 = (int)(regReturn);
			if ((pWInfo.nLevel) > (1))
			{
				int nNotReady = 0;
				SrcItem origSrc;
				nNotReady = (int)(pWInfo.nLevel - iLevel - 1);
				pOrTab = sqlite3DbMallocRaw(db, (ulong)(sizeof(SrcList) + nNotReady * sizeof(SrcItem)));
				if ((pOrTab) == (null))
					return (ulong)(notReady);
				pOrTab.nAlloc = (uint)((byte)(nNotReady + 1));
				pOrTab.nSrc = (int)(pOrTab.nAlloc);
				CRuntime.memcpy(pOrTab.a, pTabItem, (ulong)(sizeof(SrcItem)));
				origSrc = pWInfo.pTabList.a;
				for (k = (int)(1); (k) <= (nNotReady); k++)
				{
					CRuntime.memcpy(pOrTab.a[k], origSrc[pLevel[k].iFrom], (ulong)(sizeof(SrcItem)));
				}
			}
			else
			{
				pOrTab = pWInfo.pTabList;
			}

			if ((pWInfo.wctrlFlags & 0x0010) == (0))
			{
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					regRowset = (int)(++pParse.nMem);
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regRowset));
				}
				else
				{
					Index pPk = sqlite3PrimaryKeyIndex(pTab);
					regRowset = (int)(pParse.nTab++);
					sqlite3VdbeAddOp2(v, (int)(116), (int)(regRowset), (int)(pPk.nKeyCol));
					sqlite3VdbeSetP4KeyInfo(pParse, pPk);
				}

				regRowid = (int)(++pParse.nMem);
			}

			iRetInit = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regReturn)));
			if ((pWC.nTerm) > (1))
			{
				int iTerm = 0;
				for (iTerm = (int)(0); (iTerm) < (pWC.nTerm); iTerm++)
				{
					Expr pExpr = pWC.a[iTerm].pExpr;
					if ((pWC.a[iTerm]) == (pTerm))
						continue;
					if ((pWC.a[iTerm].wtFlags & (0x0002 | 0x0004 | 0x8000)) != 0)
					{
						continue;
					}

					if ((pWC.a[iTerm].eOperator & 0x1fff) == (0))
						continue;
					if ((((pExpr).flags & (0x200000)) != 0))
						continue;
					pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
					pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
				}

				if ((pAndExpr) != null)
				{
					pAndExpr = sqlite3PExpr(pParse, (int)(44 | 0x10000), null, pAndExpr);
				}
			}

			sqlite3VdbeExplain(pParse, (byte)(1), "MULTI-INDEX OR");
			for (ii = (int)(0); (ii) < (pOrWc.nTerm); ii++)
			{
				WhereTerm pOrTerm = pOrWc.a[ii];
				if (((pOrTerm.leftCursor) == (iCur)) || ((pOrTerm.eOperator & 0x0400) != 0))
				{
					WhereInfo pSubWInfo;
					Expr pOrExpr = pOrTerm.pExpr;
					Expr pDelete;
					int jmp1 = (int)(0);
					pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, (int)(0));
					if ((db.mallocFailed) != 0)
					{
						sqlite3ExprDelete(db, pDelete);
						continue;
					}

					if ((pAndExpr) != null)
					{
						pAndExpr.pLeft = pOrExpr;
						pOrExpr = pAndExpr;
					}

					sqlite3VdbeExplain(pParse, (byte)(1), "INDEX %d", (int)(ii + 1));
					pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, null, null, null, (ushort)(0x0020), (int)(iCovCur));
					if ((pSubWInfo) != null)
					{
						WhereLoop pSubLoop;
						int addrExplain = (int)(sqlite3WhereExplainOneScan(pParse, pOrTab, pSubWInfo.a[0], (ushort)(0)));
						((void)(addrExplain));
						if ((pWInfo.wctrlFlags & 0x0010) == (0))
						{
							int iSet = (int)(((ii) == (pOrWc.nTerm - 1)) ? -1 : ii);
							if ((((pTab).tabFlags & 0x00000080) == (0)))
							{
								sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(-1), (int)(regRowid));
								jmp1 = (int)(sqlite3VdbeAddOp4Int(v, (int)(46), (int)(regRowset), (int)(0), (int)(regRowid), (int)(iSet)));
							}
							else
							{
								Index pPk = sqlite3PrimaryKeyIndex(pTab);
								int nPk = (int)(pPk.nKeyCol);
								int iPk = 0;
								int r = 0;
								r = (int)(sqlite3GetTempRange(pParse, (int)(nPk)));
								for (iPk = (int)(0); (iPk) < (nPk); iPk++)
								{
									int iCol = (int)(pPk.aiColumn[iPk]);
									sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(iCol), (int)(r + iPk));
								}

								if ((iSet) != 0)
								{
									jmp1 = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(regRowset), (int)(0), (int)(r), (int)(nPk)));
								}

								if ((iSet) >= (0))
								{
									sqlite3VdbeAddOp3(v, (int)(96), (int)(r), (int)(nPk), (int)(regRowid));
									sqlite3VdbeAddOp4Int(v, (int)(137), (int)(regRowset), (int)(regRowid), (int)(r), (int)(nPk));
									if ((iSet) != 0)
										sqlite3VdbeChangeP5(v, (ushort)(0x10));
								}

								sqlite3ReleaseTempRange(pParse, (int)(r), (int)(nPk));
							}
						}

						sqlite3VdbeAddOp2(v, (int)(12), (int)(regReturn), (int)(iLoopBody));
						if ((jmp1) != 0)
							sqlite3VdbeJumpHere(v, (int)(jmp1));
						if ((pSubWInfo.untestedTerms) != 0)
							untestedTerms = (int)(1);
						pSubLoop = pSubWInfo.a[0].pWLoop;
						if ((((pSubLoop.wsFlags & 0x00000200) != 0) && (((ii) == (0)) || ((pSubLoop.u.btree.pIndex) == (pCov)))) && ((((pTab).tabFlags & 0x00000080) == (0)) || (!(((pSubLoop.u.btree.pIndex).idxType) == (2)))))
						{
							pCov = pSubLoop.u.btree.pIndex;
						}
						else
						{
							pCov = null;
						}

						if ((sqlite3WhereUsesDeferredSeek(pSubWInfo)) != 0)
						{
							pWInfo.bDeferredSeek = (uint)(1);
						}

						sqlite3WhereEnd(pSubWInfo);
						sqlite3VdbeExplainPop(pParse);
					}

					sqlite3ExprDelete(db, pDelete);
				}
			}

			sqlite3VdbeExplainPop(pParse);
			pLevel.u.pCoveringIdx = pCov;
			if ((pCov) != null)
				pLevel.iIdxCur = (int)(iCovCur);
			if ((pAndExpr) != null)
			{
				pAndExpr.pLeft = null;
				sqlite3ExprDelete(db, pAndExpr);
			}

			sqlite3VdbeChangeP1(v, (int)(iRetInit), (int)(sqlite3VdbeCurrentAddr(v)));
			sqlite3VdbeGoto(v, (int)(pLevel.addrBrk));
			sqlite3VdbeResolveLabel(v, (int)(iLoopBody));
			if ((pWInfo.nLevel) > (1))
			{
				sqlite3DbFree(db, pOrTab);
			}

			if (untestedTerms == 0)
				disableTerm(pLevel, pTerm);
		}
		else
		{
			if ((pTabItem.fg.isRecursive) != 0)
			{
				pLevel.op = (byte)(182);
			}
			else
			{
				pLevel.op = (byte)(sqlite3WhereCodeOneLoopStart_aStep[bRev]);
				pLevel.p1 = (int)(iCur);
				pLevel.p2 = (int)(1 + sqlite3VdbeAddOp2(v, (int)(sqlite3WhereCodeOneLoopStart_aStart[bRev]), (int)(iCur), (int)(addrHalt)));
				pLevel.p5 = (byte)(1);
			}
		}

		iLoop = (int)(pIdx ? 1 : 2);
		do
		{
			int iNext = (int)(0);
			for (pTerm = pWC.a, j = (int)(pWC.nTerm); (j) > (0); j--, pTerm++)
			{
				Expr pE;
				int skipLikeAddr = (int)(0);
				if ((pTerm.wtFlags & (0x0002 | 0x0004)) != 0)
					continue;
				if ((pTerm.prereqAll & pLevel.notReady) != 0)
				{
					pWInfo.untestedTerms = (uint)(1);
					continue;
				}

				pE = pTerm.pExpr;
				if (((pTabItem.fg.jointype & 0x0008) != 0) && (!(((pE).flags & (0x000001)) != 0)))
				{
					continue;
				}

				if (((iLoop) == (1)) && (sqlite3ExprCoveredByIndex(pE, (int)(pLevel.iTabCur), pIdx) == 0))
				{
					iNext = (int)(2);
					continue;
				}

				if (((iLoop) < (3)) && ((pTerm.wtFlags & 0x1000) != 0))
				{
					if ((iNext) == (0))
						iNext = (int)(3);
					continue;
				}

				if ((pTerm.wtFlags & 0x0200) != 0)
				{
					uint x = (uint)(pLevel.iLikeRepCntr);
					if ((x) > (0))
					{
						skipLikeAddr = (int)(sqlite3VdbeAddOp1(v, (int)((x & 1) ? 20 : 18), (int)(x >> 1)));
					}
				}

				sqlite3ExprIfFalse(pParse, pE, (int)(addrCont), (int)(0x10));
				if ((skipLikeAddr) != 0)
					sqlite3VdbeJumpHere(v, (int)(skipLikeAddr));
				pTerm.wtFlags |= (ushort)(0x0004);
			}

			iLoop = (int)(iNext);
		}
		while ((iLoop) > (0));
		for (pTerm = pWC.a, j = (int)(pWC.nBase); (j) > (0); j--, pTerm++)
		{
			Expr pE;
			Expr sEAlt = new Expr();
			WhereTerm pAlt;
			if ((pTerm.wtFlags & (0x0002 | 0x0004)) != 0)
				continue;
			if ((pTerm.eOperator & (0x0002 | 0x0080)) == (0))
				continue;
			if ((pTerm.eOperator & 0x0800) == (0))
				continue;
			if (pTerm.leftCursor != iCur)
				continue;
			if ((pTabItem.fg.jointype & 0x0008) != 0)
				continue;
			pE = pTerm.pExpr;
			pAlt = sqlite3WhereFindTerm(pWC, (int)(iCur), (int)(pTerm.u.x.leftColumn), (ulong)(notReady), (uint)(0x0002 | 0x0001 | 0x0080), null);
			if ((pAlt) == (null))
				continue;
			if ((pAlt.wtFlags & (0x0004)) != 0)
				continue;
			if ((((pAlt.eOperator & 0x0001) != 0) && (((pAlt.pExpr).flags & 0x000800) != 0)) && ((pAlt.pExpr.x.pSelect.pEList.nExpr) > (1)))
			{
				continue;
			}

			sEAlt = (Expr)(pAlt.pExpr);
			sEAlt.pLeft = pE.pLeft;
			sqlite3ExprIfFalse(pParse, sEAlt, (int)(addrCont), (int)(0x10));
			pAlt.wtFlags |= (ushort)(0x0004);
		}

		if ((pLevel.iLeftJoin) != 0)
		{
			pLevel.addrFirst = (int)(sqlite3VdbeCurrentAddr(v));
			sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pLevel.iLeftJoin));
			for (pTerm = pWC.a, j = (int)(0); (j) < (pWC.nBase); j++, pTerm++)
			{
				if ((pTerm.wtFlags & (0x0002 | 0x0004)) != 0)
					continue;
				if ((pTerm.prereqAll & pLevel.notReady) != 0)
				{
					continue;
				}

				sqlite3ExprIfFalse(pParse, pTerm.pExpr, (int)(addrCont), (int)(0x10));
				pTerm.wtFlags |= (ushort)(0x0004);
			}
		}

		return (ulong)(pLevel.notReady);
	}
	public static int sqlite3WhereExplainBloomFilter(Parse pParse, WhereInfo pWInfo, WhereLevel pLevel)
	{
		int ret = (int)(0);
		SrcItem pItem = pWInfo.pTabList.a[pLevel.iFrom];
		Vdbe v = pParse.pVdbe;
		sqlite3 db = pParse.db;
		sbyte* zMsg;
		int i = 0;
		WhereLoop pLoop;
		sqlite3_str str = new sqlite3_str();
		sbyte* zBuf = stackalloc sbyte[100];
		sqlite3StrAccumInit(str, db, zBuf, (int)(100 * sizeof(sbyte)), (int)(1000000000));
		str.printfFlags = (byte)(0x01);
		sqlite3_str_appendf(str, "BLOOM FILTER ON %S (", pItem);
		pLoop = pLevel.pWLoop;
		if ((pLoop.wsFlags & 0x00000100) != 0)
		{
			Table pTab = pItem.pTab;
			if ((pTab.iPKey) >= (0))
			{
				sqlite3_str_appendf(str, "%s=?", pTab.aCol[pTab.iPKey].zCnName);
			}
			else
			{
				sqlite3_str_appendf(str, "rowid=?");
			}
		}
		else
		{
			for (i = (int)(pLoop.nSkip); (i) < (pLoop.u.btree.nEq); i++)
			{
				sbyte* z = explainIndexColumnName(pLoop.u.btree.pIndex, (int)(i));
				if ((i) > (pLoop.nSkip))
					sqlite3_str_append(str, " AND ", (int)(5));
				sqlite3_str_appendf(str, "%s=?", z);
			}
		}

		sqlite3_str_append(str, ")", (int)(1));
		zMsg = sqlite3StrAccumFinish(str);
		ret = (int)(sqlite3VdbeAddOp4(v, (int)(183), (int)(sqlite3VdbeCurrentAddr(v)), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7)));
		return (int)(ret);
	}
	public static int sqlite3WhereExplainOneScan(Parse pParse, SrcList pTabList, WhereLevel pLevel, ushort wctrlFlags)
	{
		int ret = (int)(0);
		if ((((pParse).pToplevel ? (pParse).pToplevel : (pParse)).explain) == (2))
		{
			SrcItem pItem = pTabList.a[pLevel.iFrom];
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			int isSearch = 0;
			WhereLoop pLoop;
			uint flags = 0;
			sbyte* zMsg;
			sqlite3_str str = new sqlite3_str();
			sbyte* zBuf = stackalloc sbyte[100];
			pLoop = pLevel.pWLoop;
			flags = (uint)(pLoop.wsFlags);
			if (((flags & 0x00002000) != 0) || ((wctrlFlags & 0x0020) != 0))
				return (int)(0);
			isSearch = (int)((((flags & (0x00000020 | 0x00000010)) != 0) || (((flags & 0x00000400) == (0)) && ((pLoop.u.btree.nEq) > (0)))) || ((wctrlFlags & (0x0001 | 0x0002)) != 0) ? 1 : 0);
			sqlite3StrAccumInit(str, db, zBuf, (int)(100 * sizeof(sbyte)), (int)(1000000000));
			str.printfFlags = (byte)(0x01);
			sqlite3_str_appendf(str, "%s %S", (isSearch) != 0 ? "SEARCH" : "SCAN", pItem);
			if ((flags & (0x00000100 | 0x00000400)) == (0))
			{
				sbyte* zFmt = null;
				Index pIdx;
				pIdx = pLoop.u.btree.pIndex;
				if ((!(((pItem.pTab).tabFlags & 0x00000080) == (0))) && (((pIdx).idxType) == (2)))
				{
					if ((isSearch) != 0)
					{
						zFmt = "PRIMARY KEY";
					}
				}
				else if ((flags & 0x00020000) != 0)
				{
					zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
				}
				else if ((flags & 0x00004000) != 0)
				{
					zFmt = "AUTOMATIC COVERING INDEX";
				}
				else if ((flags & 0x00000040) != 0)
				{
					zFmt = "COVERING INDEX %s";
				}
				else
				{
					zFmt = "INDEX %s";
				}

				if ((zFmt) != null)
				{
					sqlite3_str_append(str, " USING ", (int)(7));
					sqlite3_str_appendf(str, zFmt, pIdx.zName);
					explainIndexRange(str, pLoop);
				}
			}
			else if (((flags & 0x00000100) != 0) && ((flags & 0x0000000f) != 0))
			{
				sbyte cRangeOp = 0;
				sbyte* zRowid = "rowid";
				sqlite3_str_appendf(str, " USING INTEGER PRIMARY KEY (%s", zRowid);
				if ((flags & (0x00000001 | 0x00000004)) != 0)
				{
					cRangeOp = (sbyte)(61);
				}
				else if ((flags & 0x00000030) == (0x00000030))
				{
					sqlite3_str_appendf(str, ">? AND %s", zRowid);
					cRangeOp = (sbyte)(60);
				}
				else if ((flags & 0x00000020) != 0)
				{
					cRangeOp = (sbyte)(62);
				}
				else
				{
					cRangeOp = (sbyte)(60);
				}

				sqlite3_str_appendf(str, "%c?)", (int)(cRangeOp));
			}
			else if ((flags & 0x00000400) != 0)
			{
				sqlite3_str_appendf(str, " VIRTUAL TABLE INDEX %d:%s", (int)(pLoop.u.vtab.idxNum), pLoop.u.vtab.idxStr);
			}

			zMsg = sqlite3StrAccumFinish(str);
			ret = (int)(sqlite3VdbeAddOp4(v, (int)(183), (int)(sqlite3VdbeCurrentAddr(v)), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7)));
		}

		return (int)(ret);
	}
	public static void sqlite3WhereTabFuncArgs(Parse pParse, SrcItem pItem, WhereClause pWC)
	{
		Table pTab;
		int j = 0; int k = 0;
		ExprList pArgs;
		Expr pColRef;
		Expr pTerm;
		if ((pItem.fg.isTabFunc) == (0))
			return;
		pTab = pItem.pTab;
		pArgs = pItem.u1.pFuncArg;
		if ((pArgs) == (null))
			return;
		for (j = (int)(k = (int)(0)); (j) < (pArgs.nExpr); j++)
		{
			Expr pRhs;
			while (((k) < (pTab.nCol)) && ((pTab.aCol[k].colFlags & 0x0002) == (0)))
			{
				k++;
			}

			if ((k) >= (pTab.nCol))
			{
				sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d", pTab.zName, (int)(j));
				return;
			}

			pColRef = sqlite3ExprAlloc(pParse.db, (int)(167), null, (int)(0));
			if ((pColRef) == (null))
				return;
			pColRef.iTable = (int)(pItem.iCursor);
			pColRef.iColumn = (short)(k++);
			pColRef.y.pTab = pTab;
			pItem.colUsed |= (ulong)(sqlite3ExprColUsed(pColRef));
			pRhs = sqlite3PExpr(pParse, (int)(174), sqlite3ExprDup(pParse.db, pArgs.a[j].pExpr, (int)(0)), null);
			pTerm = sqlite3PExpr(pParse, (int)(53), pColRef, pRhs);
			if ((pItem.fg.jointype & 0x0008) != 0)
			{
				sqlite3SetJoinExpr(pTerm, (int)(pItem.iCursor));
			}

			whereClauseInsert(pWC, pTerm, (ushort)(0x0001));
		}
	}
	public static Window sqlite3WindowAlloc(Parse pParse, int eType, int eStart, Expr pStart, int eEnd, Expr pEnd, byte eExclude)
	{
		Window pWin = null;
		int bImplicitFrame = (int)(0);
		if ((eType) == (0))
		{
			bImplicitFrame = (int)(1);
			eType = (int)(89);
		}

		if ((((eStart) == (85)) && ((eEnd) == (88))) || (((eStart) == (86)) && (((eEnd) == (88)) || ((eEnd) == (85)))))
		{
			sqlite3ErrorMsg(pParse, "unsupported frame specification");
			goto windowAllocErr;
		}

		pWin = (Window)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(Window))));
		if ((pWin) == (null))
			goto windowAllocErr;
		pWin.eFrmType = (byte)(eType);
		pWin.eStart = (byte)(eStart);
		pWin.eEnd = (byte)(eEnd);
		if (((eExclude) == (0)) && (((pParse.db).dbOptFlags & (0x00000002)) != 0))
		{
			eExclude = (byte)(66);
		}

		pWin.eExclude = (byte)(eExclude);
		pWin.bImplicitFrame = (byte)(bImplicitFrame);
		pWin.pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
		pWin.pStart = sqlite3WindowOffsetExpr(pParse, pStart);
		return pWin;
	windowAllocErr:
		; sqlite3ExprDelete(pParse.db, pEnd);
		sqlite3ExprDelete(pParse.db, pStart);
		return null;
	}
	public static Window sqlite3WindowAssemble(Parse pParse, Window pWin, ExprList pPartition, ExprList pOrderBy, Token* pBase)
	{
		if ((pWin) != null)
		{
			pWin.pPartition = pPartition;
			pWin.pOrderBy = pOrderBy;
			if ((pBase) != null)
			{
				pWin.zBase = sqlite3DbStrNDup(pParse.db, pBase->z, (ulong)(pBase->n));
			}
		}
		else
		{
			sqlite3ExprListDelete(pParse.db, pPartition);
			sqlite3ExprListDelete(pParse.db, pOrderBy);
		}

		return pWin;
	}
	public static void sqlite3WindowAttach(Parse pParse, Expr p, Window pWin)
	{
		if ((p) != null)
		{
			p.y.pWin = pWin;
			(p).flags |= (uint)(0x1000000);
			pWin.pOwner = p;
			if (((p.flags & 0x000002) != 0) && (pWin.eFrmType != 166))
			{
				sqlite3ErrorMsg(pParse, "DISTINCT is not supported for window functions");
			}
		}
		else
		{
			sqlite3WindowDelete(pParse.db, pWin);
		}
	}
	public static void sqlite3WindowChain(Parse pParse, Window pWin, Window pList)
	{
		if ((pWin.zBase) != null)
		{
			sqlite3 db = pParse.db;
			Window pExist = windowFind(pParse, pList, pWin.zBase);
			if ((pExist) != null)
			{
				sbyte* zErr = null;
				if ((pWin.pPartition) != null)
				{
					zErr = "PARTITION clause";
				}
				else if (((pExist.pOrderBy) != null) && ((pWin.pOrderBy) != null))
				{
					zErr = "ORDER BY clause";
				}
				else if ((pExist.bImplicitFrame) == (0))
				{
					zErr = "frame specification";
				}

				if ((zErr) != null)
				{
					sqlite3ErrorMsg(pParse, "cannot override %s of window: %s", zErr, pWin.zBase);
				}
				else
				{
					pWin.pPartition = sqlite3ExprListDup(db, pExist.pPartition, (int)(0));
					if ((pExist.pOrderBy) != null)
					{
						pWin.pOrderBy = sqlite3ExprListDup(db, pExist.pOrderBy, (int)(0));
					}

					sqlite3DbFree(db, pWin.zBase);
					pWin.zBase = null;
				}
			}
		}
	}
	public static void sqlite3WindowCodeInit(Parse pParse, Select pSelect)
	{
		int nEphExpr = (int)(pSelect.pSrc.a[0].pSelect.pEList.nExpr);
		Window pMWin = pSelect.pWin;
		Window pWin;
		Vdbe v = sqlite3GetVdbe(pParse);
		sqlite3VdbeAddOp2(v, (int)(116), (int)(pMWin.iEphCsr), (int)(nEphExpr));
		sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 1), (int)(pMWin.iEphCsr));
		sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 2), (int)(pMWin.iEphCsr));
		sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 3), (int)(pMWin.iEphCsr));
		if ((pMWin.pPartition) != null)
		{
			int nExpr = (int)(pMWin.pPartition.nExpr);
			pMWin.regPart = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nExpr);
			sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(pMWin.regPart), (int)(pMWin.regPart + nExpr - 1));
		}

		pMWin.regOne = (int)(++pParse.nMem);
		sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regOne));
		if ((pMWin.eExclude) != 0)
		{
			pMWin.regStartRowid = (int)(++pParse.nMem);
			pMWin.regEndRowid = (int)(++pParse.nMem);
			pMWin.csrApp = (int)(pParse.nTab++);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regStartRowid));
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pMWin.regEndRowid));
			sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.csrApp), (int)(pMWin.iEphCsr));
			return;
		}

		for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
		{
			FuncDef p = pWin.pFunc;
			if (((p.funcFlags & 0x1000) != 0) && (pWin.eStart != 90))
			{
				ExprList pList;
				KeyInfo pKeyInfo;
				pList = pWin.pOwner.x.pList;
				pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, (int)(0), (int)(0));
				pWin.csrApp = (int)(pParse.nTab++);
				pWin.regApp = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(3);
				if (((pKeyInfo) != null) && ((pWin.pFunc.zName[1]) == (105)))
				{
					pKeyInfo.aSortFlags[0] = (byte)(0x01);
				}

				sqlite3VdbeAddOp2(v, (int)(116), (int)(pWin.csrApp), (int)(2));
				sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
			}
			else if (((p.zName) == (nth_valueName)) || ((p.zName) == (first_valueName)))
			{
				pWin.regApp = (int)(pParse.nMem + 1);
				pWin.csrApp = (int)(pParse.nTab++);
				pParse.nMem += (int)(2);
				sqlite3VdbeAddOp2(v, (int)(113), (int)(pWin.csrApp), (int)(pMWin.iEphCsr));
			}
			else if (((p.zName) == (leadName)) || ((p.zName) == (lagName)))
			{
				pWin.csrApp = (int)(pParse.nTab++);
				sqlite3VdbeAddOp2(v, (int)(113), (int)(pWin.csrApp), (int)(pMWin.iEphCsr));
			}
		}
	}
	public static void sqlite3WindowCodeStep(Parse pParse, Select p, WhereInfo pWInfo, int regGosub, int addrGosub)
	{
		Window pMWin = p.pWin;
		ExprList pOrderBy = pMWin.pOrderBy;
		Vdbe v = sqlite3GetVdbe(pParse);
		int csrWrite = 0;
		int csrInput = (int)(p.pSrc.a[0].iCursor);
		int nInput = (int)(p.pSrc.a[0].pTab.nCol);
		int iInput = 0;
		int addrNe = 0;
		int addrGosubFlush = (int)(0);
		int addrInteger = (int)(0);
		int addrEmpty = 0;
		int regNew = 0;
		int regRecord = 0;
		int regNewPeer = (int)(0);
		int regPeer = (int)(0);
		int regFlushPart = (int)(0);
		WindowCodeArg s = new WindowCodeArg();
		int lblWhereEnd = 0;
		int regStart = (int)(0);
		int regEnd = (int)(0);
		lblWhereEnd = (int)(sqlite3VdbeMakeLabel(pParse));
		CRuntime.memset(s, (int)(0), (ulong)(sizeof(WindowCodeArg)));
		s.pParse = pParse;
		s.pMWin = pMWin;
		s.pVdbe = v;
		s.regGosub = (int)(regGosub);
		s.addrGosub = (int)(addrGosub);
		s.current.csr = (int)(pMWin.iEphCsr);
		csrWrite = (int)(s.current.csr + 1);
		s.start.csr = (int)(s.current.csr + 2);
		s.end.csr = (int)(s.current.csr + 3);
		switch (pMWin.eStart)
		{
			case 86:
				if ((pMWin.eFrmType != 89) && ((windowExprGtZero(pParse, pMWin.pStart)) != 0))
				{
					s.eDelete = (int)(1);
				}

				break;
			case 90:
				if ((windowCacheFrame(pMWin)) == (0))
				{
					if ((pMWin.eEnd) == (88))
					{
						if ((pMWin.eFrmType != 89) && ((windowExprGtZero(pParse, pMWin.pEnd)) != 0))
						{
							s.eDelete = (int)(3);
						}
					}
					else
					{
						s.eDelete = (int)(1);
					}
				}

				break;
			default:
				s.eDelete = (int)(2);
				break;
		}

		regNew = (int)(pParse.nMem + 1);
		pParse.nMem += (int)(nInput);
		regRecord = (int)(++pParse.nMem);
		s.regRowid = (int)(++pParse.nMem);
		if (((pMWin.eStart) == (88)) || ((pMWin.eStart) == (86)))
		{
			regStart = (int)(++pParse.nMem);
		}

		if (((pMWin.eEnd) == (88)) || ((pMWin.eEnd) == (86)))
		{
			regEnd = (int)(++pParse.nMem);
		}

		if (pMWin.eFrmType != 76)
		{
			int nPeer = (int)(pOrderBy ? pOrderBy.nExpr : 0);
			regNewPeer = (int)(regNew + pMWin.nBufferCol);
			if ((pMWin.pPartition) != null)
				regNewPeer += (int)(pMWin.pPartition.nExpr);
			regPeer = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nPeer);
			s.start.reg = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nPeer);
			s.current.reg = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nPeer);
			s.end.reg = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nPeer);
		}

		for (iInput = (int)(0); (iInput) < (nInput); iInput++)
		{
			sqlite3VdbeAddOp3(v, (int)(93), (int)(csrInput), (int)(iInput), (int)(regNew + iInput));
		}

		sqlite3VdbeAddOp3(v, (int)(96), (int)(regNew), (int)(nInput), (int)(regRecord));
		if ((pMWin.pPartition) != null)
		{
			int addr = 0;
			ExprList pPart = pMWin.pPartition;
			int nPart = (int)(pPart.nExpr);
			int regNewPart = (int)(regNew + pMWin.nBufferCol);
			KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, (int)(0), (int)(0));
			regFlushPart = (int)(++pParse.nMem);
			addr = (int)(sqlite3VdbeAddOp3(v, (int)(89), (int)(regNewPart), (int)(pMWin.regPart), (int)(nPart)));
			sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
			sqlite3VdbeAddOp3(v, (int)(16), (int)(addr + 2), (int)(addr + 4), (int)(addr + 2));
			addrGosubFlush = (int)(sqlite3VdbeAddOp1(v, (int)(12), (int)(regFlushPart)));
			sqlite3VdbeAddOp3(v, (int)(79), (int)(regNewPart), (int)(pMWin.regPart), (int)(nPart - 1));
		}

		sqlite3VdbeAddOp2(v, (int)(126), (int)(csrWrite), (int)(s.regRowid));
		sqlite3VdbeAddOp3(v, (int)(127), (int)(csrWrite), (int)(regRecord), (int)(s.regRowid));
		addrNe = (int)(sqlite3VdbeAddOp3(v, (int)(52), (int)(pMWin.regOne), (int)(0), (int)(s.regRowid)));
		s.regArg = (int)(windowInitAccum(pParse, pMWin));
		if ((regStart) != 0)
		{
			sqlite3ExprCode(pParse, pMWin.pStart, (int)(regStart));
			windowCheckValue(pParse, (int)(regStart), (int)(0 + ((pMWin.eFrmType) == (89) ? 3 : 0)));
		}

		if ((regEnd) != 0)
		{
			sqlite3ExprCode(pParse, pMWin.pEnd, (int)(regEnd));
			windowCheckValue(pParse, (int)(regEnd), (int)(1 + ((pMWin.eFrmType) == (89) ? 3 : 0)));
		}

		if (((pMWin.eFrmType != 89) && ((pMWin.eStart) == (pMWin.eEnd))) && ((regStart) != 0))
		{
			int op = (int)(((pMWin.eStart) == (86)) ? 57 : 55);
			int addrGe = (int)(sqlite3VdbeAddOp3(v, (int)(op), (int)(regStart), (int)(0), (int)(regEnd)));
			windowAggFinal(s, (int)(0));
			sqlite3VdbeAddOp2(v, (int)(38), (int)(s.current.csr), (int)(1));
			windowReturnOneRow(s);
			sqlite3VdbeAddOp1(v, (int)(145), (int)(s.current.csr));
			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblWhereEnd));
			sqlite3VdbeJumpHere(v, (int)(addrGe));
		}

		if ((((pMWin.eStart) == (86)) && (pMWin.eFrmType != 89)) && ((regEnd) != 0))
		{
			sqlite3VdbeAddOp3(v, (int)(107), (int)(regStart), (int)(regEnd), (int)(regStart));
		}

		if (pMWin.eStart != 90)
		{
			sqlite3VdbeAddOp2(v, (int)(38), (int)(s.start.csr), (int)(1));
		}

		sqlite3VdbeAddOp2(v, (int)(38), (int)(s.current.csr), (int)(1));
		sqlite3VdbeAddOp2(v, (int)(38), (int)(s.end.csr), (int)(1));
		if (((regPeer) != 0) && ((pOrderBy) != null))
		{
			sqlite3VdbeAddOp3(v, (int)(79), (int)(regNewPeer), (int)(regPeer), (int)(pOrderBy.nExpr - 1));
			sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.start.reg), (int)(pOrderBy.nExpr - 1));
			sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.current.reg), (int)(pOrderBy.nExpr - 1));
			sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.end.reg), (int)(pOrderBy.nExpr - 1));
		}

		sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblWhereEnd));
		sqlite3VdbeJumpHere(v, (int)(addrNe));
		if ((regPeer) != 0)
		{
			windowIfNewPeer(pParse, pOrderBy, (int)(regNewPeer), (int)(regPeer), (int)(lblWhereEnd));
		}

		if ((pMWin.eStart) == (86))
		{
			windowCodeOp(s, (int)(3), (int)(0), (int)(0));
			if (pMWin.eEnd != 90)
			{
				if ((pMWin.eFrmType) == (89))
				{
					int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
					int addrNext = (int)(sqlite3VdbeCurrentAddr(v));
					windowCodeRangeTest(s, (int)(57), (int)(s.current.csr), (int)(regEnd), (int)(s.end.csr), (int)(lbl));
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
					windowCodeOp(s, (int)(1), (int)(0), (int)(0));
					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrNext));
					sqlite3VdbeResolveLabel(v, (int)(lbl));
				}
				else
				{
					windowCodeOp(s, (int)(1), (int)(regEnd), (int)(0));
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
				}
			}
		}
		else if ((pMWin.eEnd) == (88))
		{
			int bRPS = (int)((((pMWin.eStart) == (88)) && ((pMWin.eFrmType) == (89))) ? 1 : 0);
			windowCodeOp(s, (int)(3), (int)(regEnd), (int)(0));
			if ((bRPS) != 0)
				windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
			windowCodeOp(s, (int)(1), (int)(0), (int)(0));
			if (bRPS == 0)
				windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
		}
		else
		{
			int addr = (int)(0);
			windowCodeOp(s, (int)(3), (int)(0), (int)(0));
			if (pMWin.eEnd != 90)
			{
				if ((pMWin.eFrmType) == (89))
				{
					int lbl = (int)(0);
					addr = (int)(sqlite3VdbeCurrentAddr(v));
					if ((regEnd) != 0)
					{
						lbl = (int)(sqlite3VdbeMakeLabel(pParse));
						windowCodeRangeTest(s, (int)(57), (int)(s.current.csr), (int)(regEnd), (int)(s.end.csr), (int)(lbl));
					}

					windowCodeOp(s, (int)(1), (int)(0), (int)(0));
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
					if ((regEnd) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addr));
						sqlite3VdbeResolveLabel(v, (int)(lbl));
					}
				}
				else
				{
					if ((regEnd) != 0)
					{
						addr = (int)(sqlite3VdbeAddOp3(v, (int)(49), (int)(regEnd), (int)(0), (int)(1)));
					}

					windowCodeOp(s, (int)(1), (int)(0), (int)(0));
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
					if ((regEnd) != 0)
						sqlite3VdbeJumpHere(v, (int)(addr));
				}
			}
		}

		sqlite3VdbeResolveLabel(v, (int)(lblWhereEnd));
		sqlite3WhereEnd(pWInfo);
		if ((pMWin.pPartition) != null)
		{
			addrInteger = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regFlushPart)));
			sqlite3VdbeJumpHere(v, (int)(addrGosubFlush));
		}

		s.regRowid = (int)(0);
		addrEmpty = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(csrWrite)));
		if ((pMWin.eEnd) == (88))
		{
			int bRPS = (int)((((pMWin.eStart) == (88)) && ((pMWin.eFrmType) == (89))) ? 1 : 0);
			windowCodeOp(s, (int)(3), (int)(regEnd), (int)(0));
			if ((bRPS) != 0)
				windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
			windowCodeOp(s, (int)(1), (int)(0), (int)(0));
		}
		else if ((pMWin.eStart) == (86))
		{
			int addrStart = 0;
			int addrBreak1 = 0;
			int addrBreak2 = 0;
			int addrBreak3 = 0;
			windowCodeOp(s, (int)(3), (int)(0), (int)(0));
			if ((pMWin.eFrmType) == (89))
			{
				addrStart = (int)(sqlite3VdbeCurrentAddr(v));
				addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(regStart), (int)(1)));
				addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
			}
			else if ((pMWin.eEnd) == (90))
			{
				addrStart = (int)(sqlite3VdbeCurrentAddr(v));
				addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(regStart), (int)(1)));
				addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(0), (int)(1)));
			}
			else
			{
				addrStart = (int)(sqlite3VdbeCurrentAddr(v));
				addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(regEnd), (int)(1)));
				addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(regStart), (int)(1)));
			}

			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
			sqlite3VdbeJumpHere(v, (int)(addrBreak2));
			addrStart = (int)(sqlite3VdbeCurrentAddr(v));
			addrBreak3 = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
			sqlite3VdbeJumpHere(v, (int)(addrBreak1));
			sqlite3VdbeJumpHere(v, (int)(addrBreak3));
		}
		else
		{
			int addrBreak = 0;
			int addrStart = 0;
			windowCodeOp(s, (int)(3), (int)(0), (int)(0));
			addrStart = (int)(sqlite3VdbeCurrentAddr(v));
			addrBreak = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
			windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
			sqlite3VdbeJumpHere(v, (int)(addrBreak));
		}

		sqlite3VdbeJumpHere(v, (int)(addrEmpty));
		sqlite3VdbeAddOp1(v, (int)(145), (int)(s.current.csr));
		if ((pMWin.pPartition) != null)
		{
			if ((pMWin.regStartRowid) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regStartRowid));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pMWin.regEndRowid));
			}

			sqlite3VdbeChangeP1(v, (int)(addrInteger), (int)(sqlite3VdbeCurrentAddr(v)));
			sqlite3VdbeAddOp1(v, (int)(67), (int)(regFlushPart));
		}
	}
	public static int sqlite3WindowCompare(Parse pParse, Window p1, Window p2, int bFilter)
	{
		int res = 0;
		if (((p1) == (null)) || ((p2) == (null)))
			return (int)(1);
		if (p1.eFrmType != p2.eFrmType)
			return (int)(1);
		if (p1.eStart != p2.eStart)
			return (int)(1);
		if (p1.eEnd != p2.eEnd)
			return (int)(1);
		if (p1.eExclude != p2.eExclude)
			return (int)(1);
		if ((sqlite3ExprCompare(pParse, p1.pStart, p2.pStart, (int)(-1))) != 0)
			return (int)(1);
		if ((sqlite3ExprCompare(pParse, p1.pEnd, p2.pEnd, (int)(-1))) != 0)
			return (int)(1);
		if ((res = (int)(sqlite3ExprListCompare(p1.pPartition, p2.pPartition, (int)(-1)))))
		{
			return (int)(res);
		}

		if ((res = (int)(sqlite3ExprListCompare(p1.pOrderBy, p2.pOrderBy, (int)(-1)))))
		{
			return (int)(res);
		}

		if ((bFilter) != 0)
		{
			if ((res = (int)(sqlite3ExprCompare(pParse, p1.pFilter, p2.pFilter, (int)(-1)))))
			{
				return (int)(res);
			}
		}

		return (int)(0);
	}
	public static Expr sqlite3WindowOffsetExpr(Parse pParse, Expr pExpr)
	{
		if ((0) == (sqlite3ExprIsConstant(pExpr)))
		{
			if (((pParse.eParseMode) >= (2)))
				sqlite3RenameExprUnmap(pParse, pExpr);
			sqlite3ExprDelete(pParse.db, pExpr);
			pExpr = sqlite3ExprAlloc(pParse.db, (int)(121), null, (int)(0));
		}

		return pExpr;
	}
	public static int sqlite3WindowRewrite(Parse pParse, Select p)
	{
		int rc = (int)(0);
		if (((((p.pWin) != null) && ((p.pPrior) == (null))) && ((p.selFlags & 0x0100000) == (0))) && ((!((pParse.eParseMode) >= (2))) != 0))
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			sqlite3 db = pParse.db;
			Select pSub = null;
			SrcList pSrc = p.pSrc;
			Expr pWhere = p.pWhere;
			ExprList pGroupBy = p.pGroupBy;
			Expr pHaving = p.pHaving;
			ExprList pSort = null;
			ExprList pSublist = null;
			Window pMWin = p.pWin;
			Window pWin;
			Table pTab;
			Walker w = new Walker();
			uint selFlags = (uint)(p.selFlags);
			pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
			if ((pTab) == (null))
			{
				return (int)(sqlite3ErrorToParser(db, (int)(7)));
			}

			sqlite3AggInfoPersistWalkerInit(w, pParse);
			sqlite3WalkSelect(w, p);
			if ((p.selFlags & 0x0000008) == (0))
			{
				w.xExprCallback = disallowAggregatesInOrderByCb;
				w.xSelectCallback = null;
				sqlite3WalkExprList(w, p.pOrderBy);
			}

			p.pSrc = null;
			p.pWhere = null;
			p.pGroupBy = null;
			p.pHaving = null;
			p.selFlags &= (uint)(~0x0000008);
			p.selFlags |= (uint)(0x0100000);
			pSort = exprListAppendList(pParse, null, pMWin.pPartition, (int)(1));
			pSort = exprListAppendList(pParse, pSort, pMWin.pOrderBy, (int)(1));
			if ((((pSort) != null) && ((p.pOrderBy) != null)) && ((p.pOrderBy.nExpr) <= (pSort.nExpr)))
			{
				int nSave = (int)(pSort.nExpr);
				pSort.nExpr = (int)(p.pOrderBy.nExpr);
				if ((sqlite3ExprListCompare(pSort, p.pOrderBy, (int)(-1))) == (0))
				{
					sqlite3ExprListDelete(db, p.pOrderBy);
					p.pOrderBy = null;
				}

				pSort.nExpr = (int)(nSave);
			}

			pMWin.iEphCsr = (int)(pParse.nTab++);
			pParse.nTab += (int)(3);
			selectWindowRewriteEList(pParse, pMWin, pSrc, p.pEList, pTab, pSublist);
			selectWindowRewriteEList(pParse, pMWin, pSrc, p.pOrderBy, pTab, pSublist);
			pMWin.nBufferCol = (int)(pSublist ? pSublist.nExpr : 0);
			pSublist = exprListAppendList(pParse, pSublist, pMWin.pPartition, (int)(0));
			pSublist = exprListAppendList(pParse, pSublist, pMWin.pOrderBy, (int)(0));
			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				ExprList pArgs;
				pArgs = pWin.pOwner.x.pList;
				if ((pWin.pFunc.funcFlags & 0x00100000) != 0)
				{
					selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, pSublist);
					pWin.iArgCol = (int)(pSublist ? pSublist.nExpr : 0);
					pWin.bExprArgs = (byte)(1);
				}
				else
				{
					pWin.iArgCol = (int)(pSublist ? pSublist.nExpr : 0);
					pSublist = exprListAppendList(pParse, pSublist, pArgs, (int)(0));
				}

				if ((pWin.pFilter) != null)
				{
					Expr pFilter = sqlite3ExprDup(db, pWin.pFilter, (int)(0));
					pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
				}

				pWin.regAccum = (int)(++pParse.nMem);
				pWin.regResult = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
			}

			if ((pSublist) == (null))
			{
				pSublist = sqlite3ExprListAppend(pParse, null, sqlite3Expr(db, (int)(155), "0"));
			}

			pSub = sqlite3SelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, (uint)(0), null);
			p.pSrc = sqlite3SrcListAppend(pParse, null, null, null);
			if ((p.pSrc) != null)
			{
				Table pTab2;
				p.pSrc.a[0].pSelect = pSub;
				sqlite3SrcListAssignCursors(pParse, p.pSrc);
				pSub.selFlags |= (uint)(0x0000040 | 0x8000000);
				pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, (sbyte)(0x40));
				pSub.selFlags |= (uint)(selFlags & 0x0000008);
				if ((pTab2) == (null))
				{
					rc = (int)(7);
				}
				else
				{
					CRuntime.memcpy(pTab, pTab2, (ulong)(sizeof(Table)));
					pTab.tabFlags |= (uint)(0x00004000);
					p.pSrc.a[0].pTab = pTab;
					pTab = pTab2;
					CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
					w.xExprCallback = sqlite3WindowExtraAggFuncDepth;
					w.xSelectCallback = sqlite3WalkerDepthIncrease;
					w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
					sqlite3WalkSelect(w, pSub);
				}
			}
			else
			{
				sqlite3SelectDelete(db, pSub);
			}

			if ((db.mallocFailed) != 0)
				rc = (int)(7);
			sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pTab);
		}

		return (int)(rc);
	}
	public static void sqlite3WindowUpdate(Parse pParse, Window pList, Window pWin, FuncDef pFunc)
	{
		if (((pWin.zName) != null) && ((pWin.eFrmType) == (0)))
		{
			Window p = windowFind(pParse, pList, pWin.zName);
			if ((p) == (null))
				return;
			pWin.pPartition = sqlite3ExprListDup(pParse.db, p.pPartition, (int)(0));
			pWin.pOrderBy = sqlite3ExprListDup(pParse.db, p.pOrderBy, (int)(0));
			pWin.pStart = sqlite3ExprDup(pParse.db, p.pStart, (int)(0));
			pWin.pEnd = sqlite3ExprDup(pParse.db, p.pEnd, (int)(0));
			pWin.eStart = (byte)(p.eStart);
			pWin.eEnd = (byte)(p.eEnd);
			pWin.eFrmType = (byte)(p.eFrmType);
			pWin.eExclude = (byte)(p.eExclude);
		}
		else
		{
			sqlite3WindowChain(pParse, pWin, pList);
		}

		if ((((pWin.eFrmType) == (89)) && (((pWin.pStart) != null) || ((pWin.pEnd) != null))) && (((pWin.pOrderBy) == (null)) || (pWin.pOrderBy.nExpr != 1)))
		{
			sqlite3ErrorMsg(pParse, "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression");
		}
		else if ((pFunc.funcFlags & 0x00010000) != 0)
		{
			sqlite3 db = pParse.db;
			if ((pWin.pFilter) != null)
			{
				sqlite3ErrorMsg(pParse, "FILTER clause may only be used with aggregate window functions");
			}
			else
			{
				WindowUpdate* aUp = stackalloc WindowUpdate[] { { row_numberName, 76, 90, 85 }, { dense_rankName, 89, 90, 85 }, { rankName, 89, 90, 85 }, { percent_rankName, 92, 85, 90 }, { cume_distName, 92, 86, 90 }, { ntileName, 76, 85, 90 }, { leadName, 76, 90, 90 }, { lagName, 76, 90, 85 } };
				int i = 0;
				for (i = (int)(0); (i) < ((int)(8 * sizeof(WindowUpdate) / sizeof(WindowUpdate))); i++)
				{
					if ((pFunc.zName) == (aUp[i].zFunc))
					{
						sqlite3ExprDelete(db, pWin.pStart);
						sqlite3ExprDelete(db, pWin.pEnd);
						pWin.pEnd = pWin.pStart = null;
						pWin.eFrmType = (byte)(aUp[i].eFrmType);
						pWin.eStart = (byte)(aUp[i].eStart);
						pWin.eEnd = (byte)(aUp[i].eEnd);
						pWin.eExclude = (byte)(0);
						if ((pWin.eStart) == (86))
						{
							pWin.pStart = sqlite3Expr(db, (int)(155), "1");
						}

						break;
					}
				}
			}
		}

		pWin.pFunc = pFunc;
	}
	public static With sqlite3WithAdd(Parse pParse, With pWith, Cte pCte)
	{
		sqlite3 db = pParse.db;
		With pNew;
		sbyte* zName;
		if ((pCte) == (null))
		{
			return pWith;
		}

		zName = pCte.zName;
		if (((zName) != null) && ((pWith) != null))
		{
			int i = 0;
			for (i = (int)(0); (i) < (pWith.nCte); i++)
			{
				if ((sqlite3StrICmp(zName, pWith.a[i].zName)) == (0))
				{
					sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
				}
			}
		}

		if ((pWith) != null)
		{
			long nByte = (long)(sizeof(With) + (sizeof(Cte) * pWith.nCte));
			pNew = sqlite3DbRealloc(db, pWith, (ulong)(nByte));
		}
		else
		{
			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(With)));
		}

		if ((db.mallocFailed) != 0)
		{
			sqlite3CteDelete(db, pCte);
			pNew = pWith;
		}
		else
		{
			pNew.a[pNew.nCte++] = (Cte)(pCte);
			sqlite3DbFree(db, pCte);
		}

		return pNew;
	}
	public static With sqlite3WithPush(Parse pParse, With pWith, byte bFree)
	{
		if ((pWith) != null)
		{
			if ((bFree) != 0)
			{
				pWith = (With)(sqlite3ParserAddCleanup(pParse, sqlite3WithDelete, pWith));
				if ((pWith) == (null))
					return null;
			}

			if ((pParse.nErr) == (0))
			{
				pWith.pOuter = pParse.pWith;
				pParse.pWith = pWith;
			}
		}

		return pWith;
	}
	public static void sqliteAuthBadReturnCode(Parse pParse)
	{
		sqlite3ErrorMsg(pParse, "authorizer malfunction");
		pParse.rc = (int)(1);
	}
	public static int sqliteProcessJoin(Parse pParse, Select p)
	{
		SrcList pSrc;
		int i = 0; int j = 0;
		SrcItem pLeft;
		SrcItem pRight;
		pSrc = p.pSrc;
		pLeft = pSrc.a[0];
		pRight = pLeft[1];
		for (i = (int)(0); (i) < (pSrc.nSrc - 1); i++, pRight++, pLeft++)
		{
			Table pRightTab = pRight.pTab;
			int isOuter = 0;
			if ((((pLeft.pTab) == (null)) || ((pRightTab) == (null))))
				continue;
			isOuter = (int)((pRight.fg.jointype & 0x0020) != 0);
			if ((pRight.fg.jointype & 0x0004) != 0)
			{
				if (((pRight.pOn) != null) || ((pRight.pUsing) != null))
				{
					sqlite3ErrorMsg(pParse, "a NATURAL join may not have an ON or USING clause", (int)(0));
					return (int)(1);
				}

				for (j = (int)(0); (j) < (pRightTab.nCol); j++)
				{
					sbyte* zName;
					int iLeft = 0;
					int iLeftCol = 0;
					if ((((&pRightTab.aCol[j])->colFlags & 0x0002) != 0))
						continue;
					zName = pRightTab.aCol[j].zCnName;
					if ((tableAndColumnIndex(pSrc, (int)(i + 1), zName, &iLeft, &iLeftCol, (int)(1))) != 0)
					{
						addWhereTerm(pParse, pSrc, (int)(iLeft), (int)(iLeftCol), (int)(i + 1), (int)(j), (int)(isOuter), p.pWhere);
					}
				}
			}

			if (((pRight.pOn) != null) && ((pRight.pUsing) != null))
			{
				sqlite3ErrorMsg(pParse, "cannot have both ON and USING clauses in the same join");
				return (int)(1);
			}

			if ((pRight.pOn) != null)
			{
				if ((isOuter) != 0)
					sqlite3SetJoinExpr(pRight.pOn, (int)(pRight.iCursor));
				p.pWhere = sqlite3ExprAnd(pParse, p.pWhere, pRight.pOn);
				pRight.pOn = null;
			}

			if ((pRight.pUsing) != null)
			{
				IdList* pList = pRight.pUsing;
				for (j = (int)(0); (j) < (pList->nId); j++)
				{
					sbyte* zName;
					int iLeft = 0;
					int iLeftCol = 0;
					int iRightCol = 0;
					zName = pList->a[j].zName;
					iRightCol = (int)(sqlite3ColumnIndex(pRightTab, zName));
					if (((iRightCol) < (0)) || (tableAndColumnIndex(pSrc, (int)(i + 1), zName, &iLeft, &iLeftCol, (int)(0)) == 0))
					{
						sqlite3ErrorMsg(pParse, "cannot join using column %s - column not present in both tables", zName);
						return (int)(1);
					}

					addWhereTerm(pParse, pSrc, (int)(iLeft), (int)(iLeftCol), (int)(i + 1), (int)(iRightCol), (int)(isOuter), p.pWhere);
				}
			}
		}

		return (int)(0);
	}
	public static void srclistRenumberCursors(Parse pParse, int* aCsrMap, SrcList pSrc, int iExcept)
	{
		int i = 0;
		SrcItem pItem;
		for (i = (int)(0), pItem = pSrc.a; (i) < (pSrc.nSrc); i++, pItem++)
		{
			if (i != iExcept)
			{
				Select p;
				if ((pItem.fg.isRecursive == 0) || ((aCsrMap[pItem.iCursor + 1]) == (0)))
				{
					aCsrMap[pItem.iCursor + 1] = (int)(pParse.nTab++);
				}

				pItem.iCursor = (int)(aCsrMap[pItem.iCursor + 1]);
				for (p = pItem.pSelect; p; p = p.pPrior)
				{
					srclistRenumberCursors(pParse, aCsrMap, p.pSrc, (int)(-1));
				}
			}
		}
	}
	public static int tabIsReadOnly(Parse pParse, Table pTab)
	{
		sqlite3 db;
		if ((((pTab).eTabType) == (1)))
		{
			return ((sqlite3GetVTable(pParse.db, pTab).pMod.pModule.xUpdate) == (null) ? 1 : 0);
		}

		if ((pTab.tabFlags & (0x00000001 | 0x00001000)) == (0))
			return (int)(0);
		db = pParse.db;
		if ((pTab.tabFlags & 0x00000001) != 0)
		{
			return (((sqlite3WritableSchema(db)) == (0)) && ((pParse.nested) == (0)) ? 1 : 0);
		}

		return (int)(sqlite3ReadOnlyShadowTables(db));
	}
	public static int termIsEquivalence(Parse pParse, Expr pExpr)
	{
		sbyte aff1 = 0; sbyte aff2 = 0;
		CollSeq pColl;
		if (!(((pParse.db).dbOptFlags & (0x00000080)) == (0)))
			return (int)(0);
		if ((pExpr.op != 53) && (pExpr.op != 45))
			return (int)(0);
		if ((((pExpr).flags & (0x000001)) != 0))
			return (int)(0);
		aff1 = (sbyte)(sqlite3ExprAffinity(pExpr.pLeft));
		aff2 = (sbyte)(sqlite3ExprAffinity(pExpr.pRight));
		if ((aff1 != aff2) && ((!((aff1) >= (0x43))) || (!((aff2) >= (0x43)))))
		{
			return (int)(0);
		}

		pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);
		if ((sqlite3IsBinary(pColl)) != 0)
			return (int)(1);
		return (int)(sqlite3ExprCollSeqMatch(pParse, pExpr.pLeft, pExpr.pRight));
	}
	public static Expr tokenExpr(Parse pParse, int op, Token t)
	{
		Expr p = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Expr) + t.n + 1));
		if ((p) != null)
		{
			p.op = ((byte)(op));
			p.affExpr = (sbyte)(0);
			p.flags = (uint)(0x800000);
			p.iAgg = (short)(-1);
			p.pLeft = p.pRight = null;
			p.pAggInfo = null;
			CRuntime.memset(&p.x, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18074 : 3)) ) )
        ;
			CRuntime.memset(&p.y, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18103 : 3)) ) )
        ;
			p.op2 = (byte)(0);
			p.iTable = (int)(0);
			p.iColumn = (short)(0);
			p.u.zToken = (sbyte*)(p[1]);
			CRuntime.memcpy(p.u.zToken, t.z, (ulong)(t.n));
			p.u.zToken[t.n] = (sbyte)(0);
			p.w.iOfst = ((int)(t.z - pParse.zTail));
			if ((sqlite3CtypeMap[(byte)(p.u.zToken[0])] & 0x80) != 0)
			{
				sqlite3DequoteExpr(p);
			}

			p.nHeight = (int)(1);
			if (((pParse.eParseMode) >= (2)))
			{
				return (Expr)(sqlite3RenameTokenMap(pParse, (void*)(p), &t));
			}
		}

		return p;
	}
	public static void transferParseError(Parse pTo, Parse pFrom)
	{
		if ((pTo.nErr) == (0))
		{
			pTo.zErrMsg = pFrom.zErrMsg;
			pTo.nErr = (int)(pFrom.nErr);
			pTo.rc = (int)(pFrom.rc);
		}
		else
		{
			sqlite3DbFree(pFrom.db, pFrom.zErrMsg);
		}
	}
	public static void translateColumnToCopy(Parse pParse, int iStart, int iTabCur, int iRegister, int iAutoidxCur)
	{
		Vdbe v = pParse.pVdbe;
		VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iStart));
		int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
		if ((pParse.db.mallocFailed) != 0)
			return;
		for (; (iStart) < (iEnd); iStart++, pOp++)
		{
			if (pOp->p1 != iTabCur)
				continue;
			if ((pOp->opcode) == (93))
			{
				pOp->opcode = (byte)(79);
				pOp->p1 = (int)(pOp->p2 + iRegister);
				pOp->p2 = (int)(pOp->p3);
				pOp->p3 = (int)(0);
			}
			else if ((pOp->opcode) == (134))
			{
				pOp->opcode = (byte)(125);
				pOp->p1 = (int)(iAutoidxCur);
			}
		}
	}
	public static TriggerStep triggerStepAllocate(Parse pParse, byte op, Token* pName, sbyte* zStart, sbyte* zEnd)
	{
		sqlite3 db = pParse.db;
		TriggerStep pTriggerStep;
		if ((pParse.nErr) != 0)
			return null;
		pTriggerStep = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerStep) + pName->n + 1));
		if ((pTriggerStep) != null)
		{
			sbyte* z = (sbyte*)(pTriggerStep[1]);
			CRuntime.memcpy(z, pName->z, (ulong)(pName->n));
			sqlite3Dequote(z);
			pTriggerStep.zTarget = z;
			pTriggerStep.op = (byte)(op);
			pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd);
			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameTokenMap(pParse, pTriggerStep.zTarget, pName);
			}
		}

		return pTriggerStep;
	}
	public static void unmapColumnIdlistNames(Parse pParse, IdList* pIdList)
	{
		if ((pIdList) != null)
		{
			int ii = 0;
			for (ii = (int)(0); (ii) < (pIdList->nId); ii++)
			{
				sqlite3RenameTokenRemap(pParse, null, (void*)(pIdList->a[ii].zName));
			}
		}
	}
	public static void updateAccumulator(Parse pParse, int regAcc, AggInfo pAggInfo, int eDistinctType)
	{
		Vdbe v = pParse.pVdbe;
		int i = 0;
		int regHit = (int)(0);
		int addrHitTest = (int)(0);
		AggInfo_func pF;
		AggInfo_col pC;
		pAggInfo.directMode = (byte)(1);
		for (i = (int)(0), pF = pAggInfo.aFunc; (i) < (pAggInfo.nFunc); i++, pF++)
		{
			int nArg = 0;
			int addrNext = (int)(0);
			int regAgg = 0;
			ExprList pList;
			pList = pF.pFExpr.x.pList;
			if ((((pF.pFExpr).flags & (0x1000000)) != 0))
			{
				Expr pFilter = pF.pFExpr.y.pWin.pFilter;
				if ((((pAggInfo.nAccumulator) != 0) && ((pF.pFunc.funcFlags & 0x0020) != 0)) && ((regAcc) != 0))
				{
					if ((regHit) == (0))
						regHit = (int)(++pParse.nMem);
					sqlite3VdbeAddOp2(v, (int)(79), (int)(regAcc), (int)(regHit));
				}

				addrNext = (int)(sqlite3VdbeMakeLabel(pParse));
				sqlite3ExprIfFalse(pParse, pFilter, (int)(addrNext), (int)(0x10));
			}

			if ((pList) != null)
			{
				nArg = (int)(pList.nExpr);
				regAgg = (int)(sqlite3GetTempRange(pParse, (int)(nArg)));
				sqlite3ExprCodeExprList(pParse, pList, (int)(regAgg), (int)(0), (byte)(0x01));
			}
			else
			{
				nArg = (int)(0);
				regAgg = (int)(0);
			}

			if (((pF.iDistinct) >= (0)) && ((pList) != null))
			{
				if ((addrNext) == (0))
				{
					addrNext = (int)(sqlite3VdbeMakeLabel(pParse));
				}

				pF.iDistinct = (int)(codeDistinct(pParse, (int)(eDistinctType), (int)(pF.iDistinct), (int)(addrNext), pList, (int)(regAgg)));
			}

			if ((pF.pFunc.funcFlags & 0x0020) != 0)
			{
				CollSeq pColl = null;
				ExprList_item* pItem;
				int j = 0;
				for (j = (int)(0), pItem = pList.a; (pColl == null) && ((j) < (nArg)); j++, pItem++)
				{
					pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
				}

				if (pColl == null)
				{
					pColl = pParse.db.pDfltColl;
				}

				if (((regHit) == (0)) && ((pAggInfo.nAccumulator) != 0))
					regHit = (int)(++pParse.nMem);
				sqlite3VdbeAddOp4(v, (int)(84), (int)(regHit), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
			}

			sqlite3VdbeAddOp3(v, (int)(161), (int)(0), (int)(regAgg), (int)(pF.iMem));
			sqlite3VdbeAppendP4(v, pF.pFunc, (int)(-8));
			sqlite3VdbeChangeP5(v, (ushort)((byte)(nArg)));
			sqlite3ReleaseTempRange(pParse, (int)(regAgg), (int)(nArg));
			if ((addrNext) != 0)
			{
				sqlite3VdbeResolveLabel(v, (int)(addrNext));
			}
		}

		if (((regHit) == (0)) && ((pAggInfo.nAccumulator) != 0))
		{
			regHit = (int)(regAcc);
		}

		if ((regHit) != 0)
		{
			addrHitTest = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(regHit)));
		}

		for (i = (int)(0), pC = pAggInfo.aCol; (i) < (pAggInfo.nAccumulator); i++, pC++)
		{
			sqlite3ExprCode(pParse, pC.pCExpr, (int)(pC.iMem));
		}

		pAggInfo.directMode = (byte)(0);
		if ((addrHitTest) != 0)
		{
			sqlite3VdbeJumpHereOrPopInst(v, (int)(addrHitTest));
		}
	}
	public static void updateFromSelect(Parse pParse, int iEph, Index pPk, ExprList pChanges, SrcList pTabList, Expr pWhere, ExprList pOrderBy, Expr pLimit)
	{
		int i = 0;
		SelectDest dest = new SelectDest();
		Select pSelect = null;
		ExprList pList = null;
		ExprList pGrp = null;
		Expr pLimit2 = null;
		ExprList pOrderBy2 = null;
		sqlite3 db = pParse.db;
		Table pTab = pTabList.a[0].pTab;
		SrcList pSrc;
		Expr pWhere2;
		int eDest = 0;
		pSrc = sqlite3SrcListDup(db, pTabList, (int)(0));
		pWhere2 = sqlite3ExprDup(db, pWhere, (int)(0));
		if ((pSrc) != null)
		{
			pSrc.a[0].fg.notCte = (uint)(1);
			pSrc.a[0].iCursor = (int)(-1);
			pSrc.a[0].pTab.nTabRef--;
			pSrc.a[0].pTab = null;
		}

		if ((pPk) != null)
		{
			for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
			{
				Expr pNew = exprRowColumn(pParse, (int)(pPk.aiColumn[i]));
				pList = sqlite3ExprListAppend(pParse, pList, pNew);
			}

			eDest = (int)((((pTab).eTabType) == (1)) ? 14 : 15);
		}
		else if ((((pTab).eTabType) == (2)))
		{
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, (int)(i)));
			}

			eDest = (int)(14);
		}
		else
		{
			eDest = (int)((((pTab).eTabType) == (1)) ? 14 : 15);
			pList = sqlite3ExprListAppend(pParse, null, sqlite3PExpr(pParse, (int)(75), null, null));
		}

		if ((pChanges) != null)
		{
			for (i = (int)(0); (i) < (pChanges.nExpr); i++)
			{
				pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, pChanges.a[i].pExpr, (int)(0)));
			}
		}

		pSelect = sqlite3SelectNew(pParse, pList, pSrc, pWhere2, pGrp, null, pOrderBy2, (uint)(0x0800000 | 0x0020000), pLimit2);
		if ((pSelect) != null)
			pSelect.selFlags |= (uint)(0x8000000);
		sqlite3SelectDestInit(dest, (int)(eDest), (int)(iEph));
		dest.iSDParm2 = (int)(pPk ? pPk.nKeyCol : -1);
		sqlite3Select(pParse, pSelect, dest);
		sqlite3SelectDelete(db, pSelect);
	}
	public static void updateVirtualTable(Parse pParse, SrcList pSrc, Table pTab, ExprList pChanges, Expr pRowid, int* aXRef, Expr pWhere, int onError)
	{
		Vdbe v = pParse.pVdbe;
		int ephemTab = 0;
		int i = 0;
		sqlite3 db = pParse.db;
		sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
		WhereInfo pWInfo = null;
		int nArg = (int)(2 + pTab.nCol);
		int regArg = 0;
		int regRec = 0;
		int regRowid = 0;
		int iCsr = (int)(pSrc.a[0].iCursor);
		int* aDummy = stackalloc int[2];
		int eOnePass = 0;
		int addr = 0;
		ephemTab = (int)(pParse.nTab++);
		addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(ephemTab), (int)(nArg)));
		regArg = (int)(pParse.nMem + 1);
		pParse.nMem += (int)(nArg);
		if ((pSrc.nSrc) > (1))
		{
			Index pPk = null;
			Expr pRow;
			ExprList pList;
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				if ((pRowid) != null)
				{
					pRow = sqlite3ExprDup(db, pRowid, (int)(0));
				}
				else
				{
					pRow = sqlite3PExpr(pParse, (int)(75), null, null);
				}
			}
			else
			{
				short iPk = 0;
				pPk = sqlite3PrimaryKeyIndex(pTab);
				iPk = (short)(pPk.aiColumn[0]);
				if ((aXRef[iPk]) >= (0))
				{
					pRow = sqlite3ExprDup(db, pChanges.a[aXRef[iPk]].pExpr, (int)(0));
				}
				else
				{
					pRow = exprRowColumn(pParse, (int)(iPk));
				}
			}

			pList = sqlite3ExprListAppend(pParse, null, pRow);
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((aXRef[i]) >= (0))
				{
					pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, pChanges.a[aXRef[i]].pExpr, (int)(0)));
				}
				else
				{
					pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, (int)(i)));
				}
			}

			updateFromSelect(pParse, (int)(ephemTab), pPk, pList, pSrc, pWhere, null, null);
			sqlite3ExprListDelete(db, pList);
			eOnePass = (int)(0);
		}
		else
		{
			regRec = (int)(++pParse.nMem);
			regRowid = (int)(++pParse.nMem);
			pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, null, null, null, (ushort)(0x0004), (int)(0));
			if ((pWInfo) == (null))
				return;
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((aXRef[i]) >= (0))
				{
					sqlite3ExprCode(pParse, pChanges.a[aXRef[i]].pExpr, (int)(regArg + 2 + i));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(174), (int)(iCsr), (int)(i), (int)(regArg + 2 + i));
					sqlite3VdbeChangeP5(v, (ushort)(0x01));
				}
			}

			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				sqlite3VdbeAddOp2(v, (int)(134), (int)(iCsr), (int)(regArg));
				if ((pRowid) != null)
				{
					sqlite3ExprCode(pParse, pRowid, (int)(regArg + 1));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(134), (int)(iCsr), (int)(regArg + 1));
				}
			}
			else
			{
				Index pPk;
				short iPk = 0;
				pPk = sqlite3PrimaryKeyIndex(pTab);
				iPk = (short)(pPk.aiColumn[0]);
				sqlite3VdbeAddOp3(v, (int)(174), (int)(iCsr), (int)(iPk), (int)(regArg));
				sqlite3VdbeAddOp2(v, (int)(80), (int)(regArg + 2 + iPk), (int)(regArg + 1));
			}

			eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aDummy));
			if ((eOnePass) != 0)
			{
				sqlite3VdbeChangeToNoop(v, (int)(addr));
				sqlite3VdbeAddOp1(v, (int)(121), (int)(iCsr));
			}
			else
			{
				sqlite3MultiWrite(pParse);
				sqlite3VdbeAddOp3(v, (int)(96), (int)(regArg), (int)(nArg), (int)(regRec));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(ephemTab), (int)(regRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(ephemTab), (int)(regRec), (int)(regRowid));
			}
		}

		if ((eOnePass) == (0))
		{
			if ((pSrc.nSrc) == (1))
			{
				sqlite3WhereEnd(pWInfo);
			}

			addr = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(ephemTab)));
			for (i = (int)(0); (i) < (nArg); i++)
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(ephemTab), (int)(i), (int)(regArg + i));
			}
		}

		sqlite3VtabMakeWritable(pParse, pTab);
		sqlite3VdbeAddOp4(v, (int)(10), (int)(0), (int)(nArg), (int)(regArg), pVTab, (int)(-12));
		sqlite3VdbeChangeP5(v, (ushort)((onError) == (11) ? 2 : onError));
		sqlite3MayAbort(pParse);
		if ((eOnePass) == (0))
		{
			sqlite3VdbeAddOp2(v, (int)(5), (int)(ephemTab), (int)(addr + 1));
			sqlite3VdbeJumpHere(v, (int)(addr));
			sqlite3VdbeAddOp2(v, (int)(121), (int)(ephemTab), (int)(0));
		}
		else
		{
			sqlite3WhereEnd(pWInfo);
		}
	}
	public static int vtabBestIndex(Parse pParse, Table pTab, sqlite3_index_info* p)
	{
		sqlite3_vtab pVtab = sqlite3GetVTable(pParse.db, pTab).pVtab;
		int rc = 0;
		pParse.db.nSchemaLock++;
		rc = (int)(pVtab.pModule.xBestIndex(pVtab, p));
		pParse.db.nSchemaLock--;
		if ((rc != 0) && (rc != 19))
		{
			if ((rc) == (7))
			{
				sqlite3OomFault(pParse.db);
			}
			else if (pVtab.zErrMsg == null)
			{
				sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr((int)(rc)));
			}
			else
			{
				sqlite3ErrorMsg(pParse, "%s", pVtab.zErrMsg);
			}
		}

		sqlite3_free(pVtab.zErrMsg);
		pVtab.zErrMsg = null;
		return (int)(rc);
	}
	public static int whereRangeScanEst(Parse pParse, WhereLoopBuilder pBuilder, WhereTerm pLower, WhereTerm pUpper, WhereLoop pLoop)
	{
		int rc = (int)(0);
		int nOut = (int)(pLoop.nOut);
		short nNew = 0;
		nNew = (short)(whereRangeAdjust(pLower, (short)(nOut)));
		nNew = (short)(whereRangeAdjust(pUpper, (short)(nNew)));
		if (((((pLower) != null) && ((pLower.truthProb) > (0))) && ((pUpper) != null)) && ((pUpper.truthProb) > (0)))
		{
			nNew -= (short)(20);
		}

		nOut -= (int)((pLower != null) + (pUpper != null));
		if ((nNew) < (10))
			nNew = (short)(10);
		if ((nNew) < (nOut))
			nOut = (int)(nNew);
		pLoop.nOut = ((short)(nOut));
		return (int)(rc);
	}
	public static int whereRangeVectorLen(Parse pParse, int iCur, Index pIdx, int nEq, WhereTerm pTerm)
	{
		int nCmp = (int)(sqlite3ExprVectorSize(pTerm.pExpr.pLeft));
		int i = 0;
		nCmp = (int)((nCmp) < (pIdx.nColumn - nEq) ? (nCmp) : (pIdx.nColumn - nEq));
		for (i = (int)(1); (i) < (nCmp); i++)
		{
			sbyte aff = 0;
			sbyte idxaff = (sbyte)(0);
			CollSeq pColl;
			Expr pLhs;
			Expr pRhs;
			pLhs = pTerm.pExpr.pLeft.x.pList.a[i].pExpr;
			pRhs = pTerm.pExpr.pRight;
			if ((((pRhs).flags & 0x000800) != 0))
			{
				pRhs = pRhs.x.pSelect.pEList.a[i].pExpr;
			}
			else
			{
				pRhs = pRhs.x.pList.a[i].pExpr;
			}

			if ((((pLhs.op != 167) || (pLhs.iTable != iCur)) || (pLhs.iColumn != pIdx.aiColumn[i + nEq])) || (pIdx.aSortOrder[i + nEq] != pIdx.aSortOrder[nEq]))
			{
				break;
			}

			aff = (sbyte)(sqlite3CompareAffinity(pRhs, (sbyte)(sqlite3ExprAffinity(pLhs))));
			idxaff = (sbyte)(sqlite3TableColumnAffinity(pIdx.pTable, (int)(pLhs.iColumn)));
			if (aff != idxaff)
				break;
			pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
			if ((pColl) == (null))
				break;
			if ((sqlite3StrICmp(pColl.zName, pIdx.azColl[i + nEq])) != 0)
				break;
		}

		return (int)(i);
	}
	public static void windowCheckValue(Parse pParse, int reg, int eCond)
	{
		Vdbe v = sqlite3GetVdbe(pParse);
		int regZero = (int)(sqlite3GetTempReg(pParse));
		sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regZero));
		if ((eCond) >= (3))
		{
			int regString = (int)(sqlite3GetTempReg(pParse));
			sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(regString), (int)(0), "", (int)(-1));
			sqlite3VdbeAddOp3(v, (int)(57), (int)(regString), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(reg));
			sqlite3VdbeChangeP5(v, (ushort)(0x43 | 0x10));
		}
		else
		{
			sqlite3VdbeAddOp2(v, (int)(15), (int)(reg), (int)(sqlite3VdbeCurrentAddr(v) + 2));
		}

		sqlite3VdbeAddOp3(v, (int)(windowCheckValue_aOp[eCond]), (int)(regZero), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(reg));
		sqlite3VdbeChangeP5(v, (ushort)(0x43));
		sqlite3MayAbort(pParse);
		sqlite3VdbeAddOp2(v, (int)(70), (int)(1), (int)(2));
		sqlite3VdbeAppendP4(v, (void*)(windowCheckValue_azErr[eCond]), (int)(-1));
		sqlite3ReleaseTempReg(pParse, (int)(regZero));
	}
	public static int windowExprGtZero(Parse pParse, Expr pExpr)
	{
		int ret = (int)(0);
		sqlite3 db = pParse.db;
		sqlite3_value pVal = null;
		sqlite3ValueFromExpr(db, pExpr, (byte)(db.enc), (byte)(0x43), pVal);
		if (((pVal) != null) && ((sqlite3_value_int(pVal)) > (0)))
		{
			ret = (int)(1);
		}

		sqlite3ValueFree(pVal);
		return (int)(ret);
	}
	public static Window windowFind(Parse pParse, Window pList, sbyte* zName)
	{
		Window p;
		for (p = pList; p; p = p.pNextWin)
		{
			if ((sqlite3StrICmp(p.zName, zName)) == (0))
				break;
		}

		if ((p) == (null))
		{
			sqlite3ErrorMsg(pParse, "no such window: %s", zName);
		}

		return p;
	}
	public static void windowIfNewPeer(Parse pParse, ExprList pOrderBy, int regNew, int regOld, int addr)
	{
		Vdbe v = sqlite3GetVdbe(pParse);
		if ((pOrderBy) != null)
		{
			int nVal = (int)(pOrderBy.nExpr);
			KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, (int)(0), (int)(0));
			sqlite3VdbeAddOp3(v, (int)(89), (int)(regOld), (int)(regNew), (int)(nVal));
			sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
			sqlite3VdbeAddOp3(v, (int)(16), (int)(sqlite3VdbeCurrentAddr(v) + 1), (int)(addr), (int)(sqlite3VdbeCurrentAddr(v) + 1));
			sqlite3VdbeAddOp3(v, (int)(79), (int)(regNew), (int)(regOld), (int)(nVal - 1));
		}
		else
		{
			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addr));
		}
	}
	public static int windowInitAccum(Parse pParse, Window pMWin)
	{
		Vdbe v = sqlite3GetVdbe(pParse);
		int regArg = 0;
		int nArg = (int)(0);
		Window pWin;
		for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
		{
			FuncDef pFunc = pWin.pFunc;
			sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
			nArg = (int)((nArg) > (windowArgCount(pWin)) ? (nArg) : (windowArgCount(pWin)));
			if ((pMWin.regStartRowid) == (0))
			{
				if (((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName)))
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
				}

				if (((pFunc.funcFlags & 0x1000) != 0) && ((pWin.csrApp) != 0))
				{
					sqlite3VdbeAddOp1(v, (int)(145), (int)(pWin.csrApp));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
				}
			}
		}

		regArg = (int)(pParse.nMem + 1);
		pParse.nMem += (int)(nArg);
		return (int)(regArg);
	}
	public static int xferOptimization(Parse pParse, Table pDest, Select pSelect, int onError, int iDbDest)
	{
		sqlite3 db = pParse.db;
		ExprList pEList;
		Table pSrc;
		Index pSrcIdx; Index pDestIdx;
		SrcItem pItem;
		int i = 0;
		int iDbSrc = 0;
		int iSrc = 0; int iDest = 0;
		int addr1 = 0; int addr2 = 0;
		int emptyDestTest = (int)(0);
		int emptySrcTest = (int)(0);
		Vdbe v;
		int regAutoinc = 0;
		int destHasUniqueIdx = (int)(0);
		int regData = 0; int regRowid = 0;
		if (((pParse.pWith) != null) || ((pSelect.pWith) != null))
		{
			return (int)(0);
		}

		if ((((pDest).eTabType) == (1)))
		{
			return (int)(0);
		}

		if ((onError) == (11))
		{
			if ((pDest.iPKey) >= (0))
				onError = (int)(pDest.keyConf);
			if ((onError) == (11))
				onError = (int)(2);
		}

		if (pSelect.pSrc.nSrc != 1)
		{
			return (int)(0);
		}

		if ((pSelect.pSrc.a[0].pSelect) != null)
		{
			return (int)(0);
		}

		if ((pSelect.pWhere) != null)
		{
			return (int)(0);
		}

		if ((pSelect.pOrderBy) != null)
		{
			return (int)(0);
		}

		if ((pSelect.pGroupBy) != null)
		{
			return (int)(0);
		}

		if ((pSelect.pLimit) != null)
		{
			return (int)(0);
		}

		if ((pSelect.pPrior) != null)
		{
			return (int)(0);
		}

		if ((pSelect.selFlags & 0x0000001) != 0)
		{
			return (int)(0);
		}

		pEList = pSelect.pEList;
		if (pEList.nExpr != 1)
		{
			return (int)(0);
		}

		if (pEList.a[0].pExpr.op != 180)
		{
			return (int)(0);
		}

		pItem = pSelect.pSrc.a;
		pSrc = sqlite3LocateTableItem(pParse, (uint)(0), pItem);
		if ((pSrc) == (null))
		{
			return (int)(0);
		}

		if (((pSrc.tnum) == (pDest.tnum)) && ((pSrc.pSchema) == (pDest.pSchema)))
		{
			return (int)(0);
		}

		if ((((pDest).tabFlags & 0x00000080) == (0)) != (((pSrc).tabFlags & 0x00000080) == (0)))
		{
			return (int)(0);
		}

		if (!(((pSrc).eTabType) == (0)))
		{
			return (int)(0);
		}

		if (pDest.nCol != pSrc.nCol)
		{
			return (int)(0);
		}

		if (pDest.iPKey != pSrc.iPKey)
		{
			return (int)(0);
		}

		if (((pDest.tabFlags & 0x00010000) != 0) && ((pSrc.tabFlags & 0x00010000) == (0)))
		{
			return (int)(0);
		}

		for (i = (int)(0); (i) < (pDest.nCol); i++)
		{
			Column* pDestCol = &pDest.aCol[i];
			Column* pSrcCol = &pSrc.aCol[i];
			if ((pDestCol->colFlags & 0x0060) != (pSrcCol->colFlags & 0x0060))
			{
				return (int)(0);
			}

			if ((pDestCol->colFlags & 0x0060) != 0)
			{
				if (sqlite3ExprCompare(null, sqlite3ColumnExpr(pSrc, pSrcCol), sqlite3ColumnExpr(pDest, pDestCol), (int)(-1)) != 0)
				{
					return (int)(0);
				}
			}

			if (pDestCol->affinity != pSrcCol->affinity)
			{
				return (int)(0);
			}

			if (sqlite3_stricmp(sqlite3ColumnColl(pDestCol), sqlite3ColumnColl(pSrcCol)) != 0)
			{
				return (int)(0);
			}

			if (((pDestCol->notNull) != 0) && (pSrcCol->notNull == 0))
			{
				return (int)(0);
			}

			if (((pDestCol->colFlags & 0x0060) == (0)) && ((i) > (0)))
			{
				Expr pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);
				Expr pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);
				if ((((pDestExpr) == (null)) != ((pSrcExpr) == (null))) || ((pDestExpr != null) && (CRuntime.strcmp(pDestExpr.u.zToken, pSrcExpr.u.zToken) != 0)))
				{
					return (int)(0);
				}
			}
		}

		for (pDestIdx = pDest.pIndex; pDestIdx; pDestIdx = pDestIdx.pNext)
		{
			if (((pDestIdx).onError != 0))
			{
				destHasUniqueIdx = (int)(1);
			}

			for (pSrcIdx = pSrc.pIndex; pSrcIdx; pSrcIdx = pSrcIdx.pNext)
			{
				if ((xferCompatibleIndex(pDestIdx, pSrcIdx)) != 0)
					break;
			}

			if ((pSrcIdx) == (null))
			{
				return (int)(0);
			}

			if ((((pSrcIdx.tnum) == (pDestIdx.tnum)) && ((pSrc.pSchema) == (pDest.pSchema))) && ((sqlite3FaultSim((int)(411))) == (0)))
			{
				return (int)(0);
			}
		}

		if (((pDest.pCheck) != null) && ((sqlite3ExprListCompare(pSrc.pCheck, pDest.pCheck, (int)(-1))) != 0))
		{
			return (int)(0);
		}

		if (((db.flags & 0x00004000) != 0) && (pDest.u.tab.pFKey != null))
		{
			return (int)(0);
		}

		if ((db.flags & ((ulong)(0x00001) << 32)) != 0)
		{
			return (int)(0);
		}

		iDbSrc = (int)(sqlite3SchemaToIndex(db, pSrc.pSchema));
		v = sqlite3GetVdbe(pParse);
		sqlite3CodeVerifySchema(pParse, (int)(iDbSrc));
		iSrc = (int)(pParse.nTab++);
		iDest = (int)(pParse.nTab++);
		regAutoinc = (int)(autoIncBegin(pParse, (int)(iDbDest), pDest));
		regData = (int)(sqlite3GetTempReg(pParse));
		sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regData));
		regRowid = (int)(sqlite3GetTempReg(pParse));
		sqlite3OpenTable(pParse, (int)(iDest), (int)(iDbDest), pDest, (int)(112));
		if (((db.mDbFlags & 0x0004) == (0)) && (((((pDest.iPKey) < (0)) && (pDest.pIndex != null)) || ((destHasUniqueIdx) != 0)) || ((onError != 2) && (onError != 1))))
		{
			addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iDest), (int)(0)));
			emptyDestTest = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
			sqlite3VdbeJumpHere(v, (int)(addr1));
		}

		if ((((pSrc).tabFlags & 0x00000080) == (0)))
		{
			byte insFlags = 0;
			sqlite3OpenTable(pParse, (int)(iSrc), (int)(iDbSrc), pSrc, (int)(101));
			emptySrcTest = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iSrc), (int)(0)));
			if ((pDest.iPKey) >= (0))
			{
				addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iSrc), (int)(regRowid)));
				if ((db.mDbFlags & 0x0004) == (0))
				{
					addr2 = (int)(sqlite3VdbeAddOp3(v, (int)(33), (int)(iDest), (int)(0), (int)(regRowid)));
					sqlite3RowidConstraint(pParse, (int)(onError), pDest);
					sqlite3VdbeJumpHere(v, (int)(addr2));
				}

				autoIncStep(pParse, (int)(regAutoinc), (int)(regRowid));
			}
			else if (((pDest.pIndex) == (null)) && ((db.mDbFlags & 0x0008) == 0))
			{
				addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(126), (int)(iDest), (int)(regRowid)));
			}
			else
			{
				addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iSrc), (int)(regRowid)));
			}

			if ((db.mDbFlags & 0x0004) != 0)
			{
				sqlite3VdbeAddOp1(v, (int)(136), (int)(iDest));
				insFlags = (byte)(0x08 | 0x10 | 0x80);
			}
			else
			{
				insFlags = (byte)(0x01 | 0x20 | 0x08 | 0x80);
			}

			{
				sqlite3VdbeAddOp3(v, (int)(128), (int)(iDest), (int)(iSrc), (int)(regRowid));
			}

			sqlite3VdbeAddOp3(v, (int)(127), (int)(iDest), (int)(regData), (int)(regRowid));
			if ((db.mDbFlags & 0x0004) == (0))
			{
				sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pDest), (int)(-6));
			}

			sqlite3VdbeChangeP5(v, (ushort)(insFlags));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iSrc), (int)(addr1));
			sqlite3VdbeAddOp2(v, (int)(121), (int)(iSrc), (int)(0));
			sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
		}
		else
		{
			sqlite3TableLock(pParse, (int)(iDbDest), (uint)(pDest.tnum), (byte)(1), pDest.zName);
			sqlite3TableLock(pParse, (int)(iDbSrc), (uint)(pSrc.tnum), (byte)(0), pSrc.zName);
		}

		for (pDestIdx = pDest.pIndex; pDestIdx; pDestIdx = pDestIdx.pNext)
		{
			byte idxInsFlags = (byte)(0);
			for (pSrcIdx = pSrc.pIndex; (pSrcIdx); pSrcIdx = pSrcIdx.pNext)
			{
				if ((xferCompatibleIndex(pDestIdx, pSrcIdx)) != 0)
					break;
			}

			sqlite3VdbeAddOp3(v, (int)(101), (int)(iSrc), (int)(pSrcIdx.tnum), (int)(iDbSrc));
			sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
			sqlite3VdbeAddOp3(v, (int)(112), (int)(iDest), (int)(pDestIdx.tnum), (int)(iDbDest));
			sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
			sqlite3VdbeChangeP5(v, (ushort)(0x01));
			addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iSrc), (int)(0)));
			if ((db.mDbFlags & 0x0004) != 0)
			{
				for (i = (int)(0); (i) < (pSrcIdx.nColumn); i++)
				{
					sbyte* zColl = pSrcIdx.azColl[i];
					if ((sqlite3_stricmp(sqlite3StrBINARY, zColl)) != 0)
						break;
				}

				if ((i) == (pSrcIdx.nColumn))
				{
					idxInsFlags = (byte)(0x10 | 0x80);
					sqlite3VdbeAddOp1(v, (int)(136), (int)(iDest));
					sqlite3VdbeAddOp2(v, (int)(128), (int)(iDest), (int)(iSrc));
				}
			}
			else if ((!(((pSrc).tabFlags & 0x00000080) == (0))) && ((pDestIdx.idxType) == (2)))
			{
				idxInsFlags |= (byte)(0x01);
			}

			if (idxInsFlags != (0x10 | 0x80))
			{
				sqlite3VdbeAddOp3(v, (int)(133), (int)(iSrc), (int)(regData), (int)(1));
				if ((((db.mDbFlags & 0x0004) == (0)) && (!(((pDest).tabFlags & 0x00000080) == (0)))) && (((pDestIdx).idxType) == (2)))
				{
				}
			}

			sqlite3VdbeAddOp2(v, (int)(137), (int)(iDest), (int)(regData));
			sqlite3VdbeChangeP5(v, (ushort)(idxInsFlags | 0x08));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iSrc), (int)(addr1 + 1));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			sqlite3VdbeAddOp2(v, (int)(121), (int)(iSrc), (int)(0));
			sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
		}

		if ((emptySrcTest) != 0)
			sqlite3VdbeJumpHere(v, (int)(emptySrcTest));
		sqlite3ReleaseTempReg(pParse, (int)(regRowid));
		sqlite3ReleaseTempReg(pParse, (int)(regData));
		if ((emptyDestTest) != 0)
		{
			sqlite3AutoincrementEnd(pParse);
			sqlite3VdbeAddOp2(v, (int)(70), (int)(0), (int)(0));
			sqlite3VdbeJumpHere(v, (int)(emptyDestTest));
			sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
			return (int)(0);
		}
		else
		{
			return (int)(1);
		}
	}
}
}