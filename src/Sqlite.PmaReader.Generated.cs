// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int vdbePmaReadBlob(PmaReader p, int nByte, byte** ppOut)
		{
			int iBuf = 0;
			int nAvail = 0;
			if ((p.aMap) != null)
			{
				*ppOut = &p.aMap[p.iReadOff];
				p.iReadOff += (long)(nByte);
				return (int)(0);
			}

			iBuf = (int)(p.iReadOff % p.nBuffer);
			if ((iBuf) == (0))
			{
				int nRead = 0;
				int rc = 0;
				if ((p.iEof - p.iReadOff) > ((long)(p.nBuffer)))
				{
					nRead = (int)(p.nBuffer);
				}
				else
				{
					nRead = ((int)(p.iEof - p.iReadOff));
				}

				rc = (int)(sqlite3OsRead(p.pFd, p.aBuffer, (int)(nRead), (long)(p.iReadOff)));
				if (rc != 0)
					return (int)(rc);
			}

			nAvail = (int)(p.nBuffer - iBuf);
			if ((nByte) <= (nAvail))
			{
				*ppOut = &p.aBuffer[iBuf];
				p.iReadOff += (long)(nByte);
			}
			else
			{
				int nRem = 0;
				if ((p.nAlloc) < (nByte))
				{
					byte* aNew;
					long nNew = (long)((128) > (2 * (long)(p.nAlloc)) ? (128) : (2 * (long)(p.nAlloc)));
					while ((nByte) > (nNew))
					{
						nNew = (long)(nNew * 2);
					}

					aNew = sqlite3Realloc(p.aAlloc, (ulong)(nNew));
					if (aNew == null)
						return (int)(7);
					p.nAlloc = (int)(nNew);
					p.aAlloc = aNew;
				}

				CRuntime.memcpy(p.aAlloc, &p.aBuffer[iBuf], (ulong)(nAvail));
				p.iReadOff += (long)(nAvail);
				nRem = (int)(nByte - nAvail);
				while ((nRem) > (0))
				{
					int rc = 0;
					int nCopy = 0;
					byte* aNext;
					nCopy = (int)(nRem);
					if ((nRem) > (p.nBuffer))
						nCopy = (int)(p.nBuffer);
					rc = (int)(vdbePmaReadBlob(p, (int)(nCopy), &aNext));
					if (rc != 0)
						return (int)(rc);
					CRuntime.memcpy(&p.aAlloc[nByte - nRem], aNext, (ulong)(nCopy));
					nRem -= (int)(nCopy);
				}

				*ppOut = p.aAlloc;
			}

			return (int)(0);
		}
		public static void vdbePmaReaderClear(PmaReader pReadr)
		{
			sqlite3_free(pReadr.aAlloc);
			sqlite3_free(pReadr.aBuffer);
			if ((pReadr.aMap) != null)
				sqlite3OsUnfetch(pReadr.pFd, (long)(0), pReadr.aMap);
			vdbeIncrFree(pReadr.pIncr);
			CRuntime.memset(pReadr, (int)(0), (ulong)(sizeof(PmaReader)));
		}
		public static int vdbePmaReaderIncrInit(PmaReader pReadr, int eMode)
		{
			IncrMerger pIncr = pReadr.pIncr;
			int rc = (int)(0);
			if ((pIncr) != null)
			{
				if ((pIncr.bUseThread) != 0)
				{
					void* pCtx = (void*)(pReadr);
					rc = (int)(vdbeSorterCreateThread(pIncr.pTask, vdbePmaReaderBgIncrInit, pCtx));
				}
				else
				{
					rc = (int)(vdbePmaReaderIncrMergeInit(pReadr, (int)(eMode)));
				}
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderIncrMergeInit(PmaReader pReadr, int eMode)
		{
			int rc = (int)(0);
			IncrMerger pIncr = pReadr.pIncr;
			SortSubtask pTask = pIncr.pTask;
			sqlite3 db = pTask.pSorter.db;
			rc = (int)(vdbeMergeEngineInit(pTask, pIncr.pMerger, (int)(eMode)));
			if ((rc) == (0))
			{
				int mxSz = (int)(pIncr.mxSz);
				if ((pIncr.bUseThread) != 0)
				{
					rc = (int)(vdbeSorterOpenTempFile(db, (long)(mxSz), pIncr.aFile[0].pFd));
					if ((rc) == (0))
					{
						rc = (int)(vdbeSorterOpenTempFile(db, (long)(mxSz), pIncr.aFile[1].pFd));
					}
				}
				else
				{
					if ((pTask.file2.pFd) == (null))
					{
						rc = (int)(vdbeSorterOpenTempFile(db, (long)(pTask.file2.iEof), pTask.file2.pFd));
						pTask.file2.iEof = (long)(0);
					}

					if ((rc) == (0))
					{
						pIncr.aFile[1].pFd = pTask.file2.pFd;
						pIncr.iStartOff = (long)(pTask.file2.iEof);
						pTask.file2.iEof += (long)(mxSz);
					}
				}
			}

			if (((rc) == (0)) && ((pIncr.bUseThread) != 0))
			{
				rc = (int)(vdbeIncrPopulate(pIncr));
			}

			if (((rc) == (0)) && (((8) == (0)) || (eMode != 1)))
			{
				rc = (int)(vdbePmaReaderNext(pReadr));
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderNext(PmaReader pReadr)
		{
			int rc = (int)(0);
			ulong nRec = (ulong)(0);
			if ((pReadr.iReadOff) >= (pReadr.iEof))
			{
				IncrMerger pIncr = pReadr.pIncr;
				int bEof = (int)(1);
				if ((pIncr) != null)
				{
					rc = (int)(vdbeIncrSwap(pIncr));
					if (((rc) == (0)) && ((pIncr.bEof) == (0)))
					{
						rc = (int)(vdbePmaReaderSeek(pIncr.pTask, pReadr, pIncr.aFile[0], (long)(pIncr.iStartOff)));
						bEof = (int)(0);
					}
				}

				if ((bEof) != 0)
				{
					vdbePmaReaderClear(pReadr);
					return (int)(rc);
				}
			}

			if ((rc) == (0))
			{
				rc = (int)(vdbePmaReadVarint(pReadr, &nRec));
			}

			if ((rc) == (0))
			{
				pReadr.nKey = ((int)(nRec));
				rc = (int)(vdbePmaReadBlob(pReadr, (int)(nRec), &pReadr.aKey));
			}

			return (int)(rc);
		}
		public static int vdbePmaReadVarint(PmaReader p, ulong* pnOut)
		{
			int iBuf = 0;
			if ((p.aMap) != null)
			{
				p.iReadOff += (long)(sqlite3GetVarint(&p.aMap[p.iReadOff], pnOut));
			}
			else
			{
				iBuf = (int)(p.iReadOff % p.nBuffer);
				if (((iBuf) != 0) && ((p.nBuffer - iBuf) >= (9)))
				{
					p.iReadOff += (long)(sqlite3GetVarint(&p.aBuffer[iBuf], pnOut));
				}
				else
				{
					byte* aVarint = stackalloc byte[16];
					byte* a;
					int i = (int)(0);
					int rc = 0;
					do
					{
						rc = (int)(vdbePmaReadBlob(p, (int)(1), &a));
						if ((rc) != 0)
							return (int)(rc);
						aVarint[(i++) & 0xf] = (byte)(a[0]);
					}
					while ((a[0] & 0x80) != 0);
					sqlite3GetVarint(aVarint, pnOut);
				}
			}

			return (int)(0);
		}
	}
}