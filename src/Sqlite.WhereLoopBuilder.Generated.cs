// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int indexMightHelpWithOrderBy(WhereLoopBuilder pBuilder, Index pIndex, int iCursor)
		{
			ExprList pOB;
			ExprList aColExpr;
			int ii = 0; int jj = 0;
			if ((pIndex.bUnordered) != 0)
				return (int)(0);
			if ((pOB = pBuilder.pWInfo.pOrderBy) == (null))
				return (int)(0);
			for (ii = (int)(0); (ii) < (pOB.nExpr); ii++)
			{
				Expr pExpr = sqlite3ExprSkipCollateAndLikely(pOB.a[ii].pExpr);
				if (((pExpr) == (null)))
					continue;
				if (((pExpr.op) == (167)) && ((pExpr.iTable) == (iCursor)))
				{
					if ((pExpr.iColumn) < (0))
						return (int)(1);
					for (jj = (int)(0); (jj) < (pIndex.nKeyCol); jj++)
					{
						if ((pExpr.iColumn) == (pIndex.aiColumn[jj]))
							return (int)(1);
					}
				}
				else if ((aColExpr = pIndex.aColExpr) != null)
				{
					for (jj = (int)(0); (jj) < (pIndex.nKeyCol); jj++)
					{
						if (pIndex.aiColumn[jj] != (-2))
							continue;
						if ((sqlite3ExprCompareSkip(pExpr, aColExpr.a[jj].pExpr, (int)(iCursor))) == (0))
						{
							return (int)(1);
						}
					}
				}
			}

			return (int)(0);
		}
		public static int whereLoopAddAll(WhereLoopBuilder pBuilder)
		{
			WhereInfo pWInfo = pBuilder.pWInfo;
			ulong mPrereq = (ulong)(0);
			ulong mPrior = (ulong)(0);
			int iTab = 0;
			SrcList pTabList = pWInfo.pTabList;
			SrcItem pItem;
			SrcItem pEnd = pTabList.a[pWInfo.nLevel];
			sqlite3 db = pWInfo.pParse.db;
			int rc = (int)(0);
			WhereLoop pNew;
			pNew = pBuilder.pNew;
			whereLoopInit(pNew);
			pBuilder.iPlanLimit = (uint)(20000);
			for (iTab = (int)(0), pItem = pTabList.a; (pItem) < (pEnd); iTab++, pItem++)
			{
				ulong mUnusable = (ulong)(0);
				pNew.iTab = (byte)(iTab);
				pBuilder.iPlanLimit += (uint)(1000);
				pNew.maskSelf = (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(pItem.iCursor)));
				if ((pItem.fg.jointype & (0x0008 | 0x0002)) != 0)
				{
					mPrereq = (ulong)(mPrior);
				}
				else
				{
					mPrereq = (ulong)(0);
				}

				if ((((pItem.pTab).eTabType) == (1)))
				{
					SrcItem p;
					for (p = pItem[1]; (p) < (pEnd); p++)
					{
						if (((mUnusable) != 0) || ((p.fg.jointype & (0x0008 | 0x0002)) != 0))
						{
							mUnusable |= (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(p.iCursor)));
						}
					}

					rc = (int)(whereLoopAddVirtual(pBuilder, (ulong)(mPrereq), (ulong)(mUnusable)));
				}
				else
				{
					rc = (int)(whereLoopAddBtree(pBuilder, (ulong)(mPrereq)));
				}

				if (((rc) == (0)) && ((pBuilder.pWC.hasOr) != 0))
				{
					rc = (int)(whereLoopAddOr(pBuilder, (ulong)(mPrereq), (ulong)(mUnusable)));
				}

				mPrior |= (ulong)(pNew.maskSelf);
				if (((rc) != 0) || ((db.mallocFailed) != 0))
				{
					if ((rc) == (101))
					{
						sqlite3_log((int)(28), "abbreviated query algorithm search");
						rc = (int)(0);
					}
					else
					{
						break;
					}
				}
			}

			whereLoopClear(db, pNew);
			return (int)(rc);
		}
		public static int whereLoopAddBtree(WhereLoopBuilder pBuilder, ulong mPrereq)
		{
			WhereInfo pWInfo;
			Index pProbe;
			Index sPk = new Index();
			short* aiRowEstPk = stackalloc short[2];
			short aiColumnPk = (short)(-1);
			SrcList pTabList;
			SrcItem pSrc;
			WhereLoop pNew;
			int rc = (int)(0);
			int iSortIdx = (int)(1);
			int b = 0;
			short rSize = 0;
			WhereClause pWC;
			Table pTab;
			pNew = pBuilder.pNew;
			pWInfo = pBuilder.pWInfo;
			pTabList = pWInfo.pTabList;
			pSrc = pTabList.a[pNew.iTab];
			pTab = pSrc.pTab;
			pWC = pBuilder.pWC;
			if ((pSrc.fg.isIndexedBy) != 0)
			{
				pProbe = pSrc.u2.pIBIndex;
			}
			else if (!(((pTab).tabFlags & 0x00000080) == (0)))
			{
				pProbe = pTab.pIndex;
			}
			else
			{
				Index pFirst;
				CRuntime.memset(sPk, (int)(0), (ulong)(sizeof(Index)));
				sPk.nKeyCol = (ushort)(1);
				sPk.nColumn = (ushort)(1);
				sPk.aiColumn = &aiColumnPk;
				sPk.aiRowLogEst = aiRowEstPk;
				sPk.onError = (byte)(5);
				sPk.pTable = pTab;
				sPk.szIdxRow = (short)(pTab.szTabRow);
				sPk.idxType = (uint)(3);
				aiRowEstPk[0] = (short)(pTab.nRowLogEst);
				aiRowEstPk[1] = (short)(0);
				pFirst = pSrc.pTab.pIndex;
				if ((pSrc.fg.notIndexed) == (0))
				{
					sPk.pNext = pFirst;
				}

				pProbe = sPk;
			}

			rSize = (short)(pTab.nRowLogEst);
			if ((((((((pBuilder.pOrSet == null) && ((pWInfo.wctrlFlags & 0x0020) == (0))) && ((pWInfo.pParse.db.flags & 0x00008000) != 0)) && (pSrc.fg.isIndexedBy == 0)) && (pSrc.fg.notIndexed == 0)) && (((pTab).tabFlags & 0x00000080) == (0))) && (pSrc.fg.isCorrelated == 0)) && (pSrc.fg.isRecursive == 0))
			{
				short rLogSize = 0;
				WhereTerm pTerm;
				WhereTerm pWCEnd = pWC.a[pWC.nTerm];
				rLogSize = (short)(estLog((short)(rSize)));
				for (pTerm = pWC.a; ((rc) == (0)) && ((pTerm) < (pWCEnd)); pTerm++)
				{
					if ((pTerm.prereqRight & pNew.maskSelf) != 0)
						continue;
					if ((termCanDriveIndex(pTerm, pSrc, (ulong)(0))) != 0)
					{
						pNew.u.btree.nEq = (ushort)(1);
						pNew.nSkip = (ushort)(0);
						pNew.u.btree.pIndex = null;
						pNew.nLTerm = (ushort)(1);
						pNew.aLTerm[0] = pTerm;
						pNew.rSetup = (short)(rLogSize + rSize);
						if ((!(((pTab).eTabType) == (2))) && ((pTab.tabFlags & 0x00004000) == (0)))
						{
							pNew.rSetup += (short)(28);
						}
						else
						{
							pNew.rSetup -= (short)(10);
						}

						if ((pNew.rSetup) < (0))
							pNew.rSetup = (short)(0);
						pNew.nOut = (short)(43);
						pNew.rRun = (short)(sqlite3LogEstAdd((short)(rLogSize), (short)(pNew.nOut)));
						pNew.wsFlags = (uint)(0x00004000);
						pNew.prereq = (ulong)(mPrereq | pTerm.prereqRight);
						rc = (int)(whereLoopInsert(pBuilder, pNew));
					}
				}
			}

			for (; ((rc) == (0)) && ((pProbe) != null); pProbe = ((pSrc.fg.isIndexedBy) != 0 ? null : pProbe.pNext), iSortIdx++)
			{
				int isLeft = (int)((pSrc.fg.jointype & 0x0020) != 0);
				if ((pProbe.pPartIdxWhere != null) && (whereUsablePartialIndex((int)(pSrc.iCursor), (int)(isLeft), pWC, pProbe.pPartIdxWhere) == 0))
				{
					continue;
				}

				if ((pProbe.bNoQuery) != 0)
					continue;
				rSize = (short)(pProbe.aiRowLogEst[0]);
				pNew.u.btree.nEq = (ushort)(0);
				pNew.u.btree.nBtm = (ushort)(0);
				pNew.u.btree.nTop = (ushort)(0);
				pNew.nSkip = (ushort)(0);
				pNew.nLTerm = (ushort)(0);
				pNew.iSortIdx = (byte)(0);
				pNew.rSetup = (short)(0);
				pNew.prereq = (ulong)(mPrereq);
				pNew.nOut = (short)(rSize);
				pNew.u.btree.pIndex = pProbe;
				b = (int)(indexMightHelpWithOrderBy(pBuilder, pProbe, (int)(pSrc.iCursor)));
				if ((pProbe.idxType) == (3))
				{
					pNew.wsFlags = (uint)(0x00000100);
					pNew.iSortIdx = (byte)((b) != 0 ? iSortIdx : 0);
					pNew.rRun = (short)(rSize + 16);
					whereLoopOutputAdjust(pWC, pNew, (short)(rSize));
					rc = (int)(whereLoopInsert(pBuilder, pNew));
					pNew.nOut = (short)(rSize);
					if ((rc) != 0)
						break;
				}
				else
				{
					ulong m = 0;
					if ((pProbe.isCovering) != 0)
					{
						pNew.wsFlags = (uint)(0x00000040 | 0x00000200);
						m = (ulong)(0);
					}
					else
					{
						m = (ulong)(pSrc.colUsed & pProbe.colNotIdxed);
						pNew.wsFlags = (uint)(((m) == (0)) ? (0x00000040 | 0x00000200) : 0x00000200);
					}

					if ((((((b) != 0) || (!(((pTab).tabFlags & 0x00000080) == (0)))) || (pProbe.pPartIdxWhere != null)) || ((pSrc.fg.isIndexedBy) != 0)) || (((((((m) == (0)) && ((pProbe.bUnordered) == (0))) && ((pProbe.szIdxRow) < (pTab.szTabRow))) && ((pWInfo.wctrlFlags & 0x0004) == (0))) && ((sqlite3Config.bUseCis) != 0)) && (((pWInfo.pParse.db).dbOptFlags & (0x00000020)) == (0))))
					{
						pNew.iSortIdx = (byte)((b) != 0 ? iSortIdx : 0);
						pNew.rRun = (short)(rSize + 1 + (15 * pProbe.szIdxRow) / pTab.szTabRow);
						if (m != 0)
						{
							short nLookup = (short)(rSize + 16);
							int ii = 0;
							int iCur = (int)(pSrc.iCursor);
							WhereClause pWC2 = pWInfo.sWC;
							for (ii = (int)(0); (ii) < (pWC2.nTerm); ii++)
							{
								WhereTerm pTerm = pWC2.a[ii];
								if (sqlite3ExprCoveredByIndex(pTerm.pExpr, (int)(iCur), pProbe) == 0)
								{
									break;
								}

								if ((pTerm.truthProb) <= (0))
								{
									nLookup += (short)(pTerm.truthProb);
								}
								else
								{
									nLookup--;
									if ((pTerm.eOperator & (0x0002 | 0x0080)) != 0)
										nLookup -= (short)(19);
								}
							}

							pNew.rRun = (short)(sqlite3LogEstAdd((short)(pNew.rRun), (short)(nLookup)));
						}

						whereLoopOutputAdjust(pWC, pNew, (short)(rSize));
						rc = (int)(whereLoopInsert(pBuilder, pNew));
						pNew.nOut = (short)(rSize);
						if ((rc) != 0)
							break;
					}
				}

				pBuilder.bldFlags1 = (byte)(0);
				rc = (int)(whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(0)));
				if ((pBuilder.bldFlags1) == (0x0001))
				{
					pTab.tabFlags |= (uint)(0x00000100);
				}
			}

			return (int)(rc);
		}
		public static int whereLoopAddBtreeIndex(WhereLoopBuilder pBuilder, SrcItem pSrc, Index pProbe, short nInMul)
		{
			WhereInfo pWInfo = pBuilder.pWInfo;
			Parse pParse = pWInfo.pParse;
			sqlite3 db = pParse.db;
			WhereLoop pNew;
			WhereTerm pTerm;
			int opMask = 0;
			WhereScan scan = new WhereScan();
			ulong saved_prereq = 0;
			ushort saved_nLTerm = 0;
			ushort saved_nEq = 0;
			ushort saved_nBtm = 0;
			ushort saved_nTop = 0;
			ushort saved_nSkip = 0;
			uint saved_wsFlags = 0;
			short saved_nOut = 0;
			int rc = (int)(0);
			short rSize = 0;
			short rLogSize = 0;
			WhereTerm pTop = null; WhereTerm pBtm = null;
			pNew = pBuilder.pNew;
			if ((db.mallocFailed) != 0)
				return (int)(7);
			if ((pNew.wsFlags & 0x00000020) != 0)
			{
				opMask = (int)((0x0002 << (56 - 53)) | (0x0002 << (55 - 53)));
			}
			else
			{
				opMask = (int)(0x0002 | 0x0001 | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)) | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53)) | 0x0100 | 0x0080);
			}

			if ((pProbe.bUnordered) != 0)
				opMask &= (int)(~((0x0002 << (54 - 53)) | (0x0002 << (57 - 53)) | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53))));
			saved_nEq = (ushort)(pNew.u.btree.nEq);
			saved_nBtm = (ushort)(pNew.u.btree.nBtm);
			saved_nTop = (ushort)(pNew.u.btree.nTop);
			saved_nSkip = (ushort)(pNew.nSkip);
			saved_nLTerm = (ushort)(pNew.nLTerm);
			saved_wsFlags = (uint)(pNew.wsFlags);
			saved_prereq = (ulong)(pNew.prereq);
			saved_nOut = (short)(pNew.nOut);
			pTerm = whereScanInit(scan, pBuilder.pWC, (int)(pSrc.iCursor), (int)(saved_nEq), (uint)(opMask), pProbe);
			pNew.rSetup = (short)(0);
			rSize = (short)(pProbe.aiRowLogEst[0]);
			rLogSize = (short)(estLog((short)(rSize)));
			for (; ((rc) == (0)) && (pTerm != null); pTerm = whereScanNext(scan))
			{
				ushort eOp = (ushort)(pTerm.eOperator);
				short rCostIdx = 0;
				short nOutUnadjusted = 0;
				int nIn = (int)(0);
				if ((((eOp) == (0x0100)) || ((pTerm.wtFlags & 0x0080) != 0)) && ((indexColumnNotNull(pProbe, (int)(saved_nEq))) != 0))
				{
					continue;
				}

				if ((pTerm.prereqRight & pNew.maskSelf) != 0)
					continue;
				if (((pTerm.wtFlags & 0x0100) != 0) && ((pTerm.eOperator) == (0x0002 << (56 - 53))))
					continue;
				if (((pSrc.fg.jointype & 0x0008) != 0) && (!(((pTerm.pExpr).flags & (0x000001)) != 0)))
				{
					continue;
				}

				if (((pProbe).onError != 0) && ((saved_nEq) == (pProbe.nKeyCol - 1)))
				{
					pBuilder.bldFlags1 |= (byte)(0x0002);
				}
				else
				{
					pBuilder.bldFlags1 |= (byte)(0x0001);
				}

				pNew.wsFlags = (uint)(saved_wsFlags);
				pNew.u.btree.nEq = (ushort)(saved_nEq);
				pNew.u.btree.nBtm = (ushort)(saved_nBtm);
				pNew.u.btree.nTop = (ushort)(saved_nTop);
				pNew.nLTerm = (ushort)(saved_nLTerm);
				if ((whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1))) != 0)
					break;
				pNew.aLTerm[pNew.nLTerm++] = pTerm;
				pNew.prereq = (ulong)((saved_prereq | pTerm.prereqRight) & ~pNew.maskSelf);
				if ((eOp & 0x0001) != 0)
				{
					Expr pExpr = pTerm.pExpr;
					if ((((pExpr).flags & 0x000800) != 0))
					{
						int i = 0;
						nIn = (int)(46);
						for (i = (int)(0); (i) < (pNew.nLTerm - 1); i++)
						{
							if (((pNew.aLTerm[i]) != null) && ((pNew.aLTerm[i].pExpr) == (pExpr)))
								nIn = (int)(0);
						}
					}
					else if ((((pExpr.x.pList) != null) && ((pExpr.x.pList.nExpr) != 0)))
					{
						nIn = (int)(sqlite3LogEst((ulong)(pExpr.x.pList.nExpr)));
					}

					if (((pProbe.hasStat1) != 0) && ((rLogSize) >= (10)))
					{
						short M = 0;
						short logK = 0;
						short x = 0;
						M = (short)(pProbe.aiRowLogEst[saved_nEq]);
						logK = (short)(estLog((short)(nIn)));
						x = (short)(M + logK + 10 - (nIn + rLogSize));
						if ((x) >= (0))
						{
						}
						else if (((nInMul) < (2)) && (((db).dbOptFlags & (0x00020000)) == (0)))
						{
							pNew.wsFlags |= (uint)(0x00100000);
						}
						else
						{
							continue;
						}
					}

					pNew.wsFlags |= (uint)(0x00000004);
				}
				else if ((eOp & (0x0002 | 0x0080)) != 0)
				{
					int iCol = (int)(pProbe.aiColumn[saved_nEq]);
					pNew.wsFlags |= (uint)(0x00000001);
					if (((iCol) == (-1)) || ((((iCol) >= (0)) && ((nInMul) == (0))) && ((saved_nEq) == (pProbe.nKeyCol - 1))))
					{
						if ((((iCol) == (-1)) || ((pProbe.uniqNotNull) != 0)) || ((((pProbe.nKeyCol) == (1)) && ((pProbe.onError) != 0)) && ((eOp) == (0x0002))))
						{
							pNew.wsFlags |= (uint)(0x00001000);
						}
						else
						{
							pNew.wsFlags |= (uint)(0x00010000);
						}
					}

					if ((scan.iEquiv) > (1))
						pNew.wsFlags |= (uint)(0x00200000);
				}
				else if ((eOp & 0x0100) != 0)
				{
					pNew.wsFlags |= (uint)(0x00000008);
				}
				else if ((eOp & ((0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) != 0)
				{
					pNew.wsFlags |= (uint)(0x00000002 | 0x00000020);
					pNew.u.btree.nBtm = (ushort)(whereRangeVectorLen(pParse, (int)(pSrc.iCursor), pProbe, (int)(saved_nEq), pTerm));
					pBtm = pTerm;
					pTop = null;
					if ((pTerm.wtFlags & 0x0100) != 0)
					{
						pTop = pTerm[1];
						if ((whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1))) != 0)
							break;
						pNew.aLTerm[pNew.nLTerm++] = pTop;
						pNew.wsFlags |= (uint)(0x00000010);
						pNew.u.btree.nTop = (ushort)(1);
					}
				}
				else
				{
					pNew.wsFlags |= (uint)(0x00000002 | 0x00000010);
					pNew.u.btree.nTop = (ushort)(whereRangeVectorLen(pParse, (int)(pSrc.iCursor), pProbe, (int)(saved_nEq), pTerm));
					pTop = pTerm;
					pBtm = (pNew.wsFlags & 0x00000020) != 0 ? pNew.aLTerm[pNew.nLTerm - 2] : null;
				}

				if ((pNew.wsFlags & 0x00000002) != 0)
				{
					whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
				}
				else
				{
					int nEq = (int)(++pNew.u.btree.nEq);
					if (((pTerm.truthProb) <= (0)) && ((pProbe.aiColumn[saved_nEq]) >= (0)))
					{
						pNew.nOut += (short)(pTerm.truthProb);
						pNew.nOut -= (short)(nIn);
					}
					else
					{
						{
							pNew.nOut += (short)(pProbe.aiRowLogEst[nEq] - pProbe.aiRowLogEst[nEq - 1]);
							if ((eOp & 0x0100) != 0)
							{
								pNew.nOut += (short)(10);
							}
						}
					}
				}

				rCostIdx = (short)(pNew.nOut + 1 + (15 * pProbe.szIdxRow) / pSrc.pTab.szTabRow);
				pNew.rRun = (short)(sqlite3LogEstAdd((short)(rLogSize), (short)(rCostIdx)));
				if ((pNew.wsFlags & (0x00000040 | 0x00000100)) == (0))
				{
					pNew.rRun = (short)(sqlite3LogEstAdd((short)(pNew.rRun), (short)(pNew.nOut + 16)));
				}

				nOutUnadjusted = (short)(pNew.nOut);
				pNew.rRun += (short)(nInMul + nIn);
				pNew.nOut += (short)(nInMul + nIn);
				whereLoopOutputAdjust(pBuilder.pWC, pNew, (short)(rSize));
				rc = (int)(whereLoopInsert(pBuilder, pNew));
				if ((pNew.wsFlags & 0x00000002) != 0)
				{
					pNew.nOut = (short)(saved_nOut);
				}
				else
				{
					pNew.nOut = (short)(nOutUnadjusted);
				}

				if ((((pNew.wsFlags & 0x00000010) == (0)) && ((pNew.u.btree.nEq) < (pProbe.nColumn))) && (((pNew.u.btree.nEq) < (pProbe.nKeyCol)) || (pProbe.idxType != 2)))
				{
					whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(nInMul + nIn));
				}

				pNew.nOut = (short)(saved_nOut);
			}

			pNew.prereq = (ulong)(saved_prereq);
			pNew.u.btree.nEq = (ushort)(saved_nEq);
			pNew.u.btree.nBtm = (ushort)(saved_nBtm);
			pNew.u.btree.nTop = (ushort)(saved_nTop);
			pNew.nSkip = (ushort)(saved_nSkip);
			pNew.wsFlags = (uint)(saved_wsFlags);
			pNew.nOut = (short)(saved_nOut);
			pNew.nLTerm = (ushort)(saved_nLTerm);
			if (((((((((saved_nEq) == (saved_nSkip)) && ((saved_nEq + 1) < (pProbe.nKeyCol))) && ((saved_nEq) == (pNew.nLTerm))) && ((pProbe.noSkipScan) == (0))) && (pProbe.hasStat1 != 0)) && (((db).dbOptFlags & (0x00004000)) == (0))) && ((pProbe.aiRowLogEst[saved_nEq + 1]) >= (42))) && ((rc = (int)(whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1)))) == (0)))
			{
				short nIter = 0;
				pNew.u.btree.nEq++;
				pNew.nSkip++;
				pNew.aLTerm[pNew.nLTerm++] = null;
				pNew.wsFlags |= (uint)(0x00008000);
				nIter = (short)(pProbe.aiRowLogEst[saved_nEq] - pProbe.aiRowLogEst[saved_nEq + 1]);
				pNew.nOut -= (short)(nIter);
				nIter += (short)(5);
				whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(nIter + nInMul));
				pNew.nOut = (short)(saved_nOut);
				pNew.u.btree.nEq = (ushort)(saved_nEq);
				pNew.nSkip = (ushort)(saved_nSkip);
				pNew.wsFlags = (uint)(saved_wsFlags);
			}

			return (int)(rc);
		}
		public static int whereLoopAddOr(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUnusable)
		{
			WhereInfo pWInfo = pBuilder.pWInfo;
			WhereClause pWC;
			WhereLoop pNew;
			WhereTerm pTerm; WhereTerm pWCEnd;
			int rc = (int)(0);
			int iCur = 0;
			WhereClause tempWC = new WhereClause();
			WhereLoopBuilder sSubBuild = new WhereLoopBuilder();
			WhereOrSet sSum = new WhereOrSet(); WhereOrSet sCur = new WhereOrSet();
			SrcItem pItem;
			pWC = pBuilder.pWC;
			pWCEnd = pWC.a[pWC.nTerm];
			pNew = pBuilder.pNew;
			CRuntime.memset(sSum, (int)(0), (ulong)(sizeof(WhereOrSet)));
			pItem = pWInfo.pTabList.a[pNew.iTab];
			iCur = (int)(pItem.iCursor);
			for (pTerm = pWC.a; ((pTerm) < (pWCEnd)) && ((rc) == (0)); pTerm++)
			{
				if (((pTerm.eOperator & 0x0200) != 0) && ((pTerm.u.pOrInfo.indexable & pNew.maskSelf) != 0))
				{
					WhereClause pOrWC = pTerm.u.pOrInfo.wc;
					WhereTerm pOrWCEnd = pOrWC.a[pOrWC.nTerm];
					WhereTerm pOrTerm;
					int once = (int)(1);
					int i = 0;
					int j = 0;
					sSubBuild = (WhereLoopBuilder)(pBuilder);
					sSubBuild.pOrSet = sCur;
					for (pOrTerm = pOrWC.a; (pOrTerm) < (pOrWCEnd); pOrTerm++)
					{
						if ((pOrTerm.eOperator & 0x0400) != 0)
						{
							sSubBuild.pWC = pOrTerm.u.pAndInfo.wc;
						}
						else if ((pOrTerm.leftCursor) == (iCur))
						{
							tempWC.pWInfo = pWC.pWInfo;
							tempWC.pOuter = pWC;
							tempWC.op = (byte)(44);
							tempWC.nTerm = (int)(1);
							tempWC.nBase = (int)(1);
							tempWC.a = pOrTerm;
							sSubBuild.pWC = tempWC;
						}
						else
						{
							continue;
						}

						sCur.n = (ushort)(0);
						if ((((pItem.pTab).eTabType) == (1)))
						{
							rc = (int)(whereLoopAddVirtual(sSubBuild, (ulong)(mPrereq), (ulong)(mUnusable)));
						}
						else
						{
							rc = (int)(whereLoopAddBtree(sSubBuild, (ulong)(mPrereq)));
						}

						if ((rc) == (0))
						{
							rc = (int)(whereLoopAddOr(sSubBuild, (ulong)(mPrereq), (ulong)(mUnusable)));
						}

						if ((sCur.n) == (0))
						{
							sSum.n = (ushort)(0);
							break;
						}
						else if ((once) != 0)
						{
							whereOrMove(sSum, sCur);
							once = (int)(0);
						}
						else
						{
							WhereOrSet sPrev = new WhereOrSet();
							whereOrMove(sPrev, sSum);
							sSum.n = (ushort)(0);
							for (i = (int)(0); (i) < (sPrev.n); i++)
							{
								for (j = (int)(0); (j) < (sCur.n); j++)
								{
									whereOrInsert(sSum, (ulong)(sPrev.a[i].prereq | sCur.a[j].prereq), (short)(sqlite3LogEstAdd((short)(sPrev.a[i].rRun), (short)(sCur.a[j].rRun))), (short)(sqlite3LogEstAdd((short)(sPrev.a[i].nOut), (short)(sCur.a[j].nOut))));
								}
							}
						}
					}

					pNew.nLTerm = (ushort)(1);
					pNew.aLTerm[0] = pTerm;
					pNew.wsFlags = (uint)(0x00002000);
					pNew.rSetup = (short)(0);
					pNew.iSortIdx = (byte)(0);
					CRuntime.memset(&pNew.u, (int)(0), (ulong)(sizeof(union WhereLoop::(unnamed at sqlite3.c : 146967 : 3)) ) ) ; for (i = (int)(0); ((rc) == (0)) && ((i) < (sSum.n)); i++) { pNew.rRun = (short)(sSum.a[i].rRun + 1); pNew.nOut = (short)(sSum.a[i].nOut); pNew.prereq = (ulong)(sSum.a[i].prereq); rc = (int)(whereLoopInsert(pBuilder, pNew)); }
		}
	}

    return (int) (rc);
}
public static int whereLoopAddVirtual(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUnusable)
{
	int rc = (int)(0);
	WhereInfo pWInfo;
	Parse pParse;
	WhereClause pWC;
	SrcItem pSrc;
	sqlite3_index_info* p;
	int nConstraint = 0;
	int bIn = 0;
	WhereLoop pNew;
	ulong mBest = 0;
	ushort mNoOmit = 0;
	int bRetry = (int)(0);
	pWInfo = pBuilder.pWInfo;
	pParse = pWInfo.pParse;
	pWC = pBuilder.pWC;
	pNew = pBuilder.pNew;
	pSrc = pWInfo.pTabList.a[pNew.iTab];
	p = allocateIndexInfo(pWInfo, pWC, (ulong)(mUnusable), pSrc, &mNoOmit);
	if ((p) == (null))
		return (int)(7);
	pNew.rSetup = (short)(0);
	pNew.wsFlags = (uint)(0x00000400);
	pNew.nLTerm = (ushort)(0);
	pNew.u.vtab.needFree = (uint)(0);
	nConstraint = (int)(p->nConstraint);
	if ((whereLoopResize(pParse.db, pNew, (int)(nConstraint))) != 0)
	{
		freeIndexInfo(pParse.db, p);
		return (int)(7);
	}

	rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0), p, (ushort)(mNoOmit), &bIn, &bRetry));
	if ((bRetry) != 0)
	{
		rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0), p, (ushort)(mNoOmit), &bIn, null));
	}

	if (((rc) == (0)) && (((mBest = (ulong)(pNew.prereq & ~mPrereq)) != 0) || ((bIn) != 0)))
	{
		int seenZero = (int)(0);
		int seenZeroNoIN = (int)(0);
		ulong mPrev = (ulong)(0);
		ulong mBestNoIn = (ulong)(0);
		if ((bIn) != 0)
		{
			rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0x0001), p, (ushort)(mNoOmit), &bIn, null));
			mBestNoIn = (ulong)(pNew.prereq & ~mPrereq);
			if ((mBestNoIn) == (0))
			{
				seenZero = (int)(1);
				seenZeroNoIN = (int)(1);
			}
		}

		while ((rc) == (0))
		{
			int i = 0;
			ulong mNext = ((ulong)(-1));
			for (i = (int)(0); (i) < (nConstraint); i++)
			{
				ulong mThis = (ulong)(pWC.a[p->aConstraint[i].iTermOffset].prereqRight & ~mPrereq);
				if (((mThis) > (mPrev)) && ((mThis) < (mNext)))
					mNext = (ulong)(mThis);
			}

			mPrev = (ulong)(mNext);
			if ((mNext) == ((ulong)(-1)))
				break;
			if (((mNext) == (mBest)) || ((mNext) == (mBestNoIn)))
				continue;
			rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mNext | mPrereq), (ushort)(0), p, (ushort)(mNoOmit), &bIn, null));
			if ((pNew.prereq) == (mPrereq))
			{
				seenZero = (int)(1);
				if ((bIn) == (0))
					seenZeroNoIN = (int)(1);
			}
		}

		if (((rc) == (0)) && ((seenZero) == (0)))
		{
			rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mPrereq), (ushort)(0), p, (ushort)(mNoOmit), &bIn, null));
			if ((bIn) == (0))
				seenZeroNoIN = (int)(1);
		}

		if (((rc) == (0)) && ((seenZeroNoIN) == (0)))
		{
			rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mPrereq), (ushort)(0x0001), p, (ushort)(mNoOmit), &bIn, null));
		}
	}

	if ((p->needToFreeIdxStr) != 0)
		sqlite3_free(p->idxStr);
	freeIndexInfo(pParse.db, p);
	return (int)(rc);
}
public static int whereLoopAddVirtualOne(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUsable, ushort mExclude, sqlite3_index_info* pIdxInfo, ushort mNoOmit, int* pbIn, int* pbRetryLimit)
{
	WhereClause pWC = pBuilder.pWC;
	HiddenIndexInfo pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
	sqlite3_index_constraint* pIdxCons;
	sqlite3_index_constraint_usage* pUsage = pIdxInfo->aConstraintUsage;
	int i = 0;
	int mxTerm = 0;
	int rc = (int)(0);
	WhereLoop pNew = pBuilder.pNew;
	Parse pParse = pBuilder.pWInfo.pParse;
	SrcItem pSrc = pBuilder.pWInfo.pTabList.a[pNew.iTab];
	int nConstraint = (int)(pIdxInfo->nConstraint);
	*pbIn = (int)(0);
	pNew.prereq = (ulong)(mPrereq);
	pIdxCons = *&pIdxInfo->aConstraint;
	for (i = (int)(0); (i) < (nConstraint); i++, pIdxCons++)
	{
		WhereTerm pTerm = pWC.a[pIdxCons->iTermOffset];
		pIdxCons->usable = (byte)(0);
		if ((((pTerm.prereqRight & mUsable) == (pTerm.prereqRight)) && ((pTerm.eOperator & mExclude) == (0))) && (((pbRetryLimit) != null) || (isLimitTerm(pTerm) == 0)))
		{
			pIdxCons->usable = (byte)(1);
		}
	}

	CRuntime.memset(pUsage, (int)(0), (ulong)(sizeof(sqlite3_index_constraint_usage) * nConstraint));
	pIdxInfo->idxStr = null;
	pIdxInfo->idxNum = (int)(0);
	pIdxInfo->orderByConsumed = (int)(0);
	pIdxInfo->estimatedCost = (double)((1e99) / (double)(2));
	pIdxInfo->estimatedRows = (long)(25);
	pIdxInfo->idxFlags = (int)(0);
	pIdxInfo->colUsed = (ulong)((long)(pSrc.colUsed));
	pHidden.mHandleIn = (uint)(0);
	rc = (int)(vtabBestIndex(pParse, pSrc.pTab, pIdxInfo));
	if ((rc) != 0)
	{
		if ((rc) == (19))
		{
			return (int)(0);
		}

		return (int)(rc);
	}

	mxTerm = (int)(-1);
	CRuntime.memset(pNew.aLTerm, (int)(0), (ulong)(sizeof(WhereTerm) * nConstraint));
	CRuntime.memset(&pNew.u.vtab, (int)(0), (ulong)(sizeof(WhereLoop::(unnamed at sqlite3.c : 146975 : 5))) ) ;
pIdxCons = *&pIdxInfo->aConstraint;
for (i = (int)(0); (i) < (nConstraint); i++, pIdxCons++)
{
	int iTerm = 0;
	if ((iTerm = (int)(pUsage[i].argvIndex - 1)) >= (0))
	{
		WhereTerm pTerm;
		int j = (int)(pIdxCons->iTermOffset);
		if ((((((iTerm) >= (nConstraint)) || ((j) < (0))) || ((j) >= (pWC.nTerm))) || (pNew.aLTerm[iTerm] != null)) || ((pIdxCons->usable) == (0)))
		{
			sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc.pTab.zName);
			return (int)(1);
		}

		pTerm = pWC.a[j];
		pNew.prereq |= (ulong)(pTerm.prereqRight);
		pNew.aLTerm[iTerm] = pTerm;
		if ((iTerm) > (mxTerm))
			mxTerm = (int)(iTerm);
		if ((pUsage[i].omit) != 0)
		{
			if (((i) < (16)) && (((1 << i) & mNoOmit) == (0)))
			{
				pNew.u.vtab.omitMask |= (ushort)(1 << iTerm);
			}
			else
			{
			}

			if ((pTerm.eMatchOp) == (74))
			{
				pNew.u.vtab.bOmitOffset = (uint)(1);
			}
		}

		if ((((i) <= (31) ? ((uint)(1)) << (i) : 0) & pHidden.mHandleIn) != 0)
		{
			pNew.u.vtab.mHandleIn |= (uint)(((uint)(1)) << (iTerm));
		}
		else if ((pTerm.eOperator & 0x0001) != 0)
		{
			pIdxInfo->orderByConsumed = (int)(0);
			pIdxInfo->idxFlags &= (int)(~1);
			*pbIn = (int)(1);
		}

		if (((isLimitTerm(pTerm)) != 0) && ((*pbIn) != 0))
		{
			if ((pIdxInfo->needToFreeIdxStr) != 0)
			{
				sqlite3_free(pIdxInfo->idxStr);
				pIdxInfo->idxStr = null;
				pIdxInfo->needToFreeIdxStr = (int)(0);
			}

			*pbRetryLimit = (int)(1);
			return (int)(0);
		}
	}
}

pNew.nLTerm = (ushort)(mxTerm + 1);
for (i = (int)(0); (i) <= (mxTerm); i++)
{
	if ((pNew.aLTerm[i]) == (null))
	{
		sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc.pTab.zName);
		return (int)(1);
	}
}

pNew.u.vtab.idxNum = (int)(pIdxInfo->idxNum);
pNew.u.vtab.needFree = (uint)(pIdxInfo->needToFreeIdxStr);
pIdxInfo->needToFreeIdxStr = (int)(0);
pNew.u.vtab.idxStr = pIdxInfo->idxStr;
pNew.u.vtab.isOrdered = ((sbyte)((pIdxInfo->orderByConsumed) != 0 ? pIdxInfo->nOrderBy : 0));
pNew.rSetup = (short)(0);
pNew.rRun = (short)(sqlite3LogEstFromDouble((double)(pIdxInfo->estimatedCost)));
pNew.nOut = (short)(sqlite3LogEst((ulong)(pIdxInfo->estimatedRows)));
if ((pIdxInfo->idxFlags & 1) != 0)
{
	pNew.wsFlags |= (uint)(0x00001000);
}
else
{
	pNew.wsFlags &= (uint)(~0x00001000);
}

rc = (int)(whereLoopInsert(pBuilder, pNew));
if ((pNew.u.vtab.needFree) != 0)
{
	sqlite3_free(pNew.u.vtab.idxStr);
	pNew.u.vtab.needFree = (uint)(0);
}

return (int)(rc);
}
public static int whereLoopInsert(WhereLoopBuilder pBuilder, WhereLoop pTemplate)
{
	WhereLoop ppPrev; WhereLoop p;
	WhereInfo pWInfo = pBuilder.pWInfo;
	sqlite3 db = pWInfo.pParse.db;
	int rc = 0;
	if ((pBuilder.iPlanLimit) == (0))
	{
		if ((pBuilder.pOrSet) != null)
			pBuilder.pOrSet.n = (ushort)(0);
		return (int)(101);
	}

	pBuilder.iPlanLimit--;
	whereLoopAdjustCost(pWInfo.pLoops, pTemplate);
	if (pBuilder.pOrSet != null)
	{
		if ((pTemplate.nLTerm) != 0)
		{
			whereOrInsert(pBuilder.pOrSet, (ulong)(pTemplate.prereq), (short)(pTemplate.rRun), (short)(pTemplate.nOut));
		}

		return (int)(0);
	}

	ppPrev = whereLoopFindLesser(pWInfo.pLoops, pTemplate);
	if ((ppPrev) == (null))
	{
		return (int)(0);
	}
	else
	{
		p = ppPrev;
	}

	if ((p) == (null))
	{
		ppPrev = p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereLoop)));
		if ((p) == (null))
			return (int)(7);
		whereLoopInit(p);
		p.pNextLoop = null;
	}
	else
	{
		WhereLoop ppTail = p.pNextLoop;
		WhereLoop pToDel;
		while ((ppTail) != null)
		{
			ppTail = whereLoopFindLesser(ppTail, pTemplate);
			if ((ppTail) == (null))
				break;
			pToDel = ppTail;
			if ((pToDel) == (null))
				break;
			ppTail = pToDel.pNextLoop;
			whereLoopDelete(db, pToDel);
		}
	}

	rc = (int)(whereLoopXfer(db, p, pTemplate));
	if ((p.wsFlags & 0x00000400) == (0))
	{
		Index pIndex = p.u.btree.pIndex;
		if (((pIndex) != null) && ((pIndex.idxType) == (3)))
		{
			p.u.btree.pIndex = null;
		}
	}

	return (int)(rc);
}
public static int whereShortCut(WhereLoopBuilder pBuilder)
{
	WhereInfo pWInfo;
	SrcItem pItem;
	WhereClause pWC;
	WhereTerm pTerm;
	WhereLoop pLoop;
	int iCur = 0;
	int j = 0;
	Table pTab;
	Index pIdx;
	WhereScan scan = new WhereScan();
	pWInfo = pBuilder.pWInfo;
	if ((pWInfo.wctrlFlags & 0x0020) != 0)
		return (int)(0);
	pItem = pWInfo.pTabList.a;
	pTab = pItem.pTab;
	if ((((pTab).eTabType) == (1)))
		return (int)(0);
	if ((pItem.fg.isIndexedBy) != 0)
		return (int)(0);
	iCur = (int)(pItem.iCursor);
	pWC = pWInfo.sWC;
	pLoop = pBuilder.pNew;
	pLoop.wsFlags = (uint)(0);
	pLoop.nSkip = (ushort)(0);
	pTerm = whereScanInit(scan, pWC, (int)(iCur), (int)(-1), (uint)(0x0002 | 0x0080), null);
	while (((pTerm) != null) && ((pTerm.prereqRight) != 0))
	{
		pTerm = whereScanNext(scan);
	}

	if ((pTerm) != null)
	{
		pLoop.wsFlags = (uint)(0x00000001 | 0x00000100 | 0x00001000);
		pLoop.aLTerm[0] = pTerm;
		pLoop.nLTerm = (ushort)(1);
		pLoop.u.btree.nEq = (ushort)(1);
		pLoop.rRun = (short)(33);
	}
	else
	{
		for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
		{
			int opMask = 0;
			if (((!((pIdx).onError != 0)) || (pIdx.pPartIdxWhere != null)) || ((pIdx.nKeyCol) > ((int)(3 * sizeof(WhereTerm) / sizeof(WhereTerm)))))
				continue;
			opMask = (int)((pIdx.uniqNotNull) != 0 ? (0x0002 | 0x0080) : 0x0002);
			for (j = (int)(0); (j) < (pIdx.nKeyCol); j++)
			{
				pTerm = whereScanInit(scan, pWC, (int)(iCur), (int)(j), (uint)(opMask), pIdx);
				while (((pTerm) != null) && ((pTerm.prereqRight) != 0))
				{
					pTerm = whereScanNext(scan);
				}

				if ((pTerm) == (null))
					break;
				pLoop.aLTerm[j] = pTerm;
			}

			if (j != pIdx.nKeyCol)
				continue;
			pLoop.wsFlags = (uint)(0x00000001 | 0x00001000 | 0x00000200);
			if (((pIdx.isCovering) != 0) || ((pItem.colUsed & pIdx.colNotIdxed) == (0)))
			{
				pLoop.wsFlags |= (uint)(0x00000040);
			}

			pLoop.nLTerm = (ushort)(j);
			pLoop.u.btree.nEq = (ushort)(j);
			pLoop.u.btree.pIndex = pIdx;
			pLoop.rRun = (short)(39);
			break;
		}
	}

	if ((pLoop.wsFlags) != 0)
	{
		pLoop.nOut = ((short)(1));
		pWInfo.a[0].pWLoop = pLoop;
		pLoop.maskSelf = (ulong)(1);
		pWInfo.a[0].iTabCur = (int)(iCur);
		pWInfo.nRowOut = (short)(1);
		if ((pWInfo.pOrderBy) != null)
			pWInfo.nOBSat = (sbyte)(pWInfo.pOrderBy.nExpr);
		if ((pWInfo.wctrlFlags & 0x0100) != 0)
		{
			pWInfo.eDistinct = (byte)(1);
		}

		if ((scan.iEquiv) > (1))
			pLoop.wsFlags |= (uint)(0x00200000);
		return (int)(1);
	}

	return (int)(0);
}}
}