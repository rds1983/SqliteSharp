// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int vdbeIncrMergerNew(SortSubtask pTask, MergeEngine pMerger, IncrMerger ppOut)
		{
			int rc = (int)(0);
			IncrMerger pIncr = ppOut = (IncrMerger)((sqlite3FaultSim((int)(100))) != 0 ? null : sqlite3MallocZero((ulong)(sizeof(IncrMerger))));
			if ((pIncr) != null)
			{
				pIncr.pMerger = pMerger;
				pIncr.pTask = pTask;
				pIncr.mxSz = (int)((pTask.pSorter.mxKeysize + 9) > (pTask.pSorter.mxPmaSize / 2) ? (pTask.pSorter.mxKeysize + 9) : (pTask.pSorter.mxPmaSize / 2));
				pTask.file2.iEof += (long)(pIncr.mxSz);
			}
			else
			{
				vdbeMergeEngineFree(pMerger);
				rc = (int)(7);
			}

			return (int)(rc);
		}
		public static int vdbeMergeEngineInit(SortSubtask pTask, MergeEngine pMerger, int eMode)
		{
			int rc = (int)(0);
			int i = 0;
			int nTree = 0;
			pMerger.pTask = pTask;
			nTree = (int)(pMerger.nTree);
			for (i = (int)(0); (i) < (nTree); i++)
			{
				if (((8) > (0)) && ((eMode) == (2)))
				{
					rc = (int)(vdbePmaReaderNext(pMerger.aReadr[nTree - i - 1]));
				}
				else
				{
					rc = (int)(vdbePmaReaderIncrInit(pMerger.aReadr[i], (int)(0)));
				}

				if (rc != 0)
					return (int)(rc);
			}

			for (i = (int)(pMerger.nTree - 1); (i) > (0); i--)
			{
				vdbeMergeEngineCompare(pMerger, (int)(i));
			}

			return (int)(pTask.pUnpacked.errCode);
		}
		public static int vdbeMergeEngineLevel0(SortSubtask pTask, int nPMA, long* piOffset, MergeEngine ppOut)
		{
			MergeEngine pNew;
			long iOff = (long)(*piOffset);
			int i = 0;
			int rc = (int)(0);
			ppOut = pNew = vdbeMergeEngineNew((int)(nPMA));
			if ((pNew) == (null))
				rc = (int)(7);
			for (i = (int)(0); ((i) < (nPMA)) && ((rc) == (0)); i++)
			{
				long nDummy = (long)(0);
				PmaReader pReadr = pNew.aReadr[i];
				rc = (int)(vdbePmaReaderInit(pTask, pTask.file, (long)(iOff), pReadr, &nDummy));
				iOff = (long)(pReadr.iEof);
			}

			if (rc != 0)
			{
				vdbeMergeEngineFree(pNew);
				ppOut = null;
			}

			*piOffset = (long)(iOff);
			return (int)(rc);
		}
		public static int vdbePmaReaderInit(SortSubtask pTask, SorterFile pFile, long iStart, PmaReader pReadr, long* pnByte)
		{
			int rc = 0;
			rc = (int)(vdbePmaReaderSeek(pTask, pReadr, pFile, (long)(iStart)));
			if ((rc) == (0))
			{
				ulong nByte = (ulong)(0);
				rc = (int)(vdbePmaReadVarint(pReadr, &nByte));
				pReadr.iEof = (long)(pReadr.iReadOff + nByte);
				*pnByte += (long)(nByte);
			}

			if ((rc) == (0))
			{
				rc = (int)(vdbePmaReaderNext(pReadr));
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderSeek(SortSubtask pTask, PmaReader pReadr, SorterFile pFile, long iOff)
		{
			int rc = (int)(0);
			if ((sqlite3FaultSim((int)(201))) != 0)
				return (int)(10 | (1 << 8));
			if ((pReadr.aMap) != null)
			{
				sqlite3OsUnfetch(pReadr.pFd, (long)(0), pReadr.aMap);
				pReadr.aMap = null;
			}

			pReadr.iReadOff = (long)(iOff);
			pReadr.iEof = (long)(pFile.iEof);
			pReadr.pFd = pFile.pFd;
			rc = (int)(vdbeSorterMapFile(pTask, pFile, &pReadr.aMap));
			if (((rc) == (0)) && ((pReadr.aMap) == (null)))
			{
				int pgsz = (int)(pTask.pSorter.pgsz);
				int iBuf = (int)(pReadr.iReadOff % pgsz);
				if ((pReadr.aBuffer) == (null))
				{
					pReadr.aBuffer = (byte*)(sqlite3Malloc((ulong)(pgsz)));
					if ((pReadr.aBuffer) == (null))
						rc = (int)(7);
					pReadr.nBuffer = (int)(pgsz);
				}

				if (((rc) == (0)) && ((iBuf) != 0))
				{
					int nRead = (int)(pgsz - iBuf);
					if ((pReadr.iReadOff + nRead) > (pReadr.iEof))
					{
						nRead = ((int)(pReadr.iEof - pReadr.iReadOff));
					}

					rc = (int)(sqlite3OsRead(pReadr.pFd, &pReadr.aBuffer[iBuf], (int)(nRead), (long)(pReadr.iReadOff)));
				}
			}

			return (int)(rc);
		}
		public static int vdbeSortAllocUnpacked(SortSubtask pTask)
		{
			if ((pTask.pUnpacked) == (null))
			{
				pTask.pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask.pSorter.pKeyInfo);
				if ((pTask.pUnpacked) == (null))
					return (int)(7);
				pTask.pUnpacked.nField = (ushort)(pTask.pSorter.pKeyInfo.nKeyField);
				pTask.pUnpacked.errCode = (byte)(0);
			}

			return (int)(0);
		}
		public static int vdbeSorterAddToTree(SortSubtask pTask, int nDepth, int iSeq, MergeEngine pRoot, MergeEngine pLeaf)
		{
			int rc = (int)(0);
			int nDiv = (int)(1);
			int i = 0;
			MergeEngine p = pRoot;
			IncrMerger pIncr;
			rc = (int)(vdbeIncrMergerNew(pTask, pLeaf, pIncr));
			for (i = (int)(1); (i) < (nDepth); i++)
			{
				nDiv = (int)(nDiv * 16);
			}

			for (i = (int)(1); ((i) < (nDepth)) && ((rc) == (0)); i++)
			{
				int iIter = (int)((iSeq / nDiv) % 16);
				PmaReader pReadr = p.aReadr[iIter];
				if ((pReadr.pIncr) == (null))
				{
					MergeEngine pNew = vdbeMergeEngineNew((int)(16));
					if ((pNew) == (null))
					{
						rc = (int)(7);
					}
					else
					{
						rc = (int)(vdbeIncrMergerNew(pTask, pNew, pReadr.pIncr));
					}
				}

				if ((rc) == (0))
				{
					p = pReadr.pIncr.pMerger;
					nDiv = (int)(nDiv / 16);
				}
			}

			if ((rc) == (0))
			{
				p.aReadr[iSeq % 16].pIncr = pIncr;
			}
			else
			{
				vdbeIncrFree(pIncr);
			}

			return (int)(rc);
		}
		public static int vdbeSorterCompare(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			UnpackedRecord r2 = pTask.pUnpacked;
			if (*pbKey2Cached == 0)
			{
				sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, (int)(nKey2), pKey2, r2);
				*pbKey2Cached = (int)(1);
			}

			return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, r2));
		}
		public static int vdbeSorterCompareInt(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			byte* p1 = (byte*)(pKey1);
			byte* p2 = (byte*)(pKey2);
			int s1 = (int)(p1[1]);
			int s2 = (int)(p2[1]);
			byte* v1 = &p1[p1[0]];
			byte* v2 = &p2[p2[0]];
			int res = 0;
			if ((s1) == (s2))
			{
				byte n = (byte)(vdbeSorterCompareInt_aLen[s1]);
				int i = 0;
				res = (int)(0);
				for (i = (int)(0); (i) < (n); i++)
				{
					if ((res = (int)(v1[i] - v2[i])) != 0)
					{
						if (((v1[0] ^ v2[0]) & 0x80) != 0)
						{
							res = (int)((v1[0] & 0x80) != 0 ? -1 : +1);
						}

						break;
					}
				}
			}
			else if (((s1) > (7)) && ((s2) > (7)))
			{
				res = (int)(s1 - s2);
			}
			else
			{
				if ((s2) > (7))
				{
					res = (int)(+1);
				}
				else if ((s1) > (7))
				{
					res = (int)(-1);
				}
				else
				{
					res = (int)(s1 - s2);
				}

				if ((res) > (0))
				{
					if ((*v1 & 0x80) != 0)
						res = (int)(-1);
				}
				else
				{
					if ((*v2 & 0x80) != 0)
						res = (int)(+1);
				}
			}

			if ((res) == (0))
			{
				if ((pTask.pSorter.pKeyInfo.nKeyField) > (1))
				{
					res = (int)(vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, (int)(nKey1), pKey2, (int)(nKey2)));
				}
			}
			else if ((pTask.pSorter.pKeyInfo.aSortFlags[0]) != 0)
			{
				res = (int)(res * -1);
			}

			return (int)(res);
		}
		public static int vdbeSorterCompareTail(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			UnpackedRecord r2 = pTask.pUnpacked;
			if ((*pbKey2Cached) == (0))
			{
				sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, (int)(nKey2), pKey2, r2);
				*pbKey2Cached = (int)(1);
			}

			return (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, r2, (int)(1)));
		}
		public static int vdbeSorterCompareText(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			byte* p1 = (byte*)(pKey1);
			byte* p2 = (byte*)(pKey2);
			byte* v1 = &p1[p1[0]];
			byte* v2 = &p2[p2[0]];
			int n1 = 0;
			int n2 = 0;
			int res = 0;
			n1 = (int)((uint)(*(&p1[1])));
			if ((n1) >= (0x80))
				sqlite3GetVarint32((&p1[1]), (uint*)(&(n1)));
			n2 = (int)((uint)(*(&p2[1])));
			if ((n2) >= (0x80))
				sqlite3GetVarint32((&p2[1]), (uint*)(&(n2)));
			res = (int)(memcmp(v1, v2, (ulong)((((n1) < (n2) ? (n1) : (n2)) - 13) / 2)));
			if ((res) == (0))
			{
				res = (int)(n1 - n2);
			}

			if ((res) == (0))
			{
				if ((pTask.pSorter.pKeyInfo.nKeyField) > (1))
				{
					res = (int)(vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, (int)(nKey1), pKey2, (int)(nKey2)));
				}
			}
			else
			{
				if ((pTask.pSorter.pKeyInfo.aSortFlags[0]) != 0)
				{
					res = (int)(res * -1);
				}
			}

			return (int)(res);
		}
		public static int vdbeSorterCreateThread(SortSubtask pTask, delegate75 xTask, void* pIn)
		{
			return (int)(sqlite3ThreadCreate(pTask.pThread, xTask, pIn));
		}
		public static int vdbeSorterJoinThread(SortSubtask pTask)
		{
			int rc = (int)(0);
			if ((pTask.pThread) != null)
			{
				void* pRet = ((void*)((long)(1)));
				(void)(sqlite3ThreadJoin(pTask.pThread, &pRet));
				rc = ((int)((long)(pRet)));
				pTask.bDone = (int)(0);
				pTask.pThread = null;
			}

			return (int)(rc);
		}
		public static int vdbeSorterListToPMA(SortSubtask pTask, SorterList* pList)
		{
			sqlite3 db = pTask.pSorter.db;
			int rc = (int)(0);
			PmaWriter writer = new PmaWriter();
			CRuntime.memset(writer, (int)(0), (ulong)(sizeof(PmaWriter)));
			if ((pTask.file.pFd) == (null))
			{
				rc = (int)(vdbeSorterOpenTempFile(db, (long)(0), pTask.file.pFd));
			}

			if ((rc) == (0))
			{
				vdbeSorterExtendFile(db, pTask.file.pFd, (long)(pTask.file.iEof + pList->szPMA + 9));
			}

			if ((rc) == (0))
			{
				rc = (int)(vdbeSorterSort(pTask, pList));
			}

			if ((rc) == (0))
			{
				SorterRecord* p;
				SorterRecord* pNext = null;
				vdbePmaWriterInit(pTask.file.pFd, writer, (int)(pTask.pSorter.pgsz), (long)(pTask.file.iEof));
				pTask.nPMA++;
				vdbePmaWriteVarint(writer, (ulong)(pList->szPMA));
				for (p = pList->pList; p; p = pNext)
				{
					pNext = p->u.pNext;
					vdbePmaWriteVarint(writer, (ulong)(p->nVal));
					vdbePmaWriteBlob(writer, ((void*)((p) + 1)), (int)(p->nVal));
					if ((pList->aMemory) == (null))
						sqlite3_free(p);
				}

				pList->pList = p;
				rc = (int)(vdbePmaWriterFinish(writer, &pTask.file.iEof));
			}

			return (int)(rc);
		}
		public static int vdbeSorterMapFile(SortSubtask pTask, SorterFile pFile, byte** pp)
		{
			int rc = (int)(0);
			if ((pFile.iEof) <= ((long)(pTask.pSorter.db.nMaxSorterMmap)))
			{
				sqlite3_file pFd = pFile.pFd;
				if ((pFd.pMethods.iVersion) >= (3))
				{
					rc = (int)(sqlite3OsFetch(pFd, (long)(0), (int)(pFile.iEof), (void**)(pp)));
				}
			}

			return (int)(rc);
		}
		public static int vdbeSorterSort(SortSubtask pTask, SorterList* pList)
		{
			int i = 0;
			SorterRecord* p;
			int rc = 0;
			SorterRecord** aSlot = stackalloc SorterRecord[64];
			rc = (int)(vdbeSortAllocUnpacked(pTask));
			if (rc != 0)
				return (int)(rc);
			p = pList->pList;
			pTask.xCompare = vdbeSorterGetCompare(pTask.pSorter);
			CRuntime.memset(aSlot, (int)(0), (ulong)(64 * sizeof(SorterRecord)));
			while ((p) != null)
			{
				SorterRecord* pNext;
				if ((pList->aMemory) != null)
				{
					if (((byte*)(p)) == (pList->aMemory))
					{
						pNext = null;
					}
					else
					{
						pNext = (SorterRecord*)(&pList->aMemory[p->u.iNext]);
					}
				}
				else
				{
					pNext = p->u.pNext;
				}

				p->u.pNext = null;
				for (i = (int)(0); aSlot[i]; i++)
				{
					p = vdbeSorterMerge(pTask, p, aSlot[i]);
					aSlot[i] = null;
				}

				aSlot[i] = p;
				p = pNext;
			}

			p = null;
			for (i = (int)(0); (i) < ((int)(64 * sizeof(SorterRecord) / sizeof(SorterRecord*))); i++)
			{
				if ((aSlot[i]) == (null))
					continue;
				p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
			}

			pList->pList = p;
			return (int)(pTask.pUnpacked.errCode);
		}
	}
}