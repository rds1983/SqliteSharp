// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void absFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			switch (sqlite3_value_type(argv[0]))
			{
				case 1:
					{
						long iVal = (long)(sqlite3_value_int64(argv[0]));
						if ((iVal) < (0))
						{
							if ((iVal) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
							{
								sqlite3_result_error(context, "integer overflow", (int)(-1));
								return;
							}

							iVal = (long)(-iVal);
						}

						sqlite3_result_int64(context, (long)(iVal));
						break;
					}

				case 5:
					{
						sqlite3_result_null(context);
						break;
					}

				default:
					{
						double rVal = (double)(sqlite3_value_double(argv[0]));
						if ((rVal) < (0))
							rVal = (double)(-rVal);
						sqlite3_result_double(context, (double)(rVal));
						break;
					}
			}
		}
		public static void attachFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			int i = 0;
			int rc = (int)(0);
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zName;
			sbyte* zFile;
			sbyte* zPath = null;
			sbyte* zErr = null;
			uint flags = 0;
			Db aNew;
			Db pNew;
			sbyte* zErrDyn = null;
			sqlite3_vfs pVfs;
			zFile = (sbyte*)(sqlite3_value_text(argv[0]));
			zName = (sbyte*)(sqlite3_value_text(argv[1]));
			if ((zFile) == (null))
				zFile = "";
			if ((zName) == (null))
				zName = "";
			if ((db.init.reopenMemdb) != 0)
			{
				pVfs = sqlite3_vfs_find("memdb");
				if ((pVfs) == (null))
					return;
				pNew = db.aDb[db.init.iDb];
				if ((pNew.pBt) != null)
					sqlite3BtreeClose(pNew.pBt);
				pNew.pBt = null;
				pNew.pSchema = null;
				rc = (int)(sqlite3BtreeOpen(pVfs, "x\000", db, pNew.pBt, (int)(0), (int)(0x00000100)));
			}
			else
			{
				if ((db.nDb) >= (db.aLimit[7] + 2))
				{
					zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", (int)(db.aLimit[7]));
					goto attach_error;
				}

				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((sqlite3DbIsNamed(db, (int)(i), zName)) != 0)
					{
						zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
						goto attach_error;
					}
				}

				if ((db.aDb) == (db.aDbStatic))
				{
					aNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Db) * 3));
					if ((aNew) == (null))
						return;
					CRuntime.memcpy(aNew, db.aDb, (ulong)(sizeof(Db) * 2));
				}
				else
				{
					aNew = sqlite3DbRealloc(db, db.aDb, (ulong)(sizeof(Db) * (db.nDb + 1)));
					if ((aNew) == (null))
						return;
				}

				db.aDb = aNew;
				pNew = db.aDb[db.nDb];
				CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(Db)));
				flags = (uint)(db.openFlags);
				rc = (int)(sqlite3ParseUri(db.pVfs.zName, zFile, &flags, pVfs, &zPath, &zErr));
				if (rc != 0)
				{
					if ((rc) == (7))
						sqlite3OomFault(db);
					sqlite3_result_error(context, zErr, (int)(-1));
					sqlite3_free(zErr);
					return;
				}

				flags |= (uint)(0x00000100);
				rc = (int)(sqlite3BtreeOpen(pVfs, zPath, db, pNew.pBt, (int)(0), (int)(flags)));
				db.nDb++;
				pNew.zDbSName = sqlite3DbStrDup(db, zName);
			}

			db.noSharedCache = (byte)(0);
			if ((rc) == (19))
			{
				rc = (int)(1);
				zErrDyn = sqlite3MPrintf(db, "database is already attached");
			}
			else if ((rc) == (0))
			{
				Pager pPager;
				pNew.pSchema = sqlite3SchemaGet(db, pNew.pBt);
				if (pNew.pSchema == null)
				{
					rc = (int)(7);
				}
				else if (((pNew.pSchema.file_format) != 0) && (pNew.pSchema.enc != ((db).enc)))
				{
					zErrDyn = sqlite3MPrintf(db, "attached databases must use the same text encoding as main database");
					rc = (int)(1);
				}

				sqlite3BtreeEnter(pNew.pBt);
				pPager = sqlite3BtreePager(pNew.pBt);
				sqlite3PagerLockingMode(pPager, (int)(db.dfltLockMode));
				sqlite3BtreeSecureDelete(pNew.pBt, (int)(sqlite3BtreeSecureDelete(db.aDb[0].pBt, (int)(-1))));
				sqlite3BtreeSetPagerFlags(pNew.pBt, (uint)(0x03 | (db.flags & 0x38)));
				sqlite3BtreeLeave(pNew.pBt);
			}

			pNew.safety_level = (byte)(2 + 1);
			if (((rc) == (0)) && ((pNew.zDbSName) == (null)))
			{
				rc = (int)(7);
			}

			sqlite3_free_filename(zPath);
			if ((rc) == (0))
			{
				sqlite3BtreeEnterAll(db);
				db.init.iDb = (byte)(0);
				db.mDbFlags &= (uint)(~(0x0010));
				if ((db.init.reopenMemdb) == 0)
				{
					rc = (int)(sqlite3Init(db, &zErrDyn));
				}

				sqlite3BtreeLeaveAll(db);
			}

			if ((rc) != 0)
			{
				if ((db.init.reopenMemdb) == 0)
				{
					int iDb = (int)(db.nDb - 1);
					if ((db.aDb[iDb].pBt) != null)
					{
						sqlite3BtreeClose(db.aDb[iDb].pBt);
						db.aDb[iDb].pBt = null;
						db.aDb[iDb].pSchema = null;
					}

					sqlite3ResetAllSchemasOfConnection(db);
					db.nDb = (int)(iDb);
					if (((rc) == (7)) || ((rc) == (10 | (12 << 8))))
					{
						sqlite3OomFault(db);
						sqlite3DbFree(db, zErrDyn);
						zErrDyn = sqlite3MPrintf(db, "out of memory");
					}
					else if ((zErrDyn) == (null))
					{
						zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
					}
				}

				goto attach_error;
			}

			return;
		attach_error:
			; if ((zErrDyn) != null) { sqlite3_result_error(context, zErrDyn, (int)(-1)); sqlite3DbFree(db, zErrDyn); }
			if ((rc) != 0)
				sqlite3_result_error_code(context, (int)(rc));
		}
		public static void avgFinalize(sqlite3_context context)
		{
			SumCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			if (((p) != null) && ((p->cnt) > (0)))
			{
				sqlite3_result_double(context, (double)(p->rSum / (double)(p->cnt)));
			}
		}
		public static void cdateFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			dateFunc(context, (int)(0), null);
		}
		public static void changes(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sqlite3_result_int64(context, (long)(sqlite3_changes64(db)));
		}
		public static void charFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* z; byte* zOut;
			int i = 0;
			zOut = z = sqlite3_malloc64((ulong)(argc * 4 + 1));
			if ((z) == (null))
			{
				sqlite3_result_error_nomem(context);
				return;
			}

			for (i = (int)(0); (i) < (argc); i++)
			{
				long x = 0;
				uint c = 0;
				x = (long)(sqlite3_value_int64(argv[i]));
				if (((x) < (0)) || ((x) > (0x10ffff)))
					x = (long)(0xfffd);
				c = ((uint)(x & 0x1fffff));
				if ((c) < (0x00080))
				{
					*zOut++ = ((byte)(c & 0xFF));
				}
				else if ((c) < (0x00800))
				{
					*zOut++ = (byte)(0xC0 + (byte)((c >> 6) & 0x1F));
					*zOut++ = (byte)(0x80 + (byte)(c & 0x3F));
				}
				else if ((c) < (0x10000))
				{
					*zOut++ = (byte)(0xE0 + (byte)((c >> 12) & 0x0F));
					*zOut++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
					*zOut++ = (byte)(0x80 + (byte)(c & 0x3F));
				}
				else
				{
					*zOut++ = (byte)(0xF0 + (byte)((c >> 18) & 0x07));
					*zOut++ = (byte)(0x80 + (byte)((c >> 12) & 0x3F));
					*zOut++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
					*zOut++ = (byte)(0x80 + (byte)(c & 0x3F));
				}
			}

			sqlite3_result_text64(context, (sbyte*)(z), (ulong)(zOut - z), sqlite3_free, (byte)(1));
		}
		public static void compileoptiongetFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int n = 0;
			n = (int)(sqlite3_value_int(argv[0]));
			sqlite3_result_text(context, sqlite3_compileoption_get((int)(n)), (int)(-1), null);
		}
		public static void compileoptionusedFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* zOptName;
			if ((zOptName = (sbyte*)(sqlite3_value_text(argv[0]))) != null)
			{
				sqlite3_result_int(context, (int)(sqlite3_compileoption_used(zOptName)));
			}
		}
		public static void countFinalize(sqlite3_context context)
		{
			CountCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			sqlite3_result_int64(context, (long)(p ? p->n : 0));
		}
		public static void countInverse(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			CountCtx* p;
			p = sqlite3_aggregate_context(ctx, (int)(sizeof(CountCtx)));
			if ((((argc) == (0)) || (5 != sqlite3_value_type(argv[0]))) && ((p) != null))
			{
				p->n--;
			}
		}
		public static void countStep(sqlite3_context context, int argc, sqlite3_value argv)
		{
			CountCtx* p;
			p = sqlite3_aggregate_context(context, (int)(sizeof(CountCtx)));
			if ((((argc) == (0)) || (5 != sqlite3_value_type(argv[0]))) && ((p) != null))
			{
				p->n++;
			}
		}
		public static void ctimeFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			timeFunc(context, (int)(0), null);
		}
		public static void ctimestampFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			datetimeFunc(context, (int)(0), null);
		}
		public static void cume_distInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			p->nStep++;
		}
		public static void cume_distStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nTotal++;
			}
		}
		public static void cume_distValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(0)));
			if ((p) != null)
			{
				double r = (double)((double)(p->nStep) / (double)(p->nTotal));
				sqlite3_result_double(pCtx, (double)(r));
			}
		}
		public static void dateFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				int Y = 0;
				sbyte* zBuf = stackalloc sbyte[16];
				computeYMD(&x);
				Y = (int)(x.Y);
				if ((Y) < (0))
					Y = (int)(-Y);
				zBuf[1] = (sbyte)(48 + (Y / 1000) % 10);
				zBuf[2] = (sbyte)(48 + (Y / 100) % 10);
				zBuf[3] = (sbyte)(48 + (Y / 10) % 10);
				zBuf[4] = (sbyte)(48 + (Y) % 10);
				zBuf[5] = (sbyte)(45);
				zBuf[6] = (sbyte)(48 + (x.M / 10) % 10);
				zBuf[7] = (sbyte)(48 + (x.M) % 10);
				zBuf[8] = (sbyte)(45);
				zBuf[9] = (sbyte)(48 + (x.D / 10) % 10);
				zBuf[10] = (sbyte)(48 + (x.D) % 10);
				zBuf[11] = (sbyte)(0);
				if ((x.Y) < (0))
				{
					zBuf[0] = (sbyte)(45);
					sqlite3_result_text(context, zBuf, (int)(11), ((Void(Void * ))(-1)));
				}
				else
				{
					sqlite3_result_text(context, &zBuf[1], (int)(10), ((Void(Void * ))(-1)));
				}
			}
		}
		public static void datetimeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				int Y = 0;
				int s = 0;
				sbyte* zBuf = stackalloc sbyte[24];
				computeYMD_HMS(&x);
				Y = (int)(x.Y);
				if ((Y) < (0))
					Y = (int)(-Y);
				zBuf[1] = (sbyte)(48 + (Y / 1000) % 10);
				zBuf[2] = (sbyte)(48 + (Y / 100) % 10);
				zBuf[3] = (sbyte)(48 + (Y / 10) % 10);
				zBuf[4] = (sbyte)(48 + (Y) % 10);
				zBuf[5] = (sbyte)(45);
				zBuf[6] = (sbyte)(48 + (x.M / 10) % 10);
				zBuf[7] = (sbyte)(48 + (x.M) % 10);
				zBuf[8] = (sbyte)(45);
				zBuf[9] = (sbyte)(48 + (x.D / 10) % 10);
				zBuf[10] = (sbyte)(48 + (x.D) % 10);
				zBuf[11] = (sbyte)(32);
				zBuf[12] = (sbyte)(48 + (x.h / 10) % 10);
				zBuf[13] = (sbyte)(48 + (x.h) % 10);
				zBuf[14] = (sbyte)(58);
				zBuf[15] = (sbyte)(48 + (x.m / 10) % 10);
				zBuf[16] = (sbyte)(48 + (x.m) % 10);
				zBuf[17] = (sbyte)(58);
				s = ((int)(x.s));
				zBuf[18] = (sbyte)(48 + (s / 10) % 10);
				zBuf[19] = (sbyte)(48 + (s) % 10);
				zBuf[20] = (sbyte)(0);
				if ((x.Y) < (0))
				{
					zBuf[0] = (sbyte)(45);
					sqlite3_result_text(context, zBuf, (int)(20), ((Void(Void * ))(-1)));
				}
				else
				{
					sqlite3_result_text(context, &zBuf[1], (int)(19), ((Void(Void * ))(-1)));
				}
			}
		}
		public static void dense_rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
				p->nStep = (long)(1);
		}
		public static void dense_rankValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				if ((p->nStep) != 0)
				{
					p->nValue++;
					p->nStep = (long)(0);
				}

				sqlite3_result_int64(pCtx, (long)(p->nValue));
			}
		}
		public static void detachFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sbyte* zName = (sbyte*)(sqlite3_value_text(argv[0]));
			sqlite3 db = sqlite3_context_db_handle(context);
			int i = 0;
			Db pDb = null;
			HashElem* pEntry;
			sbyte* zErr = stackalloc sbyte[128];
			if ((zName) == (null))
				zName = "";
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				pDb = db.aDb[i];
				if ((pDb.pBt) == (null))
					continue;
				if ((sqlite3DbIsNamed(db, (int)(i), zName)) != 0)
					break;
			}

			if ((i) >= (db.nDb))
			{
				sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "no such database: %s", zName);
				goto detach_error;
			}

			if ((i) < (2))
			{
				sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "cannot detach database %s", zName);
				goto detach_error;
			}

			if ((sqlite3BtreeTxnState(pDb.pBt) != 0) || ((sqlite3BtreeIsInBackup(pDb.pBt)) != 0))
			{
				sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "database %s is locked", zName);
				goto detach_error;
			}

			pEntry = ((&db.aDb[1].pSchema.trigHash)->first);
			while ((pEntry) != null)
			{
				Trigger pTrig = (Trigger)((pEntry)->data);
				if ((pTrig.pTabSchema) == (pDb.pSchema))
				{
					pTrig.pTabSchema = pTrig.pSchema;
				}

				pEntry = ((pEntry)->next);
			}

			sqlite3BtreeClose(pDb.pBt);
			pDb.pBt = null;
			pDb.pSchema = null;
			sqlite3CollapseDatabaseArray(db);
			return;
		detach_error:
			; sqlite3_result_error(context, zErr, (int)(-1));
		}
		public static void dropColumnFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			int iSchema = (int)(sqlite3_value_int(argv[0]));
			sbyte* zSql = (sbyte*)(sqlite3_value_text(argv[1]));
			int iCol = (int)(sqlite3_value_int(argv[2]));
			sbyte* zDb = db.aDb[iSchema].zDbSName;
			int rc = 0;
			Parse sParse = new Parse();
			RenameToken* pCol;
			Table pTab;
			sbyte* zEnd;
			sbyte* zNew = null;
			delegate67 xAuth = db.xAuth;
			db.xAuth = null;
			rc = (int)(renameParseSql(sParse, zDb, db, zSql, ((iSchema) == (1) ? 1 : 0)));
			if (rc != 0)
				goto drop_column_done;
			pTab = sParse.pNewTable;
			if ((((pTab) == (null)) || ((pTab.nCol) == (1))) || ((iCol) >= (pTab.nCol)))
			{
				rc = (int)(sqlite3CorruptError((int)(110906)));
				goto drop_column_done;
			}

			pCol = renameTokenFind(sParse, null, (void*)(pTab.aCol[iCol].zCnName));
			if ((iCol) < (pTab.nCol - 1))
			{
				RenameToken* pEnd;
				pEnd = renameTokenFind(sParse, null, (void*)(pTab.aCol[iCol + 1].zCnName));
				zEnd = pEnd->t.z;
			}
			else
			{
				zEnd = &zSql[pTab.u.tab.addColOffset];
				while ((pCol->t.z[0] != 0) && (pCol->t.z[0] != 44))
				{
					pCol->t.z--;
				}
			}

			zNew = sqlite3MPrintf(db, "%.*s%s", (long)(pCol->t.z - zSql), zSql, zEnd);
			sqlite3_result_text(context, zNew, (int)(-1), ((Void(Void * ))(-1)));
			sqlite3_free(zNew);
		drop_column_done:
			; renameParseCleanup(sParse);
			db.xAuth = xAuth;
			if (rc != 0)
			{
				sqlite3_result_error_code(context, (int)(rc));
			}
		}
		public static void errlogFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sqlite3_log((int)(sqlite3_value_int(argv[0])), "%s", sqlite3_value_text(argv[1]));
		}
		public static void first_valueFinalizeFunc(sqlite3_context pCtx)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
			if (((p) != null) && ((p.pValue) != null))
			{
				sqlite3_result_value(pCtx, p.pValue);
				sqlite3_value_free(p.pValue);
				p.pValue = null;
			}
		}
		public static void first_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
			if (((p) != null) && ((p.pValue) == (null)))
			{
				p.pValue = sqlite3_value_dup(apArg[0]);
				if (p.pValue == null)
				{
					sqlite3_result_error_nomem(pCtx);
				}
			}
		}
		public static void groupConcatFinalize(sqlite3_context context)
		{
			GroupConcatCtx pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(0)));
			if ((pGCC) != null)
			{
				sqlite3ResultStrAccum(context, pGCC.str);
				sqlite3_free(pGCC.pnSepLengths);
			}
		}
		public static void groupConcatInverse(sqlite3_context context, int argc, sqlite3_value argv)
		{
			GroupConcatCtx pGCC;
			(void)(argc);
			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(sizeof(GroupConcatCtx))));
			if ((pGCC) != null)
			{
				int nVS = 0;
				(void)(sqlite3_value_text(argv[0]));
				nVS = (int)(sqlite3_value_bytes(argv[0]));
				pGCC.nAccum -= (int)(1);
				if (pGCC.pnSepLengths != null)
				{
					if ((pGCC.nAccum) > (0))
					{
						nVS += (int)(*pGCC.pnSepLengths);
						CRuntime.memmove(pGCC.pnSepLengths, pGCC.pnSepLengths + 1, (ulong)((pGCC.nAccum - 1) * sizeof(int)));
					}
				}
				else
				{
					nVS += (int)(pGCC.nFirstSepLength);
				}

				if ((nVS) >= ((int)(pGCC.str.nChar)))
				{
					pGCC.str.nChar = (uint)(0);
				}
				else
				{
					pGCC.str.nChar -= (uint)(nVS);
					CRuntime.memmove(pGCC.str.zText, &pGCC.str.zText[nVS], (ulong)(pGCC.str.nChar));
				}

				if ((pGCC.str.nChar) == (0))
				{
					pGCC.str.mxAlloc = (uint)(0);
					sqlite3_free(pGCC.pnSepLengths);
					pGCC.pnSepLengths = null;
				}
			}
		}
		public static void groupConcatStep(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* zVal;
			GroupConcatCtx pGCC;
			sbyte* zSep;
			int nVal = 0; int nSep = 0;
			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(sizeof(GroupConcatCtx))));
			if ((pGCC) != null)
			{
				sqlite3 db = sqlite3_context_db_handle(context);
				int firstTerm = (int)((pGCC.str.mxAlloc) == (0) ? 1 : 0);
				pGCC.str.mxAlloc = (uint)(db.aLimit[0]);
				if ((argc) == (1))
				{
					if (firstTerm == 0)
					{
						sqlite3_str_appendchar(pGCC.str, (int)(1), (sbyte)(44));
					}
					else
					{
						pGCC.nFirstSepLength = (int)(1);
					}
				}
				else if (firstTerm == 0)
				{
					zSep = (sbyte*)(sqlite3_value_text(argv[1]));
					nSep = (int)(sqlite3_value_bytes(argv[1]));
					if ((zSep) != null)
					{
						sqlite3_str_append(pGCC.str, zSep, (int)(nSep));
					}
					else
					{
						nSep = (int)(0);
					}

					if ((nSep != pGCC.nFirstSepLength) || (pGCC.pnSepLengths != null))
					{
						int* pnsl = pGCC.pnSepLengths;
						if ((pnsl) == (null))
						{
							pnsl = (int*)(sqlite3_malloc64((ulong)((pGCC.nAccum + 1) * sizeof(int))));
							if (pnsl != null)
							{
								int i = (int)(0);
								int nA = (int)(pGCC.nAccum - 1);
								while ((i) < (nA))
								{
									pnsl[i++] = (int)(pGCC.nFirstSepLength);
								}
							}
						}
						else
						{
							pnsl = (int*)(sqlite3_realloc64(pnsl, (ulong)(pGCC.nAccum * sizeof(int))));
						}

						if (pnsl != null)
						{
							if (((pGCC.nAccum) > (0)))
							{
								pnsl[pGCC.nAccum - 1] = (int)(nSep);
							}

							pGCC.pnSepLengths = pnsl;
						}
						else
						{
							sqlite3StrAccumSetError(pGCC.str, (byte)(7));
						}
					}
				}
				else
				{
					pGCC.nFirstSepLength = (int)(sqlite3_value_bytes(argv[1]));
				}

				pGCC.nAccum += (int)(1);
				zVal = (sbyte*)(sqlite3_value_text(argv[0]));
				nVal = (int)(sqlite3_value_bytes(argv[0]));
				if ((zVal) != null)
					sqlite3_str_append(pGCC.str, zVal, (int)(nVal));
			}
		}
		public static void groupConcatValue(sqlite3_context context)
		{
			GroupConcatCtx pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(0)));
			if ((pGCC) != null)
			{
				sqlite3_str pAccum = pGCC.str;
				if ((pAccum.accError) == (18))
				{
					sqlite3_result_error_toobig(context);
				}
				else if ((pAccum.accError) == (7))
				{
					sqlite3_result_error_nomem(context);
				}
				else
				{
					sbyte* zText = sqlite3_str_value(pAccum);
					sqlite3_result_text(context, zText, (int)(pAccum.nChar), ((Void(Void * ))(-1)));
				}
			}
		}
		public static void hexFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int i = 0; int n = 0;
			byte* pBlob;
			sbyte* zHex; sbyte* z;
			pBlob = sqlite3_value_blob(argv[0]);
			n = (int)(sqlite3_value_bytes(argv[0]));
			z = zHex = contextMalloc(context, (long)(((long)(n)) * 2 + 1));
			if ((zHex) != null)
			{
				for (i = (int)(0); (i) < (n); i++, pBlob++)
				{
					byte c = (byte)(*pBlob);
					*(z++) = (sbyte)(hexdigits[(c >> 4) & 0xf]);
					*(z++) = (sbyte)(hexdigits[c & 0xf]);
				}

				*z = (sbyte)(0);
				sqlite3_result_text(context, zHex, (int)(n * 2), sqlite3_free);
			}
		}
		public static void instrFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zHaystack;
			byte* zNeedle;
			int nHaystack = 0;
			int nNeedle = 0;
			int typeHaystack = 0; int typeNeedle = 0;
			int N = (int)(1);
			int isText = 0;
			byte firstChar = 0;
			sqlite3_value pC1 = null;
			sqlite3_value pC2 = null;
			typeHaystack = (int)(sqlite3_value_type(argv[0]));
			typeNeedle = (int)(sqlite3_value_type(argv[1]));
			if (((typeHaystack) == (5)) || ((typeNeedle) == (5)))
				return;
			nHaystack = (int)(sqlite3_value_bytes(argv[0]));
			nNeedle = (int)(sqlite3_value_bytes(argv[1]));
			if ((nNeedle) > (0))
			{
				if (((typeHaystack) == (4)) && ((typeNeedle) == (4)))
				{
					zHaystack = sqlite3_value_blob(argv[0]);
					zNeedle = sqlite3_value_blob(argv[1]);
					isText = (int)(0);
				}
				else if ((typeHaystack != 4) && (typeNeedle != 4))
				{
					zHaystack = sqlite3_value_text(argv[0]);
					zNeedle = sqlite3_value_text(argv[1]);
					isText = (int)(1);
				}
				else
				{
					pC1 = sqlite3_value_dup(argv[0]);
					zHaystack = sqlite3_value_text(pC1);
					if ((zHaystack) == (null))
						goto endInstrOOM;
					nHaystack = (int)(sqlite3_value_bytes(pC1));
					pC2 = sqlite3_value_dup(argv[1]);
					zNeedle = sqlite3_value_text(pC2);
					if ((zNeedle) == (null))
						goto endInstrOOM;
					nNeedle = (int)(sqlite3_value_bytes(pC2));
					isText = (int)(1);
				}

				if (((zNeedle) == (null)) || (((nHaystack) != 0) && ((zHaystack) == (null))))
					goto endInstrOOM;
				firstChar = (byte)(zNeedle[0]);
				while (((nNeedle) <= (nHaystack)) && ((zHaystack[0] != firstChar) || (memcmp(zHaystack, zNeedle, (ulong)(nNeedle)) != 0)))
				{
					N++;
					do
					{
						nHaystack--;
						zHaystack++;
					}
					while (((isText) != 0) && ((zHaystack[0] & 0xc0) == (0x80)));
				}

				if ((nNeedle) > (nHaystack))
					N = (int)(0);
			}

			sqlite3_result_int(context, (int)(N));
		endInstr:
			; sqlite3_value_free(pC1);
			sqlite3_value_free(pC2);
			return;
		endInstrOOM:
			; sqlite3_result_error_nomem(context);
			goto endInstr;
		}
		public static int isDate(sqlite3_context context, int argc, sqlite3_value argv, DateTime* p)
		{
			int i = 0; int n = 0;
			byte* z;
			int eType = 0;
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
			if ((argc) == (0))
			{
				if (sqlite3NotPureFunc(context) == 0)
					return (int)(1);
				return (int)(setDateTimeToCurrent(context, p));
			}

			if (((eType = (int)(sqlite3_value_type(argv[0]))) == (2)) || ((eType) == (1)))
			{
				setRawDateNumber(p, (double)(sqlite3_value_double(argv[0])));
			}
			else
			{
				z = sqlite3_value_text(argv[0]);
				if ((z == null) || ((parseDateOrTime(context, (sbyte*)(z), p)) != 0))
				{
					return (int)(1);
				}
			}

			for (i = (int)(1); (i) < (argc); i++)
			{
				z = sqlite3_value_text(argv[i]);
				n = (int)(sqlite3_value_bytes(argv[i]));
				if (((z) == (null)) || ((parseModifier(context, (sbyte*)(z), (int)(n), p, (int)(i))) != 0))
					return (int)(1);
			}

			computeJD(p);
			if (((p->isError) != 0) || (validJulianDay((long)(p->iJD)) == 0))
				return (int)(1);
			return (int)(0);
		}
		public static void jsonArrayCompute(sqlite3_context ctx, int isFinal)
		{
			JsonString pStr;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
			if ((pStr) != null)
			{
				pStr.pCtx = ctx;
				jsonAppendChar(pStr, (sbyte)(93));
				if ((pStr.bErr) != 0)
				{
					if ((pStr.bErr) == (1))
						sqlite3_result_error_nomem(ctx);
				}
				else if ((isFinal) != 0)
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), (pStr.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free);
					pStr.bStatic = (byte)(1);
				}
				else
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), ((Void(Void * ))(-1)));
					pStr.nUsed--;
				}
			}
			else
			{
				sqlite3_result_text(ctx, "[]", (int)(2), null);
			}

			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonArrayFinal(sqlite3_context ctx)
		{
			jsonArrayCompute(ctx, (int)(1));
		}
		public static void jsonArrayFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			int i = 0;
			JsonString jx = new JsonString();
			jsonInit(jx, ctx);
			jsonAppendChar(jx, (sbyte)(91));
			for (i = (int)(0); (i) < (argc); i++)
			{
				jsonAppendSeparator(jx);
				jsonAppendValue(jx, argv[i]);
			}

			jsonAppendChar(jx, (sbyte)(93));
			jsonResult(jx);
			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonArrayLengthFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			long n = (long)(0);
			uint i = 0;
			JsonNode* pNode;
			p = jsonParseCached(ctx, argv, ctx);
			if ((p) == (null))
				return;
			if ((argc) == (2))
			{
				sbyte* zPath = (sbyte*)(sqlite3_value_text(argv[1]));
				pNode = jsonLookup(p, zPath, null, ctx);
			}
			else
			{
				pNode = p->aNode;
			}

			if ((pNode) == (null))
			{
				return;
			}

			if ((pNode->eType) == (6))
			{
				for (i = (uint)(1); (i) <= (pNode->n); n++)
				{
					i += (uint)(jsonNodeSize(&pNode[i]));
				}
			}

			sqlite3_result_int64(ctx, (long)(n));
		}
		public static void jsonArrayStep(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonString pStr;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(sizeof(JsonString))));
			if ((pStr) != null)
			{
				if ((pStr.zBuf) == (null))
				{
					jsonInit(pStr, ctx);
					jsonAppendChar(pStr, (sbyte)(91));
				}
				else if ((pStr.nUsed) > (1))
				{
					jsonAppendChar(pStr, (sbyte)(44));
				}

				pStr.pCtx = ctx;
				jsonAppendValue(pStr, argv[0]);
			}
		}
		public static void jsonArrayValue(sqlite3_context ctx)
		{
			jsonArrayCompute(ctx, (int)(0));
		}
		public static void jsonExtractFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			JsonNode* pNode;
			sbyte* zPath;
			int flags = ((int)((long)(sqlite3_user_data(ctx))));
			JsonString jx = new JsonString();
			if ((argc) < (2))
				return;
			p = jsonParseCached(ctx, argv, ctx);
			if ((p) == (null))
				return;
			if ((argc) == (2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[1]));
				if ((zPath) == (null))
					return;
				if ((flags & 0x03) != 0)
				{
					if (zPath[0] != 36)
					{
						jsonInit(jx, ctx);
						if ((sqlite3CtypeMap[(byte)(zPath[0])] & 0x04) != 0)
						{
							jsonAppendRaw(jx, "$[", (uint)(2));
							jsonAppendRaw(jx, zPath, (uint)((int)(CRuntime.strlen(zPath))));
							jsonAppendRaw(jx, "]", (uint)(2));
						}
						else
						{
							jsonAppendRaw(jx, "$.", (uint)(1 + (zPath[0] != 91)));
							jsonAppendRaw(jx, zPath, (uint)((int)(CRuntime.strlen(zPath))));
							jsonAppendChar(jx, (sbyte)(0));
						}

						pNode = (jx.bErr) != 0 ? null : jsonLookup(p, jx.zBuf, null, ctx);
						jsonReset(jx);
					}
					else
					{
						pNode = jsonLookup(p, zPath, null, ctx);
					}

					if ((pNode) != null)
					{
						if ((flags & 0x01) != 0)
						{
							jsonReturnJson(pNode, ctx, null);
						}
						else
						{
							jsonReturn(pNode, ctx, null);
							sqlite3_result_subtype(ctx, (uint)(0));
						}
					}
				}
				else
				{
					pNode = jsonLookup(p, zPath, null, ctx);
					if (((p->nErr) == (0)) && ((pNode) != null))
						jsonReturn(pNode, ctx, null);
				}
			}
			else
			{
				int i = 0;
				jsonInit(jx, ctx);
				jsonAppendChar(jx, (sbyte)(91));
				for (i = (int)(1); (i) < (argc); i++)
				{
					zPath = (sbyte*)(sqlite3_value_text(argv[i]));
					pNode = jsonLookup(p, zPath, null, ctx);
					if ((p->nErr) != 0)
						break;
					jsonAppendSeparator(jx);
					if ((pNode) != null)
					{
						jsonRenderNode(pNode, jx, null);
					}
					else
					{
						jsonAppendRaw(jx, "null", (uint)(4));
					}
				}

				if ((i) == (argc))
				{
					jsonAppendChar(jx, (sbyte)(93));
					jsonResult(jx);
					sqlite3_result_subtype(ctx, (uint)(74));
				}

				jsonReset(jx);
			}
		}
		public static void jsonGroupInverse(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			uint i = 0;
			int inStr = (int)(0);
			int nNest = (int)(0);
			sbyte* z;
			sbyte c = 0;
			JsonString pStr;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
			if ((!pStr) != 0)
				return;
			z = pStr.zBuf;
			for (i = (uint)(1); ((i) < (pStr.nUsed)) && ((((c = (sbyte)(z[i])) != 44) || ((inStr) != 0)) || ((nNest) != 0)); i++)
			{
				if ((c) == (34))
				{
					inStr = (int)(!inStr);
				}
				else if ((c) == (92))
				{
					i++;
				}
				else if (inStr == 0)
				{
					if (((c) == (123)) || ((c) == (91)))
						nNest++;
					if (((c) == (125)) || ((c) == (93)))
						nNest--;
				}
			}

			if ((i) < (pStr.nUsed))
			{
				pStr.nUsed -= (ulong)(i);
				CRuntime.memmove(&z[1], &z[i + 1], (ulong)(pStr.nUsed - 1));
				z[pStr.nUsed] = (sbyte)(0);
			}
			else
			{
				pStr.nUsed = (ulong)(1);
			}
		}
		public static void jsonObjectCompute(sqlite3_context ctx, int isFinal)
		{
			JsonString pStr;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
			if ((pStr) != null)
			{
				jsonAppendChar(pStr, (sbyte)(125));
				if ((pStr.bErr) != 0)
				{
					if ((pStr.bErr) == (1))
						sqlite3_result_error_nomem(ctx);
				}
				else if ((isFinal) != 0)
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), (pStr.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free);
					pStr.bStatic = (byte)(1);
				}
				else
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), ((Void(Void * ))(-1)));
					pStr.nUsed--;
				}
			}
			else
			{
				sqlite3_result_text(ctx, "{}", (int)(2), null);
			}

			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonObjectFinal(sqlite3_context ctx)
		{
			jsonObjectCompute(ctx, (int)(1));
		}
		public static void jsonObjectFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			int i = 0;
			JsonString jx = new JsonString();
			sbyte* z;
			uint n = 0;
			if ((argc & 1) != 0)
			{
				sqlite3_result_error(ctx, "json_object() requires an even number of arguments", (int)(-1));
				return;
			}

			jsonInit(jx, ctx);
			jsonAppendChar(jx, (sbyte)(123));
			for (i = (int)(0); (i) < (argc); i += (int)(2))
			{
				if (sqlite3_value_type(argv[i]) != 3)
				{
					sqlite3_result_error(ctx, "json_object() labels must be TEXT", (int)(-1));
					jsonReset(jx);
					return;
				}

				jsonAppendSeparator(jx);
				z = (sbyte*)(sqlite3_value_text(argv[i]));
				n = ((uint)(sqlite3_value_bytes(argv[i])));
				jsonAppendString(jx, z, (uint)(n));
				jsonAppendChar(jx, (sbyte)(58));
				jsonAppendValue(jx, argv[i + 1]);
			}

			jsonAppendChar(jx, (sbyte)(125));
			jsonResult(jx);
			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonObjectStep(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonString pStr;
			sbyte* z;
			uint n = 0;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(sizeof(JsonString))));
			if ((pStr) != null)
			{
				if ((pStr.zBuf) == (null))
				{
					jsonInit(pStr, ctx);
					jsonAppendChar(pStr, (sbyte)(123));
				}
				else if ((pStr.nUsed) > (1))
				{
					jsonAppendChar(pStr, (sbyte)(44));
				}

				pStr.pCtx = ctx;
				z = (sbyte*)(sqlite3_value_text(argv[0]));
				n = ((uint)(sqlite3_value_bytes(argv[0])));
				jsonAppendString(pStr, z, (uint)(n));
				jsonAppendChar(pStr, (sbyte)(58));
				jsonAppendValue(pStr, argv[1]);
			}
		}
		public static void jsonObjectValue(sqlite3_context ctx)
		{
			jsonObjectCompute(ctx, (int)(0));
		}
		public static void jsonPatchFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonParse y = new JsonParse();
			JsonNode* pResult;
			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;
			if ((jsonParse(&y, ctx, (sbyte*)(sqlite3_value_text(argv[1])))) != 0)
			{
				jsonParseReset(&x);
				return;
			}

			pResult = jsonMergePatch(&x, (uint)(0), y.aNode);
			if ((pResult) != null)
			{
				jsonReturnJson(pResult, ctx, null);
			}
			else
			{
				sqlite3_result_error_nomem(ctx);
			}

			jsonParseReset(&x);
			jsonParseReset(&y);
		}
		public static void jsonQuoteFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonString jx = new JsonString();
			jsonInit(jx, ctx);
			jsonAppendValue(jx, argv[0]);
			jsonResult(jx);
			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonRemoveFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonNode* pNode;
			sbyte* zPath;
			uint i = 0;
			if ((argc) < (1))
				return;
			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;
			for (i = (uint)(1); (i) < ((uint)(argc)); i++)
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[i]));
				if ((zPath) == (null))
					goto remove_done;
				pNode = jsonLookup(&x, zPath, null, ctx);
				if ((x.nErr) != 0)
					goto remove_done;
				if ((pNode) != null)
					pNode->jnFlags |= (byte)(0x04);
			}

			if ((x.aNode[0].jnFlags & 0x04) == (0))
			{
				jsonReturnJson(x.aNode, ctx, null);
			}

		remove_done:
			; jsonParseReset(&x);
		}
		public static void jsonReplaceFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonNode* pNode;
			sbyte* zPath;
			uint i = 0;
			if ((argc) < (1))
				return;
			if ((argc & 1) == (0))
			{
				jsonWrongNumArgs(ctx, "replace");
				return;
			}

			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;
			for (i = (uint)(1); (i) < ((uint)(argc)); i += (uint)(2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[i]));
				pNode = jsonLookup(&x, zPath, null, ctx);
				if ((x.nErr) != 0)
					goto replace_err;
				if ((pNode) != null)
				{
					pNode->jnFlags |= ((byte)(0x08));
					pNode->u.iReplace = (uint)(i + 1);
				}
			}

			if ((x.aNode[0].jnFlags & 0x08) != 0)
			{
				sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);
			}
			else
			{
				jsonReturnJson(x.aNode, ctx, argv);
			}

		replace_err:
			; jsonParseReset(&x);
		}
		public static void jsonSetFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonNode* pNode;
			sbyte* zPath;
			uint i = 0;
			int bApnd = 0;
			int bIsSet = (int)(sqlite3_user_data(ctx) != null);
			if ((argc) < (1))
				return;
			if ((argc & 1) == (0))
			{
				jsonWrongNumArgs(ctx, (bIsSet) != 0 ? "set" : "insert");
				return;
			}

			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;
			for (i = (uint)(1); (i) < ((uint)(argc)); i += (uint)(2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[i]));
				bApnd = (int)(0);
				pNode = jsonLookup(&x, zPath, &bApnd, ctx);
				if ((x.oom) != 0)
				{
					sqlite3_result_error_nomem(ctx);
					goto jsonSetDone;
				}
				else if ((x.nErr) != 0)
				{
					goto jsonSetDone;
				}
				else if (((pNode) != null) && (((bApnd) != 0) || ((bIsSet) != 0)))
				{
					pNode->jnFlags |= ((byte)(0x08));
					pNode->u.iReplace = (uint)(i + 1);
				}
			}

			if ((x.aNode[0].jnFlags & 0x08) != 0)
			{
				sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);
			}
			else
			{
				jsonReturnJson(x.aNode, ctx, argv);
			}

		jsonSetDone:
			; jsonParseReset(&x);
		}
		public static void jsonTypeFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			sbyte* zPath;
			JsonNode* pNode;
			p = jsonParseCached(ctx, argv, ctx);
			if ((p) == (null))
				return;
			if ((argc) == (2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[1]));
				pNode = jsonLookup(p, zPath, null, ctx);
			}
			else
			{
				pNode = p->aNode;
			}

			if ((pNode) != null)
			{
				sqlite3_result_text(ctx, jsonType[pNode->eType], (int)(-1), null);
			}
		}
		public static void jsonValidFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			p = jsonParseCached(ctx, argv, null);
			sqlite3_result_int(ctx, (int)(p != null));
		}
		public static void jsonWrongNumArgs(sqlite3_context pCtx, sbyte* zFuncName)
		{
			sbyte* zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments", zFuncName);
			sqlite3_result_error(pCtx, zMsg, (int)(-1));
			sqlite3_free(zMsg);
		}
		public static void juliandayFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				computeJD(&x);
				sqlite3_result_double(context, (double)(x.iJD / 86400000.0));
			}
		}
		public static void last_insert_rowid(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sqlite3_result_int64(context, (long)(sqlite3_last_insert_rowid(db)));
		}
		public static void last_valueFinalizeFunc(sqlite3_context pCtx)
		{
			LastValueCtx p;
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
			if (((p) != null) && ((p.pVal) != null))
			{
				sqlite3_result_value(pCtx, p.pVal);
				sqlite3_value_free(p.pVal);
				p.pVal = null;
			}
		}
		public static void last_valueInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			LastValueCtx p;
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
			if ((p) != null)
			{
				p.nVal--;
				if ((p.nVal) == (0))
				{
					sqlite3_value_free(p.pVal);
					p.pVal = null;
				}
			}
		}
		public static void last_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			LastValueCtx p;
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
			if ((p) != null)
			{
				sqlite3_value_free(p.pVal);
				p.pVal = sqlite3_value_dup(apArg[0]);
				if ((p.pVal) == (null))
				{
					sqlite3_result_error_nomem(pCtx);
				}
				else
				{
					p.nVal++;
				}
			}
		}
		public static void last_valueValueFunc(sqlite3_context pCtx)
		{
			LastValueCtx p;
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(0)));
			if (((p) != null) && ((p.pVal) != null))
			{
				sqlite3_result_value(pCtx, p.pVal);
			}
		}
		public static void lengthFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			switch (sqlite3_value_type(argv[0]))
			{
				case 4:
				case 1:
				case 2:
					{
						sqlite3_result_int(context, (int)(sqlite3_value_bytes(argv[0])));
						break;
					}

				case 3:
					{
						byte* z = sqlite3_value_text(argv[0]);
						byte* z0;
						byte c = 0;
						if ((z) == (null))
							return;
						z0 = z;
						while ((c = (byte)(*z)) != 0)
						{
							z++;
							if ((c) >= (0xc0))
							{
								while ((*z & 0xc0) == (0x80))
								{
									z++;
									z0++;
								}
							}
						}

						sqlite3_result_int(context, (int)(z - z0));
						break;
					}

				default:
					{
						sqlite3_result_null(context);
						break;
					}
			}
		}
		public static void likeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zA; byte* zB;
			uint escape = 0;
			int nPat = 0;
			sqlite3 db = sqlite3_context_db_handle(context);
			compareInfo* pInfo = sqlite3_user_data(context);
			compareInfo backupInfo = new compareInfo();
			nPat = (int)(sqlite3_value_bytes(argv[0]));
			if ((nPat) > (db.aLimit[8]))
			{
				sqlite3_result_error(context, "LIKE or GLOB pattern too complex", (int)(-1));
				return;
			}

			if ((argc) == (3))
			{
				byte* zEsc = sqlite3_value_text(argv[2]);
				if ((zEsc) == (null))
					return;
				if (sqlite3Utf8CharLen((sbyte*)(zEsc), (int)(-1)) != 1)
				{
					sqlite3_result_error(context, "ESCAPE expression must be a single character", (int)(-1));
					return;
				}

				escape = (uint)(sqlite3Utf8Read(&zEsc));
				if (((escape) == (pInfo->matchAll)) || ((escape) == (pInfo->matchOne)))
				{
					CRuntime.memcpy(&backupInfo, pInfo, (ulong)(sizeof(compareInfo)));
					pInfo = &backupInfo;
					if ((escape) == (pInfo->matchAll))
						pInfo->matchAll = (byte)(0);
					if ((escape) == (pInfo->matchOne))
						pInfo->matchOne = (byte)(0);
				}
			}
			else
			{
				escape = (uint)(pInfo->matchSet);
			}

			zB = sqlite3_value_text(argv[0]);
			zA = sqlite3_value_text(argv[1]);
			if (((zA) != null) && ((zB) != null))
			{
				sqlite3_result_int(context, ((patternCompare(zB, zA, pInfo, (uint)(escape))) == (0) ? 1 : 0));
			}
		}
		public static void loadExt(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* zFile = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zProc;
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zErrMsg = null;
			if ((db.flags & 0x00020000) == (0))
			{
				sqlite3_result_error(context, "not authorized", (int)(-1));
				return;
			}

			if ((argc) == (2))
			{
				zProc = (sbyte*)(sqlite3_value_text(argv[1]));
			}
			else
			{
				zProc = null;
			}

			if (((zFile) != null) && ((sqlite3_load_extension(db, zFile, zProc, &zErrMsg)) != 0))
			{
				sqlite3_result_error(context, zErrMsg, (int)(-1));
				sqlite3_free(zErrMsg);
			}
		}
		public static void lowerFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* z1;
			sbyte* z2;
			int i = 0; int n = 0;
			z2 = (sbyte*)(sqlite3_value_text(argv[0]));
			n = (int)(sqlite3_value_bytes(argv[0]));
			if ((z2) != null)
			{
				z1 = contextMalloc(context, (long)(((long)(n)) + 1));
				if ((z1) != null)
				{
					for (i = (int)(0); (i) < (n); i++)
					{
						z1[i] = (sbyte)(sqlite3UpperToLower[(byte)(z2[i])]);
					}

					sqlite3_result_text(context, z1, (int)(n), sqlite3_free);
				}
			}
		}
		public static void minMaxFinalize(sqlite3_context context)
		{
			minMaxValueFinalize(context, (int)(0));
		}
		public static void minmaxFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int i = 0;
			int mask = 0;
			int iBest = 0;
			CollSeq pColl;
			mask = (int)((sqlite3_user_data(context)) == (null) ? 0 : -1);
			pColl = sqlite3GetFuncCollSeq(context);
			iBest = (int)(0);
			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			for (i = (int)(1); (i) < (argc); i++)
			{
				if ((sqlite3_value_type(argv[i])) == (5))
					return;
				if ((sqlite3MemCompare(argv[iBest], argv[i], pColl) ^ mask) >= (0))
				{
					iBest = (int)(i);
				}
			}

			sqlite3_result_value(context, argv[iBest]);
		}
		public static void minmaxStep(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3_value pArg = argv[0];
			sqlite3_value pBest;
			pBest = (sqlite3_value)(sqlite3_aggregate_context(context, (int)(sizeof(sqlite3_value))));
			if (pBest == null)
				return;
			if ((sqlite3_value_type(pArg)) == (5))
			{
				if ((pBest.flags) != 0)
					sqlite3SkipAccumulatorLoad(context);
			}
			else if ((pBest.flags) != 0)
			{
				int max = 0;
				int cmp = 0;
				CollSeq pColl = sqlite3GetFuncCollSeq(context);
				max = (int)(sqlite3_user_data(context) != null);
				cmp = (int)(sqlite3MemCompare(pBest, pArg, pColl));
				if ((((max) != 0) && ((cmp) < (0))) || ((max == 0) && ((cmp) > (0))))
				{
					sqlite3VdbeMemCopy(pBest, pArg);
				}
				else
				{
					sqlite3SkipAccumulatorLoad(context);
				}
			}
			else
			{
				pBest.db = sqlite3_context_db_handle(context);
				sqlite3VdbeMemCopy(pBest, pArg);
			}
		}
		public static void minMaxValue(sqlite3_context context)
		{
			minMaxValueFinalize(context, (int)(1));
		}
		public static void minMaxValueFinalize(sqlite3_context context, int bValue)
		{
			sqlite3_value pRes;
			pRes = (sqlite3_value)(sqlite3_aggregate_context(context, (int)(0)));
			if ((pRes) != null)
			{
				if ((pRes.flags) != 0)
				{
					sqlite3_result_value(context, pRes);
				}

				if ((bValue) == (0))
					sqlite3VdbeMemRelease(pRes);
			}
		}
		public static void noopStepFunc(sqlite3_context p, int n, sqlite3_value a)
		{
		}
		public static void noopValueFunc(sqlite3_context p)
		{
		}
		public static void nth_valueFinalizeFunc(sqlite3_context pCtx)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(0)));
			if (((p) != null) && ((p.pValue) != null))
			{
				sqlite3_result_value(pCtx, p.pValue);
				sqlite3_value_free(p.pValue);
				p.pValue = null;
			}
		}
		public static void nth_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
			if ((p) != null)
			{
				long iVal = 0;
				switch (sqlite3_value_numeric_type(apArg[1]))
				{
					case 1:
						iVal = (long)(sqlite3_value_int64(apArg[1]));
						break;
					case 2:
						{
							double fVal = (double)(sqlite3_value_double(apArg[1]));
							if (((long)(fVal)) != fVal)
								goto error_out;
							iVal = ((long)(fVal));
							break;
						}

					default:
						goto error_out;
				}

				if ((iVal) <= (0))
					goto error_out;
				p.nStep++;
				if ((iVal) == (p.nStep))
				{
					p.pValue = sqlite3_value_dup(apArg[0]);
					if (p.pValue == null)
					{
						sqlite3_result_error_nomem(pCtx);
					}
				}
			}

			return;
		error_out:
			; sqlite3_result_error(pCtx, "second argument to nth_value must be a positive integer", (int)(-1));
		}
		public static void ntileInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NtileCtx* p;
			p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
			p->iRow++;
		}
		public static void ntileStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NtileCtx* p;
			p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
			if ((p) != null)
			{
				if ((p->nTotal) == (0))
				{
					p->nParam = (long)(sqlite3_value_int64(apArg[0]));
					if ((p->nParam) <= (0))
					{
						sqlite3_result_error(pCtx, "argument of ntile must be a positive integer", (int)(-1));
					}
				}

				p->nTotal++;
			}
		}
		public static void ntileValueFunc(sqlite3_context pCtx)
		{
			NtileCtx* p;
			p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
			if (((p) != null) && ((p->nParam) > (0)))
			{
				int nSize = (int)(p->nTotal / p->nParam);
				if ((nSize) == (0))
				{
					sqlite3_result_int64(pCtx, (long)(p->iRow + 1));
				}
				else
				{
					long nLarge = (long)(p->nTotal - p->nParam * nSize);
					long iSmall = (long)(nLarge * (nSize + 1));
					long iRow = (long)(p->iRow);
					if ((iRow) < (iSmall))
					{
						sqlite3_result_int64(pCtx, (long)(1 + iRow / (nSize + 1)));
					}
					else
					{
						sqlite3_result_int64(pCtx, (long)(1 + nLarge + (iRow - iSmall) / nSize));
					}
				}
			}
		}
		public static void nullifFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			CollSeq pColl = sqlite3GetFuncCollSeq(context);
			if (sqlite3MemCompare(argv[0], argv[1], pColl) != 0)
			{
				sqlite3_result_value(context, argv[0]);
			}
		}
		public static int parseDateOrTime(sqlite3_context context, sbyte* zDate, DateTime* p)
		{
			double r = 0;
			if ((parseYyyyMmDd(zDate, p)) == (0))
			{
				return (int)(0);
			}
			else if ((parseHhMmSs(zDate, p)) == (0))
			{
				return (int)(0);
			}
			else if (((sqlite3StrICmp(zDate, "now")) == (0)) && ((sqlite3NotPureFunc(context)) != 0))
			{
				return (int)(setDateTimeToCurrent(context, p));
			}
			else if ((sqlite3AtoF(zDate, &r, (int)(sqlite3Strlen30(zDate)), (byte)(1))) > (0))
			{
				setRawDateNumber(p, (double)(r));
				return (int)(0);
			}

			return (int)(1);
		}
		public static int parseModifier(sqlite3_context pCtx, sbyte* z, int n, DateTime* p, int idx)
		{
			int rc = (int)(1);
			double r = 0;
			switch (sqlite3UpperToLower[(byte)(z[0])])
			{
				case 97:
					{
						if ((sqlite3_stricmp(z, "auto")) == (0))
						{
							if ((idx) > (1))
								return (int)(1);
							if ((p->rawS == 0) || ((p->validJD) != 0))
							{
								rc = (int)(0);
								p->rawS = (sbyte)(0);
							}
							else if (((p->s) >= (-21086676 * (long)(10000))) && ((p->s) <= ((25340230 * (long)(10000)) + 799)))
							{
								r = (double)(p->s * 1000.0 + 210866760000000.0);
								clearYMD_HMS_TZ(p);
								p->iJD = ((long)(r + 0.5));
								p->validJD = (sbyte)(1);
								p->rawS = (sbyte)(0);
								rc = (int)(0);
							}
						}

						break;
					}

				case 106:
					{
						if ((sqlite3_stricmp(z, "julianday")) == (0))
						{
							if ((idx) > (1))
								return (int)(1);
							if (((p->validJD) != 0) && ((p->rawS) != 0))
							{
								rc = (int)(0);
								p->rawS = (sbyte)(0);
							}
						}

						break;
					}

				case 108:
					{
						if (((sqlite3_stricmp(z, "localtime")) == (0)) && ((sqlite3NotPureFunc(pCtx)) != 0))
						{
							rc = (int)(toLocaltime(p, pCtx));
						}

						break;
					}

				case 117:
					{
						if (((sqlite3_stricmp(z, "unixepoch")) == (0)) && ((p->rawS) != 0))
						{
							if ((idx) > (1))
								return (int)(1);
							r = (double)(p->s * 1000.0 + 210866760000000.0);
							if (((r) >= (0.0)) && ((r) < (464269060800000.0)))
							{
								clearYMD_HMS_TZ(p);
								p->iJD = ((long)(r + 0.5));
								p->validJD = (sbyte)(1);
								p->rawS = (sbyte)(0);
								rc = (int)(0);
							}
						}
						else if (((sqlite3_stricmp(z, "utc")) == (0)) && ((sqlite3NotPureFunc(pCtx)) != 0))
						{
							if ((p->tzSet) == (0))
							{
								long iOrigJD = 0;
								long iGuess = 0;
								int cnt = (int)(0);
								int iErr = 0;
								computeJD(p);
								iGuess = (long)(iOrigJD = (long)(p->iJD));
								iErr = (int)(0);
								do
								{
									DateTime new = new DateTime();
									CRuntime.memset(&new, (int)(0), (ulong)(sizeof(DateTime)));
									iGuess -= (long)(iErr);
									new.iJD = (long)(iGuess);
									new.validJD = (sbyte)(1);
									rc = (int)(toLocaltime(&new, pCtx));
									if ((rc) != 0)
										return (int)(rc);
									computeJD(&new);
									iErr = (int)(new.iJD - iOrigJD);
								}
								while (((iErr) != 0) && ((cnt++) < (3)));
								CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
								p->iJD = (long)(iGuess);
								p->validJD = (sbyte)(1);
								p->tzSet = (sbyte)(1);
							}

							rc = (int)(0);
						}

						break;
					}

				case 119:
					{
						if ((((((sqlite3_strnicmp(z, "weekday ", (int)(8))) == (0)) && ((sqlite3AtoF(&z[8], &r, (int)(sqlite3Strlen30(&z[8])), (byte)(1))) > (0))) && ((n = ((int)(r))) == (r))) && ((n) >= (0))) && ((r) < (7)))
						{
							long Z = 0;
							computeYMD_HMS(p);
							p->validTZ = (sbyte)(0);
							p->validJD = (sbyte)(0);
							computeJD(p);
							Z = (long)(((p->iJD + 129600000) / 86400000) % 7);
							if ((Z) > (n))
								Z -= (long)(7);
							p->iJD += (long)((n - Z) * 86400000);
							clearYMD_HMS_TZ(p);
							rc = (int)(0);
						}

						break;
					}

				case 115:
					{
						if (sqlite3_strnicmp(z, "start of ", (int)(9)) != 0)
							break;
						if (((p->validJD == 0) && (p->validYMD == 0)) && (p->validHMS == 0))
							break;
						z += 9;
						computeYMD(p);
						p->validHMS = (sbyte)(1);
						p->h = (int)(p->m = (int)(0));
						p->s = (double)(0.0);
						p->rawS = (sbyte)(0);
						p->validTZ = (sbyte)(0);
						p->validJD = (sbyte)(0);
						if ((sqlite3_stricmp(z, "month")) == (0))
						{
							p->D = (int)(1);
							rc = (int)(0);
						}
						else if ((sqlite3_stricmp(z, "year")) == (0))
						{
							p->M = (int)(1);
							p->D = (int)(1);
							rc = (int)(0);
						}
						else if ((sqlite3_stricmp(z, "day")) == (0))
						{
							rc = (int)(0);
						}

						break;
					}

				case 43:
				case 45:
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					{
						double rRounder = 0;
						int i = 0;
						for (n = (int)(1); (((z[n]) != 0) && (z[n] != 58)) && ((sqlite3CtypeMap[(byte)(z[n])] & 0x01) == 0); n++)
						{
						}

						if ((sqlite3AtoF(z, &r, (int)(n), (byte)(1))) <= (0))
						{
							rc = (int)(1);
							break;
						}

						if ((z[n]) == (58))
						{
							sbyte* z2 = z;
							DateTime tx = new DateTime();
							long day = 0;
							if ((sqlite3CtypeMap[(byte)(*z2)] & 0x04) == 0)
								z2++;
							CRuntime.memset(&tx, (int)(0), (ulong)(sizeof(DateTime)));
							if ((parseHhMmSs(z2, &tx)) != 0)
								break;
							computeJD(&tx);
							tx.iJD -= (long)(43200000);
							day = (long)(tx.iJD / 86400000);
							tx.iJD -= (long)(day * 86400000);
							if ((z[0]) == (45))
								tx.iJD = (long)(-tx.iJD);
							computeJD(p);
							clearYMD_HMS_TZ(p);
							p->iJD += (long)(tx.iJD);
							rc = (int)(0);
							break;
						}

						z += n;
						while ((sqlite3CtypeMap[(byte)(*z)] & 0x01) != 0)
						{
							z++;
						}

						n = (int)(sqlite3Strlen30(z));
						if (((n) > (10)) || ((n) < (3)))
							break;
						if ((sqlite3UpperToLower[(byte)(z[n - 1])]) == (115))
							n--;
						computeJD(p);
						rc = (int)(1);
						rRounder = (double)((r) < (0) ? -0.5 : +0.5);
						for (i = (int)(0); (i) < ((int)(6 * sizeof(aXformTypeDef) / sizeof(aXformTypeDef))); i++)
						{
							if (((((aXformType[i].nName) == (n)) && ((sqlite3_strnicmp(aXformType[i].zName, z, (int)(n))) == (0))) && ((r) > (-aXformType[i].rLimit))) && ((r) < (aXformType[i].rLimit)))
							{
								switch (i)
								{
									case 4:
										{
											int x = 0;
											computeYMD_HMS(p);
											p->M += ((int)(r));
											x = (int)((p->M) > (0) ? (p->M - 1) / 12 : (p->M - 12) / 12);
											p->Y += (int)(x);
											p->M -= (int)(x * 12);
											p->validJD = (sbyte)(0);
											r -= (double)((int)(r));
											break;
										}

									case 5:
										{
											int y = (int)(r);
											computeYMD_HMS(p);
											p->Y += (int)(y);
											p->validJD = (sbyte)(0);
											r -= (double)((int)(r));
											break;
										}
								}

								computeJD(p);
								p->iJD += ((long)(r * 1000.0 * aXformType[i].rXform + rRounder));
								rc = (int)(0);
								break;
							}
						}

						clearYMD_HMS_TZ(p);
						break;
					}

				default:
					{
						break;
					}
			}

			return (int)(rc);
		}
		public static void percent_rankInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			p->nStep++;
		}
		public static void percent_rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nTotal++;
			}
		}
		public static void percent_rankValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nValue = (long)(p->nStep);
				if ((p->nTotal) > (1))
				{
					double r = (double)((double)(p->nValue) / (double)(p->nTotal - 1));
					sqlite3_result_double(pCtx, (double)(r));
				}
				else
				{
					sqlite3_result_double(pCtx, (double)(0.0));
				}
			}
		}
		public static void printfFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			PrintfArguments x = new PrintfArguments();
			sqlite3_str str = new sqlite3_str();
			sbyte* zFormat;
			int n = 0;
			sqlite3 db = sqlite3_context_db_handle(context);
			if (((argc) >= (1)) && ((zFormat = (sbyte*)(sqlite3_value_text(argv[0]))) != null))
			{
				x.nArg = (int)(argc - 1);
				x.nUsed = (int)(0);
				x.apArg = argv[1];
				sqlite3StrAccumInit(str, db, null, (int)(0), (int)(db.aLimit[0]));
				str.printfFlags = (byte)(0x02);
				sqlite3_str_appendf(str, zFormat, x);
				n = (int)(str.nChar);
				sqlite3_result_text(context, sqlite3StrAccumFinish(str), (int)(n), ((Void(Void * ))(sqlite3OomFault)));
			}
		}
		public static void quoteFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sqlite3_str str = new sqlite3_str();
			sqlite3 db = sqlite3_context_db_handle(context);
			sqlite3StrAccumInit(str, db, null, (int)(0), (int)(db.aLimit[0]));
			sqlite3QuoteValue(str, argv[0]);
			sqlite3_result_text(context, sqlite3StrAccumFinish(str), (int)(str.nChar), ((Void(Void * ))(sqlite3OomFault)));
			if (str.accError != 0)
			{
				sqlite3_result_null(context);
				sqlite3_result_error_code(context, (int)(str.accError));
			}
		}
		public static void randomBlob(sqlite3_context context, int argc, sqlite3_value argv)
		{
			long n = 0;
			byte* p;
			n = (long)(sqlite3_value_int64(argv[0]));
			if ((n) < (1))
			{
				n = (long)(1);
			}

			p = contextMalloc(context, (long)(n));
			if ((p) != null)
			{
				sqlite3_randomness((int)(n), p);
				sqlite3_result_blob(context, (sbyte*)(p), (int)(n), sqlite3_free);
			}
		}
		public static void randomFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			long r = 0;
			sqlite3_randomness((int)(sizeof(long)), &r);
			if ((r) < (0))
			{
				r = (long)(-(r & (0xffffffff | (((long)(0x7fffffff)) << 32))));
			}

			sqlite3_result_int64(context, (long)(r));
		}
		public static void rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nStep++;
				if ((p->nValue) == (0))
				{
					p->nValue = (long)(p->nStep);
				}
			}
		}
		public static void rankValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				sqlite3_result_int64(pCtx, (long)(p->nValue));
				p->nValue = (long)(0);
			}
		}
		public static void renameColumnFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			RenameCtx sCtx = new RenameCtx();
			sbyte* zSql = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[3]));
			sbyte* zTable = (sbyte*)(sqlite3_value_text(argv[4]));
			int iCol = (int)(sqlite3_value_int(argv[5]));
			sbyte* zNew = (sbyte*)(sqlite3_value_text(argv[6]));
			int bQuote = (int)(sqlite3_value_int(argv[7]));
			int bTemp = (int)(sqlite3_value_int(argv[8]));
			sbyte* zOld;
			int rc = 0;
			Parse sParse = new Parse();
			Walker sWalker = new Walker();
			Index pIdx;
			int i = 0;
			Table pTab;
			delegate67 xAuth = db.xAuth;
			if ((zSql) == (null))
				return;
			if ((zTable) == (null))
				return;
			if ((zNew) == (null))
				return;
			if ((iCol) < (0))
				return;
			sqlite3BtreeEnterAll(db);
			pTab = sqlite3FindTable(db, zTable, zDb);
			if (((pTab) == (null)) || ((iCol) >= (pTab.nCol)))
			{
				sqlite3BtreeLeaveAll(db);
				return;
			}

			zOld = pTab.aCol[iCol].zCnName;
			CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
			sCtx.iCol = (int)(((iCol) == (pTab.iPKey)) ? -1 : iCol);
			db.xAuth = null;
			rc = (int)(renameParseSql(sParse, zDb, db, zSql, (int)(bTemp)));
			CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
			sWalker.pParse = sParse;
			sWalker.xExprCallback = renameColumnExprCb;
			sWalker.xSelectCallback = renameColumnSelectCb;
			sWalker.u.pRename = sCtx;
			sCtx.pTab = pTab;
			if (rc != 0)
				goto renameColumnFunc_done;
			if ((sParse.pNewTable) != null)
			{
				if ((((sParse.pNewTable).eTabType) == (2)))
				{
					Select pSelect = sParse.pNewTable.u.view.pSelect;
					pSelect.selFlags &= (uint)(~0x0200000);
					sParse.rc = (int)(0);
					sqlite3SelectPrep(sParse, pSelect, null);
					rc = (int)((db.mallocFailed) != 0 ? 7 : sParse.rc);
					if ((rc) == (0))
					{
						sqlite3WalkSelect(sWalker, pSelect);
					}

					if (rc != 0)
						goto renameColumnFunc_done;
				}
				else if ((((sParse.pNewTable).eTabType) == (0)))
				{
					int bFKOnly = (int)(sqlite3_stricmp(zTable, sParse.pNewTable.zName));
					FKey pFKey;
					sCtx.pTab = sParse.pNewTable;
					if ((bFKOnly) == (0))
					{
						if ((iCol) < (sParse.pNewTable.nCol))
						{
							renameTokenFind(sParse, sCtx, (void*)(sParse.pNewTable.aCol[iCol].zCnName));
						}

						if ((sCtx.iCol) < (0))
						{
							renameTokenFind(sParse, sCtx, (void*)(&sParse.pNewTable.iPKey));
						}

						sqlite3WalkExprList(sWalker, sParse.pNewTable.pCheck);
						for (pIdx = sParse.pNewTable.pIndex; pIdx; pIdx = pIdx.pNext)
						{
							sqlite3WalkExprList(sWalker, pIdx.aColExpr);
						}

						for (pIdx = sParse.pNewIndex; pIdx; pIdx = pIdx.pNext)
						{
							sqlite3WalkExprList(sWalker, pIdx.aColExpr);
						}

						for (i = (int)(0); (i) < (sParse.pNewTable.nCol); i++)
						{
							Expr pExpr = sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable.aCol[i]);
							sqlite3WalkExpr(sWalker, pExpr);
						}
					}

					for (pFKey = sParse.pNewTable.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
					{
						for (i = (int)(0); (i) < (pFKey.nCol); i++)
						{
							if (((bFKOnly) == (0)) && ((pFKey.aCol[i].iFrom) == (iCol)))
							{
								renameTokenFind(sParse, sCtx, (void*)(&pFKey.aCol[i]));
							}

							if (((0) == (sqlite3_stricmp(pFKey.zTo, zTable))) && ((0) == (sqlite3_stricmp(pFKey.aCol[i].zCol, zOld))))
							{
								renameTokenFind(sParse, sCtx, (void*)(pFKey.aCol[i].zCol));
							}
						}
					}
				}
			}
			else if ((sParse.pNewIndex) != null)
			{
				sqlite3WalkExprList(sWalker, sParse.pNewIndex.aColExpr);
				sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
			}
			else
			{
				TriggerStep pStep;
				rc = (int)(renameResolveTrigger(sParse));
				if (rc != 0)
					goto renameColumnFunc_done;
				for (pStep = sParse.pNewTrigger.step_list; pStep; pStep = pStep.pNext)
				{
					if ((pStep.zTarget) != null)
					{
						Table pTarget = sqlite3LocateTable(sParse, (uint)(0), pStep.zTarget, zDb);
						if ((pTarget) == (pTab))
						{
							if ((pStep.pUpsert) != null)
							{
								ExprList pUpsertSet = pStep.pUpsert.pUpsertSet;
								renameColumnElistNames(sParse, sCtx, pUpsertSet, zOld);
							}

							renameColumnIdlistNames(sParse, sCtx, pStep.pIdList, zOld);
							renameColumnElistNames(sParse, sCtx, pStep.pExprList, zOld);
						}
					}
				}

				if ((sParse.pTriggerTab) == (pTab))
				{
					renameColumnIdlistNames(sParse, sCtx, sParse.pNewTrigger.pColumns, zOld);
				}

				renameWalkTrigger(sWalker, sParse.pNewTrigger);
			}

			rc = (int)(renameEditSql(context, sCtx, zSql, zNew, (int)(bQuote)));
		renameColumnFunc_done:
			; if (rc != 0) { if (((rc) == (1)) && ((sqlite3WritableSchema(db)) != 0)) { sqlite3_result_value(context, argv[0]); } else if ((sParse.zErrMsg) != null) { renameColumnParseError(context, "", argv[1], argv[2], sParse); } else { sqlite3_result_error_code(context, (int)(rc)); } }
			renameParseCleanup(sParse);
			renameTokenFree(db, sCtx.pList);
			db.xAuth = xAuth;
			sqlite3BtreeLeaveAll(db);
		}
		public static void renameColumnParseError(sqlite3_context pCtx, sbyte* zWhen, sqlite3_value pType, sqlite3_value pObject, Parse pParse)
		{
			sbyte* zT = (sbyte*)(sqlite3_value_text(pType));
			sbyte* zN = (sbyte*)(sqlite3_value_text(pObject));
			sbyte* zErr;
			zErr = sqlite3MPrintf(pParse.db, "error in %s %s%s%s: %s", zT, zN, ((zWhen[0]) != 0 ? " " : ""), zWhen, pParse.zErrMsg);
			sqlite3_result_error(pCtx, zErr, (int)(-1));
			sqlite3DbFree(pParse.db, zErr);
		}
		public static int renameEditSql(sqlite3_context pCtx, RenameCtx pRename, sbyte* zSql, sbyte* zNew, int bQuote)
		{
			long nNew = (long)(sqlite3Strlen30(zNew));
			long nSql = (long)(sqlite3Strlen30(zSql));
			sqlite3 db = sqlite3_context_db_handle(pCtx);
			int rc = (int)(0);
			sbyte* zQuot = null;
			sbyte* zOut;
			long nQuot = (long)(0);
			sbyte* zBuf1 = null;
			sbyte* zBuf2 = null;
			if ((zNew) != null)
			{
				zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);
				if ((zQuot) == (null))
				{
					return (int)(7);
				}
				else
				{
					nQuot = (long)(sqlite3Strlen30(zQuot) - 1);
				}

				zOut = sqlite3DbMallocZero(db, (ulong)(nSql + pRename.nList * nQuot + 1));
			}
			else
			{
				zOut = (sbyte*)(sqlite3DbMallocZero(db, (ulong)((nSql * 2 + 1) * 3)));
				if ((zOut) != null)
				{
					zBuf1 = &zOut[nSql * 2 + 1];
					zBuf2 = &zOut[nSql * 4 + 2];
				}
			}

			if ((zOut) != null)
			{
				int nOut = (int)(nSql);
				CRuntime.memcpy(zOut, zSql, (ulong)(nSql));
				while ((pRename.pList) != null)
				{
					int iOff = 0;
					uint nReplace = 0;
					sbyte* zReplace;
					RenameToken* pBest = renameColumnTokenNext(pRename);
					if ((zNew) != null)
					{
						if (((bQuote) == (0)) && ((sqlite3IsIdChar((byte)(*pBest->t.z))) != 0))
						{
							nReplace = (uint)(nNew);
							zReplace = zNew;
						}
						else
						{
							nReplace = (uint)(nQuot);
							zReplace = zQuot;
							if ((pBest->t.z[pBest->t.n]) == (34))
								nReplace++;
						}
					}
					else
					{
						CRuntime.memcpy(zBuf1, pBest->t.z, (ulong)(pBest->t.n));
						zBuf1[pBest->t.n] = (sbyte)(0);
						sqlite3Dequote(zBuf1);
						sqlite3_snprintf((int)(nSql * 2), zBuf2, "%Q%s", zBuf1, (pBest->t.z[pBest->t.n]) == (39) ? " " : "");
						zReplace = zBuf2;
						nReplace = (uint)(sqlite3Strlen30(zReplace));
					}

					iOff = (int)(pBest->t.z - zSql);
					if (pBest->t.n != nReplace)
					{
						CRuntime.memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n], (ulong)(nOut - (iOff + pBest->t.n)));
						nOut += (int)(nReplace - pBest->t.n);
						zOut[nOut] = (sbyte)(0);
					}

					CRuntime.memcpy(&zOut[iOff], zReplace, (ulong)(nReplace));
					sqlite3DbFree(db, pBest);
				}

				sqlite3_result_text(pCtx, zOut, (int)(-1), ((Void(Void * ))(-1)));
				sqlite3DbFree(db, zOut);
			}
			else
			{
				rc = (int)(7);
			}

			sqlite3_free(zQuot);
			return (int)(rc);
		}
		public static void renameQuotefixFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[1]));
			delegate67 xAuth = db.xAuth;
			db.xAuth = null;
			sqlite3BtreeEnterAll(db);
			if (((zDb) != null) && ((zInput) != null))
			{
				int rc = 0;
				Parse sParse = new Parse();
				rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(0)));
				if ((rc) == (0))
				{
					RenameCtx sCtx = new RenameCtx();
					Walker sWalker = new Walker();
					CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
					CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
					sWalker.pParse = sParse;
					sWalker.xExprCallback = renameQuotefixExprCb;
					sWalker.xSelectCallback = renameColumnSelectCb;
					sWalker.u.pRename = sCtx;
					if ((sParse.pNewTable) != null)
					{
						if ((((sParse.pNewTable).eTabType) == (2)))
						{
							Select pSelect = sParse.pNewTable.u.view.pSelect;
							pSelect.selFlags &= (uint)(~0x0200000);
							sParse.rc = (int)(0);
							sqlite3SelectPrep(sParse, pSelect, null);
							rc = (int)((db.mallocFailed) != 0 ? 7 : sParse.rc);
							if ((rc) == (0))
							{
								sqlite3WalkSelect(sWalker, pSelect);
							}
						}
						else
						{
							int i = 0;
							sqlite3WalkExprList(sWalker, sParse.pNewTable.pCheck);
							for (i = (int)(0); (i) < (sParse.pNewTable.nCol); i++)
							{
								sqlite3WalkExpr(sWalker, sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable.aCol[i]));
							}
						}
					}
					else if ((sParse.pNewIndex) != null)
					{
						sqlite3WalkExprList(sWalker, sParse.pNewIndex.aColExpr);
						sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
					}
					else
					{
						rc = (int)(renameResolveTrigger(sParse));
						if ((rc) == (0))
						{
							renameWalkTrigger(sWalker, sParse.pNewTrigger);
						}
					}

					if ((rc) == (0))
					{
						rc = (int)(renameEditSql(context, sCtx, zInput, null, (int)(0)));
					}

					renameTokenFree(db, sCtx.pList);
				}

				if (rc != 0)
				{
					if (((sqlite3WritableSchema(db)) != 0) && ((rc) == (1)))
					{
						sqlite3_result_value(context, argv[1]);
					}
					else
					{
						sqlite3_result_error_code(context, (int)(rc));
					}
				}

				renameParseCleanup(sParse);
			}

			db.xAuth = xAuth;
			sqlite3BtreeLeaveAll(db);
		}
		public static void renameTableFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[3]));
			sbyte* zOld = (sbyte*)(sqlite3_value_text(argv[4]));
			sbyte* zNew = (sbyte*)(sqlite3_value_text(argv[5]));
			int bTemp = (int)(sqlite3_value_int(argv[6]));
			if ((((zInput) != null) && ((zOld) != null)) && ((zNew) != null))
			{
				Parse sParse = new Parse();
				int rc = 0;
				int bQuote = (int)(1);
				RenameCtx sCtx = new RenameCtx();
				Walker sWalker = new Walker();
				delegate67 xAuth = db.xAuth;
				db.xAuth = null;
				sqlite3BtreeEnterAll(db);
				CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
				sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
				CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
				sWalker.pParse = sParse;
				sWalker.xExprCallback = renameTableExprCb;
				sWalker.xSelectCallback = renameTableSelectCb;
				sWalker.u.pRename = sCtx;
				rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(bTemp)));
				if ((rc) == (0))
				{
					int isLegacy = (int)(db.flags & 0x04000000);
					if ((sParse.pNewTable) != null)
					{
						Table pTab = sParse.pNewTable;
						if ((((pTab).eTabType) == (2)))
						{
							if ((isLegacy) == (0))
							{
								Select pSelect = pTab.u.view.pSelect;
								NameContext sNC = new NameContext();
								CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
								sNC.pParse = sParse;
								pSelect.selFlags &= (uint)(~0x0200000);
								sqlite3SelectPrep(sParse, pTab.u.view.pSelect, sNC);
								if ((sParse.nErr) != 0)
								{
									rc = (int)(sParse.rc);
								}
								else
								{
									sqlite3WalkSelect(sWalker, pTab.u.view.pSelect);
								}
							}
						}
						else
						{
							if ((((isLegacy) == (0)) || ((db.flags & 0x00004000) != 0)) && (!(((pTab).eTabType) == (1))))
							{
								FKey pFKey;
								for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
								{
									if ((sqlite3_stricmp(pFKey.zTo, zOld)) == (0))
									{
										renameTokenFind(sParse, sCtx, (void*)(pFKey.zTo));
									}
								}
							}

							if ((sqlite3_stricmp(zOld, pTab.zName)) == (0))
							{
								sCtx.pTab = pTab;
								if ((isLegacy) == (0))
								{
									sqlite3WalkExprList(sWalker, pTab.pCheck);
								}

								renameTokenFind(sParse, sCtx, pTab.zName);
							}
						}
					}
					else if ((sParse.pNewIndex) != null)
					{
						renameTokenFind(sParse, sCtx, sParse.pNewIndex.zName);
						if ((isLegacy) == (0))
						{
							sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
						}
					}
					else
					{
						Trigger pTrigger = sParse.pNewTrigger;
						TriggerStep pStep;
						if (((0) == (sqlite3_stricmp(sParse.pNewTrigger.table, zOld))) && ((sCtx.pTab.pSchema) == (pTrigger.pTabSchema)))
						{
							renameTokenFind(sParse, sCtx, sParse.pNewTrigger.table);
						}

						if ((isLegacy) == (0))
						{
							rc = (int)(renameResolveTrigger(sParse));
							if ((rc) == (0))
							{
								renameWalkTrigger(sWalker, pTrigger);
								for (pStep = pTrigger.step_list; pStep; pStep = pStep.pNext)
								{
									if (((pStep.zTarget) != null) && ((0) == (sqlite3_stricmp(pStep.zTarget, zOld))))
									{
										renameTokenFind(sParse, sCtx, pStep.zTarget);
									}
								}
							}
						}
					}
				}

				if ((rc) == (0))
				{
					rc = (int)(renameEditSql(context, sCtx, zInput, zNew, (int)(bQuote)));
				}

				if (rc != 0)
				{
					if (((rc) == (1)) && ((sqlite3WritableSchema(db)) != 0))
					{
						sqlite3_result_value(context, argv[3]);
					}
					else if ((sParse.zErrMsg) != null)
					{
						renameColumnParseError(context, "", argv[1], argv[2], sParse);
					}
					else
					{
						sqlite3_result_error_code(context, (int)(rc));
					}
				}

				renameParseCleanup(sParse);
				renameTokenFree(db, sCtx.pList);
				sqlite3BtreeLeaveAll(db);
				db.xAuth = xAuth;
			}

			return;
		}
		public static void renameTableTest(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[1]));
			int bTemp = (int)(sqlite3_value_int(argv[4]));
			int isLegacy = (int)(db.flags & 0x04000000);
			sbyte* zWhen = (sbyte*)(sqlite3_value_text(argv[5]));
			int bNoDQS = (int)(sqlite3_value_int(argv[6]));
			delegate67 xAuth = db.xAuth;
			db.xAuth = null;
			if (((zDb) != null) && ((zInput) != null))
			{
				int rc = 0;
				Parse sParse = new Parse();
				int flags = (int)(db.flags);
				if ((bNoDQS) != 0)
					db.flags &= (ulong)(~(0x40000000 | 0x20000000));
				rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(bTemp)));
				db.flags |= (ulong)(flags & (0x40000000 | 0x20000000));
				if ((rc) == (0))
				{
					if ((((isLegacy) == (0)) && ((sParse.pNewTable) != null)) && (((sParse.pNewTable).eTabType) == (2)))
					{
						NameContext sNC = new NameContext();
						CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
						sNC.pParse = sParse;
						sqlite3SelectPrep(sParse, sParse.pNewTable.u.view.pSelect, sNC);
						if ((sParse.nErr) != 0)
							rc = (int)(sParse.rc);
					}
					else if ((sParse.pNewTrigger) != null)
					{
						if ((isLegacy) == (0))
						{
							rc = (int)(renameResolveTrigger(sParse));
						}

						if ((rc) == (0))
						{
							int i1 = (int)(sqlite3SchemaToIndex(db, sParse.pNewTrigger.pTabSchema));
							int i2 = (int)(sqlite3FindDbName(db, zDb));
							if ((i1) == (i2))
							{
								sqlite3_result_int(context, (int)(1));
							}
						}
					}
				}

				if (((rc != 0) && ((zWhen) != null)) && (sqlite3WritableSchema(db) == 0))
				{
					renameColumnParseError(context, zWhen, argv[2], argv[3], sParse);
				}

				renameParseCleanup(sParse);
			}

			db.xAuth = xAuth;
		}
		public static void replaceFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zStr;
			byte* zPattern;
			byte* zRep;
			byte* zOut;
			int nStr = 0;
			int nPattern = 0;
			int nRep = 0;
			long nOut = 0;
			int loopLimit = 0;
			int i = 0; int j = 0;
			uint cntExpand = 0;
			sqlite3 db = sqlite3_context_db_handle(context);
			zStr = sqlite3_value_text(argv[0]);
			if ((zStr) == (null))
				return;
			nStr = (int)(sqlite3_value_bytes(argv[0]));
			zPattern = sqlite3_value_text(argv[1]);
			if ((zPattern) == (null))
			{
				return;
			}

			if ((zPattern[0]) == (0))
			{
				sqlite3_result_value(context, argv[0]);
				return;
			}

			nPattern = (int)(sqlite3_value_bytes(argv[1]));
			zRep = sqlite3_value_text(argv[2]);
			if ((zRep) == (null))
				return;
			nRep = (int)(sqlite3_value_bytes(argv[2]));
			nOut = (long)(nStr + 1);
			zOut = contextMalloc(context, (long)(nOut));
			if ((zOut) == (null))
			{
				return;
			}

			loopLimit = (int)(nStr - nPattern);
			cntExpand = (uint)(0);
			for (i = (int)(j = (int)(0)); (i) <= (loopLimit); i++)
			{
				if ((zStr[i] != zPattern[0]) || ((memcmp(&zStr[i], zPattern, (ulong)(nPattern))) != 0))
				{
					zOut[j++] = (byte)(zStr[i]);
				}
				else
				{
					if ((nRep) > (nPattern))
					{
						nOut += (long)(nRep - nPattern);
						if ((nOut - 1) > (db.aLimit[0]))
						{
							sqlite3_result_error_toobig(context);
							sqlite3_free(zOut);
							return;
						}

						cntExpand++;
						if ((cntExpand & (cntExpand - 1)) == (0))
						{
							byte* zOld;
							zOld = zOut;
							zOut = sqlite3Realloc(zOut, (ulong)((int)(nOut) + (nOut - nStr - 1)));
							if ((zOut) == (null))
							{
								sqlite3_result_error_nomem(context);
								sqlite3_free(zOld);
								return;
							}
						}
					}

					CRuntime.memcpy(&zOut[j], zRep, (ulong)(nRep));
					j += (int)(nRep);
					i += (int)(nPattern - 1);
				}
			}

			CRuntime.memcpy(&zOut[j], &zStr[i], (ulong)(nStr - i));
			j += (int)(nStr - i);
			zOut[j] = (byte)(0);
			sqlite3_result_text(context, (sbyte*)(zOut), (int)(j), sqlite3_free);
		}
		public static void roundFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int n = (int)(0);
			double r = 0;
			sbyte* zBuf;
			if ((argc) == (2))
			{
				if ((5) == (sqlite3_value_type(argv[1])))
					return;
				n = (int)(sqlite3_value_int(argv[1]));
				if ((n) > (30))
					n = (int)(30);
				if ((n) < (0))
					n = (int)(0);
			}

			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			r = (double)(sqlite3_value_double(argv[0]));
			if (((r) < (-4503599627370496.0)) || ((r) > (+4503599627370496.0)))
			{
			}
			else if ((n) == (0))
			{
				r = ((double)((long)(r + ((r) < (0) ? -0.5 : +0.5))));
			}
			else
			{
				zBuf = sqlite3_mprintf("%.*f", (int)(n), (double)(r));
				if ((zBuf) == (null))
				{
					sqlite3_result_error_nomem(context);
					return;
				}

				sqlite3AtoF(zBuf, &r, (int)(sqlite3Strlen30(zBuf)), (byte)(1));
				sqlite3_free(zBuf);
			}

			sqlite3_result_double(context, (double)(r));
		}
		public static void row_numberStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			long* p = (long*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(long))));
			if ((p) != null)
				(*p)++;
		}
		public static void row_numberValueFunc(sqlite3_context pCtx)
		{
			long* p = (long*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(long))));
			sqlite3_result_int64(pCtx, (long)((p) != 0 ? *p : 0));
		}
		public static int setDateTimeToCurrent(sqlite3_context context, DateTime* p)
		{
			p->iJD = (long)(sqlite3StmtCurrentTime(context));
			if ((p->iJD) > (0))
			{
				p->validJD = (sbyte)(1);
				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static void setResultStrOrError(sqlite3_context pCtx, sbyte* z, int n, byte enc, delegate17 xDel)
		{
			int rc = (int)(sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(enc), xDel));
			if ((rc) != 0)
			{
				if ((rc) == (18))
				{
					sqlite3_result_error_toobig(pCtx);
				}
				else
				{
					sqlite3_result_error_nomem(pCtx);
				}
			}
		}
		public static void signFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int type0 = 0;
			double x = 0;
			type0 = (int)(sqlite3_value_numeric_type(argv[0]));
			if ((type0 != 1) && (type0 != 2))
				return;
			x = (double)(sqlite3_value_double(argv[0]));
			sqlite3_result_int(context, (int)((x) < (0.0) ? -1 : (x) > (0.0) ? +1 : 0));
		}
		public static void sourceidFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3_result_text(context, sqlite3_sourceid(), (int)(-1), null);
		}
		public static int sqlite3_aggregate_count(sqlite3_context p)
		{
			return (int)(p.pMem.n);
		}
		public static sqlite3 sqlite3_context_db_handle(sqlite3_context p)
		{
			return p.pOut.db;
		}
		public static void sqlite3_result_blob(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{
			setResultStrOrError(pCtx, z, (int)(n), (byte)(0), xDel);
		}
		public static void sqlite3_result_blob64(sqlite3_context pCtx, void* z, ulong n, delegate17 xDel)
		{
			if ((n) > (0x7fffffff))
			{
				(void)(invokeValueDestructor(z, xDel, pCtx));
			}
			else
			{
				setResultStrOrError(pCtx, z, (int)(n), (byte)(0), xDel);
			}
		}
		public static void sqlite3_result_double(sqlite3_context pCtx, double rVal)
		{
			sqlite3VdbeMemSetDouble(pCtx.pOut, (double)(rVal));
		}
		public static void sqlite3_result_error(sqlite3_context pCtx, sbyte* z, int n)
		{
			pCtx.isError = (int)(1);
			sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(1), ((Void(Void * ))(-1)));
		}
		public static void sqlite3_result_error_code(sqlite3_context pCtx, int errCode)
		{
			pCtx.isError = (int)((errCode) != 0 ? errCode : -1);
			if ((pCtx.pOut.flags & 0x0001) != 0)
			{
				sqlite3VdbeMemSetStr(pCtx.pOut, sqlite3ErrStr((int)(errCode)), (long)(-1), (byte)(1), null);
			}
		}
		public static void sqlite3_result_error_nomem(sqlite3_context pCtx)
		{
			sqlite3VdbeMemSetNull(pCtx.pOut);
			pCtx.isError = (int)(7);
			sqlite3OomFault(pCtx.pOut.db);
		}
		public static void sqlite3_result_error_toobig(sqlite3_context pCtx)
		{
			pCtx.isError = (int)(18);
			sqlite3VdbeMemSetStr(pCtx.pOut, "string or blob too big", (long)(-1), (byte)(1), null);
		}
		public static void sqlite3_result_error16(sqlite3_context pCtx, void* z, int n)
		{
			pCtx.isError = (int)(1);
			sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(2), ((Void(Void * ))(-1)));
		}
		public static void sqlite3_result_int(sqlite3_context pCtx, int iVal)
		{
			sqlite3VdbeMemSetInt64(pCtx.pOut, (long)(iVal));
		}
		public static void sqlite3_result_int64(sqlite3_context pCtx, long iVal)
		{
			sqlite3VdbeMemSetInt64(pCtx.pOut, (long)(iVal));
		}
		public static void sqlite3_result_null(sqlite3_context pCtx)
		{
			sqlite3VdbeMemSetNull(pCtx.pOut);
		}
		public static void sqlite3_result_pointer(sqlite3_context pCtx, void* pPtr, sbyte* zPType, delegate17 xDestructor)
		{
			sqlite3_value pOut = pCtx.pOut;
			sqlite3VdbeMemRelease(pOut);
			pOut.flags = (ushort)(0x0001);
			sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
		}
		public static void sqlite3_result_subtype(sqlite3_context pCtx, uint eSubtype)
		{
			sqlite3_value pOut = pCtx.pOut;
			pOut.eSubtype = (byte)(eSubtype & 0xff);
			pOut.flags |= (ushort)(0x8000);
		}
		public static void sqlite3_result_text(sqlite3_context pCtx, sbyte* z, int n, delegate17 xDel)
		{
			setResultStrOrError(pCtx, z, (int)(n), (byte)(1), xDel);
		}
		public static void sqlite3_result_text16(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{
			setResultStrOrError(pCtx, z, (int)(n), (byte)(2), xDel);
		}
		public static void sqlite3_result_text16be(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{
			setResultStrOrError(pCtx, z, (int)(n), (byte)(3), xDel);
		}
		public static void sqlite3_result_text16le(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{
			setResultStrOrError(pCtx, z, (int)(n), (byte)(2), xDel);
		}
		public static void sqlite3_result_text64(sqlite3_context pCtx, sbyte* z, ulong n, delegate17 xDel, byte enc)
		{
			if ((enc) == (4))
				enc = (byte)(2);
			if ((n) > (0x7fffffff))
			{
				(void)(invokeValueDestructor(z, xDel, pCtx));
			}
			else
			{
				setResultStrOrError(pCtx, z, (int)(n), (byte)(enc), xDel);
			}
		}
		public static void sqlite3_result_value(sqlite3_context pCtx, sqlite3_value pValue)
		{
			sqlite3VdbeMemCopy(pCtx.pOut, pValue);
		}
		public static void sqlite3_result_zeroblob(sqlite3_context pCtx, int n)
		{
			sqlite3VdbeMemSetZeroBlob(pCtx.pOut, (int)(n));
		}
		public static int sqlite3_result_zeroblob64(sqlite3_context pCtx, ulong n)
		{
			sqlite3_value pOut = pCtx.pOut;
			if ((n) > ((ulong)(pOut.db.aLimit[0])))
			{
				return (int)(18);
			}

			sqlite3VdbeMemSetZeroBlob(pCtx.pOut, (int)(n));
			return (int)(0);
		}
		public static void sqlite3_set_auxdata(sqlite3_context pCtx, int iArg, void* pAux, delegate17 xDelete)
		{
			AuxData pAuxData;
			Vdbe pVdbe = pCtx.pVdbe;
			for (pAuxData = pVdbe.pAuxData; pAuxData; pAuxData = pAuxData.pNextAux)
			{
				if (((pAuxData.iAuxArg) == (iArg)) && (((pAuxData.iAuxOp) == (pCtx.iOp)) || ((iArg) < (0))))
				{
					break;
				}
			}

			if ((pAuxData) == (null))
			{
				pAuxData = sqlite3DbMallocZero(pVdbe.db, (ulong)(sizeof(AuxData)));
				if (pAuxData == null)
					goto failed;
				pAuxData.iAuxOp = (int)(pCtx.iOp);
				pAuxData.iAuxArg = (int)(iArg);
				pAuxData.pNextAux = pVdbe.pAuxData;
				pVdbe.pAuxData = pAuxData;
				if ((pCtx.isError) == (0))
					pCtx.isError = (int)(-1);
			}
			else if ((pAuxData.xDeleteAux) != null)
			{
				pAuxData.xDeleteAux(pAuxData.pAux);
			}

			pAuxData.pAux = pAux;
			pAuxData.xDeleteAux = xDelete;
			return;
		failed:
			; if ((xDelete) != null) { xDelete(pAux); }
		}
		public static int sqlite3_vtab_nochange(sqlite3_context p)
		{
			return (int)(sqlite3_value_nochange(p.pOut));
		}
		public static CollSeq sqlite3GetFuncCollSeq(sqlite3_context context)
		{
			VdbeOp* pOp;
			pOp = &context.pVdbe.aOp[context.iOp - 1];
			return pOp->p4.pColl;
		}
		public static void sqlite3InvalidFunction(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sbyte* zName = (sbyte*)(sqlite3_user_data(context));
			sbyte* zErr;
			zErr = sqlite3_mprintf("unable to use function %s in the requested context", zName);
			sqlite3_result_error(context, zErr, (int)(-1));
			sqlite3_free(zErr);
		}
		public static int sqlite3NotPureFunc(sqlite3_context pCtx)
		{
			VdbeOp* pOp;
			pOp = pCtx.pVdbe.aOp + pCtx.iOp;
			if ((pOp->opcode) == (65))
			{
				sbyte* zContext;
				sbyte* zMsg;
				if ((pOp->p5 & 0x000004) != 0)
				{
					zContext = "a CHECK constraint";
				}
				else if ((pOp->p5 & 0x000008) != 0)
				{
					zContext = "a generated column";
				}
				else
				{
					zContext = "an index";
				}

				zMsg = sqlite3_mprintf("non-deterministic use of %s() in %s", pCtx.pFunc.zName, zContext);
				sqlite3_result_error(pCtx, zMsg, (int)(-1));
				sqlite3_free(zMsg);
				return (int)(0);
			}

			return (int)(1);
		}
		public static void sqlite3ResultIntReal(sqlite3_context pCtx)
		{
			if ((pCtx.pOut.flags & 0x0004) != 0)
			{
				pCtx.pOut.flags &= (ushort)(~0x0004);
				pCtx.pOut.flags |= (ushort)(0x0020);
			}
		}
		public static void sqlite3ResultStrAccum(sqlite3_context pCtx, sqlite3_str p)
		{
			if ((p.accError) != 0)
			{
				sqlite3_result_error_code(pCtx, (int)(p.accError));
				sqlite3_str_reset(p);
			}
			else if ((((p).printfFlags & 0x04) != 0))
			{
				sqlite3_result_text(pCtx, p.zText, (int)(p.nChar), ((Void(Void * ))(sqlite3OomFault)));
			}
			else
			{
				sqlite3_result_text(pCtx, "", (int)(0), null);
				sqlite3_str_reset(p);
			}
		}
		public static void sqlite3SkipAccumulatorLoad(sqlite3_context context)
		{
			context.isError = (int)(-1);
			context.skipFlag = (byte)(1);
		}
		public static long sqlite3StmtCurrentTime(sqlite3_context p)
		{
			int rc = 0;
			long* piTime = &p.pVdbe.iCurrentTime;
			if ((*piTime) == (0))
			{
				rc = (int)(sqlite3OsCurrentTimeInt64(p.pOut.db.pVfs, piTime));
				if ((rc) != 0)
					*piTime = (long)(0);
			}

			return (long)(*piTime);
		}
		public static void statGet(sqlite3_context context, int argc, sqlite3_value argv)
		{
			StatAccum p = (StatAccum)(sqlite3_value_blob(argv[0]));
			{
				sqlite3_str sStat = new sqlite3_str();
				int i = 0;
				sqlite3StrAccumInit(sStat, null, null, (int)(0), (int)((p.nKeyCol + 1) * 100));
				sqlite3_str_appendf(sStat, "%llu", (ulong)((p.nSkipAhead) != 0 ? (ulong)(p.nEst) : (ulong)(p.nRow)));
				for (i = (int)(0); (i) < (p.nKeyCol); i++)
				{
					ulong nDistinct = (ulong)(p.current.anDLt[i] + 1);
					ulong iVal = (ulong)((p.nRow + nDistinct - 1) / nDistinct);
					sqlite3_str_appendf(sStat, " %llu", (ulong)(iVal));
				}

				sqlite3ResultStrAccum(context, sStat);
			}
		}
		public static void statInit(sqlite3_context context, int argc, sqlite3_value argv)
		{
			StatAccum p;
			int nCol = 0;
			int nKeyCol = 0;
			int nColUp = 0;
			int n = 0;
			sqlite3 db = sqlite3_context_db_handle(context);
			nCol = (int)(sqlite3_value_int(argv[0]));
			nColUp = (int)((sizeof(uint)) < (8) ? (nCol + 1) & ~1 : nCol);
			nKeyCol = (int)(sqlite3_value_int(argv[1]));
			n = (int)(sizeof(StatAccum) + sizeof(uint) * nColUp + sizeof(uint) * nColUp);
			p = sqlite3DbMallocZero(db, (ulong)(n));
			if ((p) == (null))
			{
				sqlite3_result_error_nomem(context);
				return;
			}

			p.db = db;
			p.nEst = (uint)(sqlite3_value_int64(argv[2]));
			p.nRow = (uint)(0);
			p.nLimit = (int)(sqlite3_value_int64(argv[3]));
			p.nCol = (int)(nCol);
			p.nKeyCol = (int)(nKeyCol);
			p.nSkipAhead = (byte)(0);
			p.current.anDLt = (uint*)(p[1]);
			p.current.anEq = &p.current.anDLt[nColUp];
			sqlite3_result_blob(context, p, (int)(sizeof(StatAccum)), statAccumDestructor);
		}
		public static void statPush(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int i = 0;
			StatAccum p = (StatAccum)(sqlite3_value_blob(argv[0]));
			int iChng = (int)(sqlite3_value_int(argv[1]));
			if ((p.nRow) == (0))
			{
				for (i = (int)(0); (i) < (p.nCol); i++)
				{
					p.current.anEq[i] = (uint)(1);
				}
			}
			else
			{
				for (i = (int)(0); (i) < (iChng); i++)
				{
					p.current.anEq[i]++;
				}

				for (i = (int)(iChng); (i) < (p.nCol); i++)
				{
					p.current.anDLt[i]++;
					p.current.anEq[i] = (uint)(1);
				}
			}

			p.nRow++;
			if (((p.nLimit) != 0) && ((p.nRow) > ((uint)(p.nLimit) * (p.nSkipAhead + 1))))
			{
				p.nSkipAhead++;
				sqlite3_result_int(context, ((p.current.anDLt[0]) > (0) ? 1 : 0));
			}
		}
		public static void strftimeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			ulong i = 0; ulong j = 0;
			sqlite3 db;
			sbyte* zFmt;
			sqlite3_str sRes = new sqlite3_str();
			if ((argc) == (0))
				return;
			zFmt = (sbyte*)(sqlite3_value_text(argv[0]));
			if (((zFmt) == (null)) || ((isDate(context, (int)(argc - 1), argv[1], &x)) != 0))
				return;
			db = sqlite3_context_db_handle(context);
			sqlite3StrAccumInit(sRes, null, null, (int)(0), (int)(db.aLimit[0]));
			computeJD(&x);
			computeYMD_HMS(&x);
			for (i = (ulong)(j = (ulong)(0)); zFmt[i]; i++)
			{
				if (zFmt[i] != 37)
					continue;
				if ((j) < (i))
					sqlite3_str_append(sRes, zFmt + j, (int)(i - j));
				i++;
				j = (ulong)(i + 1);
				switch (zFmt[i])
				{
					case 100:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.D));
							break;
						}

					case 102:
						{
							double s = (double)(x.s);
							if ((s) > (59.999))
								s = (double)(59.999);
							sqlite3_str_appendf(sRes, "%06.3f", (double)(s));
							break;
						}

					case 72:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.h));
							break;
						}

					case 87:
					case 106:
						{
							int nDay = 0;
							DateTime y = (DateTime)(x);
							y.validJD = (sbyte)(0);
							y.M = (int)(1);
							y.D = (int)(1);
							computeJD(&y);
							nDay = ((int)((x.iJD - y.iJD + 43200000) / 86400000));
							if ((zFmt[i]) == (87))
							{
								int wd = 0;
								wd = ((int)(((x.iJD + 43200000) / 86400000) % 7));
								sqlite3_str_appendf(sRes, "%02d", (int)((nDay + 7 - wd) / 7));
							}
							else
							{
								sqlite3_str_appendf(sRes, "%03d", (int)(nDay + 1));
							}

							break;
						}

					case 74:
						{
							sqlite3_str_appendf(sRes, "%.16g", (double)(x.iJD / 86400000.0));
							break;
						}

					case 109:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.M));
							break;
						}

					case 77:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.m));
							break;
						}

					case 115:
						{
							long iS = (long)(x.iJD / 1000 - 21086676 * (long)(10000));
							sqlite3_str_appendf(sRes, "%lld", (long)(iS));
							break;
						}

					case 83:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.s));
							break;
						}

					case 119:
						{
							sqlite3_str_appendchar(sRes, (int)(1), (sbyte)((sbyte)(((x.iJD + 129600000) / 86400000) % 7) + 48));
							break;
						}

					case 89:
						{
							sqlite3_str_appendf(sRes, "%04d", (int)(x.Y));
							break;
						}

					case 37:
						{
							sqlite3_str_appendchar(sRes, (int)(1), (sbyte)(37));
							break;
						}

					default:
						{
							sqlite3_str_reset(sRes);
							return;
						}
				}
			}

			if ((j) < (i))
				sqlite3_str_append(sRes, zFmt + j, (int)(i - j));
			sqlite3ResultStrAccum(context, sRes);
		}
		public static void substrFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* z;
			byte* z2;
			int len = 0;
			int p0type = 0;
			long p1 = 0; long p2 = 0;
			int negP2 = (int)(0);
			if (((sqlite3_value_type(argv[1])) == (5)) || (((argc) == (3)) && ((sqlite3_value_type(argv[2])) == (5))))
			{
				return;
			}

			p0type = (int)(sqlite3_value_type(argv[0]));
			p1 = (long)(sqlite3_value_int(argv[1]));
			if ((p0type) == (4))
			{
				len = (int)(sqlite3_value_bytes(argv[0]));
				z = sqlite3_value_blob(argv[0]);
				if ((z) == (null))
					return;
			}
			else
			{
				z = sqlite3_value_text(argv[0]);
				if ((z) == (null))
					return;
				len = (int)(0);
				if ((p1) < (0))
				{
					for (z2 = z; *z2; len++)
					{
						{
							if ((*(z2++)) >= (0xc0))
							{
								while ((*z2 & 0xc0) == (0x80))
								{
									z2++;
								}
							}
						}
					}
				}
			}

			if ((argc) == (3))
			{
				p2 = (long)(sqlite3_value_int(argv[2]));
				if ((p2) < (0))
				{
					p2 = (long)(-p2);
					negP2 = (int)(1);
				}
			}
			else
			{
				p2 = (long)(sqlite3_context_db_handle(context).aLimit[0]);
			}

			if ((p1) < (0))
			{
				p1 += (long)(len);
				if ((p1) < (0))
				{
					p2 += (long)(p1);
					if ((p2) < (0))
						p2 = (long)(0);
					p1 = (long)(0);
				}
			}
			else if ((p1) > (0))
			{
				p1--;
			}
			else if ((p2) > (0))
			{
				p2--;
			}

			if ((negP2) != 0)
			{
				p1 -= (long)(p2);
				if ((p1) < (0))
				{
					p2 += (long)(p1);
					p1 = (long)(0);
				}
			}

			if (p0type != 4)
			{
				while (((*z) != 0) && ((p1) != 0))
				{
					{
						if ((*(z++)) >= (0xc0))
						{
							while ((*z & 0xc0) == (0x80))
							{
								z++;
							}
						}
					}

					p1--;
				}

				for (z2 = z; ((*z2) != 0) && ((p2) != 0); p2--)
				{
					{
						if ((*(z2++)) >= (0xc0))
						{
							while ((*z2 & 0xc0) == (0x80))
							{
								z2++;
							}
						}
					}
				}

				sqlite3_result_text64(context, (sbyte*)(z), (ulong)(z2 - z), ((Void(Void * ))(-1)), (byte)(1));
			}
			else
			{
				if ((p1 + p2) > (len))
				{
					p2 = (long)(len - p1);
					if ((p2) < (0))
						p2 = (long)(0);
				}

				sqlite3_result_blob64(context, (sbyte*)(&z[p1]), (ulong)(p2), ((Void(Void * ))(-1)));
			}
		}
		public static void subtypeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sqlite3_result_int(context, (int)(sqlite3_value_subtype(argv[0])));
		}
		public static void sumFinalize(sqlite3_context context)
		{
			SumCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			if (((p) != null) && ((p->cnt) > (0)))
			{
				if ((p->overflow) != 0)
				{
					sqlite3_result_error(context, "integer overflow", (int)(-1));
				}
				else if ((p->approx) != 0)
				{
					sqlite3_result_double(context, (double)(p->rSum));
				}
				else
				{
					sqlite3_result_int64(context, (long)(p->iSum));
				}
			}
		}
		public static void sumInverse(sqlite3_context context, int argc, sqlite3_value argv)
		{
			SumCtx* p;
			int type = 0;
			p = sqlite3_aggregate_context(context, (int)(sizeof(SumCtx)));
			type = (int)(sqlite3_value_numeric_type(argv[0]));
			if (((p) != null) && (type != 5))
			{
				p->cnt--;
				if (((type) == (1)) && ((p->approx) == (0)))
				{
					long v = (long)(sqlite3_value_int64(argv[0]));
					p->rSum -= (double)(v);
					p->iSum -= (long)(v);
				}
				else
				{
					p->rSum -= (double)(sqlite3_value_double(argv[0]));
				}
			}
		}
		public static void sumStep(sqlite3_context context, int argc, sqlite3_value argv)
		{
			SumCtx* p;
			int type = 0;
			p = sqlite3_aggregate_context(context, (int)(sizeof(SumCtx)));
			type = (int)(sqlite3_value_numeric_type(argv[0]));
			if (((p) != null) && (type != 5))
			{
				p->cnt++;
				if ((type) == (1))
				{
					long v = (long)(sqlite3_value_int64(argv[0]));
					p->rSum += (double)(v);
					if (((p->approx | p->overflow) == (0)) && ((sqlite3AddInt64(&p->iSum, (long)(v))) != 0))
					{
						p->approx = (byte)(p->overflow = (byte)(1));
					}
				}
				else
				{
					p->rSum += (double)(sqlite3_value_double(argv[0]));
					p->approx = (byte)(1);
				}
			}
		}
		public static void timeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				int s = 0;
				sbyte* zBuf = stackalloc sbyte[16];
				computeHMS(&x);
				zBuf[0] = (sbyte)(48 + (x.h / 10) % 10);
				zBuf[1] = (sbyte)(48 + (x.h) % 10);
				zBuf[2] = (sbyte)(58);
				zBuf[3] = (sbyte)(48 + (x.m / 10) % 10);
				zBuf[4] = (sbyte)(48 + (x.m) % 10);
				zBuf[5] = (sbyte)(58);
				s = ((int)(x.s));
				zBuf[6] = (sbyte)(48 + (s / 10) % 10);
				zBuf[7] = (sbyte)(48 + (s) % 10);
				zBuf[8] = (sbyte)(0);
				sqlite3_result_text(context, zBuf, (int)(8), ((Void(Void * ))(-1)));
			}
		}
		public static void total_changes(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sqlite3_result_int64(context, (long)(sqlite3_total_changes64(db)));
		}
		public static void totalFinalize(sqlite3_context context)
		{
			SumCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			sqlite3_result_double(context, (double)(p ? p->rSum : (double)(0)));
		}
		public static void trimFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zIn;
			byte* zCharSet;
			uint nIn = 0;
			int flags = 0;
			int i = 0;
			uint* aLen = null;
			byte** azChar = null;
			int nChar = 0;
			if ((sqlite3_value_type(argv[0])) == (5))
			{
				return;
			}

			zIn = sqlite3_value_text(argv[0]);
			if ((zIn) == (null))
				return;
			nIn = ((uint)(sqlite3_value_bytes(argv[0])));
			if ((argc) == (1))
			{
				nChar = (int)(1);
				aLen = trimFunc_lenOne;
				azChar = trimFunc_azOne;
				zCharSet = null;
			}
			else if ((zCharSet = sqlite3_value_text(argv[1])) == (null))
			{
				return;
			}
			else
			{
				byte* z;
				for (z = zCharSet, nChar = (int)(0); *z; nChar++)
				{
					{
						if ((*(z++)) >= (0xc0))
						{
							while ((*z & 0xc0) == (0x80))
							{
								z++;
							}
						}
					}
				}

				if ((nChar) > (0))
				{
					azChar = contextMalloc(context, (long)(((long)(nChar)) * (sizeof(char*) + sizeof(unsigned))));
					if ((azChar) == (null))
					{
						return;
					}

					aLen = (uint*)(&azChar[nChar]);
					for (z = zCharSet, nChar = (int)(0); *z; nChar++)
					{
						azChar[nChar] = z;
						{
							if ((*(z++)) >= (0xc0))
							{
								while ((*z & 0xc0) == (0x80))
								{
									z++;
								}
							}
						}

						aLen[nChar] = ((uint)(z - azChar[nChar]));
					}
				}
			}

			if ((nChar) > (0))
			{
				flags = ((int)((long)(sqlite3_user_data(context))));
				if ((flags & 1) != 0)
				{
					while ((nIn) > (0))
					{
						uint len = (uint)(0);
						for (i = (int)(0); (i) < (nChar); i++)
						{
							len = (uint)(aLen[i]);
							if (((len) <= (nIn)) && ((memcmp(zIn, azChar[i], (ulong)(len))) == (0)))
								break;
						}

						if ((i) >= (nChar))
							break;
						zIn += len;
						nIn -= (uint)(len);
					}
				}

				if ((flags & 2) != 0)
				{
					while ((nIn) > (0))
					{
						uint len = (uint)(0);
						for (i = (int)(0); (i) < (nChar); i++)
						{
							len = (uint)(aLen[i]);
							if (((len) <= (nIn)) && ((memcmp(&zIn[nIn - len], azChar[i], (ulong)(len))) == (0)))
								break;
						}

						if ((i) >= (nChar))
							break;
						nIn -= (uint)(len);
					}
				}

				if ((zCharSet) != null)
				{
					sqlite3_free(azChar);
				}
			}

			sqlite3_result_text(context, (sbyte*)(zIn), (int)(nIn), ((Void(Void * ))(-1)));
		}
		public static void typeofFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			int i = (int)(sqlite3_value_type(argv[0]) - 1);
			sqlite3_result_text(context, typeofFunc_azType[i], (int)(-1), null);
		}
		public static void unicodeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* z = sqlite3_value_text(argv[0]);
			(void)(argc);
			if (((z) != null) && ((z[0]) != 0))
				sqlite3_result_int(context, (int)(sqlite3Utf8Read(&z)));
		}
		public static void unixepochFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				computeJD(&x);
				sqlite3_result_int64(context, (long)(x.iJD / 1000 - 21086676 * (long)(10000)));
			}
		}
		public static void upperFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* z1;
			sbyte* z2;
			int i = 0; int n = 0;
			z2 = (sbyte*)(sqlite3_value_text(argv[0]));
			n = (int)(sqlite3_value_bytes(argv[0]));
			if ((z2) != null)
			{
				z1 = contextMalloc(context, (long)(((long)(n)) + 1));
				if ((z1) != null)
				{
					for (i = (int)(0); (i) < (n); i++)
					{
						z1[i] = ((sbyte)((z2[i]) & ~(sqlite3CtypeMap[(byte)(z2[i])] & 0x20)));
					}

					sqlite3_result_text(context, z1, (int)(n), sqlite3_free);
				}
			}
		}
		public static void versionFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3_result_text(context, sqlite3_libversion(), (int)(-1), null);
		}
		public static void zeroblobFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			long n = 0;
			int rc = 0;
			n = (long)(sqlite3_value_int64(argv[0]));
			if ((n) < (0))
				n = (long)(0);
			rc = (int)(sqlite3_result_zeroblob64(context, (ulong)(n)));
			if ((rc) != 0)
			{
				sqlite3_result_error_code(context, (int)(rc));
			}
		}
	}
}