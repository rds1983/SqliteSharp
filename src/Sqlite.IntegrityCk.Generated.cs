// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void checkAppendMsg(IntegrityCk pCheck, sbyte* zFormat)
		{
			sbyte* ap;
			if (pCheck.mxErr == 0)
				return;
			pCheck.mxErr--;
			pCheck.nErr++;
			(__va_start(&ap, zFormat));
			if ((pCheck.errMsg.nChar) != 0)
			{
				sqlite3_str_append(pCheck.errMsg, "\n", (int)(1));
			}

			if ((pCheck.zPfx) != null)
			{
				sqlite3_str_appendf(pCheck.errMsg, pCheck.zPfx, (uint)(pCheck.v1), (int)(pCheck.v2));
			}

			sqlite3_str_vappendf(pCheck.errMsg, zFormat, ap);
			((void)(ap = null));
			if ((pCheck.errMsg.accError) == (7))
			{
				pCheck.bOomFault = (int)(1);
			}
		}
		public static void checkList(IntegrityCk pCheck, int isFreeList, uint iPage, uint N)
		{
			int i = 0;
			uint expected = (uint)(N);
			int nErrAtStart = (int)(pCheck.nErr);
			while ((iPage != 0) && ((pCheck.mxErr) != 0))
			{
				PgHdr pOvflPage;
				byte* pOvflData;
				if ((checkRef(pCheck, (uint)(iPage))) != 0)
					break;
				N--;
				if ((sqlite3PagerGet(pCheck.pPager, (uint)(iPage), pOvflPage, (int)(0))) != 0)
				{
					checkAppendMsg(pCheck, "failed to get page %d", (uint)(iPage));
					break;
				}

				pOvflData = (byte*)(sqlite3PagerGetData(pOvflPage));
				if ((isFreeList) != 0)
				{
					uint n = (uint)(sqlite3Get4byte(&pOvflData[4]));
					if ((pCheck.pBt.autoVacuum) != 0)
					{
						checkPtrmap(pCheck, (uint)(iPage), (byte)(2), (uint)(0));
					}

					if ((n) > (pCheck.pBt.usableSize / 4 - 2))
					{
						checkAppendMsg(pCheck, "freelist leaf count too big on page %d", (uint)(iPage));
						N--;
					}
					else
					{
						for (i = (int)(0); (i) < ((int)(n)); i++)
						{
							uint iFreePage = (uint)(sqlite3Get4byte(&pOvflData[8 + i * 4]));
							if ((pCheck.pBt.autoVacuum) != 0)
							{
								checkPtrmap(pCheck, (uint)(iFreePage), (byte)(2), (uint)(0));
							}

							checkRef(pCheck, (uint)(iFreePage));
						}

						N -= (uint)(n);
					}
				}
				else
				{
					if (((pCheck.pBt.autoVacuum) != 0) && ((N) > (0)))
					{
						i = (int)(sqlite3Get4byte(pOvflData));
						checkPtrmap(pCheck, (uint)(i), (byte)(4), (uint)(iPage));
					}
				}

				iPage = (uint)(sqlite3Get4byte(pOvflData));
				sqlite3PagerUnref(pOvflPage);
			}

			if (((N) != 0) && ((nErrAtStart) == (pCheck.nErr)))
			{
				checkAppendMsg(pCheck, "%s is %d but should be %d", (isFreeList) != 0 ? "size" : "overflow list length", (uint)(expected - N), (uint)(expected));
			}
		}
		public static void checkPtrmap(IntegrityCk pCheck, uint iChild, byte eType, uint iParent)
		{
			int rc = 0;
			byte ePtrmapType = 0;
			uint iPtrmapParent = 0;
			rc = (int)(ptrmapGet(pCheck.pBt, (uint)(iChild), &ePtrmapType, &iPtrmapParent));
			if (rc != 0)
			{
				if (((rc) == (7)) || ((rc) == (10 | (12 << 8))))
					pCheck.bOomFault = (int)(1);
				checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", (uint)(iChild));
				return;
			}

			if ((ePtrmapType != eType) || (iPtrmapParent != iParent))
			{
				checkAppendMsg(pCheck, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", (uint)(iChild), (int)(eType), (uint)(iParent), (int)(ePtrmapType), (uint)(iPtrmapParent));
			}
		}
		public static int checkRef(IntegrityCk pCheck, uint iPage)
		{
			if (((iPage) > (pCheck.nPage)) || ((iPage) == (0)))
			{
				checkAppendMsg(pCheck, "invalid page number %d", (uint)(iPage));
				return (int)(1);
			}

			if ((getPageReferenced(pCheck, (uint)(iPage))) != 0)
			{
				checkAppendMsg(pCheck, "2nd reference to page %d", (uint)(iPage));
				return (int)(1);
			}

			if ((0) != 0)
				return (int)(1);
			setPageReferenced(pCheck, (uint)(iPage));
			return (int)(0);
		}
		public static int checkTreePage(IntegrityCk pCheck, uint iPage, long* piMinKey, long maxKey)
		{
			MemPage pPage = null;
			int i = 0;
			int rc = 0;
			int depth = (int)(-1); int d2 = 0;
			int pgno = 0;
			int nFrag = 0;
			int hdr = 0;
			int cellStart = 0;
			int nCell = 0;
			int doCoverageCheck = (int)(1);
			int keyCanBeEqual = (int)(1);
			byte* data;
			byte* pCell;
			byte* pCellIdx;
			BtShared pBt;
			uint pc = 0;
			uint usableSize = 0;
			uint contentOffset = 0;
			uint* heap = null;
			uint x = 0; uint prev = (uint)(0);
			sbyte* saved_zPfx = pCheck.zPfx;
			int saved_v1 = (int)(pCheck.v1);
			int saved_v2 = (int)(pCheck.v2);
			byte savedIsInit = (byte)(0);
			pBt = pCheck.pBt;
			usableSize = (uint)(pBt.usableSize);
			if ((iPage) == (0))
				return (int)(0);
			if ((checkRef(pCheck, (uint)(iPage))) != 0)
				return (int)(0);
			pCheck.zPfx = "Page %u: ";
			pCheck.v1 = (uint)(iPage);
			if ((rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0)))) != 0)
			{
				checkAppendMsg(pCheck, "unable to get the page. error code=%d", (int)(rc));
				goto end_of_check;
			}

			savedIsInit = (byte)(pPage.isInit);
			pPage.isInit = (byte)(0);
			if ((rc = (int)(btreeInitPage(pPage))) != 0)
			{
				checkAppendMsg(pCheck, "btreeInitPage() returns error code %d", (int)(rc));
				goto end_of_check;
			}

			if ((rc = (int)(btreeComputeFreeSpace(pPage))) != 0)
			{
				checkAppendMsg(pCheck, "free space corruption", (int)(rc));
				goto end_of_check;
			}

			data = pPage.aData;
			hdr = (int)(pPage.hdrOffset);
			pCheck.zPfx = "On tree page %u cell %d: ";
			contentOffset = (uint)(((((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]) - 1) & 0xffff) + 1);
			nCell = (int)((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]);
			cellStart = (int)(hdr + 12 - 4 * pPage.leaf);
			pCellIdx = &data[cellStart + 2 * (nCell - 1)];
			if (pPage.leaf == 0)
			{
				pgno = (int)(sqlite3Get4byte(&data[hdr + 8]));
				if ((pBt.autoVacuum) != 0)
				{
					pCheck.zPfx = "On page %u at right child: ";
					checkPtrmap(pCheck, (uint)(pgno), (byte)(5), (uint)(iPage));
				}

				depth = (int)(checkTreePage(pCheck, (uint)(pgno), &maxKey, (long)(maxKey)));
				keyCanBeEqual = (int)(0);
			}
			else
			{
				heap = pCheck.heap;
				heap[0] = (uint)(0);
			}

			for (i = (int)(nCell - 1); ((i) >= (0)) && ((pCheck.mxErr) != 0); i--)
			{
				CellInfo info = new CellInfo();
				pCheck.v2 = (int)(i);
				pc = (uint)(_byteswap_ushort((ushort)(*(ushort*)(pCellIdx))));
				pCellIdx -= 2;
				if (((pc) < (contentOffset)) || ((pc) > (usableSize - 4)))
				{
					checkAppendMsg(pCheck, "Offset %d out of range %d..%d", (uint)(pc), (uint)(contentOffset), (uint)(usableSize - 4));
					doCoverageCheck = (int)(0);
					continue;
				}

				pCell = &data[pc];
				pPage.xParseCell(pPage, pCell, &info);
				if ((pc + info.nSize) > (usableSize))
				{
					checkAppendMsg(pCheck, "Extends off end of page");
					doCoverageCheck = (int)(0);
					continue;
				}

				if ((pPage.intKey) != 0)
				{
					if (((keyCanBeEqual) != 0 ? ((info.nKey) > (maxKey)) : ((info.nKey) >= (maxKey))) != 0)
					{
						checkAppendMsg(pCheck, "Rowid %lld out of order", (long)(info.nKey));
					}

					maxKey = (long)(info.nKey);
					keyCanBeEqual = (int)(0);
				}

				if ((info.nPayload) > (info.nLocal))
				{
					uint nPage = 0;
					uint pgnoOvfl = 0;
					nPage = (uint)((info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4));
					pgnoOvfl = (uint)(sqlite3Get4byte(&pCell[info.nSize - 4]));
					if ((pBt.autoVacuum) != 0)
					{
						checkPtrmap(pCheck, (uint)(pgnoOvfl), (byte)(3), (uint)(iPage));
					}

					checkList(pCheck, (int)(0), (uint)(pgnoOvfl), (uint)(nPage));
				}

				if (pPage.leaf == 0)
				{
					pgno = (int)(sqlite3Get4byte(pCell));
					if ((pBt.autoVacuum) != 0)
					{
						checkPtrmap(pCheck, (uint)(pgno), (byte)(5), (uint)(iPage));
					}

					d2 = (int)(checkTreePage(pCheck, (uint)(pgno), &maxKey, (long)(maxKey)));
					keyCanBeEqual = (int)(0);
					if (d2 != depth)
					{
						checkAppendMsg(pCheck, "Child page depth differs");
						depth = (int)(d2);
					}
				}
				else
				{
					btreeHeapInsert(heap, (uint)((pc << 16) | (pc + info.nSize - 1)));
				}
			}

			*piMinKey = (long)(maxKey);
			pCheck.zPfx = null;
			if (((doCoverageCheck) != 0) && ((pCheck.mxErr) > (0)))
			{
				if (pPage.leaf == 0)
				{
					heap = pCheck.heap;
					heap[0] = (uint)(0);
					for (i = (int)(nCell - 1); (i) >= (0); i--)
					{
						uint size = 0;
						pc = (uint)(_byteswap_ushort((ushort)(*(ushort*)(&data[cellStart + i * 2]))));
						size = (uint)(pPage.xCellSize(pPage, &data[pc]));
						btreeHeapInsert(heap, (uint)((pc << 16) | (pc + size - 1)));
					}
				}

				i = (int)((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);
				while ((i) > (0))
				{
					int size = 0;
					int j = 0;
					size = (int)((&data[i + 2])[0] << 8 | (&data[i + 2])[1]);
					btreeHeapInsert(heap, (uint)((((uint)(i)) << 16) | (i + size - 1)));
					j = (int)((&data[i])[0] << 8 | (&data[i])[1]);
					i = (int)(j);
				}

				nFrag = (int)(0);
				prev = (uint)(contentOffset - 1);
				while ((btreeHeapPull(heap, &x)) != 0)
				{
					if ((prev & 0xffff) >= (x >> 16))
					{
						checkAppendMsg(pCheck, "Multiple uses for byte %u of page %u", (uint)(x >> 16), (uint)(iPage));
						break;
					}
					else
					{
						nFrag += (int)((x >> 16) - (prev & 0xffff) - 1);
						prev = (uint)(x);
					}
				}

				nFrag += (int)(usableSize - (prev & 0xffff) - 1);
				if (((heap[0]) == (0)) && (nFrag != data[hdr + 7]))
				{
					checkAppendMsg(pCheck, "Fragmentation of %d bytes reported as %d on page %u", (int)(nFrag), (int)(data[hdr + 7]), (uint)(iPage));
				}
			}

		end_of_check:
			; if (doCoverageCheck == 0) pPage.isInit = (byte)(savedIsInit);
			releasePage(pPage);
			pCheck.zPfx = saved_zPfx;
			pCheck.v1 = (uint)(saved_v1);
			pCheck.v2 = (int)(saved_v2);
			return (int)(depth + 1);
		}
		public static int getPageReferenced(IntegrityCk pCheck, uint iPg)
		{
			return (int)(pCheck.aPgRef[iPg / 8] & (1 << (iPg & 0x07)));
		}
		public static void setPageReferenced(IntegrityCk pCheck, uint iPg)
		{
			pCheck.aPgRef[iPg / 8] |= (byte)(1 << (iPg & 0x07));
		}
	}
}