// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static ushort cachedCellSize(CellArray p, int N)
		{
			if ((p.szCell[N]) != 0)
				return (ushort)(p.szCell[N]);
			return (ushort)(computeCellSize(p, (int)(N)));
		}
		public static ushort computeCellSize(CellArray p, int N)
		{
			p.szCell[N] = (ushort)(p.pRef.xCellSize(p.pRef, p.apCell[N]));
			return (ushort)(p.szCell[N]);
		}
		public static void populateCellCache(CellArray p, int idx, int N)
		{
			while ((N) > (0))
			{
				if ((p.szCell[idx]) == (0))
				{
					p.szCell[idx] = (ushort)(p.pRef.xCellSize(p.pRef, p.apCell[idx]));
				}
				else
				{
				}

				idx++;
				N--;
			}
		}
		public static int rebuildPage(CellArray pCArray, int iFirst, int nCell, MemPage pPg)
		{
			int hdr = (int)(pPg.hdrOffset);
			byte* aData = pPg.aData;
			int usableSize = (int)(pPg.pBt.usableSize);
			byte* pEnd = &aData[usableSize];
			int i = (int)(iFirst);
			uint j = 0;
			int iEnd = (int)(i + nCell);
			byte* pCellptr = pPg.aCellIdx;
			byte* pTmp = sqlite3PagerTempSpace(pPg.pBt.pPager);
			byte* pData;
			int k = 0;
			byte* pSrcEnd;
			j = (uint)((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1]);
			if ((j) > ((uint)(usableSize)))
			{
				j = (uint)(0);
			}

			CRuntime.memcpy(&pTmp[j], &aData[j], (ulong)(usableSize - j));
			for (k = (int)(0); ((pCArray.ixNx[k]) <= (i)) && ((k) < (3 * 2)); k++)
			{
			}

			pSrcEnd = pCArray.apEnd[k];
			pData = pEnd;
			while ((1) != 0)
			{
				byte* pCell = pCArray.apCell[i];
				ushort sz = (ushort)(pCArray.szCell[i]);
				if (((((ulong)(pCell)) >= ((ulong)(aData + j))) && (((ulong)(pCell)) < ((ulong)(pEnd)))))
				{
					if (((ulong)(pCell + sz)) > ((ulong)(pEnd)))
						return (int)(sqlite3CorruptError((int)(73321)));
					pCell = &pTmp[pCell - aData];
				}
				else if ((((ulong)(pCell + sz)) > ((ulong)(pSrcEnd))) && (((ulong)(pCell)) < ((ulong)(pSrcEnd))))
				{
					return (int)(sqlite3CorruptError((int)(73326)));
				}

				pData -= sz;
				((pCellptr)[0] = ((byte)((pData - aData) >> 8)), (pCellptr)[1] = ((byte)(pData - aData)));
				pCellptr += 2;
				if ((pData) < (pCellptr))
					return (int)(sqlite3CorruptError((int)(73332)));
				CRuntime.memmove(pData, pCell, (ulong)(sz));
				i++;
				if ((i) >= (iEnd))
					break;
				if ((pCArray.ixNx[k]) <= (i))
				{
					k++;
					pSrcEnd = pCArray.apEnd[k];
				}
			}

			pPg.nCell = (ushort)(nCell);
			pPg.nOverflow = (byte)(0);
			((&aData[hdr + 1])[0] = ((byte)((0) >> 8)), (&aData[hdr + 1])[1] = ((byte)(0)));
			((&aData[hdr + 3])[0] = ((byte)((pPg.nCell) >> 8)), (&aData[hdr + 3])[1] = ((byte)(pPg.nCell)));
			((&aData[hdr + 5])[0] = ((byte)((pData - aData) >> 8)), (&aData[hdr + 5])[1] = ((byte)(pData - aData)));
			aData[hdr + 7] = (byte)(0x00);
			return (int)(0);
		}
	}
}