// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void whereLoopAdjustCost(WhereLoop p, WhereLoop pTemplate)
		{
			if ((pTemplate.wsFlags & 0x00000200) == (0))
				return;
			for (p; ; p = p.pNextLoop)
			{
				if (p.iTab != pTemplate.iTab)
					continue;
				if ((p.wsFlags & 0x00000200) == (0))
					continue;
				if ((whereLoopCheaperProperSubset(p, pTemplate)) != 0)
				{
					pTemplate.rRun = (short)((p.rRun) < (pTemplate.rRun) ? (p.rRun) : (pTemplate.rRun));
					pTemplate.nOut = (short)((p.nOut - 1) < (pTemplate.nOut) ? (p.nOut - 1) : (pTemplate.nOut));
				}
				else if ((whereLoopCheaperProperSubset(pTemplate, p)) != 0)
				{
					pTemplate.rRun = (short)((p.rRun) > (pTemplate.rRun) ? (p.rRun) : (pTemplate.rRun));
					pTemplate.nOut = (short)((p.nOut + 1) > (pTemplate.nOut) ? (p.nOut + 1) : (pTemplate.nOut));
				}
			}
		}
		public static int whereLoopCheaperProperSubset(WhereLoop pX, WhereLoop pY)
		{
			int i = 0; int j = 0;
			if ((pX.nLTerm - pX.nSkip) >= (pY.nLTerm - pY.nSkip))
			{
				return (int)(0);
			}

			if (((pX.rRun) > (pY.rRun)) && ((pX.nOut) > (pY.nOut)))
				return (int)(0);
			if ((pY.nSkip) > (pX.nSkip))
				return (int)(0);
			for (i = (int)(pX.nLTerm - 1); (i) >= (0); i--)
			{
				if ((pX.aLTerm[i]) == (null))
					continue;
				for (j = (int)(pY.nLTerm - 1); (j) >= (0); j--)
				{
					if ((pY.aLTerm[j]) == (pX.aLTerm[i]))
						break;
				}

				if ((j) < (0))
					return (int)(0);
			}

			if (((pX.wsFlags & 0x00000040) != 0) && ((pY.wsFlags & 0x00000040) == (0)))
			{
				return (int)(0);
			}

			return (int)(1);
		}
		public static WhereLoop whereLoopFindLesser(WhereLoop ppPrev, WhereLoop pTemplate)
		{
			WhereLoop p;
			for (p = (ppPrev); p; ppPrev = p.pNextLoop, p = ppPrev)
			{
				if ((p.iTab != pTemplate.iTab) || (p.iSortIdx != pTemplate.iSortIdx))
				{
					continue;
				}

				if ((((((p.wsFlags & 0x00004000) != 0) && ((pTemplate.nSkip) == (0))) && ((pTemplate.wsFlags & 0x00000200) != 0)) && ((pTemplate.wsFlags & 0x00000001) != 0)) && ((p.prereq & pTemplate.prereq) == (pTemplate.prereq)))
				{
					break;
				}

				if (((((p.prereq & pTemplate.prereq) == (p.prereq)) && ((p.rSetup) <= (pTemplate.rSetup))) && ((p.rRun) <= (pTemplate.rRun))) && ((p.nOut) <= (pTemplate.nOut)))
				{
					return null;
				}

				if ((((p.prereq & pTemplate.prereq) == (pTemplate.prereq)) && ((p.rRun) >= (pTemplate.rRun))) && ((p.nOut) >= (pTemplate.nOut)))
				{
					break;
				}
			}

			return ppPrev;
		}
		public static void whereLoopInit(WhereLoop p)
		{
			p.aLTerm = p.aLTermSpace;
			p.nLTerm = (ushort)(0);
			p.nLSlot = (ushort)((int)(3 * sizeof(WhereTerm) / sizeof(WhereTerm)));
			p.wsFlags = (uint)(0);
		}
	}
}