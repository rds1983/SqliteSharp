// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int vdbeSorterFlushPMA(VdbeSorter pSorter)
		{
			int rc = (int)(0);
			int i = 0;
			SortSubtask pTask = null;
			int nWorker = (int)(pSorter.nTask - 1);
			pSorter.bUsePMA = (byte)(1);
			for (i = (int)(0); (i) < (nWorker); i++)
			{
				int iTest = (int)((pSorter.iPrev + i + 1) % nWorker);
				pTask = pSorter.aTask[iTest];
				if ((pTask.bDone) != 0)
				{
					rc = (int)(vdbeSorterJoinThread(pTask));
				}

				if ((rc != 0) || ((pTask.pThread) == (null)))
					break;
			}

			if ((rc) == (0))
			{
				if ((i) == (nWorker))
				{
					rc = (int)(vdbeSorterListToPMA(pSorter.aTask[nWorker], &pSorter.list));
				}
				else
				{
					byte* aMem;
					void* pCtx;
					aMem = pTask.list.aMemory;
					pCtx = (void*)(pTask);
					pSorter.iPrev = ((byte)(pTask - pSorter.aTask));
					pTask.list = (SorterList)(pSorter.list);
					pSorter.list.pList = null;
					pSorter.list.szPMA = (int)(0);
					if ((aMem) != null)
					{
						pSorter.list.aMemory = aMem;
						pSorter.nMemory = (int)(sqlite3MallocSize(aMem));
					}
					else if ((pSorter.list.aMemory) != null)
					{
						pSorter.list.aMemory = sqlite3Malloc((ulong)(pSorter.nMemory));
						if (pSorter.list.aMemory == null)
							return (int)(7);
					}

					rc = (int)(vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx));
				}
			}

			return (int)(rc);
		}
		public static int vdbeSorterJoinAll(VdbeSorter pSorter, int rcin)
		{
			int rc = (int)(rcin);
			int i = 0;
			for (i = (int)(pSorter.nTask - 1); (i) >= (0); i--)
			{
				SortSubtask pTask = pSorter.aTask[i];
				int rc2 = (int)(vdbeSorterJoinThread(pTask));
				if ((rc) == (0))
					rc = (int)(rc2);
			}

			return (int)(rc);
		}
		public static int vdbeSorterMergeTreeBuild(VdbeSorter pSorter, MergeEngine ppOut)
		{
			MergeEngine pMain = null;
			int rc = (int)(0);
			int iTask = 0;
			if ((pSorter.nTask) > (1))
			{
				pMain = vdbeMergeEngineNew((int)(pSorter.nTask));
				if ((pMain) == (null))
					rc = (int)(7);
			}

			for (iTask = (int)(0); ((rc) == (0)) && ((iTask) < (pSorter.nTask)); iTask++)
			{
				SortSubtask pTask = pSorter.aTask[iTask];
				if (((8) == (0)) || ((pTask.nPMA) != 0))
				{
					MergeEngine pRoot = null;
					int nDepth = (int)(vdbeSorterTreeDepth((int)(pTask.nPMA)));
					long iReadOff = (long)(0);
					if ((pTask.nPMA) <= (16))
					{
						rc = (int)(vdbeMergeEngineLevel0(pTask, (int)(pTask.nPMA), &iReadOff, pRoot));
					}
					else
					{
						int i = 0;
						int iSeq = (int)(0);
						pRoot = vdbeMergeEngineNew((int)(16));
						if ((pRoot) == (null))
							rc = (int)(7);
						for (i = (int)(0); ((i) < (pTask.nPMA)) && ((rc) == (0)); i += (int)(16))
						{
							MergeEngine pMerger = null;
							int nReader = 0;
							nReader = (int)((pTask.nPMA - i) < (16) ? (pTask.nPMA - i) : (16));
							rc = (int)(vdbeMergeEngineLevel0(pTask, (int)(nReader), &iReadOff, pMerger));
							if ((rc) == (0))
							{
								rc = (int)(vdbeSorterAddToTree(pTask, (int)(nDepth), (int)(iSeq++), pRoot, pMerger));
							}
						}
					}

					if ((rc) == (0))
					{
						if (pMain != null)
						{
							rc = (int)(vdbeIncrMergerNew(pTask, pRoot, pMain.aReadr[iTask].pIncr));
						}
						else
						{
							pMain = pRoot;
						}
					}
					else
					{
						vdbeMergeEngineFree(pRoot);
					}
				}
			}

			if (rc != 0)
			{
				vdbeMergeEngineFree(pMain);
				pMain = null;
			}

			ppOut = pMain;
			return (int)(rc);
		}
		public static int vdbeSorterSetupMerge(VdbeSorter pSorter)
		{
			int rc = 0;
			SortSubtask pTask0 = pSorter.aTask[0];
			MergeEngine pMain = null;
			sqlite3 db = pTask0.pSorter.db;
			int i = 0;
			delegate80 xCompare = vdbeSorterGetCompare(pSorter);
			for (i = (int)(0); (i) < (pSorter.nTask); i++)
			{
				pSorter.aTask[i].xCompare = xCompare;
			}

			rc = (int)(vdbeSorterMergeTreeBuild(pSorter, pMain));
			if ((rc) == (0))
			{
				if ((pSorter.bUseThreads) != 0)
				{
					int iTask = 0;
					PmaReader pReadr = null;
					SortSubtask pLast = pSorter.aTask[pSorter.nTask - 1];
					rc = (int)(vdbeSortAllocUnpacked(pLast));
					if ((rc) == (0))
					{
						pReadr = (PmaReader)(sqlite3DbMallocZero(db, (ulong)(sizeof(PmaReader))));
						pSorter.pReader = pReadr;
						if ((pReadr) == (null))
							rc = (int)(7);
					}

					if ((rc) == (0))
					{
						rc = (int)(vdbeIncrMergerNew(pLast, pMain, pReadr.pIncr));
						if ((rc) == (0))
						{
							vdbeIncrMergerSetThreads(pReadr.pIncr);
							for (iTask = (int)(0); (iTask) < (pSorter.nTask - 1); iTask++)
							{
								IncrMerger pIncr;
								if ((pIncr = pMain.aReadr[iTask].pIncr))
								{
									vdbeIncrMergerSetThreads(pIncr);
								}
							}

							for (iTask = (int)(0); ((rc) == (0)) && ((iTask) < (pSorter.nTask)); iTask++)
							{
								PmaReader p = pMain.aReadr[iTask];
								rc = (int)(vdbePmaReaderIncrInit(p, (int)(1)));
							}
						}

						pMain = null;
					}

					if ((rc) == (0))
					{
						rc = (int)(vdbePmaReaderIncrMergeInit(pReadr, (int)(2)));
					}
				}
				else
				{
					rc = (int)(vdbeMergeEngineInit(pTask0, pMain, (int)(0)));
					pSorter.pMerger = pMain;
					pMain = null;
				}
			}

			if (rc != 0)
			{
				vdbeMergeEngineFree(pMain);
			}

			return (int)(rc);
		}
	}
}