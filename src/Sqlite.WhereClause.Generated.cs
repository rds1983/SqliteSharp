// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void markTermAsChild(WhereClause pWC, int iChild, int iParent)
		{
			pWC.a[iChild].iParent = (int)(iParent);
			pWC.a[iChild].truthProb = (short)(pWC.a[iParent].truthProb);
			pWC.a[iParent].nChild++;
		}
		public static void sqlite3WhereAddLimit(WhereClause pWC, Select p)
		{
			if (((((p) != null) && ((p.pLimit) != null)) && ((p.selFlags & (0x0000001 | 0x0000008)) == (0))) && (((p.pSrc.nSrc) == (1)) && (((p.pSrc.a[0].pTab).eTabType) == (1))))
			{
				ExprList pOrderBy = p.pOrderBy;
				int iCsr = (int)(p.pSrc.a[0].iCursor);
				int ii = 0;
				for (ii = (int)(0); (ii) < (pWC.nTerm); ii++)
				{
					if ((pWC.a[ii].wtFlags & 0x0004) != 0)
					{
						continue;
					}

					if (pWC.a[ii].leftCursor != iCsr)
						return;
				}

				if ((pOrderBy) != null)
				{
					for (ii = (int)(0); (ii) < (pOrderBy.nExpr); ii++)
					{
						Expr pExpr = pOrderBy.a[ii].pExpr;
						if (pExpr.op != 167)
							return;
						if (pExpr.iTable != iCsr)
							return;
						if ((pOrderBy.a[ii].sortFlags & 0x02) != 0)
							return;
					}
				}

				whereAddLimitExpr(pWC, (int)(p.iLimit), p.pLimit.pLeft, (int)(iCsr), (int)(73));
				if ((p.iOffset) > (0))
				{
					whereAddLimitExpr(pWC, (int)(p.iOffset), p.pLimit.pRight, (int)(iCsr), (int)(74));
				}
			}
		}
		public static void sqlite3WhereClauseClear(WhereClause pWC)
		{
			sqlite3 db = pWC.pWInfo.pParse.db;
			if ((pWC.nTerm) > (0))
			{
				WhereTerm a = pWC.a;
				WhereTerm aLast = pWC.a[pWC.nTerm - 1];
				while ((1) != 0)
				{
					if ((a.wtFlags & 0x0001) != 0)
					{
						sqlite3ExprDelete(db, a.pExpr);
					}

					if ((a.wtFlags & (0x0010 | 0x0020)) != 0)
					{
						if ((a.wtFlags & 0x0010) != 0)
						{
							whereOrInfoDelete(db, a.u.pOrInfo);
						}
						else
						{
							whereAndInfoDelete(db, a.u.pAndInfo);
						}
					}

					if ((a) == (aLast))
						break;
					a++;
				}
			}

			if (pWC.a != pWC.aStatic)
			{
				sqlite3DbFree(db, pWC.a);
			}
		}
		public static void sqlite3WhereClauseInit(WhereClause pWC, WhereInfo pWInfo)
		{
			pWC.pWInfo = pWInfo;
			pWC.hasOr = (byte)(0);
			pWC.pOuter = null;
			pWC.nTerm = (int)(0);
			pWC.nBase = (int)(0);
			pWC.nSlot = ((int)(8 * sizeof(WhereTerm) / sizeof(WhereTerm)));
			pWC.a = pWC.aStatic;
		}
		public static WhereTerm sqlite3WhereFindTerm(WhereClause pWC, int iCur, int iColumn, ulong notReady, uint op, Index pIdx)
		{
			WhereTerm pResult = null;
			WhereTerm p;
			WhereScan scan = new WhereScan();
			p = whereScanInit(scan, pWC, (int)(iCur), (int)(iColumn), (uint)(op), pIdx);
			op &= (uint)(0x0002 | 0x0080);
			while ((p) != null)
			{
				if ((p.prereqRight & notReady) == (0))
				{
					if (((p.prereqRight) == (0)) && ((p.eOperator & op) != 0))
					{
						return p;
					}

					if ((pResult) == (null))
						pResult = p;
				}

				p = whereScanNext(scan);
			}

			return pResult;
		}
		public static void sqlite3WhereSplit(WhereClause pWC, Expr pExpr, byte op)
		{
			Expr pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);
			pWC.op = (byte)(op);
			if ((pE2) == (null))
				return;
			if (pE2.op != op)
			{
				whereClauseInsert(pWC, pExpr, (ushort)(0));
			}
			else
			{
				sqlite3WhereSplit(pWC, pE2.pLeft, (byte)(op));
				sqlite3WhereSplit(pWC, pE2.pRight, (byte)(op));
			}
		}
		public static void whereAddLimitExpr(WhereClause pWC, int iReg, Expr pExpr, int iCsr, int eMatchOp)
		{
			Parse pParse = pWC.pWInfo.pParse;
			sqlite3 db = pParse.db;
			Expr pNew;
			int iVal = (int)(0);
			if (((sqlite3ExprIsInteger(pExpr, &iVal)) != 0) && ((iVal) >= (0)))
			{
				Expr pVal = sqlite3Expr(db, (int)(155), null);
				if ((pVal) == (null))
					return;
				(pVal).flags |= (uint)(0x000400);
				pVal.u.iValue = (int)(iVal);
				pNew = sqlite3PExpr(pParse, (int)(46), null, pVal);
			}
			else
			{
				Expr pVal = sqlite3Expr(db, (int)(176), null);
				if ((pVal) == (null))
					return;
				pVal.iTable = (int)(iReg);
				pNew = sqlite3PExpr(pParse, (int)(46), null, pVal);
			}

			if ((pNew) != null)
			{
				WhereTerm pTerm;
				int idx = 0;
				idx = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0001 | 0x0002)));
				pTerm = pWC.a[idx];
				pTerm.leftCursor = (int)(iCsr);
				pTerm.eOperator = (ushort)(0x0040);
				pTerm.eMatchOp = (byte)(eMatchOp);
			}
		}
		public static int whereClauseInsert(WhereClause pWC, Expr p, ushort wtFlags)
		{
			WhereTerm pTerm;
			int idx = 0;
			if ((pWC.nTerm) >= (pWC.nSlot))
			{
				WhereTerm pOld = pWC.a;
				sqlite3 db = pWC.pWInfo.pParse.db;
				pWC.a = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereTerm) * pWC.nSlot * 2));
				if ((pWC.a) == (null))
				{
					if ((wtFlags & 0x0001) != 0)
					{
						sqlite3ExprDelete(db, p);
					}

					pWC.a = pOld;
					return (int)(0);
				}

				CRuntime.memcpy(pWC.a, pOld, (ulong)(sizeof(WhereTerm) * pWC.nTerm));
				if (pOld != pWC.aStatic)
				{
					sqlite3DbFree(db, pOld);
				}

				pWC.nSlot = (int)(sqlite3DbMallocSize(db, pWC.a) / sizeof(WhereTerm));
			}

			pTerm = pWC.a[idx = (int)(pWC.nTerm++)];
			if ((wtFlags & 0x0002) == (0))
				pWC.nBase = (int)(pWC.nTerm);
			if (((p) != null) && (((p).flags & (0x040000)) != 0))
			{
				pTerm.truthProb = (short)(sqlite3LogEst((ulong)(p.iTable)) - 270);
			}
			else
			{
				pTerm.truthProb = (short)(1);
			}

			pTerm.pExpr = sqlite3ExprSkipCollateAndLikely(p);
			pTerm.wtFlags = (ushort)(wtFlags);
			pTerm.pWC = pWC;
			pTerm.iParent = (int)(-1);
			CRuntime.memset(&pTerm.eOperator, (int)(0), (ulong)(sizeof(WhereTerm) - ((ulong)(&((0).eOperator)))));
			return (int)(idx);
		}
		public static void whereLoopOutputAdjust(WhereClause pWC, WhereLoop pLoop, short nRow)
		{
			WhereTerm pTerm; WhereTerm pX;
			ulong notAllowed = (ulong)(~(pLoop.prereq | pLoop.maskSelf));
			int i = 0; int j = 0;
			short iReduce = (short)(0);
			for (i = (int)(pWC.nBase), pTerm = pWC.a; (i) > (0); i--, pTerm++)
			{
				if ((pTerm.prereqAll & notAllowed) != 0)
					continue;
				if ((pTerm.prereqAll & pLoop.maskSelf) == (0))
					continue;
				if ((pTerm.wtFlags & 0x0002) != 0)
					continue;
				for (j = (int)(pLoop.nLTerm - 1); (j) >= (0); j--)
				{
					pX = pLoop.aLTerm[j];
					if ((pX) == (null))
						continue;
					if ((pX) == (pTerm))
						break;
					if (((pX.iParent) >= (0)) && ((pWC.a[pX.iParent]) == (pTerm)))
						break;
				}

				if ((j) < (0))
				{
					if ((pLoop.maskSelf) == (pTerm.prereqAll))
					{
						if (((pTerm.eOperator & 0x3f) != 0) || ((pWC.pWInfo.pTabList.a[pLoop.iTab].fg.jointype & 0x0008) == (0)))
						{
							pLoop.wsFlags |= (uint)(0x00800000);
						}
					}

					if ((pTerm.truthProb) <= (0))
					{
						pLoop.nOut += (short)(pTerm.truthProb);
					}
					else
					{
						pLoop.nOut--;
						if (((pTerm.eOperator & (0x0002 | 0x0080)) != 0) && ((pTerm.wtFlags & 0) == (0)))
						{
							Expr pRight = pTerm.pExpr.pRight;
							int k = (int)(0);
							if ((((sqlite3ExprIsInteger(pRight, &k)) != 0) && ((k) >= (-1))) && ((k) <= (1)))
							{
								k = (int)(10);
							}
							else
							{
								k = (int)(20);
							}

							if ((iReduce) < (k))
							{
								pTerm.wtFlags |= (ushort)(0x2000);
								iReduce = (short)(k);
							}
						}
					}
				}
			}

			if ((pLoop.nOut) > (nRow - iReduce))
			{
				pLoop.nOut = (short)(nRow - iReduce);
			}
		}
	}
}