// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void enlargeAndAppend(sqlite3_str p, sbyte* z, int N)
		{
			N = (int)(sqlite3StrAccumEnlarge(p, (int)(N)));
			if ((N) > (0))
			{
				CRuntime.memcpy(&p.zText[p.nChar], z, (ulong)(N));
				p.nChar += (uint)(N);
			}
		}
		public static void explainAppendTerm(sqlite3_str pStr, Index pIdx, int nTerm, int iTerm, int bAnd, sbyte* zOp)
		{
			int i = 0;
			if ((bAnd) != 0)
				sqlite3_str_append(pStr, " AND ", (int)(5));
			if ((nTerm) > (1))
				sqlite3_str_append(pStr, "(", (int)(1));
			for (i = (int)(0); (i) < (nTerm); i++)
			{
				if ((i) != 0)
					sqlite3_str_append(pStr, ",", (int)(1));
				sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, (int)(iTerm + i)));
			}

			if ((nTerm) > (1))
				sqlite3_str_append(pStr, ")", (int)(1));
			sqlite3_str_append(pStr, zOp, (int)(1));
			if ((nTerm) > (1))
				sqlite3_str_append(pStr, "(", (int)(1));
			for (i = (int)(0); (i) < (nTerm); i++)
			{
				if ((i) != 0)
					sqlite3_str_append(pStr, ",", (int)(1));
				sqlite3_str_append(pStr, "?", (int)(1));
			}

			if ((nTerm) > (1))
				sqlite3_str_append(pStr, ")", (int)(1));
		}
		public static void explainIndexRange(sqlite3_str pStr, WhereLoop pLoop)
		{
			Index pIndex = pLoop.u.btree.pIndex;
			ushort nEq = (ushort)(pLoop.u.btree.nEq);
			ushort nSkip = (ushort)(pLoop.nSkip);
			int i = 0; int j = 0;
			if (((nEq) == (0)) && ((pLoop.wsFlags & (0x00000020 | 0x00000010)) == (0)))
				return;
			sqlite3_str_append(pStr, " (", (int)(2));
			for (i = (int)(0); (i) < (nEq); i++)
			{
				sbyte* z = explainIndexColumnName(pIndex, (int)(i));
				if ((i) != 0)
					sqlite3_str_append(pStr, " AND ", (int)(5));
				sqlite3_str_appendf(pStr, (i) >= (nSkip) ? "%s=?" : "ANY(%s)", z);
			}

			j = (int)(i);
			if ((pLoop.wsFlags & 0x00000020) != 0)
			{
				explainAppendTerm(pStr, pIndex, (int)(pLoop.u.btree.nBtm), (int)(j), (int)(i), ">");
				i = (int)(1);
			}

			if ((pLoop.wsFlags & 0x00000010) != 0)
			{
				explainAppendTerm(pStr, pIndex, (int)(pLoop.u.btree.nTop), (int)(j), (int)(i), "<");
			}

			sqlite3_str_append(pStr, ")", (int)(1));
		}
		public static void sqlite3_str_append(sqlite3_str p, sbyte* z, int N)
		{
			if ((p.nChar + N) >= (p.nAlloc))
			{
				enlargeAndAppend(p, z, (int)(N));
			}
			else if ((N) != 0)
			{
				p.nChar += (uint)(N);
				CRuntime.memcpy(&p.zText[p.nChar - N], z, (ulong)(N));
			}
		}
		public static void sqlite3_str_appendall(sqlite3_str p, sbyte* z)
		{
			sqlite3_str_append(p, z, (int)(sqlite3Strlen30(z)));
		}
		public static void sqlite3_str_appendchar(sqlite3_str p, int N, sbyte c)
		{
			if (((p.nChar + (long)(N)) >= (p.nAlloc)) && ((N = (int)(sqlite3StrAccumEnlarge(p, (int)(N)))) <= (0)))
			{
				return;
			}

			while ((N--) > (0))
			{
				p.zText[p.nChar++] = (sbyte)(c);
			}
		}
		public static void sqlite3_str_appendf(sqlite3_str p, sbyte* zFormat)
		{
			sbyte* ap;
			(__va_start(&ap, zFormat));
			sqlite3_str_vappendf(p, zFormat, ap);
			((void)(ap = null));
		}
		public static int sqlite3_str_errcode(sqlite3_str p)
		{
			return (int)(p ? p.accError : 7);
		}
		public static int sqlite3_str_length(sqlite3_str p)
		{
			return (int)(p ? p.nChar : 0);
		}
		public static void sqlite3_str_reset(sqlite3_str p)
		{
			if ((((p).printfFlags & 0x04) != 0))
			{
				sqlite3DbFree(p.db, p.zText);
				p.printfFlags &= (byte)(~0x04);
			}

			p.nAlloc = (uint)(0);
			p.nChar = (uint)(0);
			p.zText = null;
		}
		public static void sqlite3_str_vappendf(sqlite3_str pAccum, sbyte* fmt, sbyte* ap)
		{
			int c = 0;
			sbyte* bufpt;
			int precision = 0;
			int length = 0;
			int idx = 0;
			int width = 0;
			byte flag_leftjustify = 0;
			byte flag_prefix = 0;
			byte flag_alternateform = 0;
			byte flag_altform2 = 0;
			byte flag_zeropad = 0;
			byte flag_long = 0;
			byte done = 0;
			byte cThousand = 0;
			byte xtype = (byte)(17);
			byte bArgList = 0;
			sbyte prefix = 0;
			ulong longvalue = 0;
			double realvalue = 0;
			et_info* infop;
			sbyte* zOut;
			int nOut = 0;
			sbyte* zExtra = null;
			int exp = 0; int e2 = 0;
			int nsd = 0;
			double rounder = 0;
			byte flag_dp = 0;
			byte flag_rtz = 0;
			PrintfArguments pArgList = null;
			sbyte* buf = stackalloc sbyte[70];
			bufpt = null;
			if ((pAccum.printfFlags & 0x02) != 0)
			{
				pArgList = ((((sizeof(PrintfArguments)) > ()) || ((sizeof(PrintfArguments) & (sizeof(PrintfArguments) - 1)) != 0)) ? (PrintfArguments)((ap += ) - ) : (PrintfArguments)((ap += ) - ));
				bArgList = (byte)(1);
			}
			else
			{
				bArgList = (byte)(0);
			}

			for (; (c = (int)(*fmt)) != 0; ++fmt)
			{
				if (c != 37)
				{
					bufpt = fmt;
					do
					{
						fmt++;
					}
					while (((*fmt) != 0) && (*fmt != 37));
					sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));
					if ((*fmt) == (0))
						break;
				}

				if ((c = (int)(*++fmt)) == (0))
				{
					sqlite3_str_append(pAccum, "%", (int)(1));
					break;
				}

				flag_leftjustify = (byte)(flag_prefix = (byte)(cThousand = (byte)(flag_alternateform = (byte)(flag_altform2 = (byte)(flag_zeropad = (byte)(0))))));
				done = (byte)(0);
				width = (int)(0);
				flag_long = (byte)(0);
				precision = (int)(-1);
				do
				{
					switch (c)
					{
						case 45:
							flag_leftjustify = (byte)(1);
							break;
						case 43:
							flag_prefix = (byte)(43);
							break;
						case 32:
							flag_prefix = (byte)(32);
							break;
						case 35:
							flag_alternateform = (byte)(1);
							break;
						case 33:
							flag_altform2 = (byte)(1);
							break;
						case 48:
							flag_zeropad = (byte)(1);
							break;
						case 44:
							cThousand = (byte)(44);
							break;
						default:
							done = (byte)(1);
							break;
						case 108:
							{
								flag_long = (byte)(1);
								c = (int)(*++fmt);
								if ((c) == (108))
								{
									c = (int)(*++fmt);
									flag_long = (byte)(2);
								}

								done = (byte)(1);
								break;
							}

						case 49:
						case 50:
						case 51:
						case 52:
						case 53:
						case 54:
						case 55:
						case 56:
						case 57:
							{
								uint wx = (uint)(c - 48);
								while (((c = (int)(*++fmt)) >= (48)) && ((c) <= (57)))
								{
									wx = (uint)(wx * 10 + c - 48);
								}

								width = (int)(wx & 0x7fffffff);
								if ((c != 46) && (c != 108))
								{
									done = (byte)(1);
								}
								else
								{
									fmt--;
								}

								break;
							}

						case 42:
							{
								if ((bArgList) != 0)
								{
									width = ((int)(getIntArg(pArgList)));
								}
								else
								{
									width = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
								}

								if ((width) < (0))
								{
									flag_leftjustify = (byte)(1);
									width = (int)((width) >= (-2147483647) ? -width : 0);
								}

								if (((c = (int)(fmt[1])) != 46) && (c != 108))
								{
									c = (int)(*++fmt);
									done = (byte)(1);
								}

								break;
							}

						case 46:
							{
								c = (int)(*++fmt);
								if ((c) == (42))
								{
									if ((bArgList) != 0)
									{
										precision = ((int)(getIntArg(pArgList)));
									}
									else
									{
										precision = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
									}

									if ((precision) < (0))
									{
										precision = (int)((precision) >= (-2147483647) ? -precision : -1);
									}

									c = (int)(*++fmt);
								}
								else
								{
									uint px = (uint)(0);
									while (((c) >= (48)) && ((c) <= (57)))
									{
										px = (uint)(px * 10 + c - 48);
										c = (int)(*++fmt);
									}

									precision = (int)(px & 0x7fffffff);
								}

								if ((c) == (108))
								{
									--fmt;
								}
								else
								{
									done = (byte)(1);
								}

								break;
							}
					}
				}
				while ((done == 0) && ((c = (int)(*++fmt)) != 0));
				infop = &fmtinfo[0];
				xtype = (byte)(17);
				for (idx = (int)(0); (idx) < ((int)(23 * sizeof(et_info) / sizeof(et_info))); idx++)
				{
					if ((c) == (fmtinfo[idx].fmttype))
					{
						infop = &fmtinfo[idx];
						xtype = (byte)(infop->type);
						break;
					}
				}

				switch (xtype)
				{
					case 13:
						flag_long = (byte)((sizeof(char*)) == (sizeof(long)) ? 2 : (sizeof(char*)) == (sizeof(longint)) ? 1 : 0);
					case 15:
					case 0:
						cThousand = (byte)(0);
					case 16:
						if ((infop->flags & 1) != 0)
						{
							long v = 0;
							if ((bArgList) != 0)
							{
								v = (long)(getIntArg(pArgList));
							}
							else if ((flag_long) != 0)
							{
								if ((flag_long) == (2))
								{
									v = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
								}
								else
								{
									v = (long)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
								}
							}
							else
							{
								v = (long)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
							}

							if ((v) < (0))
							{
								longvalue = (ulong)(~v);
								longvalue++;
								prefix = (sbyte)(45);
							}
							else
							{
								longvalue = (ulong)(v);
								prefix = (sbyte)(flag_prefix);
							}
						}
						else
						{
							if ((bArgList) != 0)
							{
								longvalue = ((ulong)(getIntArg(pArgList)));
							}
							else if ((flag_long) != 0)
							{
								if ((flag_long) == (2))
								{
									longvalue = (ulong)((((sizeof(ulong)) > ()) || ((sizeof(ulong) & (sizeof(ulong) - 1)) != 0)) ? **(ulong**)((ap += ) - ) : *(ulong*)((ap += ) - ));
								}
								else
								{
									longvalue = (ulong)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
								}
							}
							else
							{
								longvalue = (ulong)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
							}

							prefix = (sbyte)(0);
						}

						if ((longvalue) == (0))
							flag_alternateform = (byte)(0);
						if (((flag_zeropad) != 0) && ((precision) < (width - (prefix != 0))))
						{
							precision = (int)(width - (prefix != 0));
						}

						if ((precision) < (70 - 10 - 70 / 3))
						{
							nOut = (int)(70);
							zOut = buf;
						}
						else
						{
							ulong n = 0;
							n = (ulong)((ulong)(precision) + 10);
							if ((cThousand) != 0)
								n += (ulong)(precision / 3);
							zOut = zExtra = printfTempBuf(pAccum, (long)(n));
							if ((zOut) == (null))
								return;
							nOut = ((int)(n));
						}

						bufpt = &zOut[nOut - 1];
						if ((xtype) == (15))
						{
							int x = (int)(longvalue % 10);
							if (((x) >= (4)) || (((longvalue / 10) % 10) == (1)))
							{
								x = (int)(0);
							}

							*(--bufpt) = (sbyte)(sqlite3_str_vappendf_zOrd[x * 2 + 1]);
							*(--bufpt) = (sbyte)(sqlite3_str_vappendf_zOrd[x * 2]);
						}

						{
							sbyte* cset = &aDigits[infop->charset];
							byte _base_ = (byte)(infop->_base_);
							do
							{
								*(--bufpt) = (sbyte)(cset[longvalue % _base_]);
								longvalue = (ulong)(longvalue / _base_);
							}
							while ((longvalue) > (0));
						}

						length = ((int)(&zOut[nOut - 1] - bufpt));
						while ((precision) > (length))
						{
							*(--bufpt) = (sbyte)(48);
							length++;
						}

						if ((cThousand) != 0)
						{
							int nn = (int)((length - 1) / 3);
							int ix = (int)((length - 1) % 3 + 1);
							bufpt -= nn;
							for (idx = (int)(0); (nn) > (0); idx++)
							{
								bufpt[idx] = (sbyte)(bufpt[idx + nn]);
								ix--;
								if ((ix) == (0))
								{
									bufpt[++idx] = (sbyte)(cThousand);
									nn--;
									ix = (int)(3);
								}
							}
						}

						if ((prefix) != 0)
							*(--bufpt) = (sbyte)(prefix);
						if (((flag_alternateform) != 0) && ((infop->prefix) != 0))
						{
							sbyte* pre;
							sbyte x = 0;
							pre = &aPrefix[infop->prefix];
							for (; (x = (sbyte)(*pre)) != 0; pre++)
							{
								*(--bufpt) = (sbyte)(x);
							}
						}

						length = ((int)(&zOut[nOut - 1] - bufpt));
						break;
					case 1:
					case 2:
					case 3:
						if ((bArgList) != 0)
						{
							realvalue = (double)(getDoubleArg(pArgList));
						}
						else
						{
							realvalue = (double)(((() > ()) || ((&(-1)) != 0)) ? **(double**)((ap += ) - ) : *(double*)((ap += ) - ));
						}

						if ((precision) < (0))
							precision = (int)(6);
						if ((precision) > (100000000))
						{
							precision = (int)(100000000);
						}

						if ((realvalue) < (0.0))
						{
							realvalue = (double)(-realvalue);
							prefix = (sbyte)(45);
						}
						else
						{
							prefix = (sbyte)(flag_prefix);
						}

						if (((xtype) == (3)) && ((precision) > (0)))
							precision--;
						idx = (int)(precision & 0xfff);
						rounder = (double)(arRound[idx % 10]);
						while ((idx) >= (10))
						{
							rounder *= (double)(1.0e-10);
							idx -= (int)(10);
						}

						if ((xtype) == (1))
						{
							double rx = (double)(realvalue);
							ulong u = 0;
							int ex = 0;
							CRuntime.memcpy(&u, &rx, (ulong)(sizeof(ulong)));
							ex = (int)(-1023 + (int)((u >> 52) & 0x7ff));
							if ((precision + (ex / 3)) < (15))
								rounder += (double)(realvalue * 3e-16);
							realvalue += (double)(rounder);
						}

						exp = (int)(0);
						if ((sqlite3IsNaN((double)(realvalue))) != 0)
						{
							bufpt = "NaN";
							length = (int)(3);
							break;
						}

						if ((realvalue) > (0.0))
						{
							double scale = (double)(1.0);
							while (((realvalue) >= (1e100 * scale)) && ((exp) <= (350)))
							{
								scale *= (double)(1e100);
								exp += (int)(100);
							}

							while (((realvalue) >= (1e10 * scale)) && ((exp) <= (350)))
							{
								scale *= (double)(1e10);
								exp += (int)(10);
							}

							while (((realvalue) >= (10.0 * scale)) && ((exp) <= (350)))
							{
								scale *= (double)(10.0);
								exp++;
							}

							realvalue /= (double)(scale);
							while ((realvalue) < (1e-8))
							{
								realvalue *= (double)(1e8);
								exp -= (int)(8);
							}

							while ((realvalue) < (1.0))
							{
								realvalue *= (double)(10.0);
								exp--;
							}

							if ((exp) > (350))
							{
								bufpt = buf;
								buf[0] = (sbyte)(prefix);
								CRuntime.memcpy(buf + (prefix != 0), "Inf", (ulong)(4));
								length = (int)(3 + (prefix != 0));
								break;
							}
						}

						bufpt = buf;
						if (xtype != 1)
						{
							realvalue += (double)(rounder);
							if ((realvalue) >= (10.0))
							{
								realvalue *= (double)(0.1);
								exp++;
							}
						}

						if ((xtype) == (3))
						{
							flag_rtz = (byte)(!flag_alternateform);
							if (((exp) < (-4)) || ((exp) > (precision)))
							{
								xtype = (byte)(2);
							}
							else
							{
								precision = (int)(precision - exp);
								xtype = (byte)(1);
							}
						}
						else
						{
							flag_rtz = (byte)(flag_altform2);
						}

						if ((xtype) == (2))
						{
							e2 = (int)(0);
						}
						else
						{
							e2 = (int)(exp);
						}

						{
							long szBufNeeded = 0;
							szBufNeeded = (long)(((e2) > (0) ? (e2) : (0)) + (long)(precision) + (long)(width) + 15);
							if ((szBufNeeded) > (70))
							{
								bufpt = zExtra = printfTempBuf(pAccum, (long)(szBufNeeded));
								if ((bufpt) == (null))
									return;
							}
						}

						zOut = bufpt;
						nsd = (int)(16 + flag_altform2 * 10);
						flag_dp = (byte)(((precision) > (0) ? 1 : 0) | flag_alternateform | flag_altform2);
						if ((prefix) != 0)
						{
							*(bufpt++) = (sbyte)(prefix);
						}

						if ((e2) < (0))
						{
							*(bufpt++) = (sbyte)(48);
						}
						else
						{
							for (; (e2) >= (0); e2--)
							{
								*(bufpt++) = (sbyte)(et_getdigit(&realvalue, &nsd));
							}
						}

						if ((flag_dp) != 0)
						{
							*(bufpt++) = (sbyte)(46);
						}

						for (e2++; (e2) < (0); precision--, e2++)
						{
							*(bufpt++) = (sbyte)(48);
						}

						while ((precision--) > (0))
						{
							*(bufpt++) = (sbyte)(et_getdigit(&realvalue, &nsd));
						}

						if (((flag_rtz) != 0) && ((flag_dp) != 0))
						{
							while ((bufpt[-1]) == (48))
							{
								*(--bufpt) = (sbyte)(0);
							}

							if ((bufpt[-1]) == (46))
							{
								if ((flag_altform2) != 0)
								{
									*(bufpt++) = (sbyte)(48);
								}
								else
								{
									*(--bufpt) = (sbyte)(0);
								}
							}
						}

						if ((xtype) == (2))
						{
							*(bufpt++) = (sbyte)(aDigits[infop->charset]);
							if ((exp) < (0))
							{
								*(bufpt++) = (sbyte)(45);
								exp = (int)(-exp);
							}
							else
							{
								*(bufpt++) = (sbyte)(43);
							}

							if ((exp) >= (100))
							{
								*(bufpt++) = ((sbyte)((exp / 100) + 48));
								exp %= (int)(100);
							}

							*(bufpt++) = ((sbyte)(exp / 10 + 48));
							*(bufpt++) = ((sbyte)(exp % 10 + 48));
						}

						*bufpt = (sbyte)(0);
						length = ((int)(bufpt - zOut));
						bufpt = zOut;
						if ((((flag_zeropad) != 0) && (flag_leftjustify == 0)) && ((length) < (width)))
						{
							int i = 0;
							int nPad = (int)(width - length);
							for (i = (int)(width); (i) >= (nPad); i--)
							{
								bufpt[i] = (sbyte)(bufpt[i - nPad]);
							}

							i = (int)(prefix != 0);
							while ((nPad--) != 0)
							{
								bufpt[i++] = (sbyte)(48);
							}

							length = (int)(width);
						}

						break;
					case 4:
						if (bArgList == 0)
						{
							*(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(pAccum.nChar);
						}

						length = (int)(width = (int)(0));
						break;
					case 7:
						buf[0] = (sbyte)(37);
						bufpt = buf;
						length = (int)(1);
						break;
					case 8:
						if ((bArgList) != 0)
						{
							bufpt = getTextArg(pArgList);
							length = (int)(1);
							if ((bufpt) != null)
							{
								buf[0] = (sbyte)(c = (int)(*(bufpt++)));
								if ((c & 0xc0) == (0xc0))
								{
									while (((length) < (4)) && ((bufpt[0] & 0xc0) == (0x80)))
									{
										buf[length++] = (sbyte)(*(bufpt++));
									}
								}
							}
							else
							{
								buf[0] = (sbyte)(0);
							}
						}
						else
						{
							uint ch = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
							if ((ch) < (0x00080))
							{
								buf[0] = (sbyte)(ch & 0xff);
								length = (int)(1);
							}
							else if ((ch) < (0x00800))
							{
								buf[0] = (sbyte)(0xc0 + (byte)((ch >> 6) & 0x1f));
								buf[1] = (sbyte)(0x80 + (byte)(ch & 0x3f));
								length = (int)(2);
							}
							else if ((ch) < (0x10000))
							{
								buf[0] = (sbyte)(0xe0 + (byte)((ch >> 12) & 0x0f));
								buf[1] = (sbyte)(0x80 + (byte)((ch >> 6) & 0x3f));
								buf[2] = (sbyte)(0x80 + (byte)(ch & 0x3f));
								length = (int)(3);
							}
							else
							{
								buf[0] = (sbyte)(0xf0 + (byte)((ch >> 18) & 0x07));
								buf[1] = (sbyte)(0x80 + (byte)((ch >> 12) & 0x3f));
								buf[2] = (sbyte)(0x80 + (byte)((ch >> 6) & 0x3f));
								buf[3] = (sbyte)(0x80 + (byte)(ch & 0x3f));
								length = (int)(4);
							}
						}

						if ((precision) > (1))
						{
							width -= (int)(precision - 1);
							if (((width) > (1)) && (flag_leftjustify == 0))
							{
								sqlite3_str_appendchar(pAccum, (int)(width - 1), (sbyte)(32));
								width = (int)(0);
							}

							while ((precision--) > (1))
							{
								sqlite3_str_append(pAccum, buf, (int)(length));
							}
						}

						bufpt = buf;
						flag_altform2 = (byte)(1);
						goto adjust_width_for_utf8;
					case 5:
					case 6:
						if ((bArgList) != 0)
						{
							bufpt = getTextArg(pArgList);
							xtype = (byte)(5);
						}
						else
						{
							bufpt = (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
						}

						if ((bufpt) == (null))
						{
							bufpt = "";
						}
						else if ((xtype) == (6))
						{
							if ((((((pAccum.nChar) == (0)) && ((pAccum.mxAlloc) != 0)) && ((width) == (0))) && ((precision) < (0))) && ((pAccum.accError) == (0)))
							{
								pAccum.zText = bufpt;
								pAccum.nAlloc = (uint)(sqlite3DbMallocSize(pAccum.db, bufpt));
								pAccum.nChar = (uint)(0x7fffffff & (int)(CRuntime.strlen(bufpt)));
								pAccum.printfFlags |= (byte)(0x04);
								length = (int)(0);
								break;
							}

							zExtra = bufpt;
						}

						if ((precision) >= (0))
						{
							if ((flag_altform2) != 0)
							{
								byte* z = (byte*)(bufpt);
								while (((precision--) > (0)) && ((z[0]) != 0))
								{
									{
										if ((*(z++)) >= (0xc0))
										{
											while ((*z & 0xc0) == (0x80))
											{
												z++;
											}
										}
									}
								}

								length = ((int)(z - (byte*)(bufpt)));
							}
							else
							{
								for (length = (int)(0); ((length) < (precision)) && ((bufpt[length]) != 0); length++)
								{
								}
							}
						}
						else
						{
							length = (int)(0x7fffffff & (int)(CRuntime.strlen(bufpt)));
						}

					adjust_width_for_utf8:
						;
						if (((flag_altform2) != 0) && ((width) > (0)))
						{
							int ii = (int)(length - 1);
							while ((ii) >= (0))
							{
								if ((bufpt[ii--] & 0xc0) == (0x80))
									width++;
							}
						}

						break;
					case 9:
					case 10:
					case 14:
						{
							int i = 0;
							int j = 0;
							int k = 0;
							int n = 0;
							int isnull = 0;
							int needQuote = 0;
							sbyte ch = 0;
							sbyte q = (sbyte)(((xtype) == (14)) ? 34 : 39);
							sbyte* escarg;
							if ((bArgList) != 0)
							{
								escarg = getTextArg(pArgList);
							}
							else
							{
								escarg = (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
							}

							isnull = (int)((escarg) == (null) ? 1 : 0);
							if ((isnull) != 0)
								escarg = ((xtype) == (10) ? "NULL" : "(NULL)");
							k = (int)(precision);
							for (i = (int)(n = (int)(0)); (k != 0) && ((ch = (sbyte)(escarg[i])) != 0); i++, k--)
							{
								if ((ch) == (q))
									n++;
								if (((flag_altform2) != 0) && ((ch & 0xc0) == (0xc0)))
								{
									while ((escarg[i + 1] & 0xc0) == (0x80))
									{
										i++;
									}
								}
							}

							needQuote = (int)((isnull == 0) && ((xtype) == (10)) ? 1 : 0);
							n += (int)(i + 3);
							if ((n) > (70))
							{
								bufpt = zExtra = printfTempBuf(pAccum, (long)(n));
								if ((bufpt) == (null))
									return;
							}
							else
							{
								bufpt = buf;
							}

							j = (int)(0);
							if ((needQuote) != 0)
								bufpt[j++] = (sbyte)(q);
							k = (int)(i);
							for (i = (int)(0); (i) < (k); i++)
							{
								bufpt[j++] = (sbyte)(ch = (sbyte)(escarg[i]));
								if ((ch) == (q))
									bufpt[j++] = (sbyte)(ch);
							}

							if ((needQuote) != 0)
								bufpt[j++] = (sbyte)(q);
							bufpt[j] = (sbyte)(0);
							length = (int)(j);
							goto adjust_width_for_utf8;
						}

					case 11:
						{
							if ((pAccum.printfFlags & 0x01) == (0))
								return;
							if ((flag_alternateform) != 0)
							{
								Expr pExpr = ((((sizeof(Expr)) > ()) || ((sizeof(Expr) & (sizeof(Expr) - 1)) != 0)) ? (Expr)((ap += ) - ) : (Expr)((ap += ) - ));
								if (((pExpr) != null) && ((!(((pExpr).flags & (0x000400)) != 0)) != 0))
								{
									sqlite3_str_appendall(pAccum, pExpr.u.zToken);
									sqlite3RecordErrorOffsetOfExpr(pAccum.db, pExpr);
								}
							}
							else
							{
								Token* pToken = ((((sizeof(Token)) > ()) || ((sizeof(Token) & (sizeof(Token) - 1)) != 0)) ? **(Token***)((ap += ) - ) : *(Token**)((ap += ) - ));
								if (((pToken) != null) && ((pToken->n) != 0))
								{
									sqlite3_str_append(pAccum, pToken->z, (int)(pToken->n));
									sqlite3RecordErrorByteOffset(pAccum.db, pToken->z);
								}
							}

							length = (int)(width = (int)(0));
							break;
						}

					case 12:
						{
							SrcItem pItem;
							if ((pAccum.printfFlags & 0x01) == (0))
								return;
							pItem = ((((sizeof(SrcItem)) > ()) || ((sizeof(SrcItem) & (sizeof(SrcItem) - 1)) != 0)) ? (SrcItem)((ap += ) - ) : (SrcItem)((ap += ) - ));
							if (((pItem.zAlias) != null) && (flag_altform2 == 0))
							{
								sqlite3_str_appendall(pAccum, pItem.zAlias);
							}
							else if ((pItem.zName) != null)
							{
								if ((pItem.zDatabase) != null)
								{
									sqlite3_str_appendall(pAccum, pItem.zDatabase);
									sqlite3_str_append(pAccum, ".", (int)(1));
								}

								sqlite3_str_appendall(pAccum, pItem.zName);
							}
							else if ((pItem.zAlias) != null)
							{
								sqlite3_str_appendall(pAccum, pItem.zAlias);
							}
							else if ((pItem.pSelect) != null)
							{
								sqlite3_str_appendf(pAccum, "SUBQUERY %u", (uint)(pItem.pSelect.selId));
							}

							length = (int)(width = (int)(0));
							break;
						}

					default:
						{
							return;
						}
				}

				width -= (int)(length);
				if ((width) > (0))
				{
					if (flag_leftjustify == 0)
						sqlite3_str_appendchar(pAccum, (int)(width), (sbyte)(32));
					sqlite3_str_append(pAccum, bufpt, (int)(length));
					if ((flag_leftjustify) != 0)
						sqlite3_str_appendchar(pAccum, (int)(width), (sbyte)(32));
				}
				else
				{
					sqlite3_str_append(pAccum, bufpt, (int)(length));
				}

				if ((zExtra) != null)
				{
					sqlite3DbFree(pAccum.db, zExtra);
					zExtra = null;
				}
			}
		}
		public static void sqlite3QuoteValue(sqlite3_str pStr, sqlite3_value pValue)
		{
			switch (sqlite3_value_type(pValue))
			{
				case 2:
					{
						double r1 = 0;
						double r2 = 0;
						sbyte* zVal;
						r1 = (double)(sqlite3_value_double(pValue));
						sqlite3_str_appendf(pStr, "%!.15g", (double)(r1));
						zVal = sqlite3_str_value(pStr);
						if ((zVal) != null)
						{
							sqlite3AtoF(zVal, &r2, (int)(pStr.nChar), (byte)(1));
							if (r1 != r2)
							{
								sqlite3_str_reset(pStr);
								sqlite3_str_appendf(pStr, "%!.20e", (double)(r1));
							}
						}

						break;
					}

				case 1:
					{
						sqlite3_str_appendf(pStr, "%lld", (long)(sqlite3_value_int64(pValue)));
						break;
					}

				case 4:
					{
						sbyte* zBlob = sqlite3_value_blob(pValue);
						int nBlob = (int)(sqlite3_value_bytes(pValue));
						sqlite3StrAccumEnlarge(pStr, (int)(nBlob * 2 + 4));
						if ((pStr.accError) == (0))
						{
							sbyte* zText = pStr.zText;
							int i = 0;
							for (i = (int)(0); (i) < (nBlob); i++)
							{
								zText[(i * 2) + 2] = (sbyte)(hexdigits[(zBlob[i] >> 4) & 0x0F]);
								zText[(i * 2) + 3] = (sbyte)(hexdigits[(zBlob[i]) & 0x0F]);
							}

							zText[(nBlob * 2) + 2] = (sbyte)(39);
							zText[(nBlob * 2) + 3] = (sbyte)(0);
							zText[0] = (sbyte)(88);
							zText[1] = (sbyte)(39);
							pStr.nChar = (uint)(nBlob * 2 + 3);
						}

						break;
					}

				case 3:
					{
						byte* zArg = sqlite3_value_text(pValue);
						sqlite3_str_appendf(pStr, "%Q", zArg);
						break;
					}

				default:
					{
						sqlite3_str_append(pStr, "NULL", (int)(4));
						break;
					}
			}
		}
		public static int sqlite3StrAccumEnlarge(sqlite3_str p, int N)
		{
			sbyte* zNew;
			if ((p.accError) != 0)
			{
				return (int)(0);
			}

			if ((p.mxAlloc) == (0))
			{
				sqlite3StrAccumSetError(p, (byte)(18));
				return (int)(p.nAlloc - p.nChar - 1);
			}
			else
			{
				sbyte* zOld = (((p).printfFlags & 0x04) != 0) ? p.zText : null;
				long szNew = (long)(p.nChar);
				szNew += (long)((long)(N) + 1);
				if ((szNew + p.nChar) <= (p.mxAlloc))
				{
					szNew += (long)(p.nChar);
				}

				if ((szNew) > (p.mxAlloc))
				{
					sqlite3_str_reset(p);
					sqlite3StrAccumSetError(p, (byte)(18));
					return (int)(0);
				}
				else
				{
					p.nAlloc = (uint)((int)(szNew));
				}

				if ((p.db) != null)
				{
					zNew = sqlite3DbRealloc(p.db, zOld, (ulong)(p.nAlloc));
				}
				else
				{
					zNew = sqlite3Realloc(zOld, (ulong)(p.nAlloc));
				}

				if ((zNew) != null)
				{
					if ((!(((p).printfFlags & 0x04) != 0)) && ((p.nChar) > (0)))
						CRuntime.memcpy(zNew, p.zText, (ulong)(p.nChar));
					p.zText = zNew;
					p.nAlloc = (uint)(sqlite3DbMallocSize(p.db, zNew));
					p.printfFlags |= (byte)(0x04);
				}
				else
				{
					sqlite3_str_reset(p);
					sqlite3StrAccumSetError(p, (byte)(7));
					return (int)(0);
				}
			}

			return (int)(N);
		}
		public static void sqlite3StrAccumInit(sqlite3_str p, sqlite3 db, sbyte* zBase, int n, int mx)
		{
			p.zText = zBase;
			p.db = db;
			p.nAlloc = (uint)(n);
			p.mxAlloc = (uint)(mx);
			p.nChar = (uint)(0);
			p.accError = (byte)(0);
			p.printfFlags = (byte)(0);
		}
		public static void sqlite3StrAccumSetError(sqlite3_str p, byte eError)
		{
			p.accError = (byte)(eError);
			if ((p.mxAlloc) != 0)
				sqlite3_str_reset(p);
			if ((eError) == (18))
				sqlite3ErrorToParser(p.db, (int)(eError));
		}
	}
}