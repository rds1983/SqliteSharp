// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static Expr substExpr(SubstContext pSubst, Expr pExpr)
		{
			if ((pExpr) == (null))
				return null;
			if ((((pExpr).flags & (0x000001)) != 0) && ((pExpr.w.iRightJoinTable) == (pSubst.iTable)))
			{
				pExpr.w.iRightJoinTable = (int)(pSubst.iNewTable);
			}

			if ((((pExpr.op) == (167)) && ((pExpr.iTable) == (pSubst.iTable))) && (!(((pExpr).flags & (0x000008)) != 0)))
			{
				{
					Expr pNew;
					Expr pCopy = pSubst.pEList.a[pExpr.iColumn].pExpr;
					Expr ifNullRow = new Expr();
					if ((sqlite3ExprIsVector(pCopy)) != 0)
					{
						sqlite3VectorErrorMsg(pSubst.pParse, pCopy);
					}
					else
					{
						sqlite3 db = pSubst.pParse.db;
						if (((pSubst.isLeftJoin) != 0) && (pCopy.op != 167))
						{
							CRuntime.memset(ifNullRow, (int)(0), (ulong)(sizeof(Expr)));
							ifNullRow.op = (byte)(179);
							ifNullRow.pLeft = pCopy;
							ifNullRow.iTable = (int)(pSubst.iNewTable);
							ifNullRow.flags = (uint)(0x020000);
							pCopy = ifNullRow;
						}

						pNew = sqlite3ExprDup(db, pCopy, (int)(0));
						if ((db.mallocFailed) != 0)
						{
							sqlite3ExprDelete(db, pNew);
							return pExpr;
						}

						if ((pSubst.isLeftJoin) != 0)
						{
							(pNew).flags |= (uint)(0x100000);
						}

						if ((((pExpr).flags & (0x000001)) != 0))
						{
							sqlite3SetJoinExpr(pNew, (int)(pExpr.w.iRightJoinTable));
						}

						sqlite3ExprDelete(db, pExpr);
						pExpr = pNew;
						if ((pExpr.op != 167) && (pExpr.op != 113))
						{
							CollSeq pColl = sqlite3ExprCollSeq(pSubst.pParse, pExpr);
							pExpr = sqlite3ExprAddCollateString(pSubst.pParse, pExpr, (pColl ? pColl.zName : "BINARY"));
						}

						(pExpr).flags &= (uint)(~(0x000100));
					}
				}
			}
			else
			{
				if (((pExpr.op) == (179)) && ((pExpr.iTable) == (pSubst.iTable)))
				{
					pExpr.iTable = (int)(pSubst.iNewTable);
				}

				pExpr.pLeft = substExpr(pSubst, pExpr.pLeft);
				pExpr.pRight = substExpr(pSubst, pExpr.pRight);
				if ((((pExpr).flags & 0x000800) != 0))
				{
					substSelect(pSubst, pExpr.x.pSelect, (int)(1));
				}
				else
				{
					substExprList(pSubst, pExpr.x.pList);
				}

				if ((((pExpr).flags & (0x1000000)) != 0))
				{
					Window pWin = pExpr.y.pWin;
					pWin.pFilter = substExpr(pSubst, pWin.pFilter);
					substExprList(pSubst, pWin.pPartition);
					substExprList(pSubst, pWin.pOrderBy);
				}
			}

			return pExpr;
		}
		public static void substExprList(SubstContext pSubst, ExprList pList)
		{
			int i = 0;
			if ((pList) == (null))
				return;
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				pList.a[i].pExpr = substExpr(pSubst, pList.a[i].pExpr);
			}
		}
		public static void substSelect(SubstContext pSubst, Select p, int doPrior)
		{
			SrcList pSrc;
			SrcItem pItem;
			int i = 0;
			if (p == null)
				return;
			do
			{
				substExprList(pSubst, p.pEList);
				substExprList(pSubst, p.pGroupBy);
				substExprList(pSubst, p.pOrderBy);
				p.pHaving = substExpr(pSubst, p.pHaving);
				p.pWhere = substExpr(pSubst, p.pWhere);
				pSrc = p.pSrc;
				for (i = (int)(pSrc.nSrc), pItem = pSrc.a; (i) > (0); i--, pItem++)
				{
					substSelect(pSubst, pItem.pSelect, (int)(1));
					if ((pItem.fg.isTabFunc) != 0)
					{
						substExprList(pSubst, pItem.u1.pFuncArg);
					}
				}
			}
			while (((doPrior) != 0) && ((p = p.pPrior) != null));
		}
	}
}