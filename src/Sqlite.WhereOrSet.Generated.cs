// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int whereOrInsert(WhereOrSet pSet, ulong prereq, short rRun, short nOut)
		{
			ushort i = 0;
			WhereOrCost* p;
			for (i = (ushort)(pSet.n), p = pSet.a; (i) > (0); i--, p++)
			{
				if (((rRun) <= (p->rRun)) && ((prereq & p->prereq) == (prereq)))
				{
					goto whereOrInsert_done;
				}

				if (((p->rRun) <= (rRun)) && ((p->prereq & prereq) == (p->prereq)))
				{
					return (int)(0);
				}
			}

			if ((pSet.n) < (3))
			{
				p = &pSet.a[pSet.n++];
				p->nOut = (short)(nOut);
			}
			else
			{
				p = pSet.a;
				for (i = (ushort)(1); (i) < (pSet.n); i++)
				{
					if ((p->rRun) > (pSet.a[i].rRun))
						p = pSet.a + i;
				}

				if ((p->rRun) <= (rRun))
					return (int)(0);
			}

		whereOrInsert_done:
			; p->prereq = (ulong)(prereq);
			p->rRun = (short)(rRun);
			if ((p->nOut) > (nOut))
				p->nOut = (short)(nOut);
			return (int)(1);
		}
		public static void whereOrMove(WhereOrSet pDest, WhereOrSet pSrc)
		{
			pDest.n = (ushort)(pSrc.n);
			CRuntime.memcpy(pDest.a, pSrc.a, (ulong)(pDest.n * sizeof(WhereOrCost)));
		}
	}
}