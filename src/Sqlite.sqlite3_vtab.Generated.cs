// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int jsonEachBestIndex(sqlite3_vtab tab, sqlite3_index_info* pIdxInfo)
		{
			int i = 0;
			int* aIdx = stackalloc int[2];
			int unusableMask = (int)(0);
			int idxMask = (int)(0);
			sqlite3_index_constraint* pConstraint;
			aIdx[0] = (int)(aIdx[1] = (int)(-1));
			pConstraint = pIdxInfo->aConstraint;
			for (i = (int)(0); (i) < (pIdxInfo->nConstraint); i++, pConstraint++)
			{
				int iCol = 0;
				int iMask = 0;
				if ((pConstraint->iColumn) < (8))
					continue;
				iCol = (int)(pConstraint->iColumn - 8);
				iMask = (int)(1 << iCol);
				if ((pConstraint->usable) == (0))
				{
					unusableMask |= (int)(iMask);
				}
				else if ((pConstraint->op) == (2))
				{
					aIdx[iCol] = (int)(i);
					idxMask |= (int)(iMask);
				}
			}

			if ((unusableMask & ~idxMask) != 0)
			{
				return (int)(19);
			}

			if ((aIdx[0]) < (0))
			{
				pIdxInfo->idxNum = (int)(0);
			}
			else
			{
				pIdxInfo->estimatedCost = (double)(1.0);
				i = (int)(aIdx[0]);
				pIdxInfo->aConstraintUsage[i].argvIndex = (int)(1);
				pIdxInfo->aConstraintUsage[i].omit = (byte)(1);
				if ((aIdx[1]) < (0))
				{
					pIdxInfo->idxNum = (int)(1);
				}
				else
				{
					i = (int)(aIdx[1]);
					pIdxInfo->aConstraintUsage[i].argvIndex = (int)(2);
					pIdxInfo->aConstraintUsage[i].omit = (byte)(1);
					pIdxInfo->idxNum = (int)(3);
				}
			}

			return (int)(0);
		}
		public static int jsonEachDisconnect(sqlite3_vtab pVtab)
		{
			sqlite3_free(pVtab);
			return (int)(0);
		}
		public static int jsonEachOpenEach(sqlite3_vtab p, sqlite3_vtab_cursor ppCursor)
		{
			JsonEachCursor pCur;
			pCur = sqlite3_malloc((int)(sizeof(JsonEachCursor)));
			if ((pCur) == (null))
				return (int)(7);
			CRuntime.memset(pCur, (int)(0), (ulong)(sizeof(JsonEachCursor)));
			ppCursor = pCur._base_;
			return (int)(0);
		}
		public static int jsonEachOpenTree(sqlite3_vtab p, sqlite3_vtab_cursor ppCursor)
		{
			int rc = (int)(jsonEachOpenEach(p, ppCursor));
			if ((rc) == (0))
			{
				JsonEachCursor pCur = (JsonEachCursor)(ppCursor);
				pCur.bRecursive = (byte)(1);
			}

			return (int)(rc);
		}
		public static int pragmaVtabBestIndex(sqlite3_vtab tab, sqlite3_index_info* pIdxInfo)
		{
			PragmaVtab pTab = (PragmaVtab)(tab);
			sqlite3_index_constraint* pConstraint;
			int i = 0; int j = 0;
			int* seen = stackalloc int[2];
			pIdxInfo->estimatedCost = ((double)(1));
			if ((pTab.nHidden) == (0))
			{
				return (int)(0);
			}

			pConstraint = pIdxInfo->aConstraint;
			seen[0] = (int)(0);
			seen[1] = (int)(0);
			for (i = (int)(0); (i) < (pIdxInfo->nConstraint); i++, pConstraint++)
			{
				if ((pConstraint->usable) == (0))
					continue;
				if (pConstraint->op != 2)
					continue;
				if ((pConstraint->iColumn) < (pTab.iHidden))
					continue;
				j = (int)(pConstraint->iColumn - pTab.iHidden);
				seen[j] = (int)(i + 1);
			}

			if ((seen[0]) == (0))
			{
				pIdxInfo->estimatedCost = ((double)(2147483647));
				pIdxInfo->estimatedRows = (long)(2147483647);
				return (int)(0);
			}

			j = (int)(seen[0] - 1);
			pIdxInfo->aConstraintUsage[j].argvIndex = (int)(1);
			pIdxInfo->aConstraintUsage[j].omit = (byte)(1);
			if ((seen[1]) == (0))
				return (int)(0);
			pIdxInfo->estimatedCost = ((double)(20));
			pIdxInfo->estimatedRows = (long)(20);
			j = (int)(seen[1] - 1);
			pIdxInfo->aConstraintUsage[j].argvIndex = (int)(2);
			pIdxInfo->aConstraintUsage[j].omit = (byte)(1);
			return (int)(0);
		}
		public static int pragmaVtabDisconnect(sqlite3_vtab pVtab)
		{
			PragmaVtab pTab = (PragmaVtab)(pVtab);
			sqlite3_free(pTab);
			return (int)(0);
		}
		public static int pragmaVtabOpen(sqlite3_vtab pVtab, sqlite3_vtab_cursor ppCursor)
		{
			PragmaVtabCursor pCsr;
			pCsr = (PragmaVtabCursor)(sqlite3_malloc((int)(sizeof(PragmaVtabCursor))));
			if ((pCsr) == (null))
				return (int)(7);
			CRuntime.memset(pCsr, (int)(0), (ulong)(sizeof(PragmaVtabCursor)));
			pCsr._base_.pVtab = pVtab;
			ppCursor = pCsr._base_;
			return (int)(0);
		}
	}
}