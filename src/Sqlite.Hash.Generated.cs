// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void insertElement(Hash* pH, _ht* pEntry, HashElem* pNew)
		{
			HashElem* pHead;
			if ((pEntry) != null)
			{
				pHead = (pEntry->count) != 0 ? pEntry->chain : null;
				pEntry->count++;
				pEntry->chain = pNew;
			}
			else
			{
				pHead = null;
			}

			if ((pHead) != null)
			{
				pNew->next = pHead;
				pNew->prev = pHead->prev;
				if ((pHead->prev) != null)
				{
					pHead->prev->next = pNew;
				}
				else
				{
					pH->first = pNew;
				}

				pHead->prev = pNew;
			}
			else
			{
				pNew->next = pH->first;
				if ((pH->first) != null)
				{
					pH->first->prev = pNew;
				}

				pNew->prev = null;
				pH->first = pNew;
			}
		}
		public static int rehash(Hash* pH, uint new_size)
		{
			_ht* new_ht;
			HashElem* elem; HashElem* next_elem;
			if ((new_size * sizeof(_ht)) > (1024))
			{
				new_size = (uint)(1024 / sizeof(_ht));
			}

			if ((new_size) == (pH->htsize))
				return (int)(0);
			sqlite3BeginBenignMalloc();
			new_ht = (_ht*)(sqlite3Malloc((ulong)(new_size * sizeof(_ht))));
			sqlite3EndBenignMalloc();
			if ((new_ht) == (null))
				return (int)(0);
			sqlite3_free(pH->ht);
			pH->ht = new_ht;
			pH->htsize = (uint)(new_size = (uint)(sqlite3MallocSize(new_ht) / sizeof(_ht)));
			CRuntime.memset(new_ht, (int)(0), (ulong)(new_size * sizeof(_ht)));
			for (elem = pH->first, pH->first = null; elem; elem = next_elem)
			{
				uint h = (uint)(strHash(elem->pKey) % new_size);
				next_elem = elem->next;
				insertElement(pH, &new_ht[h], elem);
			}

			return (int)(1);
		}
		public static void removeElementGivenHash(Hash* pH, HashElem* elem, uint h)
		{
			_ht* pEntry;
			if ((elem->prev) != null)
			{
				elem->prev->next = elem->next;
			}
			else
			{
				pH->first = elem->next;
			}

			if ((elem->next) != null)
			{
				elem->next->prev = elem->prev;
			}

			if ((pH->ht) != null)
			{
				pEntry = &pH->ht[h];
				if ((pEntry->chain) == (elem))
				{
					pEntry->chain = elem->next;
				}

				pEntry->count--;
			}

			sqlite3_free(elem);
			pH->count--;
			if ((pH->count) == (0))
			{
				sqlite3HashClear(pH);
			}
		}
		public static void sqlite3HashClear(Hash* pH)
		{
			HashElem* elem;
			elem = pH->first;
			pH->first = null;
			sqlite3_free(pH->ht);
			pH->ht = null;
			pH->htsize = (uint)(0);
			while ((elem) != null)
			{
				HashElem* next_elem = elem->next;
				sqlite3_free(elem);
				elem = next_elem;
			}

			pH->count = (uint)(0);
		}
		public static void sqlite3HashInit(Hash* pNew)
		{
			pNew->first = null;
			pNew->count = (uint)(0);
			pNew->htsize = (uint)(0);
			pNew->ht = null;
		}
	}
}