// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void estimateTableWidth(Table pTab)
		{
			uint wTable = (uint)(0);
			Column* pTabCol;
			int i = 0;
			for (i = (int)(pTab.nCol), pTabCol = pTab.aCol; (i) > (0); i--, pTabCol++)
			{
				wTable += (uint)(pTabCol->szEst);
			}

			if ((pTab.iPKey) < (0))
				wTable++;
			pTab.szTabRow = (short)(sqlite3LogEst((ulong)(wTable * 4)));
		}
		public static int fkChildIsModified(Table pTab, FKey p, int* aChange, int bChngRowid)
		{
			int i = 0;
			for (i = (int)(0); (i) < (p.nCol); i++)
			{
				int iChildKey = (int)(p.aCol[i].iFrom);
				if ((aChange[iChildKey]) >= (0))
					return (int)(1);
				if (((iChildKey) == (pTab.iPKey)) && ((bChngRowid) != 0))
					return (int)(1);
			}

			return (int)(0);
		}
		public static int fkParentIsModified(Table pTab, FKey p, int* aChange, int bChngRowid)
		{
			int i = 0;
			for (i = (int)(0); (i) < (p.nCol); i++)
			{
				sbyte* zKey = p.aCol[i].zCol;
				int iKey = 0;
				for (iKey = (int)(0); (iKey) < (pTab.nCol); iKey++)
				{
					if (((aChange[iKey]) >= (0)) || (((iKey) == (pTab.iPKey)) && ((bChngRowid) != 0)))
					{
						Column* pCol = &pTab.aCol[iKey];
						if ((zKey) != null)
						{
							if ((0) == (sqlite3StrICmp(pCol->zCnName, zKey)))
								return (int)(1);
						}
						else if ((pCol->colFlags & 0x0001) != 0)
						{
							return (int)(1);
						}
					}
				}
			}

			return (int)(0);
		}
		public static Expr sqlite3ColumnExpr(Table pTab, Column* pCol)
		{
			if ((pCol->iDflt) == (0))
				return null;
			if ((!(((pTab).eTabType) == (0))) != 0)
				return null;
			if (((pTab.u.tab.pDfltList) == (null)))
				return null;
			if (((pTab.u.tab.pDfltList.nExpr) < (pCol->iDflt)))
				return null;
			return pTab.u.tab.pDfltList.a[pCol->iDflt - 1].pExpr;
		}
		public static int sqlite3ColumnIndex(Table pTab, sbyte* zCol)
		{
			int i = 0;
			byte h = (byte)(sqlite3StrIHash(zCol));
			Column* pCol;
			for (pCol = pTab.aCol, i = (int)(0); (i) < (pTab.nCol); pCol++, i++)
			{
				if (((pCol->hName) == (h)) && ((sqlite3StrICmp(pCol->zCnName, zCol)) == (0)))
					return (int)(i);
			}

			return (int)(-1);
		}
		public static FKey sqlite3FkReferences(Table pTab)
		{
			return (FKey)(sqlite3HashFind(&pTab.pSchema.fkeyHash, pTab.zName));
		}
		public static Index sqlite3PrimaryKeyIndex(Table pTab)
		{
			Index p;
			for (p = pTab.pIndex; ((p) != null) && (!(((p).idxType) == (2))); p = p.pNext)
			{
			}

			return p;
		}
		public static short sqlite3StorageColumnToTable(Table pTab, short iCol)
		{
			if ((pTab.tabFlags & 0x00000020) != 0)
			{
				int i = 0;
				for (i = (int)(0); (i) <= (iCol); i++)
				{
					if ((pTab.aCol[i].colFlags & 0x0020) != 0)
						iCol++;
				}
			}

			return (short)(iCol);
		}
		public static sbyte sqlite3TableColumnAffinity(Table pTab, int iCol)
		{
			if (((iCol) < (0)) || ((iCol) >= (pTab.nCol)))
				return (sbyte)(0x44);
			return (sbyte)(pTab.aCol[iCol].affinity);
		}
		public static short sqlite3TableColumnToStorage(Table pTab, short iCol)
		{
			int i = 0;
			short n = 0;
			if (((pTab.tabFlags & 0x00000020) == (0)) || ((iCol) < (0)))
				return (short)(iCol);
			for (i = (int)(0), n = (short)(0); (i) < (iCol); i++)
			{
				if ((pTab.aCol[i].colFlags & 0x0020) == (0))
					n++;
			}

			if ((pTab.aCol[i].colFlags & 0x0020) != 0)
			{
				return (short)(pTab.nNVCol + i - n);
			}
			else
			{
				return (short)(n);
			}
		}
	}
}