// Generated by Sichem at 3/31/2022 10:01:59 PM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static void absFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{


			switch (sqlite3_value_type(argv[0]))
			{
				case 1:
					{
						long iVal = (long)(sqlite3_value_int64(argv[0]));
						if ((iVal) < (0))
						{
							if ((iVal) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
							{
								sqlite3_result_error(context, "integer overflow", (int)(-1));
								return;
							}

							iVal = (long)(-iVal);
						}

						sqlite3_result_int64(context, (long)(iVal));
						break;
					}

				case 5:
					{
						sqlite3_result_null(context);
						break;
					}

				default:
					{
						double rVal = (double)(sqlite3_value_double(argv[0]));
						if ((rVal) < (0))
							rVal = (double)(-rVal);
						sqlite3_result_double(context, (double)(rVal));
						break;
					}
			}
		}
		public static int accessPayload(BtCursor pCur, uint offset, uint amt, byte* pBuf, int eOp)
		{
			byte* aPayload;
			int rc = (int)(0);
			int iIdx = (int)(0);
			MemPage pPage = pCur.pPage;
			BtShared pBt = pCur.pBt;



			if ((pCur.ix) >= (pPage.nCell))
			{
				return (int)(sqlite3CorruptError((int)(71050)));
			}


			getCellInfo(pCur);
			aPayload = pCur.info.pPayload;


			if (((ulong)(aPayload - pPage.aData)) > (pBt.usableSize - pCur.info.nLocal))
			{
				return (int)(sqlite3CorruptError((int)(71065)));
			}

			if ((offset) < (pCur.info.nLocal))
			{
				int a = (int)(amt);
				if ((a + offset) > (pCur.info.nLocal))
				{
					a = (int)(pCur.info.nLocal - offset);
				}

				rc = (int)(copyPayload(&aPayload[offset], pBuf, (int)(a), (int)(eOp), pPage.pDbPage));
				offset = (uint)(0);
				pBuf += a;
				amt -= (uint)(a);
			}
			else
			{
				offset -= (uint)(pCur.info.nLocal);
			}

			if (((rc) == (0)) && ((amt) > (0)))
			{
				uint ovflSize = (uint)(pBt.usableSize - 4);
				uint nextPage = 0;
				nextPage = (uint)(sqlite3Get4byte(&aPayload[pCur.info.nLocal]));
				if ((pCur.curFlags & 0x04) == (0))
				{
					int nOvfl = (int)((pCur.info.nPayload - pCur.info.nLocal + ovflSize - 1) / ovflSize);
					if (((pCur.aOverflow) == (null)) || ((nOvfl * (int)(sizeof(uint))) > (sqlite3MallocSize(pCur.aOverflow))))
					{
						uint* aNew = (uint*)(sqlite3Realloc(pCur.aOverflow, (ulong)(nOvfl * 2 * sizeof(uint))));
						if ((aNew) == (null))
						{
							return (int)(7);
						}
						else
						{
							pCur.aOverflow = aNew;
						}
					}

					CRuntime.memset(pCur.aOverflow, (int)(0), (ulong)(nOvfl * sizeof(uint)));
					pCur.curFlags |= (byte)(0x04);
				}
				else
				{
					if ((pCur.aOverflow[offset / ovflSize]) != 0)
					{
						iIdx = (int)(offset / ovflSize);
						nextPage = (uint)(pCur.aOverflow[iIdx]);
						offset = (uint)(offset % ovflSize);
					}
				}


				while ((nextPage) != 0)
				{
					if ((nextPage) > (pBt.nPage))
						return (int)(sqlite3CorruptError((int)(71127)));

					pCur.aOverflow[iIdx] = (uint)(nextPage);
					if ((offset) >= (ovflSize))
					{


						if ((pCur.aOverflow[iIdx + 1]) != 0)
						{
							nextPage = (uint)(pCur.aOverflow[iIdx + 1]);
						}
						else
						{
							rc = (int)(getOverflowPage(pBt, (uint)(nextPage), null, &nextPage));
						}

						offset -= (uint)(ovflSize);
					}
					else
					{
						int a = (int)(amt);
						if ((a + offset) > (ovflSize))
						{
							a = (int)(ovflSize - offset);
						}

						{
							PgHdr pDbPage;
							rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(nextPage), pDbPage, (int)((eOp) == (0) ? 0x02 : 0)));
							if ((rc) == (0))
							{
								aPayload = sqlite3PagerGetData(pDbPage);
								nextPage = (uint)(sqlite3Get4byte(aPayload));
								rc = (int)(copyPayload(&aPayload[offset + 4], pBuf, (int)(a), (int)(eOp), pDbPage));
								sqlite3PagerUnref(pDbPage);
								offset = (uint)(0);
							}
						}

						amt -= (uint)(a);
						if ((amt) == (0))
							return (int)(rc);
						pBuf += a;
					}

					if ((rc) != 0)
						break;
					iIdx++;
				}
			}

			if (((rc) == (0)) && ((amt) > (0)))
			{
				return (int)(sqlite3CorruptError((int)(71212)));
			}

			return (int)(rc);
		}
		public static int accessPayloadChecked(BtCursor pCur, uint offset, uint amt, void* pBuf)
		{
			int rc = 0;
			if ((pCur.eState) == (1))
			{
				return (int)(4);
			}


			rc = (int)(btreeRestoreCursorPosition(pCur));
			return (int)((rc) != 0 ? rc : accessPayload(pCur, (uint)(offset), (uint)(amt), pBuf, (int)(0)));
		}
		public static sbyte* actionName(byte action)
		{
			sbyte* zName;
			switch (action)
			{
				case 8:
					zName = "SET NULL";
					break;
				case 9:
					zName = "SET DEFAULT";
					break;
				case 10:
					zName = "CASCADE";
					break;
				case 7:
					zName = "RESTRICT";
					break;
				default:
					zName = "NO ACTION";

					break;
			}

			return zName;
		}
		public static int addAggInfoColumn(sqlite3 db, AggInfo pInfo)
		{
			int i = 0;
			pInfo.aCol = sqlite3ArrayAllocate(db, pInfo.aCol, (int)(sizeof(AggInfo_col)), &pInfo.nColumn, &i);
			return (int)(i);
		}
		public static int addAggInfoFunc(sqlite3 db, AggInfo pInfo)
		{
			int i = 0;
			pInfo.aFunc = sqlite3ArrayAllocate(db, pInfo.aFunc, (int)(sizeof(AggInfo_func)), &pInfo.nFunc, &i);
			return (int)(i);
		}
		public static void addArgumentToVtab(Parse pParse)
		{
			if (((pParse.sArg.z) != null) && ((pParse.pNewTable) != null))
			{
				sbyte* z = pParse.sArg.z;
				int n = (int)(pParse.sArg.n);
				sqlite3 db = pParse.db;
				addModuleArgument(pParse, pParse.pNewTable, sqlite3DbStrNDup(db, z, (ulong)(n)));
			}
		}
		public static void addModuleArgument(Parse pParse, Table pTable, sbyte* zArg)
		{
			long nBytes = 0;
			sbyte** azModuleArg;
			sqlite3 db = pParse.db;

			nBytes = (long)(sizeof(char*) * (2 + pTable.u.vtab.nArg));
			if ((pTable.u.vtab.nArg + 3) >= (db.aLimit[2]))
			{
				sqlite3ErrorMsg(pParse, "too many columns on %s", pTable.zName);
			}

			azModuleArg = sqlite3DbRealloc(db, pTable.u.vtab.azArg, (ulong)(nBytes));
			if ((azModuleArg) == (null))
			{
				sqlite3DbFree(db, zArg);
			}
			else
			{
				int i = (int)(pTable.u.vtab.nArg++);
				azModuleArg[i] = zArg;
				azModuleArg[i + 1] = null;
				pTable.u.vtab.azArg = azModuleArg;
			}
		}
		public static int addToSavepointBitvecs(Pager pPager, uint pgno)
		{
			int ii = 0;
			int rc = (int)(0);
			for (ii = (int)(0); (ii) < (pPager.nSavepoint); ii++)
			{
				PagerSavepoint* p = &pPager.aSavepoint[ii];
				if ((pgno) <= (p->nOrig))
				{
					rc |= (int)(sqlite3BitvecSet(p->pInSavepoint, (uint)(pgno)));

				}
			}

			return (int)(rc);
		}
		public static void addToVTrans(sqlite3 db, VTable pVTab)
		{
			db.aVTrans[db.nVTrans++] = pVTab;
			sqlite3VtabLock(pVTab);
		}
		public static void addWhereTerm(Parse pParse, SrcList pSrc, int iLeft, int iColLeft, int iRight, int iColRight, int isOuterJoin, Expr ppWhere)
		{
			sqlite3 db = pParse.db;
			Expr pE1;
			Expr pE2;
			Expr pEq;




			pE1 = sqlite3CreateColumnExpr(db, pSrc, (int)(iLeft), (int)(iColLeft));
			pE2 = sqlite3CreateColumnExpr(db, pSrc, (int)(iRight), (int)(iColRight));
			pEq = sqlite3PExpr(pParse, (int)(53), pE1, pE2);

			if (((pEq) != null) && ((isOuterJoin) != 0))
			{
				(pEq).flags |= (uint)(0x000001);

				pEq.w.iRightJoinTable = (int)(pE2.iTable);
			}

			ppWhere = sqlite3ExprAnd(pParse, ppWhere, pEq);
		}
		public static void agginfoFree(sqlite3 db, AggInfo p)
		{
			sqlite3DbFree(db, p.aCol);
			sqlite3DbFree(db, p.aFunc);
			sqlite3DbFreeNN(db, p);
		}
		public static int agginfoPersistExprCb(Walker pWalker, Expr pExpr)
		{
			if (((!(((pExpr).flags & (0x004000 | 0x002000)) != 0)) != 0) && (pExpr.pAggInfo != null))
			{
				AggInfo pAggInfo = pExpr.pAggInfo;
				int iAgg = (int)(pExpr.iAgg);
				Parse pParse = pWalker.pParse;
				sqlite3 db = pParse.db;

				if ((pExpr.op) == (169))
				{

					if ((pAggInfo.aCol[iAgg].pCExpr) == (pExpr))
					{
						pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
						if ((pExpr) != null)
						{
							pAggInfo.aCol[iAgg].pCExpr = pExpr;
							sqlite3ExprDeferredDelete(pParse, pExpr);
						}
					}
				}
				else
				{

					if ((pAggInfo.aFunc[iAgg].pFExpr) == (pExpr))
					{
						pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
						if ((pExpr) != null)
						{
							pAggInfo.aFunc[iAgg].pFExpr = pExpr;
							sqlite3ExprDeferredDelete(pParse, pExpr);
						}
					}
				}
			}

			return (int)(0);
		}
		public static int allocateBtreePage(BtShared pBt, MemPage ppPage, uint* pPgno, uint nearby, byte eMode)
		{
			MemPage pPage1;
			int rc = 0;
			uint n = 0;
			uint k = 0;
			MemPage pTrunk = null;
			MemPage pPrevTrunk = null;
			uint mxPage = 0;


			pPage1 = pBt.pPage1;
			mxPage = (uint)(btreePagecount(pBt));
			n = (uint)(sqlite3Get4byte(&pPage1.aData[36]));
			if ((n) >= (mxPage))
			{
				return (int)(sqlite3CorruptError((int)(72259)));
			}

			if ((n) > (0))
			{
				uint iTrunk = 0;
				byte searchList = (byte)(0);
				uint nSearch = (uint)(0);
				if ((eMode) == (1))
				{
					if ((nearby) <= (mxPage))
					{
						byte eType = 0;


						rc = (int)(ptrmapGet(pBt, (uint)(nearby), &eType, null));
						if ((rc) != 0)
							return (int)(rc);
						if ((eType) == (2))
						{
							searchList = (byte)(1);
						}
					}
				}
				else if ((eMode) == (2))
				{
					searchList = (byte)(1);
				}

				rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
				if ((rc) != 0)
					return (int)(rc);
				sqlite3Put4byte(&pPage1.aData[36], (uint)(n - 1));
				do
				{
					pPrevTrunk = pTrunk;
					if ((pPrevTrunk) != null)
					{
						iTrunk = (uint)(sqlite3Get4byte(&pPrevTrunk.aData[0]));
					}
					else
					{
						iTrunk = (uint)(sqlite3Get4byte(&pPage1.aData[32]));
					}

					if (((iTrunk) > (mxPage)) || ((nSearch++) > (n)))
					{
						rc = (int)(sqlite3CorruptError((int)(72315)));
					}
					else
					{
						rc = (int)(btreeGetUnusedPage(pBt, (uint)(iTrunk), pTrunk, (int)(0)));
					}

					if ((rc) != 0)
					{
						pTrunk = null;
						goto end_allocate_page;
					}



					k = (uint)(sqlite3Get4byte(&pTrunk.aData[4]));
					if (((k) == (0)) && (searchList == 0))
					{

						rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
						if ((rc) != 0)
						{
							goto end_allocate_page;
						}

						*pPgno = (uint)(iTrunk);
						CRuntime.memcpy(&pPage1.aData[32], &pTrunk.aData[0], (ulong)(4));
						ppPage = pTrunk;
						pTrunk = null;
					}
					else if ((k) > (pBt.usableSize / 4 - 2))
					{
						rc = (int)(sqlite3CorruptError((int)(72344)));
						goto end_allocate_page;
					}
					else if (((searchList) != 0) && (((nearby) == (iTrunk)) || (((iTrunk) < (nearby)) && ((eMode) == (2)))))
					{
						*pPgno = (uint)(iTrunk);
						ppPage = pTrunk;
						searchList = (byte)(0);
						rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
						if ((rc) != 0)
						{
							goto end_allocate_page;
						}

						if ((k) == (0))
						{
							if (pPrevTrunk == null)
							{
								CRuntime.memcpy(&pPage1.aData[32], &pTrunk.aData[0], (ulong)(4));
							}
							else
							{
								rc = (int)(sqlite3PagerWrite(pPrevTrunk.pDbPage));
								if (rc != 0)
								{
									goto end_allocate_page;
								}

								CRuntime.memcpy(&pPrevTrunk.aData[0], &pTrunk.aData[0], (ulong)(4));
							}
						}
						else
						{
							MemPage pNewTrunk;
							uint iNewTrunk = (uint)(sqlite3Get4byte(&pTrunk.aData[8]));
							if ((iNewTrunk) > (mxPage))
							{
								rc = (int)(sqlite3CorruptError((int)(72378)));
								goto end_allocate_page;
							}

							rc = (int)(btreeGetUnusedPage(pBt, (uint)(iNewTrunk), pNewTrunk, (int)(0)));
							if (rc != 0)
							{
								goto end_allocate_page;
							}

							rc = (int)(sqlite3PagerWrite(pNewTrunk.pDbPage));
							if (rc != 0)
							{
								releasePage(pNewTrunk);
								goto end_allocate_page;
							}

							CRuntime.memcpy(&pNewTrunk.aData[0], &pTrunk.aData[0], (ulong)(4));
							sqlite3Put4byte(&pNewTrunk.aData[4], (uint)(k - 1));
							CRuntime.memcpy(&pNewTrunk.aData[8], &pTrunk.aData[12], (ulong)((k - 1) * 4));
							releasePage(pNewTrunk);
							if (pPrevTrunk == null)
							{

								sqlite3Put4byte(&pPage1.aData[32], (uint)(iNewTrunk));
							}
							else
							{
								rc = (int)(sqlite3PagerWrite(pPrevTrunk.pDbPage));
								if ((rc) != 0)
								{
									goto end_allocate_page;
								}

								sqlite3Put4byte(&pPrevTrunk.aData[0], (uint)(iNewTrunk));
							}
						}

						pTrunk = null;
					}
					else if ((k) > (0))
					{
						uint closest = 0;
						uint iPage = 0;
						byte* aData = pTrunk.aData;
						if ((nearby) > (0))
						{
							uint i = 0;
							closest = (uint)(0);
							if ((eMode) == (2))
							{
								for (i = (uint)(0); (i) < (k); i++)
								{
									iPage = (uint)(sqlite3Get4byte(&aData[8 + i * 4]));
									if ((iPage) <= (nearby))
									{
										closest = (uint)(i);
										break;
									}
								}
							}
							else
							{
								int dist = 0;
								dist = (int)(sqlite3AbsInt32((int)(sqlite3Get4byte(&aData[8]) - nearby)));
								for (i = (uint)(1); (i) < (k); i++)
								{
									int d2 = (int)(sqlite3AbsInt32((int)(sqlite3Get4byte(&aData[8 + i * 4]) - nearby)));
									if ((d2) < (dist))
									{
										closest = (uint)(i);
										dist = (int)(d2);
									}
								}
							}
						}
						else
						{
							closest = (uint)(0);
						}

						iPage = (uint)(sqlite3Get4byte(&aData[8 + closest * 4]));
						if (((iPage) > (mxPage)) || ((iPage) < (2)))
						{
							rc = (int)(sqlite3CorruptError((int)(72443)));
							goto end_allocate_page;
						}

						if ((searchList == 0) || (((iPage) == (nearby)) || (((iPage) < (nearby)) && ((eMode) == (2)))))
						{
							int noContent = 0;
							*pPgno = (uint)(iPage);
							rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
							if ((rc) != 0)
								goto end_allocate_page;
							if ((closest) < (k - 1))
							{
								CRuntime.memcpy(&aData[8 + closest * 4], &aData[4 + k * 4], (ulong)(4));
							}

							sqlite3Put4byte(&aData[4], (uint)(k - 1));
							noContent = (int)((!btreeGetHasContent(pBt, (uint)(*pPgno))) != 0 ? 0x01 : 0);
							rc = (int)(btreeGetUnusedPage(pBt, (uint)(*pPgno), ppPage, (int)(noContent)));
							if ((rc) == (0))
							{
								rc = (int)(sqlite3PagerWrite((ppPage).pDbPage));
								if (rc != 0)
								{
									releasePage(ppPage);
									ppPage = null;
								}
							}

							searchList = (byte)(0);
						}
					}

					releasePage(pPrevTrunk);
					pPrevTrunk = null;
				}
				while ((searchList) != 0);
			}
			else
			{
				int bNoContent = (int)(((0) == (pBt.bDoTruncate)) ? 0x01 : 0);
				rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
				if ((rc) != 0)
					return (int)(rc);
				pBt.nPage++;
				if ((pBt.nPage) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
					pBt.nPage++;
				if (((pBt.autoVacuum) != 0) && ((ptrmapPageno((pBt), (uint)(pBt.nPage))) == (pBt.nPage)))
				{
					MemPage pPg = null;

					rc = (int)(btreeGetUnusedPage(pBt, (uint)(pBt.nPage), pPg, (int)(bNoContent)));
					if ((rc) == (0))
					{
						rc = (int)(sqlite3PagerWrite(pPg.pDbPage));
						releasePage(pPg);
					}

					if ((rc) != 0)
						return (int)(rc);
					pBt.nPage++;
					if ((pBt.nPage) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
					{
						pBt.nPage++;
					}
				}

				sqlite3Put4byte(28 + pBt.pPage1.aData, (uint)(pBt.nPage));
				*pPgno = (uint)(pBt.nPage);

				rc = (int)(btreeGetUnusedPage(pBt, (uint)(*pPgno), ppPage, (int)(bNoContent)));
				if ((rc) != 0)
					return (int)(rc);
				rc = (int)(sqlite3PagerWrite((ppPage).pDbPage));
				if (rc != 0)
				{
					releasePage(ppPage);
					ppPage = null;
				}
			}


		end_allocate_page:
			; releasePage(pTrunk);
			releasePage(pPrevTrunk);


			return (int)(rc);
		}
		public static VdbeCursor allocateCursor(Vdbe p, int iCur, int nField, byte eCurType)
		{
			sqlite3_value pMem = (iCur) > (0) ? p.aMem[p.nMem - iCur] : p.aMem;
			int nByte = 0;
			VdbeCursor pCx = null;
			nByte = (int)((((sizeof(VdbeCursor)) + 7) & ~7) + 2 * sizeof(uint) * nField + ((eCurType) == (0) ? sqlite3BtreeCursorSize() : 0));

			if ((p.apCsr[iCur]) != null)
			{
				sqlite3VdbeFreeCursor(p, p.apCsr[iCur]);
				p.apCsr[iCur] = null;
			}




			if ((pMem.szMalloc) < (nByte))
			{
				if ((pMem.szMalloc) > (0))
				{
					sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
				}

				pMem.z = pMem.zMalloc = sqlite3DbMallocRaw(pMem.db, (ulong)(nByte));
				if ((pMem.zMalloc) == (null))
				{
					pMem.szMalloc = (int)(0);
					return null;
				}

				pMem.szMalloc = (int)(nByte);
			}

			p.apCsr[iCur] = pCx = (VdbeCursor)(pMem.zMalloc);
			CRuntime.memset(pCx, (int)(0), ((ulong)((0).pAltCursor)));
			pCx.eCurType = (byte)(eCurType);
			pCx.nField = (short)(nField);
			pCx.aOffset = &pCx.aType[nField];
			if ((eCurType) == (0))
			{
				pCx.uc.pCursor = (BtCursor)(&pMem.z[(((sizeof(VdbeCursor)) + 7) & ~7) + 2 * sizeof(uint) * nField]);
				sqlite3BtreeCursorZero(pCx.uc.pCursor);
			}

			return pCx;
		}
		public static sqlite3_index_info* allocateIndexInfo(WhereInfo pWInfo, WhereClause pWC, ulong mUnusable, SrcItem pSrc, ushort* pmNoOmit)
		{
			int i = 0; int j = 0;
			int nTerm = 0;
			Parse pParse = pWInfo.pParse;
			sqlite3_index_constraint* pIdxCons;
			sqlite3_index_orderby* pIdxOrderBy;
			sqlite3_index_constraint_usage* pUsage;
			HiddenIndexInfo pHidden;
			WhereTerm pTerm;
			int nOrderBy = 0;
			sqlite3_index_info* pIdxInfo;
			ushort mNoOmit = (ushort)(0);
			Table pTab;
			int eDistinct = (int)(0);
			ExprList pOrderBy = pWInfo.pOrderBy;

			pTab = pSrc.pTab;


			for (i = (int)(nTerm = (int)(0)), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				pTerm.wtFlags &= (ushort)(~0x0040);
				if (pTerm.leftCursor != pSrc.iCursor)
					continue;
				if ((pTerm.prereqRight & mUnusable) != 0)
					continue;

				if ((pTerm.eOperator & ~(0x0800)) == (0))
					continue;
				if ((pTerm.wtFlags & 0x0080) != 0)
					continue;



				if (((pSrc.fg.jointype & 0x0008) != 0) && (!(((pTerm.pExpr).flags & (0x000001)) != 0)))
				{
					continue;
				}

				nTerm++;
				pTerm.wtFlags |= (ushort)(0x0040);
			}

			nOrderBy = (int)(0);
			if ((pOrderBy) != null)
			{
				int n = (int)(pOrderBy.nExpr);
				for (i = (int)(0); (i) < (n); i++)
				{
					Expr pExpr = pOrderBy.a[i].pExpr;
					Expr pE2;
					if ((sqlite3ExprIsConstant(pExpr)) != 0)
					{
						continue;
					}

					if ((pOrderBy.a[i].sortFlags & 0x02) != 0)
						break;
					if (((pExpr.op) == (167)) && ((pExpr.iTable) == (pSrc.iCursor)))
					{

						continue;
					}

					if ((((pExpr.op) == (113)) && (((pE2 = pExpr.pLeft).op) == (167))) && ((pE2.iTable) == (pSrc.iCursor)))
					{
						sbyte* zColl;



						pExpr.iColumn = (short)(pE2.iColumn);
						if ((pE2.iColumn) < (0))
							continue;
						zColl = sqlite3ColumnColl(&pTab.aCol[pE2.iColumn]);
						if ((zColl) == (null))
							zColl = sqlite3StrBINARY;
						if ((sqlite3_stricmp(pExpr.u.zToken, zColl)) == (0))
							continue;
					}

					break;
				}

				if ((i) == (n))
				{
					nOrderBy = (int)(n);
					if ((pWInfo.wctrlFlags & (0x0040 | 0x0080)) != 0)
					{
						eDistinct = (int)(1 + ((pWInfo.wctrlFlags & 0x0080) != 0));
					}
				}
			}

			pIdxInfo = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(sqlite3_index_info) + (sizeof(sqlite3_index_constraint) + sizeof(sqlite3_index_constraint_usage)) * nTerm + sizeof(sqlite3_index_orderby) * nOrderBy + sizeof(HiddenIndexInfo) + sizeof(sqlite3_value) * nTerm));
			if ((pIdxInfo) == (null))
			{
				sqlite3ErrorMsg(pParse, "out of memory");
				return null;
			}

			pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			pIdxCons = (sqlite3_index_constraint*)(pHidden.aRhs[nTerm]);
			pIdxOrderBy = (sqlite3_index_orderby*)(&pIdxCons[nTerm]);
			pUsage = (sqlite3_index_constraint_usage*)(&pIdxOrderBy[nOrderBy]);
			pIdxInfo->aConstraint = pIdxCons;
			pIdxInfo->aOrderBy = pIdxOrderBy;
			pIdxInfo->aConstraintUsage = pUsage;
			pHidden.pWC = pWC;
			pHidden.pParse = pParse;
			pHidden.eDistinct = (int)(eDistinct);
			pHidden.mIn = (uint)(0);
			for (i = (int)(j = (int)(0)), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				ushort op = 0;
				if ((pTerm.wtFlags & 0x0040) == (0))
					continue;
				pIdxCons[j].iColumn = (int)(pTerm.u.x.leftColumn);
				pIdxCons[j].iTermOffset = (int)(i);
				op = (ushort)(pTerm.eOperator & 0x1fff);
				if ((op) == (0x0001))
				{
					if ((pTerm.wtFlags & 0x8000) == (0))
					{
						pHidden.mIn |= (uint)((j) <= (31) ? ((uint)(1)) << (j) : 0);
					}

					op = (ushort)(0x0002);
				}

				if ((op) == (0x0040))
				{
					pIdxCons[j].op = (byte)(pTerm.eMatchOp);
				}
				else if ((op & (0x0100 | 0x0080)) != 0)
				{
					if ((op) == (0x0100))
					{
						pIdxCons[j].op = (byte)(71);
					}
					else
					{
						pIdxCons[j].op = (byte)(72);
					}
				}
				else
				{
					pIdxCons[j].op = ((byte)(op));






					if (((op & ((0x0002 << (56 - 53)) | (0x0002 << (55 - 53)) | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) != 0) && ((sqlite3ExprIsVector(pTerm.pExpr.pRight)) != 0))
					{
						if ((j) < (16))
							mNoOmit |= (ushort)(1 << j);
						if ((op) == (0x0002 << (56 - 53)))
							pIdxCons[j].op = (byte)(0x0002 << (55 - 53));
						if ((op) == (0x0002 << (54 - 53)))
							pIdxCons[j].op = (byte)(0x0002 << (57 - 53));
					}
				}

				j++;
			}


			pIdxInfo->nConstraint = (int)(j);
			for (i = (int)(j = (int)(0)); (i) < (nOrderBy); i++)
			{
				Expr pExpr = pOrderBy.a[i].pExpr;
				if ((sqlite3ExprIsConstant(pExpr)) != 0)
					continue;

				pIdxOrderBy[j].iColumn = (int)(pExpr.iColumn);
				pIdxOrderBy[j].desc = (byte)(pOrderBy.a[i].sortFlags & 0x01);
				j++;
			}

			pIdxInfo->nOrderBy = (int)(j);
			*pmNoOmit = (ushort)(mNoOmit);
			return pIdxInfo;
		}
		public static int allocateSpace(MemPage pPage, int nByte, int* pIdx)
		{
			int hdr = (int)(pPage.hdrOffset);
			byte* data = pPage.aData;
			int top = 0;
			int rc = (int)(0);
			int gap = 0;








			gap = (int)(pPage.cellOffset + 2 * pPage.nCell);

			top = (int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);

			if ((gap) > (top))
			{
				if (((top) == (0)) && ((pPage.pBt.usableSize) == (65536)))
				{
					top = (int)(65536);
				}
				else
				{
					return (int)(sqlite3CorruptError((int)(67837)));
				}
			}

			if ((((data[hdr + 2]) != 0) || ((data[hdr + 1]) != 0)) && ((gap + 2) <= (top)))
			{
				byte* pSpace = pageFindSlot(pPage, (int)(nByte), &rc);
				if ((pSpace) != null)
				{
					int g2 = 0;

					*pIdx = (int)(g2 = ((int)(pSpace - data)));
					if ((g2) <= (gap))
					{
						return (int)(sqlite3CorruptError((int)(67855)));
					}
					else
					{
						return (int)(0);
					}
				}
				else if ((rc) != 0)
				{
					return (int)(rc);
				}
			}

			if ((gap + 2 + nByte) > (top))
			{


				rc = (int)(defragmentPage(pPage, (int)((4) < (pPage.nFree - (2 + nByte)) ? (4) : (pPage.nFree - (2 + nByte)))));
				if ((rc) != 0)
					return (int)(rc);
				top = (int)(((((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]) - 1) & 0xffff) + 1);

			}

			top -= (int)(nByte);
			((&data[hdr + 5])[0] = ((byte)((top) >> 8)), (&data[hdr + 5])[1] = ((byte)(top)));

			*pIdx = (int)(top);
			return (int)(0);
		}
		public static int allocateTempSpace(BtShared pBt)
		{



			pBt.pTmpSpace = sqlite3PageMalloc((int)(pBt.pageSize));
			if ((pBt.pTmpSpace) == (null))
			{
				BtCursor pCur = pBt.pCursor;
				pBt.pCursor = pCur.pNext;
				CRuntime.memset(pCur, (int)(0), (ulong)(sizeof(BtCursor)));
				return (int)(7);
			}

			CRuntime.memset(pBt.pTmpSpace, (int)(0), (ulong)(8));
			pBt.pTmpSpace += 4;
			return (int)(0);
		}
		public static void* allocSpace(ReusableSpace* p, void* pBuf, long nByte)
		{

			if ((pBuf) == (null))
			{
				nByte = (long)(((nByte) + 7) & ~7);
				if ((nByte) <= (p->nFree))
				{
					p->nFree -= (long)(nByte);
					pBuf = &p->pSpace[p->nFree];
				}
				else
				{
					p->nNeeded += (long)(nByte);
				}
			}


			return pBuf;
		}
		public static int allowedOp(int op)
		{




			return (((((op) == (49)) || (((op) >= (53)) && ((op) <= (57)))) || ((op) == (50))) || ((op) == (45)) ? 1 : 0);
		}
		public static int alsoAnInt(sqlite3_value pRec, double rValue, long* piValue)
		{
			long iValue = (long)(rValue);
			if ((sqlite3RealSameAsInt((double)(rValue), (long)(iValue))) != 0)
			{
				*piValue = (long)(iValue);
				return (int)(1);
			}

			return ((0) == (sqlite3Atoi64(pRec.z, piValue, (int)(pRec.n), (byte)(pRec.enc))) ? 1 : 0);
		}
		public static int analysisLoader(void* pData, int argc, sbyte** argv, sbyte** NotUsed)
		{
			analysisInfo pInfo = (analysisInfo)(pData);
			Index pIndex;
			Table pTable;
			sbyte* z;

			(void)(NotUsed) ,  (void)(argc);
			if ((((argv) == (null)) || ((argv[0]) == (null))) || ((argv[2]) == (null)))
			{
				return (int)(0);
			}

			pTable = sqlite3FindTable(pInfo.db, argv[0], pInfo.zDatabase);
			if ((pTable) == (null))
			{
				return (int)(0);
			}

			if ((argv[1]) == (null))
			{
				pIndex = null;
			}
			else if ((sqlite3_stricmp(argv[0], argv[1])) == (0))
			{
				pIndex = sqlite3PrimaryKeyIndex(pTable);
			}
			else
			{
				pIndex = sqlite3FindIndex(pInfo.db, argv[1], pInfo.zDatabase);
			}

			z = argv[2];
			if ((pIndex) != null)
			{
				uint* aiRowEst = null;
				int nCol = (int)(pIndex.nKeyCol + 1);
				pIndex.bUnordered = (uint)(0);
				decodeIntArray(z, (int)(nCol), aiRowEst, pIndex.aiRowLogEst, pIndex);
				pIndex.hasStat1 = (uint)(1);
				if ((pIndex.pPartIdxWhere) == (null))
				{
					pTable.nRowLogEst = (short)(pIndex.aiRowLogEst[0]);
					pTable.tabFlags |= (uint)(0x00000010);
				}
			}
			else
			{
				Index fakeIdx = new Index();
				fakeIdx.szIdxRow = (short)(pTable.szTabRow);
				decodeIntArray(z, (int)(1), null, &pTable.nRowLogEst, fakeIdx);
				pTable.szTabRow = (short)(fakeIdx.szIdxRow);
				pTable.tabFlags |= (uint)(0x00000010);
			}

			return (int)(0);
		}
		public static int analyzeAggregate(Walker pWalker, Expr pExpr)
		{
			int i = 0;
			NameContext pNC = pWalker.u.pNC;
			Parse pParse = pNC.pParse;
			SrcList pSrcList = pNC.pSrcList;
			AggInfo pAggInfo = pNC.uNC.pAggInfo;

			switch (pExpr.op)
			{
				case 169:
				case 167:
					{
						if ((pSrcList != null))
						{
							SrcItem pItem = pSrcList.a;
							for (i = (int)(0); (i) < (pSrcList.nSrc); i++, pItem++)
							{
								AggInfo_col* pCol;

								if ((pExpr.iTable) == (pItem.iCursor))
								{
									int k = 0;
									pCol = pAggInfo.aCol;
									for (k = (int)(0); (k) < (pAggInfo.nColumn); k++, pCol++)
									{
										if (((pCol->iTable) == (pExpr.iTable)) && ((pCol->iColumn) == (pExpr.iColumn)))
										{
											break;
										}
									}

									if (((k) >= (pAggInfo.nColumn)) && ((k = (int)(addAggInfoColumn(pParse.db, pAggInfo))) >= (0)))
									{
										pCol = &pAggInfo.aCol[k];

										pCol->pTab = pExpr.y.pTab;
										pCol->iTable = (int)(pExpr.iTable);
										pCol->iColumn = (short)(pExpr.iColumn);
										pCol->iMem = (int)(++pParse.nMem);
										pCol->iSorterColumn = (short)(-1);
										pCol->pCExpr = pExpr;
										if ((pAggInfo.pGroupBy) != null)
										{
											int j = 0;
											int n = 0;
											ExprList pGB = pAggInfo.pGroupBy;
											ExprList_item* pTerm = pGB.a;
											n = (int)(pGB.nExpr);
											for (j = (int)(0); (j) < (n); j++, pTerm++)
											{
												Expr pE = pTerm->pExpr;
												if ((((pE.op) == (167)) && ((pE.iTable) == (pExpr.iTable))) && ((pE.iColumn) == (pExpr.iColumn)))
												{
													pCol->iSorterColumn = (short)(j);
													break;
												}
											}
										}

										if ((pCol->iSorterColumn) < (0))
										{
											pCol->iSorterColumn = (short)(pAggInfo.nSortingColumn++);
										}
									}

									pExpr.pAggInfo = pAggInfo;
									pExpr.op = (byte)(169);
									pExpr.iAgg = ((short)(k));
									break;
								}
							}
						}

						return (int)(1);
					}

				case 168:
					{
						if (((pNC.ncFlags & 0x020000) == (0)) && ((pWalker.walkerDepth) == (pExpr.op2)))
						{
							AggInfo_func* pItem = pAggInfo.aFunc;
							for (i = (int)(0); (i) < (pAggInfo.nFunc); i++, pItem++)
							{
								if ((pItem->pFExpr) == (pExpr))
									break;
								if ((sqlite3ExprCompare(null, pItem->pFExpr, pExpr, (int)(-1))) == (0))
								{
									break;
								}
							}

							if ((i) >= (pAggInfo.nFunc))
							{
								byte enc = (byte)((pParse.db).enc);
								i = (int)(addAggInfoFunc(pParse.db, pAggInfo));
								if ((i) >= (0))
								{

									pItem = &pAggInfo.aFunc[i];
									pItem->pFExpr = pExpr;
									pItem->iMem = (int)(++pParse.nMem);

									pItem->pFunc = sqlite3FindFunction(pParse.db, pExpr.u.zToken, (int)(pExpr.x.pList ? pExpr.x.pList.nExpr : 0), (byte)(enc), (byte)(0));
									if ((pExpr.flags & 0x000002) != 0)
									{
										pItem->iDistinct = (int)(pParse.nTab++);
									}
									else
									{
										pItem->iDistinct = (int)(-1);
									}
								}
							}


							pExpr.iAgg = ((short)(i));
							pExpr.pAggInfo = pAggInfo;
							return (int)(1);
						}
						else
						{
							return (int)(0);
						}
					}
			}

			return (int)(0);
		}
		public static void analyzeDatabase(Parse pParse, int iDb)
		{
			sqlite3 db = pParse.db;
			Schema pSchema = db.aDb[iDb].pSchema;
			HashElem* k;
			int iStatCur = 0;
			int iMem = 0;
			int iTab = 0;
			sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
			iStatCur = (int)(pParse.nTab);
			pParse.nTab += (int)(3);
			openStatTable(pParse, (int)(iDb), (int)(iStatCur), null, null);
			iMem = (int)(pParse.nMem + 1);
			iTab = (int)(pParse.nTab);

			for (k = ((&pSchema.tblHash)->first); k; k = ((k)->next))
			{
				Table pTab = (Table)((k)->data);
				analyzeOneTable(pParse, pTab, null, (int)(iStatCur), (int)(iMem), (int)(iTab));
			}

			loadAnalysis(pParse, (int)(iDb));
		}
		public static int analyzeFilterKeyword(byte* z, int lastToken)
		{
			if (((lastToken) == (23)) && ((getToken(&z)) == (22)))
			{
				return (int)(166);
			}

			return (int)(59);
		}
		public static void analyzeOneTable(Parse pParse, Table pTab, Index pOnlyIdx, int iStatCur, int iMem, int iTab)
		{
			sqlite3 db = pParse.db;
			Index pIdx;
			int iIdxCur = 0;
			int iTabCur = 0;
			Vdbe v;
			int i = 0;
			int jZeroRows = (int)(-1);
			int iDb = 0;
			byte needTableCnt = (byte)(1);
			int regNewRowid = (int)(iMem++);
			int regStat = (int)(iMem++);
			int regChng = (int)(iMem++);
			int regRowid = (int)(iMem++);
			int regTemp = (int)(iMem++);
			int regTemp2 = (int)(iMem++);
			int regTabname = (int)(iMem++);
			int regIdxname = (int)(iMem++);
			int regStat1 = (int)(iMem++);
			int regPrev = (int)(iMem);
			pParse.nMem = (int)((pParse.nMem) > (iMem) ? (pParse.nMem) : (iMem));
			v = sqlite3GetVdbe(pParse);
			if (((v) == (null)) || ((pTab) == (null)))
			{
				return;
			}

			if (!(((pTab).eTabType) == (0)))
			{
				return;
			}

			if ((sqlite3_strlike("sqlite\\_%", pTab.zName, (uint)(92))) == (0))
			{
				return;
			}


			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));


			if ((sqlite3AuthCheck(pParse, (int)(28), pTab.zName, null, db.aDb[iDb].zDbSName)) != 0)
			{
				return;
			}

			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
			iTabCur = (int)(iTab++);
			iIdxCur = (int)(iTab++);
			pParse.nTab = (int)((pParse.nTab) > (iTab) ? (pParse.nTab) : (iTab));
			sqlite3OpenTable(pParse, (int)(iTabCur), (int)(iDb), pTab, (int)(101));
			sqlite3VdbeLoadString(v, (int)(regTabname), pTab.zName);
			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				int nCol = 0;
				int addrRewind = 0;
				int addrNextRow = 0;
				sbyte* zIdxName;
				int nColTest = 0;
				if (((pOnlyIdx) != null) && (pOnlyIdx != pIdx))
					continue;
				if ((pIdx.pPartIdxWhere) == (null))
					needTableCnt = (byte)(0);
				if ((!(((pTab).tabFlags & 0x00000080) == (0))) && (((pIdx).idxType) == (2)))
				{
					nCol = (int)(pIdx.nKeyCol);
					zIdxName = pTab.zName;
					nColTest = (int)(nCol - 1);
				}
				else
				{
					nCol = (int)(pIdx.nColumn);
					zIdxName = pIdx.zName;
					nColTest = (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol - 1 : nCol - 1);
				}

				sqlite3VdbeLoadString(v, (int)(regIdxname), zIdxName);
				pParse.nMem = (int)((pParse.nMem) > (regPrev + nColTest) ? (pParse.nMem) : (regPrev + nColTest));

				sqlite3VdbeAddOp3(v, (int)(101), (int)(iIdxCur), (int)(pIdx.tnum), (int)(iDb));
				sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(nCol), (int)(regStat + 1));

				sqlite3VdbeAddOp2(v, (int)(71), (int)(pIdx.nKeyCol), (int)(regRowid));
				{
					addrRewind = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iIdxCur)));
					sqlite3VdbeAddOp3(v, (int)(97), (int)(iIdxCur), (int)(regTemp), (int)(1));
				}


				sqlite3VdbeAddOp2(v, (int)(71), (int)(db.nAnalysisLimit), (int)(regTemp2));
				sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regStat + 1), (int)(regStat), (int)(4), statInitFuncdef, (int)(0));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regChng));
				addrNextRow = (int)(sqlite3VdbeCurrentAddr(v));
				if ((nColTest) > (0))
				{
					int endDistinctTest = (int)(sqlite3VdbeMakeLabel(pParse));
					int* aGotoChng;
					aGotoChng = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * nColTest));
					if ((aGotoChng) == (null))
						continue;
					sqlite3VdbeAddOp0(v, (int)(11));
					addrNextRow = (int)(sqlite3VdbeCurrentAddr(v));
					if ((((nColTest) == (1)) && ((pIdx.nKeyCol) == (1))) && ((pIdx).onError != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(51), (int)(regPrev), (int)(endDistinctTest));
					}

					for (i = (int)(0); (i) < (nColTest); i++)
					{
						sbyte* pColl = (sbyte*)(sqlite3LocateCollSeq(pParse, pIdx.azColl[i]));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(i), (int)(regChng));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(i), (int)(regTemp));
						aGotoChng[i] = (int)(sqlite3VdbeAddOp4(v, (int)(52), (int)(regTemp), (int)(0), (int)(regPrev + i), pColl, (int)(-2)));
						sqlite3VdbeChangeP5(v, (ushort)(0x80));
					}

					sqlite3VdbeAddOp2(v, (int)(71), (int)(nColTest), (int)(regChng));
					sqlite3VdbeGoto(v, (int)(endDistinctTest));
					sqlite3VdbeJumpHere(v, (int)(addrNextRow - 1));
					for (i = (int)(0); (i) < (nColTest); i++)
					{
						sqlite3VdbeJumpHere(v, (int)(aGotoChng[i]));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(i), (int)(regPrev + i));
					}

					sqlite3VdbeResolveLabel(v, (int)(endDistinctTest));
					sqlite3DbFree(db, aGotoChng);
				}


				{
					sqlite3VdbeAddFunctionCall(pParse, (int)(1), (int)(regStat), (int)(regTemp), (int)(2 + 0), statPushFuncdef, (int)(0));
					if ((db.nAnalysisLimit) != 0)
					{
						int j1 = 0;
						int j2 = 0;
						int j3 = 0;
						j1 = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(regTemp)));
						j2 = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(regTemp)));
						j3 = (int)(sqlite3VdbeAddOp4Int(v, (int)(26), (int)(iIdxCur), (int)(0), (int)(regPrev), (int)(1)));
						sqlite3VdbeJumpHere(v, (int)(j1));
						sqlite3VdbeAddOp2(v, (int)(5), (int)(iIdxCur), (int)(addrNextRow));
						sqlite3VdbeJumpHere(v, (int)(j2));
						sqlite3VdbeJumpHere(v, (int)(j3));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(5), (int)(iIdxCur), (int)(addrNextRow));
					}
				}

				callStatGet(pParse, (int)(regStat), (int)(0), (int)(regStat1));

				sqlite3VdbeAddOp4(v, (int)(96), (int)(regTabname), (int)(3), (int)(regTemp), "BBB", (int)(0));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(iStatCur), (int)(regNewRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(iStatCur), (int)(regTemp), (int)(regNewRowid));
				sqlite3VdbeChangeP5(v, (ushort)(0x08));
				sqlite3VdbeJumpHere(v, (int)(addrRewind));
			}

			if (((pOnlyIdx) == (null)) && ((needTableCnt) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(97), (int)(iTabCur), (int)(regStat1));
				jZeroRows = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regStat1)));
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regIdxname));

				sqlite3VdbeAddOp4(v, (int)(96), (int)(regTabname), (int)(3), (int)(regTemp), "BBB", (int)(0));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(iStatCur), (int)(regNewRowid));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(iStatCur), (int)(regTemp), (int)(regNewRowid));
				sqlite3VdbeChangeP5(v, (ushort)(0x08));
				sqlite3VdbeJumpHere(v, (int)(jZeroRows));
			}
		}
		public static int analyzeOverKeyword(byte* z, int lastToken)
		{
			if ((lastToken) == (23))
			{
				int t = (int)(getToken(&z));
				if (((t) == (22)) || ((t) == (59)))
					return (int)(165);
			}

			return (int)(59);
		}
		public static void analyzeTable(Parse pParse, Table pTab, Index pOnlyIdx)
		{
			int iDb = 0;
			int iStatCur = 0;


			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
			sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
			iStatCur = (int)(pParse.nTab);
			pParse.nTab += (int)(3);
			if ((pOnlyIdx) != null)
			{
				openStatTable(pParse, (int)(iDb), (int)(iStatCur), pOnlyIdx.zName, "idx");
			}
			else
			{
				openStatTable(pParse, (int)(iDb), (int)(iStatCur), pTab.zName, "tbl");
			}

			analyzeOneTable(pParse, pTab, pOnlyIdx, (int)(iStatCur), (int)(pParse.nMem + 1), (int)(pParse.nTab));
			loadAnalysis(pParse, (int)(iDb));
		}
		public static int analyzeWindowKeyword(byte* z)
		{
			int t = 0;
			t = (int)(getToken(&z));
			if (t != 59)
				return (int)(59);
			t = (int)(getToken(&z));
			if (t != 24)
				return (int)(59);
			return (int)(164);
		}
		public static int anotherValidCursor(BtCursor pCur)
		{
			BtCursor pOther;
			for (pOther = pCur.pBt.pCursor; pOther; pOther = pOther.pNext)
			{
				if (((pOther != pCur) && ((pOther.eState) == (0))) && ((pOther.pPage) == (pCur.pPage)))
				{
					return (int)(sqlite3CorruptError((int)(74723)));
				}
			}

			return (int)(0);
		}
		public static int apiHandleError(sqlite3 db, int rc)
		{
			if (((db.mallocFailed) != 0) || ((rc) == (10 | (12 << 8))))
			{
				sqlite3OomClear(db);
				sqlite3Error(db, (int)(7));
				return (int)(7);
			}

			return (int)(rc & db.errMask);
		}
		public static sbyte* appendText(sbyte* p, sbyte* z)
		{
			ulong n = (ulong)(CRuntime.strlen(z));
			CRuntime.memcpy(p, z, (ulong)(n + 1));
			return p + n + 1;
		}
		public static void applyAffinity(sqlite3_value pRec, sbyte affinity, byte enc)
		{
			if ((affinity) >= (0x43))
			{

				if ((pRec.flags & 0x0004) == (0))
				{
					if ((pRec.flags & 0x0008) == (0))
					{
						if ((pRec.flags & 0x0002) != 0)
							applyNumericAffinity(pRec, (int)(1));
					}
					else
					{
						sqlite3VdbeIntegerAffinity(pRec);
					}
				}
			}
			else if ((affinity) == (0x42))
			{
				if ((0) == (pRec.flags & 0x0002))
				{
					if ((pRec.flags & (0x0008 | 0x0004 | 0x0020)) != 0)
					{
						sqlite3VdbeMemStringify(pRec, (byte)(enc), (byte)(1));
					}
				}

				pRec.flags &= (ushort)(~(0x0008 | 0x0004 | 0x0020));
			}
		}
		public static void applyNumericAffinity(sqlite3_value pRec, int bTryForInt)
		{
			double rValue = 0;
			byte enc = (byte)(pRec.enc);
			int rc = 0;

			rc = (int)(sqlite3AtoF(pRec.z, &rValue, (int)(pRec.n), (byte)(enc)));
			if ((rc) <= (0))
				return;
			if (((rc) == (1)) && ((alsoAnInt(pRec, (double)(rValue), &pRec.u.i)) != 0))
			{
				pRec.flags |= (ushort)(0x0004);
			}
			else
			{
				pRec.u.r = (double)(rValue);
				pRec.flags |= (ushort)(0x0008);
				if ((bTryForInt) != 0)
					sqlite3VdbeIntegerAffinity(pRec);
			}

			pRec.flags &= (ushort)(~0x0002);
		}
		public static int areDoubleQuotedStringsEnabled(sqlite3 db, NameContext pTopNC)
		{
			if ((db.init.busy) != 0)
				return (int)(1);
			if ((pTopNC.ncFlags & 0x010000) != 0)
			{
				if (((sqlite3WritableSchema(db)) != 0) && ((db.flags & 0x40000000) != 0))
				{
					return (int)(1);
				}

				return (int)((db.flags & 0x20000000) != 0);
			}
			else
			{
				return (int)((db.flags & 0x40000000) != 0);
			}
		}
		public static void attachBackupObject(sqlite3_backup p)
		{
			sqlite3_backup pp;

			pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p.pSrc));
			p.pNext = pp;
			pp = p;
			p.isAttached = (int)(1);
		}
		public static void attachFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			int i = 0;
			int rc = (int)(0);
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zName;
			sbyte* zFile;
			sbyte* zPath = null;
			sbyte* zErr = null;
			uint flags = 0;
			Db aNew;
			Db pNew;
			sbyte* zErrDyn = null;
			sqlite3_vfs pVfs;
			(void)(NotUsed);
			zFile = (sbyte*)(sqlite3_value_text(argv[0]));
			zName = (sbyte*)(sqlite3_value_text(argv[1]));
			if ((zFile) == (null))
				zFile = "";
			if ((zName) == (null))
				zName = "";
			if ((db.init.reopenMemdb) != 0)
			{
				pVfs = sqlite3_vfs_find("memdb");
				if ((pVfs) == (null))
					return;
				pNew = db.aDb[db.init.iDb];
				if ((pNew.pBt) != null)
					sqlite3BtreeClose(pNew.pBt);
				pNew.pBt = null;
				pNew.pSchema = null;
				rc = (int)(sqlite3BtreeOpen(pVfs, "x\000", db, pNew.pBt, (int)(0), (int)(0x00000100)));
			}
			else
			{
				if ((db.nDb) >= (db.aLimit[7] + 2))
				{
					zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", (int)(db.aLimit[7]));
					goto attach_error;
				}

				for (i = (int)(0); (i) < (db.nDb); i++)
				{

					if ((sqlite3DbIsNamed(db, (int)(i), zName)) != 0)
					{
						zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
						goto attach_error;
					}
				}

				if ((db.aDb) == (db.aDbStatic))
				{
					aNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Db) * 3));
					if ((aNew) == (null))
						return;
					CRuntime.memcpy(aNew, db.aDb, (ulong)(sizeof(Db) * 2));
				}
				else
				{
					aNew = sqlite3DbRealloc(db, db.aDb, (ulong)(sizeof(Db) * (db.nDb + 1)));
					if ((aNew) == (null))
						return;
				}

				db.aDb = aNew;
				pNew = db.aDb[db.nDb];
				CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(Db)));
				flags = (uint)(db.openFlags);
				rc = (int)(sqlite3ParseUri(db.pVfs.zName, zFile, &flags, pVfs, &zPath, &zErr));
				if (rc != 0)
				{
					if ((rc) == (7))
						sqlite3OomFault(db);
					sqlite3_result_error(context, zErr, (int)(-1));
					sqlite3_free(zErr);
					return;
				}


				flags |= (uint)(0x00000100);
				rc = (int)(sqlite3BtreeOpen(pVfs, zPath, db, pNew.pBt, (int)(0), (int)(flags)));
				db.nDb++;
				pNew.zDbSName = sqlite3DbStrDup(db, zName);
			}

			db.noSharedCache = (byte)(0);
			if ((rc) == (19))
			{
				rc = (int)(1);
				zErrDyn = sqlite3MPrintf(db, "database is already attached");
			}
			else if ((rc) == (0))
			{
				Pager pPager;
				pNew.pSchema = sqlite3SchemaGet(db, pNew.pBt);
				if (pNew.pSchema == null)
				{
					rc = (int)(7);
				}
				else if (((pNew.pSchema.file_format) != 0) && (pNew.pSchema.enc != ((db).enc)))
				{
					zErrDyn = sqlite3MPrintf(db, "attached databases must use the same text encoding as main database");
					rc = (int)(1);
				}

				sqlite3BtreeEnter(pNew.pBt);
				pPager = sqlite3BtreePager(pNew.pBt);
				sqlite3PagerLockingMode(pPager, (int)(db.dfltLockMode));
				sqlite3BtreeSecureDelete(pNew.pBt, (int)(sqlite3BtreeSecureDelete(db.aDb[0].pBt, (int)(-1))));
				sqlite3BtreeSetPagerFlags(pNew.pBt, (uint)(0x03 | (db.flags & 0x38)));
				sqlite3BtreeLeave(pNew.pBt);
			}

			pNew.safety_level = (byte)(2 + 1);
			if (((rc) == (0)) && ((pNew.zDbSName) == (null)))
			{
				rc = (int)(7);
			}

			sqlite3_free_filename(zPath);
			if ((rc) == (0))
			{
				sqlite3BtreeEnterAll(db);
				db.init.iDb = (byte)(0);
				db.mDbFlags &= (uint)(~(0x0010));
				if ((db.init.reopenMemdb) == 0)
				{
					rc = (int)(sqlite3Init(db, &zErrDyn));
				}

				sqlite3BtreeLeaveAll(db);

			}

			if ((rc) != 0)
			{
				if ((db.init.reopenMemdb) == 0)
				{
					int iDb = (int)(db.nDb - 1);

					if ((db.aDb[iDb].pBt) != null)
					{
						sqlite3BtreeClose(db.aDb[iDb].pBt);
						db.aDb[iDb].pBt = null;
						db.aDb[iDb].pSchema = null;
					}

					sqlite3ResetAllSchemasOfConnection(db);
					db.nDb = (int)(iDb);
					if (((rc) == (7)) || ((rc) == (10 | (12 << 8))))
					{
						sqlite3OomFault(db);
						sqlite3DbFree(db, zErrDyn);
						zErrDyn = sqlite3MPrintf(db, "out of memory");
					}
					else if ((zErrDyn) == (null))
					{
						zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
					}
				}

				goto attach_error;
			}

			return;
		attach_error:
			; if ((zErrDyn) != null) { sqlite3_result_error(context, zErrDyn, (int)(-1)); sqlite3DbFree(db, zErrDyn); }
			if ((rc) != 0)
				sqlite3_result_error_code(context, (int)(rc));
		}
		public static Select attachWithToSelect(Parse pParse, Select pSelect, With pWith)
		{
			if ((pSelect) != null)
			{
				pSelect.pWith = pWith;
				parserDoubleLinkSelect(pParse, pSelect);
			}
			else
			{
				sqlite3WithDelete(pParse.db, pWith);
			}

			return pSelect;
		}
		public static int autoIncBegin(Parse pParse, int iDb, Table pTab)
		{
			int memId = (int)(0);

			if (((pTab.tabFlags & 0x00000008) != 0) && ((pParse.db.mDbFlags & 0x0004) == (0)))
			{
				Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
				AutoincInfo pInfo;
				Table pSeqTab = pParse.db.aDb[iDb].pSchema.pSeqTab;
				if (((((pSeqTab) == (null)) || (!(((pSeqTab).tabFlags & 0x00000080) == (0)))) || ((((pSeqTab).eTabType) == (1)) != 0)) || (pSeqTab.nCol != 2))
				{
					pParse.nErr++;
					pParse.rc = (int)(11 | (2 << 8));
					return (int)(0);
				}

				pInfo = pToplevel.pAinc;
				while (((pInfo) != null) && (pInfo.pTab != pTab))
				{
					pInfo = pInfo.pNext;
				}

				if ((pInfo) == (null))
				{
					pInfo = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(AutoincInfo)));
					sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);
					if ((pParse.db.mallocFailed) != 0)
						return (int)(0);
					pInfo.pNext = pToplevel.pAinc;
					pToplevel.pAinc = pInfo;
					pInfo.pTab = pTab;
					pInfo.iDb = (int)(iDb);
					pToplevel.nMem++;
					pInfo.regCtr = (int)(++pToplevel.nMem);
					pToplevel.nMem += (int)(2);
				}

				memId = (int)(pInfo.regCtr);
			}

			return (int)(memId);
		}
		public static void autoIncrementEnd(Parse pParse)
		{
			AutoincInfo p;
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;

			for (p = pParse.pAinc; p; p = p.pNext)
			{
				VdbeOp* aOp;
				Db pDb = db.aDb[p.iDb];
				int iRec = 0;
				int memId = (int)(p.regCtr);
				iRec = (int)(sqlite3GetTempReg(pParse));

				sqlite3VdbeAddOp3(v, (int)(55), (int)(memId + 2), (int)(sqlite3VdbeCurrentAddr(v) + 7), (int)(memId));
				sqlite3OpenTable(pParse, (int)(0), (int)(p.iDb), pDb.pSchema.pSeqTab, (int)(112));
				aOp = sqlite3VdbeAddOpList(v, ((int)(5 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), autoIncrementEnd_autoIncEnd, (int)(autoIncrementEnd_iLn));
				if ((aOp) == (null))
					break;
				aOp[0].p1 = (int)(memId + 1);
				aOp[1].p2 = (int)(memId + 1);
				aOp[2].p1 = (int)(memId - 1);
				aOp[2].p3 = (int)(iRec);
				aOp[3].p2 = (int)(iRec);
				aOp[3].p3 = (int)(memId + 1);
				aOp[3].p5 = (ushort)(0x08);
				sqlite3ReleaseTempReg(pParse, (int)(iRec));
			}
		}
		public static void autoIncStep(Parse pParse, int memId, int regRowid)
		{
			if ((memId) > (0))
			{
				sqlite3VdbeAddOp2(pParse.pVdbe, (int)(158), (int)(memId), (int)(regRowid));
			}
		}
		public static int autoVacuumCommit(Btree p)
		{
			int rc = (int)(0);
			Pager pPager;
			BtShared pBt;
			sqlite3 db;

			pBt = p.pBt;
			pPager = pBt.pPager;

			invalidateAllOverflowCache(pBt);

			if (pBt.incrVacuum == 0)
			{
				uint nFin = 0;
				uint nFree = 0;
				uint nVac = 0;
				uint iFree = 0;
				uint nOrig = 0;
				nOrig = (uint)(btreePagecount(pBt));
				if (((ptrmapPageno((pBt), (uint)(nOrig))) == (nOrig)) || ((nOrig) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
				{
					return (int)(sqlite3CorruptError((int)(70152)));
				}

				nFree = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36]));
				db = p.db;
				if ((db.xAutovacPages) != null)
				{
					int iDb = 0;
					for (iDb = (int)(0); ((iDb) < (db.nDb)); iDb++)
					{
						if ((db.aDb[iDb].pBt) == (p))
							break;
					}

					nVac = (uint)(db.xAutovacPages(db.pAutovacPagesArg, db.aDb[iDb].zDbSName, (uint)(nOrig), (uint)(nFree), (uint)(pBt.pageSize)));
					if ((nVac) > (nFree))
					{
						nVac = (uint)(nFree);
					}

					if ((nVac) == (0))
					{
						return (int)(0);
					}
				}
				else
				{
					nVac = (uint)(nFree);
				}

				nFin = (uint)(finalDbSize(pBt, (uint)(nOrig), (uint)(nVac)));
				if ((nFin) > (nOrig))
					return (int)(sqlite3CorruptError((int)(70179)));
				if ((nFin) < (nOrig))
				{
					rc = (int)(saveAllCursors(pBt, (uint)(0), null));
				}

				for (iFree = (uint)(nOrig); ((iFree) > (nFin)) && ((rc) == (0)); iFree--)
				{
					rc = (int)(incrVacuumStep(pBt, (uint)(nFin), (uint)(iFree), ((nVac) == (nFree) ? 1 : 0)));
				}

				if ((((rc) == (101)) || ((rc) == (0))) && ((nFree) > (0)))
				{
					rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
					if ((nVac) == (nFree))
					{
						sqlite3Put4byte(&pBt.pPage1.aData[32], (uint)(0));
						sqlite3Put4byte(&pBt.pPage1.aData[36], (uint)(0));
					}

					sqlite3Put4byte(&pBt.pPage1.aData[28], (uint)(nFin));
					pBt.bDoTruncate = (byte)(1);
					pBt.nPage = (uint)(nFin);
				}

				if (rc != 0)
				{
					sqlite3PagerRollback(pPager);
				}
			}


			return (int)(rc);
		}
		public static void avgFinalize(sqlite3_context context)
		{
			SumCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			if (((p) != null) && ((p->cnt) > (0)))
			{
				sqlite3_result_double(context, (double)(p->rSum / (double)(p->cnt)));
			}
		}
		public static int backupOnePage(sqlite3_backup p, uint iSrcPg, byte* zSrcData, int bUpdate)
		{
			Pager pDestPager = sqlite3BtreePager(p.pDest);
			int nSrcPgsz = (int)(sqlite3BtreeGetPageSize(p.pSrc));
			int nDestPgsz = (int)(sqlite3BtreeGetPageSize(p.pDest));
			int nCopy = (int)((nSrcPgsz) < (nDestPgsz) ? (nSrcPgsz) : (nDestPgsz));
			long iEnd = (long)((long)(iSrcPg) * (long)(nSrcPgsz));
			int rc = (int)(0);
			long iOff = 0;





			if ((nSrcPgsz != nDestPgsz) && ((sqlite3PagerIsMemdb(pDestPager)) != 0))
			{
				rc = (int)(8);
			}

			for (iOff = (long)(iEnd - (long)(nSrcPgsz)); ((rc) == (0)) && ((iOff) < (iEnd)); iOff += (long)(nDestPgsz))
			{
				PgHdr pDestPg = null;
				uint iDest = (uint)((uint)(iOff / nDestPgsz) + 1);
				if ((iDest) == ((sqlite3PendingByte / ((p.pDest.pBt).pageSize)) + 1))
					continue;
				if (((0) == (rc = (int)(sqlite3PagerGet(pDestPager, (uint)(iDest), pDestPg, (int)(0))))) && ((0) == (rc = (int)(sqlite3PagerWrite(pDestPg)))))
				{
					byte* zIn = &zSrcData[iOff % nSrcPgsz];
					byte* zDestData = sqlite3PagerGetData(pDestPg);
					byte* zOut = &zDestData[iOff % nDestPgsz];
					CRuntime.memcpy(zOut, zIn, (ulong)(nCopy));
					((byte*)(sqlite3PagerGetExtra(pDestPg)))[0] = (byte)(0);
					if (((iOff) == (0)) && ((bUpdate) == (0)))
					{
						sqlite3Put4byte(&zOut[28], (uint)(sqlite3BtreeLastPage(p.pSrc)));
					}
				}

				sqlite3PagerUnref(pDestPg);
			}

			return (int)(rc);
		}
		public static int backupTruncateFile(sqlite3_file pFile, long iSize)
		{
			long iCurrent = 0;
			int rc = (int)(sqlite3OsFileSize(pFile, &iCurrent));
			if (((rc) == (0)) && ((iCurrent) > (iSize)))
			{
				rc = (int)(sqlite3OsTruncate(pFile, (long)(iSize)));
			}

			return (int)(rc);
		}
		public static void backupUpdate(sqlite3_backup p, uint iPage, byte* aData)
		{

			do
			{

				if ((isFatalError((int)(p.rc)) == 0) && ((iPage) < (p.iNext)))
				{
					int rc = 0;

					sqlite3_mutex_enter(p.pDestDb.mutex);
					rc = (int)(backupOnePage(p, (uint)(iPage), aData, (int)(1)));
					sqlite3_mutex_leave(p.pDestDb.mutex);

					if (rc != 0)
					{
						p.rc = (int)(rc);
					}
				}
			}
			while ((p = p.pNext) != null);
		}
		public static int balance(BtCursor pCur)
		{
			int rc = (int)(0);
			int nMin = (int)(pCur.pBt.usableSize * 2 / 3);
			byte* aBalanceQuickSpace = stackalloc byte[13];
			byte* pFree = null;
			do
			{
				int iPage = 0;
				MemPage pPage = pCur.pPage;
				if (((pPage.nFree) < (0)) && ((btreeComputeFreeSpace(pPage)) != 0))
					break;
				if (((pPage.nOverflow) == (0)) && ((pPage.nFree) <= (nMin)))
				{
					break;
				}
				else if ((iPage = (int)(pCur.iPage)) == (0))
				{
					if (((pPage.nOverflow) != 0) && ((rc = (int)(anotherValidCursor(pCur))) == (0)))
					{

						rc = (int)(balance_deeper(pPage, pCur.apPage[1]));
						if ((rc) == (0))
						{
							pCur.iPage = (sbyte)(1);
							pCur.ix = (ushort)(0);
							pCur.aiIdx[0] = (ushort)(0);
							pCur.apPage[0] = pPage;
							pCur.pPage = pCur.apPage[1];

						}
					}
					else
					{
						break;
					}
				}
				else
				{
					MemPage pParent = pCur.apPage[iPage - 1];
					int iIdx = (int)(pCur.aiIdx[iPage - 1]);
					rc = (int)(sqlite3PagerWrite(pParent.pDbPage));
					if (((rc) == (0)) && ((pParent.nFree) < (0)))
					{
						rc = (int)(btreeComputeFreeSpace(pParent));
					}

					if ((rc) == (0))
					{
						if ((((((pPage.intKeyLeaf) != 0) && ((pPage.nOverflow) == (1))) && ((pPage.aiOvfl[0]) == (pPage.nCell))) && (pParent.pgno != 1)) && ((pParent.nCell) == (iIdx)))
						{

							rc = (int)(balance_quick(pParent, pPage, aBalanceQuickSpace));
						}
						else
						{
							byte* pSpace = sqlite3PageMalloc((int)(pCur.pBt.pageSize));
							rc = (int)(balance_nonroot(pParent, (int)(iIdx), pSpace, ((iPage) == (1) ? 1 : 0), (int)(pCur.hints & 0x00000001)));
							if ((pFree) != null)
							{
								sqlite3PageFree(pFree);
							}

							pFree = pSpace;
						}
					}

					pPage.nOverflow = (byte)(0);
					releasePage(pPage);
					pCur.iPage--;

					pCur.pPage = pCur.apPage[pCur.iPage];
				}
			}
			while ((rc) == (0));
			if ((pFree) != null)
			{
				sqlite3PageFree(pFree);
			}

			return (int)(rc);
		}
		public static int balance_deeper(MemPage pRoot, MemPage ppChild)
		{
			int rc = 0;
			MemPage pChild = null;
			uint pgnoChild = (uint)(0);
			BtShared pBt = pRoot.pBt;


			rc = (int)(sqlite3PagerWrite(pRoot.pDbPage));
			if ((rc) == (0))
			{
				rc = (int)(allocateBtreePage(pBt, pChild, &pgnoChild, (uint)(pRoot.pgno), (byte)(0)));
				copyNodeContent(pRoot, pChild, &rc);
				if ((pBt.autoVacuum) != 0)
				{
					ptrmapPut(pBt, (uint)(pgnoChild), (byte)(5), (uint)(pRoot.pgno), &rc);
				}
			}

			if ((rc) != 0)
			{
				ppChild = null;
				releasePage(pChild);
				return (int)(rc);
			}




			CRuntime.memcpy(pChild.aiOvfl, pRoot.aiOvfl, (ulong)(pRoot.nOverflow * sizeof(ushort)));
			CRuntime.memcpy(pChild.apOvfl, pRoot.apOvfl, (ulong)(pRoot.nOverflow * sizeof(byte*)));
			pChild.nOverflow = (byte)(pRoot.nOverflow);
			zeroPage(pRoot, (int)(pChild.aData[0] & ~0x08));
			sqlite3Put4byte(&pRoot.aData[pRoot.hdrOffset + 8], (uint)(pgnoChild));
			ppChild = pChild;
			return (int)(0);
		}
		public static int balance_nonroot(MemPage pParent, int iParentIdx, byte* aOvflSpace, int isRoot, int bBulk)
		{
			BtShared pBt;
			int nMaxCells = (int)(0);
			int nNew = (int)(0);
			int nOld = 0;
			int i = 0; int j = 0; int k = 0;
			int nxDiv = 0;
			int rc = (int)(0);
			ushort leafCorrection = 0;
			int leafData = 0;
			int usableSpace = 0;
			int pageFlags = 0;
			int iSpace1 = (int)(0);
			int iOvflSpace = (int)(0);
			int szScratch = 0;
			var apOld = new MemPage[3]; apOld[0] = new MemPage(); apOld[1] = new MemPage(); apOld[2] = new MemPage();
			var apNew = new MemPage[5]; apNew[0] = new MemPage(); apNew[1] = new MemPage(); apNew[2] = new MemPage(); apNew[3] = new MemPage(); apNew[4] = new MemPage();
			byte* pRight;
			byte** apDiv = stackalloc byte[2];
			int* cntNew = stackalloc int[5];
			int* cntOld = stackalloc int[5];
			int* szNew = stackalloc int[5];
			byte* aSpace1;
			uint pgno = 0;
			byte* abDone = stackalloc byte[5];
			uint* aPgno = stackalloc uint[5];
			uint* aPgOrder = stackalloc uint[5];
			ushort* aPgFlags = stackalloc ushort[5];
			CellArray b = new CellArray();
			CRuntime.memset(abDone, (int)(0), (ulong)(5 * sizeof(byte)));
			CRuntime.memset(b, (int)(0), (ulong)(sizeof(CellArray)));
			pBt = pParent.pBt;




			if (aOvflSpace == null)
			{
				return (int)(7);
			}


			i = (int)(pParent.nOverflow + pParent.nCell);
			if ((i) < (2))
			{
				nxDiv = (int)(0);
			}
			else
			{

				if ((iParentIdx) == (0))
				{
					nxDiv = (int)(0);
				}
				else if ((iParentIdx) == (i))
				{
					nxDiv = (int)(i - 2 + bBulk);
				}
				else
				{
					nxDiv = (int)(iParentIdx - 1);
				}

				i = (int)(2 - bBulk);
			}

			nOld = (int)(i + 1);
			if ((i + nxDiv - pParent.nOverflow) == (pParent.nCell))
			{
				pRight = &pParent.aData[pParent.hdrOffset + 8];
			}
			else
			{
				pRight = ((pParent).aData + ((pParent).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pParent).aCellIdx[2 * (i + nxDiv - pParent.nOverflow)])))));
			}

			pgno = (uint)(sqlite3Get4byte(pRight));
			while ((1) != 0)
			{
				if ((rc) == (0))
				{
					rc = (int)(getAndInitPage(pBt, (uint)(pgno), apOld[i], null, (int)(0)));
				}

				if ((rc) != 0)
				{
					CRuntime.memset(apOld, (int)(0), (ulong)((i + 1) * sizeof(MemPage)));
					goto balance_cleanup;
				}

				if ((apOld[i].nFree) < (0))
				{
					rc = (int)(btreeComputeFreeSpace(apOld[i]));
					if ((rc) != 0)
					{
						CRuntime.memset(apOld, (int)(0), (ulong)((i) * sizeof(MemPage)));
						goto balance_cleanup;
					}
				}

				nMaxCells += (int)(apOld[i].nCell + ((int)(4 * sizeof(byte) / sizeof(byte*))));
				if ((i--) == (0))
					break;
				if (((pParent.nOverflow) != 0) && ((i + nxDiv) == (pParent.aiOvfl[0])))
				{
					apDiv[i] = pParent.apOvfl[0];
					pgno = (uint)(sqlite3Get4byte(apDiv[i]));
					szNew[i] = (int)(pParent.xCellSize(pParent, apDiv[i]));
					pParent.nOverflow = (byte)(0);
				}
				else
				{
					apDiv[i] = ((pParent).aData + ((pParent).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pParent).aCellIdx[2 * (i + nxDiv - pParent.nOverflow)])))));
					pgno = (uint)(sqlite3Get4byte(apDiv[i]));
					szNew[i] = (int)(pParent.xCellSize(pParent, apDiv[i]));
					if ((pBt.btsFlags & 0x000c) != 0)
					{
						int iOff = 0;
						iOff = (int)(((int)((long)(apDiv[i]))) - ((int)((long)(pParent.aData))));
						if ((iOff + szNew[i]) <= ((int)(pBt.usableSize)))
						{
							CRuntime.memcpy(&aOvflSpace[iOff], apDiv[i], (ulong)(szNew[i]));
							apDiv[i] = &aOvflSpace[apDiv[i] - pParent.aData];
						}
					}

					dropCell(pParent, (int)(i + nxDiv - pParent.nOverflow), (int)(szNew[i]), &rc);
				}
			}

			nMaxCells = (int)((nMaxCells + 3) & ~3);
			szScratch = (int)(nMaxCells * sizeof(byte) + nMaxCells * sizeof(ushort) + pBt.pageSize);

			b.apCell = sqlite3DbMallocRaw(null, (ulong)(szScratch));
			if ((b.apCell) == (null))
			{
				rc = (int)(7);
				goto balance_cleanup;
			}

			b.szCell = (ushort*)(&b.apCell[nMaxCells]);
			aSpace1 = (byte*)(&b.szCell[nMaxCells]);

			b.pRef = apOld[0];
			leafCorrection = (ushort)(b.pRef.leaf * 4);
			leafData = (int)(b.pRef.intKeyLeaf);
			for (i = (int)(0); (i) < (nOld); i++)
			{
				MemPage pOld = apOld[i];
				int limit = (int)(pOld.nCell);
				byte* aData = pOld.aData;
				ushort maskPage = (ushort)(pOld.maskPage);
				byte* piCell = aData + pOld.cellOffset;
				byte* piEnd;
				if (pOld.aData[0] != apOld[0].aData[0])
				{
					rc = (int)(sqlite3CorruptError((int)(74057)));
					goto balance_cleanup;
				}

				CRuntime.memset(&b.szCell[b.nCell], (int)(0), (ulong)(sizeof(ushort) * (limit + pOld.nOverflow)));
				if ((pOld.nOverflow) > (0))
				{
					if (((limit) < (pOld.aiOvfl[0])))
					{
						rc = (int)(sqlite3CorruptError((int)(74081)));
						goto balance_cleanup;
					}

					limit = (int)(pOld.aiOvfl[0]);
					for (j = (int)(0); (j) < (limit); j++)
					{
						b.apCell[b.nCell] = aData + (maskPage & _byteswap_ushort((ushort)(*(ushort*)(piCell))));
						piCell += 2;
						b.nCell++;
					}

					for (k = (int)(0); (k) < (pOld.nOverflow); k++)
					{

						b.apCell[b.nCell] = pOld.apOvfl[k];
						b.nCell++;
					}
				}

				piEnd = aData + pOld.cellOffset + 2 * pOld.nCell;
				while ((piCell) < (piEnd))
				{

					b.apCell[b.nCell] = aData + (maskPage & _byteswap_ushort((ushort)(*(ushort*)(piCell))));
					piCell += 2;
					b.nCell++;
				}


				cntOld[i] = (int)(b.nCell);
				if (((i) < (nOld - 1)) && (leafData == 0))
				{
					ushort sz = (ushort)(szNew[i]);
					byte* pTemp;

					b.szCell[b.nCell] = (ushort)(sz);
					pTemp = &aSpace1[iSpace1];
					iSpace1 += (int)(sz);


					CRuntime.memcpy(pTemp, apDiv[i], (ulong)(sz));
					b.apCell[b.nCell] = pTemp + leafCorrection;

					b.szCell[b.nCell] = (ushort)(b.szCell[b.nCell] - leafCorrection);
					if (pOld.leaf == 0)
					{


						CRuntime.memcpy(b.apCell[b.nCell], &pOld.aData[8], (ulong)(4));
					}
					else
					{

						while ((b.szCell[b.nCell]) < (4))
						{


							aSpace1[iSpace1++] = (byte)(0x00);
							b.szCell[b.nCell]++;
						}
					}

					b.nCell++;
				}
			}

			usableSpace = (int)(pBt.usableSize - 12 + leafCorrection);
			for (i = (int)(k = (int)(0)); (i) < (nOld); i++, k++)
			{
				MemPage p = apOld[i];
				b.apEnd[k] = p.aDataEnd;
				b.ixNx[k] = (int)(cntOld[i]);
				if (((k) != 0) && ((b.ixNx[k]) == (b.ixNx[k - 1])))
				{
					k--;
				}

				if (leafData == 0)
				{
					k++;
					b.apEnd[k] = pParent.aDataEnd;
					b.ixNx[k] = (int)(cntOld[i] + 1);
				}


				szNew[i] = (int)(usableSpace - p.nFree);
				for (j = (int)(0); (j) < (p.nOverflow); j++)
				{
					szNew[i] += (int)(2 + p.xCellSize(p, p.apOvfl[j]));
				}

				cntNew[i] = (int)(cntOld[i]);
			}

			k = (int)(nOld);
			for (i = (int)(0); (i) < (k); i++)
			{
				int sz = 0;
				while ((szNew[i]) > (usableSpace))
				{
					if ((i + 1) >= (k))
					{
						k = (int)(i + 2);
						if ((k) > (3 + 2))
						{
							rc = (int)(sqlite3CorruptError((int)(74182)));
							goto balance_cleanup;
						}

						szNew[k - 1] = (int)(0);
						cntNew[k - 1] = (int)(b.nCell);
					}

					sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i] - 1)));
					szNew[i] -= (int)(sz);
					if (leafData == 0)
					{
						if ((cntNew[i]) < (b.nCell))
						{
							sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
						}
						else
						{
							sz = (int)(0);
						}
					}

					szNew[i + 1] += (int)(sz);
					cntNew[i]--;
				}

				while ((cntNew[i]) < (b.nCell))
				{
					sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
					if ((szNew[i] + sz) > (usableSpace))
						break;
					szNew[i] += (int)(sz);
					cntNew[i]++;
					if (leafData == 0)
					{
						if ((cntNew[i]) < (b.nCell))
						{
							sz = (int)(2 + cachedCellSize(b, (int)(cntNew[i])));
						}
						else
						{
							sz = (int)(0);
						}
					}

					szNew[i + 1] -= (int)(sz);
				}

				if ((cntNew[i]) >= (b.nCell))
				{
					k = (int)(i + 1);
				}
				else if ((cntNew[i]) <= ((i) > (0) ? cntNew[i - 1] : 0))
				{
					rc = (int)(sqlite3CorruptError((int)(74215)));
					goto balance_cleanup;
				}
			}

			for (i = (int)(k - 1); (i) > (0); i--)
			{
				int szRight = (int)(szNew[i]);
				int szLeft = (int)(szNew[i - 1]);
				int r = 0;
				int d = 0;
				r = (int)(cntNew[i - 1] - 1);
				d = (int)(r + 1 - leafData);
				(void)(cachedCellSize(b, (int)(d)));
				do
				{


					(void)(cachedCellSize(b, (int)(r)));
					if ((szRight != 0) && (((bBulk) != 0) || ((szRight + b.szCell[d] + 2) > (szLeft - (b.szCell[r] + ((i) == (k - 1) ? 0 : 2))))))
					{
						break;
					}

					szRight += (int)(b.szCell[d] + 2);
					szLeft -= (int)(b.szCell[r] + 2);
					cntNew[i - 1] = (int)(r);
					r--;
					d--;
				}
				while ((r) >= (0));
				szNew[i] = (int)(szRight);
				szNew[i - 1] = (int)(szLeft);
				if ((cntNew[i - 1]) <= ((i) > (1) ? cntNew[i - 2] : 0))
				{
					rc = (int)(sqlite3CorruptError((int)(74257)));
					goto balance_cleanup;
				}
			}


			pageFlags = (int)(apOld[0].aData[0]);
			for (i = (int)(0); (i) < (k); i++)
			{
				MemPage pNew;
				if ((i) < (nOld))
				{
					pNew = apNew[i] = apOld[i];
					apOld[i] = null;
					rc = (int)(sqlite3PagerWrite(pNew.pDbPage));
					nNew++;
					if ((sqlite3PagerPageRefcount(pNew.pDbPage) != 1 + ((i) == (iParentIdx - nxDiv))) && ((rc) == (0)))
					{
						rc = (int)(sqlite3CorruptError((int)(74290)));
					}

					if ((rc) != 0)
						goto balance_cleanup;
				}
				else
				{

					rc = (int)(allocateBtreePage(pBt, pNew, &pgno, (uint)((bBulk) != 0 ? 1 : pgno), (byte)(0)));
					if ((rc) != 0)
						goto balance_cleanup;
					zeroPage(pNew, (int)(pageFlags));
					apNew[i] = pNew;
					nNew++;
					cntOld[i] = (int)(b.nCell);
					if ((pBt.autoVacuum) != 0)
					{
						ptrmapPut(pBt, (uint)(pNew.pgno), (byte)(5), (uint)(pParent.pgno), &rc);
						if (rc != 0)
						{
							goto balance_cleanup;
						}
					}
				}
			}

			for (i = (int)(0); (i) < (nNew); i++)
			{
				aPgOrder[i] = (uint)(aPgno[i] = (uint)(apNew[i].pgno));
				aPgFlags[i] = (ushort)(apNew[i].pDbPage.flags);
				for (j = (int)(0); (j) < (i); j++)
				{
					if (((aPgno[j]) == (aPgno[i])))
					{

						rc = (int)(sqlite3CorruptError((int)(74336)));
						goto balance_cleanup;
					}
				}
			}

			for (i = (int)(0); (i) < (nNew); i++)
			{
				int iBest = (int)(0);
				for (j = (int)(1); (j) < (nNew); j++)
				{
					if ((aPgOrder[j]) < (aPgOrder[iBest]))
						iBest = (int)(j);
				}

				pgno = (uint)(aPgOrder[iBest]);
				aPgOrder[iBest] = (uint)(0xffffffff);
				if (iBest != i)
				{
					if ((iBest) > (i))
					{
						sqlite3PagerRekey(apNew[iBest].pDbPage, (uint)(pBt.nPage + iBest + 1), (ushort)(0));
					}

					sqlite3PagerRekey(apNew[i].pDbPage, (uint)(pgno), (ushort)(aPgFlags[iBest]));
					apNew[i].pgno = (uint)(pgno);
				}
			}




			sqlite3Put4byte(pRight, (uint)(apNew[nNew - 1].pgno));
			if (((pageFlags & 0x08) == (0)) && (nOld != nNew))
			{
				MemPage pOld = ((nNew) > (nOld) ? apNew : apOld)[nOld - 1];
				CRuntime.memcpy(&apNew[nNew - 1].aData[8], &pOld.aData[8], (ulong)(4));
			}

			if ((pBt.autoVacuum) != 0)
			{
				MemPage pOld;
				MemPage pNew = pOld = apNew[0];
				int cntOldNext = (int)(pNew.nCell + pNew.nOverflow);
				int iNew = (int)(0);
				int iOld = (int)(0);
				for (i = (int)(0); (i) < (b.nCell); i++)
				{
					byte* pCell = b.apCell[i];
					while ((i) == (cntOldNext))
					{
						iOld++;


						pOld = (iOld) < (nNew) ? apNew[iOld] : apOld[iOld];
						cntOldNext += (int)(pOld.nCell + pOld.nOverflow + !leafData);
					}

					if ((i) == (cntNew[iNew]))
					{
						pNew = apNew[++iNew];
						if (leafData == 0)
							continue;
					}

					if ((((iOld) >= (nNew)) || (pNew.pgno != aPgno[iOld])) || (!((((ulong)(pCell)) >= ((ulong)(pOld.aData))) && (((ulong)(pCell)) < ((ulong)(pOld.aDataEnd))))))
					{
						if (leafCorrection == 0)
						{
							ptrmapPut(pBt, (uint)(sqlite3Get4byte(pCell)), (byte)(5), (uint)(pNew.pgno), &rc);
						}

						if ((cachedCellSize(b, (int)(i))) > (pNew.minLocal))
						{
							ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);
						}

						if ((rc) != 0)
							goto balance_cleanup;
					}
				}
			}

			for (i = (int)(0); (i) < (nNew - 1); i++)
			{
				byte* pCell;
				byte* pTemp;
				int sz = 0;
				byte* pSrcEnd;
				MemPage pNew = apNew[i];
				j = (int)(cntNew[i]);


				pCell = b.apCell[j];
				sz = (int)(b.szCell[j] + leafCorrection);
				pTemp = &aOvflSpace[iOvflSpace];
				if (pNew.leaf == 0)
				{
					CRuntime.memcpy(&pNew.aData[8], pCell, (ulong)(4));
				}
				else if ((leafData) != 0)
				{
					CellInfo info = new CellInfo();
					j--;
					pNew.xParseCell(pNew, b.apCell[j], &info);
					pCell = pTemp;
					sz = (int)(4 + sqlite3PutVarint(&pCell[4], (ulong)(info.nKey)));
					pTemp = null;
				}
				else
				{
					pCell -= 4;
					if ((b.szCell[j]) == (4))
					{

						sz = (int)(pParent.xCellSize(pParent, pCell));
					}
				}

				iOvflSpace += (int)(sz);


				for (k = (int)(0); ((b.ixNx[k]) <= (i)) && ((k) < (3 * 2)); k++)
				{
				}

				pSrcEnd = b.apEnd[k];
				if (((((ulong)(pSrcEnd)) >= ((ulong)(pCell))) && (((ulong)(pSrcEnd)) < ((ulong)(pCell + sz)))))
				{
					rc = (int)(sqlite3CorruptError((int)(74493)));
					goto balance_cleanup;
				}

				insertCell(pParent, (int)(nxDiv + i), pCell, (int)(sz), pTemp, (uint)(pNew.pgno), &rc);
				if (rc != 0)
					goto balance_cleanup;

			}

			for (i = (int)(1 - nNew); (i) < (nNew); i++)
			{
				int iPg = (int)((i) < (0) ? -i : i);

				if ((abDone[iPg]) != 0)
					continue;
				if (((i) >= (0)) || ((cntOld[iPg - 1]) >= (cntNew[iPg - 1])))
				{
					int iNew = 0;
					int iOld = 0;
					int nNewCell = 0;


					if ((iPg) == (0))
					{
						iNew = (int)(iOld = (int)(0));
						nNewCell = (int)(cntNew[0]);
					}
					else
					{
						iOld = (int)((iPg) < (nOld) ? (cntOld[iPg - 1] + !leafData) : b.nCell);
						iNew = (int)(cntNew[iPg - 1] + !leafData);
						nNewCell = (int)(cntNew[iPg] - iNew);
					}

					rc = (int)(editPage(apNew[iPg], (int)(iOld), (int)(iNew), (int)(nNewCell), b));
					if ((rc) != 0)
						goto balance_cleanup;
					abDone[iPg]++;
					apNew[iPg].nFree = (int)(usableSpace - szNew[iPg]);


				}
			}




			if ((((isRoot) != 0) && ((pParent.nCell) == (0))) && ((pParent.hdrOffset) <= (apNew[0].nFree)))
			{

				rc = (int)(defragmentPage(apNew[0], (int)(-1)));

				copyNodeContent(apNew[0], pParent, &rc);
				freePage(apNew[0], &rc);
			}
			else if (((pBt.autoVacuum) != 0) && (leafCorrection == 0))
			{
				for (i = (int)(0); (i) < (nNew); i++)
				{
					uint key = (uint)(sqlite3Get4byte(&apNew[i].aData[8]));
					ptrmapPut(pBt, (uint)(key), (byte)(5), (uint)(apNew[i].pgno), &rc);
				}
			}


			for (i = (int)(nNew); (i) < (nOld); i++)
			{
				freePage(apOld[i], &rc);
			}

		balance_cleanup:
			; sqlite3DbFree(null, b.apCell);
			for (i = (int)(0); (i) < (nOld); i++)
			{
				releasePage(apOld[i]);
			}

			for (i = (int)(0); (i) < (nNew); i++)
			{
				releasePage(apNew[i]);
			}

			return (int)(rc);
		}
		public static int balance_quick(MemPage pParent, MemPage pPage, byte* pSpace)
		{
			BtShared pBt = pPage.pBt;
			MemPage pNew;
			int rc = 0;
			uint pgnoNew = 0;



			if ((pPage.nCell) == (0))
				return (int)(sqlite3CorruptError((int)(73634)));


			rc = (int)(allocateBtreePage(pBt, pNew, &pgnoNew, (uint)(0), (byte)(0)));
			if ((rc) == (0))
			{
				byte* pOut = &pSpace[4];
				byte* pCell = pPage.apOvfl[0];
				ushort szCell = (ushort)(pPage.xCellSize(pPage, pCell));
				byte* pStop;
				CellArray b = new CellArray();


				zeroPage(pNew, (int)(0x01 | 0x04 | 0x08));
				b.nCell = (int)(1);
				b.pRef = pPage;
				b.apCell = &pCell;
				b.szCell = &szCell;
				b.apEnd[0] = pPage.aDataEnd;
				b.ixNx[0] = (int)(2);
				rc = (int)(rebuildPage(b, (int)(0), (int)(1), pNew));
				if ((rc) != 0)
				{
					releasePage(pNew);
					return (int)(rc);
				}

				pNew.nFree = (int)(pBt.usableSize - pNew.cellOffset - 2 - szCell);
				if ((pBt.autoVacuum) != 0)
				{
					ptrmapPut(pBt, (uint)(pgnoNew), (byte)(5), (uint)(pParent.pgno), &rc);
					if ((szCell) > (pNew.minLocal))
					{
						ptrmapPutOvflPtr(pNew, pNew, pCell, &rc);
					}
				}

				pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (pPage.nCell - 1)])))));
				pStop = &pCell[9];
				while (((*(pCell++) & 0x80) != 0) && ((pCell) < (pStop)))
				{
				}

				pStop = &pCell[9];
				while ((((*(pOut++) = (byte)(*(pCell++))) & 0x80) != 0) && ((pCell) < (pStop)))
				{
				}

				if ((rc) == (0))
				{
					insertCell(pParent, (int)(pParent.nCell), pSpace, (int)(pOut - pSpace), null, (uint)(pPage.pgno), &rc);
				}

				sqlite3Put4byte(&pParent.aData[pParent.hdrOffset + 8], (uint)(pgnoNew));
				releasePage(pNew);
			}

			return (int)(rc);
		}
		public static byte binaryCompareP5(Expr pExpr1, Expr pExpr2, int jumpIfNull)
		{
			byte aff = (byte)(sqlite3ExprAffinity(pExpr2));
			aff = (byte)((byte)(sqlite3CompareAffinity(pExpr1, (sbyte)(aff))) | (byte)(jumpIfNull));
			return (byte)(aff);
		}
		public static void binaryToUnaryIfNull(Parse pParse, Expr pY, Expr pA, int op)
		{
			sqlite3 db = pParse.db;
			if (((((pA) != null) && ((pY) != null)) && ((pY.op) == (121))) && (!((pParse.eParseMode) >= (2))))
			{
				pA.op = ((byte)(op));
				sqlite3ExprDelete(db, pA.pRight);
				pA.pRight = null;
			}
		}
		public static int binCollFunc(void* NotUsed, int nKey1, void* pKey1, int nKey2, void* pKey2)
		{
			int rc = 0; int n = 0;
			(void)(NotUsed);
			n = (int)((nKey1) < (nKey2) ? nKey1 : nKey2);

			rc = (int)(memcmp(pKey1, pKey2, (ulong)(n)));
			if ((rc) == (0))
			{
				rc = (int)(nKey1 - nKey2);
			}

			return (int)(rc);
		}
		public static int bindText(sqlite3_stmt* pStmt, int i, void* zData, long nData, delegate17 xDel, byte encoding)
		{
			Vdbe p = (Vdbe)(pStmt);
			sqlite3_value pVar;
			int rc = 0;
			rc = (int)(vdbeUnbind(p, (int)(i)));
			if ((rc) == (0))
			{
				if (zData != null)
				{
					pVar = p.aVar[i - 1];
					rc = (int)(sqlite3VdbeMemSetStr(pVar, zData, (long)(nData), (byte)(encoding), xDel));
					if (((rc) == (0)) && (encoding != 0))
					{
						rc = (int)(sqlite3VdbeChangeEncoding(pVar, (int)((p.db).enc)));
					}

					if ((rc) != 0)
					{
						sqlite3Error(p.db, (int)(rc));
						rc = (int)(sqlite3ApiExit(p.db, (int)(rc)));
					}
				}

				sqlite3_mutex_leave(p.db.mutex);
			}
			else if ((xDel != null) && (xDel != ((Void(Void * ))(-1))))
			{
				xDel(zData);
			}

			return (int)(rc);
		}
		public static int blobReadWrite(sqlite3_blob* pBlob, void* z, int n, int iOffset, delegate173 xCall)
		{
			int rc = 0;
			Incrblob p = (Incrblob)(pBlob);
			Vdbe v;
			sqlite3 db;
			if ((p) == (null))
				return (int)(sqlite3MisuseError((int)(96390)));
			db = p.db;
			sqlite3_mutex_enter(db.mutex);
			v = (Vdbe)(p.pStmt);
			if ((((n) < (0)) || ((iOffset) < (0))) || (((long)(iOffset) + n) > (p.nByte)))
			{
				rc = (int)(1);
			}
			else if ((v) == (null))
			{
				rc = (int)(4);
			}
			else
			{

				sqlite3BtreeEnterCursor(p.pCsr);
				rc = (int)(xCall(p.pCsr, (uint)(iOffset + p.iOffset), (uint)(n), z));
				sqlite3BtreeLeaveCursor(p.pCsr);
				if ((rc) == (4))
				{
					sqlite3VdbeFinalize(v);
					p.pStmt = null;
				}
				else
				{
					v.rc = (int)(rc);
				}
			}

			sqlite3Error(db, (int)(rc));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int blobSeekToRow(Incrblob p, long iRow, sbyte** pzErr)
		{
			int rc = 0;
			sbyte* zErr = null;
			Vdbe v = (Vdbe)(p.pStmt);
			v.aMem[1].flags = (ushort)(0x0004);
			v.aMem[1].u.i = (long)(iRow);
			if ((v.pc) > (4))
			{
				v.pc = (int)(4);

				rc = (int)(sqlite3VdbeExec(v));
			}
			else
			{
				rc = (int)(sqlite3_step(p.pStmt));
			}

			if ((rc) == (100))
			{
				VdbeCursor pC = v.apCsr[0];
				uint type = 0;


				type = (uint)((pC.nHdrParsed) > (p.iCol) ? pC.aType[p.iCol] : 0);
				if ((type) < (12))
				{
					zErr = sqlite3MPrintf(p.db, "cannot open value of type %s", (type) == (0) ? "null" : (type) == (7) ? "real" : "integer");
					rc = (int)(1);
					sqlite3_finalize(p.pStmt);
					p.pStmt = null;
				}
				else
				{
					p.iOffset = (int)(pC.aType[p.iCol + pC.nField]);
					p.nByte = (int)(sqlite3VdbeSerialTypeLen((uint)(type)));
					p.pCsr = pC.uc.pCursor;
					sqlite3BtreeIncrblobCursor(p.pCsr);
				}
			}

			if ((rc) == (100))
			{
				rc = (int)(0);
			}
			else if ((p.pStmt) != null)
			{
				rc = (int)(sqlite3_finalize(p.pStmt));
				p.pStmt = null;
				if ((rc) == (0))
				{
					zErr = sqlite3MPrintf(p.db, "no such rowid: %lld", (long)(iRow));
					rc = (int)(1);
				}
				else
				{
					zErr = sqlite3MPrintf(p.db, "%s", sqlite3_errmsg(p.db));
				}
			}



			*pzErr = zErr;
			return (int)(rc);
		}
		public static int btreeCellSizeCheck(MemPage pPage)
		{
			int iCellFirst = 0;
			int iCellLast = 0;
			int i = 0;
			int sz = 0;
			int pc = 0;
			byte* data;
			int usableSize = 0;
			int cellOffset = 0;
			iCellFirst = (int)(pPage.cellOffset + 2 * pPage.nCell);
			usableSize = (int)(pPage.pBt.usableSize);
			iCellLast = (int)(usableSize - 4);
			data = pPage.aData;
			cellOffset = (int)(pPage.cellOffset);
			if (pPage.leaf == 0)
				iCellLast--;
			for (i = (int)(0); (i) < (pPage.nCell); i++)
			{
				pc = (int)(_byteswap_ushort((ushort)(*(ushort*)(&data[cellOffset + i * 2]))));
				if (((pc) < (iCellFirst)) || ((pc) > (iCellLast)))
				{
					return (int)(sqlite3CorruptError((int)(68167)));
				}

				sz = (int)(pPage.xCellSize(pPage, &data[pc]));
				if ((pc + sz) > (usableSize))
				{
					return (int)(sqlite3CorruptError((int)(68172)));
				}
			}

			return (int)(0);
		}
		public static void btreeClearHasContent(BtShared pBt)
		{
			sqlite3BitvecDestroy(pBt.pHasContent);
			pBt.pHasContent = null;
		}
		public static int btreeComputeFreeSpace(MemPage pPage)
		{
			int pc = 0;
			byte hdr = 0;
			byte* data;
			int usableSize = 0;
			int nFree = 0;
			int top = 0;
			int iCellFirst = 0;
			int iCellLast = 0;








			usableSize = (int)(pPage.pBt.usableSize);
			hdr = (byte)(pPage.hdrOffset);
			data = pPage.aData;
			top = (int)(((((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]) - 1) & 0xffff) + 1);
			iCellFirst = (int)(hdr + 8 + pPage.childPtrSize + 2 * pPage.nCell);
			iCellLast = (int)(usableSize - 4);
			pc = (int)((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);
			nFree = (int)(data[hdr + 7] + top);
			if ((pc) > (0))
			{
				uint next = 0;
				uint size = 0;
				if ((pc) < (top))
				{
					return (int)(sqlite3CorruptError((int)(68105)));
				}

				while ((1) != 0)
				{
					if ((pc) > (iCellLast))
					{
						return (int)(sqlite3CorruptError((int)(68110)));
					}

					next = (uint)((&data[pc])[0] << 8 | (&data[pc])[1]);
					size = (uint)((&data[pc + 2])[0] << 8 | (&data[pc + 2])[1]);
					nFree = (int)(nFree + size);
					if ((next) <= (pc + size + 3))
						break;
					pc = (int)(next);
				}

				if ((next) > (0))
				{
					return (int)(sqlite3CorruptError((int)(68120)));
				}

				if ((pc + size) > ((uint)(usableSize)))
				{
					return (int)(sqlite3CorruptError((int)(68124)));
				}
			}

			if (((nFree) > (usableSize)) || ((nFree) < (iCellFirst)))
			{
				return (int)(sqlite3CorruptError((int)(68136)));
			}

			pPage.nFree = (int)((ushort)(nFree - iCellFirst));
			return (int)(0);
		}
		public static int btreeCreateTable(Btree p, uint* piTable, int createTabFlags)
		{
			BtShared pBt = p.pBt;
			MemPage pRoot;
			uint pgnoRoot = 0;
			int rc = 0;
			int ptfFlags = 0;



			if ((pBt.autoVacuum) != 0)
			{
				uint pgnoMove = 0;
				MemPage pPageMove;
				invalidateAllOverflowCache(pBt);
				sqlite3BtreeGetMeta(p, (int)(4), &pgnoRoot);
				if ((pgnoRoot) > (btreePagecount(pBt)))
				{
					return (int)(sqlite3CorruptError((int)(75640)));
				}

				pgnoRoot++;
				while (((pgnoRoot) == (ptrmapPageno(pBt, (uint)(pgnoRoot)))) || ((pgnoRoot) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
				{
					pgnoRoot++;
				}


				rc = (int)(allocateBtreePage(pBt, pPageMove, &pgnoMove, (uint)(pgnoRoot), (byte)(1)));
				if (rc != 0)
				{
					return (int)(rc);
				}

				if (pgnoMove != pgnoRoot)
				{
					byte eType = (byte)(0);
					uint iPtrPage = (uint)(0);
					rc = (int)(saveAllCursors(pBt, (uint)(0), null));
					releasePage(pPageMove);
					if (rc != 0)
					{
						return (int)(rc);
					}

					rc = (int)(btreeGetPage(pBt, (uint)(pgnoRoot), pRoot, (int)(0)));
					if (rc != 0)
					{
						return (int)(rc);
					}

					rc = (int)(ptrmapGet(pBt, (uint)(pgnoRoot), &eType, &iPtrPage));
					if (((eType) == (1)) || ((eType) == (2)))
					{
						rc = (int)(sqlite3CorruptError((int)(75688)));
					}

					if (rc != 0)
					{
						releasePage(pRoot);
						return (int)(rc);
					}



					rc = (int)(relocatePage(pBt, pRoot, (byte)(eType), (uint)(iPtrPage), (uint)(pgnoMove), (int)(0)));
					releasePage(pRoot);
					if (rc != 0)
					{
						return (int)(rc);
					}

					rc = (int)(btreeGetPage(pBt, (uint)(pgnoRoot), pRoot, (int)(0)));
					if (rc != 0)
					{
						return (int)(rc);
					}

					rc = (int)(sqlite3PagerWrite(pRoot.pDbPage));
					if (rc != 0)
					{
						releasePage(pRoot);
						return (int)(rc);
					}
				}
				else
				{
					pRoot = pPageMove;
				}

				ptrmapPut(pBt, (uint)(pgnoRoot), (byte)(1), (uint)(0), &rc);
				if ((rc) != 0)
				{
					releasePage(pRoot);
					return (int)(rc);
				}


				rc = (int)(sqlite3BtreeUpdateMeta(p, (int)(4), (uint)(pgnoRoot)));
				if ((rc) != 0)
				{
					releasePage(pRoot);
					return (int)(rc);
				}
			}
			else
			{
				rc = (int)(allocateBtreePage(pBt, pRoot, &pgnoRoot, (uint)(1), (byte)(0)));
				if ((rc) != 0)
					return (int)(rc);
			}


			if ((createTabFlags & 1) != 0)
			{
				ptfFlags = (int)(0x01 | 0x04 | 0x08);
			}
			else
			{
				ptfFlags = (int)(0x02 | 0x08);
			}

			zeroPage(pRoot, (int)(ptfFlags));
			sqlite3PagerUnref(pRoot.pDbPage);

			*piTable = (uint)(pgnoRoot);
			return (int)(0);
		}
		public static int btreeCursor(Btree p, uint iTable, int wrFlag, KeyInfo pKeyInfo, BtCursor pCur)
		{
			BtShared pBt = p.pBt;
			BtCursor pX;








			if ((iTable) <= (1))
			{
				if ((iTable) < (1))
				{
					return (int)(sqlite3CorruptError((int)(70643)));
				}
				else if ((btreePagecount(pBt)) == (0))
				{

					iTable = (uint)(0);
				}
			}

			pCur.pgnoRoot = (uint)(iTable);
			pCur.iPage = (sbyte)(-1);
			pCur.pKeyInfo = pKeyInfo;
			pCur.pBtree = p;
			pCur.pBt = pBt;
			pCur.curFlags = (byte)(0);
			for (pX = pBt.pCursor; pX; pX = pX.pNext)
			{
				if ((pX.pgnoRoot) == (iTable))
				{
					pX.curFlags |= (byte)(0x20);
					pCur.curFlags = (byte)(0x20);
				}
			}

			pCur.eState = (byte)(1);
			pCur.pNext = pBt.pCursor;
			pBt.pCursor = pCur;
			if ((wrFlag) != 0)
			{
				pCur.curFlags |= (byte)(0x01);
				pCur.curPagerFlags = (byte)(0);
				if ((pBt.pTmpSpace) == (null))
					return (int)(allocateTempSpace(pBt));
			}
			else
			{
				pCur.curPagerFlags = (byte)(0x02);
			}

			return (int)(0);
		}
		public static int btreeCursorWithLock(Btree p, uint iTable, int wrFlag, KeyInfo pKeyInfo, BtCursor pCur)
		{
			int rc = 0;
			sqlite3BtreeEnter(p);
			rc = (int)(btreeCursor(p, (uint)(iTable), (int)(wrFlag), pKeyInfo, pCur));
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int btreeDropTable(Btree p, uint iTable, int* piMoved)
		{
			int rc = 0;
			MemPage pPage = null;
			BtShared pBt = p.pBt;



			if ((iTable) > (btreePagecount(pBt)))
			{
				return (int)(sqlite3CorruptError((int)(75889)));
			}

			rc = (int)(sqlite3BtreeClearTable(p, (int)(iTable), null));
			if ((rc) != 0)
				return (int)(rc);
			rc = (int)(btreeGetPage(pBt, (uint)(iTable), pPage, (int)(0)));
			if ((rc) != 0)
			{
				releasePage(pPage);
				return (int)(rc);
			}

			*piMoved = (int)(0);
			if ((pBt.autoVacuum) != 0)
			{
				uint maxRootPgno = 0;
				sqlite3BtreeGetMeta(p, (int)(4), &maxRootPgno);
				if ((iTable) == (maxRootPgno))
				{
					freePage(pPage, &rc);
					releasePage(pPage);
					if (rc != 0)
					{
						return (int)(rc);
					}
				}
				else
				{
					MemPage pMove;
					releasePage(pPage);
					rc = (int)(btreeGetPage(pBt, (uint)(maxRootPgno), pMove, (int)(0)));
					if (rc != 0)
					{
						return (int)(rc);
					}

					rc = (int)(relocatePage(pBt, pMove, (byte)(1), (uint)(0), (uint)(iTable), (int)(0)));
					releasePage(pMove);
					if (rc != 0)
					{
						return (int)(rc);
					}

					pMove = null;
					rc = (int)(btreeGetPage(pBt, (uint)(maxRootPgno), pMove, (int)(0)));
					freePage(pMove, &rc);
					releasePage(pMove);
					if (rc != 0)
					{
						return (int)(rc);
					}

					*piMoved = (int)(maxRootPgno);
				}

				maxRootPgno--;
				while (((maxRootPgno) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) || ((ptrmapPageno((pBt), (uint)(maxRootPgno))) == (maxRootPgno)))
				{
					maxRootPgno--;
				}


				rc = (int)(sqlite3BtreeUpdateMeta(p, (int)(4), (uint)(maxRootPgno)));
			}
			else
			{
				freePage(pPage, &rc);
				releasePage(pPage);
			}

			return (int)(rc);
		}
		public static void btreeEndTransaction(Btree p)
		{
			BtShared pBt = p.pBt;
			sqlite3 db = p.db;

			pBt.bDoTruncate = (byte)(0);
			if (((p.inTrans) > (0)) && ((db.nVdbeRead) > (1)))
			{
				downgradeAllSharedCacheTableLocks(p);
				p.inTrans = (byte)(1);
			}
			else
			{
				if (p.inTrans != 0)
				{
					clearAllSharedCacheTableLocks(p);
					pBt.nTransaction--;
					if ((0) == (pBt.nTransaction))
					{
						pBt.inTransaction = (byte)(0);
					}
				}

				p.inTrans = (byte)(0);
				unlockBtreeIfUnused(pBt);
			}



		}
		public static void btreeEnterAll(sqlite3 db)
		{
			int i = 0;
			int skipOk = (int)(1);
			Btree p;

			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				p = db.aDb[i].pBt;
				if (((p) != null) && ((p.sharable) != 0))
				{
					sqlite3BtreeEnter(p);
					skipOk = (int)(0);
				}
			}

			db.noSharedCache = (byte)(skipOk);
		}
		public static int btreeGetHasContent(BtShared pBt, uint pgno)
		{
			Bitvec* p = pBt.pHasContent;
			return (((p) != null) && (((pgno) > (sqlite3BitvecSize(p))) || ((sqlite3BitvecTestNotNull(p, (uint)(pgno))) != 0)) ? 1 : 0);
		}
		public static int btreeGetPage(BtShared pBt, uint pgno, MemPage ppPage, int flags)
		{
			int rc = 0;
			PgHdr pDbPage;


			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(pgno), pDbPage, (int)(flags)));
			if ((rc) != 0)
				return (int)(rc);
			ppPage = btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
			return (int)(0);
		}
		public static int btreeGetUnusedPage(BtShared pBt, uint pgno, MemPage ppPage, int flags)
		{
			int rc = (int)(btreeGetPage(pBt, (uint)(pgno), ppPage, (int)(flags)));
			if ((rc) == (0))
			{
				if ((sqlite3PagerPageRefcount((ppPage).pDbPage)) > (1))
				{
					releasePage(ppPage);
					ppPage = null;
					return (int)(sqlite3CorruptError((int)(68460)));
				}

				(ppPage).isInit = (byte)(0);
			}
			else
			{
				ppPage = null;
			}

			return (int)(rc);
		}
		public static void btreeHeapInsert(uint* aHeap, uint x)
		{
			uint j = 0; uint i = (uint)(++aHeap[0]);
			aHeap[i] = (uint)(x);
			while (((j = (uint)(i / 2)) > (0)) && ((aHeap[j]) > (aHeap[i])))
			{
				x = (uint)(aHeap[j]);
				aHeap[j] = (uint)(aHeap[i]);
				aHeap[i] = (uint)(x);
				i = (uint)(j);
			}
		}
		public static int btreeHeapPull(uint* aHeap, uint* pOut)
		{
			uint j = 0; uint i = 0; uint x = 0;
			if ((x = (uint)(aHeap[0])) == (0))
				return (int)(0);
			*pOut = (uint)(aHeap[1]);
			aHeap[1] = (uint)(aHeap[x]);
			aHeap[x] = (uint)(0xffffffff);
			aHeap[0]--;
			i = (uint)(1);
			while ((j = (uint)(i * 2)) <= (aHeap[0]))
			{
				if ((aHeap[j]) > (aHeap[j + 1]))
					j++;
				if ((aHeap[i]) < (aHeap[j]))
					break;
				x = (uint)(aHeap[i]);
				aHeap[i] = (uint)(aHeap[j]);
				aHeap[j] = (uint)(x);
				i = (uint)(j);
			}

			return (int)(1);
		}
		public static int btreeInitPage(MemPage pPage)
		{
			byte* data;
			BtShared pBt;







			pBt = pPage.pBt;
			data = pPage.aData + pPage.hdrOffset;
			if ((decodeFlags(pPage, (int)(data[0]))) != 0)
			{
				return (int)(sqlite3CorruptError((int)(68204)));
			}


			pPage.maskPage = ((ushort)(pBt.pageSize - 1));
			pPage.nOverflow = (byte)(0);
			pPage.cellOffset = (ushort)(pPage.hdrOffset + 8 + pPage.childPtrSize);
			pPage.aCellIdx = data + pPage.childPtrSize + 8;
			pPage.aDataEnd = pPage.aData + pBt.pageSize;
			pPage.aDataOfst = pPage.aData + pPage.childPtrSize;
			pPage.nCell = (ushort)((&data[3])[0] << 8 | (&data[3])[1]);
			if ((pPage.nCell) > ((pBt.pageSize - 8) / 6))
			{
				return (int)(sqlite3CorruptError((int)(68218)));
			}


			pPage.nFree = (int)(-1);
			pPage.isInit = (byte)(1);
			if ((pBt.db.flags & 0x00200000) != 0)
			{
				return (int)(btreeCellSizeCheck(pPage));
			}

			return (int)(0);
		}
		public static int btreeInvokeBusyHandler(void* pArg)
		{
			BtShared pBt = (BtShared)(pArg);


			return (int)(sqlite3InvokeBusyHandler(pBt.db.busyHandler));
		}
		public static void btreeLeaveAll(sqlite3 db)
		{
			int i = 0;
			Btree p;

			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				p = db.aDb[i].pBt;
				if ((p) != null)
					sqlite3BtreeLeave(p);
			}
		}
		public static void btreeLockCarefully(Btree p)
		{
			Btree pLater;
			if ((sqlite3_mutex_try(p.pBt.mutex)) == (0))
			{
				p.pBt.db = p.db;
				p.locked = (byte)(1);
				return;
			}

			for (pLater = p.pNext; pLater; pLater = pLater.pNext)
			{



				if ((pLater.locked) != 0)
				{
					unlockBtreeMutex(pLater);
				}
			}

			lockBtreeMutex(p);
			for (pLater = p.pNext; pLater; pLater = pLater.pNext)
			{
				if ((pLater.wantToLock) != 0)
				{
					lockBtreeMutex(pLater);
				}
			}
		}
		public static int btreeMoveto(BtCursor pCur, void* pKey, long nKey, int bias, int* pRes)
		{
			int rc = 0;
			UnpackedRecord pIdxKey;
			if ((pKey) != null)
			{
				KeyInfo pKeyInfo = pCur.pKeyInfo;

				pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
				if ((pIdxKey) == (null))
					return (int)(7);
				sqlite3VdbeRecordUnpack(pKeyInfo, (int)(nKey), pKey, pIdxKey);
				if (((pIdxKey.nField) == (0)) || ((pIdxKey.nField) > (pKeyInfo.nAllField)))
				{
					rc = (int)(sqlite3CorruptError((int)(66984)));
				}
				else
				{
					rc = (int)(sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes));
				}

				sqlite3DbFree(pCur.pKeyInfo.db, pIdxKey);
			}
			else
			{
				pIdxKey = null;
				rc = (int)(sqlite3BtreeTableMoveto(pCur, (long)(nKey), (int)(bias), pRes));
			}

			return (int)(rc);
		}
		public static int btreeNext(BtCursor pCur)
		{
			int rc = 0;
			int idx = 0;
			MemPage pPage;

			if (pCur.eState != 0)
			{

				rc = (int)((pCur.eState) >= (3) ? btreeRestoreCursorPosition(pCur) : 0);
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((1) == (pCur.eState))
				{
					return (int)(101);
				}

				if ((pCur.eState) == (2))
				{
					pCur.eState = (byte)(0);
					if ((pCur.skipNext) > (0))
						return (int)(0);
				}
			}

			pPage = pCur.pPage;
			idx = (int)(++pCur.ix);
			if ((pPage.isInit == 0) || ((sqlite3FaultSim((int)(412))) != 0))
			{
				return (int)(sqlite3CorruptError((int)(72079)));
			}

			if ((idx) >= (pPage.nCell))
			{
				if (pPage.leaf == 0)
				{
					rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]))));
					if ((rc) != 0)
						return (int)(rc);
					return (int)(moveToLeftmost(pCur));
				}

				do
				{
					if ((pCur.iPage) == (0))
					{
						pCur.eState = (byte)(1);
						return (int)(101);
					}

					moveToParent(pCur);
					pPage = pCur.pPage;
				}
				while ((pCur.ix) >= (pPage.nCell));
				if ((pPage.intKey) != 0)
				{
					return (int)(sqlite3BtreeNext(pCur, (int)(0)));
				}
				else
				{
					return (int)(0);
				}
			}

			if ((pPage.leaf) != 0)
			{
				return (int)(0);
			}
			else
			{
				return (int)(moveToLeftmost(pCur));
			}
		}
		public static int btreeOverwriteCell(BtCursor pCur, BtreePayload pX)
		{
			int iOffset = 0;
			int nTotal = (int)(pX.nData + pX.nZero);
			int rc = 0;
			MemPage pPage = pCur.pPage;
			BtShared pBt;
			uint ovflPgno = 0;
			uint ovflPageSize = 0;
			if (((pCur.info.pPayload + pCur.info.nLocal) > (pPage.aDataEnd)) || ((pCur.info.pPayload) < (pPage.aData + pPage.cellOffset)))
			{
				return (int)(sqlite3CorruptError((int)(74920)));
			}

			rc = (int)(btreeOverwriteContent(pPage, pCur.info.pPayload, pX, (int)(0), (int)(pCur.info.nLocal)));
			if ((rc) != 0)
				return (int)(rc);
			if ((pCur.info.nLocal) == (nTotal))
				return (int)(0);
			iOffset = (int)(pCur.info.nLocal);


			ovflPgno = (uint)(sqlite3Get4byte(pCur.info.pPayload + iOffset));
			pBt = pPage.pBt;
			ovflPageSize = (uint)(pBt.usableSize - 4);
			do
			{
				rc = (int)(btreeGetPage(pBt, (uint)(ovflPgno), pPage, (int)(0)));
				if ((rc) != 0)
					return (int)(rc);
				if ((sqlite3PagerPageRefcount(pPage.pDbPage) != 1) || ((pPage.isInit) != 0))
				{
					rc = (int)(sqlite3CorruptError((int)(74939)));
				}
				else
				{
					if ((iOffset + ovflPageSize) < ((uint)(nTotal)))
					{
						ovflPgno = (uint)(sqlite3Get4byte(pPage.aData));
					}
					else
					{
						ovflPageSize = (uint)(nTotal - iOffset);
					}

					rc = (int)(btreeOverwriteContent(pPage, pPage.aData + 4, pX, (int)(iOffset), (int)(ovflPageSize)));
				}

				sqlite3PagerUnref(pPage.pDbPage);
				if ((rc) != 0)
					return (int)(rc);
				iOffset += (int)(ovflPageSize);
			}
			while ((iOffset) < (nTotal));
			return (int)(0);
		}
		public static int btreeOverwriteContent(MemPage pPage, byte* pDest, BtreePayload pX, int iOffset, int iAmt)
		{
			int nData = (int)(pX.nData - iOffset);
			if ((nData) <= (0))
			{
				int i = 0;
				for (i = (int)(0); ((i) < (iAmt)) && ((pDest[i]) == (0)); i++)
				{
				}

				if ((i) < (iAmt))
				{
					int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
					if ((rc) != 0)
						return (int)(rc);
					CRuntime.memset(pDest + i, (int)(0), (ulong)(iAmt - i));
				}
			}
			else
			{
				if ((nData) < (iAmt))
				{
					int rc = (int)(btreeOverwriteContent(pPage, pDest + nData, pX, (int)(iOffset + nData), (int)(iAmt - nData)));
					if ((rc) != 0)
						return (int)(rc);
					iAmt = (int)(nData);
				}

				if (memcmp(pDest, ((byte*)(pX.pData)) + iOffset, (ulong)(iAmt)) != 0)
				{
					int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
					if ((rc) != 0)
						return (int)(rc);
					CRuntime.memmove(pDest, ((byte*)(pX.pData)) + iOffset, (ulong)(iAmt));
				}
			}

			return (int)(0);
		}
		public static uint btreePagecount(BtShared pBt)
		{
			return (uint)(pBt.nPage);
		}
		public static MemPage btreePageFromDbPage(PgHdr pDbPage, uint pgno, BtShared pBt)
		{
			MemPage pPage = (MemPage)(sqlite3PagerGetExtra(pDbPage));
			if (pgno != pPage.pgno)
			{
				pPage.aData = sqlite3PagerGetData(pDbPage);
				pPage.pDbPage = pDbPage;
				pPage.pBt = pBt;
				pPage.pgno = (uint)(pgno);
				pPage.hdrOffset = (byte)((pgno) == (1) ? 100 : 0);
			}


			return pPage;
		}
		public static MemPage btreePageLookup(BtShared pBt, uint pgno)
		{
			PgHdr pDbPage;

			pDbPage = sqlite3PagerLookup(pBt.pPager, (uint)(pgno));
			if ((pDbPage) != null)
			{
				return btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
			}

			return null;
		}
		public static void btreeParseCell(MemPage pPage, int iCell, CellInfo* pInfo)
		{
			pPage.xParseCell(pPage, ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (iCell)]))))), pInfo);
		}
		public static void btreeParseCellAdjustSizeForOverflow(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			int minLocal = 0;
			int maxLocal = 0;
			int surplus = 0;
			minLocal = (int)(pPage.minLocal);
			maxLocal = (int)(pPage.maxLocal);
			surplus = (int)(minLocal + (pInfo->nPayload - minLocal) % (pPage.pBt.usableSize - 4));
			if ((surplus) <= (maxLocal))
			{
				pInfo->nLocal = ((ushort)(surplus));
			}
			else
			{
				pInfo->nLocal = ((ushort)(minLocal));
			}

			pInfo->nSize = (ushort)((ushort)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4);
		}
		public static void btreeParseCellPtr(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			byte* pIter;
			uint nPayload = 0;
			ulong iKey = 0;




			pIter = pCell;
			nPayload = (uint)(*pIter);
			if ((nPayload) >= (0x80))
			{
				byte* pEnd = &pIter[8];
				nPayload &= (uint)(0x7f);
				do
				{
					nPayload = (uint)((nPayload << 7) | (*++pIter & 0x7f));
				}
				while (((*pIter) >= (0x80)) && ((pIter) < (pEnd)));
			}

			pIter++;
			iKey = (ulong)(*pIter);
			if ((iKey) >= (0x80))
			{
				byte x = 0;
				iKey = (ulong)(((iKey & 0x7f) << 7) | ((x = (byte)(*++pIter)) & 0x7f));
				if ((x) >= (0x80))
				{
					iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
					if ((x) >= (0x80))
					{
						iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
						if ((x) >= (0x80))
						{
							iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
							if ((x) >= (0x80))
							{
								iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
								if ((x) >= (0x80))
								{
									iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
									if ((x) >= (0x80))
									{
										iKey = (ulong)((iKey << 7) | ((x = (byte)(*++pIter)) & 0x7f));
										if ((x) >= (0x80))
										{
											iKey = (ulong)((iKey << 8) | (*++pIter));
										}
									}
								}
							}
						}
					}
				}
			}

			pIter++;
			pInfo->nKey = (long)(*(long*)(&iKey));
			pInfo->nPayload = (uint)(nPayload);
			pInfo->pPayload = pIter;
			if ((nPayload) <= (pPage.maxLocal))
			{
				pInfo->nSize = (ushort)(nPayload + (ushort)(pIter - pCell));
				if ((pInfo->nSize) < (4))
					pInfo->nSize = (ushort)(4);
				pInfo->nLocal = ((ushort)(nPayload));
			}
			else
			{
				btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
			}
		}
		public static void btreeParseCellPtrIndex(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			byte* pIter;
			uint nPayload = 0;



			pIter = pCell + pPage.childPtrSize;
			nPayload = (uint)(*pIter);
			if ((nPayload) >= (0x80))
			{
				byte* pEnd = &pIter[8];
				nPayload &= (uint)(0x7f);
				do
				{
					nPayload = (uint)((nPayload << 7) | (*++pIter & 0x7f));
				}
				while (((*(pIter)) >= (0x80)) && ((pIter) < (pEnd)));
			}

			pIter++;
			pInfo->nKey = (long)(nPayload);
			pInfo->nPayload = (uint)(nPayload);
			pInfo->pPayload = pIter;
			if ((nPayload) <= (pPage.maxLocal))
			{
				pInfo->nSize = (ushort)(nPayload + (ushort)(pIter - pCell));
				if ((pInfo->nSize) < (4))
					pInfo->nSize = (ushort)(4);
				pInfo->nLocal = ((ushort)(nPayload));
			}
			else
			{
				btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
			}
		}
		public static void btreeParseCellPtrNoPayload(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{



			(void)(pPage);
			pInfo->nSize = (ushort)(4 + sqlite3GetVarint(&pCell[4], (ulong*)(&pInfo->nKey)));
			pInfo->nPayload = (uint)(0);
			pInfo->nLocal = (ushort)(0);
			pInfo->pPayload = null;
			return;
		}
		public static int btreePayloadToLocal(MemPage pPage, long nPayload)
		{
			int maxLocal = 0;
			maxLocal = (int)(pPage.maxLocal);
			if ((nPayload) <= (maxLocal))
			{
				return (int)(nPayload);
			}
			else
			{
				int minLocal = 0;
				int surplus = 0;
				minLocal = (int)(pPage.minLocal);
				surplus = (int)(minLocal + (nPayload - minLocal) % (pPage.pBt.usableSize - 4));
				return (int)(((surplus) <= (maxLocal)) ? surplus : minLocal);
			}
		}
		public static int btreePrevious(BtCursor pCur)
		{
			int rc = 0;
			MemPage pPage;



			if (pCur.eState != 0)
			{
				rc = (int)((pCur.eState) >= (3) ? btreeRestoreCursorPosition(pCur) : 0);
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((1) == (pCur.eState))
				{
					return (int)(101);
				}

				if ((2) == (pCur.eState))
				{
					pCur.eState = (byte)(0);
					if ((pCur.skipNext) < (0))
						return (int)(0);
				}
			}

			pPage = pCur.pPage;

			if (pPage.leaf == 0)
			{
				int idx = (int)(pCur.ix);
				rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))))))));
				if ((rc) != 0)
					return (int)(rc);
				rc = (int)(moveToRightmost(pCur));
			}
			else
			{
				while ((pCur.ix) == (0))
				{
					if ((pCur.iPage) == (0))
					{
						pCur.eState = (byte)(1);
						return (int)(101);
					}

					moveToParent(pCur);
				}



				pCur.ix--;
				pPage = pCur.pPage;
				if (((pPage.intKey) != 0) && (pPage.leaf == 0))
				{
					rc = (int)(sqlite3BtreePrevious(pCur, (int)(0)));
				}
				else
				{
					rc = (int)(0);
				}
			}

			return (int)(rc);
		}
		public static void btreeReleaseAllCursorPages(BtCursor pCur)
		{
			int i = 0;
			if ((pCur.iPage) >= (0))
			{
				for (i = (int)(0); (i) < (pCur.iPage); i++)
				{
					releasePageNotNull(pCur.apPage[i]);
				}

				releasePageNotNull(pCur.pPage);
				pCur.iPage = (sbyte)(-1);
			}
		}
		public static int btreeRestoreCursorPosition(BtCursor pCur)
		{
			int rc = 0;
			int skipNext = (int)(0);


			if ((pCur.eState) == (4))
			{
				return (int)(pCur.skipNext);
			}

			pCur.eState = (byte)(1);
			if ((sqlite3FaultSim((int)(410))) != 0)
			{
				rc = (int)(10);
			}
			else
			{
				rc = (int)(btreeMoveto(pCur, pCur.pKey, (long)(pCur.nKey), (int)(0), &skipNext));
			}

			if ((rc) == (0))
			{
				sqlite3_free(pCur.pKey);
				pCur.pKey = null;

				if ((skipNext) != 0)
					pCur.skipNext = (int)(skipNext);
				if (((pCur.skipNext) != 0) && ((pCur.eState) == (0)))
				{
					pCur.eState = (byte)(2);
				}
			}

			return (int)(rc);
		}
		public static int btreeSetHasContent(BtShared pBt, uint pgno)
		{
			int rc = (int)(0);
			if (pBt.pHasContent == null)
			{

				pBt.pHasContent = sqlite3BitvecCreate((uint)(pBt.nPage));
				if (pBt.pHasContent == null)
				{
					rc = (int)(7);
				}
			}

			if (((rc) == (0)) && ((pgno) <= (sqlite3BitvecSize(pBt.pHasContent))))
			{
				rc = (int)(sqlite3BitvecSet(pBt.pHasContent, (uint)(pgno)));
			}

			return (int)(rc);
		}
		public static void btreeSetNPage(BtShared pBt, MemPage pPage1)
		{
			int nPage = (int)(sqlite3Get4byte(&pPage1.aData[28]));
			if ((nPage) == (0))
				sqlite3PagerPagecount(pBt.pPager, &nPage);
			pBt.nPage = (uint)(nPage);
		}
		public static ushort cachedCellSize(CellArray p, int N)
		{

			if ((p.szCell[N]) != 0)
				return (ushort)(p.szCell[N]);
			return (ushort)(computeCellSize(p, (int)(N)));
		}
		public static void callCollNeeded(sqlite3 db, int enc, sbyte* zName)
		{

			if ((db.xCollNeeded) != null)
			{
				sbyte* zExternal = sqlite3DbStrDup(db, zName);
				if (zExternal == null)
					return;
				db.xCollNeeded(db.pCollNeededArg, db, (int)(enc), zExternal);
				sqlite3DbFree(db, zExternal);
			}

			if ((db.xCollNeeded16) != null)
			{
				sbyte* zExternal;
				sqlite3_value pTmp = sqlite3ValueNew(db);
				sqlite3ValueSetStr(pTmp, (int)(-1), zName, (byte)(1), null);
				zExternal = sqlite3ValueText(pTmp, (byte)(2));
				if ((zExternal) != null)
				{
					db.xCollNeeded16(db.pCollNeededArg, db, (int)((db).enc), zExternal);
				}

				sqlite3ValueFree(pTmp);
			}
		}
		public static void callFinaliser(sqlite3 db, int offset)
		{
			int i = 0;
			if ((db.aVTrans) != null)
			{
				VTable aVTrans = db.aVTrans;
				db.aVTrans = null;
				for (i = (int)(0); (i) < (db.nVTrans); i++)
				{
					VTable pVTab = aVTrans[i];
					sqlite3_vtab p = pVTab.pVtab;
					if ((p) != null)
					{
						delegate23 x;
						x = *(Int(sqlite3_vtab * ))((sbyte*)(p.pModule) + offset);
						if ((x) != null)
							x(p);
					}

					pVTab.iSavepoint = (int)(0);
					sqlite3VtabUnlock(pVTab);
				}

				sqlite3DbFree(db, aVTrans);
				db.nVTrans = (int)(0);
			}
		}
		public static void callStatGet(Parse pParse, int regStat, int iParam, int regOut)
		{
			(void)(iParam);

			sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regStat), (int)(regOut), (int)(1 + 0), statGetFuncdef, (int)(0));
		}
		public static int cannotBeFunction(Parse pParse, SrcItem pFrom)
		{
			if ((pFrom.fg.isTabFunc) != 0)
			{
				sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom.zName);
				return (int)(1);
			}

			return (int)(0);
		}
		public static void cdateFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			dateFunc(context, (int)(0), null);
		}
		public static ushort cellSizePtr(MemPage pPage, byte* pCell)
		{
			byte* pIter = pCell + pPage.childPtrSize;
			byte* pEnd;
			uint nSize = 0;
			nSize = (uint)(*pIter);
			if ((nSize) >= (0x80))
			{
				pEnd = &pIter[8];
				nSize &= (uint)(0x7f);
				do
				{
					nSize = (uint)((nSize << 7) | (*++pIter & 0x7f));
				}
				while (((*(pIter)) >= (0x80)) && ((pIter) < (pEnd)));
			}

			pIter++;
			if ((pPage.intKey) != 0)
			{
				pEnd = &pIter[9];
				while ((((*pIter++) & 0x80) != 0) && ((pIter) < (pEnd)))
				{
				}
			}

			if ((nSize) <= (pPage.maxLocal))
			{
				nSize += ((uint)(pIter - pCell));
				if ((nSize) < (4))
					nSize = (uint)(4);
			}
			else
			{
				int minLocal = (int)(pPage.minLocal);
				nSize = (uint)(minLocal + (nSize - minLocal) % (pPage.pBt.usableSize - 4));
				if ((nSize) > (pPage.maxLocal))
				{
					nSize = (uint)(minLocal);
				}

				nSize += (uint)(4 + (ushort)(pIter - pCell));
			}


			return (ushort)(nSize);
		}
		public static ushort cellSizePtrNoPayload(MemPage pPage, byte* pCell)
		{
			byte* pIter = pCell + 4;
			byte* pEnd;
			(void)(pPage);

			pEnd = pIter + 9;
			while ((((*pIter++) & 0x80) != 0) && ((pIter) < (pEnd)))
			{
			}


			return (ushort)(pIter - pCell);
		}
		public static void changes(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			(void)(NotUsed) ,  (void)(NotUsed2);
			sqlite3_result_int64(context, (long)(sqlite3_changes64(db)));
		}
		public static int changeTempStorage(Parse pParse, sbyte* zStorageType)
		{
			int ts = (int)(getTempStore(zStorageType));
			sqlite3 db = pParse.db;
			if ((db.temp_store) == (ts))
				return (int)(0);
			if (invalidateTempStorage(pParse) != 0)
			{
				return (int)(1);
			}

			db.temp_store = ((byte)(ts));
			return (int)(0);
		}
		public static void charFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* z; byte* zOut;
			int i = 0;
			zOut = z = sqlite3_malloc64((ulong)(argc * 4 + 1));
			if ((z) == (null))
			{
				sqlite3_result_error_nomem(context);
				return;
			}

			for (i = (int)(0); (i) < (argc); i++)
			{
				long x = 0;
				uint c = 0;
				x = (long)(sqlite3_value_int64(argv[i]));
				if (((x) < (0)) || ((x) > (0x10ffff)))
					x = (long)(0xfffd);
				c = ((uint)(x & 0x1fffff));
				if ((c) < (0x00080))
				{
					*zOut++ = ((byte)(c & 0xFF));
				}
				else if ((c) < (0x00800))
				{
					*zOut++ = (byte)(0xC0 + (byte)((c >> 6) & 0x1F));
					*zOut++ = (byte)(0x80 + (byte)(c & 0x3F));
				}
				else if ((c) < (0x10000))
				{
					*zOut++ = (byte)(0xE0 + (byte)((c >> 12) & 0x0F));
					*zOut++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
					*zOut++ = (byte)(0x80 + (byte)(c & 0x3F));
				}
				else
				{
					*zOut++ = (byte)(0xF0 + (byte)((c >> 18) & 0x07));
					*zOut++ = (byte)(0x80 + (byte)((c >> 12) & 0x3F));
					*zOut++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
					*zOut++ = (byte)(0x80 + (byte)(c & 0x3F));
				}
			}

			sqlite3_result_text64(context, (sbyte*)(z), (ulong)(zOut - z), sqlite3_free, (byte)(1));
		}
		public static void checkAppendMsg(IntegrityCk pCheck, sbyte* zFormat)
		{
			sbyte* ap;
			if (pCheck.mxErr == 0)
				return;
			pCheck.mxErr--;
			pCheck.nErr++;
			(__va_start(&ap, zFormat));
			if ((pCheck.errMsg.nChar) != 0)
			{
				sqlite3_str_append(pCheck.errMsg, "\n", (int)(1));
			}

			if ((pCheck.zPfx) != null)
			{
				sqlite3_str_appendf(pCheck.errMsg, pCheck.zPfx, (uint)(pCheck.v1), (int)(pCheck.v2));
			}

			sqlite3_str_vappendf(pCheck.errMsg, zFormat, ap);
			((void)(ap = null));
			if ((pCheck.errMsg.accError) == (7))
			{
				pCheck.bOomFault = (int)(1);
			}
		}
		public static int checkColumnOverlap(IdList* pIdList, ExprList pEList)
		{
			int e = 0;
			if (((pIdList) == (null)) || ((pEList) == (null)))
				return (int)(1);
			for (e = (int)(0); (e) < (pEList.nExpr); e++)
			{
				if ((sqlite3IdListIndex(pIdList, pEList.a[e].zEName)) >= (0))
					return (int)(1);
			}

			return (int)(0);
		}
		public static int checkConstraintExprNode(Walker pWalker, Expr pExpr)
		{
			if ((pExpr.op) == (167))
			{

				if ((pExpr.iColumn) >= (0))
				{
					if ((pWalker.u.aiCol[pExpr.iColumn]) >= (0))
					{
						pWalker.eCode |= (ushort)(0x01);
					}
				}
				else
				{
					pWalker.eCode |= (ushort)(0x02);
				}
			}

			return (int)(0);
		}
		public static void checkList(IntegrityCk pCheck, int isFreeList, uint iPage, uint N)
		{
			int i = 0;
			uint expected = (uint)(N);
			int nErrAtStart = (int)(pCheck.nErr);
			while ((iPage != 0) && ((pCheck.mxErr) != 0))
			{
				PgHdr pOvflPage;
				byte* pOvflData;
				if ((checkRef(pCheck, (uint)(iPage))) != 0)
					break;
				N--;
				if ((sqlite3PagerGet(pCheck.pPager, (uint)(iPage), pOvflPage, (int)(0))) != 0)
				{
					checkAppendMsg(pCheck, "failed to get page %d", (uint)(iPage));
					break;
				}

				pOvflData = (byte*)(sqlite3PagerGetData(pOvflPage));
				if ((isFreeList) != 0)
				{
					uint n = (uint)(sqlite3Get4byte(&pOvflData[4]));
					if ((pCheck.pBt.autoVacuum) != 0)
					{
						checkPtrmap(pCheck, (uint)(iPage), (byte)(2), (uint)(0));
					}

					if ((n) > (pCheck.pBt.usableSize / 4 - 2))
					{
						checkAppendMsg(pCheck, "freelist leaf count too big on page %d", (uint)(iPage));
						N--;
					}
					else
					{
						for (i = (int)(0); (i) < ((int)(n)); i++)
						{
							uint iFreePage = (uint)(sqlite3Get4byte(&pOvflData[8 + i * 4]));
							if ((pCheck.pBt.autoVacuum) != 0)
							{
								checkPtrmap(pCheck, (uint)(iFreePage), (byte)(2), (uint)(0));
							}

							checkRef(pCheck, (uint)(iFreePage));
						}

						N -= (uint)(n);
					}
				}
				else
				{
					if (((pCheck.pBt.autoVacuum) != 0) && ((N) > (0)))
					{
						i = (int)(sqlite3Get4byte(pOvflData));
						checkPtrmap(pCheck, (uint)(i), (byte)(4), (uint)(iPage));
					}
				}

				iPage = (uint)(sqlite3Get4byte(pOvflData));
				sqlite3PagerUnref(pOvflPage);
			}

			if (((N) != 0) && ((nErrAtStart) == (pCheck.nErr)))
			{
				checkAppendMsg(pCheck, "%s is %d but should be %d", (isFreeList) != 0 ? "size" : "overflow list length", (uint)(expected - N), (uint)(expected));
			}
		}
		public static void checkPtrmap(IntegrityCk pCheck, uint iChild, byte eType, uint iParent)
		{
			int rc = 0;
			byte ePtrmapType = 0;
			uint iPtrmapParent = 0;
			rc = (int)(ptrmapGet(pCheck.pBt, (uint)(iChild), &ePtrmapType, &iPtrmapParent));
			if (rc != 0)
			{
				if (((rc) == (7)) || ((rc) == (10 | (12 << 8))))
					pCheck.bOomFault = (int)(1);
				checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", (uint)(iChild));
				return;
			}

			if ((ePtrmapType != eType) || (iPtrmapParent != iParent))
			{
				checkAppendMsg(pCheck, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", (uint)(iChild), (int)(eType), (uint)(iParent), (int)(ePtrmapType), (uint)(iPtrmapParent));
			}
		}
		public static int checkReadTransaction(sqlite3 db, Btree p)
		{
			if (sqlite3BtreeTxnState(p) != 0)
			{
				sqlite3ErrorWithMsg(db, (int)(1), "destination database is in use");
				return (int)(1);
			}

			return (int)(0);
		}
		public static int checkRef(IntegrityCk pCheck, uint iPage)
		{
			if (((iPage) > (pCheck.nPage)) || ((iPage) == (0)))
			{
				checkAppendMsg(pCheck, "invalid page number %d", (uint)(iPage));
				return (int)(1);
			}

			if ((getPageReferenced(pCheck, (uint)(iPage))) != 0)
			{
				checkAppendMsg(pCheck, "2nd reference to page %d", (uint)(iPage));
				return (int)(1);
			}

			if ((0) != 0)
				return (int)(1);
			setPageReferenced(pCheck, (uint)(iPage));
			return (int)(0);
		}
		public static int checkTreePage(IntegrityCk pCheck, uint iPage, long* piMinKey, long maxKey)
		{
			MemPage pPage = null;
			int i = 0;
			int rc = 0;
			int depth = (int)(-1); int d2 = 0;
			int pgno = 0;
			int nFrag = 0;
			int hdr = 0;
			int cellStart = 0;
			int nCell = 0;
			int doCoverageCheck = (int)(1);
			int keyCanBeEqual = (int)(1);
			byte* data;
			byte* pCell;
			byte* pCellIdx;
			BtShared pBt;
			uint pc = 0;
			uint usableSize = 0;
			uint contentOffset = 0;
			uint* heap = null;
			uint x = 0; uint prev = (uint)(0);
			sbyte* saved_zPfx = pCheck.zPfx;
			int saved_v1 = (int)(pCheck.v1);
			int saved_v2 = (int)(pCheck.v2);
			byte savedIsInit = (byte)(0);
			pBt = pCheck.pBt;
			usableSize = (uint)(pBt.usableSize);
			if ((iPage) == (0))
				return (int)(0);
			if ((checkRef(pCheck, (uint)(iPage))) != 0)
				return (int)(0);
			pCheck.zPfx = "Page %u: ";
			pCheck.v1 = (uint)(iPage);
			if ((rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0)))) != 0)
			{
				checkAppendMsg(pCheck, "unable to get the page. error code=%d", (int)(rc));
				goto end_of_check;
			}

			savedIsInit = (byte)(pPage.isInit);
			pPage.isInit = (byte)(0);
			if ((rc = (int)(btreeInitPage(pPage))) != 0)
			{

				checkAppendMsg(pCheck, "btreeInitPage() returns error code %d", (int)(rc));
				goto end_of_check;
			}

			if ((rc = (int)(btreeComputeFreeSpace(pPage))) != 0)
			{

				checkAppendMsg(pCheck, "free space corruption", (int)(rc));
				goto end_of_check;
			}

			data = pPage.aData;
			hdr = (int)(pPage.hdrOffset);
			pCheck.zPfx = "On tree page %u cell %d: ";
			contentOffset = (uint)(((((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]) - 1) & 0xffff) + 1);

			nCell = (int)((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]);

			cellStart = (int)(hdr + 12 - 4 * pPage.leaf);

			pCellIdx = &data[cellStart + 2 * (nCell - 1)];
			if (pPage.leaf == 0)
			{
				pgno = (int)(sqlite3Get4byte(&data[hdr + 8]));
				if ((pBt.autoVacuum) != 0)
				{
					pCheck.zPfx = "On page %u at right child: ";
					checkPtrmap(pCheck, (uint)(pgno), (byte)(5), (uint)(iPage));
				}

				depth = (int)(checkTreePage(pCheck, (uint)(pgno), &maxKey, (long)(maxKey)));
				keyCanBeEqual = (int)(0);
			}
			else
			{
				heap = pCheck.heap;
				heap[0] = (uint)(0);
			}

			for (i = (int)(nCell - 1); ((i) >= (0)) && ((pCheck.mxErr) != 0); i--)
			{
				CellInfo info = new CellInfo();
				pCheck.v2 = (int)(i);

				pc = (uint)(_byteswap_ushort((ushort)(*(ushort*)(pCellIdx))));
				pCellIdx -= 2;
				if (((pc) < (contentOffset)) || ((pc) > (usableSize - 4)))
				{
					checkAppendMsg(pCheck, "Offset %d out of range %d..%d", (uint)(pc), (uint)(contentOffset), (uint)(usableSize - 4));
					doCoverageCheck = (int)(0);
					continue;
				}

				pCell = &data[pc];
				pPage.xParseCell(pPage, pCell, &info);
				if ((pc + info.nSize) > (usableSize))
				{
					checkAppendMsg(pCheck, "Extends off end of page");
					doCoverageCheck = (int)(0);
					continue;
				}

				if ((pPage.intKey) != 0)
				{
					if (((keyCanBeEqual) != 0 ? ((info.nKey) > (maxKey)) : ((info.nKey) >= (maxKey))) != 0)
					{
						checkAppendMsg(pCheck, "Rowid %lld out of order", (long)(info.nKey));
					}

					maxKey = (long)(info.nKey);
					keyCanBeEqual = (int)(0);
				}

				if ((info.nPayload) > (info.nLocal))
				{
					uint nPage = 0;
					uint pgnoOvfl = 0;

					nPage = (uint)((info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4));
					pgnoOvfl = (uint)(sqlite3Get4byte(&pCell[info.nSize - 4]));
					if ((pBt.autoVacuum) != 0)
					{
						checkPtrmap(pCheck, (uint)(pgnoOvfl), (byte)(3), (uint)(iPage));
					}

					checkList(pCheck, (int)(0), (uint)(pgnoOvfl), (uint)(nPage));
				}

				if (pPage.leaf == 0)
				{
					pgno = (int)(sqlite3Get4byte(pCell));
					if ((pBt.autoVacuum) != 0)
					{
						checkPtrmap(pCheck, (uint)(pgno), (byte)(5), (uint)(iPage));
					}

					d2 = (int)(checkTreePage(pCheck, (uint)(pgno), &maxKey, (long)(maxKey)));
					keyCanBeEqual = (int)(0);
					if (d2 != depth)
					{
						checkAppendMsg(pCheck, "Child page depth differs");
						depth = (int)(d2);
					}
				}
				else
				{
					btreeHeapInsert(heap, (uint)((pc << 16) | (pc + info.nSize - 1)));
				}
			}

			*piMinKey = (long)(maxKey);
			pCheck.zPfx = null;
			if (((doCoverageCheck) != 0) && ((pCheck.mxErr) > (0)))
			{
				if (pPage.leaf == 0)
				{
					heap = pCheck.heap;
					heap[0] = (uint)(0);
					for (i = (int)(nCell - 1); (i) >= (0); i--)
					{
						uint size = 0;
						pc = (uint)(_byteswap_ushort((ushort)(*(ushort*)(&data[cellStart + i * 2]))));
						size = (uint)(pPage.xCellSize(pPage, &data[pc]));
						btreeHeapInsert(heap, (uint)((pc << 16) | (pc + size - 1)));
					}
				}

				i = (int)((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);
				while ((i) > (0))
				{
					int size = 0;
					int j = 0;

					size = (int)((&data[i + 2])[0] << 8 | (&data[i + 2])[1]);

					btreeHeapInsert(heap, (uint)((((uint)(i)) << 16) | (i + size - 1)));
					j = (int)((&data[i])[0] << 8 | (&data[i])[1]);


					i = (int)(j);
				}

				nFrag = (int)(0);
				prev = (uint)(contentOffset - 1);
				while ((btreeHeapPull(heap, &x)) != 0)
				{
					if ((prev & 0xffff) >= (x >> 16))
					{
						checkAppendMsg(pCheck, "Multiple uses for byte %u of page %u", (uint)(x >> 16), (uint)(iPage));
						break;
					}
					else
					{
						nFrag += (int)((x >> 16) - (prev & 0xffff) - 1);
						prev = (uint)(x);
					}
				}

				nFrag += (int)(usableSize - (prev & 0xffff) - 1);
				if (((heap[0]) == (0)) && (nFrag != data[hdr + 7]))
				{
					checkAppendMsg(pCheck, "Fragmentation of %d bytes reported as %d on page %u", (int)(nFrag), (int)(data[hdr + 7]), (uint)(iPage));
				}
			}

		end_of_check:
			; if (doCoverageCheck == 0) pPage.isInit = (byte)(savedIsInit);
			releasePage(pPage);
			pCheck.zPfx = saved_zPfx;
			pCheck.v1 = (uint)(saved_v1);
			pCheck.v2 = (int)(saved_v2);
			return (int)(depth + 1);
		}
		public static void clearAllSharedCacheTableLocks(Btree p)
		{
			BtShared pBt = p.pBt;
			BtLock ppIter = pBt.pLock;



			while ((ppIter) != null)
			{
				BtLock pLock = ppIter;


				if ((pLock.pBtree) == (p))
				{
					ppIter = pLock.pNext;

					if (pLock.iTable != 1)
					{
						sqlite3_free(pLock);
					}
				}
				else
				{
					ppIter = pLock.pNext;
				}
			}


			if ((pBt.pWriter) == (p))
			{
				pBt.pWriter = null;
				pBt.btsFlags &= (ushort)(~(0x0040 | 0x0080));
			}
			else if ((pBt.nTransaction) == (2))
			{
				pBt.btsFlags &= (ushort)(~0x0080);
			}
		}
		public static int clearCellOverflow(MemPage pPage, byte* pCell, CellInfo* pInfo)
		{
			BtShared pBt;
			uint ovflPgno = 0;
			int rc = 0;
			int nOvfl = 0;
			uint ovflPageSize = 0;


			if ((pCell + pInfo->nSize) > (pPage.aDataEnd))
			{
				return (int)(sqlite3CorruptError((int)(72717)));
			}

			ovflPgno = (uint)(sqlite3Get4byte(pCell + pInfo->nSize - 4));
			pBt = pPage.pBt;

			ovflPageSize = (uint)(pBt.usableSize - 4);
			nOvfl = (int)((pInfo->nPayload - pInfo->nLocal + ovflPageSize - 1) / ovflPageSize);

			while ((nOvfl--) != 0)
			{
				uint iNext = (uint)(0);
				MemPage pOvfl = null;
				if (((ovflPgno) < (2)) || ((ovflPgno) > (btreePagecount(pBt))))
				{
					return (int)(sqlite3CorruptError((int)(72734)));
				}

				if ((nOvfl) != 0)
				{
					rc = (int)(getOverflowPage(pBt, (uint)(ovflPgno), pOvfl, &iNext));
					if ((rc) != 0)
						return (int)(rc);
				}

				if ((((pOvfl) != null) || ((pOvfl = btreePageLookup(pBt, (uint)(ovflPgno))) != null)) && (sqlite3PagerPageRefcount(pOvfl.pDbPage) != 1))
				{
					rc = (int)(sqlite3CorruptError((int)(72754)));
				}
				else
				{
					rc = (int)(freePage2(pBt, pOvfl, (uint)(ovflPgno)));
				}

				if ((pOvfl) != null)
				{
					sqlite3PagerUnref(pOvfl.pDbPage);
				}

				if ((rc) != 0)
					return (int)(rc);
				ovflPgno = (uint)(iNext);
			}

			return (int)(0);
		}
		public static int clearDatabasePage(BtShared pBt, uint pgno, int freePageFlag, long* pnChange)
		{
			MemPage pPage;
			int rc = 0;
			byte* pCell;
			int i = 0;
			int hdr = 0;
			CellInfo info = new CellInfo();

			if ((pgno) > (btreePagecount(pBt)))
			{
				return (int)(sqlite3CorruptError((int)(75778)));
			}

			rc = (int)(getAndInitPage(pBt, (uint)(pgno), pPage, null, (int)(0)));
			if ((rc) != 0)
				return (int)(rc);
			if (((pBt.openFlags & 4) == (0)) && (sqlite3PagerPageRefcount(pPage.pDbPage) != (1 + ((pgno) == (1)))))
			{
				rc = (int)(sqlite3CorruptError((int)(75785)));
				goto cleardatabasepage_out;
			}

			hdr = (int)(pPage.hdrOffset);
			for (i = (int)(0); (i) < (pPage.nCell); i++)
			{
				pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (i)])))));
				if (pPage.leaf == 0)
				{
					rc = (int)(clearDatabasePage(pBt, (uint)(sqlite3Get4byte(pCell)), (int)(1), pnChange));
					if ((rc) != 0)
						goto cleardatabasepage_out;
				}

				pPage.xParseCell(pPage, pCell, &info);
				if (info.nLocal != info.nPayload)
				{
					rc = (int)(clearCellOverflow(pPage, pCell, &info));
				}
				else
				{
					rc = (int)(0);
				}

				if ((rc) != 0)
					goto cleardatabasepage_out;
			}

			if (pPage.leaf == 0)
			{
				rc = (int)(clearDatabasePage(pBt, (uint)(sqlite3Get4byte(&pPage.aData[hdr + 8])), (int)(1), pnChange));
				if ((rc) != 0)
					goto cleardatabasepage_out;
				if ((pPage.intKey) != 0)
					pnChange = null;
			}

			if ((pnChange) != null)
			{
				*pnChange += (long)(pPage.nCell);
			}

			if ((freePageFlag) != 0)
			{
				freePage(pPage, &rc);
			}
			else if ((rc = (int)(sqlite3PagerWrite(pPage.pDbPage))) == (0))
			{
				zeroPage(pPage, (int)(pPage.aData[hdr] | 0x08));
			}

		cleardatabasepage_out:
			; releasePage(pPage);
			return (int)(rc);
		}
		public static void clearSelect(sqlite3 db, Select p, int bFree)
		{
			while ((p) != null)
			{
				Select pPrior = p.pPrior;
				sqlite3ExprListDelete(db, p.pEList);
				sqlite3SrcListDelete(db, p.pSrc);
				sqlite3ExprDelete(db, p.pWhere);
				sqlite3ExprListDelete(db, p.pGroupBy);
				sqlite3ExprDelete(db, p.pHaving);
				sqlite3ExprListDelete(db, p.pOrderBy);
				sqlite3ExprDelete(db, p.pLimit);
				if ((p.pWith) != null)
					sqlite3WithDelete(db, p.pWith);
				if ((p.pWinDefn) != null)
				{
					sqlite3WindowListDelete(db, p.pWinDefn);
				}

				while ((p.pWin) != null)
				{

					sqlite3WindowUnlinkFromSelect(p.pWin);
				}

				if ((bFree) != 0)
					sqlite3DbFreeNN(db, p);
				p = pPrior;
				bFree = (int)(1);
			}
		}
		public static void clearYMD_HMS_TZ(DateTime* p)
		{
			p->validYMD = (sbyte)(0);
			p->validHMS = (sbyte)(0);
			p->validTZ = (sbyte)(0);
		}
		public static void closeAllCursors(Vdbe p)
		{
			if ((p.pFrame) != null)
			{
				VdbeFrame pFrame;
				for (pFrame = p.pFrame; pFrame.pParent; pFrame = pFrame.pParent)
				{
				}

				sqlite3VdbeFrameRestore(pFrame);
				p.pFrame = null;
				p.nFrame = (int)(0);
			}


			closeCursorsInFrame(p);
			if ((p.aMem) != null)
			{
				releaseMemArray(p.aMem, (int)(p.nMem));
			}

			while ((p.pDelFrame) != null)
			{
				VdbeFrame pDel = p.pDelFrame;
				p.pDelFrame = pDel.pParent;
				sqlite3VdbeFrameDelete(pDel);
			}

			if ((p.pAuxData) != null)
				sqlite3VdbeDeleteAuxData(p.db, p.pAuxData, (int)(-1), (int)(0));

		}
		public static void closeCursorsInFrame(Vdbe p)
		{
			if ((p.apCsr) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (p.nCursor); i++)
				{
					VdbeCursor pC = p.apCsr[i];
					if ((pC) != null)
					{
						sqlite3VdbeFreeCursor(p, pC);
						p.apCsr[i] = null;
					}
				}
			}
		}
		public static int codeAllEqualityTerms(Parse pParse, WhereLevel pLevel, int bRev, int nExtraReg, sbyte** pzAff)
		{
			ushort nEq = 0;
			ushort nSkip = 0;
			Vdbe v = pParse.pVdbe;
			Index pIdx;
			WhereTerm pTerm;
			WhereLoop pLoop;
			int j = 0;
			int regBase = 0;
			int nReg = 0;
			sbyte* zAff;
			pLoop = pLevel.pWLoop;

			nEq = (ushort)(pLoop.u.btree.nEq);
			nSkip = (ushort)(pLoop.nSkip);
			pIdx = pLoop.u.btree.pIndex;

			regBase = (int)(pParse.nMem + 1);
			nReg = (int)(pLoop.u.btree.nEq + nExtraReg);
			pParse.nMem += (int)(nReg);
			zAff = sqlite3DbStrDup(pParse.db, sqlite3IndexAffinityStr(pParse.db, pIdx));

			if ((nSkip) != 0)
			{
				int iIdxCur = (int)(pLevel.iIdxCur);
				sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(regBase), (int)(regBase + nSkip - 1));
				sqlite3VdbeAddOp1(v, (int)((bRev) != 0 ? 34 : 38), (int)(iIdxCur));
				j = (int)(sqlite3VdbeAddOp0(v, (int)(11)));

				pLevel.addrSkip = (int)(sqlite3VdbeAddOp4Int(v, (int)((bRev) != 0 ? 23 : 26), (int)(iIdxCur), (int)(0), (int)(regBase), (int)(nSkip)));
				sqlite3VdbeJumpHere(v, (int)(j));
				for (j = (int)(0); (j) < (nSkip); j++)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(j), (int)(regBase + j));
				}
			}


			for (j = (int)(nSkip); (j) < (nEq); j++)
			{
				int r1 = 0;
				pTerm = pLoop.aLTerm[j];

				r1 = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(j), (int)(bRev), (int)(regBase + j)));
				if (r1 != regBase + j)
				{
					if ((nReg) == (1))
					{
						sqlite3ReleaseTempReg(pParse, (int)(regBase));
						regBase = (int)(r1);
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(79), (int)(r1), (int)(regBase + j));
					}
				}
			}

			for (j = (int)(nSkip); (j) < (nEq); j++)
			{
				pTerm = pLoop.aLTerm[j];
				if ((pTerm.eOperator & 0x0001) != 0)
				{
					if ((pTerm.pExpr.flags & 0x000800) != 0)
					{
						if ((zAff) != null)
							zAff[j] = (sbyte)(0x41);
					}
				}
				else if ((pTerm.eOperator & 0x0100) == (0))
				{
					Expr pRight = pTerm.pExpr.pRight;
					if (((pTerm.wtFlags & 0x0800) == (0)) && ((sqlite3ExprCanBeNull(pRight)) != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + j), (int)(pLevel.addrBrk));
					}

					if ((pParse.nErr) == (0))
					{

						if ((sqlite3CompareAffinity(pRight, (sbyte)(zAff[j]))) == (0x41))
						{
							zAff[j] = (sbyte)(0x41);
						}

						if ((sqlite3ExprNeedsNoAffinityChange(pRight, (sbyte)(zAff[j]))) != 0)
						{
							zAff[j] = (sbyte)(0x41);
						}
					}
				}
			}

			*pzAff = zAff;
			return (int)(regBase);
		}
		public static void codeApplyAffinity(Parse pParse, int _base_, int n, sbyte* zAff)
		{
			Vdbe v = pParse.pVdbe;
			if ((zAff) == (null))
			{

				return;
			}



			while (((n) > (0)) && ((zAff[0]) <= (0x41)))
			{
				n--;
				_base_++;
				zAff++;
			}

			while (((n) > (1)) && ((zAff[n - 1]) <= (0x41)))
			{
				n--;
			}

			if ((n) > (0))
			{
				sqlite3VdbeAddOp4(v, (int)(95), (int)(_base_), (int)(n), (int)(0), zAff, (int)(n));
			}
		}
		public static void codeAttach(Parse pParse, int type, FuncDef pFunc, Expr pAuthArg, Expr pFilename, Expr pDbname, Expr pKey)
		{
			int rc = 0;
			NameContext sName = new NameContext();
			Vdbe v;
			sqlite3 db = pParse.db;
			int regArgs = 0;
			if ((pParse.nErr) != 0)
				goto attach_end;
			CRuntime.memset(sName, (int)(0), (ulong)(sizeof(NameContext)));
			sName.pParse = pParse;
			if (((0 != resolveAttachExpr(sName, pFilename)) || (0 != resolveAttachExpr(sName, pDbname))) || (0 != resolveAttachExpr(sName, pKey)))
			{
				goto attach_end;
			}

			if ((pAuthArg) != null)
			{
				sbyte* zAuthArg;
				if ((pAuthArg.op) == (117))
				{

					zAuthArg = pAuthArg.u.zToken;
				}
				else
				{
					zAuthArg = null;
				}

				rc = (int)(sqlite3AuthCheck(pParse, (int)(type), zAuthArg, null, null));
				if (rc != 0)
				{
					goto attach_end;
				}
			}

			v = sqlite3GetVdbe(pParse);
			regArgs = (int)(sqlite3GetTempRange(pParse, (int)(4)));
			sqlite3ExprCode(pParse, pFilename, (int)(regArgs));
			sqlite3ExprCode(pParse, pDbname, (int)(regArgs + 1));
			sqlite3ExprCode(pParse, pKey, (int)(regArgs + 2));

			if ((v) != null)
			{
				sqlite3VdbeAddFunctionCall(pParse, (int)(0), (int)(regArgs + 3 - pFunc.nArg), (int)(regArgs + 3), (int)(pFunc.nArg), pFunc, (int)(0));
				sqlite3VdbeAddOp1(v, (int)(165), (((type) == (24)) ? 1 : 0));
			}

		attach_end:
			; sqlite3ExprDelete(db, pFilename);
			sqlite3ExprDelete(db, pDbname);
			sqlite3ExprDelete(db, pKey);
		}
		public static int codeCompare(Parse pParse, Expr pLeft, Expr pRight, int opcode, int in1, int in2, int dest, int jumpIfNull, int isCommuted)
		{
			int p5 = 0;
			int addr = 0;
			CollSeq p4;
			if ((pParse.nErr) != 0)
				return (int)(0);
			if ((isCommuted) != 0)
			{
				p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
			}
			else
			{
				p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
			}

			p5 = (int)(binaryCompareP5(pLeft, pRight, (int)(jumpIfNull)));
			addr = (int)(sqlite3VdbeAddOp4(pParse.pVdbe, (int)(opcode), (int)(in2), (int)(dest), (int)(in1), (void*)(p4), (int)(-2)));
			sqlite3VdbeChangeP5(pParse.pVdbe, (ushort)((byte)(p5)));
			return (int)(addr);
		}
		public static void codeDeferredSeek(WhereInfo pWInfo, Index pIdx, int iCur, int iIdxCur)
		{
			Parse pParse = pWInfo.pParse;
			Vdbe v = pParse.pVdbe;


			pWInfo.bDeferredSeek = (uint)(1);
			sqlite3VdbeAddOp3(v, (int)(140), (int)(iIdxCur), (int)(0), (int)(iCur));
			if (((pWInfo.wctrlFlags & 0x0020) != 0) && ((((pParse).pToplevel ? (pParse).pToplevel : (pParse)).writeMask) == (0)))
			{
				int i = 0;
				Table pTab = pIdx.pTable;
				uint* ai = (uint*)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(uint) * (pTab.nCol + 1))));
				if ((ai) != null)
				{
					ai[0] = (uint)(pTab.nCol);
					for (i = (int)(0); (i) < (pIdx.nColumn - 1); i++)
					{
						int x1 = 0;
						int x2 = 0;

						x1 = (int)(pIdx.aiColumn[i]);
						x2 = (int)(sqlite3TableColumnToStorage(pTab, (short)(x1)));
						if ((x1) >= (0))
							ai[x2 + 1] = (uint)(i + 1);
					}

					sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(ai), (int)(-15));
				}
			}
		}
		public static int codeDistinct(Parse pParse, int eTnctType, int iTab, int addrRepeat, ExprList pEList, int regElem)
		{
			int iRet = (int)(0);
			int nResultCol = (int)(pEList.nExpr);
			Vdbe v = pParse.pVdbe;
			switch (eTnctType)
			{
				case 2:
					{
						int i = 0;
						int iJump = 0;
						int regPrev = 0;
						iRet = (int)(regPrev = (int)(pParse.nMem + 1));
						pParse.nMem += (int)(nResultCol);
						iJump = (int)(sqlite3VdbeCurrentAddr(v) + nResultCol);
						for (i = (int)(0); (i) < (nResultCol); i++)
						{
							CollSeq pColl = sqlite3ExprCollSeq(pParse, pEList.a[i].pExpr);
							if ((i) < (nResultCol - 1))
							{
								sqlite3VdbeAddOp3(v, (int)(52), (int)(regElem + i), (int)(iJump), (int)(regPrev + i));
							}
							else
							{
								sqlite3VdbeAddOp3(v, (int)(53), (int)(regElem + i), (int)(addrRepeat), (int)(regPrev + i));
							}

							sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pColl), (int)(-2));
							sqlite3VdbeChangeP5(v, (ushort)(0x80));
						}


						sqlite3VdbeAddOp3(v, (int)(79), (int)(regElem), (int)(regPrev), (int)(nResultCol - 1));
						break;
					}

				case 1:
					{
						break;
					}

				default:
					{
						int r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iTab), (int)(addrRepeat), (int)(regElem), (int)(nResultCol));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regElem), (int)(nResultCol), (int)(r1));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iTab), (int)(r1), (int)(regElem), (int)(nResultCol));
						sqlite3VdbeChangeP5(v, (ushort)(0x10));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						iRet = (int)(iTab);
						break;
					}
			}

			return (int)(iRet);
		}
		public static int codeEqualityTerm(Parse pParse, WhereTerm pTerm, WhereLevel pLevel, int iEq, int bRev, int iTarget)
		{
			Expr pX = pTerm.pExpr;
			Vdbe v = pParse.pVdbe;
			int iReg = 0;


			if (((pX.op) == (53)) || ((pX.op) == (45)))
			{
				iReg = (int)(sqlite3ExprCodeTarget(pParse, pX.pRight, (int)(iTarget)));
			}
			else if ((pX.op) == (50))
			{
				iReg = (int)(iTarget);
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(iReg));
			}
			else
			{
				int eType = (int)(5);
				int iTab = 0;
				InLoop* pIn;
				WhereLoop pLoop = pLevel.pWLoop;
				int i = 0;
				int nEq = (int)(0);
				int* aiMap = null;
				if ((((pLoop.wsFlags & 0x00000400) == (0)) && (pLoop.u.btree.pIndex != null)) && ((pLoop.u.btree.pIndex.aSortOrder[iEq]) != 0))
				{
					bRev = (int)(!bRev);
				}


				iReg = (int)(iTarget);
				for (i = (int)(0); (i) < (iEq); i++)
				{
					if (((pLoop.aLTerm[i]) != null) && ((pLoop.aLTerm[i].pExpr) == (pX)))
					{
						disableTerm(pLevel, pTerm);
						return (int)(iTarget);
					}
				}

				for (i = (int)(iEq); (i) < (pLoop.nLTerm); i++)
				{

					if ((pLoop.aLTerm[i].pExpr) == (pX))
						nEq++;
				}

				iTab = (int)(0);
				if ((!(((pX).flags & 0x000800) != 0)) || ((pX.x.pSelect.pEList.nExpr) == (1)))
				{
					eType = (int)(sqlite3FindInIndex(pParse, pX, (uint)(0x0004), null, null, &iTab));
				}
				else
				{
					sqlite3 db = pParse.db;
					pX = removeUnindexableInClauseTerms(pParse, (int)(iEq), pLoop, pX);
					if (db.mallocFailed == 0)
					{
						aiMap = (int*)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(int) * nEq)));
						eType = (int)(sqlite3FindInIndex(pParse, pX, (uint)(0x0004), null, aiMap, &iTab));
						pTerm.pExpr.iTable = (int)(iTab);
					}

					sqlite3ExprDelete(db, pX);
					pX = pTerm.pExpr;
				}

				if ((eType) == (4))
				{
					bRev = (int)(!bRev);
				}

				sqlite3VdbeAddOp2(v, (int)((bRev) != 0 ? 34 : 38), (int)(iTab), (int)(0));

				pLoop.wsFlags |= (uint)(0x00000800);
				if ((pLevel.u._in_.nIn) == (0))
				{
					pLevel.addrNxt = (int)(sqlite3VdbeMakeLabel(pParse));
				}

				if (((iEq) > (0)) && ((pLoop.wsFlags & 0x00100000) == (0)))
				{
					pLoop.wsFlags |= (uint)(0x00040000);
				}

				i = (int)(pLevel.u._in_.nIn);
				pLevel.u._in_.nIn += (int)(nEq);
				pLevel.u._in_.aInLoop = sqlite3DbReallocOrFree(pParse.db, pLevel.u._in_.aInLoop, (ulong)(sizeof(InLoop) * pLevel.u._in_.nIn));
				pIn = pLevel.u._in_.aInLoop;
				if ((pIn) != null)
				{
					int iMap = (int)(0);
					pIn += i;
					for (i = (int)(iEq); (i) < (pLoop.nLTerm); i++)
					{
						if ((pLoop.aLTerm[i].pExpr) == (pX))
						{
							int iOut = (int)(iReg + i - iEq);
							if ((eType) == (1))
							{
								pIn->addrInTop = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iTab), (int)(iOut)));
							}
							else
							{
								int iCol = (int)((aiMap) != 0 ? aiMap[iMap++] : 0);
								pIn->addrInTop = (int)(sqlite3VdbeAddOp3(v, (int)(93), (int)(iTab), (int)(iCol), (int)(iOut)));
							}

							sqlite3VdbeAddOp1(v, (int)(50), (int)(iOut));
							if ((i) == (iEq))
							{
								pIn->iCur = (int)(iTab);
								pIn->eEndLoopOp = (byte)((bRev) != 0 ? 4 : 5);
								if ((iEq) > (0))
								{
									pIn->iBase = (int)(iReg - i);
									pIn->nPrefix = (int)(i);
								}
								else
								{
									pIn->nPrefix = (int)(0);
								}
							}
							else
							{
								pIn->eEndLoopOp = (byte)(182);
							}

							pIn++;
						}
					}

					if (((iEq) > (0)) && ((pLoop.wsFlags & (0x00100000 | 0x00000400)) == (0)))
					{
						sqlite3VdbeAddOp3(v, (int)(124), (int)(pLevel.iIdxCur), (int)(0), (int)(iEq));
					}
				}
				else
				{
					pLevel.u._in_.nIn = (int)(0);
				}

				sqlite3DbFree(pParse.db, aiMap);
			}

			if (((pLevel.pWLoop.wsFlags & 0x00200000) == (0)) || ((pTerm.eOperator & 0x0800) == (0)))
			{
				disableTerm(pLevel, pTerm);
			}

			return (int)(iReg);
		}
		public static void codeExprOrVector(Parse pParse, Expr p, int iReg, int nReg)
		{

			if (((p) != null) && ((sqlite3ExprIsVector(p)) != 0))
			{
				if ((((p).flags & 0x000800) != 0))
				{
					Vdbe v = pParse.pVdbe;
					int iSelect = 0;

					iSelect = (int)(sqlite3CodeSubselect(pParse, p));
					sqlite3VdbeAddOp3(v, (int)(79), (int)(iSelect), (int)(iReg), (int)(nReg - 1));
				}
				else
				{
					int i = 0;
					ExprList pList;

					pList = p.x.pList;

					for (i = (int)(0); (i) < (nReg); i++)
					{
						sqlite3ExprCode(pParse, pList.a[i].pExpr, (int)(iReg + i));
					}
				}
			}
			else
			{

				sqlite3ExprCode(pParse, p, (int)(iReg));
			}
		}
		public static void codeInteger(Parse pParse, Expr pExpr, int negFlag, int iMem)
		{
			Vdbe v = pParse.pVdbe;
			if ((pExpr.flags & 0x000400) != 0)
			{
				int i = (int)(pExpr.u.iValue);

				if ((negFlag) != 0)
					i = (int)(-i);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(i), (int)(iMem));
			}
			else
			{
				int c = 0;
				long value = 0;
				sbyte* z = pExpr.u.zToken;

				c = (int)(sqlite3DecOrHexToI64(z, &value));
				if (((((c) == (3)) && (negFlag == 0)) || ((c) == (2))) || (((negFlag) != 0) && ((value) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))))
				{
					if ((sqlite3_strnicmp(z, "0x", (int)(2))) == (0))
					{
						sqlite3ErrorMsg(pParse, "hex literal too big: %s%#T", (negFlag) != 0 ? "-" : "", pExpr);
					}
					else
					{
						codeReal(v, z, (int)(negFlag), (int)(iMem));
					}
				}
				else
				{
					if ((negFlag) != 0)
					{
						value = (long)((c) == (3) ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) : -value);
					}

					sqlite3VdbeAddOp4Dup8(v, (int)(72), (int)(0), (int)(iMem), (int)(0), (byte*)(&value), (int)(-14));
				}
			}
		}
		public static void codeOffset(Vdbe v, int iOffset, int iContinue)
		{
			if ((iOffset) > (0))
			{
				sqlite3VdbeAddOp3(v, (int)(49), (int)(iOffset), (int)(iContinue), (int)(1));
			}
		}
		public static void codeReal(Vdbe v, sbyte* z, int negateFlag, int iMem)
		{
			if ((z != null))
			{
				double value = 0;
				sqlite3AtoF(z, &value, (int)(sqlite3Strlen30(z)), (byte)(1));

				if ((negateFlag) != 0)
					value = (double)(-value);
				sqlite3VdbeAddOp4Dup8(v, (int)(153), (int)(0), (int)(iMem), (int)(0), (byte*)(&value), (int)(-13));
			}
		}
		public static void codeReturningTrigger(Parse pParse, Trigger pTrigger, Table pTab, int regIn)
		{
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			ExprList pNew;
			Returning pReturning;
			Select sSelect = new Select();
			SrcList sFrom = new SrcList();



			pReturning = pParse.u1.pReturning;

			CRuntime.memset(sSelect, (int)(0), (ulong)(sizeof(Select)));
			CRuntime.memset(sFrom, (int)(0), (ulong)(sizeof(SrcList)));
			sSelect.pEList = sqlite3ExprListDup(db, pReturning.pReturnEL, (int)(0));
			sSelect.pSrc = sFrom;
			sFrom.nSrc = (int)(1);
			sFrom.a[0].pTab = pTab;
			sFrom.a[0].iCursor = (int)(-1);
			sqlite3SelectPrep(pParse, sSelect, null);
			if ((pParse.nErr) == (0))
			{

				sqlite3GenerateColumnNames(pParse, sSelect);
			}

			sqlite3ExprListDelete(db, sSelect.pEList);
			pNew = sqlite3ExpandReturning(pParse, pReturning.pReturnEL, pTab);
			if (db.mallocFailed == 0)
			{
				NameContext sNC = new NameContext();
				CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
				if ((pReturning.nRetCol) == (0))
				{
					pReturning.nRetCol = (int)(pNew.nExpr);
					pReturning.iRetCur = (int)(pParse.nTab++);
				}

				sNC.pParse = pParse;
				sNC.uNC.iBaseReg = (int)(regIn);
				sNC.ncFlags = (int)(0x000400);
				pParse.eTriggerOp = (byte)(pTrigger.op);
				pParse.pTriggerTab = pTab;
				if (((sqlite3ResolveExprListNames(sNC, pNew)) == (0)) && ((!db.mallocFailed) != 0))
				{
					int i = 0;
					int nCol = (int)(pNew.nExpr);
					int reg = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(nCol + 2);
					pReturning.iRetReg = (int)(reg);
					for (i = (int)(0); (i) < (nCol); i++)
					{
						Expr pCol = pNew.a[i].pExpr;

						sqlite3ExprCodeFactorable(pParse, pCol, (int)(reg + i));
						if ((sqlite3ExprAffinity(pCol)) == (0x45))
						{
							sqlite3VdbeAddOp1(v, (int)(86), (int)(reg + i));
						}
					}

					sqlite3VdbeAddOp3(v, (int)(96), (int)(reg), (int)(i), (int)(reg + i));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(pReturning.iRetCur), (int)(reg + i + 1));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(pReturning.iRetCur), (int)(reg + i), (int)(reg + i + 1));
				}
			}

			sqlite3ExprListDelete(db, pNew);
			pParse.eTriggerOp = (byte)(0);
			pParse.pTriggerTab = null;
		}
		public static TriggerPrg codeRowTrigger(Parse pParse, Trigger pTrigger, Table pTab, int orconf)
		{
			Parse pTop = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			sqlite3 db = pParse.db;
			TriggerPrg pPrg;
			Expr pWhen = null;
			Vdbe v;
			NameContext sNC = new NameContext();
			SubProgram* pProgram = null;
			int iEndTrigger = (int)(0);
			Parse sSubParse = new Parse();


			pPrg = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerPrg)));
			if (pPrg == null)
				return null;
			pPrg.pNext = pTop.pTriggerPrg;
			pTop.pTriggerPrg = pPrg;
			pPrg.pProgram = pProgram = sqlite3DbMallocZero(db, (ulong)(sizeof(SubProgram)));
			if (pProgram == null)
				return null;
			sqlite3VdbeLinkSubProgram(pTop.pVdbe, pProgram);
			pPrg.pTrigger = pTrigger;
			pPrg.orconf = (int)(orconf);
			pPrg.aColmask[0] = (uint)(0xffffffff);
			pPrg.aColmask[1] = (uint)(0xffffffff);
			sqlite3ParseObjectInit(sSubParse, db);
			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = sSubParse;
			sSubParse.pTriggerTab = pTab;
			sSubParse.pToplevel = pTop;
			sSubParse.zAuthContext = pTrigger.zName;
			sSubParse.eTriggerOp = (byte)(pTrigger.op);
			sSubParse.nQueryLoop = (uint)(pParse.nQueryLoop);
			sSubParse.disableVtab = (byte)(pParse.disableVtab);
			v = sqlite3GetVdbe(sSubParse);
			if ((v) != null)
			{
				if ((pTrigger.zName) != null)
				{
					sqlite3VdbeChangeP4(v, (int)(-1), sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger.zName), (int)(-7));
				}

				if ((pTrigger.pWhen) != null)
				{
					pWhen = sqlite3ExprDup(db, pTrigger.pWhen, (int)(0));
					if (((db.mallocFailed) == (0)) && ((0) == (sqlite3ResolveExprNames(sNC, pWhen))))
					{
						iEndTrigger = (int)(sqlite3VdbeMakeLabel(sSubParse));
						sqlite3ExprIfFalse(sSubParse, pWhen, (int)(iEndTrigger), (int)(0x10));
					}

					sqlite3ExprDelete(db, pWhen);
				}

				codeTriggerProgram(sSubParse, pTrigger.step_list, (int)(orconf));
				if ((iEndTrigger) != 0)
				{
					sqlite3VdbeResolveLabel(v, (int)(iEndTrigger));
				}

				sqlite3VdbeAddOp0(v, (int)(70));
				transferParseError(pParse, sSubParse);
				if ((pParse.nErr) == (0))
				{

					pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop.nMaxArg);
				}

				pProgram->nMem = (int)(sSubParse.nMem);
				pProgram->nCsr = (int)(sSubParse.nTab);
				pProgram->token = (void*)(pTrigger);
				pPrg.aColmask[0] = (uint)(sSubParse.oldmask);
				pPrg.aColmask[1] = (uint)(sSubParse.newmask);
				sqlite3VdbeDelete(v);
			}
			else
			{
				transferParseError(pParse, sSubParse);
			}


			sqlite3ParseObjectReset(sSubParse);
			return pPrg;
		}
		public static void codeTableLocks(Parse pParse)
		{
			int i = 0;
			Vdbe pVdbe = pParse.pVdbe;

			for (i = (int)(0); (i) < (pParse.nTableLock); i++)
			{
				TableLock* p = &pParse.aTableLock[i];
				int p1 = (int)(p->iDb);
				sqlite3VdbeAddOp4(pVdbe, (int)(168), (int)(p1), (int)(p->iTab), (int)(p->isWriteLock), p->zLockName, (int)(-1));
			}
		}
		public static int codeTriggerProgram(Parse pParse, TriggerStep pStepList, int orconf)
		{
			TriggerStep pStep;
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;



			for (pStep = pStepList; pStep; pStep = pStep.pNext)
			{
				pParse.eOrconf = (byte)(((orconf) == (11)) ? pStep.orconf : (byte)(orconf));

				if ((pStep.zSpan) != null)
				{
					sqlite3VdbeAddOp4(v, (int)(179), (int)(0x7fffffff), (int)(1), (int)(0), sqlite3MPrintf(db, "-- %s", pStep.zSpan), (int)(-7));
				}

				switch (pStep.op)
				{
					case 129:
						{
							sqlite3Update(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprListDup(db, pStep.pExprList, (int)(0)), sqlite3ExprDup(db, pStep.pWhere, (int)(0)), (int)(pParse.eOrconf), null, null, null);
							sqlite3VdbeAddOp0(v, (int)(130));
							break;
						}

					case 127:
						{
							sqlite3Insert(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3SelectDup(db, pStep.pSelect, (int)(0)), sqlite3IdListDup(db, pStep.pIdList), (int)(pParse.eOrconf), sqlite3UpsertDup(db, pStep.pUpsert));
							sqlite3VdbeAddOp0(v, (int)(130));
							break;
						}

					case 128:
						{
							sqlite3DeleteFrom(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprDup(db, pStep.pWhere, (int)(0)), null, null);
							sqlite3VdbeAddOp0(v, (int)(130));
							break;
						}

					default:

						{
							SelectDest sDest = new SelectDest();
							Select pSelect = sqlite3SelectDup(db, pStep.pSelect, (int)(0));
							sqlite3SelectDestInit(sDest, (int)(4), (int)(0));
							sqlite3Select(pParse, pSelect, sDest);
							sqlite3SelectDelete(db, pSelect);
							break;
						}
				}
			}

			return (int)(0);
		}
		public static void codeVectorCompare(Parse pParse, Expr pExpr, int dest, byte op, byte p5)
		{
			Vdbe v = pParse.pVdbe;
			Expr pLeft = pExpr.pLeft;
			Expr pRight = pExpr.pRight;
			int nLeft = (int)(sqlite3ExprVectorSize(pLeft));
			int i = 0;
			int regLeft = (int)(0);
			int regRight = (int)(0);
			byte opx = (byte)(op);
			int addrCmp = (int)(0);
			int addrDone = (int)(sqlite3VdbeMakeLabel(pParse));
			int isCommuted = (int)(((pExpr).flags & (0x000200)) != 0);

			if ((pParse.nErr) != 0)
				return;
			if (nLeft != sqlite3ExprVectorSize(pRight))
			{
				sqlite3ErrorMsg(pParse, "row value misused");
				return;
			}





			if ((op) == (55))
				opx = (byte)(56);
			if ((op) == (57))
				opx = (byte)(54);
			if ((op) == (52))
				opx = (byte)(53);
			regLeft = (int)(exprCodeSubselect(pParse, pLeft));
			regRight = (int)(exprCodeSubselect(pParse, pRight));
			sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(dest));
			for (i = (int)(0); 1; i++)
			{
				int regFree1 = (int)(0);
				int regFree2 = (int)(0);
				Expr pL = null;
				Expr pR = null;
				int r1 = 0;
				int r2 = 0;

				if ((addrCmp) != 0)
					sqlite3VdbeJumpHere(v, (int)(addrCmp));
				r1 = (int)(exprVectorRegister(pParse, pLeft, (int)(i), (int)(regLeft), pL, &regFree1));
				r2 = (int)(exprVectorRegister(pParse, pRight, (int)(i), (int)(regRight), pR, &regFree2));
				addrCmp = (int)(sqlite3VdbeCurrentAddr(v));
				codeCompare(pParse, pL, pR, (int)(opx), (int)(r1), (int)(r2), (int)(addrDone), (int)(p5), (int)(isCommuted));
				sqlite3ReleaseTempReg(pParse, (int)(regFree1));
				sqlite3ReleaseTempReg(pParse, (int)(regFree2));
				if ((((opx) == (56)) || ((opx) == (54))) && ((i) < (nLeft - 1)))
				{
					addrCmp = (int)(sqlite3VdbeAddOp0(v, (int)(58)));
				}

				if ((p5) == (0x80))
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(dest));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(91), (int)(r1), (int)(dest), (int)(r2));
				}

				if ((i) == (nLeft - 1))
				{
					break;
				}

				if ((opx) == (53))
				{
					sqlite3VdbeAddOp2(v, (int)(51), (int)(dest), (int)(addrDone));
				}
				else
				{

					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrDone));
					if ((i) == (nLeft - 2))
						opx = (byte)(op);
				}
			}

			sqlite3VdbeJumpHere(v, (int)(addrCmp));
			sqlite3VdbeResolveLabel(v, (int)(addrDone));
			if ((op) == (52))
			{
				sqlite3VdbeAddOp2(v, (int)(19), (int)(dest), (int)(dest));
			}
		}
		public static int collationMatch(sbyte* zColl, Index pIndex)
		{
			int i = 0;

			for (i = (int)(0); (i) < (pIndex.nColumn); i++)
			{
				sbyte* z = pIndex.azColl[i];

				if (((pIndex.aiColumn[i]) >= (0)) && ((0) == (sqlite3StrICmp(z, zColl))))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static void columnMallocFailure(sqlite3_stmt* pStmt)
		{
			Vdbe p = (Vdbe)(pStmt);
			if ((p) != null)
			{


				p.rc = (int)(sqlite3ApiExit(p.db, (int)(p.rc)));
				sqlite3_mutex_leave(p.db.mutex);
			}
		}
		public static sqlite3_value columnMem(sqlite3_stmt* pStmt, int i)
		{
			Vdbe pVm;
			sqlite3_value pOut;
			pVm = (Vdbe)(pStmt);
			if ((pVm) == (null))
				return columnNullValue();

			sqlite3_mutex_enter(pVm.db.mutex);
			if (((pVm.pResultSet != null) && ((i) < (pVm.nResColumn))) && ((i) >= (0)))
			{
				pOut = pVm.pResultSet[i];
			}
			else
			{
				sqlite3Error(pVm.db, (int)(25));
				pOut = columnNullValue();
			}

			return pOut;
		}
		public static void* columnName(sqlite3_stmt* pStmt, int N, int useUtf16, int useType)
		{
			void* ret;
			Vdbe p;
			int n = 0;
			sqlite3 db;
			ret = null;
			p = (Vdbe)(pStmt);
			db = p.db;

			n = (int)(sqlite3_column_count(pStmt));
			if (((N) < (n)) && ((N) >= (0)))
			{
				N += (int)(useType * n);
				sqlite3_mutex_enter(db.mutex);

				if ((useUtf16) != 0)
				{
					ret = sqlite3_value_text16(p.aColName[N]);
				}
				else
				{
					ret = sqlite3_value_text(p.aColName[N]);
				}

				if ((db.mallocFailed) != 0)
				{
					sqlite3OomClear(db);
					ret = null;
				}

				sqlite3_mutex_leave(db.mutex);
			}

			return ret;
		}
		public static sqlite3_value columnNullValue()
		{
			return columnNullValue_nullMem;
		}
		public static sbyte* columnTypeImpl(NameContext pNC, Expr pExpr)
		{
			sbyte* zType = null;
			int j = 0;


			switch (pExpr.op)
			{
				case 167:
					{
						Table pTab = null;
						Select pS = null;
						int iCol = (int)(pExpr.iColumn);
						while (((pNC) != null) && (pTab == null))
						{
							SrcList pTabList = pNC.pSrcList;
							for (j = (int)(0); ((j) < (pTabList.nSrc)) && (pTabList.a[j].iCursor != pExpr.iTable); j++)
							{
							}

							if ((j) < (pTabList.nSrc))
							{
								pTab = pTabList.a[j].pTab;
								pS = pTabList.a[j].pSelect;
							}
							else
							{
								pNC = pNC.pNext;
							}
						}

						if ((pTab) == (null))
						{
							break;
						}


						if ((pS) != null)
						{
							if (((iCol) < (pS.pEList.nExpr)) && ((iCol) >= (0)))
							{
								NameContext sNC = new NameContext();
								Expr p = pS.pEList.a[iCol].pExpr;
								sNC.pSrcList = pS.pSrc;
								sNC.pNext = pNC;
								sNC.pParse = pNC.pParse;
								zType = columnTypeImpl(sNC, p);
							}
						}
						else
						{


							if ((iCol) < (0))
							{
								zType = "INTEGER";
							}
							else
							{
								zType = sqlite3ColumnType(&pTab.aCol[iCol], null);
							}
						}

						break;
					}

				case 138:
					{
						NameContext sNC = new NameContext();
						Select pS;
						Expr p;

						pS = pExpr.x.pSelect;
						p = pS.pEList.a[0].pExpr;
						sNC.pSrcList = pS.pSrc;
						sNC.pNext = pNC;
						sNC.pParse = pNC.pParse;
						zType = columnTypeImpl(sNC, p);
						break;
					}
			}

			return zType;
		}
		public static int compare2pow63(sbyte* zNum, int incr)
		{
			int c = (int)(0);
			int i = 0;
			sbyte* pow63 = "922337203685477580";
			for (i = (int)(0); ((c) == (0)) && ((i) < (18)); i++)
			{
				c = (int)((zNum[i * incr] - pow63[i]) * 10);
			}

			if ((c) == (0))
			{
				c = (int)(zNum[18 * incr] - 56);
			}

			return (int)(c);
		}
		public static sbyte comparisonAffinity(Expr pExpr)
		{
			sbyte aff = 0;


			aff = (sbyte)(sqlite3ExprAffinity(pExpr.pLeft));
			if ((pExpr.pRight) != null)
			{
				aff = (sbyte)(sqlite3CompareAffinity(pExpr.pRight, (sbyte)(aff)));
			}
			else if ((((pExpr).flags & 0x000800) != 0))
			{
				aff = (sbyte)(sqlite3CompareAffinity(pExpr.x.pSelect.pEList.a[0].pExpr, (sbyte)(aff)));
			}
			else if ((aff) == (0))
			{
				aff = (sbyte)(0x41);
			}

			return (sbyte)(aff);
		}
		public static void compileoptiongetFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int n = 0;


			n = (int)(sqlite3_value_int(argv[0]));
			sqlite3_result_text(context, sqlite3_compileoption_get((int)(n)), (int)(-1), null);
		}
		public static void compileoptionusedFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* zOptName;


			if ((zOptName = (sbyte*)(sqlite3_value_text(argv[0]))) != null)
			{
				sqlite3_result_int(context, (int)(sqlite3_compileoption_used(zOptName)));
			}
		}
		public static ushort computeCellSize(CellArray p, int N)
		{


			p.szCell[N] = (ushort)(p.pRef.xCellSize(p.pRef, p.apCell[N]));
			return (ushort)(p.szCell[N]);
		}
		public static void computeHMS(DateTime* p)
		{
			int s = 0;
			if ((p->validHMS) != 0)
				return;
			computeJD(p);
			s = ((int)((p->iJD + 43200000) % 86400000));
			p->s = (double)(s / 1000.0);
			s = ((int)(p->s));
			p->s -= (double)(s);
			p->h = (int)(s / 3600);
			s -= (int)(p->h * 3600);
			p->m = (int)(s / 60);
			p->s += (double)(s - p->m * 60);
			p->rawS = (sbyte)(0);
			p->validHMS = (sbyte)(1);
		}
		public static void computeJD(DateTime* p)
		{
			int Y = 0; int M = 0; int D = 0; int A = 0; int B = 0; int X1 = 0; int X2 = 0;
			if ((p->validJD) != 0)
				return;
			if ((p->validYMD) != 0)
			{
				Y = (int)(p->Y);
				M = (int)(p->M);
				D = (int)(p->D);
			}
			else
			{
				Y = (int)(2000);
				M = (int)(1);
				D = (int)(1);
			}

			if ((((Y) < (-4713)) || ((Y) > (9999))) || ((p->rawS) != 0))
			{
				datetimeError(p);
				return;
			}

			if ((M) <= (2))
			{
				Y--;
				M += (int)(12);
			}

			A = (int)(Y / 100);
			B = (int)(2 - A + (A / 4));
			X1 = (int)(36525 * (Y + 4716) / 100);
			X2 = (int)(306001 * (M + 1) / 10000);
			p->iJD = ((long)((X1 + X2 + D + B - 1524.5) * 86400000));
			p->validJD = (sbyte)(1);
			if ((p->validHMS) != 0)
			{
				p->iJD += (long)(p->h * 3600000 + p->m * 60000 + (long)(p->s * 1000));
				if ((p->validTZ) != 0)
				{
					p->iJD -= (long)(p->tz * 60000);
					p->validYMD = (sbyte)(0);
					p->validHMS = (sbyte)(0);
					p->validTZ = (sbyte)(0);
				}
			}
		}
		public static void computeLimitRegisters(Parse pParse, Select p, int iBreak)
		{
			Vdbe v = null;
			int iLimit = (int)(0);
			int iOffset = 0;
			int n = 0;
			Expr pLimit = p.pLimit;
			if ((p.iLimit) != 0)
				return;
			if ((pLimit) != null)
			{


				p.iLimit = (int)(iLimit = (int)(++pParse.nMem));
				v = sqlite3GetVdbe(pParse);

				if ((sqlite3ExprIsInteger(pLimit.pLeft, &n)) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(n), (int)(iLimit));
					if ((n) == (0))
					{
						sqlite3VdbeGoto(v, (int)(iBreak));
					}
					else if (((n) >= (0)) && ((p.nSelectRow) > (sqlite3LogEst((ulong)(n)))))
					{
						p.nSelectRow = (short)(sqlite3LogEst((ulong)(n)));
						p.selFlags |= (uint)(0x0004000);
					}
				}
				else
				{
					sqlite3ExprCode(pParse, pLimit.pLeft, (int)(iLimit));
					sqlite3VdbeAddOp1(v, (int)(15), (int)(iLimit));
					sqlite3VdbeAddOp2(v, (int)(20), (int)(iLimit), (int)(iBreak));
				}

				if ((pLimit.pRight) != null)
				{
					p.iOffset = (int)(iOffset = (int)(++pParse.nMem));
					pParse.nMem++;
					sqlite3ExprCode(pParse, pLimit.pRight, (int)(iOffset));
					sqlite3VdbeAddOp1(v, (int)(15), (int)(iOffset));
					sqlite3VdbeAddOp3(v, (int)(159), (int)(iLimit), (int)(iOffset + 1), (int)(iOffset));
				}
			}
		}
		public static ushort computeNumericType(sqlite3_value pMem)
		{
			int rc = 0;
			long ix = 0;


			if ((((pMem).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pMem) : 0) != 0)
			{
				pMem.u.i = (long)(0);
				return (ushort)(0x0004);
			}

			rc = (int)(sqlite3AtoF(pMem.z, &pMem.u.r, (int)(pMem.n), (byte)(pMem.enc)));
			if ((rc) <= (0))
			{
				if (((rc) == (0)) && ((sqlite3Atoi64(pMem.z, &ix, (int)(pMem.n), (byte)(pMem.enc))) <= (1)))
				{
					pMem.u.i = (long)(ix);
					return (ushort)(0x0004);
				}
				else
				{
					return (ushort)(0x0008);
				}
			}
			else if (((rc) == (1)) && ((sqlite3Atoi64(pMem.z, &ix, (int)(pMem.n), (byte)(pMem.enc))) == (0)))
			{
				pMem.u.i = (long)(ix);
				return (ushort)(0x0004);
			}

			return (ushort)(0x0008);
		}
		public static void computeYMD(DateTime* p)
		{
			int Z = 0; int A = 0; int B = 0; int C = 0; int D = 0; int E = 0; int X1 = 0;
			if ((p->validYMD) != 0)
				return;
			if (p->validJD == 0)
			{
				p->Y = (int)(2000);
				p->M = (int)(1);
				p->D = (int)(1);
			}
			else if (validJulianDay((long)(p->iJD)) == 0)
			{
				datetimeError(p);
				return;
			}
			else
			{
				Z = ((int)((p->iJD + 43200000) / 86400000));
				A = ((int)((Z - 1867216.25) / 36524.25));
				A = (int)(Z + 1 + A - (A / 4));
				B = (int)(A + 1524);
				C = ((int)((B - 122.1) / 365.25));
				D = (int)((36525 * (C & 32767)) / 100);
				E = ((int)((B - D) / 30.6001));
				X1 = ((int)(30.6001 * E));
				p->D = (int)(B - D - X1);
				p->M = (int)((E) < (14) ? E - 1 : E - 13);
				p->Y = (int)((p->M) > (2) ? C - 4716 : C - 4715);
			}

			p->validYMD = (sbyte)(1);
		}
		public static void computeYMD_HMS(DateTime* p)
		{
			computeYMD(p);
			computeHMS(p);
		}
		public static int connectionIsBusy(sqlite3 db)
		{
			int j = 0;

			if ((db.pVdbe) != null)
				return (int)(1);
			for (j = (int)(0); (j) < (db.nDb); j++)
			{
				Btree pBt = db.aDb[j].pBt;
				if (((pBt) != null) && ((sqlite3BtreeIsInBackup(pBt)) != 0))
					return (int)(1);
			}

			return (int)(0);
		}
		public static void constInsert(WhereConst pConst, Expr pColumn, Expr pValue, Expr pExpr)
		{
			int i = 0;


			if ((((pColumn).flags & (0x000008)) != 0))
				return;
			if (sqlite3ExprAffinity(pValue) != 0)
				return;
			if (sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst.pParse, pExpr)) == 0)
			{
				return;
			}

			for (i = (int)(0); (i) < (pConst.nConst); i++)
			{
				Expr pE2 = pConst.apExpr[i * 2];

				if (((pE2.iTable) == (pColumn.iTable)) && ((pE2.iColumn) == (pColumn.iColumn)))
				{
					return;
				}
			}

			if ((sqlite3ExprAffinity(pColumn)) == (0x41))
			{
				pConst.bHasAffBlob = (int)(1);
			}

			pConst.nConst++;
			pConst.apExpr = sqlite3DbReallocOrFree(pConst.pParse.db, pConst.apExpr, (ulong)(pConst.nConst * 2 * sizeof(Expr)));
			if ((pConst.apExpr) == (null))
			{
				pConst.nConst = (int)(0);
			}
			else
			{
				pConst.apExpr[pConst.nConst * 2 - 2] = pColumn;
				pConst.apExpr[pConst.nConst * 2 - 1] = pValue;
			}
		}
		public static void constructAutomaticIndex(Parse pParse, WhereClause pWC, SrcItem pSrc, ulong notReady, WhereLevel pLevel)
		{
			int nKeyCol = 0;
			WhereTerm pTerm;
			WhereTerm pWCEnd;
			Index pIdx;
			Vdbe v;
			int addrInit = 0;
			Table pTable;
			int addrTop = 0;
			int regRecord = 0;
			int n = 0;
			int i = 0;
			int mxBitCol = 0;
			CollSeq pColl;
			WhereLoop pLoop;
			sbyte* zNotUsed;
			ulong idxCols = 0;
			ulong extraCols = 0;
			byte sentWarning = (byte)(0);
			Expr pPartial = null;
			int iContinue = (int)(0);
			SrcItem pTabItem;
			int addrCounter = (int)(0);
			int regBase = 0;
			v = pParse.pVdbe;

			addrInit = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			nKeyCol = (int)(0);
			pTable = pSrc.pTab;
			pWCEnd = pWC.a[pWC.nTerm];
			pLoop = pLevel.pWLoop;
			idxCols = (ulong)(0);
			for (pTerm = pWC.a; (pTerm) < (pWCEnd); pTerm++)
			{
				Expr pExpr = pTerm.pExpr;
				if ((((pTerm.wtFlags & 0x0002) == (0)) && (((pSrc.fg.jointype & 0x0008) == (0)) || (((pExpr).flags & (0x000001)) != 0))) && ((sqlite3ExprIsTableConstant(pExpr, (int)(pSrc.iCursor))) != 0))
				{
					pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse.db, pExpr, (int)(0)));
				}

				if ((termCanDriveIndex(pTerm, pSrc, (ulong)(notReady))) != 0)
				{
					int iCol = 0;
					ulong cMask = 0;

					iCol = (int)(pTerm.u.x.leftColumn);
					cMask = (ulong)((iCol) >= ((int)(sizeof(ulong) * 8)) ? (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1)) : (((ulong)(1)) << (iCol)));
					if (sentWarning == 0)
					{
						sqlite3_log((int)(28 | (1 << 8)), "automatic index on %s(%s)", pTable.zName, pTable.aCol[iCol].zCnName);
						sentWarning = (byte)(1);
					}

					if ((idxCols & cMask) == (0))
					{
						if ((whereLoopResize(pParse.db, pLoop, (int)(nKeyCol + 1))) != 0)
						{
							goto end_auto_index_create;
						}

						pLoop.aLTerm[nKeyCol++] = pTerm;
						idxCols |= (ulong)(cMask);
					}
				}
			}


			pLoop.u.btree.nEq = (ushort)(pLoop.nLTerm = (ushort)(nKeyCol));
			pLoop.wsFlags = (uint)(0x00000001 | 0x00000040 | 0x00000200 | 0x00004000);
			extraCols = (ulong)(pSrc.colUsed & (~idxCols | (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1))));
			mxBitCol = (int)((((int)(sizeof(ulong) * 8)) - 1) < (pTable.nCol) ? (((int)(sizeof(ulong) * 8)) - 1) : (pTable.nCol));
			for (i = (int)(0); (i) < (mxBitCol); i++)
			{
				if ((extraCols & (((ulong)(1)) << (i))) != 0)
					nKeyCol++;
			}

			if ((pSrc.colUsed & (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1))) != 0)
			{
				nKeyCol += (int)(pTable.nCol - ((int)(sizeof(ulong) * 8)) + 1);
			}

			pIdx = sqlite3AllocateIndexObject(pParse.db, (short)(nKeyCol + 1), (int)(0), &zNotUsed);
			if ((pIdx) == (null))
				goto end_auto_index_create;
			pLoop.u.btree.pIndex = pIdx;
			pIdx.zName = "auto-index";
			pIdx.pTable = pTable;
			n = (int)(0);
			idxCols = (ulong)(0);
			for (pTerm = pWC.a; (pTerm) < (pWCEnd); pTerm++)
			{
				if ((termCanDriveIndex(pTerm, pSrc, (ulong)(notReady))) != 0)
				{
					int iCol = 0;
					ulong cMask = 0;

					iCol = (int)(pTerm.u.x.leftColumn);
					cMask = (ulong)((iCol) >= ((int)(sizeof(ulong) * 8)) ? (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1)) : (((ulong)(1)) << (iCol)));
					if ((idxCols & cMask) == (0))
					{
						Expr pX = pTerm.pExpr;
						idxCols |= (ulong)(cMask);
						pIdx.aiColumn[n] = (short)(pTerm.u.x.leftColumn);
						pColl = sqlite3ExprCompareCollSeq(pParse, pX);

						pIdx.azColl[n] = pColl ? pColl.zName : sqlite3StrBINARY;
						n++;
					}
				}
			}


			for (i = (int)(0); (i) < (mxBitCol); i++)
			{
				if ((extraCols & (((ulong)(1)) << (i))) != 0)
				{
					pIdx.aiColumn[n] = (short)(i);
					pIdx.azColl[n] = sqlite3StrBINARY;
					n++;
				}
			}

			if ((pSrc.colUsed & (((ulong)(1)) << (((int)(sizeof(ulong) * 8)) - 1))) != 0)
			{
				for (i = (int)(((int)(sizeof(ulong) * 8)) - 1); (i) < (pTable.nCol); i++)
				{
					pIdx.aiColumn[n] = (short)(i);
					pIdx.azColl[n] = sqlite3StrBINARY;
					n++;
				}
			}


			pIdx.aiColumn[n] = (short)(-1);
			pIdx.azColl[n] = sqlite3StrBINARY;

			pLevel.iIdxCur = (int)(pParse.nTab++);
			sqlite3VdbeAddOp2(v, (int)(115), (int)(pLevel.iIdxCur), (int)(nKeyCol + 1));
			sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
			if ((((pParse.db).dbOptFlags & (0x00080000)) == (0)))
			{
				pLevel.regFilter = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(76), (int)(10000), (int)(pLevel.regFilter));
			}

			pTabItem = pWC.pWInfo.pTabList.a[pLevel.iFrom];
			if ((pTabItem.fg.viaCoroutine) != 0)
			{
				int regYield = (int)(pTabItem.regReturn);
				addrCounter = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(0)));
				sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(pTabItem.addrFillSub));
				addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(regYield)));
			}
			else
			{
				addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(pLevel.iTabCur)));
			}

			if ((pPartial) != null)
			{
				iContinue = (int)(sqlite3VdbeMakeLabel(pParse));
				sqlite3ExprIfFalse(pParse, pPartial, (int)(iContinue), (int)(0x10));
				pLoop.wsFlags |= (uint)(0x00020000);
			}

			regRecord = (int)(sqlite3GetTempReg(pParse));
			regBase = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(pLevel.iTabCur), (int)(regRecord), (int)(0), null, null, (int)(0)));
			if ((pLevel.regFilter) != 0)
			{
				sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(regBase), (int)(pLoop.u.btree.nEq));
			}

			sqlite3VdbeAddOp2(v, (int)(137), (int)(pLevel.iIdxCur), (int)(regRecord));
			sqlite3VdbeChangeP5(v, (ushort)(0x10));
			if ((pPartial) != null)
				sqlite3VdbeResolveLabel(v, (int)(iContinue));
			if ((pTabItem.fg.viaCoroutine) != 0)
			{
				sqlite3VdbeChangeP2(v, (int)(addrCounter), (int)(regBase + n));

				translateColumnToCopy(pParse, (int)(addrTop), (int)(pLevel.iTabCur), (int)(pTabItem.regResult), (int)(pLevel.iIdxCur));
				sqlite3VdbeGoto(v, (int)(addrTop));
				pTabItem.fg.viaCoroutine = (uint)(0);
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(pLevel.iTabCur), (int)(addrTop + 1));
				sqlite3VdbeChangeP5(v, (ushort)(3));
			}

			sqlite3VdbeJumpHere(v, (int)(addrTop));
			sqlite3ReleaseTempReg(pParse, (int)(regRecord));
			sqlite3VdbeJumpHere(v, (int)(addrInit));
		end_auto_index_create:
			; sqlite3ExprDelete(pParse.db, pPartial);
		}
		public static void* contextMalloc(sqlite3_context context, long nByte)
		{
			sbyte* z;
			sqlite3 db = sqlite3_context_db_handle(context);

			if ((nByte) > (db.aLimit[0]))
			{
				sqlite3_result_error_toobig(context);
				z = null;
			}
			else
			{
				z = sqlite3Malloc((ulong)(nByte));
				if (z == null)
				{
					sqlite3_result_error_nomem(context);
				}
			}

			return z;
		}
		public static int convertCompoundSelectToSubquery(Walker pWalker, Select p)
		{
			int i = 0;
			Select pNew;
			Select pX;
			sqlite3 db;
			ExprList_item* a;
			SrcList pNewSrc;
			Parse pParse;
			Token dummy = new Token();
			if ((p.pPrior) == (null))
				return (int)(0);
			if ((p.pOrderBy) == (null))
				return (int)(0);
			for (pX = p; ((pX) != null) && (((pX.op) == (135)) || ((pX.op) == (138))); pX = pX.pPrior)
			{
			}

			if ((pX) == (null))
				return (int)(0);
			a = p.pOrderBy.a;
			if ((a[0].u.x.iOrderByCol) != 0)
				return (int)(0);
			for (i = (int)(p.pOrderBy.nExpr - 1); (i) >= (0); i--)
			{
				if ((a[i].pExpr.flags & 0x000100) != 0)
					break;
			}

			if ((i) < (0))
				return (int)(0);
			pParse = pWalker.pParse;
			db = pParse.db;
			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Select)));
			if ((pNew) == (null))
				return (int)(2);
			CRuntime.memset(&dummy, (int)(0), (ulong)(sizeof(Token)));
			pNewSrc = sqlite3SrcListAppendFromTerm(pParse, null, null, null, &dummy, pNew, null, null);
			if ((pNewSrc) == (null))
				return (int)(2);
			pNew = (Select)(p);
			p.pSrc = pNewSrc;
			p.pEList = sqlite3ExprListAppend(pParse, null, sqlite3Expr(db, (int)(180), null));
			p.op = (byte)(138);
			p.pWhere = null;
			pNew.pGroupBy = null;
			pNew.pHaving = null;
			pNew.pOrderBy = null;
			p.pPrior = null;
			p.pNext = null;
			p.pWith = null;
			p.pWinDefn = null;
			p.selFlags &= (uint)(~0x0000100);

			p.selFlags |= (uint)(0x0010000);

			pNew.pPrior.pNext = pNew;
			pNew.pLimit = null;
			return (int)(0);
		}
		public static void convertToWithoutRowidTable(Parse pParse, Table pTab)
		{
			Index pIdx;
			Index pPk;
			int nPk = 0;
			int nExtra = 0;
			int i = 0; int j = 0;
			sqlite3 db = pParse.db;
			Vdbe v = pParse.pVdbe;
			if (db.init.imposterTable == 0)
			{
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					if (((pTab.aCol[i].colFlags & 0x0001) != 0) && ((pTab.aCol[i].notNull) == (0)))
					{
						pTab.aCol[i].notNull = (uint)(2);
					}
				}

				pTab.tabFlags |= (uint)(0x00000800);
			}


			if ((pParse.u1.addrCrTab) != 0)
			{

				sqlite3VdbeChangeP3(v, (int)(pParse.u1.addrCrTab), (int)(2));
			}

			if ((pTab.iPKey) >= (0))
			{
				ExprList pList;
				Token ipkToken = new Token();
				sqlite3TokenInit(&ipkToken, pTab.aCol[pTab.iPKey].zCnName);
				pList = sqlite3ExprListAppend(pParse, null, sqlite3ExprAlloc(db, (int)(59), &ipkToken, (int)(0)));
				if ((pList) == (null))
				{
					pTab.tabFlags &= (uint)(~0x00000080);
					return;
				}

				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenRemap(pParse, pList.a[0].pExpr, &pTab.iPKey);
				}

				pList.a[0].sortFlags = (byte)(pParse.iPkSortOrder);

				pTab.iPKey = (short)(-1);
				sqlite3CreateIndex(pParse, null, null, null, pList, (int)(pTab.keyConf), null, null, (int)(0), (int)(0), (byte)(2));
				if ((pParse.nErr) != 0)
				{
					pTab.tabFlags &= (uint)(~0x00000080);
					return;
				}


				pPk = sqlite3PrimaryKeyIndex(pTab);

			}
			else
			{
				pPk = sqlite3PrimaryKeyIndex(pTab);

				for (i = (int)(j = (int)(1)); (i) < (pPk.nKeyCol); i++)
				{
					if ((isDupColumn(pPk, (int)(j), pPk, (int)(i))) != 0)
					{
						pPk.nColumn--;
					}
					else
					{
						pPk.azColl[j] = pPk.azColl[i];
						pPk.aSortOrder[j] = (byte)(pPk.aSortOrder[i]);
						pPk.aiColumn[j++] = (short)(pPk.aiColumn[i]);
					}
				}

				pPk.nKeyCol = (ushort)(j);
			}


			pPk.isCovering = (uint)(1);
			if (db.init.imposterTable == 0)
				pPk.uniqNotNull = (uint)(1);
			nPk = (int)(pPk.nColumn = (ushort)(pPk.nKeyCol));
			if (((v) != null) && ((pPk.tnum) > (0)))
			{

				sqlite3VdbeChangeOpcode(v, (int)(pPk.tnum), (byte)(11));
			}

			pPk.tnum = (uint)(pTab.tnum);
			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				int n = 0;
				if ((((pIdx).idxType) == (2)))
					continue;
				for (i = (int)(n = (int)(0)); (i) < (nPk); i++)
				{
					if (isDupColumn(pIdx, (int)(pIdx.nKeyCol), pPk, (int)(i)) == 0)
					{
						n++;
					}
				}

				if ((n) == (0))
				{
					pIdx.nColumn = (ushort)(pIdx.nKeyCol);
					continue;
				}

				if ((resizeIndexObject(db, pIdx, (int)(pIdx.nKeyCol + n))) != 0)
					return;
				for (i = (int)(0), j = (int)(pIdx.nKeyCol); (i) < (nPk); i++)
				{
					if (isDupColumn(pIdx, (int)(pIdx.nKeyCol), pPk, (int)(i)) == 0)
					{
						pIdx.aiColumn[j] = (short)(pPk.aiColumn[i]);
						pIdx.azColl[j] = pPk.azColl[i];
						if ((pPk.aSortOrder[i]) != 0)
						{
							pIdx.bAscKeyBug = (uint)(1);
						}

						j++;
					}
				}



			}

			nExtra = (int)(0);
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((hasColumn(pPk.aiColumn, (int)(nPk), (int)(i)) == 0) && ((pTab.aCol[i].colFlags & 0x0020) == (0)))
					nExtra++;
			}

			if ((resizeIndexObject(db, pPk, (int)(nPk + nExtra))) != 0)
				return;
			for (i = (int)(0), j = (int)(nPk); (i) < (pTab.nCol); i++)
			{
				if ((hasColumn(pPk.aiColumn, (int)(j), (int)(i)) == 0) && ((pTab.aCol[i].colFlags & 0x0020) == (0)))
				{

					pPk.aiColumn[j] = (short)(i);
					pPk.azColl[j] = sqlite3StrBINARY;
					j++;
				}
			}



			recomputeColumnsNotIndexed(pPk);
		}
		public static void copyNodeContent(MemPage pFrom, MemPage pTo, int* pRC)
		{
			if ((*pRC) == (0))
			{
				BtShared pBt = pFrom.pBt;
				byte* aFrom = pFrom.aData;
				byte* aTo = pTo.aData;
				int iFromHdr = (int)(pFrom.hdrOffset);
				int iToHdr = (int)(((pTo.pgno) == (1)) ? 100 : 0);
				int rc = 0;
				int iData = 0;



				iData = (int)((&aFrom[iFromHdr + 5])[0] << 8 | (&aFrom[iFromHdr + 5])[1]);
				CRuntime.memcpy(&aTo[iData], &aFrom[iData], (ulong)(pBt.usableSize - iData));
				CRuntime.memcpy(&aTo[iToHdr], &aFrom[iFromHdr], (ulong)(pFrom.cellOffset + 2 * pFrom.nCell));
				pTo.isInit = (byte)(0);
				rc = (int)(btreeInitPage(pTo));
				if ((rc) == (0))
					rc = (int)(btreeComputeFreeSpace(pTo));
				if (rc != 0)
				{
					*pRC = (int)(rc);
					return;
				}

				if ((pBt.autoVacuum) != 0)
				{
					*pRC = (int)(setChildPtrmaps(pTo));
				}
			}
		}
		public static int copyPayload(void* pPayload, void* pBuf, int nByte, int eOp, PgHdr pDbPage)
		{
			if ((eOp) != 0)
			{
				int rc = (int)(sqlite3PagerWrite(pDbPage));
				if (rc != 0)
				{
					return (int)(rc);
				}

				CRuntime.memcpy(pPayload, pBuf, (ulong)(nByte));
			}
			else
			{
				CRuntime.memcpy(pBuf, pPayload, (ulong)(nByte));
			}

			return (int)(0);
		}
		public static void corruptSchema(InitData pData, sbyte** azObj, sbyte* zExtra)
		{
			sqlite3 db = pData.db;
			if ((db.mallocFailed) != 0)
			{
				pData.rc = (int)(7);
			}
			else if (pData.pzErrMsg[0] != null)
			{
			}
			else if ((pData.mInitFlags & (0x0003)) != 0)
			{
				*pData.pzErrMsg = sqlite3MPrintf(db, "error in %s %s after %s: %s", azObj[0], azObj[1], corruptSchema_azAlterType[(pData.mInitFlags & 0x0003) - 1], zExtra);
				pData.rc = (int)(1);
			}
			else if ((db.flags & 0x00000001) != 0)
			{
				pData.rc = (int)(sqlite3CorruptError((int)(133208)));
			}
			else
			{
				sbyte* z;
				sbyte* zObj = (azObj[1]) != 0 ? azObj[1] : "?";
				z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
				if (((zExtra) != null) && ((zExtra[0]) != 0))
					z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
				*pData.pzErrMsg = z;
				pData.rc = (int)(sqlite3CorruptError((int)(133215)));
			}
		}
		public static void countFinalize(sqlite3_context context)
		{
			CountCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			sqlite3_result_int64(context, (long)(p ? p->n : 0));
		}
		public static void countInverse(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			CountCtx* p;
			p = sqlite3_aggregate_context(ctx, (int)(sizeof(CountCtx)));
			if ((((argc) == (0)) || (5 != sqlite3_value_type(argv[0]))) && ((p) != null))
			{
				p->n--;
			}
		}
		public static uint countLookasideSlots(LookasideSlot* p)
		{
			uint cnt = (uint)(0);
			while ((p) != null)
			{
				p = p->pNext;
				cnt++;
			}

			return (uint)(cnt);
		}
		public static void countStep(sqlite3_context context, int argc, sqlite3_value argv)
		{
			CountCtx* p;
			p = sqlite3_aggregate_context(context, (int)(sizeof(CountCtx)));
			if ((((argc) == (0)) || (5 != sqlite3_value_type(argv[0]))) && ((p) != null))
			{
				p->n++;
			}


		}
		public static void* createAggContext(sqlite3_context p, int nByte)
		{
			sqlite3_value pMem = p.pMem;

			if ((nByte) <= (0))
			{
				sqlite3VdbeMemSetNull(pMem);
				pMem.z = null;
			}
			else
			{
				sqlite3VdbeMemClearAndResize(pMem, (int)(nByte));
				pMem.flags = (ushort)(0x2000);
				pMem.u.pDef = p.pFunc;
				if ((pMem.z) != null)
				{
					CRuntime.memset(pMem.z, (int)(0), (ulong)(nByte));
				}
			}

			return (void*)(pMem.z);
		}
		public static int createCollation(sqlite3 db, sbyte* zName, byte enc, void* pCtx, delegate69 xCompare, delegate17 xDel)
		{
			CollSeq pColl;
			int enc2 = 0;

			enc2 = (int)(enc);
			if (((enc2) == (4)) || ((enc2) == (8)))
			{
				enc2 = (int)(2);
			}

			if (((enc2) < (1)) || ((enc2) > (3)))
			{
				return (int)(sqlite3MisuseError((int)(171189)));
			}

			pColl = sqlite3FindCollSeq(db, (byte)(enc2), zName, (int)(0));
			if (((pColl) != null) && ((pColl.xCmp) != null))
			{
				if ((db.nVdbeActive) != 0)
				{
					sqlite3ErrorWithMsg(db, (int)(5), "unable to delete/modify collation sequence due to active statements");
					return (int)(5);
				}

				sqlite3ExpirePreparedStatements(db, (int)(0));
				if ((pColl.enc & ~8) == (enc2))
				{
					CollSeq aColl = sqlite3HashFind(&db.aCollSeq, zName);
					int j = 0;
					for (j = (int)(0); (j) < (3); j++)
					{
						CollSeq p = aColl[j];
						if ((p.enc) == (pColl.enc))
						{
							if ((p.xDel) != null)
							{
								p.xDel(p.pUser);
							}

							p.xCmp = null;
						}
					}
				}
			}

			pColl = sqlite3FindCollSeq(db, (byte)(enc2), zName, (int)(1));
			if ((pColl) == (null))
				return (int)(7);
			pColl.xCmp = xCompare;
			pColl.pUser = pCtx;
			pColl.xDel = xDel;
			pColl.enc = ((byte)(enc2 | (enc & 8)));
			sqlite3Error(db, (int)(0));
			return (int)(0);
		}
		public static int createFunctionApi(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate67 xSFunc, delegate67 xStep, delegate68 xFinal, delegate68 xValue, delegate67 xInverse, delegate17 xDestroy)
		{
			int rc = (int)(1);
			FuncDestructor pArg = null;
			sqlite3_mutex_enter(db.mutex);
			if ((xDestroy) != null)
			{
				pArg = (FuncDestructor)(sqlite3Malloc((ulong)(sizeof(FuncDestructor))));
				if (pArg == null)
				{
					sqlite3OomFault(db);
					xDestroy(p);
					goto  out
            ;
				}

				pArg.nRef = (int)(0);
				pArg.xDestroy = xDestroy;
				pArg.pUserData = p;
			}

			rc = (int)(sqlite3CreateFunc(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, xValue, xInverse, pArg));
			if (((pArg) != null) && ((pArg.nRef) == (0)))
			{

				xDestroy(p);
				sqlite3_free(pArg);
			}

     out :  ; rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static void createMask(WhereMaskSet* pMaskSet, int iCursor)
		{

			pMaskSet->ix[pMaskSet->n++] = (int)(iCursor);
		}
		public static int createModule(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
		{
			int rc = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			(void)(sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			if ((rc != 0) && ((xDestroy) != null))
				xDestroy(pAux);
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static sbyte* createTableStmt(sqlite3 db, Table p)
		{
			int i = 0; int k = 0; int n = 0;
			sbyte* zStmt;
			sbyte* zSep; sbyte* zSep2; sbyte* zEnd;
			Column* pCol;
			n = (int)(0);
			for (pCol = p.aCol, i = (int)(0); (i) < (p.nCol); i++, pCol++)
			{
				n += (int)(identLength(pCol->zCnName) + 5);
			}

			n += (int)(identLength(p.zName));
			if ((n) < (50))
			{
				zSep = "";
				zSep2 = ",";
				zEnd = ")";
			}
			else
			{
				zSep = "\n  ";
				zSep2 = ",\n  ";
				zEnd = "\n)";
			}

			n += (int)(35 + 6 * p.nCol);
			zStmt = sqlite3DbMallocRaw(null, (ulong)(n));
			if ((zStmt) == (null))
			{
				sqlite3OomFault(db);
				return null;
			}

			sqlite3_snprintf((int)(n), zStmt, "CREATE TABLE ");
			k = (int)(sqlite3Strlen30(zStmt));
			identPut(zStmt, &k, p.zName);
			zStmt[k++] = (sbyte)(40);
			for (pCol = p.aCol, i = (int)(0); (i) < (p.nCol); i++, pCol++)
			{
				int len = 0;
				sbyte* zType;
				sqlite3_snprintf((int)(n - k), &zStmt[k], zSep);
				k += (int)(sqlite3Strlen30(&zStmt[k]));
				zSep = zSep2;
				identPut(zStmt, &k, pCol->zCnName);


				zType = createTableStmt_azType[pCol->affinity - 0x41];
				len = (int)(sqlite3Strlen30(zType));

				CRuntime.memcpy(&zStmt[k], zType, (ulong)(len));
				k += (int)(len);

			}

			sqlite3_snprintf((int)(n - k), &zStmt[k], "%s", zEnd);
			return zStmt;
		}
		public static void cteClear(sqlite3 db, Cte pCte)
		{

			sqlite3ExprListDelete(db, pCte.pCols);
			sqlite3SelectDelete(db, pCte.pSelect);
			sqlite3DbFree(db, pCte.zName);
		}
		public static void ctimeFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			timeFunc(context, (int)(0), null);
		}
		public static void ctimestampFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			datetimeFunc(context, (int)(0), null);
		}
		public static void cume_distInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			(void)(nArg);

			(void)(apArg);
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			p->nStep++;
		}
		public static void cume_distStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			(void)(nArg);

			(void)(apArg);
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nTotal++;
			}
		}
		public static void cume_distValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(0)));
			if ((p) != null)
			{
				double r = (double)((double)(p->nStep) / (double)(p->nTotal));
				sqlite3_result_double(pCtx, (double)(r));
			}
		}
		public static int databaseIsUnmoved(Pager pPager)
		{
			int bHasMoved = (int)(0);
			int rc = 0;
			if ((pPager.tempFile) != 0)
				return (int)(0);
			if ((pPager.dbSize) == (0))
				return (int)(0);

			rc = (int)(sqlite3OsFileControl(pPager.fd, (int)(20), &bHasMoved));
			if ((rc) == (12))
			{
				rc = (int)(0);
			}
			else if (((rc) == (0)) && ((bHasMoved) != 0))
			{
				rc = (int)(8 | (4 << 8));
			}

			return (int)(rc);
		}
		public static sbyte* databaseName(sbyte* zName)
		{
			while ((((zName[-1] != 0) || (zName[-2] != 0)) || (zName[-3] != 0)) || (zName[-4] != 0))
			{
				zName--;
			}

			return zName;
		}
		public static void dateFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				int Y = 0;
				sbyte* zBuf = stackalloc sbyte[16];
				computeYMD(&x);
				Y = (int)(x.Y);
				if ((Y) < (0))
					Y = (int)(-Y);
				zBuf[1] = (sbyte)(48 + (Y / 1000) % 10);
				zBuf[2] = (sbyte)(48 + (Y / 100) % 10);
				zBuf[3] = (sbyte)(48 + (Y / 10) % 10);
				zBuf[4] = (sbyte)(48 + (Y) % 10);
				zBuf[5] = (sbyte)(45);
				zBuf[6] = (sbyte)(48 + (x.M / 10) % 10);
				zBuf[7] = (sbyte)(48 + (x.M) % 10);
				zBuf[8] = (sbyte)(45);
				zBuf[9] = (sbyte)(48 + (x.D / 10) % 10);
				zBuf[10] = (sbyte)(48 + (x.D) % 10);
				zBuf[11] = (sbyte)(0);
				if ((x.Y) < (0))
				{
					zBuf[0] = (sbyte)(45);
					sqlite3_result_text(context, zBuf, (int)(11), ((Void(Void * ))(-1)));
				}
				else
				{
					sqlite3_result_text(context, &zBuf[1], (int)(10), ((Void(Void * ))(-1)));
				}
			}
		}
		public static void datetimeError(DateTime* p)
		{
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
			p->isError = (sbyte)(1);
		}
		public static void datetimeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				int Y = 0;
				int s = 0;
				sbyte* zBuf = stackalloc sbyte[24];
				computeYMD_HMS(&x);
				Y = (int)(x.Y);
				if ((Y) < (0))
					Y = (int)(-Y);
				zBuf[1] = (sbyte)(48 + (Y / 1000) % 10);
				zBuf[2] = (sbyte)(48 + (Y / 100) % 10);
				zBuf[3] = (sbyte)(48 + (Y / 10) % 10);
				zBuf[4] = (sbyte)(48 + (Y) % 10);
				zBuf[5] = (sbyte)(45);
				zBuf[6] = (sbyte)(48 + (x.M / 10) % 10);
				zBuf[7] = (sbyte)(48 + (x.M) % 10);
				zBuf[8] = (sbyte)(45);
				zBuf[9] = (sbyte)(48 + (x.D / 10) % 10);
				zBuf[10] = (sbyte)(48 + (x.D) % 10);
				zBuf[11] = (sbyte)(32);
				zBuf[12] = (sbyte)(48 + (x.h / 10) % 10);
				zBuf[13] = (sbyte)(48 + (x.h) % 10);
				zBuf[14] = (sbyte)(58);
				zBuf[15] = (sbyte)(48 + (x.m / 10) % 10);
				zBuf[16] = (sbyte)(48 + (x.m) % 10);
				zBuf[17] = (sbyte)(58);
				s = ((int)(x.s));
				zBuf[18] = (sbyte)(48 + (s / 10) % 10);
				zBuf[19] = (sbyte)(48 + (s) % 10);
				zBuf[20] = (sbyte)(0);
				if ((x.Y) < (0))
				{
					zBuf[0] = (sbyte)(45);
					sqlite3_result_text(context, zBuf, (int)(20), ((Void(Void * ))(-1)));
				}
				else
				{
					sqlite3_result_text(context, &zBuf[1], (int)(19), ((Void(Void * ))(-1)));
				}
			}
		}
		public static void* dbMallocRawFinish(sqlite3 db, ulong n)
		{
			void* p;

			p = sqlite3Malloc((ulong)(n));
			if (p == null)
				sqlite3OomFault(db);
			return p;
		}
		public static void* dbReallocFinish(sqlite3 db, void* p, ulong n)
		{
			void* pNew = null;


			if ((db.mallocFailed) == (0))
			{
				if ((isLookaside(db, p)) != 0)
				{
					pNew = sqlite3DbMallocRawNN(db, (ulong)(n));
					if ((pNew) != null)
					{
						CRuntime.memcpy(pNew, p, (ulong)(lookasideMallocSize(db, p)));
						sqlite3DbFree(db, p);
					}
				}
				else
				{


					pNew = sqlite3Realloc(p, (ulong)(n));
					if (pNew == null)
					{
						sqlite3OomFault(db);
					}
				}
			}

			return pNew;
		}
		public static int decodeFlags(MemPage pPage, int flagByte)
		{
			BtShared pBt;


			pPage.leaf = ((byte)(flagByte >> 3));

			flagByte &= (int)(~0x08);
			pPage.childPtrSize = (byte)(4 - 4 * pPage.leaf);
			pPage.xCellSize = cellSizePtr;
			pBt = pPage.pBt;
			if ((flagByte) == (0x04 | 0x01))
			{


				pPage.intKey = (byte)(1);
				if ((pPage.leaf) != 0)
				{
					pPage.intKeyLeaf = (byte)(1);
					pPage.xParseCell = btreeParseCellPtr;
				}
				else
				{
					pPage.intKeyLeaf = (byte)(0);
					pPage.xCellSize = cellSizePtrNoPayload;
					pPage.xParseCell = btreeParseCellPtrNoPayload;
				}

				pPage.maxLocal = (ushort)(pBt.maxLeaf);
				pPage.minLocal = (ushort)(pBt.minLeaf);
			}
			else if ((flagByte) == (0x02))
			{


				pPage.intKey = (byte)(0);
				pPage.intKeyLeaf = (byte)(0);
				pPage.xParseCell = btreeParseCellPtrIndex;
				pPage.maxLocal = (ushort)(pBt.maxLocal);
				pPage.minLocal = (ushort)(pBt.minLocal);
			}
			else
			{
				return (int)(sqlite3CorruptError((int)(68054)));
			}

			pPage.max1bytePayload = (byte)(pBt.max1bytePayload);
			return (int)(0);
		}
		public static void decodeIntArray(sbyte* zIntArray, int nOut, uint* aOut, short* aLog, Index pIndex)
		{
			sbyte* z = zIntArray;
			int c = 0;
			int i = 0;
			uint v = 0;

			for (i = (int)(0); ((*z) != 0) && ((i) < (nOut)); i++)
			{
				v = (uint)(0);
				while (((c = (int)(z[0])) >= (48)) && ((c) <= (57)))
				{
					v = (uint)(v * 10 + c - 48);
					z++;
				}


				(void)(aOut);

				aLog[i] = (short)(sqlite3LogEst((ulong)(v)));
				if ((*z) == (32))
					z++;
			}


			{
				pIndex.bUnordered = (uint)(0);
				pIndex.noSkipScan = (uint)(0);
				while ((z[0]) != 0)
				{
					if ((sqlite3_strglob("unordered*", z)) == (0))
					{
						pIndex.bUnordered = (uint)(1);
					}
					else if ((sqlite3_strglob("sz=[0-9]*", z)) == (0))
					{
						int sz = (int)(sqlite3Atoi(z + 3));
						if ((sz) < (2))
							sz = (int)(2);
						pIndex.szIdxRow = (short)(sqlite3LogEst((ulong)(sz)));
					}
					else if ((sqlite3_strglob("noskipscan*", z)) == (0))
					{
						pIndex.noSkipScan = (uint)(1);
					}

					while ((z[0] != 0) && (z[0] != 32))
					{
						z++;
					}

					while ((z[0]) == (32))
					{
						z++;
					}
				}
			}
		}
		public static int defragmentPage(MemPage pPage, int nMaxFrag)
		{
			int i = 0;
			int pc = 0;
			int hdr = 0;
			int size = 0;
			int usableSize = 0;
			int cellOffset = 0;
			int cbrk = 0;
			int nCell = 0;
			byte* data;
			byte* temp;
			byte* src;
			int iCellFirst = 0;
			int iCellLast = 0;
			int iCellStart = 0;





			temp = null;
			src = data = pPage.aData;
			hdr = (int)(pPage.hdrOffset);
			cellOffset = (int)(pPage.cellOffset);
			nCell = (int)(pPage.nCell);

			iCellFirst = (int)(cellOffset + 2 * nCell);
			usableSize = (int)(pPage.pBt.usableSize);
			if (((int)(data[hdr + 7])) <= (nMaxFrag))
			{
				int iFree = (int)((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);
				if ((iFree) > (usableSize - 4))
					return (int)(sqlite3CorruptError((int)(67641)));
				if ((iFree) != 0)
				{
					int iFree2 = (int)((&data[iFree])[0] << 8 | (&data[iFree])[1]);
					if ((iFree2) > (usableSize - 4))
						return (int)(sqlite3CorruptError((int)(67644)));
					if (((0) == (iFree2)) || (((data[iFree2]) == (0)) && ((data[iFree2 + 1]) == (0))))
					{
						byte* pEnd = &data[cellOffset + nCell * 2];
						byte* pAddr;
						int sz2 = (int)(0);
						int sz = (int)((&data[iFree + 2])[0] << 8 | (&data[iFree + 2])[1]);
						int top = (int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
						if ((top) >= (iFree))
						{
							return (int)(sqlite3CorruptError((int)(67652)));
						}

						if ((iFree2) != 0)
						{
							if ((iFree + sz) > (iFree2))
								return (int)(sqlite3CorruptError((int)(67655)));
							sz2 = (int)((&data[iFree2 + 2])[0] << 8 | (&data[iFree2 + 2])[1]);
							if ((iFree2 + sz2) > (usableSize))
								return (int)(sqlite3CorruptError((int)(67657)));
							CRuntime.memmove(&data[iFree + sz + sz2], &data[iFree + sz], (ulong)(iFree2 - (iFree + sz)));
							sz += (int)(sz2);
						}
						else if (((iFree + sz) > (usableSize)))
						{
							return (int)(sqlite3CorruptError((int)(67661)));
						}

						cbrk = (int)(top + sz);

						CRuntime.memmove(&data[cbrk], &data[top], (ulong)(iFree - top));
						for (pAddr = &data[cellOffset]; (pAddr) < (pEnd); pAddr += 2)
						{
							pc = (int)((pAddr)[0] << 8 | (pAddr)[1]);
							if ((pc) < (iFree))
							{
								((pAddr)[0] = ((byte)((pc + sz) >> 8)), (pAddr)[1] = ((byte)(pc + sz)));
							}
							else if ((pc) < (iFree2))
							{
								((pAddr)[0] = ((byte)((pc + sz2) >> 8)), (pAddr)[1] = ((byte)(pc + sz2)));
							}
						}

						goto defragment_out;
					}
				}
			}

			cbrk = (int)(usableSize);
			iCellLast = (int)(usableSize - 4);
			iCellStart = (int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
			for (i = (int)(0); (i) < (nCell); i++)
			{
				byte* pAddr;
				pAddr = &data[cellOffset + i * 2];
				pc = (int)((pAddr)[0] << 8 | (pAddr)[1]);
				if (((pc) < (iCellStart)) || ((pc) > (iCellLast)))
				{
					return (int)(sqlite3CorruptError((int)(67690)));
				}


				size = (int)(pPage.xCellSize(pPage, &src[pc]));
				cbrk -= (int)(size);
				if (((cbrk) < (iCellStart)) || ((pc + size) > (usableSize)))
				{
					return (int)(sqlite3CorruptError((int)(67696)));
				}


				((pAddr)[0] = ((byte)((cbrk) >> 8)), (pAddr)[1] = ((byte)(cbrk)));
				if ((temp) == (null))
				{
					if ((cbrk) == (pc))
						continue;
					temp = sqlite3PagerTempSpace(pPage.pBt.pPager);
					CRuntime.memcpy(&temp[iCellStart], &data[iCellStart], (ulong)(usableSize - iCellStart));
					src = temp;
				}

				CRuntime.memcpy(&data[cbrk], &src[pc], (ulong)(size));
			}

			data[hdr + 7] = (byte)(0);
		defragment_out:
			; ((void)(0));
			if (data[hdr + 7] + cbrk - iCellFirst != pPage.nFree)
			{
				return (int)(sqlite3CorruptError((int)(67715)));
			}


			((&data[hdr + 5])[0] = ((byte)((cbrk) >> 8)), (&data[hdr + 5])[1] = ((byte)(cbrk)));
			data[hdr + 1] = (byte)(0);
			data[hdr + 2] = (byte)(0);
			CRuntime.memset(&data[iCellFirst], (int)(0), (ulong)(cbrk - iCellFirst));

			return (int)(0);
		}
		public static void deleteTable(sqlite3 db, Table pTable)
		{
			Index pIndex; Index pNext;
			for (pIndex = pTable.pIndex; pIndex; pIndex = pNext)
			{
				pNext = pIndex.pNext;

				if ((((db) == (null)) || ((db.pnBytesFreed) == (null))) && (!(((pTable).eTabType) == (1))))
				{
					sbyte* zName = pIndex.zName;
					sqlite3HashInsert(&pIndex.pSchema.idxHash, zName, null);


				}

				sqlite3FreeIndex(db, pIndex);
			}

			if ((((pTable).eTabType) == (0)))
			{
				sqlite3FkDelete(db, pTable);
			}
			else if ((((pTable).eTabType) == (1)))
			{
				sqlite3VtabClear(db, pTable);
			}
			else
			{

				sqlite3SelectDelete(db, pTable.u.view.pSelect);
			}

			sqlite3DeleteColumnNames(db, pTable);
			sqlite3DbFree(db, pTable.zName);
			sqlite3DbFree(db, pTable.zColAff);
			sqlite3ExprListDelete(db, pTable.pCheck);
			sqlite3DbFree(db, pTable);

		}
		public static void dense_rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
				p->nStep = (long)(1);
			(void)(nArg);
			(void)(apArg);
		}
		public static void dense_rankValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				if ((p->nStep) != 0)
				{
					p->nValue++;
					p->nStep = (long)(0);
				}

				sqlite3_result_int64(pCtx, (long)(p->nValue));
			}
		}
		public static void destroyRootPage(Parse pParse, int iTable, int iDb)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			int r1 = (int)(sqlite3GetTempReg(pParse));
			if ((iTable) < (2))
				sqlite3ErrorMsg(pParse, "corrupt schema");
			sqlite3VdbeAddOp3(v, (int)(143), (int)(iTable), (int)(r1), (int)(iDb));
			sqlite3MayAbort(pParse);
			sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET rootpage=%d WHERE #%d AND rootpage=#%d", pParse.db.aDb[iDb].zDbSName, (int)(iTable), (int)(r1), (int)(r1));
			sqlite3ReleaseTempReg(pParse, (int)(r1));
		}
		public static void destroyTable(Parse pParse, Table pTab)
		{
			uint iTab = (uint)(pTab.tnum);
			uint iDestroyed = (uint)(0);
			while ((1) != 0)
			{
				Index pIdx;
				uint iLargest = (uint)(0);
				if (((iDestroyed) == (0)) || ((iTab) < (iDestroyed)))
				{
					iLargest = (uint)(iTab);
				}

				for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
				{
					uint iIdx = (uint)(pIdx.tnum);

					if ((((iDestroyed) == (0)) || ((iIdx) < (iDestroyed))) && ((iIdx) > (iLargest)))
					{
						iLargest = (uint)(iIdx);
					}
				}

				if ((iLargest) == (0))
				{
					return;
				}
				else
				{
					int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));

					destroyRootPage(pParse, (int)(iLargest), (int)(iDb));
					iDestroyed = (uint)(iLargest);
				}
			}
		}
		public static void detachFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sbyte* zName = (sbyte*)(sqlite3_value_text(argv[0]));
			sqlite3 db = sqlite3_context_db_handle(context);
			int i = 0;
			Db pDb = null;
			HashElem* pEntry;
			sbyte* zErr = stackalloc sbyte[128];
			(void)(NotUsed);
			if ((zName) == (null))
				zName = "";
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				pDb = db.aDb[i];
				if ((pDb.pBt) == (null))
					continue;
				if ((sqlite3DbIsNamed(db, (int)(i), zName)) != 0)
					break;
			}

			if ((i) >= (db.nDb))
			{
				sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "no such database: %s", zName);
				goto detach_error;
			}

			if ((i) < (2))
			{
				sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "cannot detach database %s", zName);
				goto detach_error;
			}

			if ((sqlite3BtreeTxnState(pDb.pBt) != 0) || ((sqlite3BtreeIsInBackup(pDb.pBt)) != 0))
			{
				sqlite3_snprintf((int)(128 * sizeof(sbyte)), zErr, "database %s is locked", zName);
				goto detach_error;
			}


			pEntry = ((&db.aDb[1].pSchema.trigHash)->first);
			while ((pEntry) != null)
			{
				Trigger pTrig = (Trigger)((pEntry)->data);
				if ((pTrig.pTabSchema) == (pDb.pSchema))
				{
					pTrig.pTabSchema = pTrig.pSchema;
				}

				pEntry = ((pEntry)->next);
			}

			sqlite3BtreeClose(pDb.pBt);
			pDb.pBt = null;
			pDb.pSchema = null;
			sqlite3CollapseDatabaseArray(db);
			return;
		detach_error:
			; sqlite3_result_error(context, zErr, (int)(-1));
		}
		public static void disableLookaside(Parse pParse)
		{
			sqlite3 db = pParse.db;
			pParse.disableLookaside++;
			db.lookaside.bDisable++;
			db.lookaside.sz = (ushort)(0);
		}
		public static void disableTerm(WhereLevel pLevel, WhereTerm pTerm)
		{
			int nLoop = (int)(0);

			while ((((pTerm.wtFlags & 0x0004) == (0)) && (((pLevel.iLeftJoin) == (0)) || (((pTerm.pExpr).flags & (0x000001)) != 0))) && ((pLevel.notReady & pTerm.prereqAll) == (0)))
			{
				if (((nLoop) != 0) && ((pTerm.wtFlags & 0x0400) != 0))
				{
					pTerm.wtFlags |= (ushort)(0x0200);
				}
				else
				{
					pTerm.wtFlags |= (ushort)(0x0004);
				}

				if ((pTerm.iParent) < (0))
					break;
				pTerm = pTerm.pWC.a[pTerm.iParent];

				pTerm.nChild--;
				if (pTerm.nChild != 0)
					break;
				nLoop++;
			}
		}
		public static int disallowAggregatesInOrderByCb(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (168)) && ((pExpr.pAggInfo) == (null)))
			{

				sqlite3ErrorMsg(pWalker.pParse, "misuse of aggregate: %s()", pExpr.u.zToken);
			}

			return (int)(0);
		}
		public static void disconnectAllVtab(sqlite3 db)
		{
			int i = 0;
			HashElem* p;
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Schema pSchema = db.aDb[i].pSchema;
				if ((pSchema) != null)
				{
					for (p = ((&pSchema.tblHash)->first); p; p = ((p)->next))
					{
						Table pTab = (Table)((p)->data);
						if ((((pTab).eTabType) == (1)))
							sqlite3VtabDisconnect(db, pTab);
					}
				}
			}

			for (p = ((&db.aModule)->first); p; p = ((p)->next))
			{
				Module pMod = (Module)((p)->data);
				if ((pMod.pEpoTab) != null)
				{
					sqlite3VtabDisconnect(db, pMod.pEpoTab);
				}
			}

			sqlite3VtabUnlockList(db);
			sqlite3BtreeLeaveAll(db);
		}
		public static long doubleToInt64(double r)
		{
			if ((r) <= ((double)(doubleToInt64_minInt)))
			{
				return (long)(doubleToInt64_minInt);
			}
			else if ((r) >= ((double)(doubleToInt64_maxInt)))
			{
				return (long)(doubleToInt64_maxInt);
			}
			else
			{
				return (long)(r);
			}
		}
		public static int doWalCallbacks(sqlite3 db)
		{
			int rc = (int)(0);
			int i = 0;
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if ((pBt) != null)
				{
					int nEntry = 0;
					sqlite3BtreeEnter(pBt);
					nEntry = (int)(sqlite3PagerWalCallback(sqlite3BtreePager(pBt)));
					sqlite3BtreeLeave(pBt);
					if ((((nEntry) > (0)) && ((db.xWalCallback) != null)) && ((rc) == (0)))
					{
						rc = (int)(db.xWalCallback(db.pWalArg, db, db.aDb[i].zDbSName, (int)(nEntry)));
					}
				}
			}

			return (int)(rc);
		}
		public static void downgradeAllSharedCacheTableLocks(Btree p)
		{
			BtShared pBt = p.pBt;
			if ((pBt.pWriter) == (p))
			{
				BtLock pLock;
				pBt.pWriter = null;
				pBt.btsFlags &= (ushort)(~(0x0040 | 0x0080));
				for (pLock = pBt.pLock; pLock; pLock = pLock.pNext)
				{

					pLock.eLock = (byte)(1);
				}
			}
		}
		public static void dropCell(MemPage pPage, int idx, int sz, int* pRC)
		{
			uint pc = 0;
			byte* data;
			byte* ptr;
			int rc = 0;
			int hdr = 0;
			if ((*pRC) != 0)
				return;






			data = pPage.aData;
			ptr = &pPage.aCellIdx[2 * idx];

			pc = (uint)((ptr)[0] << 8 | (ptr)[1]);
			hdr = (int)(pPage.hdrOffset);
			if ((pc + sz) > (pPage.pBt.usableSize))
			{
				*pRC = (int)(sqlite3CorruptError((int)(73013)));
				return;
			}

			rc = (int)(freeSpace(pPage, (ushort)(pc), (ushort)(sz)));
			if ((rc) != 0)
			{
				*pRC = (int)(rc);
				return;
			}

			pPage.nCell--;
			if ((pPage.nCell) == (0))
			{
				CRuntime.memset(&data[hdr + 1], (int)(0), (ulong)(4));
				data[hdr + 7] = (byte)(0);
				((&data[hdr + 5])[0] = ((byte)((pPage.pBt.usableSize) >> 8)), (&data[hdr + 5])[1] = ((byte)(pPage.pBt.usableSize)));
				pPage.nFree = (int)(pPage.pBt.usableSize - pPage.hdrOffset - pPage.childPtrSize - 8);
			}
			else
			{
				CRuntime.memmove(ptr, ptr + 2, (ulong)(2 * (pPage.nCell - idx)));
				((&data[hdr + 3])[0] = ((byte)((pPage.nCell) >> 8)), (&data[hdr + 3])[1] = ((byte)(pPage.nCell)));
				pPage.nFree += (int)(2);
			}
		}
		public static void dropColumnFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			int iSchema = (int)(sqlite3_value_int(argv[0]));
			sbyte* zSql = (sbyte*)(sqlite3_value_text(argv[1]));
			int iCol = (int)(sqlite3_value_int(argv[2]));
			sbyte* zDb = db.aDb[iSchema].zDbSName;
			int rc = 0;
			Parse sParse = new Parse();
			RenameToken* pCol;
			Table pTab;
			sbyte* zEnd;
			sbyte* zNew = null;
			delegate66 xAuth = db.xAuth;
			db.xAuth = null;
			(void)(NotUsed);
			rc = (int)(renameParseSql(sParse, zDb, db, zSql, ((iSchema) == (1) ? 1 : 0)));
			if (rc != 0)
				goto drop_column_done;
			pTab = sParse.pNewTable;
			if ((((pTab) == (null)) || ((pTab.nCol) == (1))) || ((iCol) >= (pTab.nCol)))
			{
				rc = (int)(sqlite3CorruptError((int)(110899)));
				goto drop_column_done;
			}

			pCol = renameTokenFind(sParse, null, (void*)(pTab.aCol[iCol].zCnName));
			if ((iCol) < (pTab.nCol - 1))
			{
				RenameToken* pEnd;
				pEnd = renameTokenFind(sParse, null, (void*)(pTab.aCol[iCol + 1].zCnName));
				zEnd = pEnd->t.z;
			}
			else
			{

				zEnd = &zSql[pTab.u.tab.addColOffset];
				while ((pCol->t.z[0] != 0) && (pCol->t.z[0] != 44))
				{
					pCol->t.z--;
				}
			}

			zNew = sqlite3MPrintf(db, "%.*s%s", (long)(pCol->t.z - zSql), zSql, zEnd);
			sqlite3_result_text(context, zNew, (int)(-1), ((Void(Void * ))(-1)));
			sqlite3_free(zNew);
		drop_column_done:
			; renameParseCleanup(sParse);
			db.xAuth = xAuth;
			if (rc != 0)
			{
				sqlite3_result_error_code(context, (int)(rc));
			}
		}
		public static int dupedExprNodeSize(Expr p, int flags)
		{
			int nByte = (int)(dupedExprStructSize(p, (int)(flags)) & 0xfff);
			if ((!(((p).flags & (0x000400)) != 0)) && ((p.u.zToken) != null))
			{
				nByte += (int)((CRuntime.strlen(p.u.zToken) & 0x3fffffff) + 1);
			}

			return (int)(((nByte) + 7) & ~7);
		}
		public static int dupedExprSize(Expr p, int flags)
		{
			int nByte = (int)(0);
			if ((p) != null)
			{
				nByte = (int)(dupedExprNodeSize(p, (int)(flags)));
				if ((flags & 0x0001) != 0)
				{
					nByte += (int)(dupedExprSize(p.pLeft, (int)(flags)) + dupedExprSize(p.pRight, (int)(flags)));
				}
			}

			return (int)(nByte);
		}
		public static int dupedExprStructSize(Expr p, int flags)
		{
			int nSize = 0;



			if ((((0) == (flags)) || ((p.op) == (178))) || (((p).flags & (0x1000000)) != 0))
			{
				nSize = (int)(sizeof(Expr));
			}
			else
			{




				if (((p.pLeft) != null) || ((p.x.pList) != null))
				{
					nSize = (int)(((ulong)(&((0).iTable))) | 0x002000);
				}
				else
				{

					nSize = (int)(((ulong)((0).pLeft)) | 0x004000);
				}
			}

			return (int)(nSize);
		}
		public static int editPage(MemPage pPg, int iOld, int iNew, int nNew, CellArray pCArray)
		{
			byte* aData = pPg.aData;
			int hdr = (int)(pPg.hdrOffset);
			byte* pBegin = &pPg.aCellIdx[nNew * 2];
			int nCell = (int)(pPg.nCell);
			byte* pData;
			byte* pCellptr;
			int i = 0;
			int iOldEnd = (int)(iOld + pPg.nCell + pPg.nOverflow);
			int iNewEnd = (int)(iNew + nNew);

			if ((iOld) < (iNew))
			{
				int nShift = (int)(pageFreeArray(pPg, (int)(iOld), (int)(iNew - iOld), pCArray));
				if (((nShift) > (nCell)))
					return (int)(sqlite3CorruptError((int)(73521)));
				CRuntime.memmove(pPg.aCellIdx, &pPg.aCellIdx[nShift * 2], (ulong)(nCell * 2));
				nCell -= (int)(nShift);
			}

			if ((iNewEnd) < (iOldEnd))
			{
				int nTail = (int)(pageFreeArray(pPg, (int)(iNewEnd), (int)(iOldEnd - iNewEnd), pCArray));

				nCell -= (int)(nTail);
			}

			pData = &aData[(((((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1]) - 1) & 0xffff) + 1)];
			if ((pData) < (pBegin))
				goto editpage_fail;
			if ((pData) > (pPg.aDataEnd))
				goto editpage_fail;
			if ((iNew) < (iOld))
			{
				int nAdd = (int)((nNew) < (iOld - iNew) ? (nNew) : (iOld - iNew));


				pCellptr = pPg.aCellIdx;
				CRuntime.memmove(&pCellptr[nAdd * 2], pCellptr, (ulong)(nCell * 2));
				if ((pageInsertArray(pPg, pBegin, &pData, pCellptr, (int)(iNew), (int)(nAdd), pCArray)) != 0)
					goto editpage_fail;
				nCell += (int)(nAdd);
			}

			for (i = (int)(0); (i) < (pPg.nOverflow); i++)
			{
				int iCell = (int)((iOld + pPg.aiOvfl[i]) - iNew);
				if (((iCell) >= (0)) && ((iCell) < (nNew)))
				{
					pCellptr = &pPg.aCellIdx[iCell * 2];
					if ((nCell) > (iCell))
					{
						CRuntime.memmove(&pCellptr[2], pCellptr, (ulong)((nCell - iCell) * 2));
					}

					nCell++;
					cachedCellSize(pCArray, (int)(iCell + iNew));
					if ((pageInsertArray(pPg, pBegin, &pData, pCellptr, (int)(iCell + iNew), (int)(1), pCArray)) != 0)
						goto editpage_fail;
				}
			}


			pCellptr = &pPg.aCellIdx[nCell * 2];
			if ((pageInsertArray(pPg, pBegin, &pData, pCellptr, (int)(iNew + nCell), (int)(nNew - nCell), pCArray)) != 0)
				goto editpage_fail;
			pPg.nCell = (ushort)(nNew);
			pPg.nOverflow = (byte)(0);
			((&aData[hdr + 3])[0] = ((byte)((pPg.nCell) >> 8)), (&aData[hdr + 3])[1] = ((byte)(pPg.nCell)));
			((&aData[hdr + 5])[0] = ((byte)((pData - aData) >> 8)), (&aData[hdr + 5])[1] = ((byte)(pData - aData)));
			return (int)(0);
		editpage_fail:
			; populateCellCache(pCArray, (int)(iNew), (int)(nNew));
			return (int)(rebuildPage(pCArray, (int)(iNew), (int)(nNew), pPg));
		}
		public static void enlargeAndAppend(sqlite3_str p, sbyte* z, int N)
		{
			N = (int)(sqlite3StrAccumEnlarge(p, (int)(N)));
			if ((N) > (0))
			{
				CRuntime.memcpy(&p.zText[p.nChar], z, (ulong)(N));
				p.nChar += (uint)(N);
			}
		}
		public static void errlogFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{

			(void)(context);
			sqlite3_log((int)(sqlite3_value_int(argv[0])), "%s", sqlite3_value_text(argv[1]));
		}
		public static void estimateIndexWidth(Index pIdx)
		{
			uint wIndex = (uint)(0);
			int i = 0;
			Column* aCol = pIdx.pTable.aCol;
			for (i = (int)(0); (i) < (pIdx.nColumn); i++)
			{
				short x = (short)(pIdx.aiColumn[i]);

				wIndex += (uint)((x) < (0) ? 1 : aCol[pIdx.aiColumn[i]].szEst);
			}

			pIdx.szIdxRow = (short)(sqlite3LogEst((ulong)(wIndex * 4)));
		}
		public static void estimateTableWidth(Table pTab)
		{
			uint wTable = (uint)(0);
			Column* pTabCol;
			int i = 0;
			for (i = (int)(pTab.nCol), pTabCol = pTab.aCol; (i) > (0); i--, pTabCol++)
			{
				wTable += (uint)(pTabCol->szEst);
			}

			if ((pTab.iPKey) < (0))
				wTable++;
			pTab.szTabRow = (short)(sqlite3LogEst((ulong)(wTable * 4)));
		}
		public static short estLog(short N)
		{
			return (short)((N) <= (10) ? 0 : sqlite3LogEst((ulong)(N)) - 33);
		}
		public static sbyte et_getdigit(long double* val, int* cnt)
		{
			int digit = 0;
			long  double d = new long  double();
			if ((*cnt) <= (0))
				return (sbyte)(48);
			(*cnt)--;
			digit = ((int)(*val));
			d = (long  double ) (digit);
			digit += (int)(48);
			*val = (long  double ) ((*val - d) * 10.0);
			return (sbyte)(digit);
		}
		public static int execSql(sqlite3 db, sbyte** pzErrMsg, sbyte* zSql)
		{
			sqlite3_stmt* pStmt;
			int rc = 0;
			rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, null));
			if (rc != 0)
				return (int)(rc);
			while ((100) == (rc = (int)(sqlite3_step(pStmt))))
			{
				sbyte* zSubSql = (sbyte*)(sqlite3_column_text(pStmt, (int)(0)));

				if (((zSubSql) != null) && (((CRuntime.strncmp(zSubSql, "CRE", (ulong)(3))) == (0)) || ((CRuntime.strncmp(zSubSql, "INS", (ulong)(3))) == (0))))
				{
					rc = (int)(execSql(db, pzErrMsg, zSubSql));
					if (rc != 0)
						break;
				}
			}


			if ((rc) == (101))
				rc = (int)(0);
			if ((rc) != 0)
			{
				sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
			}

			(void)(sqlite3_finalize(pStmt));
			return (int)(rc);
		}
		public static int execSqlF(sqlite3 db, sbyte** pzErrMsg, sbyte* zSql)
		{
			sbyte* z;
			sbyte* ap;
			int rc = 0;
			(__va_start(&ap, zSql));
			z = sqlite3VMPrintf(db, zSql, ap);
			((void)(ap = null));
			if ((z) == (null))
				return (int)(7);
			rc = (int)(execSql(db, pzErrMsg, z));
			sqlite3DbFree(db, z);
			return (int)(rc);
		}
		public static void explainAppendTerm(sqlite3_str pStr, Index pIdx, int nTerm, int iTerm, int bAnd, sbyte* zOp)
		{
			int i = 0;

			if ((bAnd) != 0)
				sqlite3_str_append(pStr, " AND ", (int)(5));
			if ((nTerm) > (1))
				sqlite3_str_append(pStr, "(", (int)(1));
			for (i = (int)(0); (i) < (nTerm); i++)
			{
				if ((i) != 0)
					sqlite3_str_append(pStr, ",", (int)(1));
				sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, (int)(iTerm + i)));
			}

			if ((nTerm) > (1))
				sqlite3_str_append(pStr, ")", (int)(1));
			sqlite3_str_append(pStr, zOp, (int)(1));
			if ((nTerm) > (1))
				sqlite3_str_append(pStr, "(", (int)(1));
			for (i = (int)(0); (i) < (nTerm); i++)
			{
				if ((i) != 0)
					sqlite3_str_append(pStr, ",", (int)(1));
				sqlite3_str_append(pStr, "?", (int)(1));
			}

			if ((nTerm) > (1))
				sqlite3_str_append(pStr, ")", (int)(1));
		}
		public static sbyte* explainIndexColumnName(Index pIdx, int i)
		{
			i = (int)(pIdx.aiColumn[i]);
			if ((i) == (-2))
				return "<expr>";
			if ((i) == (-1))
				return "rowid";
			return pIdx.pTable.aCol[i].zCnName;
		}
		public static void explainIndexRange(sqlite3_str pStr, WhereLoop pLoop)
		{
			Index pIndex = pLoop.u.btree.pIndex;
			ushort nEq = (ushort)(pLoop.u.btree.nEq);
			ushort nSkip = (ushort)(pLoop.nSkip);
			int i = 0; int j = 0;
			if (((nEq) == (0)) && ((pLoop.wsFlags & (0x00000020 | 0x00000010)) == (0)))
				return;
			sqlite3_str_append(pStr, " (", (int)(2));
			for (i = (int)(0); (i) < (nEq); i++)
			{
				sbyte* z = explainIndexColumnName(pIndex, (int)(i));
				if ((i) != 0)
					sqlite3_str_append(pStr, " AND ", (int)(5));
				sqlite3_str_appendf(pStr, (i) >= (nSkip) ? "%s=?" : "ANY(%s)", z);
			}

			j = (int)(i);
			if ((pLoop.wsFlags & 0x00000020) != 0)
			{
				explainAppendTerm(pStr, pIndex, (int)(pLoop.u.btree.nBtm), (int)(j), (int)(i), ">");
				i = (int)(1);
			}

			if ((pLoop.wsFlags & 0x00000010) != 0)
			{
				explainAppendTerm(pStr, pIndex, (int)(pLoop.u.btree.nTop), (int)(j), (int)(i), "<");
			}

			sqlite3_str_append(pStr, ")", (int)(1));
		}
		public static void explainSimpleCount(Parse pParse, Table pTab, Index pIdx)
		{
			if ((pParse.explain) == (2))
			{
				int bCover = (int)(((pIdx != null) && ((((pTab).tabFlags & 0x00000080) == (0)) || (!(((pIdx).idxType) == (2))))) ? 1 : 0);
				sqlite3VdbeExplain(pParse, (byte)(0), "SCAN %s%s%s", pTab.zName, (bCover) != 0 ? " USING COVERING INDEX " : "", (bCover) != 0 ? pIdx.zName : "");
			}
		}
		public static void explainTempTable(Parse pParse, sbyte* zUsage)
		{
			sqlite3VdbeExplain(pParse, (byte)(0), "USE TEMP B-TREE FOR %s", zUsage);
		}
		public static void exprAnalyze(SrcList pSrc, WhereClause pWC, int idxTerm)
		{
			WhereInfo pWInfo = pWC.pWInfo;
			WhereTerm pTerm;
			WhereMaskSet* pMaskSet;
			Expr pExpr;
			ulong prereqLeft = 0;
			ulong prereqAll = 0;
			ulong extraRight = (ulong)(0);
			Expr pStr1 = null;
			int isComplete = (int)(0);
			int noCase = (int)(0);
			int op = 0;
			Parse pParse = pWInfo.pParse;
			sqlite3 db = pParse.db;
			byte eOp2 = (byte)(0);
			int nLeft = 0;
			if ((db.mallocFailed) != 0)
			{
				return;
			}


			pTerm = pWC.a[idxTerm];
			pMaskSet = &pWInfo.sMaskSet;
			pExpr = pTerm.pExpr;


			pMaskSet->bVarSelect = (int)(0);
			prereqLeft = (ulong)(sqlite3WhereExprUsage(pMaskSet, pExpr.pLeft));
			op = (int)(pExpr.op);
			if ((op) == (49))
			{

				if ((sqlite3ExprCheckIN(pParse, pExpr)) != 0)
					return;
				if ((((pExpr).flags & 0x000800) != 0))
				{
					pTerm.prereqRight = (ulong)(exprSelectUsage(pMaskSet, pExpr.x.pSelect));
				}
				else
				{
					pTerm.prereqRight = (ulong)(sqlite3WhereExprListUsage(pMaskSet, pExpr.x.pList));
				}

				prereqAll = (ulong)(prereqLeft | pTerm.prereqRight);
			}
			else
			{
				pTerm.prereqRight = (ulong)(sqlite3WhereExprUsage(pMaskSet, pExpr.pRight));
				if ((((pExpr.pLeft) == (null)) || (((pExpr).flags & (0x000800 | 0x020000)) != 0)) || (pExpr.x.pList != null))
				{
					prereqAll = (ulong)(sqlite3WhereExprUsageNN(pMaskSet, pExpr));
				}
				else
				{
					prereqAll = (ulong)(prereqLeft | pTerm.prereqRight);
				}
			}

			if ((pMaskSet->bVarSelect) != 0)
				pTerm.wtFlags |= (ushort)(0x1000);
			if ((((pExpr).flags & (0x000001)) != 0))
			{
				ulong x = (ulong)(sqlite3WhereGetMask(pMaskSet, (int)(pExpr.w.iRightJoinTable)));
				prereqAll |= (ulong)(x);
				extraRight = (ulong)(x - 1);
				if ((prereqAll >> 1) >= (x))
				{
					sqlite3ErrorMsg(pParse, "ON clause references tables to its right");
					return;
				}
			}

			pTerm.prereqAll = (ulong)(prereqAll);
			pTerm.leftCursor = (int)(-1);
			pTerm.iParent = (int)(-1);
			pTerm.eOperator = (ushort)(0);
			if ((allowedOp((int)(op))) != 0)
			{
				int* aiCurCol = stackalloc int[2];
				Expr pLeft = sqlite3ExprSkipCollate(pExpr.pLeft);
				Expr pRight = sqlite3ExprSkipCollate(pExpr.pRight);
				ushort opMask = (ushort)((pTerm.prereqRight & prereqLeft) == (0) ? 0x1fff : 0x0800);
				if ((pTerm.u.x.iField) > (0))
				{



					pLeft = pLeft.x.pList.a[pTerm.u.x.iField - 1].pExpr;
				}

				if ((exprMightBeIndexed(pSrc, (ulong)(prereqLeft), aiCurCol, pLeft, (int)(op))) != 0)
				{
					pTerm.leftCursor = (int)(aiCurCol[0]);

					pTerm.u.x.leftColumn = (int)(aiCurCol[1]);
					pTerm.eOperator = (ushort)(operatorMask((int)(op)) & opMask);
				}

				if ((op) == (45))
					pTerm.wtFlags |= (ushort)(0x0800);
				if ((((pRight) != null) && ((exprMightBeIndexed(pSrc, (ulong)(pTerm.prereqRight), aiCurCol, pRight, (int)(op))) != 0)) && (!(((pRight).flags & (0x000008)) != 0)))
				{
					WhereTerm pNew;
					Expr pDup;
					ushort eExtraOp = (ushort)(0);

					if ((pTerm.leftCursor) >= (0))
					{
						int idxNew = 0;
						pDup = sqlite3ExprDup(db, pExpr, (int)(0));
						if ((db.mallocFailed) != 0)
						{
							sqlite3ExprDelete(db, pDup);
							return;
						}

						idxNew = (int)(whereClauseInsert(pWC, pDup, (ushort)(0x0002 | 0x0001)));
						if ((idxNew) == (0))
							return;
						pNew = pWC.a[idxNew];
						markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
						if ((op) == (45))
							pNew.wtFlags |= (ushort)(0x0800);
						pTerm = pWC.a[idxTerm];
						pTerm.wtFlags |= (ushort)(0x0008);
						if ((termIsEquivalence(pParse, pDup)) != 0)
						{
							pTerm.eOperator |= (ushort)(0x0800);
							eExtraOp = (ushort)(0x0800);
						}
					}
					else
					{
						pDup = pExpr;
						pNew = pTerm;
					}

					pNew.wtFlags |= (ushort)(exprCommute(pParse, pDup));
					pNew.leftCursor = (int)(aiCurCol[0]);

					pNew.u.x.leftColumn = (int)(aiCurCol[1]);
					pNew.prereqRight = (ulong)(prereqLeft | extraRight);
					pNew.prereqAll = (ulong)(prereqAll);
					pNew.eOperator = (ushort)((operatorMask((int)(pDup.op)) + eExtraOp) & opMask);
				}
				else if ((((op) == (50)) && (!(((pExpr).flags & (0x000001)) != 0))) && ((0) == (sqlite3ExprCanBeNull(pLeft))))
				{

					pExpr.op = (byte)(170);
					pExpr.u.zToken = "false";
					(pExpr).flags |= (uint)(0x20000000);
					pTerm.prereqAll = (ulong)(0);
					pTerm.eOperator = (ushort)(0);
				}
			}
			else if (((pExpr.op) == (48)) && ((pWC.op) == (44)))
			{
				ExprList pList;
				int i = 0;

				pList = pExpr.x.pList;


				for (i = (int)(0); (i) < (2); i++)
				{
					Expr pNewExpr;
					int idxNew = 0;
					pNewExpr = sqlite3PExpr(pParse, (int)(exprAnalyze_ops[i]), sqlite3ExprDup(db, pExpr.pLeft, (int)(0)), sqlite3ExprDup(db, pList.a[i].pExpr, (int)(0)));
					transferJoinMarkings(pNewExpr, pExpr);
					idxNew = (int)(whereClauseInsert(pWC, pNewExpr, (ushort)(0x0002 | 0x0001)));
					exprAnalyze(pSrc, pWC, (int)(idxNew));
					pTerm = pWC.a[idxTerm];
					markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
				}
			}
			else if ((pExpr.op) == (43))
			{

				exprAnalyzeOrTerm(pSrc, pWC, (int)(idxTerm));
				pTerm = pWC.a[idxTerm];
			}
			else if ((pExpr.op) == (51))
			{
				if ((((pExpr.pLeft.op) == (167)) && ((pExpr.pLeft.iColumn) >= (0))) && (!(((pExpr).flags & (0x000001)) != 0)))
				{
					Expr pNewExpr;
					Expr pLeft = pExpr.pLeft;
					int idxNew = 0;
					WhereTerm pNewTerm;
					pNewExpr = sqlite3PExpr(pParse, (int)(54), sqlite3ExprDup(db, pLeft, (int)(0)), sqlite3ExprAlloc(db, (int)(121), null, (int)(0)));
					idxNew = (int)(whereClauseInsert(pWC, pNewExpr, (ushort)(0x0002 | 0x0001 | 0x0080)));
					if ((idxNew) != 0)
					{
						pNewTerm = pWC.a[idxNew];
						pNewTerm.prereqRight = (ulong)(0);
						pNewTerm.leftCursor = (int)(pLeft.iTable);
						pNewTerm.u.x.leftColumn = (int)(pLeft.iColumn);
						pNewTerm.eOperator = (ushort)(0x0002 << (54 - 53));
						markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
						pTerm = pWC.a[idxTerm];
						pTerm.wtFlags |= (ushort)(0x0008);
						pNewTerm.prereqAll = (ulong)(pTerm.prereqAll);
					}
				}
			}
			else if ((((pExpr.op) == (172)) && ((pWC.op) == (44))) && ((isLikeOrGlob(pParse, pExpr, pStr1, &isComplete, &noCase)) != 0))
			{
				Expr pLeft;
				Expr pStr2;
				Expr pNewExpr1;
				Expr pNewExpr2;
				int idxNew1 = 0;
				int idxNew2 = 0;
				sbyte* zCollSeqName;
				ushort wtFlags = (ushort)(0x0100 | 0x0002 | 0x0001);

				pLeft = pExpr.x.pList.a[1].pExpr;
				pStr2 = sqlite3ExprDup(db, pStr1, (int)(0));


				if (((noCase) != 0) && (pParse.db.mallocFailed == 0))
				{
					int i = 0;
					sbyte c = 0;
					pTerm.wtFlags |= (ushort)(0x0400);
					for (i = (int)(0); (c = (sbyte)(pStr1.u.zToken[i])) != 0; i++)
					{
						pStr1.u.zToken[i] = (sbyte)((c) & ~(sqlite3CtypeMap[(byte)(c)] & 0x20));
						pStr2.u.zToken[i] = (sbyte)(sqlite3UpperToLower[(byte)(c)]);
					}
				}

				if (db.mallocFailed == 0)
				{
					byte c = 0;
					byte* pC;
					pC = (byte*)(&pStr2.u.zToken[sqlite3Strlen30(pStr2.u.zToken) - 1]);
					c = (byte)(*pC);
					if ((noCase) != 0)
					{
						if ((c) == (65 - 1))
							isComplete = (int)(0);
						c = (byte)(sqlite3UpperToLower[c]);
					}

					*pC = (byte)(c + 1);
				}

				zCollSeqName = (noCase) != 0 ? "NOCASE" : sqlite3StrBINARY;
				pNewExpr1 = sqlite3ExprDup(db, pLeft, (int)(0));
				pNewExpr1 = sqlite3PExpr(pParse, (int)(57), sqlite3ExprAddCollateString(pParse, pNewExpr1, zCollSeqName), pStr1);
				transferJoinMarkings(pNewExpr1, pExpr);
				idxNew1 = (int)(whereClauseInsert(pWC, pNewExpr1, (ushort)(wtFlags)));
				exprAnalyze(pSrc, pWC, (int)(idxNew1));
				pNewExpr2 = sqlite3ExprDup(db, pLeft, (int)(0));
				pNewExpr2 = sqlite3PExpr(pParse, (int)(56), sqlite3ExprAddCollateString(pParse, pNewExpr2, zCollSeqName), pStr2);
				transferJoinMarkings(pNewExpr2, pExpr);
				idxNew2 = (int)(whereClauseInsert(pWC, pNewExpr2, (ushort)(wtFlags)));
				exprAnalyze(pSrc, pWC, (int)(idxNew2));
				pTerm = pWC.a[idxTerm];
				if ((isComplete) != 0)
				{
					markTermAsChild(pWC, (int)(idxNew1), (int)(idxTerm));
					markTermAsChild(pWC, (int)(idxNew2), (int)(idxTerm));
				}
			}

			if (((((((pExpr.op) == (53)) || ((pExpr.op) == (45))) && ((nLeft = (int)(sqlite3ExprVectorSize(pExpr.pLeft))) > (1))) && ((sqlite3ExprVectorSize(pExpr.pRight)) == (nLeft))) && (((pExpr.pLeft.flags & 0x000800) == (0)) || ((pExpr.pRight.flags & 0x000800) == (0)))) && ((pWC.op) == (44)))
			{
				int i = 0;
				for (i = (int)(0); (i) < (nLeft); i++)
				{
					int idxNew = 0;
					Expr pNew;
					Expr pLeft = sqlite3ExprForVectorField(pParse, pExpr.pLeft, (int)(i), (int)(nLeft));
					Expr pRight = sqlite3ExprForVectorField(pParse, pExpr.pRight, (int)(i), (int)(nLeft));
					pNew = sqlite3PExpr(pParse, (int)(pExpr.op), pLeft, pRight);
					transferJoinMarkings(pNew, pExpr);
					idxNew = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0001 | 0x8000)));
					exprAnalyze(pSrc, pWC, (int)(idxNew));
				}

				pTerm = pWC.a[idxTerm];
				pTerm.wtFlags |= (ushort)(0x0004 | 0x0002);
				pTerm.eOperator = (ushort)(0);
			}
			else if ((((((((pExpr.op) == (49)) && ((pTerm.u.x.iField) == (0))) && ((pExpr.pLeft.op) == (177))) && ((((pExpr).flags & 0x000800) != 0) != 0)) && ((pExpr.x.pSelect.pPrior) == (null))) && ((pExpr.x.pSelect.pWin) == (null))) && ((pWC.op) == (44)))
			{
				int i = 0;
				for (i = (int)(0); (i) < (sqlite3ExprVectorSize(pExpr.pLeft)); i++)
				{
					int idxNew = 0;
					idxNew = (int)(whereClauseInsert(pWC, pExpr, (ushort)(0x0002 | 0x8000)));
					pWC.a[idxNew].u.x.iField = (int)(i + 1);
					exprAnalyze(pSrc, pWC, (int)(idxNew));
					markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
				}
			}
			else if ((pWC.op) == (44))
			{
				Expr pRight = null;
				Expr pLeft = null;
				int res = (int)(isAuxiliaryVtabOperator(db, pExpr, &eOp2, pLeft, pRight));
				while ((res--) > (0))
				{
					int idxNew = 0;
					WhereTerm pNewTerm;
					ulong prereqColumn = 0;
					ulong prereqExpr = 0;
					prereqExpr = (ulong)(sqlite3WhereExprUsage(pMaskSet, pRight));
					prereqColumn = (ulong)(sqlite3WhereExprUsage(pMaskSet, pLeft));
					if ((prereqExpr & prereqColumn) == (0))
					{
						Expr pNewExpr;
						pNewExpr = sqlite3PExpr(pParse, (int)(46), null, sqlite3ExprDup(db, pRight, (int)(0)));
						if ((((pExpr).flags & (0x000001)) != 0) && ((pNewExpr) != null))
						{
							(pNewExpr).flags |= (uint)(0x000001);
							pNewExpr.w.iRightJoinTable = (int)(pExpr.w.iRightJoinTable);
						}

						idxNew = (int)(whereClauseInsert(pWC, pNewExpr, (ushort)(0x0002 | 0x0001)));
						pNewTerm = pWC.a[idxNew];
						pNewTerm.prereqRight = (ulong)(prereqExpr);
						pNewTerm.leftCursor = (int)(pLeft.iTable);
						pNewTerm.u.x.leftColumn = (int)(pLeft.iColumn);
						pNewTerm.eOperator = (ushort)(0x0040);
						pNewTerm.eMatchOp = (byte)(eOp2);
						markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
						pTerm = pWC.a[idxTerm];
						pTerm.wtFlags |= (ushort)(0x0008);
						pNewTerm.prereqAll = (ulong)(pTerm.prereqAll);
					}

					{
						Expr t = pLeft;
						pLeft = pRight;
						pRight = t;
					}
				}
			}

			pTerm = pWC.a[idxTerm];
			pTerm.prereqRight |= (ulong)(extraRight);
		}
		public static void exprAnalyzeOrTerm(SrcList pSrc, WhereClause pWC, int idxTerm)
		{
			WhereInfo pWInfo = pWC.pWInfo;
			Parse pParse = pWInfo.pParse;
			sqlite3 db = pParse.db;
			WhereTerm pTerm = pWC.a[idxTerm];
			Expr pExpr = pTerm.pExpr;
			int i = 0;
			WhereClause pOrWc;
			WhereTerm pOrTerm;
			WhereOrInfo pOrInfo;
			ulong chngToIN = 0;
			ulong indexable = 0;


			pTerm.u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, (ulong)(sizeof(WhereOrInfo)));
			if ((pOrInfo) == (null))
				return;
			pTerm.wtFlags |= (ushort)(0x0010);
			pOrWc = pOrInfo.wc;
			CRuntime.memset(pOrWc.aStatic, (int)(0), (ulong)(8 * sizeof(WhereTerm)));
			sqlite3WhereClauseInit(pOrWc, pWInfo);
			sqlite3WhereSplit(pOrWc, pExpr, (byte)(43));
			sqlite3WhereExprAnalyze(pSrc, pOrWc);
			if ((db.mallocFailed) != 0)
				return;

			indexable = (ulong)(~(ulong)(0));
			chngToIN = (ulong)(~(ulong)(0));
			for (i = (int)(pOrWc.nTerm - 1), pOrTerm = pOrWc.a; ((i) >= (0)) && ((indexable) != 0); i--, pOrTerm++)
			{
				if ((pOrTerm.eOperator & 0x01ff) == (0))
				{
					WhereAndInfo pAndInfo;

					chngToIN = (ulong)(0);
					pAndInfo = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereAndInfo)));
					if ((pAndInfo) != null)
					{
						WhereClause pAndWC;
						WhereTerm pAndTerm;
						int j = 0;
						ulong b = (ulong)(0);
						pOrTerm.u.pAndInfo = pAndInfo;
						pOrTerm.wtFlags |= (ushort)(0x0020);
						pOrTerm.eOperator = (ushort)(0x0400);
						pOrTerm.leftCursor = (int)(-1);
						pAndWC = pAndInfo.wc;
						CRuntime.memset(pAndWC.aStatic, (int)(0), (ulong)(8 * sizeof(WhereTerm)));
						sqlite3WhereClauseInit(pAndWC, pWC.pWInfo);
						sqlite3WhereSplit(pAndWC, pOrTerm.pExpr, (byte)(44));
						sqlite3WhereExprAnalyze(pSrc, pAndWC);
						pAndWC.pOuter = pWC;
						if (db.mallocFailed == 0)
						{
							for (j = (int)(0), pAndTerm = pAndWC.a; (j) < (pAndWC.nTerm); j++, pAndTerm++)
							{

								if (((allowedOp((int)(pAndTerm.pExpr.op))) != 0) || ((pAndTerm.eOperator) == (0x0040)))
								{
									b |= (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(pAndTerm.leftCursor)));
								}
							}
						}

						indexable &= (ulong)(b);
					}
				}
				else if ((pOrTerm.wtFlags & 0x0008) != 0)
				{
				}
				else
				{
					ulong b = 0;
					b = (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(pOrTerm.leftCursor)));
					if ((pOrTerm.wtFlags & 0x0002) != 0)
					{
						WhereTerm pOther = pOrWc.a[pOrTerm.iParent];
						b |= (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(pOther.leftCursor)));
					}

					indexable &= (ulong)(b);
					if ((pOrTerm.eOperator & 0x0002) == (0))
					{
						chngToIN = (ulong)(0);
					}
					else
					{
						chngToIN &= (ulong)(b);
					}
				}
			}

			pOrInfo.indexable = (ulong)(indexable);
			pTerm.eOperator = (ushort)(0x0200);
			pTerm.leftCursor = (int)(-1);
			if ((indexable) != 0)
			{
				pWC.hasOr = (byte)(1);
			}

			if (((indexable) != 0) && ((pOrWc.nTerm) == (2)))
			{
				int iOne = (int)(0);
				WhereTerm pOne;
				while ((pOne = whereNthSubterm(pOrWc.a[0], (int)(iOne++))) != null)
				{
					int iTwo = (int)(0);
					WhereTerm pTwo;
					while ((pTwo = whereNthSubterm(pOrWc.a[1], (int)(iTwo++))) != null)
					{
						whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
					}
				}
			}

			if ((chngToIN) != 0)
			{
				int okToChngToIN = (int)(0);
				int iColumn = (int)(-1);
				int iCursor = (int)(-1);
				int j = (int)(0);
				for (j = (int)(0); ((j) < (2)) && (okToChngToIN == 0); j++)
				{
					Expr pLeft = null;
					pOrTerm = pOrWc.a;
					for (i = (int)(pOrWc.nTerm - 1); (i) >= (0); i--, pOrTerm++)
					{

						pOrTerm.wtFlags &= (ushort)(~0x0040);
						if ((pOrTerm.leftCursor) == (iCursor))
						{

							continue;
						}

						if ((chngToIN & sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(pOrTerm.leftCursor))) == (0))
						{

							continue;
						}


						iColumn = (int)(pOrTerm.u.x.leftColumn);
						iCursor = (int)(pOrTerm.leftCursor);
						pLeft = pOrTerm.pExpr.pLeft;
						break;
					}

					if ((i) < (0))
					{



						break;
					}

					okToChngToIN = (int)(1);
					for (; ((i) >= (0)) && ((okToChngToIN) != 0); i--, pOrTerm++)
					{


						if (pOrTerm.leftCursor != iCursor)
						{
							pOrTerm.wtFlags &= (ushort)(~0x0040);
						}
						else if ((pOrTerm.u.x.leftColumn != iColumn) || (((iColumn) == (-2)) && ((sqlite3ExprCompare(pParse, pOrTerm.pExpr.pLeft, pLeft, (int)(-1))) != 0)))
						{
							okToChngToIN = (int)(0);
						}
						else
						{
							int affLeft = 0;
							int affRight = 0;
							affRight = (int)(sqlite3ExprAffinity(pOrTerm.pExpr.pRight));
							affLeft = (int)(sqlite3ExprAffinity(pOrTerm.pExpr.pLeft));
							if ((affRight != 0) && (affRight != affLeft))
							{
								okToChngToIN = (int)(0);
							}
							else
							{
								pOrTerm.wtFlags |= (ushort)(0x0040);
							}
						}
					}
				}

				if ((okToChngToIN) != 0)
				{
					Expr pDup;
					ExprList pList = null;
					Expr pLeft = null;
					Expr pNew;
					for (i = (int)(pOrWc.nTerm - 1), pOrTerm = pOrWc.a; (i) >= (0); i--, pOrTerm++)
					{
						if ((pOrTerm.wtFlags & 0x0040) == (0))
							continue;




						pDup = sqlite3ExprDup(db, pOrTerm.pExpr.pRight, (int)(0));
						pList = sqlite3ExprListAppend(pWInfo.pParse, pList, pDup);
						pLeft = pOrTerm.pExpr.pLeft;
					}


					pDup = sqlite3ExprDup(db, pLeft, (int)(0));
					pNew = sqlite3PExpr(pParse, (int)(49), pDup, null);
					if ((pNew) != null)
					{
						int idxNew = 0;
						transferJoinMarkings(pNew, pExpr);

						pNew.x.pList = pList;
						idxNew = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0002 | 0x0001)));
						exprAnalyze(pSrc, pWC, (int)(idxNew));
						markTermAsChild(pWC, (int)(idxNew), (int)(idxTerm));
					}
					else
					{
						sqlite3ExprListDelete(db, pList);
					}
				}
			}
		}
		public static void exprCodeBetween(Parse pParse, Expr pExpr, int dest, delegate174 xJump, int jumpIfNull)
		{
			Expr exprAnd = new Expr();
			Expr compLeft = new Expr();
			Expr compRight = new Expr();
			int regFree1 = (int)(0);
			Expr pDel = null;
			sqlite3 db = pParse.db;
			CRuntime.memset(compLeft, (int)(0), (ulong)(sizeof(Expr)));
			CRuntime.memset(compRight, (int)(0), (ulong)(sizeof(Expr)));
			CRuntime.memset(exprAnd, (int)(0), (ulong)(sizeof(Expr)));

			pDel = sqlite3ExprDup(db, pExpr.pLeft, (int)(0));
			if ((db.mallocFailed) == (0))
			{
				exprAnd.op = (byte)(44);
				exprAnd.pLeft = compLeft;
				exprAnd.pRight = compRight;
				compLeft.op = (byte)(57);
				compLeft.pLeft = pDel;
				compLeft.pRight = pExpr.x.pList.a[0].pExpr;
				compRight.op = (byte)(55);
				compRight.pLeft = pDel;
				compRight.pRight = pExpr.x.pList.a[1].pExpr;
				exprToRegister(pDel, (int)(exprCodeVector(pParse, pDel, &regFree1)));
				if ((xJump) != null)
				{
					xJump(pParse, exprAnd, (int)(dest), (int)(jumpIfNull));
				}
				else
				{
					pDel.flags |= (uint)(0x000001);
					sqlite3ExprCodeTarget(pParse, exprAnd, (int)(dest));
				}

				sqlite3ReleaseTempReg(pParse, (int)(regFree1));
			}

			sqlite3ExprDelete(db, pDel);
		}
		public static int exprCodeInlineFunction(Parse pParse, ExprList pFarg, int iFuncId, int target)
		{
			int nFarg = 0;
			Vdbe v = pParse.pVdbe;


			nFarg = (int)(pFarg.nExpr);

			switch (iFuncId)
			{
				case 0:
					{
						int endCoalesce = (int)(sqlite3VdbeMakeLabel(pParse));
						int i = 0;

						sqlite3ExprCode(pParse, pFarg.a[0].pExpr, (int)(target));
						for (i = (int)(1); (i) < (nFarg); i++)
						{
							sqlite3VdbeAddOp2(v, (int)(51), (int)(target), (int)(endCoalesce));
							sqlite3ExprCode(pParse, pFarg.a[i].pExpr, (int)(target));
						}

						setDoNotMergeFlagOnCopy(v);
						sqlite3VdbeResolveLabel(v, (int)(endCoalesce));
						break;
					}

				case 5:
					{
						Expr caseExpr = new Expr();
						CRuntime.memset(caseExpr, (int)(0), (ulong)(sizeof(Expr)));
						caseExpr.op = (byte)(157);
						caseExpr.x.pList = pFarg;
						return (int)(sqlite3ExprCodeTarget(pParse, caseExpr, (int)(target)));
					}

				default:
					{

						target = (int)(sqlite3ExprCodeTarget(pParse, pFarg.a[0].pExpr, (int)(target)));
						break;
					}

				case 3:
					{

						sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprCompare(null, pFarg.a[0].pExpr, pFarg.a[1].pExpr, (int)(-1))), (int)(target));
						break;
					}

				case 2:
					{

						sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprImpliesExpr(pParse, pFarg.a[0].pExpr, pFarg.a[1].pExpr, (int)(-1))), (int)(target));
						break;
					}

				case 1:
					{
						Expr pA1;

						pA1 = pFarg.a[1].pExpr;
						if ((pA1.op) == (167))
						{
							sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprImpliesNonNullRow(pFarg.a[0].pExpr, (int)(pA1.iTable))), (int)(target));
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
						}

						break;
					}

				case 4:
					{
						sbyte** azAff = stackalloc sbyte*[] { "blob", "text", "numeric", "integer", "real" };
						sbyte aff = 0;

						aff = (sbyte)(sqlite3ExprAffinity(pFarg.a[0].pExpr));
						sqlite3VdbeLoadString(v, (int)(target), ((aff) <= (0x40)) ? "none" : azAff[aff - 0x41]);
						break;
					}
			}

			return (int)(target);
		}
		public static int exprCodeSubselect(Parse pParse, Expr pExpr)
		{
			int reg = (int)(0);
			if ((pExpr.op) == (138))
			{
				reg = (int)(sqlite3CodeSubselect(pParse, pExpr));
			}

			return (int)(reg);
		}
		public static int exprCodeVector(Parse pParse, Expr p, int* piFreeable)
		{
			int iResult = 0;
			int nResult = (int)(sqlite3ExprVectorSize(p));
			if ((nResult) == (1))
			{
				iResult = (int)(sqlite3ExprCodeTemp(pParse, p, piFreeable));
			}
			else
			{
				*piFreeable = (int)(0);
				if ((p.op) == (138))
				{
					iResult = (int)(sqlite3CodeSubselect(pParse, p));
				}
				else
				{
					int i = 0;
					iResult = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(nResult);

					for (i = (int)(0); (i) < (nResult); i++)
					{
						sqlite3ExprCodeFactorable(pParse, p.x.pList.a[i].pExpr, (int)(i + iResult));
					}
				}
			}

			return (int)(iResult);
		}
		public static int exprColumnFlagUnion(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (167)) && ((pExpr.iColumn) >= (0)))
			{

				pWalker.eCode |= (ushort)(pWalker.u.pTab.aCol[pExpr.iColumn].colFlags);
			}

			return (int)(0);
		}
		public static ushort exprCommute(Parse pParse, Expr pExpr)
		{
			if ((((pExpr.pLeft.op) == (177)) || ((pExpr.pRight.op) == (177))) || (sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pExpr.pRight) != sqlite3BinaryCompareCollSeq(pParse, pExpr.pRight, pExpr.pLeft)))
			{
				pExpr.flags ^= (uint)(0x000200);
			}

			{
				Expr t = pExpr.pRight;
				pExpr.pRight = pExpr.pLeft;
				pExpr.pLeft = t;
			}

			if ((pExpr.op) >= (54))
			{





				pExpr.op = (byte)(((pExpr.op - 54) ^ 2) + 54);
			}

			return (ushort)(0);
		}
		public static int exprCompareVariable(Parse pParse, Expr pVar, Expr pExpr)
		{
			int res = (int)(0);
			int iVar = 0;
			sqlite3_value pL; sqlite3_value pR = null;
			sqlite3ValueFromExpr(pParse.db, pExpr, (byte)(1), (byte)(0x41), pR);
			if ((pR) != null)
			{
				iVar = (int)(pVar.iColumn);
				sqlite3VdbeSetVarmask(pParse.pVdbe, (int)(iVar));
				pL = sqlite3VdbeGetBoundValue(pParse.pReprepare, (int)(iVar), (byte)(0x41));
				if ((pL) != null)
				{
					if ((sqlite3_value_type(pL)) == (3))
					{
						sqlite3_value_text(pL);
					}

					res = (int)((0) == (sqlite3MemCompare(pL, pR, null)) ? 1 : 0);
				}

				sqlite3ValueFree(pR);
				sqlite3ValueFree(pL);
			}

			return (int)(res);
		}
		public static Expr exprDup(sqlite3 db, Expr p, int dupFlags, byte** pzBuffer)
		{
			Expr pNew;
			byte* zAlloc;
			uint staticFlag = 0;




			if ((pzBuffer) != null)
			{
				zAlloc = *pzBuffer;
				staticFlag = (uint)(0x8000000);

			}
			else
			{
				zAlloc = sqlite3DbMallocRawNN(db, (ulong)(dupedExprSize(p, (int)(dupFlags))));
				staticFlag = (uint)(0);
			}

			pNew = (Expr)(zAlloc);
			if ((pNew) != null)
			{
				uint nStructSize = (uint)(dupedExprStructSize(p, (int)(dupFlags)));
				int nNewSize = (int)(nStructSize & 0xfff);
				int nToken = 0;
				if ((!(((p).flags & (0x000400)) != 0)) && ((p.u.zToken) != null))
				{
					nToken = (int)(sqlite3Strlen30(p.u.zToken) + 1);
				}
				else
				{
					nToken = (int)(0);
				}

				if ((dupFlags) != 0)
				{

					CRuntime.memcpy(zAlloc, p, (ulong)(nNewSize));
				}
				else
				{
					uint nSize = (uint)(exprStructSize(p));
					CRuntime.memcpy(zAlloc, p, (ulong)(nSize));
					if ((nSize) < (sizeof(Expr)))
					{
						CRuntime.memset(&zAlloc[nSize], (int)(0), (ulong)(sizeof(Expr) - nSize));
					}
				}

				pNew.flags &= (uint)(~(0x002000 | 0x004000 | 0x8000000 | 0x010000));
				pNew.flags |= (uint)(nStructSize & (0x002000 | 0x004000));
				pNew.flags |= (uint)(staticFlag);
				if ((dupFlags) != 0)
				{
				}

				if ((nToken) != 0)
				{
					sbyte* zToken = pNew.u.zToken = (sbyte*)(&zAlloc[nNewSize]);
					CRuntime.memcpy(zToken, p.u.zToken, (ulong)(nToken));
				}

				if ((0) == ((p.flags | pNew.flags) & (0x004000 | 0x800000)))
				{
					if ((((p).flags & 0x000800) != 0))
					{
						pNew.x.pSelect = sqlite3SelectDup(db, p.x.pSelect, (int)(dupFlags));
					}
					else
					{
						pNew.x.pList = sqlite3ExprListDup(db, p.x.pList, (int)(dupFlags));
					}
				}

				if ((((pNew).flags & (0x002000 | 0x004000 | 0x1000000)) != 0))
				{
					zAlloc += dupedExprNodeSize(p, (int)(dupFlags));
					if (!(((pNew).flags & (0x004000 | 0x800000)) != 0))
					{
						pNew.pLeft = p.pLeft ? exprDup(db, p.pLeft, (int)(0x0001), &zAlloc) : null;
						pNew.pRight = p.pRight ? exprDup(db, p.pRight, (int)(0x0001), &zAlloc) : null;
					}

					if ((((p).flags & (0x1000000)) != 0))
					{
						pNew.y.pWin = sqlite3WindowDup(db, pNew, p.y.pWin);

					}

					if ((pzBuffer) != null)
					{
						*pzBuffer = zAlloc;
					}
				}
				else
				{
					if (!(((p).flags & (0x004000 | 0x800000)) != 0))
					{
						if ((pNew.op) == (178))
						{
							pNew.pLeft = p.pLeft;

						}
						else
						{
							pNew.pLeft = sqlite3ExprDup(db, p.pLeft, (int)(0));
						}

						pNew.pRight = sqlite3ExprDup(db, p.pRight, (int)(0));
					}
				}
			}

			return pNew;
		}
		public static int exprIdxCover(Walker pWalker, Expr pExpr)
		{
			if ((((pExpr.op) == (167)) && ((pExpr.iTable) == (pWalker.u.pIdxCover.iCur))) && ((sqlite3TableColumnToIndex(pWalker.u.pIdxCover.pIdx, (short)(pExpr.iColumn))) < (0)))
			{
				pWalker.eCode = (ushort)(1);
				return (int)(2);
			}

			return (int)(0);
		}
		public static int exprImpliesNotNull(Parse pParse, Expr p, Expr pNN, int iTab, int seenNot)
		{


			if ((sqlite3ExprCompare(pParse, p, pNN, (int)(iTab))) == (0))
			{
				return (int)(pNN.op != 121);
			}

			switch (p.op)
			{
				case 49:
					{
						if (((seenNot) != 0) && (((p).flags & (0x000800)) != 0))
							return (int)(0);

						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}

				case 48:
					{
						ExprList pList;

						pList = p.x.pList;


						if ((seenNot) != 0)
							return (int)(0);
						if (((exprImpliesNotNull(pParse, pList.a[0].pExpr, pNN, (int)(iTab), (int)(1))) != 0) || ((exprImpliesNotNull(pParse, pList.a[1].pExpr, pNN, (int)(iTab), (int)(1))) != 0))
						{
							return (int)(1);
						}

						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}

				case 53:
				case 52:
				case 56:
				case 55:
				case 54:
				case 57:
				case 106:
				case 107:
				case 103:
				case 104:
				case 105:
				case 111:
					seenNot = (int)(1);
				case 108:
				case 110:
				case 102:
				case 109:
					{
						if ((exprImpliesNotNull(pParse, p.pRight, pNN, (int)(iTab), (int)(seenNot))) != 0)
							return (int)(1);
					}

				case 181:
				case 113:
				case 174:
				case 173:
					{
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(seenNot)));
					}

				case 175:
					{
						if ((seenNot) != 0)
							return (int)(0);
						if (p.op2 != 45)
							return (int)(0);
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}

				case 114:
				case 19:
					{
						return (int)(exprImpliesNotNull(pParse, p.pLeft, pNN, (int)(iTab), (int)(1)));
					}
			}

			return (int)(0);
		}
		public static sbyte* exprINAffinity(Parse pParse, Expr pExpr)
		{
			Expr pLeft = pExpr.pLeft;
			int nVal = (int)(sqlite3ExprVectorSize(pLeft));
			Select pSelect = (((pExpr).flags & 0x000800) != 0) ? pExpr.x.pSelect : null;
			sbyte* zRet;

			zRet = sqlite3DbMallocRaw(pParse.db, (ulong)(nVal + 1));
			if ((zRet) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (nVal); i++)
				{
					Expr pA = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
					sbyte a = (sbyte)(sqlite3ExprAffinity(pA));
					if ((pSelect) != null)
					{
						zRet[i] = (sbyte)(sqlite3CompareAffinity(pSelect.pEList.a[i].pExpr, (sbyte)(a)));
					}
					else
					{
						zRet[i] = (sbyte)(a);
					}
				}

				zRet[nVal] = (sbyte)(0);
			}

			return zRet;
		}
		public static int exprIsConst(Expr p, int initFlag, int iCur)
		{
			Walker w = new Walker();
			w.eCode = (ushort)(initFlag);
			w.xExprCallback = exprNodeIsConstant;
			w.xSelectCallback = sqlite3SelectWalkFail;
			w.u.iCur = (int)(iCur);
			sqlite3WalkExpr(w, p);
			return (int)(w.eCode);
		}
		public static int exprIsDeterministic(Expr p)
		{
			Walker w = new Walker();
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			w.eCode = (ushort)(1);
			w.xExprCallback = exprNodeIsDeterministic;
			w.xSelectCallback = sqlite3SelectWalkFail;
			sqlite3WalkExpr(w, p);
			return (int)(w.eCode);
		}
		public static ExprList exprListAppendList(Parse pParse, ExprList pList, ExprList pAppend, int bIntToNull)
		{
			if ((pAppend) != null)
			{
				int i = 0;
				int nInit = (int)(pList ? pList.nExpr : 0);
				for (i = (int)(0); (i) < (pAppend.nExpr); i++)
				{
					sqlite3 db = pParse.db;
					Expr pDup = sqlite3ExprDup(db, pAppend.a[i].pExpr, (int)(0));

					if ((db.mallocFailed) != 0)
					{
						sqlite3ExprDelete(db, pDup);
						break;
					}

					if ((bIntToNull) != 0)
					{
						int iDummy = 0;
						Expr pSub;
						pSub = sqlite3ExprSkipCollateAndLikely(pDup);
						if ((sqlite3ExprIsInteger(pSub, &iDummy)) != 0)
						{
							pSub.op = (byte)(121);
							pSub.flags &= (uint)(~(0x000400 | 0x10000000 | 0x20000000));
							pSub.u.zToken = null;
						}
					}

					pList = sqlite3ExprListAppend(pParse, pList, pDup);
					if ((pList) != null)
						pList.a[nInit + i].sortFlags = (byte)(pAppend.a[i].sortFlags);
				}
			}

			return pList;
		}
		public static void exprListDeleteNN(sqlite3 db, ExprList pList)
		{
			int i = (int)(pList.nExpr);
			ExprList_item* pItem = pList.a;

			do
			{
				sqlite3ExprDelete(db, pItem->pExpr);
				sqlite3DbFree(db, pItem->zEName);
				pItem++;
			}
			while ((--i) > (0));
			sqlite3DbFreeNN(db, pList);
		}
		public static int exprMightBeIndexed(SrcList pFrom, ulong mPrereq, int* aiCurCol, Expr pExpr, int op)
		{



			if (((pExpr.op) == (177)) && (((op) >= (54)) && ((op) <= (57))))
			{

				pExpr = pExpr.x.pList.a[0].pExpr;
			}

			if ((pExpr.op) == (167))
			{
				aiCurCol[0] = (int)(pExpr.iTable);
				aiCurCol[1] = (int)(pExpr.iColumn);
				return (int)(1);
			}

			if ((mPrereq) == (0))
				return (int)(0);
			if ((mPrereq & (mPrereq - 1)) != 0)
				return (int)(0);
			return (int)(exprMightBeIndexed2(pFrom, (ulong)(mPrereq), aiCurCol, pExpr));
		}
		public static int exprMightBeIndexed2(SrcList pFrom, ulong mPrereq, int* aiCurCol, Expr pExpr)
		{
			Index pIdx;
			int i = 0;
			int iCur = 0;
			for (i = (int)(0); (mPrereq) > (1); i++, mPrereq >>= 1)
			{
			}

			iCur = (int)(pFrom.a[i].iCursor);
			for (pIdx = pFrom.a[i].pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				if ((pIdx.aColExpr) == (null))
					continue;
				for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
				{
					if (pIdx.aiColumn[i] != (-2))
						continue;
					if ((sqlite3ExprCompareSkip(pExpr, pIdx.aColExpr.a[i].pExpr, (int)(iCur))) == (0))
					{
						aiCurCol[0] = (int)(iCur);
						aiCurCol[1] = (int)(-2);
						return (int)(1);
					}
				}
			}

			return (int)(0);
		}
		public static int exprNodeIsConstant(Walker pWalker, Expr pExpr)
		{
			if (((pWalker.eCode) == (2)) && (((pExpr).flags & (0x000001)) != 0))
			{
				pWalker.eCode = (ushort)(0);
				return (int)(2);
			}

			switch (pExpr.op)
			{
				case 172:
					if ((((pWalker.eCode) >= (4)) || (((pExpr).flags & (0x080000)) != 0)) && (!(((pExpr).flags & (0x1000000)) != 0)))
					{
						if ((pWalker.eCode) == (5))
							(pExpr).flags |= (uint)(0x40000000);
						return (int)(0);
					}
					else
					{
						pWalker.eCode = (ushort)(0);
						return (int)(2);
					}

				case 59:
					if ((sqlite3ExprIdToTrueFalse(pExpr)) != 0)
					{
						return (int)(1);
					}

				case 167:
				case 168:
				case 169:
					;
					if ((((pExpr).flags & (0x000008)) != 0) && (pWalker.eCode != 2))
					{
						return (int)(0);
					}

					if (((pWalker.eCode) == (3)) && ((pExpr.iTable) == (pWalker.u.iCur)))
					{
						return (int)(0);
					}

				case 179:
				case 176:
				case 141:
					;
					pWalker.eCode = (ushort)(0);
					return (int)(2);
				case 156:
					if ((pWalker.eCode) == (5))
					{
						pExpr.op = (byte)(121);
					}
					else if ((pWalker.eCode) == (4))
					{
						pWalker.eCode = (ushort)(0);
						return (int)(2);
					}

				default:
					;
					return (int)(0);
			}
		}
		public static int exprNodeIsConstantOrGroupBy(Walker pWalker, Expr pExpr)
		{
			ExprList pGroupBy = pWalker.u.pGroupBy;
			int i = 0;
			for (i = (int)(0); (i) < (pGroupBy.nExpr); i++)
			{
				Expr p = pGroupBy.a[i].pExpr;
				if ((sqlite3ExprCompare(null, pExpr, p, (int)(-1))) < (2))
				{
					CollSeq pColl = sqlite3ExprNNCollSeq(pWalker.pParse, p);
					if ((sqlite3IsBinary(pColl)) != 0)
					{
						return (int)(1);
					}
				}
			}

			if ((((pExpr).flags & 0x000800) != 0))
			{
				pWalker.eCode = (ushort)(0);
				return (int)(2);
			}

			return (int)(exprNodeIsConstant(pWalker, pExpr));
		}
		public static int exprNodeIsDeterministic(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (172)) && ((((pExpr).flags & (0x080000)) != 0) == (0)))
			{
				pWalker.eCode = (ushort)(0);
				return (int)(2);
			}

			return (int)(0);
		}
		public static int exprProbability(Expr p)
		{
			double r = (double)(-1.0);
			if (p.op != 153)
				return (int)(-1);

			sqlite3AtoF(p.u.zToken, &r, (int)(sqlite3Strlen30(p.u.zToken)), (byte)(1));

			if ((r) > (1.0))
				return (int)(-1);
			return (int)(r * 134217728.0);
		}
		public static int exprRefToSrcList(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (167)) || ((pExpr.op) == (169)))
			{
				int i = 0;
				RefSrcList p = pWalker.u.pRefSrcList;
				SrcList pSrc = p.pRef;
				int nSrc = (int)(pSrc ? pSrc.nSrc : 0);
				for (i = (int)(0); (i) < (nSrc); i++)
				{
					if ((pExpr.iTable) == (pSrc.a[i].iCursor))
					{
						pWalker.eCode |= (ushort)(1);
						return (int)(0);
					}
				}

				for (i = (int)(0); ((i) < (p.nExclude)) && (p.aiExclude[i] != pExpr.iTable); i++)
				{
				}

				if ((i) >= (p.nExclude))
				{
					pWalker.eCode |= (ushort)(2);
				}
			}

			return (int)(0);
		}
		public static Expr exprRowColumn(Parse pParse, int iCol)
		{
			Expr pRet = sqlite3PExpr(pParse, (int)(75), null, null);
			if ((pRet) != null)
				pRet.iColumn = (short)(iCol + 1);
			return pRet;
		}
		public static ulong exprSelectUsage(WhereMaskSet* pMaskSet, Select pS)
		{
			ulong mask = (ulong)(0);
			while ((pS) != null)
			{
				SrcList pSrc = pS.pSrc;
				mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pS.pEList));
				mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pS.pGroupBy));
				mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pS.pOrderBy));
				mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pS.pWhere));
				mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pS.pHaving));
				if ((pSrc != null))
				{
					int i = 0;
					for (i = (int)(0); (i) < (pSrc.nSrc); i++)
					{
						mask |= (ulong)(exprSelectUsage(pMaskSet, pSrc.a[i].pSelect));
						mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pSrc.a[i].pOn));
						if ((pSrc.a[i].fg.isTabFunc) != 0)
						{
							mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, pSrc.a[i].u1.pFuncArg));
						}
					}
				}

				pS = pS.pPrior;
			}

			return (ulong)(mask);
		}
		public static void exprSetHeight(Expr p)
		{
			int nHeight = (int)(p.pLeft ? p.pLeft.nHeight : 0);
			if (((p.pRight) != null) && ((p.pRight.nHeight) > (nHeight)))
				nHeight = (int)(p.pRight.nHeight);
			if ((((p).flags & 0x000800) != 0))
			{
				heightOfSelect(p.x.pSelect, &nHeight);
			}
			else if ((p.x.pList) != null)
			{
				heightOfExprList(p.x.pList, &nHeight);
				p.flags |= (uint)((0x000100 | 0x200000 | 0x000004) & sqlite3ExprListFlags(p.x.pList));
			}

			p.nHeight = (int)(nHeight + 1);
		}
		public static int exprStructSize(Expr p)
		{
			if ((((p).flags & (0x004000)) != 0))
				return (int)((ulong)((0).pLeft));
			if ((((p).flags & (0x002000)) != 0))
				return (int)((ulong)(&((0).iTable)));
			return (int)(sizeof(Expr));
		}
		public static Expr exprTableColumn(sqlite3 db, Table pTab, int iCursor, short iCol)
		{
			Expr pExpr = sqlite3Expr(db, (int)(167), null);
			if ((pExpr) != null)
			{

				pExpr.y.pTab = pTab;
				pExpr.iTable = (int)(iCursor);
				pExpr.iColumn = (short)(iCol);
			}

			return pExpr;
		}
		public static Expr exprTableRegister(Parse pParse, Table pTab, int regBase, short iCol)
		{
			Expr pExpr;
			Column* pCol;
			sbyte* zColl;
			sqlite3 db = pParse.db;
			pExpr = sqlite3Expr(db, (int)(176), null);
			if ((pExpr) != null)
			{
				if (((iCol) >= (0)) && (iCol != pTab.iPKey))
				{
					pCol = &pTab.aCol[iCol];
					pExpr.iTable = (int)(regBase + sqlite3TableColumnToStorage(pTab, (short)(iCol)) + 1);
					pExpr.affExpr = (sbyte)(pCol->affinity);
					zColl = sqlite3ColumnColl(pCol);
					if ((zColl) == (null))
						zColl = db.pDfltColl.zName;
					pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
				}
				else
				{
					pExpr.iTable = (int)(regBase);
					pExpr.affExpr = (sbyte)(0x44);
				}
			}

			return pExpr;
		}
		public static void exprToRegister(Expr pExpr, int iReg)
		{
			Expr p = sqlite3ExprSkipCollateAndLikely(pExpr);
			if (((p) == (null)))
				return;
			p.op2 = (byte)(p.op);
			p.op = (byte)(176);
			p.iTable = (int)(iReg);
			(p).flags &= (uint)(~(0x001000));
		}
		public static int exprVectorRegister(Parse pParse, Expr pVector, int iField, int regSelect, Expr ppExpr, int* pRegFree)
		{
			byte op = (byte)(pVector.op);

			if ((op) == (176))
			{
				ppExpr = sqlite3VectorFieldSubexpr(pVector, (int)(iField));
				return (int)(pVector.iTable + iField);
			}

			if ((op) == (138))
			{

				ppExpr = pVector.x.pSelect.pEList.a[iField].pExpr;
				return (int)(regSelect + iField);
			}

			if ((op) == (177))
			{

				ppExpr = pVector.x.pList.a[iField].pExpr;
				return (int)(sqlite3ExprCodeTemp(pParse, ppExpr, pRegFree));
			}

			return (int)(0);
		}
		public static void* fetchPayload(BtCursor pCur, uint* pAmt)
		{
			int amt = 0;








			amt = (int)(pCur.info.nLocal);
			if ((amt) > ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)))
			{

				amt = (int)((0) > ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)) ? (0) : ((int)(pCur.pPage.aDataEnd - pCur.info.pPayload)));
			}

			*pAmt = ((uint)(amt));
			return (void*)(pCur.info.pPayload);
		}
		public static int fillInCell(MemPage pPage, byte* pCell, BtreePayload pX, int* pnSize)
		{
			int nPayload = 0;
			byte* pSrc;
			int nSrc = 0; int n = 0; int rc = 0; int mn = 0;
			int spaceLeft = 0;
			MemPage pToRelease;
			byte* pPrior;
			byte* pPayload;
			BtShared pBt;
			uint pgnoOvfl = 0;
			int nHeader = 0;


			nHeader = (int)(pPage.childPtrSize);
			if ((pPage.intKey) != 0)
			{
				nPayload = (int)(pX.nData + pX.nZero);
				pSrc = pX.pData;
				nSrc = (int)(pX.nData);

				nHeader += (int)((byte)((((uint)(nPayload)) < ((uint)(0x80))) ? (*(&pCell[nHeader]) = ((byte)(nPayload))), 1 : 
        sqlite3PutVarint((&pCell[nHeader]), (ulong)(nPayload)) ) )
        ;
				nHeader += (int)(sqlite3PutVarint(&pCell[nHeader], (ulong)(*(ulong*)(&pX.nKey))));
			}
			else
			{

				nSrc = (int)(nPayload = ((int)(pX.nKey)));
				pSrc = pX.pKey;
				nHeader += (int)((byte)((((uint)(nPayload)) < ((uint)(0x80))) ? (*(&pCell[nHeader]) = ((byte)(nPayload))), 1 : 
        sqlite3PutVarint((&pCell[nHeader]), (ulong)(nPayload)) ) )
        ;
			}

			pPayload = &pCell[nHeader];
			if ((nPayload) <= (pPage.maxLocal))
			{
				n = (int)(nHeader + nPayload);
				if ((n) < (4))
					n = (int)(4);
				*pnSize = (int)(n);

				CRuntime.memcpy(pPayload, pSrc, (ulong)(nSrc));
				CRuntime.memset(pPayload + nSrc, (int)(0), (ulong)(nPayload - nSrc));
				return (int)(0);
			}

			mn = (int)(pPage.minLocal);
			n = (int)(mn + (nPayload - mn) % (pPage.pBt.usableSize - 4));
			if ((n) > (pPage.maxLocal))
				n = (int)(mn);
			spaceLeft = (int)(n);
			*pnSize = (int)(n + nHeader + 4);
			pPrior = &pCell[nHeader + n];
			pToRelease = null;
			pgnoOvfl = (uint)(0);
			pBt = pPage.pBt;
			while ((1) != 0)
			{
				n = (int)(nPayload);
				if ((n) > (spaceLeft))
					n = (int)(spaceLeft);


				if ((nSrc) >= (n))
				{
					CRuntime.memcpy(pPayload, pSrc, (ulong)(n));
				}
				else if ((nSrc) > (0))
				{
					n = (int)(nSrc);
					CRuntime.memcpy(pPayload, pSrc, (ulong)(n));
				}
				else
				{
					CRuntime.memset(pPayload, (int)(0), (ulong)(n));
				}

				nPayload -= (int)(n);
				if ((nPayload) <= (0))
					break;
				pPayload += n;
				pSrc += n;
				nSrc -= (int)(n);
				spaceLeft -= (int)(n);
				if ((spaceLeft) == (0))
				{
					MemPage pOvfl = null;
					uint pgnoPtrmap = (uint)(pgnoOvfl);
					if ((pBt.autoVacuum) != 0)
					{
						do
						{
							pgnoOvfl++;
						}
						while (((ptrmapPageno((pBt), (uint)(pgnoOvfl))) == (pgnoOvfl)) || ((pgnoOvfl) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)));
					}

					rc = (int)(allocateBtreePage(pBt, pOvfl, &pgnoOvfl, (uint)(pgnoOvfl), (byte)(0)));
					if (((pBt.autoVacuum) != 0) && ((rc) == (0)))
					{
						byte eType = (byte)((pgnoPtrmap) != 0 ? 4 : 3);
						ptrmapPut(pBt, (uint)(pgnoOvfl), (byte)(eType), (uint)(pgnoPtrmap), &rc);
						if ((rc) != 0)
						{
							releasePage(pOvfl);
						}
					}

					if ((rc) != 0)
					{
						releasePage(pToRelease);
						return (int)(rc);
					}



					sqlite3Put4byte(pPrior, (uint)(pgnoOvfl));
					releasePage(pToRelease);
					pToRelease = pOvfl;
					pPrior = pOvfl.aData;
					sqlite3Put4byte(pPrior, (uint)(0));
					pPayload = &pOvfl.aData[4];
					spaceLeft = (int)(pBt.usableSize - 4);
				}
			}

			releasePage(pToRelease);
			return (int)(0);
		}
		public static ulong filterHash(sqlite3_value aMem, VdbeOp* pOp)
		{
			int i = 0; int mx = 0;
			ulong h = (ulong)(0);

			for (i = (int)(pOp->p3), mx = (int)(i + pOp->p4.i); (i) < (mx); i++)
			{
				sqlite3_value p = aMem[i];
				if ((p.flags & (0x0004 | 0x0020)) != 0)
				{
					h += (ulong)(p.u.i);
				}
				else if ((p.flags & 0x0008) != 0)
				{
					h += (ulong)(sqlite3VdbeIntValue(p));
				}
				else if ((p.flags & (0x0002 | 0x0010)) != 0)
				{
					h += (ulong)(p.n);
					if ((p.flags & 0x4000) != 0)
						h += (ulong)(p.u.nZero);
				}
			}

			return (ulong)(h);
		}
		public static void filterPullDown(Parse pParse, WhereInfo pWInfo, int iLevel, int addrNxt, ulong notReady)
		{
			while ((++iLevel) < (pWInfo.nLevel))
			{
				WhereLevel pLevel = pWInfo.a[iLevel];
				WhereLoop pLoop = pLevel.pWLoop;
				if ((pLevel.regFilter) == (0))
					continue;
				if ((pLevel.pWLoop.nSkip) != 0)
					continue;
				if ((pLoop.prereq & notReady) != 0)
					continue;
				if ((pLoop.wsFlags & 0x00000100) != 0)
				{
					WhereTerm pTerm = pLoop.aLTerm[0];
					int regRowid = 0;


					regRowid = (int)(sqlite3GetTempReg(pParse));
					regRowid = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(0), (int)(0), (int)(regRowid)));
					sqlite3VdbeAddOp4Int(pParse.pVdbe, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(regRowid), (int)(1));
				}
				else
				{
					ushort nEq = (ushort)(pLoop.u.btree.nEq);
					int r1 = 0;
					sbyte* zStartAff;


					r1 = (int)(codeAllEqualityTerms(pParse, pLevel, (int)(0), (int)(0), &zStartAff));
					codeApplyAffinity(pParse, (int)(r1), (int)(nEq), zStartAff);
					sqlite3DbFree(pParse.db, zStartAff);
					sqlite3VdbeAddOp4Int(pParse.pVdbe, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(r1), (int)(nEq));
				}

				pLevel.regFilter = (int)(0);
			}
		}
		public static uint finalDbSize(BtShared pBt, uint nOrig, uint nFree)
		{
			int nEntry = 0;
			uint nPtrmap = 0;
			uint nFin = 0;
			nEntry = (int)(pBt.usableSize / 5);
			nPtrmap = (uint)((nFree - nOrig + ptrmapPageno(pBt, (uint)(nOrig)) + nEntry) / nEntry);
			nFin = (uint)(nOrig - nFree - nPtrmap);
			if (((nOrig) > ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) && ((nFin) < ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
			{
				nFin--;
			}

			while (((ptrmapPageno((pBt), (uint)(nFin))) == (nFin)) || ((nFin) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
			{
				nFin--;
			}

			return (uint)(nFin);
		}
		public static void finalizeAggFunctions(Parse pParse, AggInfo pAggInfo)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			AggInfo_func* pF;
			for (i = (int)(0), pF = pAggInfo.aFunc; (i) < (pAggInfo.nFunc); i++, pF++)
			{
				ExprList pList;

				pList = pF->pFExpr.x.pList;
				sqlite3VdbeAddOp2(v, (int)(164), (int)(pF->iMem), (int)(pList ? pList.nExpr : 0));
				sqlite3VdbeAppendP4(v, pF->pFunc, (int)(-8));
			}
		}
		public static Btree findBtree(sqlite3 pErrorDb, sqlite3 pDb, sbyte* zDb)
		{
			int i = (int)(sqlite3FindDbName(pDb, zDb));
			if ((i) == (1))
			{
				Parse sParse = new Parse();
				int rc = (int)(0);
				sqlite3ParseObjectInit(sParse, pDb);
				if ((sqlite3OpenTempDatabase(sParse)) != 0)
				{
					sqlite3ErrorWithMsg(pErrorDb, (int)(sParse.rc), "%s", sParse.zErrMsg);
					rc = (int)(1);
				}

				sqlite3DbFree(pErrorDb, sParse.zErrMsg);
				sqlite3ParseObjectReset(sParse);
				if ((rc) != 0)
				{
					return null;
				}
			}

			if ((i) < (0))
			{
				sqlite3ErrorWithMsg(pErrorDb, (int)(1), "unknown database %s", zDb);
				return null;
			}

			return pDb.aDb[i].pBt;
		}
		public static CollSeq findCollSeqEntry(sqlite3 db, sbyte* zName, int create)
		{
			CollSeq pColl;
			pColl = sqlite3HashFind(&db.aCollSeq, zName);
			if (((null) == (pColl)) && ((create) != 0))
			{
				int nName = (int)(sqlite3Strlen30(zName) + 1);
				pColl = sqlite3DbMallocZero(db, (ulong)(3 * sizeof(CollSeq) + nName));
				if ((pColl) != null)
				{
					CollSeq pDel = null;
					pColl[0].zName = (sbyte*)(pColl[3]);
					pColl[0].enc = (byte)(1);
					pColl[1].zName = (sbyte*)(pColl[3]);
					pColl[1].enc = (byte)(2);
					pColl[2].zName = (sbyte*)(pColl[3]);
					pColl[2].enc = (byte)(3);
					CRuntime.memcpy(pColl[0].zName, zName, (ulong)(nName));
					pDel = sqlite3HashInsert(&db.aCollSeq, pColl[0].zName, pColl);

					if (pDel != null)
					{
						sqlite3OomFault(db);
						sqlite3DbFree(db, pDel);
						pColl = null;
					}
				}
			}

			return pColl;
		}
		public static void findConstInWhere(WhereConst pConst, Expr pExpr)
		{
			Expr pRight; Expr pLeft;
			if (((pExpr) == (null)))
				return;
			if ((((pExpr).flags & (0x000001)) != 0))
				return;
			if ((pExpr.op) == (44))
			{
				findConstInWhere(pConst, pExpr.pRight);
				findConstInWhere(pConst, pExpr.pLeft);
				return;
			}

			if (pExpr.op != 53)
				return;
			pRight = pExpr.pRight;
			pLeft = pExpr.pLeft;


			if (((pRight.op) == (167)) && ((sqlite3ExprIsConstant(pLeft)) != 0))
			{
				constInsert(pConst, pRight, pLeft, pExpr);
			}

			if (((pLeft.op) == (167)) && ((sqlite3ExprIsConstant(pRight)) != 0))
			{
				constInsert(pConst, pLeft, pRight, pExpr);
			}
		}
		public static HashElem* findElementWithHash(Hash* pH, sbyte* pKey, uint* pHash)
		{
			HashElem* elem;
			uint count = 0;
			uint h = 0;
			if ((pH->ht) != null)
			{
				_ht* pEntry;
				h = (uint)(strHash(pKey) % pH->htsize);
				pEntry = &pH->ht[h];
				elem = pEntry->chain;
				count = (uint)(pEntry->count);
			}
			else
			{
				h = (uint)(0);
				elem = pH->first;
				count = (uint)(pH->count);
			}

			if ((pHash) != null)
				*pHash = (uint)(h);
			while ((count--) != 0)
			{

				if ((sqlite3StrICmp(elem->pKey, pKey)) == (0))
				{
					return elem;
				}

				elem = elem->next;
			}

			return &findElementWithHash_nullElement;
		}
		public static int findIndexCol(Parse pParse, ExprList pList, int iBase, Index pIdx, int iCol)
		{
			int i = 0;
			sbyte* zColl = pIdx.azColl[iCol];
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				Expr p = sqlite3ExprSkipCollateAndLikely(pList.a[i].pExpr);
				if ((((p != null) && (((p.op) == (167)) || ((p.op) == (169)))) && ((p.iColumn) == (pIdx.aiColumn[iCol]))) && ((p.iTable) == (iBase)))
				{
					CollSeq pColl = sqlite3ExprNNCollSeq(pParse, pList.a[i].pExpr);
					if ((0) == (sqlite3StrICmp(pColl.zName, zColl)))
					{
						return (int)(i);
					}
				}
			}

			return (int)(-1);
		}
		public static int findNextHostParameter(sbyte* zSql, int* pnToken)
		{
			int tokenType = 0;
			int nTotal = (int)(0);
			int n = 0;
			*pnToken = (int)(0);
			while ((zSql[0]) != 0)
			{
				n = (int)(sqlite3GetToken((byte*)(zSql), &tokenType));

				if ((tokenType) == (156))
				{
					*pnToken = (int)(n);
					break;
				}

				nTotal += (int)(n);
				zSql += n;
			}

			return (int)(nTotal);
		}
		public static Select findRightmost(Select p)
		{
			while ((p.pNext) != null)
			{
				p = p.pNext;
			}

			return p;
		}
		public static void first_valueFinalizeFunc(sqlite3_context pCtx)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
			if (((p) != null) && ((p.pValue) != null))
			{
				sqlite3_result_value(pCtx, p.pValue);
				sqlite3_value_free(p.pValue);
				p.pValue = null;
			}
		}
		public static void first_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
			if (((p) != null) && ((p.pValue) == (null)))
			{
				p.pValue = sqlite3_value_dup(apArg[0]);
				if (p.pValue == null)
				{
					sqlite3_result_error_nomem(pCtx);
				}
			}

			(void)(nArg);
			(void)(apArg);
		}
		public static void fixDistinctOpenEph(Parse pParse, int eTnctType, int iVal, int iOpenEphAddr)
		{
			if (((pParse.nErr) == (0)) && (((eTnctType) == (1)) || ((eTnctType) == (2))))
			{
				Vdbe v = pParse.pVdbe;
				sqlite3VdbeChangeToNoop(v, (int)(iOpenEphAddr));
				if ((sqlite3VdbeGetOp(v, (int)(iOpenEphAddr + 1))->opcode) == (183))
				{
					sqlite3VdbeChangeToNoop(v, (int)(iOpenEphAddr + 1));
				}

				if ((eTnctType) == (2))
				{
					VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iOpenEphAddr));
					pOp->opcode = (byte)(74);
					pOp->p1 = (int)(1);
					pOp->p2 = (int)(iVal);
				}
			}
		}
		public static int fixExprCb(Walker p, Expr pExpr)
		{
			DbFixer pFix = p.u.pFix;
			if (pFix.bTemp == 0)
				(pExpr).flags |= (uint)(0x40000000);
			if ((pExpr.op) == (156))
			{
				if ((pFix.pParse.db.init.busy) != 0)
				{
					pExpr.op = (byte)(121);
				}
				else
				{
					sqlite3ErrorMsg(pFix.pParse, "%s cannot use variables", pFix.zType);
					return (int)(2);
				}
			}

			return (int)(0);
		}
		public static int fixSelectCb(Walker p, Select pSelect)
		{
			DbFixer pFix = p.u.pFix;
			int i = 0;
			SrcItem pItem;
			sqlite3 db = pFix.pParse.db;
			int iDb = (int)(sqlite3FindDbName(db, pFix.zDb));
			SrcList pList = pSelect.pSrc;
			if (((pList) == (null)))
				return (int)(0);
			for (i = (int)(0), pItem = pList.a; (i) < (pList.nSrc); i++, pItem++)
			{
				if ((pFix.bTemp) == (0))
				{
					if ((pItem.zDatabase) != null)
					{
						if (iDb != sqlite3FindDbName(db, pItem.zDatabase))
						{
							sqlite3ErrorMsg(pFix.pParse, "%s %T cannot reference objects in database %s", pFix.zType, pFix.pName, pItem.zDatabase);
							return (int)(2);
						}

						sqlite3DbFree(db, pItem.zDatabase);
						pItem.zDatabase = null;
						pItem.fg.notCte = (uint)(1);
					}

					pItem.pSchema = pFix.pSchema;
					pItem.fg.fromDDL = (uint)(1);
				}

				if ((sqlite3WalkExpr(pFix.w, pList.a[i].pOn)) != 0)
					return (int)(2);
			}

			if ((pSelect.pWith) != null)
			{
				for (i = (int)(0); (i) < (pSelect.pWith.nCte); i++)
				{
					if ((sqlite3WalkSelect(p, pSelect.pWith.a[i].pSelect)) != 0)
					{
						return (int)(2);
					}
				}
			}

			return (int)(0);
		}
		public static Trigger fkActionTrigger(Parse pParse, Table pTab, FKey pFKey, ExprList pChanges)
		{
			return null;
		}
		public static int fkChildIsModified(Table pTab, FKey p, int* aChange, int bChngRowid)
		{
			int i = 0;
			for (i = (int)(0); (i) < (p.nCol); i++)
			{
				int iChildKey = (int)(p.aCol[i].iFrom);
				if ((aChange[iChildKey]) >= (0))
					return (int)(1);
				if (((iChildKey) == (pTab.iPKey)) && ((bChngRowid) != 0))
					return (int)(1);
			}

			return (int)(0);
		}
		public static void fkLookupParent(Parse pParse, int iDb, Table pTab, Index pIdx, FKey pFKey, int* aiCol, int regData, int nIncr, int isIgnore)
		{
			int i = 0;
			Vdbe v = sqlite3GetVdbe(pParse);
			int iCur = (int)(pParse.nTab - 1);
			int iOk = (int)(sqlite3VdbeMakeLabel(pParse));
			if ((nIncr) < (0))
			{
				sqlite3VdbeAddOp2(v, (int)(48), (int)(pFKey.isDeferred), (int)(iOk));
			}

			for (i = (int)(0); (i) < (pFKey.nCol); i++)
			{
				int iReg = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + regData + 1);
				sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(iOk));
			}

			if ((isIgnore) == (0))
			{
				if ((pIdx) == (null))
				{
					int iMustBeInt = 0;
					int regTemp = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp2(v, (int)(80), (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[0])) + 1 + regData), (int)(regTemp));
					iMustBeInt = (int)(sqlite3VdbeAddOp2(v, (int)(15), (int)(regTemp), (int)(0)));
					if (((pTab) == (pFKey.pFrom)) && ((nIncr) == (1)))
					{
						sqlite3VdbeAddOp3(v, (int)(53), (int)(regData), (int)(iOk), (int)(regTemp));
						sqlite3VdbeChangeP5(v, (ushort)(0x90));
					}

					sqlite3OpenTable(pParse, (int)(iCur), (int)(iDb), pTab, (int)(101));
					sqlite3VdbeAddOp3(v, (int)(33), (int)(iCur), (int)(0), (int)(regTemp));
					sqlite3VdbeGoto(v, (int)(iOk));
					sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
					sqlite3VdbeJumpHere(v, (int)(iMustBeInt));
					sqlite3ReleaseTempReg(pParse, (int)(regTemp));
				}
				else
				{
					int nCol = (int)(pFKey.nCol);
					int regTemp = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
					int regRec = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(101), (int)(iCur), (int)(pIdx.tnum), (int)(iDb));
					sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
					for (i = (int)(0); (i) < (nCol); i++)
					{
						sqlite3VdbeAddOp2(v, (int)(79), (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + 1 + regData), (int)(regTemp + i));
					}

					if (((pTab) == (pFKey.pFrom)) && ((nIncr) == (1)))
					{
						int iJump = (int)(sqlite3VdbeCurrentAddr(v) + nCol + 1);
						for (i = (int)(0); (i) < (nCol); i++)
						{
							int iChild = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(aiCol[i])) + 1 + regData);
							int iParent = (int)(1 + regData);
							iParent += (int)(sqlite3TableColumnToStorage(pIdx.pTable, (short)(pIdx.aiColumn[i])));


							if ((pIdx.aiColumn[i]) == (pTab.iPKey))
							{
								iParent = (int)(regData);
							}

							sqlite3VdbeAddOp3(v, (int)(52), (int)(iChild), (int)(iJump), (int)(iParent));
							sqlite3VdbeChangeP5(v, (ushort)(0x10));
						}

						sqlite3VdbeGoto(v, (int)(iOk));
					}

					sqlite3VdbeAddOp4(v, (int)(96), (int)(regTemp), (int)(nCol), (int)(regRec), sqlite3IndexAffinityStr(pParse.db, pIdx), (int)(nCol));
					sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iCur), (int)(iOk), (int)(regRec), (int)(0));
					sqlite3ReleaseTempReg(pParse, (int)(regRec));
					sqlite3ReleaseTempRange(pParse, (int)(regTemp), (int)(nCol));
				}
			}

			if ((((pFKey.isDeferred == 0) && ((pParse.db.flags & 0x00080000) == 0)) && (pParse.pToplevel == null)) && (pParse.isMultiWrite == 0))
			{

				sqlite3HaltConstraint(pParse, (int)(19 | (3 << 8)), (int)(2), null, (sbyte)(-1), (byte)(4));
			}
			else
			{
				if (((nIncr) > (0)) && ((pFKey.isDeferred) == (0)))
				{
					sqlite3MayAbort(pParse);
				}

				sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(nIncr));
			}

			sqlite3VdbeResolveLabel(v, (int)(iOk));
			sqlite3VdbeAddOp1(v, (int)(121), (int)(iCur));
		}
		public static int fkParentIsModified(Table pTab, FKey p, int* aChange, int bChngRowid)
		{
			int i = 0;
			for (i = (int)(0); (i) < (p.nCol); i++)
			{
				sbyte* zKey = p.aCol[i].zCol;
				int iKey = 0;
				for (iKey = (int)(0); (iKey) < (pTab.nCol); iKey++)
				{
					if (((aChange[iKey]) >= (0)) || (((iKey) == (pTab.iPKey)) && ((bChngRowid) != 0)))
					{
						Column* pCol = &pTab.aCol[iKey];
						if ((zKey) != null)
						{
							if ((0) == (sqlite3StrICmp(pCol->zCnName, zKey)))
								return (int)(1);
						}
						else if ((pCol->colFlags & 0x0001) != 0)
						{
							return (int)(1);
						}
					}
				}
			}

			return (int)(0);
		}
		public static void fkScanChildren(Parse pParse, SrcList pSrc, Table pTab, Index pIdx, FKey pFKey, int* aiCol, int regData, int nIncr)
		{
			sqlite3 db = pParse.db;
			int i = 0;
			Expr pWhere = null;
			NameContext sNameContext = new NameContext();
			WhereInfo pWInfo;
			int iFkIfZero = (int)(0);
			Vdbe v = sqlite3GetVdbe(pParse);




			if ((nIncr) < (0))
			{
				iFkIfZero = (int)(sqlite3VdbeAddOp2(v, (int)(48), (int)(pFKey.isDeferred), (int)(0)));
			}

			for (i = (int)(0); (i) < (pFKey.nCol); i++)
			{
				Expr pLeft;
				Expr pRight;
				Expr pEq;
				short iCol = 0;
				sbyte* zCol;
				iCol = (short)(pIdx ? pIdx.aiColumn[i] : -1);
				pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(iCol));
				iCol = (short)((aiCol) != 0 ? aiCol[i] : pFKey.aCol[0].iFrom);

				zCol = pFKey.pFrom.aCol[iCol].zCnName;
				pRight = sqlite3Expr(db, (int)(59), zCol);
				pEq = sqlite3PExpr(pParse, (int)(53), pLeft, pRight);
				pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
			}

			if (((pTab) == (pFKey.pFrom)) && ((nIncr) > (0)))
			{
				Expr pNe;
				Expr pLeft;
				Expr pRight;
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(-1));
					pRight = exprTableColumn(db, pTab, (int)(pSrc.a[0].iCursor), (short)(-1));
					pNe = sqlite3PExpr(pParse, (int)(52), pLeft, pRight);
				}
				else
				{
					Expr pEq;
					Expr pAll = null;

					for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
					{
						short iCol = (short)(pIdx.aiColumn[i]);

						pLeft = exprTableRegister(pParse, pTab, (int)(regData), (short)(iCol));
						pRight = sqlite3Expr(db, (int)(59), pTab.aCol[iCol].zCnName);
						pEq = sqlite3PExpr(pParse, (int)(45), pLeft, pRight);
						pAll = sqlite3ExprAnd(pParse, pAll, pEq);
					}

					pNe = sqlite3PExpr(pParse, (int)(19), pAll, null);
				}

				pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
			}

			CRuntime.memset(sNameContext, (int)(0), (ulong)(sizeof(NameContext)));
			sNameContext.pSrcList = pSrc;
			sNameContext.pParse = pParse;
			sqlite3ResolveExprNames(sNameContext, pWhere);
			if ((pParse.nErr) == (0))
			{
				pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, null, null, null, (ushort)(0), (int)(0));
				sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(nIncr));
				if ((pWInfo) != null)
				{
					sqlite3WhereEnd(pWInfo);
				}
			}

			sqlite3ExprDelete(db, pWhere);
			if ((iFkIfZero) != 0)
			{
				sqlite3VdbeJumpHereOrPopInst(v, (int)(iFkIfZero));
			}
		}
		public static void fkTriggerDelete(sqlite3 dbMem, Trigger p)
		{
			if ((p) != null)
			{
				TriggerStep pStep = p.step_list;
				sqlite3ExprDelete(dbMem, pStep.pWhere);
				sqlite3ExprListDelete(dbMem, pStep.pExprList);
				sqlite3SelectDelete(dbMem, pStep.pSelect);
				sqlite3ExprDelete(dbMem, p.pWhen);
				sqlite3DbFree(dbMem, p);
			}
		}
		public static int flattenSubquery(Parse pParse, Select p, int iFrom, int isAgg)
		{
			sbyte* zSavedAuthContext = pParse.zAuthContext;
			Select pParent;
			Select pSub;
			Select pSub1;
			SrcList pSrc;
			SrcList pSubSrc;
			int iParent = 0;
			int iNewParent = (int)(-1);
			int isLeftJoin = (int)(0);
			int i = 0;
			Expr pWhere;
			SrcItem pSubitem;
			sqlite3 db = pParse.db;
			Walker w = new Walker();
			int* aCsrMap = null;


			if ((((db).dbOptFlags & (0x00000001)) != 0))
				return (int)(0);
			pSrc = p.pSrc;

			pSubitem = pSrc.a[iFrom];
			iParent = (int)(pSubitem.iCursor);
			pSub = pSubitem.pSelect;

			if (((p.pWin) != null) || ((pSub.pWin) != null))
				return (int)(0);
			pSubSrc = pSub.pSrc;

			if (((pSub.pLimit) != null) && ((p.pLimit) != null))
				return (int)(0);
			if (((pSub.pLimit) != null) && ((pSub.pLimit.pRight) != null))
				return (int)(0);
			if (((p.selFlags & 0x0000100) != 0) && ((pSub.pLimit) != null))
			{
				return (int)(0);
			}

			if ((pSubSrc.nSrc) == (0))
				return (int)(0);
			if ((pSub.selFlags & 0x0000001) != 0)
				return (int)(0);
			if (((pSub.pLimit) != null) && (((pSrc.nSrc) > (1)) || ((isAgg) != 0)))
			{
				return (int)(0);
			}

			if (((p.pOrderBy) != null) && ((pSub.pOrderBy) != null))
			{
				return (int)(0);
			}

			if (((isAgg) != 0) && ((pSub.pOrderBy) != null))
				return (int)(0);
			if (((pSub.pLimit) != null) && ((p.pWhere) != null))
				return (int)(0);
			if (((pSub.pLimit) != null) && ((p.selFlags & 0x0000001) != 0))
			{
				return (int)(0);
			}

			if ((pSub.selFlags & (0x0002000)) != 0)
			{
				return (int)(0);
			}

			if ((pSubitem.fg.jointype & 0x0020) != 0)
			{
				isLeftJoin = (int)(1);
				if (((((pSubSrc.nSrc) > (1)) || ((isAgg) != 0)) || (((pSubSrc.a[0].pTab).eTabType) == (1))) || ((p.selFlags & 0x0000001) != 0))
				{
					return (int)(0);
				}
			}

			if ((pSub.pPrior) != null)
			{
				if ((pSub.pOrderBy) != null)
				{
					return (int)(0);
				}

				if ((((isAgg) != 0) || ((p.selFlags & 0x0000001) != 0)) || ((isLeftJoin) > (0)))
				{
					return (int)(0);
				}

				for (pSub1 = pSub; pSub1; pSub1 = pSub1.pPrior)
				{



					if (((((pSub1.selFlags & (0x0000001 | 0x0000008)) != 0) || (((pSub1.pPrior) != null) && (pSub1.op != 135))) || ((pSub1.pSrc.nSrc) < (1))) || ((pSub1.pWin) != null))
					{
						return (int)(0);
					}
				}

				if ((p.pOrderBy) != null)
				{
					int ii = 0;
					for (ii = (int)(0); (ii) < (p.pOrderBy.nExpr); ii++)
					{
						if ((p.pOrderBy.a[ii].u.x.iOrderByCol) == (0))
							return (int)(0);
					}
				}

				if ((p.selFlags & 0x0002000) != 0)
					return (int)(0);
				if ((pSrc.nSrc) > (1))
				{
					if ((pParse.nSelect) > (500))
						return (int)(0);
					aCsrMap = sqlite3DbMallocZero(db, (ulong)(((long)(pParse.nTab) + 1) * sizeof(int)));
					if ((aCsrMap) != null)
						aCsrMap[0] = (int)(pParse.nTab);
				}
			}

			pParse.zAuthContext = pSubitem.zName;
			sqlite3AuthCheck(pParse, (int)(21), null, null, null);
			pParse.zAuthContext = zSavedAuthContext;
			pSub1 = pSubitem.pSelect;
			sqlite3DbFree(db, pSubitem.zDatabase);
			sqlite3DbFree(db, pSubitem.zName);
			sqlite3DbFree(db, pSubitem.zAlias);
			pSubitem.zDatabase = null;
			pSubitem.zName = null;
			pSubitem.zAlias = null;
			pSubitem.pSelect = null;

			for (pSub = pSub.pPrior; pSub; pSub = pSub.pPrior)
			{
				Select pNew;
				ExprList pOrderBy = p.pOrderBy;
				Expr pLimit = p.pLimit;
				Select pPrior = p.pPrior;
				Table pItemTab = pSubitem.pTab;
				pSubitem.pTab = null;
				p.pOrderBy = null;
				p.pPrior = null;
				p.pLimit = null;
				pNew = sqlite3SelectDup(db, p, (int)(0));
				p.pLimit = pLimit;
				p.pOrderBy = pOrderBy;
				p.op = (byte)(135);
				pSubitem.pTab = pItemTab;
				if ((pNew) == (null))
				{
					p.pPrior = pPrior;
				}
				else
				{
					pNew.selId = (uint)(++pParse.nSelect);
					if (((aCsrMap) != null) && ((db.mallocFailed) == (0)))
					{
						renumberCursors(pParse, pNew, (int)(iFrom), aCsrMap);
					}

					pNew.pPrior = pPrior;
					if ((pPrior) != null)
						pPrior.pNext = pNew;
					pNew.pNext = p;
					p.pPrior = pNew;
				}


			}

			sqlite3DbFree(db, aCsrMap);
			if ((db.mallocFailed) != 0)
			{
				pSubitem.pSelect = pSub1;
				return (int)(1);
			}

			if ((pSubitem.pTab != null))
			{
				Table pTabToDel = pSubitem.pTab;
				if ((pTabToDel.nTabRef) == (1))
				{
					Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
					sqlite3ParserAddCleanup(pToplevel, sqlite3DeleteTable, pTabToDel);
				}
				else
				{
					pTabToDel.nTabRef--;
				}

				pSubitem.pTab = null;
			}

			pSub = pSub1;
			for (pParent = p; pParent; pParent = pParent.pPrior, pSub = pSub.pPrior)
			{
				int nSubSrc = 0;
				byte jointype = (byte)(0);

				pSubSrc = pSub.pSrc;
				nSubSrc = (int)(pSubSrc.nSrc);
				pSrc = pParent.pSrc;
				if ((pParent) == (p))
				{
					jointype = (byte)(pSubitem.fg.jointype);
				}

				if ((nSubSrc) > (1))
				{
					pSrc = sqlite3SrcListEnlarge(pParse, pSrc, (int)(nSubSrc - 1), (int)(iFrom + 1));
					if ((pSrc) == (null))
						break;
					pParent.pSrc = pSrc;
				}

				for (i = (int)(0); (i) < (nSubSrc); i++)
				{
					sqlite3IdListDelete(db, pSrc.a[i + iFrom].pUsing);

					pSrc.a[i + iFrom] = (SrcItem)(pSubSrc.a[i]);
					iNewParent = (int)(pSubSrc.a[i].iCursor);
					CRuntime.memset(pSubSrc.a[i], (int)(0), (ulong)(sizeof(SrcItem)));
				}

				pSrc.a[iFrom].fg.jointype = (byte)(jointype);
				if (((pSub.pOrderBy) != null) && ((pParent.selFlags & 0x0400000) == (0)))
				{
					ExprList pOrderBy = pSub.pOrderBy;
					for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
					{
						pOrderBy.a[i].u.x.iOrderByCol = (ushort)(0);
					}


					pParent.pOrderBy = pOrderBy;
					pSub.pOrderBy = null;
				}

				pWhere = pSub.pWhere;
				pSub.pWhere = null;
				if ((isLeftJoin) > (0))
				{
					sqlite3SetJoinExpr(pWhere, (int)(iNewParent));
				}

				if ((pWhere) != null)
				{
					if ((pParent.pWhere) != null)
					{
						pParent.pWhere = sqlite3PExpr(pParse, (int)(44), pWhere, pParent.pWhere);
					}
					else
					{
						pParent.pWhere = pWhere;
					}
				}

				if ((db.mallocFailed) == (0))
				{
					SubstContext x = new SubstContext();
					x.pParse = pParse;
					x.iTable = (int)(iParent);
					x.iNewTable = (int)(iNewParent);
					x.isLeftJoin = (int)(isLeftJoin);
					x.pEList = pSub.pEList;
					substSelect(x, pParent, (int)(0));
				}

				pParent.selFlags |= (uint)(pSub.selFlags & 0x0000100);

				if ((pSub.pLimit) != null)
				{
					pParent.pLimit = pSub.pLimit;
					pSub.pLimit = null;
				}

				for (i = (int)(0); (i) < (nSubSrc); i++)
				{
					recomputeColumnsUsed(pParent, pSrc.a[i + iFrom]);
				}
			}

			sqlite3AggInfoPersistWalkerInit(w, pParse);
			sqlite3WalkSelect(w, pSub1);
			sqlite3SelectDelete(db, pSub1);
			return (int)(1);
		}
		public static void freeEphemeralFunction(sqlite3 db, FuncDef pDef)
		{
			if ((pDef.funcFlags & 0x0010) != 0)
			{
				sqlite3DbFreeNN(db, pDef);
			}
		}
		public static void freeIndexInfo(sqlite3 db, sqlite3_index_info* pIdxInfo)
		{
			HiddenIndexInfo pHidden;
			int i = 0;

			pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);


			for (i = (int)(0); (i) < (pIdxInfo->nConstraint); i++)
			{
				sqlite3ValueFree(pHidden.aRhs[i]);
				pHidden.aRhs[i] = null;
			}

			sqlite3DbFree(db, pIdxInfo);
		}
		public static void freeP4(sqlite3 db, int p4type, void* p4)
		{

			switch (p4type)
			{
				case (-16):
					{
						freeP4FuncCtx(db, (sqlite3_context)(p4));
						break;
					}

				case (-13):
				case (-14):
				case (-7):
				case (-17):
				case (-15):
					{
						sqlite3DbFree(db, p4);
						break;
					}

				case (-9):
					{
						if ((db.pnBytesFreed) == (null))
							sqlite3KeyInfoUnref((KeyInfo)(p4));
						break;
					}

				case (-8):
					{
						freeEphemeralFunction(db, (FuncDef)(p4));
						break;
					}

				case (-11):
					{
						if ((db.pnBytesFreed) == (null))
						{
							sqlite3ValueFree((sqlite3_value)(p4));
						}
						else
						{
							freeP4Mem(db, (sqlite3_value)(p4));
						}

						break;
					}

				case (-12):
					{
						if ((db.pnBytesFreed) == (null))
							sqlite3VtabUnlock((VTable)(p4));
						break;
					}
			}
		}
		public static void freeP4FuncCtx(sqlite3 db, sqlite3_context p)
		{
			freeEphemeralFunction(db, p.pFunc);
			sqlite3DbFreeNN(db, p);
		}
		public static void freeP4Mem(sqlite3 db, sqlite3_value p)
		{
			if ((p.szMalloc) != 0)
				sqlite3DbFree(db, p.zMalloc);
			sqlite3DbFreeNN(db, p);
		}
		public static void freePage(MemPage pPage, int* pRC)
		{
			if ((*pRC) == (0))
			{
				*pRC = (int)(freePage2(pPage.pBt, pPage, (uint)(pPage.pgno)));
			}
		}
		public static int freePage2(BtShared pBt, MemPage pMemPage, uint iPage)
		{
			MemPage pTrunk = null;
			uint iTrunk = (uint)(0);
			MemPage pPage1 = pBt.pPage1;
			MemPage pPage;
			int rc = 0;
			uint nFree = 0;



			if (((iPage) < (2)) || ((iPage) > (pBt.nPage)))
			{
				return (int)(sqlite3CorruptError((int)(72570)));
			}

			if ((pMemPage) != null)
			{
				pPage = pMemPage;
				sqlite3PagerRef(pPage.pDbPage);
			}
			else
			{
				pPage = btreePageLookup(pBt, (uint)(iPage));
			}

			rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
			if ((rc) != 0)
				goto freepage_out;
			nFree = (uint)(sqlite3Get4byte(&pPage1.aData[36]));
			sqlite3Put4byte(&pPage1.aData[36], (uint)(nFree + 1));
			if ((pBt.btsFlags & 0x0004) != 0)
			{
				if (((pPage == null) && ((rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0)))) != 0)) || ((rc = (int)(sqlite3PagerWrite(pPage.pDbPage))) != 0))
				{
					goto freepage_out;
				}

				CRuntime.memset(pPage.aData, (int)(0), (ulong)(pPage.pBt.pageSize));
			}

			if ((pBt.autoVacuum) != 0)
			{
				ptrmapPut(pBt, (uint)(iPage), (byte)(2), (uint)(0), &rc);
				if ((rc) != 0)
					goto freepage_out;
			}

			if (nFree != 0)
			{
				uint nLeaf = 0;
				iTrunk = (uint)(sqlite3Get4byte(&pPage1.aData[32]));
				if ((iTrunk) > (btreePagecount(pBt)))
				{
					rc = (int)(sqlite3CorruptError((int)(72617)));
					goto freepage_out;
				}

				rc = (int)(btreeGetPage(pBt, (uint)(iTrunk), pTrunk, (int)(0)));
				if (rc != 0)
				{
					goto freepage_out;
				}

				nLeaf = (uint)(sqlite3Get4byte(&pTrunk.aData[4]));

				if ((nLeaf) > (pBt.usableSize / 4 - 2))
				{
					rc = (int)(sqlite3CorruptError((int)(72628)));
					goto freepage_out;
				}

				if ((nLeaf) < (pBt.usableSize / 4 - 8))
				{
					rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
					if ((rc) == (0))
					{
						sqlite3Put4byte(&pTrunk.aData[4], (uint)(nLeaf + 1));
						sqlite3Put4byte(&pTrunk.aData[8 + nLeaf * 4], (uint)(iPage));
						if (((pPage) != null) && ((pBt.btsFlags & 0x0004) == (0)))
						{
							sqlite3PagerDontWrite(pPage.pDbPage);
						}

						rc = (int)(btreeSetHasContent(pBt, (uint)(iPage)));
					}

					goto freepage_out;
				}
			}

			if (((pPage) == (null)) && (0 != (rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0))))))
			{
				goto freepage_out;
			}

			rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
			if (rc != 0)
			{
				goto freepage_out;
			}

			sqlite3Put4byte(pPage.aData, (uint)(iTrunk));
			sqlite3Put4byte(&pPage.aData[4], (uint)(0));
			sqlite3Put4byte(&pPage1.aData[32], (uint)(iPage));
		freepage_out:
			; if ((pPage) != null) { pPage.isInit = (byte)(0); }
			releasePage(pPage);
			releasePage(pTrunk);
			return (int)(rc);
		}
		public static int freeSpace(MemPage pPage, ushort iStart, ushort iSize)
		{
			ushort iPtr = 0;
			ushort iFreeBlk = 0;
			byte hdr = 0;
			byte nFrag = (byte)(0);
			ushort iOrigSize = (ushort)(iSize);
			ushort x = 0;
			uint iEnd = (uint)(iStart + iSize);
			byte* data = pPage.aData;







			hdr = (byte)(pPage.hdrOffset);
			iPtr = (ushort)(hdr + 1);
			if (((data[iPtr + 1]) == (0)) && ((data[iPtr]) == (0)))
			{
				iFreeBlk = (ushort)(0);
			}
			else
			{
				while ((iFreeBlk = (ushort)((&data[iPtr])[0] << 8 | (&data[iPtr])[1])) < (iStart))
				{
					if ((iFreeBlk) < (iPtr + 4))
					{
						if ((iFreeBlk) == (0))
							break;
						return (int)(sqlite3CorruptError((int)(67933)));
					}

					iPtr = (ushort)(iFreeBlk);
				}

				if ((iFreeBlk) > (pPage.pBt.usableSize - 4))
				{
					return (int)(sqlite3CorruptError((int)(67938)));
				}


				if (((iFreeBlk) != 0) && ((iEnd + 3) >= (iFreeBlk)))
				{
					nFrag = (byte)(iFreeBlk - iEnd);
					if ((iEnd) > (iFreeBlk))
						return (int)(sqlite3CorruptError((int)(67950)));
					iEnd = (uint)(iFreeBlk + ((&data[iFreeBlk + 2])[0] << 8 | (&data[iFreeBlk + 2])[1]));
					if ((iEnd) > (pPage.pBt.usableSize))
					{
						return (int)(sqlite3CorruptError((int)(67953)));
					}

					iSize = (ushort)(iEnd - iStart);
					iFreeBlk = (ushort)((&data[iFreeBlk])[0] << 8 | (&data[iFreeBlk])[1]);
				}

				if ((iPtr) > (hdr + 1))
				{
					int iPtrEnd = (int)(iPtr + ((&data[iPtr + 2])[0] << 8 | (&data[iPtr + 2])[1]));
					if ((iPtrEnd + 3) >= (iStart))
					{
						if ((iPtrEnd) > (iStart))
							return (int)(sqlite3CorruptError((int)(67966)));
						nFrag += (byte)(iStart - iPtrEnd);
						iSize = (ushort)(iEnd - iPtr);
						iStart = (ushort)(iPtr);
					}
				}

				if ((nFrag) > (data[hdr + 7]))
					return (int)(sqlite3CorruptError((int)(67972)));
				data[hdr + 7] -= (byte)(nFrag);
			}

			x = (ushort)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);
			if ((iStart) <= (x))
			{
				if ((iStart) < (x))
					return (int)(sqlite3CorruptError((int)(67980)));
				if (iPtr != hdr + 1)
					return (int)(sqlite3CorruptError((int)(67981)));
				((&data[hdr + 1])[0] = ((byte)((iFreeBlk) >> 8)), (&data[hdr + 1])[1] = ((byte)(iFreeBlk)));
				((&data[hdr + 5])[0] = ((byte)((iEnd) >> 8)), (&data[hdr + 5])[1] = ((byte)(iEnd)));
			}
			else
			{
				((&data[iPtr])[0] = ((byte)((iStart) >> 8)), (&data[iPtr])[1] = ((byte)(iStart)));
			}

			if ((pPage.pBt.btsFlags & 0x000c) != 0)
			{
				CRuntime.memset(&data[iStart], (int)(0), (ulong)(iSize));
			}

			((&data[iStart])[0] = ((byte)((iFreeBlk) >> 8)), (&data[iStart])[1] = ((byte)(iFreeBlk)));
			((&data[iStart + 2])[0] = ((byte)((iSize) >> 8)), (&data[iStart + 2])[1] = ((byte)(iSize)));
			pPage.nFree += (int)(iOrigSize);
			return (int)(0);
		}
		public static void freeTempSpace(BtShared pBt)
		{
			if ((pBt.pTmpSpace) != null)
			{
				pBt.pTmpSpace -= 4;
				sqlite3PageFree(pBt.pTmpSpace);
				pBt.pTmpSpace = null;
			}
		}
		public static void functionDestroy(sqlite3 db, FuncDef p)
		{
			FuncDestructor pDestructor;

			pDestructor = p.u.pDestructor;
			if ((pDestructor) != null)
			{
				pDestructor.nRef--;
				if ((pDestructor.nRef) == (0))
				{
					pDestructor.xDestroy(pDestructor.pUserData);
					sqlite3DbFree(db, pDestructor);
				}
			}
		}
		public static void gatherSelectWindows(Select p)
		{
			Walker w = new Walker();
			w.xExprCallback = gatherSelectWindowsCallback;
			w.xSelectCallback = gatherSelectWindowsSelectCallback;
			w.xSelectCallback2 = null;
			w.pParse = null;
			w.u.pSelect = p;
			sqlite3WalkSelect(w, p);
		}
		public static int gatherSelectWindowsCallback(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (172)) && (((pExpr).flags & (0x1000000)) != 0))
			{
				Select pSelect = pWalker.u.pSelect;
				Window pWin = pExpr.y.pWin;



				sqlite3WindowLink(pSelect, pWin);
			}

			return (int)(0);
		}
		public static int gatherSelectWindowsSelectCallback(Walker pWalker, Select p)
		{
			return (int)((p) == (pWalker.u.pSelect) ? 0 : 1);
		}
		public static void generateColumnTypes(Parse pParse, SrcList pTabList, ExprList pEList)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			NameContext sNC = new NameContext();
			sNC.pSrcList = pTabList;
			sNC.pParse = pParse;
			sNC.pNext = null;
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				Expr p = pEList.a[i].pExpr;
				sbyte* zType;
				zType = columnTypeImpl(sNC, p);
				sqlite3VdbeSetColName(v, (int)(i), (int)(1), zType, ((Void(Void * ))(-1)));
			}
		}
		public static int generateOutputSubroutine(Parse pParse, Select p, SelectDest pIn, SelectDest pDest, int regReturn, int regPrev, KeyInfo pKeyInfo, int iBreak)
		{
			Vdbe v = pParse.pVdbe;
			int iContinue = 0;
			int addr = 0;
			addr = (int)(sqlite3VdbeCurrentAddr(v));
			iContinue = (int)(sqlite3VdbeMakeLabel(pParse));
			if ((regPrev) != 0)
			{
				int addr1 = 0;
				int addr2 = 0;
				addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regPrev)));
				addr2 = (int)(sqlite3VdbeAddOp4(v, (int)(89), (int)(pIn.iSdst), (int)(regPrev + 1), (int)(pIn.nSdst), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9)));
				sqlite3VdbeAddOp3(v, (int)(16), (int)(addr2 + 2), (int)(iContinue), (int)(addr2 + 2));
				sqlite3VdbeJumpHere(v, (int)(addr1));
				sqlite3VdbeAddOp3(v, (int)(79), (int)(pIn.iSdst), (int)(regPrev + 1), (int)(pIn.nSdst - 1));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regPrev));
			}

			if ((pParse.db.mallocFailed) != 0)
				return (int)(0);
			codeOffset(v, (int)(p.iOffset), (int)(iContinue));


			switch (pDest.eDest)
			{
				case 12:
					{
						int r1 = (int)(sqlite3GetTempReg(pParse));
						int r2 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(pIn.iSdst), (int)(pIn.nSdst), (int)(r1));
						sqlite3VdbeAddOp2(v, (int)(126), (int)(pDest.iSDParm), (int)(r2));
						sqlite3VdbeAddOp3(v, (int)(127), (int)(pDest.iSDParm), (int)(r1), (int)(r2));
						sqlite3VdbeChangeP5(v, (ushort)(0x08));
						sqlite3ReleaseTempReg(pParse, (int)(r2));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						break;
					}

				case 11:
					{
						int r1 = 0;
						r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp4(v, (int)(96), (int)(pIn.iSdst), (int)(pIn.nSdst), (int)(r1), pDest.zAffSdst, (int)(pIn.nSdst));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(pDest.iSDParm), (int)(r1), (int)(pIn.iSdst), (int)(pIn.nSdst));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						break;
					}

				case 10:
					{
						sqlite3ExprCodeMove(pParse, (int)(pIn.iSdst), (int)(pDest.iSDParm), (int)(pIn.nSdst));
						break;
					}

				case 13:
					{
						if ((pDest.iSdst) == (0))
						{
							pDest.iSdst = (int)(sqlite3GetTempRange(pParse, (int)(pIn.nSdst)));
							pDest.nSdst = (int)(pIn.nSdst);
						}

						sqlite3ExprCodeMove(pParse, (int)(pIn.iSdst), (int)(pDest.iSdst), (int)(pIn.nSdst));
						sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
						break;
					}

				default:
					{

						sqlite3VdbeAddOp2(v, (int)(83), (int)(pIn.iSdst), (int)(pIn.nSdst));
						break;
					}
			}

			if ((p.iLimit) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(60), (int)(p.iLimit), (int)(iBreak));
			}

			sqlite3VdbeResolveLabel(v, (int)(iContinue));
			sqlite3VdbeAddOp1(v, (int)(67), (int)(regReturn));
			return (int)(addr);
		}
		public static void generateSortTail(Parse pParse, Select p, SortCtx pSort, int nColumn, SelectDest pDest)
		{
			Vdbe v = pParse.pVdbe;
			int addrBreak = (int)(pSort.labelDone);
			int addrContinue = (int)(sqlite3VdbeMakeLabel(pParse));
			int addr = 0;
			int addrOnce = (int)(0);
			int iTab = 0;
			ExprList pOrderBy = pSort.pOrderBy;
			int eDest = (int)(pDest.eDest);
			int iParm = (int)(pDest.iSDParm);
			int regRow = 0;
			int regRowid = 0;
			int iCol = 0;
			int nKey = 0;
			int iSortTab = 0;
			int i = 0;
			int bSeq = 0;
			int nRefKey = (int)(0);
			ExprList_item* aOutEx = p.pEList.a;

			if ((pSort.labelBkOut) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(12), (int)(pSort.regReturn), (int)(pSort.labelBkOut));
				sqlite3VdbeGoto(v, (int)(addrBreak));
				sqlite3VdbeResolveLabel(v, (int)(pSort.labelBkOut));
			}

			iTab = (int)(pSort.iECursor);
			if ((((eDest) == (9)) || ((eDest) == (13))) || ((eDest) == (10)))
			{
				if (((eDest) == (10)) && ((p.iOffset) != 0))
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pDest.iSdst));
				}

				regRowid = (int)(0);
				regRow = (int)(pDest.iSdst);
			}
			else
			{
				regRowid = (int)(sqlite3GetTempReg(pParse));
				if (((eDest) == (12)) || ((eDest) == (14)))
				{
					regRow = (int)(sqlite3GetTempReg(pParse));
					nColumn = (int)(0);
				}
				else
				{
					regRow = (int)(sqlite3GetTempRange(pParse, (int)(nColumn)));
				}
			}

			nKey = (int)(pOrderBy.nExpr - pSort.nOBSat);
			if ((pSort.sortFlags & 0x01) != 0)
			{
				int regSortOut = (int)(++pParse.nMem);
				iSortTab = (int)(pParse.nTab++);
				if ((pSort.labelBkOut) != 0)
				{
					addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				}

				sqlite3VdbeAddOp3(v, (int)(120), (int)(iSortTab), (int)(regSortOut), (int)(nKey + 1 + nColumn + nRefKey));
				if ((addrOnce) != 0)
					sqlite3VdbeJumpHere(v, (int)(addrOnce));
				addr = (int)(1 + sqlite3VdbeAddOp2(v, (int)(36), (int)(iTab), (int)(addrBreak)));
				codeOffset(v, (int)(p.iOffset), (int)(addrContinue));
				sqlite3VdbeAddOp3(v, (int)(132), (int)(iTab), (int)(regSortOut), (int)(iSortTab));
				bSeq = (int)(0);
			}
			else
			{
				addr = (int)(1 + sqlite3VdbeAddOp2(v, (int)(37), (int)(iTab), (int)(addrBreak)));
				codeOffset(v, (int)(p.iOffset), (int)(addrContinue));
				iSortTab = (int)(iTab);
				bSeq = (int)(1);
			}

			for (i = (int)(0), iCol = (int)(nKey + bSeq - 1); (i) < (nColumn); i++)
			{
				if ((aOutEx[i].u.x.iOrderByCol) == (0))
					iCol++;
			}

			for (i = (int)(nColumn - 1); (i) >= (0); i--)
			{
				{
					int iRead = 0;
					if ((aOutEx[i].u.x.iOrderByCol) != 0)
					{
						iRead = (int)(aOutEx[i].u.x.iOrderByCol - 1);
					}
					else
					{
						iRead = (int)(iCol--);
					}

					sqlite3VdbeAddOp3(v, (int)(93), (int)(iSortTab), (int)(iRead), (int)(regRow + i));
				}
			}

			switch (eDest)
			{
				case 14:
				case 12:
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iSortTab), (int)(nKey + bSeq), (int)(regRow));
						sqlite3VdbeAddOp2(v, (int)(126), (int)(iParm), (int)(regRowid));
						sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(regRow), (int)(regRowid));
						sqlite3VdbeChangeP5(v, (ushort)(0x08));
						break;
					}

				case 11:
					{

						sqlite3VdbeAddOp4(v, (int)(96), (int)(regRow), (int)(nColumn), (int)(regRowid), pDest.zAffSdst, (int)(nColumn));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(regRowid), (int)(regRow), (int)(nColumn));
						break;
					}

				case 10:
					{
						break;
					}

				case 15:
					{
						int i2 = (int)(pDest.iSDParm2);
						int r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regRow + ((i2) < (0))), (int)(nColumn - ((i2) < (0))), (int)(r1));
						if ((i2) < (0))
						{
							sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(regRow));
						}
						else
						{
							sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regRow), (int)(i2));
						}

						break;
					}

				default:
					{

						if ((eDest) == (9))
						{
							sqlite3VdbeAddOp2(v, (int)(83), (int)(pDest.iSdst), (int)(nColumn));
						}
						else
						{
							sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
						}

						break;
					}
			}

			if ((regRowid) != 0)
			{
				if ((eDest) == (11))
				{
					sqlite3ReleaseTempRange(pParse, (int)(regRow), (int)(nColumn));
				}
				else
				{
					sqlite3ReleaseTempReg(pParse, (int)(regRow));
				}

				sqlite3ReleaseTempReg(pParse, (int)(regRowid));
			}

			sqlite3VdbeResolveLabel(v, (int)(addrContinue));
			if ((pSort.sortFlags & 0x01) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(3), (int)(iTab), (int)(addr));
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addr));
			}

			if ((pSort.regReturn) != 0)
				sqlite3VdbeAddOp1(v, (int)(67), (int)(pSort.regReturn));
			sqlite3VdbeResolveLabel(v, (int)(addrBreak));
		}
		public static void generateWithRecursiveQuery(Parse pParse, Select p, SelectDest pDest)
		{
			SrcList pSrc = p.pSrc;
			int nCol = (int)(p.pEList.nExpr);
			Vdbe v = pParse.pVdbe;
			Select pSetup;
			Select pFirstRec;
			int addrTop = 0;
			int addrCont = 0; int addrBreak = 0;
			int iCurrent = (int)(0);
			int regCurrent = 0;
			int iQueue = 0;
			int iDistinct = (int)(0);
			int eDest = (int)(8);
			SelectDest destQueue = new SelectDest();
			int i = 0;
			int rc = 0;
			ExprList pOrderBy;
			Expr pLimit;
			int regLimit = 0; int regOffset = 0;
			if ((p.pWin) != null)
			{
				sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
				return;
			}

			if ((sqlite3AuthCheck(pParse, (int)(33), null, null, null)) != 0)
				return;
			addrBreak = (int)(sqlite3VdbeMakeLabel(pParse));
			p.nSelectRow = (short)(320);
			computeLimitRegisters(pParse, p, (int)(addrBreak));
			pLimit = p.pLimit;
			regLimit = (int)(p.iLimit);
			regOffset = (int)(p.iOffset);
			p.pLimit = null;
			p.iLimit = (int)(p.iOffset = (int)(0));
			pOrderBy = p.pOrderBy;
			for (i = (int)(0); ((i) < (pSrc.nSrc)); i++)
			{
				if ((pSrc.a[i].fg.isRecursive) != 0)
				{
					iCurrent = (int)(pSrc.a[i].iCursor);
					break;
				}
			}

			iQueue = (int)(pParse.nTab++);
			if ((p.op) == (134))
			{
				eDest = (int)(pOrderBy ? 6 : 5);
				iDistinct = (int)(pParse.nTab++);
			}
			else
			{
				eDest = (int)(pOrderBy ? 7 : 8);
			}

			sqlite3SelectDestInit(destQueue, (int)(eDest), (int)(iQueue));
			regCurrent = (int)(++pParse.nMem);
			sqlite3VdbeAddOp3(v, (int)(120), (int)(iCurrent), (int)(regCurrent), (int)(nCol));
			if ((pOrderBy) != null)
			{
				KeyInfo pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, (int)(1));
				sqlite3VdbeAddOp4(v, (int)(116), (int)(iQueue), (int)(pOrderBy.nExpr + 2), (int)(0), (sbyte*)(pKeyInfo), (int)(-9));
				destQueue.pOrderBy = pOrderBy;
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(116), (int)(iQueue), (int)(nCol));
			}

			if ((iDistinct) != 0)
			{
				p.addrOpenEphm[0] = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iDistinct), (int)(0)));
				p.selFlags |= (uint)(0x0000020);
			}

			p.pOrderBy = null;
			for (pFirstRec = p; (pFirstRec != null); pFirstRec = pFirstRec.pPrior)
			{
				if ((pFirstRec.selFlags & 0x0000008) != 0)
				{
					sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
					goto end_of_recursive_query;
				}

				pFirstRec.op = (byte)(135);
				if ((pFirstRec.pPrior.selFlags & 0x0002000) == (0))
					break;
			}

			pSetup = pFirstRec.pPrior;
			pSetup.pNext = null;
			sqlite3VdbeExplain(pParse, (byte)(1), "SETUP");
			rc = (int)(sqlite3Select(pParse, pSetup, destQueue));
			pSetup.pNext = p;
			if ((rc) != 0)
				goto end_of_recursive_query;
			addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iQueue), (int)(addrBreak)));
			sqlite3VdbeAddOp1(v, (int)(135), (int)(iCurrent));
			if ((pOrderBy) != null)
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(iQueue), (int)(pOrderBy.nExpr + 1), (int)(regCurrent));
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(133), (int)(iQueue), (int)(regCurrent));
			}

			sqlite3VdbeAddOp1(v, (int)(129), (int)(iQueue));
			addrCont = (int)(sqlite3VdbeMakeLabel(pParse));
			codeOffset(v, (int)(regOffset), (int)(addrCont));
			selectInnerLoop(pParse, p, (int)(iCurrent), null, null, pDest, (int)(addrCont), (int)(addrBreak));
			if ((regLimit) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(60), (int)(regLimit), (int)(addrBreak));
			}

			sqlite3VdbeResolveLabel(v, (int)(addrCont));
			pFirstRec.pPrior = null;
			sqlite3VdbeExplain(pParse, (byte)(1), "RECURSIVE STEP");
			sqlite3Select(pParse, p, destQueue);

			pFirstRec.pPrior = pSetup;
			sqlite3VdbeGoto(v, (int)(addrTop));
			sqlite3VdbeResolveLabel(v, (int)(addrBreak));
		end_of_recursive_query:
			; sqlite3ExprListDelete(pParse.db, p.pOrderBy);
			p.pOrderBy = pOrderBy;
			p.pLimit = pLimit;
			return;
		}
		public static int getAndInitPage(BtShared pBt, uint pgno, MemPage ppPage, BtCursor pCur, int bReadOnly)
		{
			int rc = 0;
			PgHdr pDbPage;




			if ((pgno) > (btreePagecount(pBt)))
			{
				rc = (int)(sqlite3CorruptError((int)(68373)));
				goto getAndInitPage_error1;
			}

			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(pgno), pDbPage, (int)(bReadOnly)));
			if ((rc) != 0)
			{
				goto getAndInitPage_error1;
			}

			ppPage = (MemPage)(sqlite3PagerGetExtra(pDbPage));
			if (((ppPage).isInit) == (0))
			{
				btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
				rc = (int)(btreeInitPage(ppPage));
				if (rc != 0)
				{
					goto getAndInitPage_error2;
				}
			}



			if (((pCur) != null) && ((((ppPage).nCell) < (1)) || ((ppPage).intKey != pCur.curIntKey)))
			{
				rc = (int)(sqlite3CorruptError((int)(68394)));
				goto getAndInitPage_error2;
			}

			return (int)(0);
		getAndInitPage_error2:
			; releasePage(ppPage);
		getAndInitPage_error1:
			; if ((pCur) != null) { pCur.iPage--; pCur.pPage = pCur.apPage[pCur.iPage]; }

			return (int)(rc);
		}
		public static int getAutoVacuum(sbyte* z)
		{
			int i = 0;
			if ((0) == (sqlite3StrICmp(z, "none")))
				return (int)(0);
			if ((0) == (sqlite3StrICmp(z, "full")))
				return (int)(1);
			if ((0) == (sqlite3StrICmp(z, "incremental")))
				return (int)(2);
			i = (int)(sqlite3Atoi(z));
			return (int)((byte)((((i) >= (0)) && ((i) <= (2))) ? i : 0));
		}
		public static void getCellInfo(BtCursor pCur)
		{
			if ((pCur.info.nSize) == (0))
			{
				pCur.curFlags |= (byte)(0x02);
				btreeParseCell(pCur.pPage, (int)(pCur.ix), &pCur.info);
			}
			else
			{
			}
		}
		public static int getDigits(sbyte* zDate, sbyte* zFormat)
		{
			sbyte* ap;
			int cnt = (int)(0);
			sbyte nextC = 0;
			(__va_start(&ap, zFormat));
			do
			{
				sbyte N = (sbyte)(zFormat[0] - 48);
				sbyte min = (sbyte)(zFormat[1] - 48);
				int val = (int)(0);
				ushort max = 0;

				max = (ushort)(getDigits_aMx[zFormat[2] - 97]);
				nextC = (sbyte)(zFormat[3]);
				val = (int)(0);
				while ((N--) != 0)
				{
					if ((sqlite3CtypeMap[(byte)(*zDate)] & 0x04) == 0)
					{
						goto end_getDigits;
					}

					val = (int)(val * 10 + *zDate - 48);
					zDate++;
				}

				if ((((val) < ((int)(min))) || ((val) > ((int)(max)))) || ((nextC != 0) && (nextC != *zDate)))
				{
					goto end_getDigits;
				}

				*(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(val);
				zDate++;
				cnt++;
				zFormat += 4;
			}
			while ((nextC) != 0);
		end_getDigits:
			; ((void)(ap = null));
			return (int)(cnt);
		}
		public static double getDoubleArg(PrintfArguments p)
		{
			if ((p.nArg) <= (p.nUsed))
				return (double)(0.0);
			return (double)(sqlite3_value_double(p.apArg[p.nUsed++]));
		}
		public static long getIntArg(PrintfArguments p)
		{
			if ((p.nArg) <= (p.nUsed))
				return (long)(0);
			return (long)(sqlite3_value_int64(p.apArg[p.nUsed++]));
		}
		public static int getLockingMode(sbyte* z)
		{
			if ((z) != null)
			{
				if ((0) == (sqlite3StrICmp(z, "exclusive")))
					return (int)(1);
				if ((0) == (sqlite3StrICmp(z, "normal")))
					return (int)(0);
			}

			return (int)(-1);
		}
		public static int getOverflowPage(BtShared pBt, uint ovfl, MemPage ppPage, uint* pPgnoNext)
		{
			uint next = (uint)(0);
			MemPage pPage = null;
			int rc = (int)(0);


			if ((pBt.autoVacuum) != 0)
			{
				uint pgno = 0;
				uint iGuess = (uint)(ovfl + 1);
				byte eType = 0;
				while (((ptrmapPageno((pBt), (uint)(iGuess))) == (iGuess)) || ((iGuess) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
				{
					iGuess++;
				}

				if ((iGuess) <= (btreePagecount(pBt)))
				{
					rc = (int)(ptrmapGet(pBt, (uint)(iGuess), &eType, &pgno));
					if ((((rc) == (0)) && ((eType) == (4))) && ((pgno) == (ovfl)))
					{
						next = (uint)(iGuess);
						rc = (int)(101);
					}
				}
			}


			if ((rc) == (0))
			{
				rc = (int)(btreeGetPage(pBt, (uint)(ovfl), pPage, (int)(((ppPage) == (null)) ? 0x02 : 0)));

				if ((rc) == (0))
				{
					next = (uint)(sqlite3Get4byte(pPage.aData));
				}
			}

			*pPgnoNext = (uint)(next);
			if ((ppPage) != null)
			{
				ppPage = pPage;
			}
			else
			{
				releasePage(pPage);
			}

			return (int)((rc) == (101) ? 0 : rc);
		}
		public static int getPageError(Pager pPager, uint pgno, PgHdr ppPage, int flags)
		{
			(void)(pgno);
			(void)(flags);

			ppPage = null;
			return (int)(pPager.errCode);
		}
		public static int getPageMMap(Pager pPager, uint pgno, PgHdr ppPage, int flags)
		{
			int rc = (int)(0);
			PgHdr pPg = null;
			uint iFrame = (uint)(0);
			int bMmapOk = (int)((((pgno) > (1)) && (((pPager.eState) == (1)) || ((flags & 0x02) != 0))) ? 1 : 0);

			if (((pgno) <= (1)) && ((pgno) == (0)))
			{
				return (int)(sqlite3CorruptError((int)(58821)));
			}





			if (((bMmapOk) != 0) && ((pPager).pWal != null))
			{
				rc = (int)(sqlite3WalFindFrame(pPager.pWal, (uint)(pgno), &iFrame));
				if (rc != 0)
				{
					ppPage = null;
					return (int)(rc);
				}
			}

			if (((bMmapOk) != 0) && ((iFrame) == (0)))
			{
				void* pData = null;
				rc = (int)(sqlite3OsFetch(pPager.fd, (long)((long)(pgno - 1) * pPager.pageSize), (int)(pPager.pageSize), &pData));
				if (((rc) == (0)) && ((pData) != null))
				{
					if (((pPager.eState) > (1)) || ((pPager.tempFile) != 0))
					{
						pPg = sqlite3PagerLookup(pPager, (uint)(pgno));
					}

					if ((pPg) == (null))
					{
						rc = (int)(pagerAcquireMapPage(pPager, (uint)(pgno), pData, pPg));
					}
					else
					{
						sqlite3OsUnfetch(pPager.fd, (long)((long)(pgno - 1) * pPager.pageSize), pData);
					}

					if ((pPg) != null)
					{

						ppPage = pPg;
						return (int)(0);
					}
				}

				if (rc != 0)
				{
					ppPage = null;
					return (int)(rc);
				}
			}

			return (int)(getPageNormal(pPager, (uint)(pgno), ppPage, (int)(flags)));
		}
		public static int getPageNormal(Pager pPager, uint pgno, PgHdr ppPage, int flags)
		{
			int rc = (int)(0);
			PgHdr pPg;
			byte noContent = 0;
			sqlite3_pcache_page* pBase;




			if ((pgno) == (0))
				return (int)(sqlite3CorruptError((int)(58710)));
			pBase = sqlite3PcacheFetch(pPager.pPCache, (uint)(pgno), (int)(3));
			if ((pBase) == (null))
			{
				pPg = null;
				rc = (int)(sqlite3PcacheFetchStress(pPager.pPCache, (uint)(pgno), &pBase));
				if (rc != 0)
					goto pager_acquire_err;
				if ((pBase) == (null))
				{
					rc = (int)(7);
					goto pager_acquire_err;
				}
			}

			pPg = ppPage = sqlite3PcacheFetchFinish(pPager.pPCache, (uint)(pgno), pBase);



			noContent = (byte)((flags & 0x01) != 0);
			if (((pPg.pPager) != null) && (noContent == 0))
			{

				pPager.aStat[0]++;
				return (int)(0);
			}
			else
			{
				if ((pgno) == ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1)))
				{
					rc = (int)(sqlite3CorruptError((int)(58742)));
					goto pager_acquire_err;
				}

				pPg.pPager = pPager;

				if (((!((pPager.fd).pMethods != null)) || ((pPager.dbSize) < (pgno))) || ((noContent) != 0))
				{
					if ((pgno) > (pPager.mxPgno))
					{
						rc = (int)(13);
						goto pager_acquire_err;
					}

					if ((noContent) != 0)
					{
						sqlite3BeginBenignMalloc();
						if ((pgno) <= (pPager.dbOrigSize))
						{
							sqlite3BitvecSet(pPager.pInJournal, (uint)(pgno));
						}

						addToSavepointBitvecs(pPager, (uint)(pgno));
						sqlite3EndBenignMalloc();
					}

					CRuntime.memset(pPg.pData, (int)(0), (ulong)(pPager.pageSize));
				}
				else
				{

					pPager.aStat[1]++;
					rc = (int)(readDbPage(pPg));
					if (rc != 0)
					{
						goto pager_acquire_err;
					}
				}
			}

			return (int)(0);
		pager_acquire_err:
			; ((void)(0));
			if ((pPg) != null)
			{
				sqlite3PcacheDrop(pPg);
			}

			pagerUnlockIfUnused(pPager);
			ppPage = null;
			return (int)(rc);
		}
		public static int getPageReferenced(IntegrityCk pCheck, uint iPg)
		{

			return (int)(pCheck.aPgRef[iPg / 8] & (1 << (iPg & 0x07)));
		}
		public static TriggerPrg getRowTrigger(Parse pParse, Trigger pTrigger, Table pTab, int orconf)
		{
			Parse pRoot = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			TriggerPrg pPrg;

			for (pPrg = pRoot.pTriggerPrg; ((pPrg) != null) && ((pPrg.pTrigger != pTrigger) || (pPrg.orconf != orconf)); pPrg = pPrg.pNext)
			{
			}

			if (pPrg == null)
			{
				pPrg = codeRowTrigger(pParse, pTrigger, pTab, (int)(orconf));
				pParse.db.errByteOffset = (int)(-1);
			}

			return pPrg;
		}
		public static byte getSafetyLevel(sbyte* z, int omitFull, byte dflt)
		{
			int i = 0; int n = 0;
			if ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0)
			{
				return (byte)(sqlite3Atoi(z));
			}

			n = (int)(sqlite3Strlen30(z));
			for (i = (int)(0); (i) < ((int)(8 * sizeof(byte) / sizeof(byte))); i++)
			{
				if ((((getSafetyLevel_iLength[i]) == (n)) && ((sqlite3_strnicmp(&getSafetyLevel_zText[getSafetyLevel_iOffset[i]], z, (int)(n))) == (0))) && ((omitFull == 0) || ((getSafetyLevel_iValue[i]) <= (1))))
				{
					return (byte)(getSafetyLevel_iValue[i]);
				}
			}

			return (byte)(dflt);
		}
		public static int getTempStore(sbyte* z)
		{
			if (((z[0]) >= (48)) && ((z[0]) <= (50)))
			{
				return (int)(z[0] - 48);
			}
			else if ((sqlite3StrICmp(z, "file")) == (0))
			{
				return (int)(1);
			}
			else if ((sqlite3StrICmp(z, "memory")) == (0))
			{
				return (int)(2);
			}
			else
			{
				return (int)(0);
			}
		}
		public static sbyte* getTextArg(PrintfArguments p)
		{
			if ((p.nArg) <= (p.nUsed))
				return null;
			return (sbyte*)(sqlite3_value_text(p.apArg[p.nUsed++]));
		}
		public static int getToken(byte** pz)
		{
			byte* z = *pz;
			int t = 0;
			do
			{
				z += sqlite3GetToken(z, &t);
			}
			while ((t) == (183));
			if (((((((t) == (59)) || ((t) == (117))) || ((t) == (118))) || ((t) == (164))) || ((t) == (165))) || ((sqlite3ParserFallback((int)(t))) == (59)))
			{
				t = (int)(59);
			}

			*pz = z;
			return (int)(t);
		}
		public static void groupConcatFinalize(sqlite3_context context)
		{
			GroupConcatCtx pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(0)));
			if ((pGCC) != null)
			{
				sqlite3ResultStrAccum(context, pGCC.str);
				sqlite3_free(pGCC.pnSepLengths);
			}
		}
		public static void groupConcatInverse(sqlite3_context context, int argc, sqlite3_value argv)
		{
			GroupConcatCtx pGCC;


			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(sizeof(GroupConcatCtx))));
			if ((pGCC) != null)
			{
				int nVS = 0;
				(void)(sqlite3_value_text(argv[0]));
				nVS = (int)(sqlite3_value_bytes(argv[0]));
				pGCC.nAccum -= (int)(1);
				if (pGCC.pnSepLengths != null)
				{

					if ((pGCC.nAccum) > (0))
					{
						nVS += (int)(*pGCC.pnSepLengths);
						CRuntime.memmove(pGCC.pnSepLengths, pGCC.pnSepLengths + 1, (ulong)((pGCC.nAccum - 1) * sizeof(int)));
					}
				}
				else
				{
					nVS += (int)(pGCC.nFirstSepLength);
				}

				if ((nVS) >= ((int)(pGCC.str.nChar)))
				{
					pGCC.str.nChar = (uint)(0);
				}
				else
				{
					pGCC.str.nChar -= (uint)(nVS);
					CRuntime.memmove(pGCC.str.zText, &pGCC.str.zText[nVS], (ulong)(pGCC.str.nChar));
				}

				if ((pGCC.str.nChar) == (0))
				{
					pGCC.str.mxAlloc = (uint)(0);
					sqlite3_free(pGCC.pnSepLengths);
					pGCC.pnSepLengths = null;
				}
			}
		}
		public static void groupConcatStep(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* zVal;
			GroupConcatCtx pGCC;
			sbyte* zSep;
			int nVal = 0; int nSep = 0;

			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(sizeof(GroupConcatCtx))));
			if ((pGCC) != null)
			{
				sqlite3 db = sqlite3_context_db_handle(context);
				int firstTerm = (int)((pGCC.str.mxAlloc) == (0) ? 1 : 0);
				pGCC.str.mxAlloc = (uint)(db.aLimit[0]);
				if ((argc) == (1))
				{
					if (firstTerm == 0)
					{
						sqlite3_str_appendchar(pGCC.str, (int)(1), (sbyte)(44));
					}
					else
					{
						pGCC.nFirstSepLength = (int)(1);
					}
				}
				else if (firstTerm == 0)
				{
					zSep = (sbyte*)(sqlite3_value_text(argv[1]));
					nSep = (int)(sqlite3_value_bytes(argv[1]));
					if ((zSep) != null)
					{
						sqlite3_str_append(pGCC.str, zSep, (int)(nSep));
					}
					else
					{
						nSep = (int)(0);
					}

					if ((nSep != pGCC.nFirstSepLength) || (pGCC.pnSepLengths != null))
					{
						int* pnsl = pGCC.pnSepLengths;
						if ((pnsl) == (null))
						{
							pnsl = (int*)(sqlite3_malloc64((ulong)((pGCC.nAccum + 1) * sizeof(int))));
							if (pnsl != null)
							{
								int i = (int)(0);
								int nA = (int)(pGCC.nAccum - 1);
								while ((i) < (nA))
								{
									pnsl[i++] = (int)(pGCC.nFirstSepLength);
								}
							}
						}
						else
						{
							pnsl = (int*)(sqlite3_realloc64(pnsl, (ulong)(pGCC.nAccum * sizeof(int))));
						}

						if (pnsl != null)
						{
							if (((pGCC.nAccum) > (0)))
							{
								pnsl[pGCC.nAccum - 1] = (int)(nSep);
							}

							pGCC.pnSepLengths = pnsl;
						}
						else
						{
							sqlite3StrAccumSetError(pGCC.str, (byte)(7));
						}
					}
				}
				else
				{
					pGCC.nFirstSepLength = (int)(sqlite3_value_bytes(argv[1]));
				}

				pGCC.nAccum += (int)(1);
				zVal = (sbyte*)(sqlite3_value_text(argv[0]));
				nVal = (int)(sqlite3_value_bytes(argv[0]));
				if ((zVal) != null)
					sqlite3_str_append(pGCC.str, zVal, (int)(nVal));
			}
		}
		public static void groupConcatValue(sqlite3_context context)
		{
			GroupConcatCtx pGCC = (GroupConcatCtx)(sqlite3_aggregate_context(context, (int)(0)));
			if ((pGCC) != null)
			{
				sqlite3_str pAccum = pGCC.str;
				if ((pAccum.accError) == (18))
				{
					sqlite3_result_error_toobig(context);
				}
				else if ((pAccum.accError) == (7))
				{
					sqlite3_result_error_nomem(context);
				}
				else
				{
					sbyte* zText = sqlite3_str_value(pAccum);
					sqlite3_result_text(context, zText, (int)(pAccum.nChar), ((Void(Void * ))(-1)));
				}
			}
		}
		public static int growOp3(Vdbe p, int op, int p1, int p2, int p3)
		{

			if ((growOpArray(p, (int)(1))) != 0)
				return (int)(1);

			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
		}
		public static int growOpArray(Vdbe v, int nOp)
		{
			VdbeOp* pNew;
			Parse p = v.pParse;
			long nNew = (long)((v.nOpAlloc) != 0 ? 2 * (long)(v.nOpAlloc) : (long)(1024 / sizeof(VdbeOp)));
			(void)(nOp);
			if ((nNew) > (p.db.aLimit[5]))
			{
				sqlite3OomFault(p.db);
				return (int)(7);
			}



			pNew = sqlite3DbRealloc(p.db, v.aOp, (ulong)(nNew * sizeof(VdbeOp)));
			if ((pNew) != null)
			{
				p.szOpAlloc = (int)(sqlite3DbMallocSize(p.db, pNew));
				v.nOpAlloc = (int)(p.szOpAlloc / sizeof(VdbeOp));
				v.aOp = pNew;
			}

			return (int)(pNew ? 0 : 7);
		}
		public static int growVTrans(sqlite3 db)
		{
			int ARRAY_INCR = (int)(5);
			if ((db.nVTrans % ARRAY_INCR) == (0))
			{
				VTable aVTrans;
				long nBytes = (long)(sizeof(sqlite3_vtab) * ((long)(db.nVTrans) + ARRAY_INCR));
				aVTrans = sqlite3DbRealloc(db, (void*)(db.aVTrans), (ulong)(nBytes));
				if (aVTrans == null)
				{
					return (int)(7);
				}

				CRuntime.memset(aVTrans[db.nVTrans], (int)(0), (ulong)(sizeof(sqlite3_vtab) * ARRAY_INCR));
				db.aVTrans = aVTrans;
			}

			return (int)(0);
		}
		public static int handleMovedCursor(VdbeCursor p)
		{
			int isDifferentRow = 0; int rc = 0;



			rc = (int)(sqlite3BtreeCursorRestore(p.uc.pCursor, &isDifferentRow));
			p.cacheStatus = (uint)(0);
			if ((isDifferentRow) != 0)
				p.nullRow = (byte)(1);
			return (int)(rc);
		}
		public static int hasAnchor(Select p)
		{
			while (((p) != null) && ((p.selFlags & 0x0002000) != 0))
			{
				p = p.pPrior;
			}

			return (int)(p != null);
		}
		public static int hasColumn(short* aiCol, int nCol, int x)
		{
			while ((nCol--) > (0))
			{
				if ((x) == (*(aiCol++)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int hasHotJournal(Pager pPager, int* pExists)
		{
			sqlite3_vfs pVfs = pPager.pVfs;
			int rc = (int)(0);
			int exists = (int)(1);
			int jrnlOpen = (int)(!!((pPager.jfd).pMethods != null));




			*pExists = (int)(0);
			if (jrnlOpen == 0)
			{
				rc = (int)(sqlite3OsAccess(pVfs, pPager.zJournal, (int)(0), &exists));
			}

			if (((rc) == (0)) && ((exists) != 0))
			{
				int locked = (int)(0);
				rc = (int)(sqlite3OsCheckReservedLock(pPager.fd, &locked));
				if (((rc) == (0)) && (locked == 0))
				{
					uint nPage = 0;

					rc = (int)(pagerPagecount(pPager, &nPage));
					if ((rc) == (0))
					{
						if (((nPage) == (0)) && (jrnlOpen == 0))
						{
							sqlite3BeginBenignMalloc();
							if ((pagerLockDb(pPager, (int)(2))) == (0))
							{
								sqlite3OsDelete(pVfs, pPager.zJournal, (int)(0));
								if (pPager.exclusiveMode == 0)
									pagerUnlockDb(pPager, (int)(1));
							}

							sqlite3EndBenignMalloc();
						}
						else
						{
							if (jrnlOpen == 0)
							{
								int f = (int)(0x00000001 | 0x00000800);
								rc = (int)(sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, (int)(f), &f));
							}

							if ((rc) == (0))
							{
								byte first = (byte)(0);
								rc = (int)(sqlite3OsRead(pPager.jfd, (void*)(&first), (int)(1), (long)(0)));
								if ((rc) == (10 | (2 << 8)))
								{
									rc = (int)(0);
								}

								if (jrnlOpen == 0)
								{
									sqlite3OsClose(pPager.jfd);
								}

								*pExists = (int)(first != 0);
							}
							else if ((rc) == (14))
							{
								*pExists = (int)(1);
								rc = (int)(0);
							}
						}
					}
				}
			}

			return (int)(rc);
		}
		public static void havingToWhere(Parse pParse, Select p)
		{
			Walker sWalker = new Walker();
			CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
			sWalker.pParse = pParse;
			sWalker.xExprCallback = havingToWhereExprCb;
			sWalker.u.pSelect = p;
			sqlite3WalkExpr(sWalker, p.pHaving);
		}
		public static int havingToWhereExprCb(Walker pWalker, Expr pExpr)
		{
			if (pExpr.op != 44)
			{
				Select pS = pWalker.u.pSelect;
				if ((((sqlite3ExprIsConstantOrGroupBy(pWalker.pParse, pExpr, pS.pGroupBy)) != 0) && ((((pExpr).flags & (0x000001 | 0x20000000)) == (0x20000000)) == (0))) && ((pExpr.pAggInfo) == (null)))
				{
					sqlite3 db = pWalker.pParse.db;
					Expr pNew = sqlite3Expr(db, (int)(155), "1");
					if ((pNew) != null)
					{
						Expr pWhere = pS.pWhere;
						{
							Expr t = (Expr)(pNew);
							pNew = (Expr)(pExpr);
							pExpr = (Expr)(t);
						}

						pNew = sqlite3ExprAnd(pWalker.pParse, pWhere, pNew);
						pS.pWhere = pNew;
						pWalker.eCode = (ushort)(1);
					}
				}

				return (int)(1);
			}

			return (int)(0);
		}
		public static void heightOfExpr(Expr p, int* pnHeight)
		{
			if ((p) != null)
			{
				if ((p.nHeight) > (*pnHeight))
				{
					*pnHeight = (int)(p.nHeight);
				}
			}
		}
		public static void heightOfExprList(ExprList p, int* pnHeight)
		{
			if ((p) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (p.nExpr); i++)
				{
					heightOfExpr(p.a[i].pExpr, pnHeight);
				}
			}
		}
		public static void heightOfSelect(Select pSelect, int* pnHeight)
		{
			Select p;
			for (p = pSelect; p; p = p.pPrior)
			{
				heightOfExpr(p.pWhere, pnHeight);
				heightOfExpr(p.pHaving, pnHeight);
				heightOfExpr(p.pLimit, pnHeight);
				heightOfExprList(p.pEList, pnHeight);
				heightOfExprList(p.pGroupBy, pnHeight);
				heightOfExprList(p.pOrderBy, pnHeight);
			}
		}
		public static void hexFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int i = 0; int n = 0;
			byte* pBlob;
			sbyte* zHex; sbyte* z;


			pBlob = sqlite3_value_blob(argv[0]);
			n = (int)(sqlite3_value_bytes(argv[0]));

			z = zHex = contextMalloc(context, (long)(((long)(n)) * 2 + 1));
			if ((zHex) != null)
			{
				for (i = (int)(0); (i) < (n); i++, pBlob++)
				{
					byte c = (byte)(*pBlob);
					*(z++) = (sbyte)(hexdigits[(c >> 4) & 0xf]);
					*(z++) = (sbyte)(hexdigits[c & 0xf]);
				}

				*z = (sbyte)(0);
				sqlite3_result_text(context, zHex, (int)(n * 2), sqlite3_free);
			}
		}
		public static int identLength(sbyte* z)
		{
			int n = 0;
			for (n = (int)(0); *z; n++, z++)
			{
				if ((*z) == (34))
				{
					n++;
				}
			}

			return (int)(n + 2);
		}
		public static void identPut(sbyte* z, int* pIdx, sbyte* zSignedIdent)
		{
			byte* zIdent = (byte*)(zSignedIdent);
			int i = 0; int j = 0; int needQuote = 0;
			i = (int)(*pIdx);
			for (j = (int)(0); zIdent[j]; j++)
			{
				if (((sqlite3CtypeMap[(zIdent[j])] & 0x06) == 0) && (zIdent[j] != 95))
					break;
			}

			needQuote = (int)(((((sqlite3CtypeMap[(zIdent[0])] & 0x04) != 0) || (sqlite3KeywordCode(zIdent, (int)(j)) != 59)) || (zIdent[j] != 0)) || ((j) == (0)) ? 1 : 0);
			if ((needQuote) != 0)
				z[i++] = (sbyte)(34);
			for (j = (int)(0); zIdent[j]; j++)
			{
				z[i++] = (sbyte)(zIdent[j]);
				if ((zIdent[j]) == (34))
					z[i++] = (sbyte)(34);
			}

			if ((needQuote) != 0)
				z[i++] = (sbyte)(34);
			z[i] = (sbyte)(0);
			*pIdx = (int)(i);
		}
		public static int impliesNotNullRow(Walker pWalker, Expr pExpr)
		{
			if ((((pExpr).flags & (0x000001)) != 0))
				return (int)(1);
			switch (pExpr.op)
			{
				case 171:
				case 50:
				case 51:
				case 45:
				case 43:
				case 177:
				case 157:
				case 49:
				case 172:
				case 175:
					;
					return (int)(1);
				case 167:
					if ((pWalker.u.iCur) == (pExpr.iTable))
					{
						pWalker.eCode = (ushort)(1);
						return (int)(2);
					}

					return (int)(1);
				case 44:
					if ((pWalker.eCode) == (0))
					{
						sqlite3WalkExpr(pWalker, pExpr.pLeft);
						if ((pWalker.eCode) != 0)
						{
							pWalker.eCode = (ushort)(0);
							sqlite3WalkExpr(pWalker, pExpr.pRight);
						}
					}

					return (int)(1);
				case 48:
					if ((sqlite3WalkExpr(pWalker, pExpr.pLeft)) == (2))
					{

						return (int)(2);
					}

					return (int)(1);
				case 53:
				case 52:
				case 56:
				case 55:
				case 54:
				case 57:
					{
						Expr pLeft = pExpr.pLeft;
						Expr pRight = pExpr.pRight;


						if (((((pLeft.op) == (167)) && (pLeft.y.pTab != null)) && (((pLeft.y.pTab).eTabType) == (1))) || ((((pRight.op) == (167)) && (pRight.y.pTab != null)) && (((pRight.y.pTab).eTabType) == (1))))
						{
							return (int)(1);
						}
					}

				default:
					return (int)(0);
			}
		}
		public static int incrAggDepth(Walker pWalker, Expr pExpr)
		{
			if ((pExpr.op) == (168))
				pExpr.op2 += (byte)(pWalker.u.n);
			return (int)(0);
		}
		public static void incrAggFunctionDepth(Expr pExpr, int N)
		{
			if ((N) > (0))
			{
				Walker w = new Walker();
				CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
				w.xExprCallback = incrAggDepth;
				w.u.n = (int)(N);
				sqlite3WalkExpr(w, pExpr);
			}
		}
		public static int incrVacuumStep(BtShared pBt, uint nFin, uint iLastPg, int bCommit)
		{
			uint nFreeList = 0;
			int rc = 0;


			if ((!((ptrmapPageno((pBt), (uint)(iLastPg))) == (iLastPg))) && (iLastPg != ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
			{
				byte eType = 0;
				uint iPtrPage = 0;
				nFreeList = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36]));
				if ((nFreeList) == (0))
				{
					return (int)(101);
				}

				rc = (int)(ptrmapGet(pBt, (uint)(iLastPg), &eType, &iPtrPage));
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((eType) == (1))
				{
					return (int)(sqlite3CorruptError((int)(69986)));
				}

				if ((eType) == (2))
				{
					if ((bCommit) == (0))
					{
						uint iFreePg = 0;
						MemPage pFreePg;
						rc = (int)(allocateBtreePage(pBt, pFreePg, &iFreePg, (uint)(iLastPg), (byte)(1)));
						if (rc != 0)
						{
							return (int)(rc);
						}


						releasePage(pFreePg);
					}
				}
				else
				{
					uint iFreePg = 0;
					MemPage pLastPg;
					byte eMode = (byte)(0);
					uint iNear = (uint)(0);
					rc = (int)(btreeGetPage(pBt, (uint)(iLastPg), pLastPg, (int)(0)));
					if (rc != 0)
					{
						return (int)(rc);
					}

					if ((bCommit) == (0))
					{
						eMode = (byte)(2);
						iNear = (uint)(nFin);
					}

					do
					{
						MemPage pFreePg;
						rc = (int)(allocateBtreePage(pBt, pFreePg, &iFreePg, (uint)(iNear), (byte)(eMode)));
						if (rc != 0)
						{
							releasePage(pLastPg);
							return (int)(rc);
						}

						releasePage(pFreePg);
					}
					while (((bCommit) != 0) && ((iFreePg) > (nFin)));

					rc = (int)(relocatePage(pBt, pLastPg, (byte)(eType), (uint)(iPtrPage), (uint)(iFreePg), (int)(bCommit)));
					releasePage(pLastPg);
					if (rc != 0)
					{
						return (int)(rc);
					}
				}
			}

			if ((bCommit) == (0))
			{
				do
				{
					iLastPg--;
				}
				while (((iLastPg) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) || ((ptrmapPageno((pBt), (uint)(iLastPg))) == (iLastPg)));
				pBt.bDoTruncate = (byte)(1);
				pBt.nPage = (uint)(iLastPg);
			}

			return (int)(0);
		}
		public static int indexColumnIsBeingUpdated(Index pIdx, int iCol, int* aXRef, int chngRowid)
		{
			short iIdxCol = (short)(pIdx.aiColumn[iCol]);

			if ((iIdxCol) >= (0))
			{
				return ((aXRef[iIdxCol]) >= (0) ? 1 : 0);
			}




			return (int)(sqlite3ExprReferencesUpdatedColumn(pIdx.aColExpr.a[iCol].pExpr, aXRef, (int)(chngRowid)));
		}
		public static int indexColumnNotNull(Index pIdx, int iCol)
		{
			int j = 0;


			j = (int)(pIdx.aiColumn[iCol]);
			if ((j) >= (0))
			{
				return (int)(pIdx.pTable.aCol[j].notNull);
			}
			else if ((j) == (-1))
			{
				return (int)(1);
			}
			else
			{

				return (int)(0);
			}
		}
		public static Index indexIteratorFirst(IndexIterator* pIter, int* pIx)
		{

			if ((pIter->eType) != 0)
			{
				*pIx = (int)(pIter->u.ax.aIdx[0].ix);
				return pIter->u.ax.aIdx[0].p;
			}
			else
			{
				*pIx = (int)(0);
				return pIter->u.lx.pIdx;
			}
		}
		public static Index indexIteratorNext(IndexIterator* pIter, int* pIx)
		{
			if ((pIter->eType) != 0)
			{
				int i = (int)(++pIter->i);
				if ((i) >= (pIter->u.ax.nIdx))
				{
					*pIx = (int)(i);
					return null;
				}

				*pIx = (int)(pIter->u.ax.aIdx[i].ix);
				return pIter->u.ax.aIdx[i].p;
			}
			else
			{
				++(*pIx);
				pIter->u.lx.pIdx = pIter->u.lx.pIdx.pNext;
				return pIter->u.lx.pIdx;
			}
		}
		public static int indexMightHelpWithOrderBy(WhereLoopBuilder pBuilder, Index pIndex, int iCursor)
		{
			ExprList pOB;
			ExprList aColExpr;
			int ii = 0; int jj = 0;
			if ((pIndex.bUnordered) != 0)
				return (int)(0);
			if ((pOB = pBuilder.pWInfo.pOrderBy) == (null))
				return (int)(0);
			for (ii = (int)(0); (ii) < (pOB.nExpr); ii++)
			{
				Expr pExpr = sqlite3ExprSkipCollateAndLikely(pOB.a[ii].pExpr);
				if (((pExpr) == (null)))
					continue;
				if (((pExpr.op) == (167)) && ((pExpr.iTable) == (iCursor)))
				{
					if ((pExpr.iColumn) < (0))
						return (int)(1);
					for (jj = (int)(0); (jj) < (pIndex.nKeyCol); jj++)
					{
						if ((pExpr.iColumn) == (pIndex.aiColumn[jj]))
							return (int)(1);
					}
				}
				else if ((aColExpr = pIndex.aColExpr) != null)
				{
					for (jj = (int)(0); (jj) < (pIndex.nKeyCol); jj++)
					{
						if (pIndex.aiColumn[jj] != (-2))
							continue;
						if ((sqlite3ExprCompareSkip(pExpr, aColExpr.a[jj].pExpr, (int)(iCursor))) == (0))
						{
							return (int)(1);
						}
					}
				}
			}

			return (int)(0);
		}
		public static int indexWhereClauseMightChange(Index pIdx, int* aXRef, int chngRowid)
		{
			if ((pIdx.pPartIdxWhere) == (null))
				return (int)(0);
			return (int)(sqlite3ExprReferencesUpdatedColumn(pIdx.pPartIdxWhere, aXRef, (int)(chngRowid)));
		}
		public static void initMemArray(sqlite3_value p, int N, sqlite3 db, ushort flags)
		{
			while ((N--) > (0))
			{
				p.db = db;
				p.flags = (ushort)(flags);
				p.szMalloc = (int)(0);
				p++;
			}
		}
		public static void innerLoopLoadRow(Parse pParse, Select pSelect, RowLoadInfo* pInfo)
		{
			sqlite3ExprCodeExprList(pParse, pSelect.pEList, (int)(pInfo->regResult), (int)(0), (byte)(pInfo->ecelFlags));
		}
		public static void insertCell(MemPage pPage, int i, byte* pCell, int sz, byte* pTemp, uint iChild, int* pRC)
		{
			int idx = (int)(0);
			int j = 0;
			byte* data;
			byte* pIns;









			if (((pPage.nOverflow) != 0) || ((sz + 2) > (pPage.nFree)))
			{
				if ((pTemp) != null)
				{
					CRuntime.memcpy(pTemp, pCell, (ulong)(sz));
					pCell = pTemp;
				}

				if ((iChild) != 0)
				{
					sqlite3Put4byte(pCell, (uint)(iChild));
				}

				j = (int)(pPage.nOverflow++);

				pPage.apOvfl[j] = pCell;
				pPage.aiOvfl[j] = ((ushort)(i));


			}
			else
			{
				int rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
				if (rc != 0)
				{
					*pRC = (int)(rc);
					return;
				}


				data = pPage.aData;

				rc = (int)(allocateSpace(pPage, (int)(sz), &idx));
				if ((rc) != 0)
				{
					*pRC = (int)(rc);
					return;
				}




				pPage.nFree -= (int)((ushort)(2 + sz));
				if ((iChild) != 0)
				{
					CRuntime.memcpy(&data[idx + 4], pCell + 4, (ulong)(sz - 4));
					sqlite3Put4byte(&data[idx], (uint)(iChild));
				}
				else
				{
					CRuntime.memcpy(&data[idx], pCell, (ulong)(sz));
				}

				pIns = pPage.aCellIdx + i * 2;
				CRuntime.memmove(pIns + 2, pIns, (ulong)(2 * (pPage.nCell - i)));
				((pIns)[0] = ((byte)((idx) >> 8)), (pIns)[1] = ((byte)(idx)));
				pPage.nCell++;
				if ((++data[pPage.hdrOffset + 4]) == (0))
					data[pPage.hdrOffset + 3]++;

				if ((pPage.pBt.autoVacuum) != 0)
				{
					ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);
				}
			}
		}
		public static void insertElement(Hash* pH, _ht* pEntry, HashElem* pNew)
		{
			HashElem* pHead;
			if ((pEntry) != null)
			{
				pHead = (pEntry->count) != 0 ? pEntry->chain : null;
				pEntry->count++;
				pEntry->chain = pNew;
			}
			else
			{
				pHead = null;
			}

			if ((pHead) != null)
			{
				pNew->next = pHead;
				pNew->prev = pHead->prev;
				if ((pHead->prev) != null)
				{
					pHead->prev->next = pNew;
				}
				else
				{
					pH->first = pNew;
				}

				pHead->prev = pNew;
			}
			else
			{
				pNew->next = pH->first;
				if ((pH->first) != null)
				{
					pH->first->prev = pNew;
				}

				pNew->prev = null;
				pH->first = pNew;
			}
		}
		public static void instrFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zHaystack;
			byte* zNeedle;
			int nHaystack = 0;
			int nNeedle = 0;
			int typeHaystack = 0; int typeNeedle = 0;
			int N = (int)(1);
			int isText = 0;
			byte firstChar = 0;
			sqlite3_value pC1 = null;
			sqlite3_value pC2 = null;

			typeHaystack = (int)(sqlite3_value_type(argv[0]));
			typeNeedle = (int)(sqlite3_value_type(argv[1]));
			if (((typeHaystack) == (5)) || ((typeNeedle) == (5)))
				return;
			nHaystack = (int)(sqlite3_value_bytes(argv[0]));
			nNeedle = (int)(sqlite3_value_bytes(argv[1]));
			if ((nNeedle) > (0))
			{
				if (((typeHaystack) == (4)) && ((typeNeedle) == (4)))
				{
					zHaystack = sqlite3_value_blob(argv[0]);
					zNeedle = sqlite3_value_blob(argv[1]);
					isText = (int)(0);
				}
				else if ((typeHaystack != 4) && (typeNeedle != 4))
				{
					zHaystack = sqlite3_value_text(argv[0]);
					zNeedle = sqlite3_value_text(argv[1]);
					isText = (int)(1);
				}
				else
				{
					pC1 = sqlite3_value_dup(argv[0]);
					zHaystack = sqlite3_value_text(pC1);
					if ((zHaystack) == (null))
						goto endInstrOOM;
					nHaystack = (int)(sqlite3_value_bytes(pC1));
					pC2 = sqlite3_value_dup(argv[1]);
					zNeedle = sqlite3_value_text(pC2);
					if ((zNeedle) == (null))
						goto endInstrOOM;
					nNeedle = (int)(sqlite3_value_bytes(pC2));
					isText = (int)(1);
				}

				if (((zNeedle) == (null)) || (((nHaystack) != 0) && ((zHaystack) == (null))))
					goto endInstrOOM;
				firstChar = (byte)(zNeedle[0]);
				while (((nNeedle) <= (nHaystack)) && ((zHaystack[0] != firstChar) || (memcmp(zHaystack, zNeedle, (ulong)(nNeedle)) != 0)))
				{
					N++;
					do
					{
						nHaystack--;
						zHaystack++;
					}
					while (((isText) != 0) && ((zHaystack[0] & 0xc0) == (0x80)));
				}

				if ((nNeedle) > (nHaystack))
					N = (int)(0);
			}

			sqlite3_result_int(context, (int)(N));
		endInstr:
			; sqlite3_value_free(pC1);
			sqlite3_value_free(pC2);
			return;
		endInstrOOM:
			; sqlite3_result_error_nomem(context);
			goto endInstr;
		}
		public static int integrityCheckResultRow(Vdbe v)
		{
			int addr = 0;
			sqlite3VdbeAddOp2(v, (int)(83), (int)(3), (int)(1));
			addr = (int)(sqlite3VdbeAddOp3(v, (int)(49), (int)(1), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(1)));
			sqlite3VdbeAddOp0(v, (int)(70));
			return (int)(addr);
		}
		public static void invalidateAllOverflowCache(BtShared pBt)
		{
			BtCursor p;

			for (p = pBt.pCursor; p; p = p.pNext)
			{
				(p.curFlags &= (byte)(~0x04));
			}
		}
		public static void invalidateIncrblobCursors(Btree pBtree, uint pgnoRoot, long iRow, int isClearTable)
		{
			BtCursor p;


			pBtree.hasIncrblobCur = (byte)(0);
			for (p = pBtree.pBt.pCursor; p; p = p.pNext)
			{
				if ((p.curFlags & 0x10) != 0)
				{
					pBtree.hasIncrblobCur = (byte)(1);
					if (((p.pgnoRoot) == (pgnoRoot)) && (((isClearTable) != 0) || ((p.info.nKey) == (iRow))))
					{
						p.eState = (byte)(1);
					}
				}
			}
		}
		public static int invalidateTempStorage(Parse pParse)
		{
			sqlite3 db = pParse.db;
			if (db.aDb[1].pBt != null)
			{
				if ((db.autoCommit == 0) || (sqlite3BtreeTxnState(db.aDb[1].pBt) != 0))
				{
					sqlite3ErrorMsg(pParse, "temporary storage cannot be changed from within a transaction");
					return (int)(1);
				}

				sqlite3BtreeClose(db.aDb[1].pBt);
				db.aDb[1].pBt = null;
				sqlite3ResetAllSchemasOfConnection(db);
			}

			return (int)(0);
		}
		public static void invokeProfileCallback(sqlite3 db, Vdbe p)
		{
			long iNow = 0;
			long iElapse = 0;




			sqlite3OsCurrentTimeInt64(db.pVfs, &iNow);
			iElapse = (long)((iNow - p.startTime) * 1000000);
			if ((db.xProfile) != null)
			{
				db.xProfile(db.pProfileArg, p.zSql, (ulong)(iElapse));
			}

			if ((db.mTrace & 0x02) != 0)
			{
				db.trace.xV2((uint)(0x02), db.pTraceArg, p, (void*)(&iElapse));
			}

			p.startTime = (long)(0);
		}
		public static int invokeValueDestructor(void* p, delegate17 xDel, sqlite3_context pCtx)
		{

			if ((xDel) == (null))
			{
			}
			else if ((xDel) == ((Void(Void * ))(-1)))
			{
			}
			else
			{
				xDel(p);
			}

			sqlite3_result_error_toobig(pCtx);
			return (int)(18);
		}
		public static int isAllZero(sbyte* z, int n)
		{
			int i = 0;
			for (i = (int)(0); (i) < (n); i++)
			{
				if ((z[i]) != 0)
					return (int)(0);
			}

			return (int)(1);
		}
		public static int isAlterableTable(Parse pParse, Table pTab)
		{
			if ((((0) == (sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7)))) || ((pTab.tabFlags & 0x00008000) != 0)) || (((pTab.tabFlags & 0x00001000) != 0) && ((sqlite3ReadOnlyShadowTables(pParse.db)) != 0)))
			{
				sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab.zName);
				return (int)(1);
			}

			return (int)(0);
		}
		public static int isAsteriskTerm(Parse pParse, Expr pTerm)
		{

			if ((pTerm.op) == (180))
				return (int)(1);
			if (pTerm.op != 141)
				return (int)(0);


			if (pTerm.pRight.op != 180)
				return (int)(0);
			sqlite3ErrorMsg(pParse, "RETURNING may not use \"TABLE.*\" wildcards");
			return (int)(1);
		}
		public static int isAuxiliaryVtabOperator(sqlite3 db, Expr pExpr, byte* peOp2, Expr ppLeft, Expr ppRight)
		{
			if ((pExpr.op) == (172))
			{
				ExprList pList;
				Expr pCol;
				int i = 0;

				pList = pExpr.x.pList;
				if (((pList) == (null)) || (pList.nExpr != 2))
				{
					return (int)(0);
				}

				pCol = pList.a[1].pExpr;

				if ((((((pCol).op) == (167)) && ((pCol).y.pTab != null)) && (((pCol).y.pTab.eTabType) == (1))))
				{
					for (i = (int)(0); (i) < ((int)(4 * sizeof(Op2) / sizeof(Op2))); i++)
					{

						if ((sqlite3StrICmp(pExpr.u.zToken, isAuxiliaryVtabOperator_aOp[i].zOp)) == (0))
						{
							*peOp2 = (byte)(isAuxiliaryVtabOperator_aOp[i].eOp2);
							ppRight = pList.a[0].pExpr;
							ppLeft = pCol;
							return (int)(1);
						}
					}
				}

				pCol = pList.a[0].pExpr;

				if ((((((pCol).op) == (167)) && ((pCol).y.pTab != null)) && (((pCol).y.pTab.eTabType) == (1))))
				{
					sqlite3_vtab pVtab;
					sqlite3_module pMod;
					delegate67 xNotUsed;
					void* pNotUsed;
					pVtab = sqlite3GetVTable(db, pCol.y.pTab).pVtab;



					pMod = pVtab.pModule;
					if (pMod.xFindFunction != null)
					{
						i = (int)(pMod.xFindFunction(pVtab, (int)(2), pExpr.u.zToken, &xNotUsed, &pNotUsed));
						if ((i) >= (150))
						{
							*peOp2 = (byte)(i);
							ppRight = pList.a[1].pExpr;
							ppLeft = pCol;
							return (int)(1);
						}
					}
				}
			}
			else if ((((pExpr.op) == (52)) || ((pExpr.op) == (171))) || ((pExpr.op) == (51)))
			{
				int res = (int)(0);
				Expr pLeft = pExpr.pLeft;
				Expr pRight = pExpr.pRight;

				if ((((((pLeft).op) == (167)) && ((pLeft).y.pTab != null)) && (((pLeft).y.pTab.eTabType) == (1))))
				{
					res++;
				}


				if (((pRight) != null) && (((((pRight).op) == (167)) && ((pRight).y.pTab != null)) && (((pRight).y.pTab.eTabType) == (1))))
				{
					res++;
					{
						Expr t = pLeft;
						pLeft = pRight;
						pRight = t;
					}
				}

				ppLeft = pLeft;
				ppRight = pRight;
				if ((pExpr.op) == (52))
					*peOp2 = (byte)(68);
				if ((pExpr.op) == (171))
					*peOp2 = (byte)(69);
				if ((pExpr.op) == (51))
					*peOp2 = (byte)(70);
				return (int)(res);
			}

			return (int)(0);
		}
		public static Select isCandidateForInOpt(Expr pX)
		{
			Select p;
			SrcList pSrc;
			ExprList pEList;
			Table pTab;
			int i = 0;
			if (!(((pX).flags & 0x000800) != 0))
				return null;
			if ((((pX).flags & (0x000020)) != 0))
				return null;
			p = pX.x.pSelect;
			if ((p.pPrior) != null)
				return null;
			if ((p.selFlags & (0x0000001 | 0x0000008)) != 0)
			{
				return null;
			}


			if ((p.pLimit) != null)
				return null;
			if ((p.pWhere) != null)
				return null;
			pSrc = p.pSrc;

			if (pSrc.nSrc != 1)
				return null;
			if ((pSrc.a[0].pSelect) != null)
				return null;
			pTab = pSrc.a[0].pTab;


			if ((((pTab).eTabType) == (1)))
				return null;
			pEList = p.pEList;

			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				Expr pRes = pEList.a[i].pExpr;
				if (pRes.op != 167)
					return null;

			}

			return p;
		}
		public static int isDate(sqlite3_context context, int argc, sqlite3_value argv, DateTime* p)
		{
			int i = 0; int n = 0;
			byte* z;
			int eType = 0;
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
			if ((argc) == (0))
			{
				if (sqlite3NotPureFunc(context) == 0)
					return (int)(1);
				return (int)(setDateTimeToCurrent(context, p));
			}

			if (((eType = (int)(sqlite3_value_type(argv[0]))) == (2)) || ((eType) == (1)))
			{
				setRawDateNumber(p, (double)(sqlite3_value_double(argv[0])));
			}
			else
			{
				z = sqlite3_value_text(argv[0]);
				if ((z == null) || ((parseDateOrTime(context, (sbyte*)(z), p)) != 0))
				{
					return (int)(1);
				}
			}

			for (i = (int)(1); (i) < (argc); i++)
			{
				z = sqlite3_value_text(argv[i]);
				n = (int)(sqlite3_value_bytes(argv[i]));
				if (((z) == (null)) || ((parseModifier(context, (sbyte*)(z), (int)(n), p, (int)(i))) != 0))
					return (int)(1);
			}

			computeJD(p);
			if (((p->isError) != 0) || (validJulianDay((long)(p->iJD)) == 0))
				return (int)(1);
			return (int)(0);
		}
		public static int isDistinctRedundant(Parse pParse, SrcList pTabList, WhereClause pWC, ExprList pDistinct)
		{
			Table pTab;
			Index pIdx;
			int i = 0;
			int iBase = 0;
			if (pTabList.nSrc != 1)
				return (int)(0);
			iBase = (int)(pTabList.a[0].iCursor);
			pTab = pTabList.a[0].pTab;
			for (i = (int)(0); (i) < (pDistinct.nExpr); i++)
			{
				Expr p = sqlite3ExprSkipCollateAndLikely(pDistinct.a[i].pExpr);
				if (((p) == (null)))
					continue;
				if ((p.op != 167) && (p.op != 169))
					continue;
				if (((p.iTable) == (iBase)) && ((p.iColumn) < (0)))
					return (int)(1);
			}

			for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				if (!((pIdx).onError != 0))
					continue;
				if ((pIdx.pPartIdxWhere) != null)
					continue;
				for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
				{
					if ((null) == (sqlite3WhereFindTerm(pWC, (int)(iBase), (int)(i), (ulong)(~(ulong)(0)), (uint)(0x0002), pIdx)))
					{
						if ((findIndexCol(pParse, pDistinct, (int)(iBase), pIdx, (int)(i))) < (0))
							break;
						if ((indexColumnNotNull(pIdx, (int)(i))) == (0))
							break;
					}
				}

				if ((i) == (pIdx.nKeyCol))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int isDupColumn(Index pIdx, int nKey, Index pPk, int iCol)
		{
			int i = 0; int j = 0;





			j = (int)(pPk.aiColumn[iCol]);

			for (i = (int)(0); (i) < (nKey); i++)
			{

				if (((pIdx.aiColumn[i]) == (j)) && ((sqlite3StrICmp(pIdx.azColl[i], pPk.azColl[iCol])) == (0)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int isFatalError(int rc)
		{
			return ((((rc != 0) && (rc != 5)) && (rc != 6)) ? 1 : 0);
		}
		public static int isLikeOrGlob(Parse pParse, Expr pExpr, Expr ppPrefix, int* pisComplete, int* pnoCase)
		{
			byte* z = null;
			Expr pRight; Expr pLeft;
			ExprList pList;
			byte c = 0;
			int cnt = 0;
			byte* wc = stackalloc byte[4];
			sqlite3 db = pParse.db;
			sqlite3_value pVal = null;
			int op = 0;
			int rc = 0;
			if (sqlite3IsLikeFunction(db, pExpr, pnoCase, (sbyte*)(wc)) == 0)
			{
				return (int)(0);
			}


			pList = pExpr.x.pList;
			pLeft = pList.a[1].pExpr;
			pRight = sqlite3ExprSkipCollate(pList.a[0].pExpr);
			op = (int)(pRight.op);
			if (((op) == (156)) && ((db.flags & 0x00800000) == (0)))
			{
				Vdbe pReprepare = pParse.pReprepare;
				int iCol = (int)(pRight.iColumn);
				pVal = sqlite3VdbeGetBoundValue(pReprepare, (int)(iCol), (byte)(0x41));
				if (((pVal) != null) && ((sqlite3_value_type(pVal)) == (3)))
				{
					z = sqlite3_value_text(pVal);
				}

				sqlite3VdbeSetVarmask(pParse.pVdbe, (int)(iCol));

			}
			else if ((op) == (117))
			{

				z = (byte*)(pRight.u.zToken);
			}

			if ((z) != null)
			{
				cnt = (int)(0);
				while (((((c = (byte)(z[cnt])) != 0) && (c != wc[0])) && (c != wc[1])) && (c != wc[2]))
				{
					cnt++;
					if (((c) == (wc[3])) && (z[cnt] != 0))
						cnt++;
				}

				if (((cnt != 0) && (255 != z[cnt - 1])) && (((cnt) > (1)) || (z[0] != wc[3])))
				{
					Expr pPrefix;
					*pisComplete = (int)(((c) == (wc[0])) && ((z[cnt + 1]) == (0)) ? 1 : 0);
					pPrefix = sqlite3Expr(db, (int)(117), (sbyte*)(z));
					if ((pPrefix) != null)
					{
						int iFrom = 0;
						int iTo = 0;
						sbyte* zNew;

						zNew = pPrefix.u.zToken;
						zNew[cnt] = (sbyte)(0);
						for (iFrom = (int)(iTo = (int)(0)); (iFrom) < (cnt); iFrom++)
						{
							if ((zNew[iFrom]) == (wc[3]))
								iFrom++;
							zNew[iTo++] = (sbyte)(zNew[iFrom]);
						}

						zNew[iTo] = (sbyte)(0);

						if (((pLeft.op != 167) || (sqlite3ExprAffinity(pLeft) != 0x42)) || ((((((pLeft).flags & (0x1000000 | 0x2000000)) == (0)) != 0) && ((pLeft.y.pTab) != null)) && (((pLeft.y.pTab).eTabType) == (1))))
						{
							int isNum = 0;
							double rDummy = 0;
							isNum = (int)(sqlite3AtoF(zNew, &rDummy, (int)(iTo), (byte)(1)));
							if ((isNum) <= (0))
							{
								if (((iTo) == (1)) && ((zNew[0]) == (45)))
								{
									isNum = (int)(+1);
								}
								else
								{
									zNew[iTo - 1]++;
									isNum = (int)(sqlite3AtoF(zNew, &rDummy, (int)(iTo), (byte)(1)));
									zNew[iTo - 1]--;
								}
							}

							if ((isNum) > (0))
							{
								sqlite3ExprDelete(db, pPrefix);
								sqlite3ValueFree(pVal);
								return (int)(0);
							}
						}
					}

					ppPrefix = pPrefix;
					if ((op) == (156))
					{
						Vdbe v = pParse.pVdbe;
						sqlite3VdbeSetVarmask(v, (int)(pRight.iColumn));

						if (((*pisComplete) != 0) && ((pRight.u.zToken[1]) != 0))
						{
							int r1 = (int)(sqlite3GetTempReg(pParse));
							sqlite3ExprCodeTarget(pParse, pRight, (int)(r1));
							sqlite3VdbeChangeP3(v, (int)(sqlite3VdbeCurrentAddr(v) - 1), (int)(0));
							sqlite3ReleaseTempReg(pParse, (int)(r1));
						}
					}
				}
				else
				{
					z = null;
				}
			}

			rc = (int)(z != null);
			sqlite3ValueFree(pVal);
			return (int)(rc);
		}
		public static int isLimitTerm(WhereTerm pTerm)
		{

			return (((pTerm.eMatchOp) >= (73)) && ((pTerm.eMatchOp) <= (74)) ? 1 : 0);
		}
		public static int isLookaside(sqlite3 db, void* p)
		{
			return (((((ulong)(p)) >= ((ulong)(db.lookaside.pStart))) && (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))) ? 1 : 0);
		}
		public static int isRealTable(Parse pParse, Table pTab, int bDrop)
		{
			sbyte* zType = null;
			if ((((pTab).eTabType) == (2)))
			{
				zType = "view";
			}

			if ((((pTab).eTabType) == (1)))
			{
				zType = "virtual table";
			}

			if ((zType) != null)
			{
				sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"", ((bDrop) != 0 ? "drop column from" : "rename columns of"), zType, pTab.zName);
				return (int)(1);
			}

			return (int)(0);
		}
		public static SrcItem isSelfJoinView(SrcList pTabList, SrcItem pThis)
		{
			SrcItem pItem;

			if ((pThis.pSelect.selFlags & 0x1000000) != 0)
				return null;
			for (pItem = pTabList.a; (pItem) < (pThis); pItem++)
			{
				Select pS1;
				if ((pItem.pSelect) == (null))
					continue;
				if ((pItem.fg.viaCoroutine) != 0)
					continue;
				if ((pItem.zName) == (null))
					continue;


				if (pItem.pTab.pSchema != pThis.pTab.pSchema)
					continue;
				if (sqlite3_stricmp(pItem.zName, pThis.zName) != 0)
					continue;
				pS1 = pItem.pSelect;
				if (((pItem.pTab.pSchema) == (null)) && (pThis.pSelect.selId != pS1.selId))
				{
					continue;
				}

				if ((pItem.pSelect.selFlags & 0x1000000) != 0)
				{
					continue;
				}

				return pItem;
			}

			return null;
		}
		public static int isSetNullAction(Parse pParse, FKey pFKey)
		{
			Parse pTop = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			if ((pTop.pTriggerPrg) != null)
			{
				Trigger p = pTop.pTriggerPrg.pTrigger;
				if ((((p) == (pFKey.apTrigger[0])) && ((pFKey.aAction[0]) == (8))) || (((p) == (pFKey.apTrigger[1])) && ((pFKey.aAction[1]) == (8))))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static Table isSimpleCount(Select p, AggInfo pAggInfo)
		{
			Table pTab;
			Expr pExpr;

			if ((((((p.pWhere) != null) || (p.pEList.nExpr != 1)) || (p.pSrc.nSrc != 1)) || ((p.pSrc.a[0].pSelect) != null)) || (pAggInfo.nFunc != 1))
			{
				return null;
			}

			pTab = p.pSrc.a[0].pTab;


			if (!(((pTab).eTabType) == (0)))
				return null;
			pExpr = p.pEList.a[0].pExpr;

			if (pExpr.op != 168)
				return null;
			if (pExpr.pAggInfo != pAggInfo)
				return null;
			if ((pAggInfo.aFunc[0].pFunc.funcFlags & 0x0100) == (0))
				return null;

			if ((((pExpr).flags & (0x000002 | 0x1000000)) != 0))
				return null;
			return pTab;
		}
		public static long journalHdrOffset(Pager pPager)
		{
			long offset = (long)(0);
			long c = (long)(pPager.journalOff);
			if ((c) != 0)
			{
				offset = (long)(((c - 1) / (pPager.sectorSize) + 1) * (pPager.sectorSize));
			}




			return (long)(offset);
		}
		public static int jrnlBufferSize(Pager pPager)
		{

			(void)(pPager);
			return (int)(0);
		}
		public static void jsonAppendChar(JsonString p, sbyte c)
		{
			if (((p.nUsed) >= (p.nAlloc)) && (jsonGrow(p, (uint)(1)) != 0))
				return;
			p.zBuf[p.nUsed++] = (sbyte)(c);
		}
		public static void jsonAppendRaw(JsonString p, sbyte* zIn, uint N)
		{
			if ((N) == (0))
				return;
			if (((N + p.nUsed) >= (p.nAlloc)) && (jsonGrow(p, (uint)(N)) != 0))
				return;
			CRuntime.memcpy(p.zBuf + p.nUsed, zIn, (ulong)(N));
			p.nUsed += (ulong)(N);
		}
		public static void jsonAppendSeparator(JsonString p)
		{
			sbyte c = 0;
			if ((p.nUsed) == (0))
				return;
			c = (sbyte)(p.zBuf[p.nUsed - 1]);
			if ((c != 91) && (c != 123))
				jsonAppendChar(p, (sbyte)(44));
		}
		public static void jsonAppendString(JsonString p, sbyte* zIn, uint N)
		{
			uint i = 0;
			if (((zIn) == (null)) || (((N + p.nUsed + 2) >= (p.nAlloc)) && (jsonGrow(p, (uint)(N + 2)) != 0)))
				return;
			p.zBuf[p.nUsed++] = (sbyte)(34);
			for (i = (uint)(0); (i) < (N); i++)
			{
				byte c = (byte)(((byte*)(zIn))[i]);
				if (((c) == (34)) || ((c) == (92)))
				{
				json_simple_escape:
					;
					if (((p.nUsed + N + 3 - i) > (p.nAlloc)) && (jsonGrow(p, (uint)(N + 3 - i)) != 0))
						return;
					p.zBuf[p.nUsed++] = (sbyte)(92);
				}
				else if ((c) <= (0x1f))
				{






					if ((jsonAppendString_aSpecial[c]) != 0)
					{
						c = (byte)(jsonAppendString_aSpecial[c]);
						goto json_simple_escape;
					}

					if (((p.nUsed + N + 7 + i) > (p.nAlloc)) && (jsonGrow(p, (uint)(N + 7 - i)) != 0))
						return;
					p.zBuf[p.nUsed++] = (sbyte)(92);
					p.zBuf[p.nUsed++] = (sbyte)(117);
					p.zBuf[p.nUsed++] = (sbyte)(48);
					p.zBuf[p.nUsed++] = (sbyte)(48);
					p.zBuf[p.nUsed++] = (sbyte)(48 + (c >> 4));
					c = (byte)("0123456789abcdef"[c & 0xf]);
				}

				p.zBuf[p.nUsed++] = (sbyte)(c);
			}

			p.zBuf[p.nUsed++] = (sbyte)(34);

		}
		public static void jsonAppendValue(JsonString p, sqlite3_value pValue)
		{
			switch (sqlite3_value_type(pValue))
			{
				case 5:
					{
						jsonAppendRaw(p, "null", (uint)(4));
						break;
					}

				case 1:
				case 2:
					{
						sbyte* z = (sbyte*)(sqlite3_value_text(pValue));
						uint n = (uint)(sqlite3_value_bytes(pValue));
						jsonAppendRaw(p, z, (uint)(n));
						break;
					}

				case 3:
					{
						sbyte* z = (sbyte*)(sqlite3_value_text(pValue));
						uint n = (uint)(sqlite3_value_bytes(pValue));
						if ((sqlite3_value_subtype(pValue)) == (74))
						{
							jsonAppendRaw(p, z, (uint)(n));
						}
						else
						{
							jsonAppendString(p, z, (uint)(n));
						}

						break;
					}

				default:
					{
						if ((p.bErr) == (0))
						{
							sqlite3_result_error(p.pCtx, "JSON cannot hold BLOB values", (int)(-1));
							p.bErr = (byte)(2);
							jsonReset(p);
						}

						break;
					}
			}
		}
		public static void jsonArrayCompute(sqlite3_context ctx, int isFinal)
		{
			JsonString pStr;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
			if ((pStr) != null)
			{
				pStr.pCtx = ctx;
				jsonAppendChar(pStr, (sbyte)(93));
				if ((pStr.bErr) != 0)
				{
					if ((pStr.bErr) == (1))
						sqlite3_result_error_nomem(ctx);

				}
				else if ((isFinal) != 0)
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), (pStr.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free);
					pStr.bStatic = (byte)(1);
				}
				else
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), ((Void(Void * ))(-1)));
					pStr.nUsed--;
				}
			}
			else
			{
				sqlite3_result_text(ctx, "[]", (int)(2), null);
			}

			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonArrayFinal(sqlite3_context ctx)
		{
			jsonArrayCompute(ctx, (int)(1));
		}
		public static void jsonArrayFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			int i = 0;
			JsonString jx = new JsonString();
			jsonInit(jx, ctx);
			jsonAppendChar(jx, (sbyte)(91));
			for (i = (int)(0); (i) < (argc); i++)
			{
				jsonAppendSeparator(jx);
				jsonAppendValue(jx, argv[i]);
			}

			jsonAppendChar(jx, (sbyte)(93));
			jsonResult(jx);
			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonArrayLengthFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			long n = (long)(0);
			uint i = 0;
			JsonNode* pNode;
			p = jsonParseCached(ctx, argv, ctx);
			if ((p) == (null))
				return;

			if ((argc) == (2))
			{
				sbyte* zPath = (sbyte*)(sqlite3_value_text(argv[1]));
				pNode = jsonLookup(p, zPath, null, ctx);
			}
			else
			{
				pNode = p->aNode;
			}

			if ((pNode) == (null))
			{
				return;
			}

			if ((pNode->eType) == (6))
			{

				for (i = (uint)(1); (i) <= (pNode->n); n++)
				{
					i += (uint)(jsonNodeSize(&pNode[i]));
				}
			}

			sqlite3_result_int64(ctx, (long)(n));
		}
		public static void jsonArrayStep(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonString pStr;

			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(sizeof(JsonString))));
			if ((pStr) != null)
			{
				if ((pStr.zBuf) == (null))
				{
					jsonInit(pStr, ctx);
					jsonAppendChar(pStr, (sbyte)(91));
				}
				else if ((pStr.nUsed) > (1))
				{
					jsonAppendChar(pStr, (sbyte)(44));
				}

				pStr.pCtx = ctx;
				jsonAppendValue(pStr, argv[0]);
			}
		}
		public static void jsonArrayValue(sqlite3_context ctx)
		{
			jsonArrayCompute(ctx, (int)(0));
		}
		public static int jsonEachBestIndex(sqlite3_vtab tab, sqlite3_index_info* pIdxInfo)
		{
			int i = 0;
			int* aIdx = stackalloc int[2];
			int unusableMask = (int)(0);
			int idxMask = (int)(0);
			sqlite3_index_constraint* pConstraint;

			(void)(tab);
			aIdx[0] = (int)(aIdx[1] = (int)(-1));
			pConstraint = pIdxInfo->aConstraint;
			for (i = (int)(0); (i) < (pIdxInfo->nConstraint); i++, pConstraint++)
			{
				int iCol = 0;
				int iMask = 0;
				if ((pConstraint->iColumn) < (8))
					continue;
				iCol = (int)(pConstraint->iColumn - 8);

				iMask = (int)(1 << iCol);
				if ((pConstraint->usable) == (0))
				{
					unusableMask |= (int)(iMask);
				}
				else if ((pConstraint->op) == (2))
				{
					aIdx[iCol] = (int)(i);
					idxMask |= (int)(iMask);
				}
			}

			if ((unusableMask & ~idxMask) != 0)
			{
				return (int)(19);
			}

			if ((aIdx[0]) < (0))
			{
				pIdxInfo->idxNum = (int)(0);
			}
			else
			{
				pIdxInfo->estimatedCost = (double)(1.0);
				i = (int)(aIdx[0]);
				pIdxInfo->aConstraintUsage[i].argvIndex = (int)(1);
				pIdxInfo->aConstraintUsage[i].omit = (byte)(1);
				if ((aIdx[1]) < (0))
				{
					pIdxInfo->idxNum = (int)(1);
				}
				else
				{
					i = (int)(aIdx[1]);
					pIdxInfo->aConstraintUsage[i].argvIndex = (int)(2);
					pIdxInfo->aConstraintUsage[i].omit = (byte)(1);
					pIdxInfo->idxNum = (int)(3);
				}
			}

			return (int)(0);
		}
		public static int jsonEachClose(sqlite3_vtab_cursor cur)
		{
			JsonEachCursor p = (JsonEachCursor)(cur);
			jsonEachCursorReset(p);
			sqlite3_free(cur);
			return (int)(0);
		}
		public static int jsonEachColumn(sqlite3_vtab_cursor cur, sqlite3_context ctx, int i)
		{
			JsonEachCursor p = (JsonEachCursor)(cur);
			JsonNode* pThis = &p.sParse.aNode[p.i];
			switch (i)
			{
				case 0:
					{
						if ((p.i) == (0))
							break;
						if ((p.eType) == (7))
						{
							jsonReturn(pThis, ctx, null);
						}
						else if ((p.eType) == (6))
						{
							uint iKey = 0;
							if ((p.bRecursive) != 0)
							{
								if ((p.iRowid) == (0))
									break;

								iKey = (uint)(p.sParse.aNode[p.sParse.aUp[p.i]].u.iKey);
							}
							else
							{
								iKey = (uint)(p.iRowid);
							}

							sqlite3_result_int64(ctx, (long)(iKey));
						}

						break;
					}

				case 1:
					{
						if ((pThis->jnFlags & 0x40) != 0)
							pThis++;
						jsonReturn(pThis, ctx, null);
						break;
					}

				case 2:
					{
						if ((pThis->jnFlags & 0x40) != 0)
							pThis++;
						sqlite3_result_text(ctx, jsonType[pThis->eType], (int)(-1), null);
						break;
					}

				case 3:
					{
						if ((pThis->jnFlags & 0x40) != 0)
							pThis++;
						if ((pThis->eType) >= (6))
							break;
						jsonReturn(pThis, ctx, null);
						break;
					}

				case 4:
					{
						sqlite3_result_int64(ctx, (long)((long)(p.i) + ((pThis->jnFlags & 0x40) != 0)));
						break;
					}

				case 5:
					{
						if (((p.i) > (p.iBegin)) && ((p.bRecursive) != 0))
						{
							sqlite3_result_int64(ctx, (long)(p.sParse.aUp[p.i]));
						}

						break;
					}

				case 6:
					{
						JsonString x = new JsonString();
						jsonInit(x, ctx);
						if ((p.bRecursive) != 0)
						{
							jsonEachComputePath(p, x, (uint)(p.i));
						}
						else
						{
							if ((p.zRoot) != null)
							{
								jsonAppendRaw(x, p.zRoot, (uint)((int)(CRuntime.strlen(p.zRoot))));
							}
							else
							{
								jsonAppendChar(x, (sbyte)(36));
							}

							if ((p.eType) == (6))
							{
								jsonPrintf((int)(30), x, "[%d]", (uint)(p.iRowid));
							}
							else if ((p.eType) == (7))
							{

								jsonPrintf((int)(pThis->n), x, ".%.*s", (uint)(pThis->n - 2), pThis->u.zJContent + 1);
							}
						}

						jsonResult(x);
						break;
					}

				case 7:
					{
						if ((p.bRecursive) != 0)
						{
							JsonString x = new JsonString();
							jsonInit(x, ctx);
							jsonEachComputePath(p, x, (uint)(p.sParse.aUp[p.i]));
							jsonResult(x);
							break;
						}
					}

				default:
					{
						sbyte* zRoot = p.zRoot;
						if ((zRoot) == (null))
							zRoot = "$";
						sqlite3_result_text(ctx, zRoot, (int)(-1), null);
						break;
					}

				case 8:
					{

						sqlite3_result_text(ctx, p.sParse.zJson, (int)(-1), null);
						break;
					}
			}

			return (int)(0);
		}
		public static void jsonEachComputePath(JsonEachCursor p, JsonString pStr, uint i)
		{
			JsonNode* pNode; JsonNode* pUp;
			uint iUp = 0;
			if ((i) == (0))
			{
				jsonAppendChar(pStr, (sbyte)(36));
				return;
			}

			iUp = (uint)(p.sParse.aUp[i]);
			jsonEachComputePath(p, pStr, (uint)(iUp));
			pNode = &p.sParse.aNode[i];
			pUp = &p.sParse.aNode[iUp];
			if ((pUp->eType) == (6))
			{

				jsonPrintf((int)(30), pStr, "[%d]", (uint)(pUp->u.iKey));
			}
			else
			{

				if ((pNode->jnFlags & 0x40) == (0))
					pNode--;



				jsonPrintf((int)(pNode->n + 1), pStr, ".%.*s", (uint)(pNode->n - 2), pNode->u.zJContent + 1);
			}
		}
		public static int jsonEachConnect(sqlite3 db, void* pAux, int argc, sbyte** argv, sqlite3_vtab ppVtab, sbyte** pzErr)
		{
			sqlite3_vtab pNew;
			int rc = 0;
			(void)(pzErr);
			(void)(argv);

			(void)(pAux);
			rc = (int)(sqlite3_declare_vtab(db, "CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,json HIDDEN,root HIDDEN)"));
			if ((rc) == (0))
			{
				pNew = ppVtab = sqlite3_malloc((int)(sizeof(sqlite3_vtab)));
				if ((pNew) == (null))
					return (int)(7);
				CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(sqlite3_vtab)));
				sqlite3_vtab_config(db, (int)(2));
			}

			return (int)(rc);
		}
		public static void jsonEachCursorReset(JsonEachCursor p)
		{
			sqlite3_free(p.zJson);
			sqlite3_free(p.zRoot);
			jsonParseReset(&p.sParse);
			p.iRowid = (uint)(0);
			p.i = (uint)(0);
			p.iEnd = (uint)(0);
			p.eType = (byte)(0);
			p.zJson = null;
			p.zRoot = null;
		}
		public static int jsonEachDisconnect(sqlite3_vtab pVtab)
		{
			sqlite3_free(pVtab);
			return (int)(0);
		}
		public static int jsonEachEof(sqlite3_vtab_cursor cur)
		{
			JsonEachCursor p = (JsonEachCursor)(cur);
			return ((p.i) >= (p.iEnd) ? 1 : 0);
		}
		public static int jsonEachFilter(sqlite3_vtab_cursor cur, int idxNum, sbyte* idxStr, int argc, sqlite3_value argv)
		{
			JsonEachCursor p = (JsonEachCursor)(cur);
			sbyte* z;
			sbyte* zRoot = null;
			long n = 0;
			(void)(idxStr);

			jsonEachCursorReset(p);
			if ((idxNum) == (0))
				return (int)(0);
			z = (sbyte*)(sqlite3_value_text(argv[0]));
			if ((z) == (null))
				return (int)(0);
			n = (long)(sqlite3_value_bytes(argv[0]));
			p.zJson = sqlite3_malloc64((ulong)(n + 1));
			if ((p.zJson) == (null))
				return (int)(7);
			CRuntime.memcpy(p.zJson, z, (ulong)((ulong)(n) + 1));
			if ((jsonParse(&p.sParse, null, p.zJson)) != 0)
			{
				int rc = (int)(7);
				if ((p.sParse.oom) == (0))
				{
					sqlite3_free(cur.pVtab.zErrMsg);
					cur.pVtab.zErrMsg = sqlite3_mprintf("malformed JSON");
					if ((cur.pVtab.zErrMsg) != null)
						rc = (int)(1);
				}

				jsonEachCursorReset(p);
				return (int)(rc);
			}
			else if (((p.bRecursive) != 0) && ((jsonParseFindParents(&p.sParse)) != 0))
			{
				jsonEachCursorReset(p);
				return (int)(7);
			}
			else
			{
				JsonNode* pNode = null;
				if ((idxNum) == (3))
				{
					sbyte* zErr = null;
					zRoot = (sbyte*)(sqlite3_value_text(argv[1]));
					if ((zRoot) == (null))
						return (int)(0);
					n = (long)(sqlite3_value_bytes(argv[1]));
					p.zRoot = sqlite3_malloc64((ulong)(n + 1));
					if ((p.zRoot) == (null))
						return (int)(7);
					CRuntime.memcpy(p.zRoot, zRoot, (ulong)((ulong)(n) + 1));
					if (zRoot[0] != 36)
					{
						zErr = zRoot;
					}
					else
					{
						pNode = jsonLookupStep(&p.sParse, (uint)(0), p.zRoot + 1, null, &zErr);
					}

					if ((zErr) != null)
					{
						sqlite3_free(cur.pVtab.zErrMsg);
						cur.pVtab.zErrMsg = jsonPathSyntaxError(zErr);
						jsonEachCursorReset(p);
						return (int)((cur.pVtab.zErrMsg) != 0 ? 1 : 7);
					}
					else if ((pNode) == (null))
					{
						return (int)(0);
					}
				}
				else
				{
					pNode = p.sParse.aNode;
				}

				p.iBegin = (uint)(p.i = (uint)((int)(pNode - p.sParse.aNode)));
				p.eType = (byte)(pNode->eType);
				if ((p.eType) >= (6))
				{

					pNode->u.iKey = (uint)(0);
					p.iEnd = (uint)(p.i + pNode->n + 1);
					if ((p.bRecursive) != 0)
					{
						p.eType = (byte)(p.sParse.aNode[p.sParse.aUp[p.i]].eType);
						if (((p.i) > (0)) && ((p.sParse.aNode[p.i - 1].jnFlags & 0x40) != 0))
						{
							p.i--;
						}
					}
					else
					{
						p.i++;
					}
				}
				else
				{
					p.iEnd = (uint)(p.i + 1);
				}
			}

			return (int)(0);
		}
		public static int jsonEachNext(sqlite3_vtab_cursor cur)
		{
			JsonEachCursor p = (JsonEachCursor)(cur);
			if ((p.bRecursive) != 0)
			{
				if ((p.sParse.aNode[p.i].jnFlags & 0x40) != 0)
					p.i++;
				p.i++;
				p.iRowid++;
				if ((p.i) < (p.iEnd))
				{
					uint iUp = (uint)(p.sParse.aUp[p.i]);
					JsonNode* pUp = &p.sParse.aNode[iUp];
					p.eType = (byte)(pUp->eType);
					if ((pUp->eType) == (6))
					{

						if ((iUp) == (p.i - 1))
						{
							pUp->u.iKey = (uint)(0);
						}
						else
						{
							pUp->u.iKey++;
						}
					}
				}
			}
			else
			{
				switch (p.eType)
				{
					case 6:
						{
							p.i += (uint)(jsonNodeSize(&p.sParse.aNode[p.i]));
							p.iRowid++;
							break;
						}

					case 7:
						{
							p.i += (uint)(1 + jsonNodeSize(&p.sParse.aNode[p.i + 1]));
							p.iRowid++;
							break;
						}

					default:
						{
							p.i = (uint)(p.iEnd);
							break;
						}
				}
			}

			return (int)(0);
		}
		public static int jsonEachOpenEach(sqlite3_vtab p, sqlite3_vtab_cursor ppCursor)
		{
			JsonEachCursor pCur;
			(void)(p);
			pCur = sqlite3_malloc((int)(sizeof(JsonEachCursor)));
			if ((pCur) == (null))
				return (int)(7);
			CRuntime.memset(pCur, (int)(0), (ulong)(sizeof(JsonEachCursor)));
			ppCursor = pCur._base_;
			return (int)(0);
		}
		public static int jsonEachOpenTree(sqlite3_vtab p, sqlite3_vtab_cursor ppCursor)
		{
			int rc = (int)(jsonEachOpenEach(p, ppCursor));
			if ((rc) == (0))
			{
				JsonEachCursor pCur = (JsonEachCursor)(ppCursor);
				pCur.bRecursive = (byte)(1);
			}

			return (int)(rc);
		}
		public static int jsonEachRowid(sqlite3_vtab_cursor cur, long* pRowid)
		{
			JsonEachCursor p = (JsonEachCursor)(cur);
			*pRowid = (long)(p.iRowid);
			return (int)(0);
		}
		public static void jsonExtractFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			JsonNode* pNode;
			sbyte* zPath;
			int flags = ((int)((long)(sqlite3_user_data(ctx))));
			JsonString jx = new JsonString();
			if ((argc) < (2))
				return;
			p = jsonParseCached(ctx, argv, ctx);
			if ((p) == (null))
				return;
			if ((argc) == (2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[1]));
				if ((zPath) == (null))
					return;
				if ((flags & 0x03) != 0)
				{
					if (zPath[0] != 36)
					{
						jsonInit(jx, ctx);
						if ((sqlite3CtypeMap[(byte)(zPath[0])] & 0x04) != 0)
						{
							jsonAppendRaw(jx, "$[", (uint)(2));
							jsonAppendRaw(jx, zPath, (uint)((int)(CRuntime.strlen(zPath))));
							jsonAppendRaw(jx, "]", (uint)(2));
						}
						else
						{
							jsonAppendRaw(jx, "$.", (uint)(1 + (zPath[0] != 91)));
							jsonAppendRaw(jx, zPath, (uint)((int)(CRuntime.strlen(zPath))));
							jsonAppendChar(jx, (sbyte)(0));
						}

						pNode = (jx.bErr) != 0 ? null : jsonLookup(p, jx.zBuf, null, ctx);
						jsonReset(jx);
					}
					else
					{
						pNode = jsonLookup(p, zPath, null, ctx);
					}

					if ((pNode) != null)
					{
						if ((flags & 0x01) != 0)
						{
							jsonReturnJson(pNode, ctx, null);
						}
						else
						{
							jsonReturn(pNode, ctx, null);
							sqlite3_result_subtype(ctx, (uint)(0));
						}
					}
				}
				else
				{
					pNode = jsonLookup(p, zPath, null, ctx);
					if (((p->nErr) == (0)) && ((pNode) != null))
						jsonReturn(pNode, ctx, null);
				}
			}
			else
			{
				int i = 0;
				jsonInit(jx, ctx);
				jsonAppendChar(jx, (sbyte)(91));
				for (i = (int)(1); (i) < (argc); i++)
				{
					zPath = (sbyte*)(sqlite3_value_text(argv[i]));
					pNode = jsonLookup(p, zPath, null, ctx);
					if ((p->nErr) != 0)
						break;
					jsonAppendSeparator(jx);
					if ((pNode) != null)
					{
						jsonRenderNode(pNode, jx, null);
					}
					else
					{
						jsonAppendRaw(jx, "null", (uint)(4));
					}
				}

				if ((i) == (argc))
				{
					jsonAppendChar(jx, (sbyte)(93));
					jsonResult(jx);
					sqlite3_result_subtype(ctx, (uint)(74));
				}

				jsonReset(jx);
			}
		}
		public static void jsonGroupInverse(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			uint i = 0;
			int inStr = (int)(0);
			int nNest = (int)(0);
			sbyte* z;
			sbyte c = 0;
			JsonString pStr;

			(void)(argv);
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
			if ((!pStr) != 0)
				return;
			z = pStr.zBuf;
			for (i = (uint)(1); ((i) < (pStr.nUsed)) && ((((c = (sbyte)(z[i])) != 44) || ((inStr) != 0)) || ((nNest) != 0)); i++)
			{
				if ((c) == (34))
				{
					inStr = (int)(!inStr);
				}
				else if ((c) == (92))
				{
					i++;
				}
				else if (inStr == 0)
				{
					if (((c) == (123)) || ((c) == (91)))
						nNest++;
					if (((c) == (125)) || ((c) == (93)))
						nNest--;
				}
			}

			if ((i) < (pStr.nUsed))
			{
				pStr.nUsed -= (ulong)(i);
				CRuntime.memmove(&z[1], &z[i + 1], (ulong)(pStr.nUsed - 1));
				z[pStr.nUsed] = (sbyte)(0);
			}
			else
			{
				pStr.nUsed = (ulong)(1);
			}
		}
		public static int jsonGrow(JsonString p, uint N)
		{
			ulong nTotal = (ulong)((N) < (p.nAlloc) ? p.nAlloc * 2 : p.nAlloc + N + 10);
			sbyte* zNew;
			if ((p.bStatic) != 0)
			{
				if ((p.bErr) != 0)
					return (int)(1);
				zNew = sqlite3_malloc64((ulong)(nTotal));
				if ((zNew) == (null))
				{
					jsonOom(p);
					return (int)(7);
				}

				CRuntime.memcpy(zNew, p.zBuf, (ulong)(p.nUsed));
				p.zBuf = zNew;
				p.bStatic = (byte)(0);
			}
			else
			{
				zNew = sqlite3_realloc64(p.zBuf, (ulong)(nTotal));
				if ((zNew) == (null))
				{
					jsonOom(p);
					return (int)(7);
				}

				p.zBuf = zNew;
			}

			p.nAlloc = (ulong)(nTotal);
			return (int)(0);
		}
		public static byte jsonHexToInt(int h)
		{

			h += (int)(9 * (1 & (h >> 6)));
			return (byte)(h & 0xf);
		}
		public static uint jsonHexToInt4(sbyte* z)
		{
			uint v = 0;




			v = (uint)((jsonHexToInt((int)(z[0])) << 12) + (jsonHexToInt((int)(z[1])) << 8) + (jsonHexToInt((int)(z[2])) << 4) + jsonHexToInt((int)(z[3])));
			return (uint)(v);
		}
		public static void jsonInit(JsonString p, sqlite3_context pCtx)
		{
			p.pCtx = pCtx;
			p.bErr = (byte)(0);
			jsonZero(p);
		}
		public static int jsonIs4Hex(sbyte* z)
		{
			int i = 0;
			for (i = (int)(0); (i) < (4); i++)
			{
				if ((sqlite3CtypeMap[(byte)(z[i])] & 0x08) == 0)
					return (int)(0);
			}

			return (int)(1);
		}
		public static int jsonLabelCompare(JsonNode* pNode, sbyte* zKey, uint nKey)
		{

			if ((pNode->jnFlags & 0x01) != 0)
			{
				if (pNode->n != nKey)
					return (int)(0);
				return ((CRuntime.strncmp(pNode->u.zJContent, zKey, (ulong)(nKey))) == (0) ? 1 : 0);
			}
			else
			{
				if (pNode->n != nKey + 2)
					return (int)(0);
				return ((CRuntime.strncmp(pNode->u.zJContent + 1, zKey, (ulong)(nKey))) == (0) ? 1 : 0);
			}
		}
		public static JsonNode* jsonLookup(JsonParse* pParse, sbyte* zPath, int* pApnd, sqlite3_context pCtx)
		{
			sbyte* zErr = null;
			JsonNode* pNode = null;
			sbyte* zMsg;
			if ((zPath) == (null))
				return null;
			if (zPath[0] != 36)
			{
				zErr = zPath;
				goto lookup_err;
			}

			zPath++;
			pNode = jsonLookupStep(pParse, (uint)(0), zPath, pApnd, &zErr);
			if ((zErr) == (null))
				return pNode;
			lookup_err:
			; pParse->nErr++;

			zMsg = jsonPathSyntaxError(zErr);
			if ((zMsg) != null)
			{
				sqlite3_result_error(pCtx, zMsg, (int)(-1));
				sqlite3_free(zMsg);
			}
			else
			{
				sqlite3_result_error_nomem(pCtx);
			}

			return null;
		}
		public static JsonNode* jsonLookupAppend(JsonParse* pParse, sbyte* zPath, int* pApnd, sbyte** pzErr)
		{
			*pApnd = (int)(1);
			if ((zPath[0]) == (0))
			{
				jsonParseAddNode(pParse, (uint)(0), (uint)(0), null);
				return (pParse->oom) != 0 ? null : &pParse->aNode[pParse->nNode - 1];
			}

			if ((zPath[0]) == (46))
			{
				jsonParseAddNode(pParse, (uint)(7), (uint)(0), null);
			}
			else if ((CRuntime.strncmp(zPath, "[0]", (ulong)(3))) == (0))
			{
				jsonParseAddNode(pParse, (uint)(6), (uint)(0), null);
			}
			else
			{
				return null;
			}

			if ((pParse->oom) != 0)
				return null;
			return jsonLookupStep(pParse, (uint)(pParse->nNode - 1), zPath, pApnd, pzErr);
		}
		public static JsonNode* jsonLookupStep(JsonParse* pParse, uint iRoot, sbyte* zPath, int* pApnd, sbyte** pzErr)
		{
			uint i = 0; uint j = 0; uint nKey = 0;
			sbyte* zKey;
			JsonNode* pRoot = &pParse->aNode[iRoot];
			if ((zPath[0]) == (0))
				return pRoot;
			if ((pRoot->jnFlags & 0x08) != 0)
				return null;
			if ((zPath[0]) == (46))
			{
				if (pRoot->eType != 7)
					return null;
				zPath++;
				if ((zPath[0]) == (34))
				{
					zKey = zPath + 1;
					for (i = (uint)(1); ((zPath[i]) != 0) && (zPath[i] != 34); i++)
					{
					}

					nKey = (uint)(i - 1);
					if ((zPath[i]) != 0)
					{
						i++;
					}
					else
					{
						*pzErr = zPath;
						return null;
					}
				}
				else
				{
					zKey = zPath;
					for (i = (uint)(0); (((zPath[i]) != 0) && (zPath[i] != 46)) && (zPath[i] != 91); i++)
					{
					}

					nKey = (uint)(i);
				}

				if ((nKey) == (0))
				{
					*pzErr = zPath;
					return null;
				}

				j = (uint)(1);
				for (; ; )
				{
					while ((j) <= (pRoot->n))
					{
						if ((jsonLabelCompare(pRoot + j, zKey, (uint)(nKey))) != 0)
						{
							return jsonLookupStep(pParse, (uint)(iRoot + j + 1), &zPath[i], pApnd, pzErr);
						}

						j++;
						j += (uint)(jsonNodeSize(&pRoot[j]));
					}

					if ((pRoot->jnFlags & 0x20) == (0))
						break;

					iRoot += (uint)(pRoot->u.iAppend);
					pRoot = &pParse->aNode[iRoot];
					j = (uint)(1);
				}

				if ((pApnd) != null)
				{
					uint iStart = 0;
					uint iLabel = 0;
					JsonNode* pNode;
					iStart = (uint)(jsonParseAddNode(pParse, (uint)(7), (uint)(2), null));
					iLabel = (uint)(jsonParseAddNode(pParse, (uint)(5), (uint)(nKey), zKey));
					zPath += i;
					pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
					if ((pParse->oom) != 0)
						return null;
					if ((pNode) != null)
					{
						pRoot = &pParse->aNode[iRoot];

						pRoot->u.iAppend = (uint)(iStart - iRoot);
						pRoot->jnFlags |= (byte)(0x20);
						pParse->aNode[iLabel].jnFlags |= (byte)(0x01);
					}

					return pNode;
				}
			}
			else if ((zPath[0]) == (91))
			{
				i = (uint)(0);
				j = (uint)(1);
				while ((sqlite3CtypeMap[(byte)(zPath[j])] & 0x04) != 0)
				{
					i = (uint)(i * 10 + zPath[j] - 48);
					j++;
				}

				if (((j) < (2)) || (zPath[j] != 93))
				{
					if ((zPath[1]) == (35))
					{
						JsonNode* pBase = pRoot;
						int iBase = (int)(iRoot);
						if (pRoot->eType != 6)
							return null;
						for (; ; )
						{
							while ((j) <= (pBase->n))
							{
								if ((pBase[j].jnFlags & 0x04) == (0))
									i++;
								j += (uint)(jsonNodeSize(&pBase[j]));
							}

							if ((pBase->jnFlags & 0x20) == (0))
								break;

							iBase += (int)(pBase->u.iAppend);
							pBase = &pParse->aNode[iBase];
							j = (uint)(1);
						}

						j = (uint)(2);
						if (((zPath[2]) == (45)) && ((sqlite3CtypeMap[(byte)(zPath[3])] & 0x04) != 0))
						{
							uint x = (uint)(0);
							j = (uint)(3);
							do
							{
								x = (uint)(x * 10 + zPath[j] - 48);
								j++;
							}
							while ((sqlite3CtypeMap[(byte)(zPath[j])] & 0x04) != 0);
							if ((x) > (i))
								return null;
							i -= (uint)(x);
						}

						if (zPath[j] != 93)
						{
							*pzErr = zPath;
							return null;
						}
					}
					else
					{
						*pzErr = zPath;
						return null;
					}
				}

				if (pRoot->eType != 6)
					return null;
				zPath += j + 1;
				j = (uint)(1);
				for (; ; )
				{
					while (((j) <= (pRoot->n)) && (((i) > (0)) || ((pRoot[j].jnFlags & 0x04) != 0)))
					{
						if ((pRoot[j].jnFlags & 0x04) == (0))
							i--;
						j += (uint)(jsonNodeSize(&pRoot[j]));
					}

					if ((pRoot->jnFlags & 0x20) == (0))
						break;

					iRoot += (uint)(pRoot->u.iAppend);
					pRoot = &pParse->aNode[iRoot];
					j = (uint)(1);
				}

				if ((j) <= (pRoot->n))
				{
					return jsonLookupStep(pParse, (uint)(iRoot + j), zPath, pApnd, pzErr);
				}

				if (((i) == (0)) && ((pApnd) != null))
				{
					uint iStart = 0;
					JsonNode* pNode;
					iStart = (uint)(jsonParseAddNode(pParse, (uint)(6), (uint)(1), null));
					pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
					if ((pParse->oom) != 0)
						return null;
					if ((pNode) != null)
					{
						pRoot = &pParse->aNode[iRoot];

						pRoot->u.iAppend = (uint)(iStart - iRoot);
						pRoot->jnFlags |= (byte)(0x20);
					}

					return pNode;
				}
			}
			else
			{
				*pzErr = zPath;
			}

			return null;
		}
		public static JsonNode* jsonMergePatch(JsonParse* pParse, uint iTarget, JsonNode* pPatch)
		{
			uint i = 0; uint j = 0;
			uint iRoot = 0;
			JsonNode* pTarget;
			if (pPatch->eType != 7)
			{
				return pPatch;
			}


			pTarget = &pParse->aNode[iTarget];

			if (pTarget->eType != 7)
			{
				jsonRemoveAllNulls(pPatch);
				return pPatch;
			}

			iRoot = (uint)(iTarget);
			for (i = (uint)(1); (i) < (pPatch->n); i += (uint)(jsonNodeSize(&pPatch[i + 1]) + 1))
			{
				uint nKey = 0;
				sbyte* zKey;



				nKey = (uint)(pPatch[i].n);
				zKey = pPatch[i].u.zJContent;

				for (j = (uint)(1); (j) < (pTarget->n); j += (uint)(jsonNodeSize(&pTarget[j + 1]) + 1))
				{



					if (((pTarget[j].n) == (nKey)) && ((CRuntime.strncmp(pTarget[j].u.zJContent, zKey, (ulong)(nKey))) == (0)))
					{
						if ((pTarget[j + 1].jnFlags & (0x04 | 0x10)) != 0)
							break;
						if ((pPatch[i + 1].eType) == (0))
						{
							pTarget[j + 1].jnFlags |= (byte)(0x04);
						}
						else
						{
							JsonNode* pNew = jsonMergePatch(pParse, (uint)(iTarget + j + 1), &pPatch[i + 1]);
							if ((pNew) == (null))
								return null;
							pTarget = &pParse->aNode[iTarget];
							if (pNew != &pTarget[j + 1])
							{

								pTarget[j + 1].u.pPatch = pNew;
								pTarget[j + 1].jnFlags |= (byte)(0x10);
							}
						}

						break;
					}
				}

				if (((j) >= (pTarget->n)) && (pPatch[i + 1].eType != 0))
				{
					int iStart = 0;
					int iPatch = 0;
					iStart = (int)(jsonParseAddNode(pParse, (uint)(7), (uint)(2), null));
					jsonParseAddNode(pParse, (uint)(5), (uint)(nKey), zKey);
					iPatch = (int)(jsonParseAddNode(pParse, (uint)(1), (uint)(0), null));
					if ((pParse->oom) != 0)
						return null;
					jsonRemoveAllNulls(pPatch);
					pTarget = &pParse->aNode[iTarget];

					pParse->aNode[iRoot].jnFlags |= (byte)(0x20);
					pParse->aNode[iRoot].u.iAppend = (uint)(iStart - iRoot);
					iRoot = (uint)(iStart);

					pParse->aNode[iPatch].jnFlags |= (byte)(0x10);
					pParse->aNode[iPatch].u.pPatch = &pPatch[i + 1];
				}
			}

			return pTarget;
		}
		public static uint jsonNodeSize(JsonNode* pNode)
		{
			return (uint)((pNode->eType) >= (6) ? pNode->n + 1 : 1);
		}
		public static void jsonObjectCompute(sqlite3_context ctx, int isFinal)
		{
			JsonString pStr;
			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(0)));
			if ((pStr) != null)
			{
				jsonAppendChar(pStr, (sbyte)(125));
				if ((pStr.bErr) != 0)
				{
					if ((pStr.bErr) == (1))
						sqlite3_result_error_nomem(ctx);

				}
				else if ((isFinal) != 0)
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), (pStr.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free);
					pStr.bStatic = (byte)(1);
				}
				else
				{
					sqlite3_result_text(ctx, pStr.zBuf, (int)(pStr.nUsed), ((Void(Void * ))(-1)));
					pStr.nUsed--;
				}
			}
			else
			{
				sqlite3_result_text(ctx, "{}", (int)(2), null);
			}

			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonObjectFinal(sqlite3_context ctx)
		{
			jsonObjectCompute(ctx, (int)(1));
		}
		public static void jsonObjectFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			int i = 0;
			JsonString jx = new JsonString();
			sbyte* z;
			uint n = 0;
			if ((argc & 1) != 0)
			{
				sqlite3_result_error(ctx, "json_object() requires an even number of arguments", (int)(-1));
				return;
			}

			jsonInit(jx, ctx);
			jsonAppendChar(jx, (sbyte)(123));
			for (i = (int)(0); (i) < (argc); i += (int)(2))
			{
				if (sqlite3_value_type(argv[i]) != 3)
				{
					sqlite3_result_error(ctx, "json_object() labels must be TEXT", (int)(-1));
					jsonReset(jx);
					return;
				}

				jsonAppendSeparator(jx);
				z = (sbyte*)(sqlite3_value_text(argv[i]));
				n = ((uint)(sqlite3_value_bytes(argv[i])));
				jsonAppendString(jx, z, (uint)(n));
				jsonAppendChar(jx, (sbyte)(58));
				jsonAppendValue(jx, argv[i + 1]);
			}

			jsonAppendChar(jx, (sbyte)(125));
			jsonResult(jx);
			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonObjectStep(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonString pStr;
			sbyte* z;
			uint n = 0;

			pStr = (JsonString)(sqlite3_aggregate_context(ctx, (int)(sizeof(JsonString))));
			if ((pStr) != null)
			{
				if ((pStr.zBuf) == (null))
				{
					jsonInit(pStr, ctx);
					jsonAppendChar(pStr, (sbyte)(123));
				}
				else if ((pStr.nUsed) > (1))
				{
					jsonAppendChar(pStr, (sbyte)(44));
				}

				pStr.pCtx = ctx;
				z = (sbyte*)(sqlite3_value_text(argv[0]));
				n = ((uint)(sqlite3_value_bytes(argv[0])));
				jsonAppendString(pStr, z, (uint)(n));
				jsonAppendChar(pStr, (sbyte)(58));
				jsonAppendValue(pStr, argv[1]);
			}
		}
		public static void jsonObjectValue(sqlite3_context ctx)
		{
			jsonObjectCompute(ctx, (int)(0));
		}
		public static void jsonOom(JsonString p)
		{
			p.bErr = (byte)(1);
			sqlite3_result_error_nomem(p.pCtx);
			jsonReset(p);
		}
		public static int jsonParse(JsonParse* pParse, sqlite3_context pCtx, sbyte* zJson)
		{
			int i = 0;
			CRuntime.memset(pParse, (int)(0), (ulong)(sizeof(JsonParse)));
			if ((zJson) == (null))
				return (int)(1);
			pParse->zJson = zJson;
			i = (int)(jsonParseValue(pParse, (uint)(0)));
			if ((pParse->oom) != 0)
				i = (int)(-1);
			if ((i) > (0))
			{

				while ((jsonIsSpace[(byte)(zJson[i])]) != 0)
				{
					i++;
				}

				if ((zJson[i]) != 0)
					i = (int)(-1);
			}

			if ((i) <= (0))
			{
				if (pCtx != null)
				{
					if ((pParse->oom) != 0)
					{
						sqlite3_result_error_nomem(pCtx);
					}
					else
					{
						sqlite3_result_error(pCtx, "malformed JSON", (int)(-1));
					}
				}

				jsonParseReset(pParse);
				return (int)(1);
			}

			return (int)(0);
		}
		public static int jsonParseAddNode(JsonParse* pParse, uint eType, uint n, sbyte* zContent)
		{
			JsonNode* p;
			if (((pParse->aNode) == (null)) || ((pParse->nNode) >= (pParse->nAlloc)))
			{
				return (int)(jsonParseAddNodeExpand(pParse, (uint)(eType), (uint)(n), zContent));
			}

			p = &pParse->aNode[pParse->nNode];
			p->eType = ((byte)(eType));
			p->jnFlags = (byte)(0);
			p->n = (uint)(n);
			p->u.zJContent = zContent;
			return (int)(pParse->nNode++);
		}
		public static int jsonParseAddNodeExpand(JsonParse* pParse, uint eType, uint n, sbyte* zContent)
		{
			uint nNew = 0;
			JsonNode* pNew;

			if ((pParse->oom) != 0)
				return (int)(-1);
			nNew = (uint)(pParse->nAlloc * 2 + 10);
			pNew = sqlite3_realloc64(pParse->aNode, (ulong)(sizeof(JsonNode) * nNew));
			if ((pNew) == (null))
			{
				pParse->oom = (byte)(1);
				return (int)(-1);
			}

			pParse->nAlloc = (uint)(nNew);
			pParse->aNode = pNew;

			return (int)(jsonParseAddNode(pParse, (uint)(eType), (uint)(n), zContent));
		}
		public static JsonParse* jsonParseCached(sqlite3_context pCtx, sqlite3_value argv, sqlite3_context pErrCtx)
		{
			sbyte* zJson = (sbyte*)(sqlite3_value_text(argv[0]));
			int nJson = (int)(sqlite3_value_bytes(argv[0]));
			JsonParse* p;
			JsonParse* pMatch = null;
			int iKey = 0;
			int iMinKey = (int)(0);
			uint iMinHold = (uint)(0xffffffff);
			uint iMaxHold = (uint)(0);
			if ((zJson) == (null))
				return null;
			for (iKey = (int)(0); (iKey) < (4); iKey++)
			{
				p = (JsonParse*)(sqlite3_get_auxdata(pCtx, (int)((-429938) + iKey)));
				if ((p) == (null))
				{
					iMinKey = (int)(iKey);
					break;
				}

				if ((((pMatch) == (null)) && ((p->nJson) == (nJson))) && ((memcmp(p->zJson, zJson, (ulong)(nJson))) == (0)))
				{
					p->nErr = (byte)(0);
					pMatch = p;
				}
				else if ((p->iHold) < (iMinHold))
				{
					iMinHold = (uint)(p->iHold);
					iMinKey = (int)(iKey);
				}

				if ((p->iHold) > (iMaxHold))
				{
					iMaxHold = (uint)(p->iHold);
				}
			}

			if ((pMatch) != null)
			{
				pMatch->nErr = (byte)(0);
				pMatch->iHold = (uint)(iMaxHold + 1);
				return pMatch;
			}

			p = sqlite3_malloc64((ulong)(sizeof(JsonParse) + nJson + 1));
			if ((p) == (null))
			{
				sqlite3_result_error_nomem(pCtx);
				return null;
			}

			CRuntime.memset(p, (int)(0), (ulong)(sizeof(JsonParse)));
			p->zJson = (sbyte*)(&p[1]);
			CRuntime.memcpy(p->zJson, zJson, (ulong)(nJson + 1));
			if ((jsonParse(p, pErrCtx, p->zJson)) != 0)
			{
				sqlite3_free(p);
				return null;
			}

			p->nJson = (int)(nJson);
			p->iHold = (uint)(iMaxHold + 1);
			sqlite3_set_auxdata(pCtx, (int)((-429938) + iMinKey), p, (Void(Void * ))(jsonParseFree));
			return (JsonParse*)(sqlite3_get_auxdata(pCtx, (int)((-429938) + iMinKey)));
		}
		public static void jsonParseFillInParentage(JsonParse* pParse, uint i, uint iParent)
		{
			JsonNode* pNode = &pParse->aNode[i];
			uint j = 0;
			pParse->aUp[i] = (uint)(iParent);
			switch (pNode->eType)
			{
				case 6:
					{
						for (j = (uint)(1); (j) <= (pNode->n); j += (uint)(jsonNodeSize(pNode + j)))
						{
							jsonParseFillInParentage(pParse, (uint)(i + j), (uint)(i));
						}

						break;
					}

				case 7:
					{
						for (j = (uint)(1); (j) <= (pNode->n); j += (uint)(jsonNodeSize(pNode + j + 1) + 1))
						{
							pParse->aUp[i + j] = (uint)(i);
							jsonParseFillInParentage(pParse, (uint)(i + j + 1), (uint)(i));
						}

						break;
					}

				default:
					{
						break;
					}
			}
		}
		public static int jsonParseFindParents(JsonParse* pParse)
		{
			uint* aUp;

			aUp = pParse->aUp = sqlite3_malloc64((ulong)(sizeof(uint) * pParse->nNode));
			if ((aUp) == (null))
			{
				pParse->oom = (byte)(1);
				return (int)(7);
			}

			jsonParseFillInParentage(pParse, (uint)(0), (uint)(0));
			return (int)(0);
		}
		public static void jsonParseFree(JsonParse* pParse)
		{
			jsonParseReset(pParse);
			sqlite3_free(pParse);
		}
		public static void jsonParseReset(JsonParse* pParse)
		{
			sqlite3_free(pParse->aNode);
			pParse->aNode = null;
			pParse->nNode = (uint)(0);
			pParse->nAlloc = (uint)(0);
			sqlite3_free(pParse->aUp);
			pParse->aUp = null;
		}
		public static int jsonParseValue(JsonParse* pParse, uint i)
		{
			sbyte c = 0;
			uint j = 0;
			int iThis = 0;
			int x = 0;
			JsonNode* pNode;
			sbyte* z = pParse->zJson;
			while ((jsonIsSpace[(byte)(z[i])]) != 0)
			{
				i++;
			}

			if ((c = (sbyte)(z[i])) == (123))
			{
				iThis = (int)(jsonParseAddNode(pParse, (uint)(7), (uint)(0), null));
				if ((iThis) < (0))
					return (int)(-1);
				for (j = (uint)(i + 1); ; j++)
				{
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					if ((++pParse->iDepth) > (2000))
						return (int)(-1);
					x = (int)(jsonParseValue(pParse, (uint)(j)));
					if ((x) < (0))
					{
						pParse->iDepth--;
						if (((x) == (-2)) && ((pParse->nNode) == ((uint)(iThis) + 1)))
							return (int)(j + 1);
						return (int)(-1);
					}

					if ((pParse->oom) != 0)
						return (int)(-1);
					pNode = &pParse->aNode[pParse->nNode - 1];
					if (pNode->eType != 5)
						return (int)(-1);
					pNode->jnFlags |= (byte)(0x40);
					j = (uint)(x);
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					if (z[j] != 58)
						return (int)(-1);
					j++;
					x = (int)(jsonParseValue(pParse, (uint)(j)));
					pParse->iDepth--;
					if ((x) < (0))
						return (int)(-1);
					j = (uint)(x);
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					c = (sbyte)(z[j]);
					if ((c) == (44))
						continue;
					if (c != 125)
						return (int)(-1);
					break;
				}

				pParse->aNode[iThis].n = (uint)(pParse->nNode - (uint)(iThis) - 1);
				return (int)(j + 1);
			}
			else if ((c) == (91))
			{
				iThis = (int)(jsonParseAddNode(pParse, (uint)(6), (uint)(0), null));
				if ((iThis) < (0))
					return (int)(-1);
				CRuntime.memset(&pParse->aNode[iThis].u, (int)(0), (ulong)(sizeof(union JsonNode::(unnamed at sqlite3.c : 193285 : 3)) ) )
        ;
				for (j = (uint)(i + 1); ; j++)
				{
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					if ((++pParse->iDepth) > (2000))
						return (int)(-1);
					x = (int)(jsonParseValue(pParse, (uint)(j)));
					pParse->iDepth--;
					if ((x) < (0))
					{
						if (((x) == (-3)) && ((pParse->nNode) == ((uint)(iThis) + 1)))
							return (int)(j + 1);
						return (int)(-1);
					}

					j = (uint)(x);
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					c = (sbyte)(z[j]);
					if ((c) == (44))
						continue;
					if (c != 93)
						return (int)(-1);
					break;
				}

				pParse->aNode[iThis].n = (uint)(pParse->nNode - (uint)(iThis) - 1);
				return (int)(j + 1);
			}
			else if ((c) == (34))
			{
				byte jnFlags = (byte)(0);
				j = (uint)(i + 1);
				for (; ; )
				{
					c = (sbyte)(z[j]);
					if ((c & ~0x1f) == (0))
					{
						return (int)(-1);
					}

					if ((c) == (92))
					{
						c = (sbyte)(z[++j]);
						if ((((((((((c) == (34)) || ((c) == (92))) || ((c) == (47))) || ((c) == (98))) || ((c) == (102))) || ((c) == (110))) || ((c) == (114))) || ((c) == (116))) || (((c) == (117)) && ((jsonIs4Hex(z + j + 1)) != 0)))
						{
							jnFlags = (byte)(0x02);
						}
						else
						{
							return (int)(-1);
						}
					}
					else if ((c) == (34))
					{
						break;
					}

					j++;
				}

				jsonParseAddNode(pParse, (uint)(5), (uint)(j + 1 - i), &z[i]);
				if (pParse->oom == 0)
					pParse->aNode[pParse->nNode - 1].jnFlags = (byte)(jnFlags);
				return (int)(j + 1);
			}
			else if ((((c) == (110)) && ((CRuntime.strncmp(z + i, "null", (ulong)(4))) == (0))) && ((sqlite3CtypeMap[(byte)(z[i + 4])] & 0x06) == 0))
			{
				jsonParseAddNode(pParse, (uint)(0), (uint)(0), null);
				return (int)(i + 4);
			}
			else if ((((c) == (116)) && ((CRuntime.strncmp(z + i, "true", (ulong)(4))) == (0))) && ((sqlite3CtypeMap[(byte)(z[i + 4])] & 0x06) == 0))
			{
				jsonParseAddNode(pParse, (uint)(1), (uint)(0), null);
				return (int)(i + 4);
			}
			else if ((((c) == (102)) && ((CRuntime.strncmp(z + i, "false", (ulong)(5))) == (0))) && ((sqlite3CtypeMap[(byte)(z[i + 5])] & 0x06) == 0))
			{
				jsonParseAddNode(pParse, (uint)(2), (uint)(0), null);
				return (int)(i + 5);
			}
			else if (((c) == (45)) || (((c) >= (48)) && ((c) <= (57))))
			{
				byte seenDP = (byte)(0);
				byte seenE = (byte)(0);

				if ((c) <= (48))
				{
					j = (uint)((c) == (45) ? i + 1 : i);
					if ((((z[j]) == (48)) && ((z[j + 1]) >= (48))) && ((z[j + 1]) <= (57)))
						return (int)(-1);
				}

				j = (uint)(i + 1);
				for (; ; j++)
				{
					c = (sbyte)(z[j]);
					if (((c) >= (48)) && ((c) <= (57)))
						continue;
					if ((c) == (46))
					{
						if ((z[j - 1]) == (45))
							return (int)(-1);
						if ((seenDP) != 0)
							return (int)(-1);
						seenDP = (byte)(1);
						continue;
					}

					if (((c) == (101)) || ((c) == (69)))
					{
						if ((z[j - 1]) < (48))
							return (int)(-1);
						if ((seenE) != 0)
							return (int)(-1);
						seenDP = (byte)(seenE = (byte)(1));
						c = (sbyte)(z[j + 1]);
						if (((c) == (43)) || ((c) == (45)))
						{
							j++;
							c = (sbyte)(z[j + 1]);
						}

						if (((c) < (48)) || ((c) > (57)))
							return (int)(-1);
						continue;
					}

					break;
				}

				if ((z[j - 1]) < (48))
					return (int)(-1);
				jsonParseAddNode(pParse, (uint)((seenDP) != 0 ? 4 : 3), (uint)(j - i), &z[i]);
				return (int)(j);
			}
			else if ((c) == (125))
			{
				return (int)(-2);
			}
			else if ((c) == (93))
			{
				return (int)(-3);
			}
			else if ((c) == (0))
			{
				return (int)(0);
			}
			else
			{
				return (int)(-1);
			}
		}
		public static void jsonPatchFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonParse y = new JsonParse();
			JsonNode* pResult;

			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;
			if ((jsonParse(&y, ctx, (sbyte*)(sqlite3_value_text(argv[1])))) != 0)
			{
				jsonParseReset(&x);
				return;
			}

			pResult = jsonMergePatch(&x, (uint)(0), y.aNode);

			if ((pResult) != null)
			{
				jsonReturnJson(pResult, ctx, null);
			}
			else
			{
				sqlite3_result_error_nomem(ctx);
			}

			jsonParseReset(&x);
			jsonParseReset(&y);
		}
		public static sbyte* jsonPathSyntaxError(sbyte* zErr)
		{
			return sqlite3_mprintf("JSON path error near '%q'", zErr);
		}
		public static void jsonPrintf(int N, JsonString p, sbyte* zFormat)
		{
			sbyte* ap;
			if (((p.nUsed + N) >= (p.nAlloc)) && ((jsonGrow(p, (uint)(N))) != 0))
				return;
			(__va_start(&ap, zFormat));
			sqlite3_vsnprintf((int)(N), p.zBuf + p.nUsed, zFormat, ap);
			((void)(ap = null));
			p.nUsed += (ulong)((int)(CRuntime.strlen(p.zBuf + p.nUsed)));
		}
		public static void jsonQuoteFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonString jx = new JsonString();

			jsonInit(jx, ctx);
			jsonAppendValue(jx, argv[0]);
			jsonResult(jx);
			sqlite3_result_subtype(ctx, (uint)(74));
		}
		public static void jsonRemoveAllNulls(JsonNode* pNode)
		{
			int i = 0; int n = 0;

			n = (int)(pNode->n);
			for (i = (int)(2); (i) <= (n); i += (int)(jsonNodeSize(&pNode[i]) + 1))
			{
				switch (pNode[i].eType)
				{
					case 0:
						pNode[i].jnFlags |= (byte)(0x04);
						break;
					case 7:
						jsonRemoveAllNulls(&pNode[i]);
						break;
				}
			}
		}
		public static void jsonRemoveFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonNode* pNode;
			sbyte* zPath;
			uint i = 0;
			if ((argc) < (1))
				return;
			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;

			for (i = (uint)(1); (i) < ((uint)(argc)); i++)
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[i]));
				if ((zPath) == (null))
					goto remove_done;
				pNode = jsonLookup(&x, zPath, null, ctx);
				if ((x.nErr) != 0)
					goto remove_done;
				if ((pNode) != null)
					pNode->jnFlags |= (byte)(0x04);
			}

			if ((x.aNode[0].jnFlags & 0x04) == (0))
			{
				jsonReturnJson(x.aNode, ctx, null);
			}

		remove_done:
			; jsonParseReset(&x);
		}
		public static void jsonRenderNode(JsonNode* pNode, JsonString pOut, sqlite3_value aReplace)
		{

			if ((pNode->jnFlags & (0x08 | 0x10)) != 0)
			{
				if (((pNode->jnFlags & 0x08) != 0) && (aReplace != null))
				{

					jsonAppendValue(pOut, aReplace[pNode->u.iReplace]);
					return;
				}


				pNode = pNode->u.pPatch;
			}

			switch (pNode->eType)
			{
				default:
					{

						jsonAppendRaw(pOut, "null", (uint)(4));
						break;
					}

				case 1:
					{
						jsonAppendRaw(pOut, "true", (uint)(4));
						break;
					}

				case 2:
					{
						jsonAppendRaw(pOut, "false", (uint)(5));
						break;
					}

				case 5:
					{
						if ((pNode->jnFlags & 0x01) != 0)
						{

							jsonAppendString(pOut, pNode->u.zJContent, (uint)(pNode->n));
							break;
						}
					}

				case 4:
				case 3:
					{

						jsonAppendRaw(pOut, pNode->u.zJContent, (uint)(pNode->n));
						break;
					}

				case 6:
					{
						uint j = (uint)(1);
						jsonAppendChar(pOut, (sbyte)(91));
						for (; ; )
						{
							while ((j) <= (pNode->n))
							{
								if ((pNode[j].jnFlags & 0x04) == (0))
								{
									jsonAppendSeparator(pOut);
									jsonRenderNode(&pNode[j], pOut, aReplace);
								}

								j += (uint)(jsonNodeSize(&pNode[j]));
							}

							if ((pNode->jnFlags & 0x20) == (0))
								break;

							pNode = &pNode[pNode->u.iAppend];
							j = (uint)(1);
						}

						jsonAppendChar(pOut, (sbyte)(93));
						break;
					}

				case 7:
					{
						uint j = (uint)(1);
						jsonAppendChar(pOut, (sbyte)(123));
						for (; ; )
						{
							while ((j) <= (pNode->n))
							{
								if ((pNode[j + 1].jnFlags & 0x04) == (0))
								{
									jsonAppendSeparator(pOut);
									jsonRenderNode(&pNode[j], pOut, aReplace);
									jsonAppendChar(pOut, (sbyte)(58));
									jsonRenderNode(&pNode[j + 1], pOut, aReplace);
								}

								j += (uint)(1 + jsonNodeSize(&pNode[j + 1]));
							}

							if ((pNode->jnFlags & 0x20) == (0))
								break;

							pNode = &pNode[pNode->u.iAppend];
							j = (uint)(1);
						}

						jsonAppendChar(pOut, (sbyte)(125));
						break;
					}
			}
		}
		public static void jsonReplaceFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonNode* pNode;
			sbyte* zPath;
			uint i = 0;
			if ((argc) < (1))
				return;
			if ((argc & 1) == (0))
			{
				jsonWrongNumArgs(ctx, "replace");
				return;
			}

			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;

			for (i = (uint)(1); (i) < ((uint)(argc)); i += (uint)(2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[i]));
				pNode = jsonLookup(&x, zPath, null, ctx);
				if ((x.nErr) != 0)
					goto replace_err;
				if ((pNode) != null)
				{

					pNode->jnFlags |= ((byte)(0x08));
					pNode->u.iReplace = (uint)(i + 1);
				}
			}

			if ((x.aNode[0].jnFlags & 0x08) != 0)
			{

				sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);
			}
			else
			{
				jsonReturnJson(x.aNode, ctx, argv);
			}

		replace_err:
			; jsonParseReset(&x);
		}
		public static void jsonReset(JsonString p)
		{
			if (p.bStatic == 0)
				sqlite3_free(p.zBuf);
			jsonZero(p);
		}
		public static void jsonResult(JsonString p)
		{
			if ((p.bErr) == (0))
			{
				sqlite3_result_text64(p.pCtx, p.zBuf, (ulong)(p.nUsed), (p.bStatic) != 0 ? ((Void(Void * ))(-1)) : sqlite3_free, (byte)(1));
				jsonZero(p);
			}


		}
		public static void jsonReturn(JsonNode* pNode, sqlite3_context pCtx, sqlite3_value aReplace)
		{
			switch (pNode->eType)
			{
				default:
					{

						sqlite3_result_null(pCtx);
						break;
					}

				case 1:
					{
						sqlite3_result_int(pCtx, (int)(1));
						break;
					}

				case 2:
					{
						sqlite3_result_int(pCtx, (int)(0));
						break;
					}

				case 3:
					{
						long i = (long)(0);
						sbyte* z;

						z = pNode->u.zJContent;
						if ((z[0]) == (45))
						{
							z++;
						}

						while (((z[0]) >= (48)) && ((z[0]) <= (57)))
						{
							uint v = (uint)(*(z++) - 48);
							if ((i) >= ((0xffffffff | (((long)(0x7fffffff)) << 32)) / 10))
							{
								if ((i) > ((0xffffffff | (((long)(0x7fffffff)) << 32)) / 10))
									goto int_as_real;
								if (((z[0]) >= (48)) && ((z[0]) <= (57)))
									goto int_as_real;
								if ((v) == (9))
									goto int_as_real;
								if ((v) == (8))
								{
									if ((pNode->u.zJContent[0]) == (45))
									{
										sqlite3_result_int64(pCtx, (long)(((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))));
										goto int_done;
									}
									else
									{
										goto int_as_real;
									}
								}
							}

							i = (long)(i * 10 + v);
						}

						if ((pNode->u.zJContent[0]) == (45))
						{
							i = (long)(-i);
						}

						sqlite3_result_int64(pCtx, (long)(i));
					int_done:
						;
						break;
					int_as_real:
						;
					}

				case 4:
					{
						double r = 0;
						sbyte* z;

						z = pNode->u.zJContent;
						sqlite3AtoF(z, &r, (int)(sqlite3Strlen30(z)), (byte)(1));
						sqlite3_result_double(pCtx, (double)(r));
						break;
					}

				case 5:
					{

						if ((pNode->jnFlags & 0x02) == (0))
						{

							sqlite3_result_text(pCtx, pNode->u.zJContent + 1, (int)(pNode->n - 2), ((Void(Void * ))(-1)));
						}
						else
						{
							uint i = 0;
							uint n = (uint)(pNode->n);
							sbyte* z;
							sbyte* zOut;
							uint j = 0;

							z = pNode->u.zJContent;
							zOut = sqlite3_malloc((int)(n + 1));
							if ((zOut) == (null))
							{
								sqlite3_result_error_nomem(pCtx);
								break;
							}

							for (i = (uint)(1), j = (uint)(0); (i) < (n - 1); i++)
							{
								sbyte c = (sbyte)(z[i]);
								if (c != 92)
								{
									zOut[j++] = (sbyte)(c);
								}
								else
								{
									c = (sbyte)(z[++i]);
									if ((c) == (117))
									{
										uint v = (uint)(jsonHexToInt4(z + i + 1));
										i += (uint)(4);
										if ((v) == (0))
											break;
										if ((v) <= (0x7f))
										{
											zOut[j++] = ((sbyte)(v));
										}
										else if ((v) <= (0x7ff))
										{
											zOut[j++] = ((sbyte)(0xc0 | (v >> 6)));
											zOut[j++] = (sbyte)(0x80 | (v & 0x3f));
										}
										else
										{
											uint vlo = 0;
											if ((((((v & 0xfc00) == (0xd800)) && ((i) < (n - 6))) && ((z[i + 1]) == (92))) && ((z[i + 2]) == (117))) && (((vlo = (uint)(jsonHexToInt4(z + i + 3))) & 0xfc00) == (0xdc00)))
											{
												v = (uint)(((v & 0x3ff) << 10) + (vlo & 0x3ff) + 0x10000);
												i += (uint)(6);
												zOut[j++] = (sbyte)(0xf0 | (v >> 18));
												zOut[j++] = (sbyte)(0x80 | ((v >> 12) & 0x3f));
												zOut[j++] = (sbyte)(0x80 | ((v >> 6) & 0x3f));
												zOut[j++] = (sbyte)(0x80 | (v & 0x3f));
											}
											else
											{
												zOut[j++] = (sbyte)(0xe0 | (v >> 12));
												zOut[j++] = (sbyte)(0x80 | ((v >> 6) & 0x3f));
												zOut[j++] = (sbyte)(0x80 | (v & 0x3f));
											}
										}
									}
									else
									{
										if ((c) == (98))
										{
											c = (sbyte)(8);
										}
										else if ((c) == (102))
										{
											c = (sbyte)(12);
										}
										else if ((c) == (110))
										{
											c = (sbyte)(10);
										}
										else if ((c) == (114))
										{
											c = (sbyte)(13);
										}
										else if ((c) == (116))
										{
											c = (sbyte)(9);
										}

										zOut[j++] = (sbyte)(c);
									}
								}
							}

							zOut[j] = (sbyte)(0);
							sqlite3_result_text(pCtx, zOut, (int)(j), sqlite3_free);
						}

						break;
					}

				case 6:
				case 7:
					{
						jsonReturnJson(pNode, pCtx, aReplace);
						break;
					}
			}
		}
		public static void jsonReturnJson(JsonNode* pNode, sqlite3_context pCtx, sqlite3_value aReplace)
		{
			JsonString s = new JsonString();
			jsonInit(s, pCtx);
			jsonRenderNode(pNode, s, aReplace);
			jsonResult(s);
			sqlite3_result_subtype(pCtx, (uint)(74));
		}
		public static void jsonSetFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse x = new JsonParse();
			JsonNode* pNode;
			sbyte* zPath;
			uint i = 0;
			int bApnd = 0;
			int bIsSet = (int)(sqlite3_user_data(ctx) != null);
			if ((argc) < (1))
				return;
			if ((argc & 1) == (0))
			{
				jsonWrongNumArgs(ctx, (bIsSet) != 0 ? "set" : "insert");
				return;
			}

			if ((jsonParse(&x, ctx, (sbyte*)(sqlite3_value_text(argv[0])))) != 0)
				return;

			for (i = (uint)(1); (i) < ((uint)(argc)); i += (uint)(2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[i]));
				bApnd = (int)(0);
				pNode = jsonLookup(&x, zPath, &bApnd, ctx);
				if ((x.oom) != 0)
				{
					sqlite3_result_error_nomem(ctx);
					goto jsonSetDone;
				}
				else if ((x.nErr) != 0)
				{
					goto jsonSetDone;
				}
				else if (((pNode) != null) && (((bApnd) != 0) || ((bIsSet) != 0)))
				{

					pNode->jnFlags |= ((byte)(0x08));
					pNode->u.iReplace = (uint)(i + 1);
				}
			}

			if ((x.aNode[0].jnFlags & 0x08) != 0)
			{

				sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);
			}
			else
			{
				jsonReturnJson(x.aNode, ctx, argv);
			}

		jsonSetDone:
			; jsonParseReset(&x);
		}
		public static void jsonTypeFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;
			sbyte* zPath;
			JsonNode* pNode;
			p = jsonParseCached(ctx, argv, ctx);
			if ((p) == (null))
				return;
			if ((argc) == (2))
			{
				zPath = (sbyte*)(sqlite3_value_text(argv[1]));
				pNode = jsonLookup(p, zPath, null, ctx);
			}
			else
			{
				pNode = p->aNode;
			}

			if ((pNode) != null)
			{
				sqlite3_result_text(ctx, jsonType[pNode->eType], (int)(-1), null);
			}
		}
		public static void jsonValidFunc(sqlite3_context ctx, int argc, sqlite3_value argv)
		{
			JsonParse* p;

			p = jsonParseCached(ctx, argv, null);
			sqlite3_result_int(ctx, (int)(p != null));
		}
		public static void jsonWrongNumArgs(sqlite3_context pCtx, sbyte* zFuncName)
		{
			sbyte* zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments", zFuncName);
			sqlite3_result_error(pCtx, zMsg, (int)(-1));
			sqlite3_free(zMsg);
		}
		public static void jsonZero(JsonString p)
		{
			p.zBuf = p.zSpace;
			p.nAlloc = (ulong)(100 * sizeof(sbyte));
			p.nUsed = (ulong)(0);
			p.bStatic = (byte)(1);
		}
		public static void juliandayFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				computeJD(&x);
				sqlite3_result_double(context, (double)(x.iJD / 86400000.0));
			}
		}
		public static int keywordCode(sbyte* z, int n, int* pType)
		{
			int i = 0; int j = 0;
			sbyte* zKW;
			if ((n) >= (2))
			{
				i = (int)(((sqlite3UpperToLower[(byte)(z[0])] * 4) ^ (sqlite3UpperToLower[(byte)(z[n - 1])] * 3) ^ n * 1) % 127);
				for (i = (int)(((int)(aKWHash[i])) - 1); (i) >= (0); i = (int)(((int)(aKWNext[i])) - 1))
				{
					if (aKWLen[i] != n)
						continue;
					zKW = &zKWText[aKWOffset[i]];
					if ((z[0] & ~0x20) != zKW[0])
						continue;
					if ((z[1] & ~0x20) != zKW[1])
						continue;
					j = (int)(2);
					while (((j) < (n)) && ((z[j] & ~0x20) == (zKW[j])))
					{
						j++;
					}

					if ((j) < (n))
						continue;
					*pType = (int)(aKWCode[i]);
					break;
				}
			}

			return (int)(n);
		}
		public static void last_insert_rowid(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			(void)(NotUsed) ,  (void)(NotUsed2);
			sqlite3_result_int64(context, (long)(sqlite3_last_insert_rowid(db)));
		}
		public static void last_valueFinalizeFunc(sqlite3_context pCtx)
		{
			LastValueCtx p;
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
			if (((p) != null) && ((p.pVal) != null))
			{
				sqlite3_result_value(pCtx, p.pVal);
				sqlite3_value_free(p.pVal);
				p.pVal = null;
			}
		}
		public static void last_valueInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			LastValueCtx p;
			(void)(nArg);
			(void)(apArg);
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
			if ((p) != null)
			{
				p.nVal--;
				if ((p.nVal) == (0))
				{
					sqlite3_value_free(p.pVal);
					p.pVal = null;
				}
			}
		}
		public static void last_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			LastValueCtx p;
			(void)(nArg);
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(LastValueCtx))));
			if ((p) != null)
			{
				sqlite3_value_free(p.pVal);
				p.pVal = sqlite3_value_dup(apArg[0]);
				if ((p.pVal) == (null))
				{
					sqlite3_result_error_nomem(pCtx);
				}
				else
				{
					p.nVal++;
				}
			}
		}
		public static void last_valueValueFunc(sqlite3_context pCtx)
		{
			LastValueCtx p;
			p = (LastValueCtx)(sqlite3_aggregate_context(pCtx, (int)(0)));
			if (((p) != null) && ((p.pVal) != null))
			{
				sqlite3_result_value(pCtx, p.pVal);
			}
		}
		public static void lengthFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{


			switch (sqlite3_value_type(argv[0]))
			{
				case 4:
				case 1:
				case 2:
					{
						sqlite3_result_int(context, (int)(sqlite3_value_bytes(argv[0])));
						break;
					}

				case 3:
					{
						byte* z = sqlite3_value_text(argv[0]);
						byte* z0;
						byte c = 0;
						if ((z) == (null))
							return;
						z0 = z;
						while ((c = (byte)(*z)) != 0)
						{
							z++;
							if ((c) >= (0xc0))
							{
								while ((*z & 0xc0) == (0x80))
								{
									z++;
									z0++;
								}
							}
						}

						sqlite3_result_int(context, (int)(z - z0));
						break;
					}

				default:
					{
						sqlite3_result_null(context);
						break;
					}
			}
		}
		public static void likeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zA; byte* zB;
			uint escape = 0;
			int nPat = 0;
			sqlite3 db = sqlite3_context_db_handle(context);
			compareInfo* pInfo = sqlite3_user_data(context);
			compareInfo backupInfo = new compareInfo();
			nPat = (int)(sqlite3_value_bytes(argv[0]));
			if ((nPat) > (db.aLimit[8]))
			{
				sqlite3_result_error(context, "LIKE or GLOB pattern too complex", (int)(-1));
				return;
			}

			if ((argc) == (3))
			{
				byte* zEsc = sqlite3_value_text(argv[2]);
				if ((zEsc) == (null))
					return;
				if (sqlite3Utf8CharLen((sbyte*)(zEsc), (int)(-1)) != 1)
				{
					sqlite3_result_error(context, "ESCAPE expression must be a single character", (int)(-1));
					return;
				}

				escape = (uint)(sqlite3Utf8Read(&zEsc));
				if (((escape) == (pInfo->matchAll)) || ((escape) == (pInfo->matchOne)))
				{
					CRuntime.memcpy(&backupInfo, pInfo, (ulong)(sizeof(compareInfo)));
					pInfo = &backupInfo;
					if ((escape) == (pInfo->matchAll))
						pInfo->matchAll = (byte)(0);
					if ((escape) == (pInfo->matchOne))
						pInfo->matchOne = (byte)(0);
				}
			}
			else
			{
				escape = (uint)(pInfo->matchSet);
			}

			zB = sqlite3_value_text(argv[0]);
			zA = sqlite3_value_text(argv[1]);
			if (((zA) != null) && ((zB) != null))
			{
				sqlite3_result_int(context, ((patternCompare(zB, zA, pInfo, (uint)(escape))) == (0) ? 1 : 0));
			}
		}
		public static void loadAnalysis(Parse pParse, int iDb)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			if ((v) != null)
			{
				sqlite3VdbeAddOp1(v, (int)(149), (int)(iDb));
			}
		}
		public static void loadExt(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* zFile = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zProc;
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zErrMsg = null;
			if ((db.flags & 0x00020000) == (0))
			{
				sqlite3_result_error(context, "not authorized", (int)(-1));
				return;
			}

			if ((argc) == (2))
			{
				zProc = (sbyte*)(sqlite3_value_text(argv[1]));
			}
			else
			{
				zProc = null;
			}

			if (((zFile) != null) && ((sqlite3_load_extension(db, zFile, zProc, &zErrMsg)) != 0))
			{
				sqlite3_result_error(context, zErrMsg, (int)(-1));
				sqlite3_free(zErrMsg);
			}
		}
		public static int lockBtree(BtShared pBt)
		{
			int rc = 0;
			MemPage pPage1;
			uint nPage = 0;
			uint nPageFile = (uint)(0);


			rc = (int)(sqlite3PagerSharedLock(pBt.pPager));
			if (rc != 0)
				return (int)(rc);
			rc = (int)(btreeGetPage(pBt, (uint)(1), pPage1, (int)(0)));
			if (rc != 0)
				return (int)(rc);
			nPage = (uint)(sqlite3Get4byte(28 + pPage1.aData));
			sqlite3PagerPagecount(pBt.pPager, (int*)(&nPageFile));
			if (((nPage) == (0)) || (memcmp(24 + pPage1.aData, 92 + pPage1.aData, (ulong)(4)) != 0))
			{
				nPage = (uint)(nPageFile);
			}

			if ((pBt.db.flags & 0x02000000) != 0)
			{
				nPage = (uint)(0);
			}

			if ((nPage) > (0))
			{
				uint pageSize = 0;
				uint usableSize = 0;
				byte* page1 = pPage1.aData;
				rc = (int)(26);
				if (memcmp(page1, zMagicHeader, (ulong)(16)) != 0)
				{
					goto page1_init_failed;
				}

				if ((page1[18]) > (2))
				{
					pBt.btsFlags |= (ushort)(0x0001);
				}

				if ((page1[19]) > (2))
				{
					goto page1_init_failed;
				}

				if (((page1[19]) == (2)) && ((pBt.btsFlags & 0x0020) == (0)))
				{
					int isOpen = (int)(0);
					rc = (int)(sqlite3PagerOpenWal(pBt.pPager, &isOpen));
					if (rc != 0)
					{
						goto page1_init_failed;
					}
					else
					{
						if ((isOpen) == (0))
						{
							releasePageOne(pPage1);
							return (int)(0);
						}
					}

					rc = (int)(26);
				}
				else
				{
				}

				if (memcmp(&page1[21], "@  ", (ulong)(3)) != 0)
				{
					goto page1_init_failed;
				}

				pageSize = (uint)((page1[16] << 8) | (page1[17] << 16));
				if (((((pageSize - 1) & pageSize) != 0) || ((pageSize) > (65536))) || ((pageSize) <= (256)))
				{
					goto page1_init_failed;
				}

				pBt.btsFlags |= (ushort)(0x0002);

				usableSize = (uint)(pageSize - page1[20]);
				if (pageSize != pBt.pageSize)
				{
					releasePageOne(pPage1);
					pBt.usableSize = (uint)(usableSize);
					pBt.pageSize = (uint)(pageSize);
					freeTempSpace(pBt);
					rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, (int)(pageSize - usableSize)));
					return (int)(rc);
				}

				if ((nPage) > (nPageFile))
				{
					if ((sqlite3WritableSchema(pBt.db)) == (0))
					{
						rc = (int)(sqlite3CorruptError((int)(69395)));
						goto page1_init_failed;
					}
					else
					{
						nPage = (uint)(nPageFile);
					}
				}

				if ((usableSize) < (480))
				{
					goto page1_init_failed;
				}

				pBt.pageSize = (uint)(pageSize);
				pBt.usableSize = (uint)(usableSize);
				pBt.autoVacuum = (byte)((sqlite3Get4byte(&page1[36 + 4 * 4])) != 0 ? 1 : 0);
				pBt.incrVacuum = (byte)((sqlite3Get4byte(&page1[36 + 7 * 4])) != 0 ? 1 : 0);
			}

			pBt.maxLocal = ((ushort)((pBt.usableSize - 12) * 64 / 255 - 23));
			pBt.minLocal = ((ushort)((pBt.usableSize - 12) * 32 / 255 - 23));
			pBt.maxLeaf = ((ushort)(pBt.usableSize - 35));
			pBt.minLeaf = ((ushort)((pBt.usableSize - 12) * 32 / 255 - 23));
			if ((pBt.maxLocal) > (127))
			{
				pBt.max1bytePayload = (byte)(127);
			}
			else
			{
				pBt.max1bytePayload = ((byte)(pBt.maxLocal));
			}


			pBt.pPage1 = pPage1;
			pBt.nPage = (uint)(nPage);
			return (int)(0);
		page1_init_failed:
			; releasePageOne(pPage1);
			pBt.pPage1 = null;
			return (int)(rc);
		}
		public static void lockBtreeMutex(Btree p)
		{



			sqlite3_mutex_enter(p.pBt.mutex);
			p.pBt.db = p.db;
			p.locked = (byte)(1);
		}
		public static void lockTable(Parse pParse, int iDb, uint iTab, byte isWriteLock, sbyte* zName)
		{
			Parse pToplevel;
			int i = 0;
			int nBytes = 0;
			TableLock* p;

			pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			for (i = (int)(0); (i) < (pToplevel.nTableLock); i++)
			{
				p = &pToplevel.aTableLock[i];
				if (((p->iDb) == (iDb)) && ((p->iTab) == (iTab)))
				{
					p->isWriteLock = (byte)(((p->isWriteLock) != 0) || ((isWriteLock) != 0));
					return;
				}
			}

			nBytes = (int)(sizeof(TableLock) * (pToplevel.nTableLock + 1));
			pToplevel.aTableLock = sqlite3DbReallocOrFree(pToplevel.db, pToplevel.aTableLock, (ulong)(nBytes));
			if ((pToplevel.aTableLock) != null)
			{
				p = &pToplevel.aTableLock[pToplevel.nTableLock++];
				p->iDb = (int)(iDb);
				p->iTab = (uint)(iTab);
				p->isWriteLock = (byte)(isWriteLock);
				p->zLockName = zName;
			}
			else
			{
				pToplevel.nTableLock = (int)(0);
				sqlite3OomFault(pToplevel.db);
			}
		}
		public static void logBadConnection(sbyte* zType)
		{
			sqlite3_log((int)(21), "API call with %s database connection pointer", zType);
		}
		public static int lookasideMallocSize(sqlite3 db, void* p)
		{
			return (int)((p) < (db.lookaside.pMiddle) ? db.lookaside.szTrue : 128);
		}
		public static int lookupName(Parse pParse, sbyte* zDb, sbyte* zTab, sbyte* zCol, NameContext pNC, Expr pExpr)
		{
			int i = 0; int j = 0;
			int cnt = (int)(0);
			int cntTab = (int)(0);
			int nSubquery = (int)(0);
			sqlite3 db = pParse.db;
			SrcItem pItem;
			SrcItem pMatch = null;
			NameContext pTopNC = pNC;
			Schema pSchema = null;
			int eNewExprOp = (int)(167);
			Table pTab = null;
			Column* pCol;



			pExpr.iTable = (int)(-1);
			if ((zDb) != null)
			{
				if ((pNC.ncFlags & (0x000002 | 0x000004)) != 0)
				{
					zDb = null;
				}
				else
				{
					for (i = (int)(0); (i) < (db.nDb); i++)
					{

						if ((sqlite3StrICmp(db.aDb[i].zDbSName, zDb)) == (0))
						{
							pSchema = db.aDb[i].pSchema;
							break;
						}
					}

					if (((i) == (db.nDb)) && ((sqlite3StrICmp("main", zDb)) == (0)))
					{
						pSchema = db.aDb[0].pSchema;
						zDb = db.aDb[0].zDbSName;
					}
				}
			}


			do
			{
				ExprList pEList;
				SrcList pSrcList = pNC.pSrcList;
				if ((pSrcList) != null)
				{
					for (i = (int)(0), pItem = pSrcList.a; (i) < (pSrcList.nSrc); i++, pItem++)
					{
						byte hCol = 0;
						pTab = pItem.pTab;


						if (((pItem.pSelect) != null) && ((pItem.pSelect.selFlags & 0x0000800) != 0))
						{
							int hit = (int)(0);
							pEList = pItem.pSelect.pEList;
							for (j = (int)(0); (j) < (pEList.nExpr); j++)
							{
								if ((sqlite3MatchEName(&pEList.a[j], zCol, zTab, zDb)) != 0)
								{
									cnt++;
									cntTab = (int)(2);
									pMatch = pItem;
									pExpr.iColumn = (short)(j);
									hit = (int)(1);
								}
							}

							if (((hit) != 0) || ((zTab) == (null)))
								continue;
						}

						if ((zDb) != null)
						{
							if (pTab.pSchema != pSchema)
								continue;
							if (((pSchema) == (null)) && (CRuntime.strcmp(zDb, "*") != 0))
								continue;
						}

						if ((zTab) != null)
						{
							sbyte* zTabName = (pItem.zAlias) != 0 ? pItem.zAlias : pTab.zName;

							if (sqlite3StrICmp(zTabName, zTab) != 0)
							{
								continue;
							}


							if (((pParse.eParseMode) >= (2)) && ((pItem.zAlias) != null))
							{
								sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr.y.pTab));
							}
						}

						hCol = (byte)(sqlite3StrIHash(zCol));
						for (j = (int)(0), pCol = pTab.aCol; (j) < (pTab.nCol); j++, pCol++)
						{
							if (((pCol->hName) == (hCol)) && ((sqlite3StrICmp(pCol->zCnName, zCol)) == (0)))
							{
								if ((cnt) == (1))
								{
									if ((pItem.fg.jointype & 0x0004) != 0)
										continue;
									if ((nameInUsingClause(pItem.pUsing, zCol)) != 0)
										continue;
								}

								cnt++;
								pMatch = pItem;
								pExpr.iColumn = (short)((j) == (pTab.iPKey) ? -1 : (short)(j));
								break;
							}
						}

						if (((0) == (cnt)) && (((pTab).tabFlags & 0x00000200) == (0)))
						{
							cntTab++;
							pMatch = pItem;
						}
					}

					if ((pMatch) != null)
					{
						pExpr.iTable = (int)(pMatch.iCursor);

						pExpr.y.pTab = pMatch.pTab;

						if ((pMatch.fg.jointype & 0x0008) != 0)
						{
							(pExpr).flags |= (uint)(0x100000);
						}

						pSchema = pExpr.y.pTab.pSchema;
					}
				}

				if (((cnt) == (0)) && ((zDb) == (null)))
				{
					pTab = null;
					if (pParse.pTriggerTab != null)
					{
						int op = (int)(pParse.eTriggerOp);

						if ((pParse.bReturning) != 0)
						{
							if (((pNC.ncFlags & 0x000400) != 0) && (((zTab) == (null)) || ((sqlite3StrICmp(zTab, pParse.pTriggerTab.zName)) == (0))))
							{
								pExpr.iTable = (int)(op != 128);
								pTab = pParse.pTriggerTab;
							}
						}
						else if (((op != 128) && ((zTab) != null)) && ((sqlite3StrICmp("new", zTab)) == (0)))
						{
							pExpr.iTable = (int)(1);
							pTab = pParse.pTriggerTab;
						}
						else if (((op != 127) && ((zTab) != null)) && ((sqlite3StrICmp("old", zTab)) == (0)))
						{
							pExpr.iTable = (int)(0);
							pTab = pParse.pTriggerTab;
						}
					}

					if (((pNC.ncFlags & 0x000200) != 0) && (zTab != null))
					{
						Upsert pUpsert = pNC.uNC.pUpsert;
						if (((pUpsert) != null) && ((sqlite3StrICmp("excluded", zTab)) == (0)))
						{
							pTab = pUpsert.pUpsertSrc.a[0].pTab;
							pExpr.iTable = (int)(2);
						}
					}

					if ((pTab) != null)
					{
						int iCol = 0;
						byte hCol = (byte)(sqlite3StrIHash(zCol));
						pSchema = pTab.pSchema;
						cntTab++;
						for (iCol = (int)(0), pCol = pTab.aCol; (iCol) < (pTab.nCol); iCol++, pCol++)
						{
							if (((pCol->hName) == (hCol)) && ((sqlite3StrICmp(pCol->zCnName, zCol)) == (0)))
							{
								if ((iCol) == (pTab.iPKey))
								{
									iCol = (int)(-1);
								}

								break;
							}
						}

						if ((((iCol) >= (pTab.nCol)) && ((sqlite3IsRowid(zCol)) != 0)) && (((pTab).tabFlags & 0x00000200) == (0)))
						{
							iCol = (int)(-1);
						}

						if ((iCol) < (pTab.nCol))
						{
							cnt++;
							pMatch = null;
							if ((pExpr.iTable) == (2))
							{

								if (((pParse.eParseMode) >= (2)))
								{
									pExpr.iColumn = (short)(iCol);
									pExpr.y.pTab = pTab;
									eNewExprOp = (int)(167);
								}
								else
								{
									pExpr.iTable = (int)(pNC.uNC.pUpsert.regData + sqlite3TableColumnToStorage(pTab, (short)(iCol)));
									eNewExprOp = (int)(176);
								}
							}
							else
							{

								pExpr.y.pTab = pTab;
								if ((pParse.bReturning) != 0)
								{
									eNewExprOp = (int)(176);
									pExpr.op2 = (byte)(167);
									pExpr.iTable = (int)(pNC.uNC.iBaseReg + (pTab.nCol + 1) * pExpr.iTable + sqlite3TableColumnToStorage(pTab, (short)(iCol)) + 1);
								}
								else
								{
									pExpr.iColumn = ((short)(iCol));
									eNewExprOp = (int)(77);
									if ((iCol) < (0))
									{
										pExpr.affExpr = (sbyte)(0x44);
									}
									else if ((pExpr.iTable) == (0))
									{
										pParse.oldmask |= (uint)((iCol) >= (32) ? 0xffffffff : (((uint)(1)) << iCol));
									}
									else
									{
										pParse.newmask |= (uint)((iCol) >= (32) ? 0xffffffff : (((uint)(1)) << iCol));
									}
								}
							}
						}
					}
				}

				if (((((((cnt) == (0)) && ((cntTab) == (1))) && ((pMatch) != null)) && ((pNC.ncFlags & (0x000020 | 0x000008)) == (0))) && ((sqlite3IsRowid(zCol)) != 0)) && ((((pMatch.pTab).tabFlags & 0x00000200) == (0)) != 0))
				{
					cnt = (int)(1);
					pExpr.iColumn = (short)(-1);
					pExpr.affExpr = (sbyte)(0x44);
				}

				if ((((cnt) == (0)) && ((pNC.ncFlags & 0x000080) != 0)) && ((zTab) == (null)))
				{
					pEList = pNC.uNC.pEList;

					for (j = (int)(0); (j) < (pEList.nExpr); j++)
					{
						sbyte* zAs = pEList.a[j].zEName;
						if (((pEList.a[j].eEName) == (0)) && ((sqlite3_stricmp(zAs, zCol)) == (0)))
						{
							Expr pOrig;



							pOrig = pEList.a[j].pExpr;
							if (((pNC.ncFlags & 0x000001) == (0)) && (((pOrig).flags & (0x000010)) != 0))
							{
								sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
								return (int)(2);
							}

							if ((((pOrig).flags & (0x008000)) != 0) && (((pNC.ncFlags & 0x004000) == (0)) || (pNC != pTopNC)))
							{
								sqlite3ErrorMsg(pParse, "misuse of aliased window function %s", zAs);
								return (int)(2);
							}

							if (sqlite3ExprVectorSize(pOrig) != 1)
							{
								sqlite3ErrorMsg(pParse, "row value misused");
								return (int)(2);
							}

							resolveAlias(pParse, pEList, (int)(j), pExpr, (int)(nSubquery));
							cnt = (int)(1);
							pMatch = null;

							if (((pParse.eParseMode) >= (2)))
							{
								sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr));
							}

							goto lookupname_end;
						}
					}
				}

				if ((cnt) != 0)
					break;
				pNC = pNC.pNext;
				nSubquery++;
			}
			while ((pNC) != null);
			if (((cnt) == (0)) && ((zTab) == (null)))
			{

				if ((((pExpr).flags & (0x000040)) != 0) && ((areDoubleQuotedStringsEnabled(db, pTopNC)) != 0))
				{
					sqlite3_log((int)(28), "double-quoted string literal: \"%w\"", zCol);
					pExpr.op = (byte)(117);
					CRuntime.memset(&pExpr.y, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18099 : 3)) ) )
            ;
					return (int)(1);
				}

				if ((sqlite3ExprIdToTrueFalse(pExpr)) != 0)
				{
					return (int)(1);
				}
			}

			if (cnt != 1)
			{
				sbyte* zErr;
				zErr = (cnt) == (0) ? "no such column" : "ambiguous column name";
				if ((zDb) != null)
				{
					sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
				}
				else if ((zTab) != null)
				{
					sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
				}
				else
				{
					sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
				}

				sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
				pParse.checkSchema = (byte)(1);
				pTopNC.nNcErr++;
			}

			if (((pExpr.iColumn) >= (0)) && (pMatch != null))
			{
				pMatch.colUsed |= (ulong)(sqlite3ExprColUsed(pExpr));
			}

			if (!(((pExpr).flags & (0x004000 | 0x800000)) != 0))
			{
				sqlite3ExprDelete(db, pExpr.pLeft);
				pExpr.pLeft = null;
				sqlite3ExprDelete(db, pExpr.pRight);
				pExpr.pRight = null;
			}

			pExpr.op = (byte)(eNewExprOp);
			(pExpr).flags |= (uint)(0x800000);
		lookupname_end:
			; if ((cnt) == (1)) { ((void)(0)); if (((pParse.db.xAuth) != null) && (((pExpr.op) == (167)) || ((pExpr.op) == (77)))) { sqlite3AuthRead(pParse, pExpr, pSchema, pNC.pSrcList); } for (; ; ) { ((void)(0)); pTopNC.nRef++; if ((pTopNC) == (pNC)) break; pTopNC = pTopNC.pNext; } return (int)(1); } else { return (int)(2); }
		}
		public static void lowerFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* z1;
			sbyte* z2;
			int i = 0; int n = 0;

			z2 = (sbyte*)(sqlite3_value_text(argv[0]));
			n = (int)(sqlite3_value_bytes(argv[0]));

			if ((z2) != null)
			{
				z1 = contextMalloc(context, (long)(((long)(n)) + 1));
				if ((z1) != null)
				{
					for (i = (int)(0); (i) < (n); i++)
					{
						z1[i] = (sbyte)(sqlite3UpperToLower[(byte)(z2[i])]);
					}

					sqlite3_result_text(context, z1, (int)(n), sqlite3_free);
				}
			}
		}
		public static void makeColumnPartOfPrimaryKey(Parse pParse, Column* pCol)
		{
			pCol->colFlags |= (ushort)(0x0001);
			if ((pCol->colFlags & 0x0060) != 0)
			{
				sqlite3ErrorMsg(pParse, "generated columns cannot be part of the PRIMARY KEY");
			}
		}
		public static int makeSorterRecord(Parse pParse, SortCtx pSort, Select pSelect, int regBase, int nBase)
		{
			int nOBSat = (int)(pSort.nOBSat);
			Vdbe v = pParse.pVdbe;
			int regOut = (int)(++pParse.nMem);
			if ((pSort.pDeferredRowLoad) != null)
			{
				innerLoopLoadRow(pParse, pSelect, pSort.pDeferredRowLoad);
			}

			sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase + nOBSat), (int)(nBase - nOBSat), (int)(regOut));
			return (int)(regOut);
		}
		public static void mallocWithAlarm(int n, void** pp)
		{
			void* p;
			int nFull = 0;


			nFull = (int)(sqlite3Config.m.xRoundup((int)(n)));
			sqlite3StatusHighwater((int)(5), (int)(n));
			if ((mem0.alarmThreshold) > (0))
			{
				long nUsed = (long)(sqlite3StatusValue((int)(0)));
				if ((nUsed) >= (mem0.alarmThreshold - nFull))
				{
					(1);
					sqlite3MallocAlarm((int)(nFull));
					if ((mem0.hardLimit) != 0)
					{
						nUsed = (long)(sqlite3StatusValue((int)(0)));
						if ((nUsed) >= (mem0.hardLimit - nFull))
						{
							*pp = null;
							return;
						}
					}
				}
				else
				{
					(0);
				}
			}

			p = sqlite3Config.m.xMalloc((int)(nFull));
			if ((p) != null)
			{
				nFull = (int)(sqlite3MallocSize(p));
				sqlite3StatusUp((int)(0), (int)(nFull));
				sqlite3StatusUp((int)(9), (int)(1));
			}

			*pp = p;
		}
		public static void markTermAsChild(WhereClause pWC, int iChild, int iParent)
		{
			pWC.a[iChild].iParent = (int)(iParent);
			pWC.a[iChild].truthProb = (short)(pWC.a[iParent].truthProb);
			pWC.a[iParent].nChild++;
		}
		public static int matchQuality(FuncDef p, int nArg, byte enc)
		{
			int match = 0;

			if (p.nArg != nArg)
			{
				if ((nArg) == (-2))
					return (int)(((p.xSFunc) == (null)) ? 0 : 6);
				if ((p.nArg) >= (0))
					return (int)(0);
			}

			if ((p.nArg) == (nArg))
			{
				match = (int)(4);
			}
			else
			{
				match = (int)(1);
			}

			if ((enc) == (p.funcFlags & 0x0003))
			{
				match += (int)(2);
			}
			else if ((enc & p.funcFlags & 2) != 0)
			{
				match += (int)(1);
			}

			return (int)(match);
		}
		public static void measureAllocationSize(sqlite3 db, void* p)
		{
			*db.pnBytesFreed += (int)(sqlite3DbMallocSize(db, p));
		}
		public static int memdbAccess(sqlite3_vfs pVfs, sbyte* zPath, int flags, int* pResOut)
		{
			(void)(pVfs);
			(void)(zPath);
			(void)(flags);
			*pResOut = (int)(0);
			return (int)(0);
		}
		public static int memdbClose(sqlite3_file pFile)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			if ((p->zFName) != null)
			{
				int i = 0;
				sqlite3_mutex* pVfsMutex = sqlite3MutexAlloc((int)(11));
				sqlite3_mutex_enter(pVfsMutex);
				for (i = (int)(0); ((i) < (memdb_g.nMemStore)); i++)
				{
					if ((memdb_g.apMemStore[i]) == (p))
					{
						memdbEnter(p);
						if ((p->nRef) == (1))
						{
							memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];
							if ((memdb_g.nMemStore) == (0))
							{
								sqlite3_free(memdb_g.apMemStore);
								memdb_g.apMemStore = null;
							}
						}

						break;
					}
				}

				sqlite3_mutex_leave(pVfsMutex);
			}
			else
			{
				memdbEnter(p);
			}

			p->nRef--;
			if ((p->nRef) <= (0))
			{
				if ((p->mFlags & 1) != 0)
				{
					sqlite3_free(p->aData);
				}

				memdbLeave(p);
				sqlite3_mutex_free(p->pMutex);
				sqlite3_free(p);
			}
			else
			{
				memdbLeave(p);
			}

			return (int)(0);
		}
		public static int memdbCurrentTimeInt64(sqlite3_vfs pVfs, long* p)
		{
			return (int)(((sqlite3_vfs)((pVfs).pAppData)).xCurrentTimeInt64(((sqlite3_vfs)((pVfs).pAppData)), p));
		}
		public static int memdbDeviceCharacteristics(sqlite3_file pFile)
		{
			(void)(pFile);
			return (int)(0x00000001 | 0x00001000 | 0x00000200 | 0x00000400);
		}
		public static void memdbDlClose(sqlite3_vfs pVfs, void* pHandle)
		{
			((sqlite3_vfs)((pVfs).pAppData)).xDlClose(((sqlite3_vfs)((pVfs).pAppData)), pHandle);
		}
		public static void memdbDlError(sqlite3_vfs pVfs, int nByte, sbyte* zErrMsg)
		{
			((sqlite3_vfs)((pVfs).pAppData)).xDlError(((sqlite3_vfs)((pVfs).pAppData)), (int)(nByte), zErrMsg);
		}
		public static void* memdbDlOpen(sqlite3_vfs pVfs, sbyte* zPath)
		{
			return ((sqlite3_vfs)((pVfs).pAppData)).xDlOpen(((sqlite3_vfs)((pVfs).pAppData)), zPath);
		}
		public static Void()memdbDlSym(sqlite3_vfs pVfs, void* p, sbyte* zSym)
		{
			return ((sqlite3_vfs)((pVfs).pAppData)).xDlSym(((sqlite3_vfs)((pVfs).pAppData)), p, zSym);
		}
		public static int memdbEnlarge(MemStore* p, long newSz)
		{
			byte* pNew;
			if (((p->mFlags & 2) == (0)) || ((p->nMmap) > (0)))
			{
				return (int)(13);
			}

			if ((newSz) > (p->szMax))
			{
				return (int)(13);
			}

			newSz *= (long)(2);
			if ((newSz) > (p->szMax))
				newSz = (long)(p->szMax);
			pNew = sqlite3Realloc(p->aData, (ulong)(newSz));
			if ((pNew) == (null))
				return (int)(10 | (12 << 8));
			p->aData = pNew;
			p->szAlloc = (long)(newSz);
			return (int)(0);
		}
		public static void memdbEnter(MemStore* p)
		{
			sqlite3_mutex_enter(p->pMutex);
		}
		public static int memdbFetch(sqlite3_file pFile, long iOfst, int iAmt, void** pp)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			if (((iOfst + iAmt) > (p->sz)) || ((p->mFlags & 2) != 0))
			{
				*pp = null;
			}
			else
			{
				p->nMmap++;
				*pp = (void*)(p->aData + iOfst);
			}

			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbFileControl(sqlite3_file pFile, int op, void* pArg)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			int rc = (int)(12);
			memdbEnter(p);
			if ((op) == (12))
			{
				*(sbyte**)(pArg) = sqlite3_mprintf("memdb(%p,%lld)", p->aData, (long)(p->sz));
				rc = (int)(0);
			}

			if ((op) == (36))
			{
				long iLimit = (long)(*(long*)(pArg));
				if ((iLimit) < (p->sz))
				{
					if ((iLimit) < (0))
					{
						iLimit = (long)(p->szMax);
					}
					else
					{
						iLimit = (long)(p->sz);
					}
				}

				p->szMax = (long)(iLimit);
				*(long*)(pArg) = (long)(iLimit);
				rc = (int)(0);
			}

			memdbLeave(p);
			return (int)(rc);
		}
		public static int memdbFileSize(sqlite3_file pFile, long* pSize)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			*pSize = (long)(p->sz);
			memdbLeave(p);
			return (int)(0);
		}
		public static MemFile memdbFromDbSchema(sqlite3 db, sbyte* zSchema)
		{
			MemFile p = null;
			MemStore* pStore;
			int rc = (int)(sqlite3_file_control(db, zSchema, (int)(7), p));
			if ((rc) != 0)
				return null;
			if (p._base_.pMethods != memdb_io_methods)
				return null;
			pStore = p.pStore;
			memdbEnter(pStore);
			if (pStore->zFName != null)
				p = null;
			memdbLeave(pStore);
			return p;
		}
		public static int memdbFullPathname(sqlite3_vfs pVfs, sbyte* zPath, int nOut, sbyte* zOut)
		{
			(void)(pVfs);
			sqlite3_snprintf((int)(nOut), zOut, "%s", zPath);
			return (int)(0);
		}
		public static int memdbGetLastError(sqlite3_vfs pVfs, int a, sbyte* b)
		{
			return (int)(((sqlite3_vfs)((pVfs).pAppData)).xGetLastError(((sqlite3_vfs)((pVfs).pAppData)), (int)(a), b));
		}
		public static void memdbLeave(MemStore* p)
		{
			sqlite3_mutex_leave(p->pMutex);
		}
		public static int memdbLock(sqlite3_file pFile, int eLock)
		{
			MemFile pThis = (MemFile)(pFile);
			MemStore* p = pThis.pStore;
			int rc = (int)(0);
			if ((eLock) == (pThis.eLock))
				return (int)(0);
			memdbEnter(p);
			if ((eLock) > (1))
			{
				if ((p->mFlags & 4) != 0)
				{
					rc = (int)(8);
				}
				else if ((pThis.eLock) <= (1))
				{
					if ((p->nWrLock) != 0)
					{
						rc = (int)(5);
					}
					else
					{
						p->nWrLock = (int)(1);
					}
				}
			}
			else if ((eLock) == (1))
			{
				if ((pThis.eLock) > (1))
				{

					p->nWrLock = (int)(0);
				}
				else if ((p->nWrLock) != 0)
				{
					rc = (int)(5);
				}
				else
				{
					p->nRdLock++;
				}
			}
			else
			{

				if ((pThis.eLock) > (1))
				{

					p->nWrLock = (int)(0);
				}


				p->nRdLock--;
			}

			if ((rc) == (0))
				pThis.eLock = (int)(eLock);
			memdbLeave(p);
			return (int)(rc);
		}
		public static int memdbOpen(sqlite3_vfs pVfs, sbyte* zName, sqlite3_file pFd, int flags, int* pOutFlags)
		{
			MemFile pFile = (MemFile)(pFd);
			MemStore* p = null;
			int szName = 0;
			(void)(pVfs);
			CRuntime.memset(pFile, (int)(0), (ulong)(sizeof(MemFile)));
			szName = (int)(sqlite3Strlen30(zName));
			if (((szName) > (1)) && ((zName[0]) == (47)))
			{
				int i = 0;
				sqlite3_mutex* pVfsMutex = sqlite3MutexAlloc((int)(11));
				sqlite3_mutex_enter(pVfsMutex);
				for (i = (int)(0); (i) < (memdb_g.nMemStore); i++)
				{
					if ((CRuntime.strcmp(memdb_g.apMemStore[i]->zFName, zName)) == (0))
					{
						p = memdb_g.apMemStore[i];
						break;
					}
				}

				if ((p) == (null))
				{
					MemStore** apNew;
					p = sqlite3Malloc((ulong)(sizeof(MemStore) + szName + 3));
					if ((p) == (null))
					{
						sqlite3_mutex_leave(pVfsMutex);
						return (int)(7);
					}

					apNew = sqlite3Realloc(memdb_g.apMemStore, (ulong)(sizeof(MemStore*) * (memdb_g.nMemStore + 1)));
					if ((apNew) == (null))
					{
						sqlite3_free(p);
						sqlite3_mutex_leave(pVfsMutex);
						return (int)(7);
					}

					apNew[memdb_g.nMemStore++] = p;
					memdb_g.apMemStore = apNew;
					CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemStore)));
					p->mFlags = (uint)(2 | 1);
					p->szMax = (long)(sqlite3Config.mxMemdbSize);
					p->zFName = (sbyte*)(&p[1]);
					CRuntime.memcpy(p->zFName, zName, (ulong)(szName + 1));
					p->pMutex = sqlite3_mutex_alloc((int)(0));
					if ((p->pMutex) == (null))
					{
						memdb_g.nMemStore--;
						sqlite3_free(p);
						sqlite3_mutex_leave(pVfsMutex);
						return (int)(7);
					}

					p->nRef = (int)(1);
					memdbEnter(p);
				}
				else
				{
					memdbEnter(p);
					p->nRef++;
				}

				sqlite3_mutex_leave(pVfsMutex);
			}
			else
			{
				p = sqlite3Malloc((ulong)(sizeof(MemStore)));
				if ((p) == (null))
				{
					return (int)(7);
				}

				CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemStore)));
				p->mFlags = (uint)(2 | 1);
				p->szMax = (long)(sqlite3Config.mxMemdbSize);
			}

			pFile.pStore = p;
			if (pOutFlags != null)
			{
				*pOutFlags = (int)(flags | 0x00000080);
			}

			pFd.pMethods = memdb_io_methods;
			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbRandomness(sqlite3_vfs pVfs, int nByte, sbyte* zBufOut)
		{
			return (int)(((sqlite3_vfs)((pVfs).pAppData)).xRandomness(((sqlite3_vfs)((pVfs).pAppData)), (int)(nByte), zBufOut));
		}
		public static int memdbRead(sqlite3_file pFile, void* zBuf, int iAmt, long iOfst)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			if ((iOfst + iAmt) > (p->sz))
			{
				CRuntime.memset(zBuf, (int)(0), (ulong)(iAmt));
				if ((iOfst) < (p->sz))
					CRuntime.memcpy(zBuf, p->aData + iOfst, (ulong)(p->sz - iOfst));
				memdbLeave(p);
				return (int)(10 | (2 << 8));
			}

			CRuntime.memcpy(zBuf, p->aData + iOfst, (ulong)(iAmt));
			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbSleep(sqlite3_vfs pVfs, int nMicro)
		{
			return (int)(((sqlite3_vfs)((pVfs).pAppData)).xSleep(((sqlite3_vfs)((pVfs).pAppData)), (int)(nMicro)));
		}
		public static int memdbSync(sqlite3_file pFile, int flags)
		{
			(void)(pFile);
			(void)(flags);
			return (int)(0);
		}
		public static int memdbTruncate(sqlite3_file pFile, long size)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			int rc = (int)(0);
			memdbEnter(p);
			if ((size) > (p->sz))
			{
				rc = (int)(11);
			}
			else
			{
				p->sz = (long)(size);
			}

			memdbLeave(p);
			return (int)(rc);
		}
		public static int memdbUnfetch(sqlite3_file pFile, long iOfst, void* pPage)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			(void)(iOfst);
			(void)(pPage);
			memdbEnter(p);
			p->nMmap--;
			memdbLeave(p);
			return (int)(0);
		}
		public static int memdbWrite(sqlite3_file pFile, void* z, int iAmt, long iOfst)
		{
			MemStore* p = ((MemFile)(pFile)).pStore;
			memdbEnter(p);
			if ((p->mFlags & 4) != 0)
			{
				memdbLeave(p);
				return (int)(10 | (3 << 8));
			}

			if ((iOfst + iAmt) > (p->sz))
			{
				int rc = 0;
				if (((iOfst + iAmt) > (p->szAlloc)) && ((rc = (int)(memdbEnlarge(p, (long)(iOfst + iAmt)))) != 0))
				{
					memdbLeave(p);
					return (int)(rc);
				}

				if ((iOfst) > (p->sz))
					CRuntime.memset(p->aData + p->sz, (int)(0), (ulong)(iOfst - p->sz));
				p->sz = (long)(iOfst + iAmt);
			}

			CRuntime.memcpy(p->aData + iOfst, z, (ulong)(iAmt));
			memdbLeave(p);
			return (int)(0);
		}
		public static long memIntValue(sqlite3_value pMem)
		{
			long value = (long)(0);
			sqlite3Atoi64(pMem.z, &value, (int)(pMem.n), (byte)(pMem.enc));
			return (long)(value);
		}
		public static int memjrnlClose(sqlite3_file pJfd)
		{
			MemJournal p = (MemJournal)(pJfd);
			memjrnlFreeChunks(p.pFirst);
			return (int)(0);
		}
		public static int memjrnlCreateFile(MemJournal p)
		{
			int rc = 0;
			sqlite3_file pReal = (sqlite3_file)(p);
			MemJournal copy = (MemJournal)(p);
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemJournal)));
			rc = (int)(sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, (int)(copy.flags), null));
			if ((rc) == (0))
			{
				int nChunk = (int)(copy.nChunkSize);
				long iOff = (long)(0);
				FileChunk* pIter;
				for (pIter = copy.pFirst; pIter; pIter = pIter->pNext)
				{
					if ((iOff + nChunk) > (copy.endpoint.iOffset))
					{
						nChunk = (int)(copy.endpoint.iOffset - iOff);
					}

					rc = (int)(sqlite3OsWrite(pReal, pIter->zChunk, (int)(nChunk), (long)(iOff)));
					if ((rc) != 0)
						break;
					iOff += (long)(nChunk);
				}

				if ((rc) == (0))
				{
					memjrnlFreeChunks(copy.pFirst);
				}
			}

			if (rc != 0)
			{
				sqlite3OsClose(pReal);
				p = (MemJournal)(copy);
			}

			return (int)(rc);
		}
		public static int memjrnlFileSize(sqlite3_file pJfd, long* pSize)
		{
			MemJournal p = (MemJournal)(pJfd);
			*pSize = (long)(p.endpoint.iOffset);
			return (int)(0);
		}
		public static void memjrnlFreeChunks(FileChunk* pFirst)
		{
			FileChunk* pIter;
			FileChunk* pNext;
			for (pIter = pFirst; pIter; pIter = pNext)
			{
				pNext = pIter->pNext;
				sqlite3_free(pIter);
			}
		}
		public static int memjrnlRead(sqlite3_file pJfd, void* zBuf, int iAmt, long iOfst)
		{
			MemJournal p = (MemJournal)(pJfd);
			byte* zOut = zBuf;
			int nRead = (int)(iAmt);
			int iChunkOffset = 0;
			FileChunk* pChunk;
			if ((iAmt + iOfst) > (p.endpoint.iOffset))
			{
				return (int)(10 | (2 << 8));
			}


			if ((p.readpoint.iOffset != iOfst) || ((iOfst) == (0)))
			{
				long iOff = (long)(0);
				for (pChunk = p.pFirst; ((pChunk) != null) && ((iOff + p.nChunkSize) <= (iOfst)); pChunk = pChunk->pNext)
				{
					iOff += (long)(p.nChunkSize);
				}
			}
			else
			{
				pChunk = p.readpoint.pChunk;

			}

			iChunkOffset = ((int)(iOfst % p.nChunkSize));
			do
			{
				int iSpace = (int)(p.nChunkSize - iChunkOffset);
				int nCopy = (int)((nRead) < (p.nChunkSize - iChunkOffset) ? (nRead) : (p.nChunkSize - iChunkOffset));
				CRuntime.memcpy(zOut, pChunk->zChunk + iChunkOffset, (ulong)(nCopy));
				zOut += nCopy;
				nRead -= (int)(iSpace);
				iChunkOffset = (int)(0);
			}
			while ((((nRead) >= (0)) && ((pChunk = pChunk->pNext) != null)) && ((nRead) > (0)));
			p.readpoint.iOffset = (long)(pChunk ? iOfst + iAmt : 0);
			p.readpoint.pChunk = pChunk;
			return (int)(0);
		}
		public static int memjrnlSync(sqlite3_file pJfd, int flags)
		{
			(void)(pJfd) ,  (void)(flags);
			return (int)(0);
		}
		public static int memjrnlTruncate(sqlite3_file pJfd, long size)
		{
			MemJournal p = (MemJournal)(pJfd);

			if ((size) < (p.endpoint.iOffset))
			{
				FileChunk* pIter = null;
				if ((size) == (0))
				{
					memjrnlFreeChunks(p.pFirst);
					p.pFirst = null;
				}
				else
				{
					long iOff = (long)(p.nChunkSize);
					for (pIter = p.pFirst; ((pIter) != null) && ((iOff) < (size)); pIter = pIter->pNext)
					{
						iOff += (long)(p.nChunkSize);
					}

					if ((pIter) != null)
					{
						memjrnlFreeChunks(pIter->pNext);
						pIter->pNext = null;
					}
				}

				p.endpoint.pChunk = pIter;
				p.endpoint.iOffset = (long)(size);
				p.readpoint.pChunk = null;
				p.readpoint.iOffset = (long)(0);
			}

			return (int)(0);
		}
		public static int memjrnlWrite(sqlite3_file pJfd, void* zBuf, int iAmt, long iOfst)
		{
			MemJournal p = (MemJournal)(pJfd);
			int nWrite = (int)(iAmt);
			byte* zWrite = (byte*)(zBuf);
			if (((p.nSpill) > (0)) && ((iAmt + iOfst) > (p.nSpill)))
			{
				int rc = (int)(memjrnlCreateFile(p));
				if ((rc) == (0))
				{
					rc = (int)(sqlite3OsWrite(pJfd, zBuf, (int)(iAmt), (long)(iOfst)));
				}

				return (int)(rc);
			}
			else
			{

				if (((iOfst) > (0)) && (iOfst != p.endpoint.iOffset))
				{
					memjrnlTruncate(pJfd, (long)(iOfst));
				}

				if (((iOfst) == (0)) && ((p.pFirst) != null))
				{

					CRuntime.memcpy(p.pFirst->zChunk, zBuf, (ulong)(iAmt));
				}
				else
				{
					while ((nWrite) > (0))
					{
						FileChunk* pChunk = p.endpoint.pChunk;
						int iChunkOffset = (int)(p.endpoint.iOffset % p.nChunkSize);
						int iSpace = (int)((nWrite) < (p.nChunkSize - iChunkOffset) ? (nWrite) : (p.nChunkSize - iChunkOffset));

						if ((iChunkOffset) == (0))
						{
							FileChunk* pNew = sqlite3_malloc((int)(sizeof(FileChunk) + ((p.nChunkSize) - 8)));
							if (pNew == null)
							{
								return (int)(10 | (12 << 8));
							}

							pNew->pNext = null;
							if ((pChunk) != null)
							{

								pChunk->pNext = pNew;
							}
							else
							{

								p.pFirst = pNew;
							}

							pChunk = p.endpoint.pChunk = pNew;
						}


						CRuntime.memcpy(pChunk->zChunk + iChunkOffset, zWrite, (ulong)(iSpace));
						zWrite += iSpace;
						nWrite -= (int)(iSpace);
						p.endpoint.iOffset += (long)(iSpace);
					}
				}
			}

			return (int)(0);
		}
		public static double memRealValue(sqlite3_value pMem)
		{
			double val = (double)(0);
			sqlite3AtoF(pMem.z, &val, (int)(pMem.n), (byte)(pMem.enc));
			return (double)(val);
		}
		public static void minMaxFinalize(sqlite3_context context)
		{
			minMaxValueFinalize(context, (int)(0));
		}
		public static void minmaxFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int i = 0;
			int mask = 0;
			int iBest = 0;
			CollSeq pColl;

			mask = (int)((sqlite3_user_data(context)) == (null) ? 0 : -1);
			pColl = sqlite3GetFuncCollSeq(context);


			iBest = (int)(0);
			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			for (i = (int)(1); (i) < (argc); i++)
			{
				if ((sqlite3_value_type(argv[i])) == (5))
					return;
				if ((sqlite3MemCompare(argv[iBest], argv[i], pColl) ^ mask) >= (0))
				{
					iBest = (int)(i);
				}
			}

			sqlite3_result_value(context, argv[iBest]);
		}
		public static byte minMaxQuery(sqlite3 db, Expr pFunc, ExprList ppMinMax)
		{
			int eRet = (int)(0x0000);
			ExprList pEList;
			sbyte* zFunc;
			ExprList pOrderBy;
			byte sortFlags = (byte)(0);




			pEList = pFunc.x.pList;
			if (((((pEList) == (null)) || (pEList.nExpr != 1)) || (((pFunc).flags & (0x1000000)) != 0)) || (((db).dbOptFlags & (0x00010000)) != 0))
			{
				return (byte)(eRet);
			}


			zFunc = pFunc.u.zToken;
			if ((sqlite3StrICmp(zFunc, "min")) == (0))
			{
				eRet = (int)(0x0001);
				if ((sqlite3ExprCanBeNull(pEList.a[0].pExpr)) != 0)
				{
					sortFlags = (byte)(0x02);
				}
			}
			else if ((sqlite3StrICmp(zFunc, "max")) == (0))
			{
				eRet = (int)(0x0002);
				sortFlags = (byte)(0x01);
			}
			else
			{
				return (byte)(eRet);
			}

			ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, (int)(0));

			if ((pOrderBy) != null)
				pOrderBy.a[0].sortFlags = (byte)(sortFlags);
			return (byte)(eRet);
		}
		public static void minmaxStep(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3_value pArg = argv[0];
			sqlite3_value pBest;
			(void)(NotUsed);
			pBest = (sqlite3_value)(sqlite3_aggregate_context(context, (int)(sizeof(sqlite3_value))));
			if (pBest == null)
				return;
			if ((sqlite3_value_type(pArg)) == (5))
			{
				if ((pBest.flags) != 0)
					sqlite3SkipAccumulatorLoad(context);
			}
			else if ((pBest.flags) != 0)
			{
				int max = 0;
				int cmp = 0;
				CollSeq pColl = sqlite3GetFuncCollSeq(context);
				max = (int)(sqlite3_user_data(context) != null);
				cmp = (int)(sqlite3MemCompare(pBest, pArg, pColl));
				if ((((max) != 0) && ((cmp) < (0))) || ((max == 0) && ((cmp) > (0))))
				{
					sqlite3VdbeMemCopy(pBest, pArg);
				}
				else
				{
					sqlite3SkipAccumulatorLoad(context);
				}
			}
			else
			{
				pBest.db = sqlite3_context_db_handle(context);
				sqlite3VdbeMemCopy(pBest, pArg);
			}
		}
		public static void minMaxValue(sqlite3_context context)
		{
			minMaxValueFinalize(context, (int)(1));
		}
		public static void minMaxValueFinalize(sqlite3_context context, int bValue)
		{
			sqlite3_value pRes;
			pRes = (sqlite3_value)(sqlite3_aggregate_context(context, (int)(0)));
			if ((pRes) != null)
			{
				if ((pRes.flags) != 0)
				{
					sqlite3_result_value(context, pRes);
				}

				if ((bValue) == (0))
					sqlite3VdbeMemRelease(pRes);
			}
		}
		public static int modifyPagePointer(MemPage pPage, uint iFrom, uint iTo, byte eType)
		{


			if ((eType) == (4))
			{
				if (sqlite3Get4byte(pPage.aData) != iFrom)
				{
					return (int)(sqlite3CorruptError((int)(69816)));
				}

				sqlite3Put4byte(pPage.aData, (uint)(iTo));
			}
			else
			{
				int i = 0;
				int nCell = 0;
				int rc = 0;
				rc = (int)((pPage.isInit) != 0 ? 0 : btreeInitPage(pPage));
				if ((rc) != 0)
					return (int)(rc);
				nCell = (int)(pPage.nCell);
				for (i = (int)(0); (i) < (nCell); i++)
				{
					byte* pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (i)])))));
					if ((eType) == (3))
					{
						CellInfo info = new CellInfo();
						pPage.xParseCell(pPage, pCell, &info);
						if ((info.nLocal) < (info.nPayload))
						{
							if ((pCell + info.nSize) > (pPage.aData + pPage.pBt.usableSize))
							{
								return (int)(sqlite3CorruptError((int)(69835)));
							}

							if ((iFrom) == (sqlite3Get4byte(pCell + info.nSize - 4)))
							{
								sqlite3Put4byte(pCell + info.nSize - 4, (uint)(iTo));
								break;
							}
						}
					}
					else
					{
						if ((sqlite3Get4byte(pCell)) == (iFrom))
						{
							sqlite3Put4byte(pCell, (uint)(iTo));
							break;
						}
					}
				}

				if ((i) == (nCell))
				{
					if ((eType != 5) || (sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]) != iFrom))
					{
						return (int)(sqlite3CorruptError((int)(69853)));
					}

					sqlite3Put4byte(&pPage.aData[pPage.hdrOffset + 8], (uint)(iTo));
				}
			}

			return (int)(0);
		}
		public static int moveToChild(BtCursor pCur, uint newPgno)
		{
			BtShared pBt = pCur.pBt;




			if ((pCur.iPage) >= (20 - 1))
			{
				return (int)(sqlite3CorruptError((int)(71351)));
			}

			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x02 | 0x04));
			pCur.aiIdx[pCur.iPage] = (ushort)(pCur.ix);
			pCur.apPage[pCur.iPage] = pCur.pPage;
			pCur.ix = (ushort)(0);
			pCur.iPage++;
			return (int)(getAndInitPage(pBt, (uint)(newPgno), pCur.pPage, pCur, (int)(pCur.curPagerFlags)));
		}
		public static int moveToLeftmost(BtCursor pCur)
		{
			uint pgno = 0;
			int rc = (int)(0);
			MemPage pPage;


			while (((rc) == (0)) && ((pPage = pCur.pPage).leaf == 0))
			{

				pgno = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (pCur.ix)])))))));
				rc = (int)(moveToChild(pCur, (uint)(pgno)));
			}

			return (int)(rc);
		}
		public static void moveToParent(BtCursor pCur)
		{
			MemPage pLeaf;




			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x02 | 0x04));
			pCur.ix = (ushort)(pCur.aiIdx[pCur.iPage - 1]);
			pLeaf = pCur.pPage;
			pCur.pPage = pCur.apPage[--pCur.iPage];
			releasePageNotNull(pLeaf);
		}
		public static int moveToRightmost(BtCursor pCur)
		{
			uint pgno = 0;
			int rc = (int)(0);
			MemPage pPage = null;


			while ((pPage = pCur.pPage).leaf == 0)
			{
				pgno = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				pCur.ix = (ushort)(pPage.nCell);
				rc = (int)(moveToChild(pCur, (uint)(pgno)));
				if ((rc) != 0)
					return (int)(rc);
			}

			pCur.ix = (ushort)(pPage.nCell - 1);


			return (int)(0);
		}
		public static int moveToRoot(BtCursor pCur)
		{
			MemPage pRoot;
			int rc = (int)(0);






			if ((pCur.iPage) >= (0))
			{
				if ((pCur.iPage) != 0)
				{
					releasePageNotNull(pCur.pPage);
					while ((--pCur.iPage) != 0)
					{
						releasePageNotNull(pCur.apPage[pCur.iPage]);
					}

					pRoot = pCur.pPage = pCur.apPage[0];
					goto skip_init;
				}
			}
			else if ((pCur.pgnoRoot) == (0))
			{
				pCur.eState = (byte)(1);
				return (int)(16);
			}
			else
			{

				if ((pCur.eState) >= (3))
				{
					if ((pCur.eState) == (4))
					{

						return (int)(pCur.skipNext);
					}

					sqlite3BtreeClearCursor(pCur);
				}

				rc = (int)(getAndInitPage(pCur.pBtree.pBt, (uint)(pCur.pgnoRoot), pCur.pPage, null, (int)(pCur.curPagerFlags)));
				if (rc != 0)
				{
					pCur.eState = (byte)(1);
					return (int)(rc);
				}

				pCur.iPage = (sbyte)(0);
				pCur.curIntKey = (byte)(pCur.pPage.intKey);
			}

			pRoot = pCur.pPage;


			if (((pRoot.isInit) == (0)) || (((pCur.pKeyInfo) == (null)) != pRoot.intKey))
			{
				return (int)(sqlite3CorruptError((int)(71489)));
			}

		skip_init:
			; pCur.ix = (ushort)(0);
			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x08 | 0x02 | 0x04));
			if ((pRoot.nCell) > (0))
			{
				pCur.eState = (byte)(0);
			}
			else if (pRoot.leaf == 0)
			{
				uint subpage = 0;
				if (pRoot.pgno != 1)
					return (int)(sqlite3CorruptError((int)(71501)));
				subpage = (uint)(sqlite3Get4byte(&pRoot.aData[pRoot.hdrOffset + 8]));
				pCur.eState = (byte)(0);
				rc = (int)(moveToChild(pCur, (uint)(subpage)));
			}
			else
			{
				pCur.eState = (byte)(1);
				rc = (int)(16);
			}

			return (int)(rc);
		}
		public static int multiSelect(Parse pParse, Select p, SelectDest pDest)
		{
			int rc = (int)(0);
			Select pPrior;
			Vdbe v;
			SelectDest dest = new SelectDest();
			Select pDelete = null;
			sqlite3 db;



			db = pParse.db;
			pPrior = p.pPrior;
			dest = (SelectDest)(pDest);


			v = sqlite3GetVdbe(pParse);

			if ((dest.eDest) == (12))
			{

				sqlite3VdbeAddOp2(v, (int)(116), (int)(dest.iSDParm), (int)(p.pEList.nExpr));
				dest.eDest = (byte)(14);
			}

			if ((p.selFlags & 0x0000400) != 0)
			{
				rc = (int)(multiSelectValues(pParse, p, dest));
				if ((rc) >= (0))
					goto multi_select_end;
				rc = (int)(0);
			}



			if (((p.selFlags & 0x0002000) != 0) && ((hasAnchor(p)) != 0))
			{
				generateWithRecursiveQuery(pParse, p, dest);
			}
			else if ((p.pOrderBy) != null)
			{
				return (int)(multiSelectOrderBy(pParse, p, pDest));
			}
			else
			{
				if ((pPrior.pPrior) == (null))
				{
					sqlite3VdbeExplain(pParse, (byte)(1), "COMPOUND QUERY");
					sqlite3VdbeExplain(pParse, (byte)(1), "LEFT-MOST SUBQUERY");
				}

				switch (p.op)
				{
					case 135:
						{
							int addr = (int)(0);
							int nLimit = (int)(0);

							pPrior.iLimit = (int)(p.iLimit);
							pPrior.iOffset = (int)(p.iOffset);
							pPrior.pLimit = p.pLimit;
							rc = (int)(sqlite3Select(pParse, pPrior, dest));
							pPrior.pLimit = null;
							if ((rc) != 0)
							{
								goto multi_select_end;
							}

							p.pPrior = null;
							p.iLimit = (int)(pPrior.iLimit);
							p.iOffset = (int)(pPrior.iOffset);
							if ((p.iLimit) != 0)
							{
								addr = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(p.iLimit)));
								if ((p.iOffset) != 0)
								{
									sqlite3VdbeAddOp3(v, (int)(159), (int)(p.iLimit), (int)(p.iOffset + 1), (int)(p.iOffset));
								}
							}

							sqlite3VdbeExplain(pParse, (byte)(1), "UNION ALL");
							rc = (int)(sqlite3Select(pParse, p, dest));
							pDelete = p.pPrior;
							p.pPrior = pPrior;
							p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
							if (((((p.pLimit) != null) && ((sqlite3ExprIsInteger(p.pLimit.pLeft, &nLimit)) != 0)) && ((nLimit) > (0))) && ((p.nSelectRow) > (sqlite3LogEst((ulong)(nLimit)))))
							{
								p.nSelectRow = (short)(sqlite3LogEst((ulong)(nLimit)));
							}

							if ((addr) != 0)
							{
								sqlite3VdbeJumpHere(v, (int)(addr));
							}

							break;
						}

					case 136:
					case 134:
						{
							int unionTab = 0;
							byte op = (byte)(0);
							int priorOp = 0;
							Expr pLimit;
							int addr = 0;
							SelectDest uniondest = new SelectDest();
							priorOp = (int)(1);
							if ((dest.eDest) == (priorOp))
							{

								unionTab = (int)(dest.iSDParm);
							}
							else
							{
								unionTab = (int)(pParse.nTab++);

								addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(unionTab), (int)(0)));

								p.addrOpenEphm[0] = (int)(addr);
								findRightmost(p).selFlags |= (uint)(0x0000020);

							}


							sqlite3SelectDestInit(uniondest, (int)(priorOp), (int)(unionTab));
							rc = (int)(sqlite3Select(pParse, pPrior, uniondest));
							if ((rc) != 0)
							{
								goto multi_select_end;
							}

							if ((p.op) == (136))
							{
								op = (byte)(2);
							}
							else
							{

								op = (byte)(1);
							}

							p.pPrior = null;
							pLimit = p.pLimit;
							p.pLimit = null;
							uniondest.eDest = (byte)(op);
							sqlite3VdbeExplain(pParse, (byte)(1), "%s USING TEMP B-TREE", sqlite3SelectOpName((int)(p.op)));
							rc = (int)(sqlite3Select(pParse, p, uniondest));

							pDelete = p.pPrior;
							p.pPrior = pPrior;
							p.pOrderBy = null;
							if ((p.op) == (134))
							{
								p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
							}

							sqlite3ExprDelete(db, p.pLimit);
							p.pLimit = pLimit;
							p.iLimit = (int)(0);
							p.iOffset = (int)(0);


							if ((dest.eDest != priorOp) && ((db.mallocFailed) == (0)))
							{
								int iCont = 0;
								int iBreak = 0;
								int iStart = 0;
								iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
								iCont = (int)(sqlite3VdbeMakeLabel(pParse));
								computeLimitRegisters(pParse, p, (int)(iBreak));
								sqlite3VdbeAddOp2(v, (int)(38), (int)(unionTab), (int)(iBreak));
								iStart = (int)(sqlite3VdbeCurrentAddr(v));
								selectInnerLoop(pParse, p, (int)(unionTab), null, null, dest, (int)(iCont), (int)(iBreak));
								sqlite3VdbeResolveLabel(v, (int)(iCont));
								sqlite3VdbeAddOp2(v, (int)(5), (int)(unionTab), (int)(iStart));
								sqlite3VdbeResolveLabel(v, (int)(iBreak));
								sqlite3VdbeAddOp2(v, (int)(121), (int)(unionTab), (int)(0));
							}

							break;
						}

					default:

						{
							int tab1 = 0;
							int tab2 = 0;
							int iCont = 0;
							int iBreak = 0;
							int iStart = 0;
							Expr pLimit;
							int addr = 0;
							SelectDest intersectdest = new SelectDest();
							int r1 = 0;
							tab1 = (int)(pParse.nTab++);
							tab2 = (int)(pParse.nTab++);

							addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(tab1), (int)(0)));

							p.addrOpenEphm[0] = (int)(addr);
							findRightmost(p).selFlags |= (uint)(0x0000020);

							sqlite3SelectDestInit(intersectdest, (int)(1), (int)(tab1));
							rc = (int)(sqlite3Select(pParse, pPrior, intersectdest));
							if ((rc) != 0)
							{
								goto multi_select_end;
							}

							addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(tab2), (int)(0)));

							p.addrOpenEphm[1] = (int)(addr);
							p.pPrior = null;
							pLimit = p.pLimit;
							p.pLimit = null;
							intersectdest.iSDParm = (int)(tab2);
							sqlite3VdbeExplain(pParse, (byte)(1), "%s USING TEMP B-TREE", sqlite3SelectOpName((int)(p.op)));
							rc = (int)(sqlite3Select(pParse, p, intersectdest));
							pDelete = p.pPrior;
							p.pPrior = pPrior;
							if ((p.nSelectRow) > (pPrior.nSelectRow))
							{
								p.nSelectRow = (short)(pPrior.nSelectRow);
							}

							sqlite3ExprDelete(db, p.pLimit);
							p.pLimit = pLimit;
							if ((rc) != 0)
								break;

							iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
							iCont = (int)(sqlite3VdbeMakeLabel(pParse));
							computeLimitRegisters(pParse, p, (int)(iBreak));
							sqlite3VdbeAddOp2(v, (int)(38), (int)(tab1), (int)(iBreak));
							r1 = (int)(sqlite3GetTempReg(pParse));
							iStart = (int)(sqlite3VdbeAddOp2(v, (int)(133), (int)(tab1), (int)(r1)));
							sqlite3VdbeAddOp4Int(v, (int)(30), (int)(tab2), (int)(iCont), (int)(r1), (int)(0));
							sqlite3ReleaseTempReg(pParse, (int)(r1));
							selectInnerLoop(pParse, p, (int)(tab1), null, null, dest, (int)(iCont), (int)(iBreak));
							sqlite3VdbeResolveLabel(v, (int)(iCont));
							sqlite3VdbeAddOp2(v, (int)(5), (int)(tab1), (int)(iStart));
							sqlite3VdbeResolveLabel(v, (int)(iBreak));
							sqlite3VdbeAddOp2(v, (int)(121), (int)(tab2), (int)(0));
							sqlite3VdbeAddOp2(v, (int)(121), (int)(tab1), (int)(0));
							break;
						}
				}

				if ((p.pNext) == (null))
				{
					sqlite3VdbeExplainPop(pParse);
				}
			}

			if ((pParse.nErr) != 0)
				goto multi_select_end;
			if ((p.selFlags & 0x0000020) != 0)
			{
				int i = 0;
				KeyInfo pKeyInfo;
				Select pLoop;
				CollSeq apColl;
				int nCol = 0;


				nCol = (int)(p.pEList.nExpr);
				pKeyInfo = sqlite3KeyInfoAlloc(db, (int)(nCol), (int)(1));
				if (pKeyInfo == null)
				{
					rc = (int)(7);
					goto multi_select_end;
				}

				for (i = (int)(0), apColl = pKeyInfo.aColl; (i) < (nCol); i++, apColl++)
				{
					apColl = multiSelectCollSeq(pParse, p, (int)(i));
					if ((null) == (apColl))
					{
						apColl = db.pDfltColl;
					}
				}

				for (pLoop = p; pLoop; pLoop = pLoop.pPrior)
				{
					for (i = (int)(0); (i) < (2); i++)
					{
						int addr = (int)(pLoop.addrOpenEphm[i]);
						if ((addr) < (0))
						{

							break;
						}

						sqlite3VdbeChangeP2(v, (int)(addr), (int)(nCol));
						sqlite3VdbeChangeP4(v, (int)(addr), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9));
						pLoop.addrOpenEphm[i] = (int)(-1);
					}
				}

				sqlite3KeyInfoUnref(pKeyInfo);
			}

		multi_select_end:
			; pDest.iSdst = (int)(dest.iSdst);
			pDest.nSdst = (int)(dest.nSdst);
			if ((pDelete) != null)
			{
				sqlite3ParserAddCleanup(pParse, sqlite3SelectDelete, pDelete);
			}

			return (int)(rc);
		}
		public static CollSeq multiSelectCollSeq(Parse pParse, Select p, int iCol)
		{
			CollSeq pRet;
			if ((p.pPrior) != null)
			{
				pRet = multiSelectCollSeq(pParse, p.pPrior, (int)(iCol));
			}
			else
			{
				pRet = null;
			}


			if (((pRet) == (null)) && ((iCol) < (p.pEList.nExpr)))
			{
				pRet = sqlite3ExprCollSeq(pParse, p.pEList.a[iCol].pExpr);
			}

			return pRet;
		}
		public static int multiSelectOrderBy(Parse pParse, Select p, SelectDest pDest)
		{
			int i = 0; int j = 0;
			Select pPrior;
			Select pSplit;
			int nSelect = 0;
			Vdbe v;
			SelectDest destA = new SelectDest();
			SelectDest destB = new SelectDest();
			int regAddrA = 0;
			int regAddrB = 0;
			int addrSelectA = 0;
			int addrSelectB = 0;
			int regOutA = 0;
			int regOutB = 0;
			int addrOutA = 0;
			int addrOutB = (int)(0);
			int addrEofA = 0;
			int addrEofA_noB = 0;
			int addrEofB = 0;
			int addrAltB = 0;
			int addrAeqB = 0;
			int addrAgtB = 0;
			int regLimitA = 0;
			int regLimitB = 0;
			int regPrev = 0;
			int savedLimit = 0;
			int savedOffset = 0;
			int labelCmpr = 0;
			int labelEnd = 0;
			int addr1 = 0;
			int op = 0;
			KeyInfo pKeyDup = null;
			KeyInfo pKeyMerge;
			sqlite3 db;
			ExprList pOrderBy;
			int nOrderBy = 0;
			uint* aPermute;


			db = pParse.db;
			v = pParse.pVdbe;

			labelEnd = (int)(sqlite3VdbeMakeLabel(pParse));
			labelCmpr = (int)(sqlite3VdbeMakeLabel(pParse));
			op = (int)(p.op);

			pOrderBy = p.pOrderBy;

			nOrderBy = (int)(pOrderBy.nExpr);
			if (op != 135)
			{
				for (i = (int)(1); ((db.mallocFailed) == (0)) && ((i) <= (p.pEList.nExpr)); i++)
				{
					ExprList_item* pItem;
					for (j = (int)(0), pItem = pOrderBy.a; (j) < (nOrderBy); j++, pItem++)
					{


						if ((pItem->u.x.iOrderByCol) == (i))
							break;
					}

					if ((j) == (nOrderBy))
					{
						Expr pNew = sqlite3Expr(db, (int)(155), null);
						if ((pNew) == (null))
							return (int)(7);
						pNew.flags |= (uint)(0x000400);
						pNew.u.iValue = (int)(i);
						p.pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
						if ((pOrderBy) != null)
							pOrderBy.a[nOrderBy++].u.x.iOrderByCol = ((ushort)(i));
					}
				}
			}

			aPermute = sqlite3DbMallocRawNN(db, (ulong)(sizeof(uint) * (nOrderBy + 1)));
			if ((aPermute) != null)
			{
				ExprList_item* pItem;
				aPermute[0] = (uint)(nOrderBy);
				for (i = (int)(1), pItem = pOrderBy.a; (i) <= (nOrderBy); i++, pItem++)
				{



					aPermute[i] = (uint)(pItem->u.x.iOrderByCol - 1);
				}

				pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, (int)(1));
			}
			else
			{
				pKeyMerge = null;
			}

			if ((op) == (135))
			{
				regPrev = (int)(0);
			}
			else
			{
				int nExpr = (int)(p.pEList.nExpr);

				regPrev = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nExpr + 1);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regPrev));
				pKeyDup = sqlite3KeyInfoAlloc(db, (int)(nExpr), (int)(1));
				if ((pKeyDup) != null)
				{

					for (i = (int)(0); (i) < (nExpr); i++)
					{
						pKeyDup.aColl[i] = multiSelectCollSeq(pParse, p, (int)(i));
						pKeyDup.aSortFlags[i] = (byte)(0);
					}
				}
			}

			nSelect = (int)(1);
			if ((((op) == (135)) || ((op) == (134))) && (((db).dbOptFlags & (0x00200000)) == (0)))
			{
				for (pSplit = p; (pSplit.pPrior != null) && ((pSplit.op) == (op)); pSplit = pSplit.pPrior)
				{
					nSelect++;

				}
			}

			if ((nSelect) <= (3))
			{
				pSplit = p;
			}
			else
			{
				pSplit = p;
				for (i = (int)(2); (i) < (nSelect); i += (int)(2))
				{
					pSplit = pSplit.pPrior;
				}
			}

			pPrior = pSplit.pPrior;

			pSplit.pPrior = null;
			pPrior.pNext = null;


			pPrior.pOrderBy = sqlite3ExprListDup(pParse.db, pOrderBy, (int)(0));
			sqlite3ResolveOrderGroupBy(pParse, p, p.pOrderBy, "ORDER");
			sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior.pOrderBy, "ORDER");
			computeLimitRegisters(pParse, p, (int)(labelEnd));
			if (((p.iLimit) != 0) && ((op) == (135)))
			{
				regLimitA = (int)(++pParse.nMem);
				regLimitB = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(79), (int)((p.iOffset) != 0 ? p.iOffset + 1 : p.iLimit), (int)(regLimitA));
				sqlite3VdbeAddOp2(v, (int)(79), (int)(regLimitA), (int)(regLimitB));
			}
			else
			{
				regLimitA = (int)(regLimitB = (int)(0));
			}

			sqlite3ExprDelete(db, p.pLimit);
			p.pLimit = null;
			regAddrA = (int)(++pParse.nMem);
			regAddrB = (int)(++pParse.nMem);
			regOutA = (int)(++pParse.nMem);
			regOutB = (int)(++pParse.nMem);
			sqlite3SelectDestInit(destA, (int)(13), (int)(regAddrA));
			sqlite3SelectDestInit(destB, (int)(13), (int)(regAddrB));
			sqlite3VdbeExplain(pParse, (byte)(1), "MERGE (%s)", sqlite3SelectOpName((int)(p.op)));
			addrSelectA = (int)(sqlite3VdbeCurrentAddr(v) + 1);
			addr1 = (int)(sqlite3VdbeAddOp3(v, (int)(13), (int)(regAddrA), (int)(0), (int)(addrSelectA)));
			pPrior.iLimit = (int)(regLimitA);
			sqlite3VdbeExplain(pParse, (byte)(1), "LEFT");
			sqlite3Select(pParse, pPrior, destA);
			sqlite3VdbeEndCoroutine(v, (int)(regAddrA));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			addrSelectB = (int)(sqlite3VdbeCurrentAddr(v) + 1);
			addr1 = (int)(sqlite3VdbeAddOp3(v, (int)(13), (int)(regAddrB), (int)(0), (int)(addrSelectB)));
			savedLimit = (int)(p.iLimit);
			savedOffset = (int)(p.iOffset);
			p.iLimit = (int)(regLimitB);
			p.iOffset = (int)(0);
			sqlite3VdbeExplain(pParse, (byte)(1), "RIGHT");
			sqlite3Select(pParse, p, destB);
			p.iLimit = (int)(savedLimit);
			p.iOffset = (int)(savedOffset);
			sqlite3VdbeEndCoroutine(v, (int)(regAddrB));
			addrOutA = (int)(generateOutputSubroutine(pParse, p, destA, pDest, (int)(regOutA), (int)(regPrev), pKeyDup, (int)(labelEnd)));
			if (((op) == (135)) || ((op) == (134)))
			{
				addrOutB = (int)(generateOutputSubroutine(pParse, p, destB, pDest, (int)(regOutB), (int)(regPrev), pKeyDup, (int)(labelEnd)));
			}

			sqlite3KeyInfoUnref(pKeyDup);
			if (((op) == (136)) || ((op) == (137)))
			{
				addrEofA_noB = (int)(addrEofA = (int)(labelEnd));
			}
			else
			{
				addrEofA = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutB), (int)(addrOutB)));
				addrEofA_noB = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(labelEnd)));
				sqlite3VdbeGoto(v, (int)(addrEofA));
				p.nSelectRow = (short)(sqlite3LogEstAdd((short)(p.nSelectRow), (short)(pPrior.nSelectRow)));
			}

			if ((op) == (137))
			{
				addrEofB = (int)(addrEofA);
				if ((p.nSelectRow) > (pPrior.nSelectRow))
					p.nSelectRow = (short)(pPrior.nSelectRow);
			}
			else
			{
				addrEofB = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutA), (int)(addrOutA)));
				sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(labelEnd));
				sqlite3VdbeGoto(v, (int)(addrEofB));
			}

			addrAltB = (int)(sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutA), (int)(addrOutA)));
			sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA));
			sqlite3VdbeGoto(v, (int)(labelCmpr));
			if ((op) == (135))
			{
				addrAeqB = (int)(addrAltB);
			}
			else if ((op) == (137))
			{
				addrAeqB = (int)(addrAltB);
				addrAltB++;
			}
			else
			{
				addrAeqB = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA)));
				sqlite3VdbeGoto(v, (int)(labelCmpr));
			}

			addrAgtB = (int)(sqlite3VdbeCurrentAddr(v));
			if (((op) == (135)) || ((op) == (134)))
			{
				sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutB), (int)(addrOutB));
			}

			sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(addrEofB));
			sqlite3VdbeGoto(v, (int)(labelCmpr));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrA), (int)(addrEofA_noB));
			sqlite3VdbeAddOp2(v, (int)(14), (int)(regAddrB), (int)(addrEofB));
			sqlite3VdbeResolveLabel(v, (int)(labelCmpr));
			sqlite3VdbeAddOp4(v, (int)(88), (int)(0), (int)(0), (int)(0), (sbyte*)(aPermute), (int)(-15));
			sqlite3VdbeAddOp4(v, (int)(89), (int)(destA.iSdst), (int)(destB.iSdst), (int)(nOrderBy), (sbyte*)(pKeyMerge), (int)(-9));
			sqlite3VdbeChangeP5(v, (ushort)(0x01));
			sqlite3VdbeAddOp3(v, (int)(16), (int)(addrAltB), (int)(addrAeqB), (int)(addrAgtB));
			sqlite3VdbeResolveLabel(v, (int)(labelEnd));
			if ((pSplit.pPrior) != null)
			{
				sqlite3SelectDelete(db, pSplit.pPrior);
			}

			pSplit.pPrior = pPrior;
			pPrior.pNext = pSplit;
			sqlite3ExprListDelete(db, pPrior.pOrderBy);
			pPrior.pOrderBy = null;
			sqlite3VdbeExplainPop(pParse);
			return (int)(pParse.nErr != 0);
		}
		public static KeyInfo multiSelectOrderByKeyInfo(Parse pParse, Select p, int nExtra)
		{
			ExprList pOrderBy = p.pOrderBy;
			int nOrderBy = (int)((pOrderBy != null) ? pOrderBy.nExpr : 0);
			sqlite3 db = pParse.db;
			KeyInfo pRet = sqlite3KeyInfoAlloc(db, (int)(nOrderBy + nExtra), (int)(1));
			if ((pRet) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (nOrderBy); i++)
				{
					ExprList_item* pItem = &pOrderBy.a[i];
					Expr pTerm = pItem->pExpr;
					CollSeq pColl;
					if ((pTerm.flags & 0x000100) != 0)
					{
						pColl = sqlite3ExprCollSeq(pParse, pTerm);
					}
					else
					{
						pColl = multiSelectCollSeq(pParse, p, (int)(pItem->u.x.iOrderByCol - 1));
						if ((pColl) == (null))
							pColl = db.pDfltColl;
						pOrderBy.a[i].pExpr = sqlite3ExprAddCollateString(pParse, pTerm, pColl.zName);
					}


					pRet.aColl[i] = pColl;
					pRet.aSortFlags[i] = (byte)(pOrderBy.a[i].sortFlags);
				}
			}

			return pRet;
		}
		public static int multiSelectValues(Parse pParse, Select p, SelectDest pDest)
		{
			int nRow = (int)(1);
			int rc = (int)(0);
			int bShowAll = (int)((p.pLimit) == (null) ? 1 : 0);

			do
			{



				if ((p.pWin) != null)
					return (int)(-1);
				if ((p.pPrior) == (null))
					break;

				p = p.pPrior;
				nRow += (int)(bShowAll);
			}
			while ((1) != 0);
			sqlite3VdbeExplain(pParse, (byte)(0), "SCAN %d CONSTANT ROW%s", (int)(nRow), (nRow) == (1) ? "" : "S");
			while ((p) != null)
			{
				selectInnerLoop(pParse, p, (int)(-1), null, null, pDest, (int)(1), (int)(1));
				if (bShowAll == 0)
					break;
				p.nSelectRow = (short)(nRow);
				p = p.pNext;
			}

			return (int)(rc);
		}
		public static int nameInUsingClause(IdList* pUsing, sbyte* zCol)
		{
			if ((pUsing) != null)
			{
				int k = 0;
				for (k = (int)(0); (k) < (pUsing->nId); k++)
				{
					if ((sqlite3StrICmp(pUsing->a[k].zName, zCol)) == (0))
						return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int newDatabase(BtShared pBt)
		{
			MemPage pP1;
			byte* data;
			int rc = 0;

			if ((pBt.nPage) > (0))
			{
				return (int)(0);
			}

			pP1 = pBt.pPage1;

			data = pP1.aData;
			rc = (int)(sqlite3PagerWrite(pP1.pDbPage));
			if ((rc) != 0)
				return (int)(rc);
			CRuntime.memcpy(data, zMagicHeader, (ulong)(16 * sizeof(sbyte)));

			data[16] = ((byte)((pBt.pageSize >> 8) & 0xff));
			data[17] = ((byte)((pBt.pageSize >> 16) & 0xff));
			data[18] = (byte)(1);
			data[19] = (byte)(1);

			data[20] = ((byte)(pBt.pageSize - pBt.usableSize));
			data[21] = (byte)(64);
			data[22] = (byte)(32);
			data[23] = (byte)(32);
			CRuntime.memset(&data[24], (int)(0), (ulong)(100 - 24));
			zeroPage(pP1, (int)(0x01 | 0x08 | 0x04));
			pBt.btsFlags |= (ushort)(0x0002);


			sqlite3Put4byte(&data[36 + 4 * 4], (uint)(pBt.autoVacuum));
			sqlite3Put4byte(&data[36 + 7 * 4], (uint)(pBt.incrVacuum));
			pBt.nPage = (uint)(1);
			data[31] = (byte)(1);
			return (int)(0);
		}
		public static int nocaseCollatingFunc(void* NotUsed, int nKey1, void* pKey1, int nKey2, void* pKey2)
		{
			int r = (int)(sqlite3_strnicmp((sbyte*)(pKey1), (sbyte*)(pKey2), (int)(((nKey1) < (nKey2)) ? nKey1 : nKey2)));
			(void)(NotUsed);
			if ((0) == (r))
			{
				r = (int)(nKey1 - nKey2);
			}

			return (int)(r);
		}
		public static sqlite3_mutex* noopMutexAlloc(int id)
		{
			(void)(id);
			return (sqlite3_mutex*)(8);
		}
		public static int noopMutexEnd()
		{
			return (int)(0);
		}
		public static void noopMutexEnter(sqlite3_mutex* p)
		{
			(void)(p);
			return;
		}
		public static void noopMutexFree(sqlite3_mutex* p)
		{
			(void)(p);
			return;
		}
		public static int noopMutexInit()
		{
			return (int)(0);
		}
		public static void noopMutexLeave(sqlite3_mutex* p)
		{
			(void)(p);
			return;
		}
		public static int noopMutexTry(sqlite3_mutex* p)
		{
			(void)(p);
			return (int)(0);
		}
		public static void noopStepFunc(sqlite3_context p, int n, sqlite3_value a)
		{
			(void)(p);
			(void)(n);
			(void)(a);

		}
		public static void noopValueFunc(sqlite3_context p)
		{
			(void)(p);
		}
		public static void notValidImpl(Parse pParse, NameContext pNC, sbyte* zMsg, Expr pExpr, Expr pError)
		{
			sbyte* zIn = "partial index WHERE clauses";
			if ((pNC.ncFlags & 0x000020) != 0)
				zIn = "index expressions";
			else if ((pNC.ncFlags & 0x000004) != 0)
				zIn = "CHECK constraints";
			else if ((pNC.ncFlags & 0x000008) != 0)
				zIn = "generated columns";
			sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
			if ((pExpr) != null)
				pExpr.op = (byte)(121);
			sqlite3RecordErrorOffsetOfExpr(pParse.db, pError);
		}
		public static void nth_valueFinalizeFunc(sqlite3_context pCtx)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(0)));
			if (((p) != null) && ((p.pValue) != null))
			{
				sqlite3_result_value(pCtx, p.pValue);
				sqlite3_value_free(p.pValue);
				p.pValue = null;
			}
		}
		public static void nth_valueStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NthValueCtx p;
			p = (NthValueCtx)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NthValueCtx))));
			if ((p) != null)
			{
				long iVal = 0;
				switch (sqlite3_value_numeric_type(apArg[1]))
				{
					case 1:
						iVal = (long)(sqlite3_value_int64(apArg[1]));
						break;
					case 2:
						{
							double fVal = (double)(sqlite3_value_double(apArg[1]));
							if (((long)(fVal)) != fVal)
								goto error_out;
							iVal = ((long)(fVal));
							break;
						}

					default:
						goto error_out;
				}

				if ((iVal) <= (0))
					goto error_out;
				p.nStep++;
				if ((iVal) == (p.nStep))
				{
					p.pValue = sqlite3_value_dup(apArg[0]);
					if (p.pValue == null)
					{
						sqlite3_result_error_nomem(pCtx);
					}
				}
			}

			(void)(nArg);
			(void)(apArg);
			return;
		error_out:
			; sqlite3_result_error(pCtx, "second argument to nth_value must be a positive integer", (int)(-1));
		}
		public static void ntileInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NtileCtx* p;

			(void)(nArg);
			(void)(apArg);
			p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
			p->iRow++;
		}
		public static void ntileStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			NtileCtx* p;

			(void)(nArg);
			p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
			if ((p) != null)
			{
				if ((p->nTotal) == (0))
				{
					p->nParam = (long)(sqlite3_value_int64(apArg[0]));
					if ((p->nParam) <= (0))
					{
						sqlite3_result_error(pCtx, "argument of ntile must be a positive integer", (int)(-1));
					}
				}

				p->nTotal++;
			}
		}
		public static void ntileValueFunc(sqlite3_context pCtx)
		{
			NtileCtx* p;
			p = (NtileCtx*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(NtileCtx))));
			if (((p) != null) && ((p->nParam) > (0)))
			{
				int nSize = (int)(p->nTotal / p->nParam);
				if ((nSize) == (0))
				{
					sqlite3_result_int64(pCtx, (long)(p->iRow + 1));
				}
				else
				{
					long nLarge = (long)(p->nTotal - p->nParam * nSize);
					long iSmall = (long)(nLarge * (nSize + 1));
					long iRow = (long)(p->iRow);

					if ((iRow) < (iSmall))
					{
						sqlite3_result_int64(pCtx, (long)(1 + iRow / (nSize + 1)));
					}
					else
					{
						sqlite3_result_int64(pCtx, (long)(1 + nLarge + (iRow - iSmall) / nSize));
					}
				}
			}
		}
		public static void nullifFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			CollSeq pColl = sqlite3GetFuncCollSeq(context);
			(void)(NotUsed);
			if (sqlite3MemCompare(argv[0], argv[1], pColl) != 0)
			{
				sqlite3_result_value(context, argv[0]);
			}
		}
		public static int numberOfCachePages(PCache p)
		{
			if ((p.szCache) >= (0))
			{
				return (int)(p.szCache);
			}
			else
			{
				long n = 0;
				n = (long)((-1024 * (long)(p.szCache)) / (p.szPage + p.szExtra));
				if ((n) > (1000000000))
					n = (long)(1000000000);
				return (int)(n);
			}
		}
		public static ushort numericType(sqlite3_value pMem)
		{
			if ((pMem.flags & (0x0004 | 0x0008 | 0x0020)) != 0)
			{
				return (ushort)(pMem.flags & (0x0004 | 0x0008 | 0x0020));
			}

			if ((pMem.flags & (0x0002 | 0x0010)) != 0)
			{
				return (ushort)(computeNumericType(pMem));
			}

			return (ushort)(0);
		}
		public static int openDatabase(sbyte* zFilename, sqlite3 ppDb, uint flags, sbyte* zVfs)
		{
			sqlite3 db;
			int rc = 0;
			int isThreadsafe = 0;
			sbyte* zOpen = null;
			sbyte* zErrMsg = null;
			int i = 0;
			ppDb = null;
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			if ((sqlite3Config.bCoreMutex) == (0))
			{
				isThreadsafe = (int)(0);
			}
			else if ((flags & 0x00008000) != 0)
			{
				isThreadsafe = (int)(0);
			}
			else if ((flags & 0x00010000) != 0)
			{
				isThreadsafe = (int)(1);
			}
			else
			{
				isThreadsafe = (int)(sqlite3Config.bFullMutex);
			}

			if ((flags & 0x00040000) != 0)
			{
				flags &= (uint)(~0x00020000);
			}
			else if ((sqlite3Config.sharedCacheEnabled) != 0)
			{
				flags |= (uint)(0x00020000);
			}

			flags &= (uint)(~(0x00000008 | 0x00000010 | 0x00000100 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00001000 | 0x00002000 | 0x00004000 | 0x00008000 | 0x00010000 | 0x00080000));
			db = sqlite3MallocZero((ulong)(sizeof(sqlite3)));
			if ((db) == (null))
				goto opendb_out;
			if ((isThreadsafe) != 0)
			{
				db.mutex = sqlite3MutexAlloc((int)(1));
				if ((db.mutex) == (null))
				{
					sqlite3_free(db);
					db = null;
					goto opendb_out;
				}

				if ((isThreadsafe) == (0))
				{
				}
			}

			sqlite3_mutex_enter(db.mutex);
			db.errMask = (int)((flags & 0x02000000) != 0 ? 0xffffffff : 0xff);
			db.nDb = (int)(2);
			db.eOpenState = (byte)(0x6d);
			db.aDb = db.aDbStatic;
			db.lookaside.bDisable = (uint)(1);
			db.lookaside.sz = (ushort)(0);

			CRuntime.memcpy(db.aLimit, aHardLimit, (ulong)(12 * sizeof(int)));
			db.aLimit[11] = (int)(0);
			db.autoCommit = (byte)(1);
			db.nextAutovac = (sbyte)(-1);
			db.szMmap = (long)(sqlite3Config.szMmap);
			db.nextPagesize = (int)(0);
			db.init.azInit = sqlite3StdType;
			db.flags |= (ulong)(0x00000040 | 0x00040000 | 0x80000000 | 0x00000020 | 0x00000080 | 0x40000000 | 0x20000000 | 0x00008000);
			sqlite3HashInit(&db.aCollSeq);
			sqlite3HashInit(&db.aModule);
			createCollation(db, sqlite3StrBINARY, (byte)(1), null, binCollFunc, null);
			createCollation(db, sqlite3StrBINARY, (byte)(3), null, binCollFunc, null);
			createCollation(db, sqlite3StrBINARY, (byte)(2), null, binCollFunc, null);
			createCollation(db, "NOCASE", (byte)(1), null, nocaseCollatingFunc, null);
			createCollation(db, "RTRIM", (byte)(1), null, rtrimCollFunc, null);
			if ((db.mallocFailed) != 0)
			{
				goto opendb_out;
			}

			db.openFlags = (uint)(flags);



			if (((1 << (flags & 7)) & 0x46) == (0))
			{
				rc = (int)(sqlite3MisuseError((int)(171845)));
			}
			else
			{
				rc = (int)(sqlite3ParseUri(zVfs, zFilename, &flags, db.pVfs, &zOpen, &zErrMsg));
			}

			if (rc != 0)
			{
				if ((rc) == (7))
					sqlite3OomFault(db);
				sqlite3ErrorWithMsg(db, (int)(rc), (zErrMsg) != 0 ? "%s" : null, zErrMsg);
				sqlite3_free(zErrMsg);
				goto opendb_out;
			}

			rc = (int)(sqlite3BtreeOpen(db.pVfs, zOpen, db, db.aDb[0].pBt, (int)(0), (int)(flags | 0x00000100)));
			if (rc != 0)
			{
				if ((rc) == (10 | (12 << 8)))
				{
					rc = (int)(7);
				}

				sqlite3Error(db, (int)(rc));
				goto opendb_out;
			}

			sqlite3BtreeEnter(db.aDb[0].pBt);
			db.aDb[0].pSchema = sqlite3SchemaGet(db, db.aDb[0].pBt);
			if (db.mallocFailed == 0)
			{
				sqlite3SetTextEncoding(db, (byte)((db).aDb[0].pSchema.enc));
			}

			sqlite3BtreeLeave(db.aDb[0].pBt);
			db.aDb[1].pSchema = sqlite3SchemaGet(db, null);
			db.aDb[0].zDbSName = "main";
			db.aDb[0].safety_level = (byte)(2 + 1);
			db.aDb[1].zDbSName = "temp";
			db.aDb[1].safety_level = (byte)(0x01);
			db.eOpenState = (byte)(0x76);
			if ((db.mallocFailed) != 0)
			{
				goto opendb_out;
			}

			sqlite3Error(db, (int)(0));
			sqlite3RegisterPerConnectionBuiltinFunctions(db);
			rc = (int)(sqlite3_errcode(db));
			for (i = (int)(0); ((rc) == (0)) && ((i) < ((int)(2 * sizeof(Int(sqlite3 * )) / sizeof(Int(sqlite3 * ))))
         ) ; i++ ) { rc = (int)(sqlite3BuiltinExtensions[i](db)); }
			if ((rc) == (0))
			{
				sqlite3AutoLoadExtensions(db);
				rc = (int)(sqlite3_errcode(db));
				if (rc != 0)
				{
					goto opendb_out;
				}
			}

			if ((rc) != 0)
				sqlite3Error(db, (int)(rc));
			setupLookaside(db, null, (int)(sqlite3Config.szLookaside), (int)(sqlite3Config.nLookaside));
			sqlite3_wal_autocheckpoint(db, (int)(1000));
		opendb_out:
			; if ((db) != null) { ((void)(0)); sqlite3_mutex_leave(db.mutex); }
			rc = (int)(sqlite3_errcode(db));

			if ((rc & 0xff) == (7))
			{
				sqlite3_close(db);
				db = null;
			}
			else if (rc != 0)
			{
				db.eOpenState = (byte)(0xba);
			}

			ppDb = db;
			sqlite3_free_filename(zOpen);
			return (int)(rc);
		}
		public static int openSubJournal(Pager pPager)
		{
			int rc = (int)(0);
			if (!((pPager.sjfd).pMethods != null))
			{
				int flags = (int)(0x00002000 | 0x00000002 | 0x00000004 | 0x00000010 | 0x00000008);
				int nStmtSpill = (int)(sqlite3Config.nStmtSpill);
				if (((pPager.journalMode) == (4)) || ((pPager.subjInMemory) != 0))
				{
					nStmtSpill = (int)(-1);
				}

				rc = (int)(sqlite3JournalOpen(pPager.pVfs, null, pPager.sjfd, (int)(flags), (int)(nStmtSpill)));
			}

			return (int)(rc);
		}
		public static ushort operatorMask(int op)
		{
			ushort c = 0;

			if ((op) == (49))
			{
				c = (ushort)(0x0001);
			}
			else if ((op) == (50))
			{
				c = (ushort)(0x0100);
			}
			else if ((op) == (45))
			{
				c = (ushort)(0x0080);
			}
			else
			{

				c = ((ushort)(0x0002 << (op - 53)));
			}









			return (ushort)(c);
		}
		public static int osLocaltime(long* t, tm* pTm)
		{
			int rc = 0;
			if ((sqlite3Config.bLocaltimeFault) != 0)
			{
				if (sqlite3Config.xAltLocaltime != null)
				{
					return (int)(sqlite3Config.xAltLocaltime((void*)(t), (void*)(pTm)));
				}
				else
				{
					return (int)(1);
				}
			}

			rc = (int)(localtime_s(pTm, t));
			return (int)(rc);
		}
		public static sqlite3_value out2Prerelease(Vdbe p, VdbeOp* pOp)
		{
			sqlite3_value pOut;


			pOut = p.aMem[pOp->p2];
			if ((((pOut).flags & (0x2000 | 0x0400)) != 0))
			{
				return out2PrereleaseWithClear(pOut);
			}
			else
			{
				pOut.flags = (ushort)(0x0004);
				return pOut;
			}
		}
		public static sqlite3_value out2PrereleaseWithClear(sqlite3_value pOut)
		{
			sqlite3VdbeMemSetNull(pOut);
			pOut.flags = (ushort)(0x0004);
			return pOut;
		}
		public static byte* pageFindSlot(MemPage pPg, int nByte, int* pRc)
		{
			int hdr = (int)(pPg.hdrOffset);
			byte* aData = pPg.aData;
			int iAddr = (int)(hdr + 1);
			int pc = (int)((&aData[iAddr])[0] << 8 | (&aData[iAddr])[1]);
			int x = 0;
			int maxPC = (int)(pPg.pBt.usableSize - nByte);
			int size = 0;

			while ((pc) <= (maxPC))
			{
				size = (int)((&aData[pc + 2])[0] << 8 | (&aData[pc + 2])[1]);
				if ((x = (int)(size - nByte)) >= (0))
				{
					if ((x) < (4))
					{
						if ((aData[hdr + 7]) > (57))
							return null;
						CRuntime.memcpy(&aData[iAddr], &aData[pc], (ulong)(2));
						aData[hdr + 7] += ((byte)(x));
					}
					else if ((x + pc) > (maxPC))
					{
						*pRc = (int)(sqlite3CorruptError((int)(67769)));
						return null;
					}
					else
					{
						((&aData[pc + 2])[0] = ((byte)((x) >> 8)), (&aData[pc + 2])[1] = ((byte)(x)));
					}

					return &aData[pc + x];
				}

				iAddr = (int)(pc);
				pc = (int)((&aData[pc])[0] << 8 | (&aData[pc])[1]);
				if ((pc) <= (iAddr + size))
				{
					if ((pc) != 0)
					{
						*pRc = (int)(sqlite3CorruptError((int)(67783)));
					}

					return null;
				}
			}

			if ((pc) > (maxPC + nByte - 4))
			{
				*pRc = (int)(sqlite3CorruptError((int)(67790)));
			}

			return null;
		}
		public static int pageFreeArray(MemPage pPg, int iFirst, int nCell, CellArray pCArray)
		{
			byte* aData = pPg.aData;
			byte* pEnd = &aData[pPg.pBt.usableSize];
			byte* pStart = &aData[pPg.hdrOffset + 8 + pPg.childPtrSize];
			int nRet = (int)(0);
			int i = 0;
			int iEnd = (int)(iFirst + nCell);
			byte* pFree = null;
			int szFree = (int)(0);
			for (i = (int)(iFirst); (i) < (iEnd); i++)
			{
				byte* pCell = pCArray.apCell[i];
				if (((((ulong)(pCell)) >= ((ulong)(pStart))) && (((ulong)(pCell)) < ((ulong)(pEnd)))))
				{
					int sz = 0;
					sz = (int)(pCArray.szCell[i]);

					if (pFree != (pCell + sz))
					{
						if ((pFree) != null)
						{

							freeSpace(pPg, (ushort)(pFree - aData), (ushort)(szFree));
						}

						pFree = pCell;
						szFree = (int)(sz);
						if ((pFree + sz) > (pEnd))
						{
							return (int)(0);
						}
					}
					else
					{
						pFree = pCell;
						szFree += (int)(sz);
					}

					nRet++;
				}
			}

			if ((pFree) != null)
			{

				freeSpace(pPg, (ushort)(pFree - aData), (ushort)(szFree));
			}

			return (int)(nRet);
		}
		public static int pageInsertArray(MemPage pPg, byte* pBegin, byte** ppData, byte* pCellptr, int iFirst, int nCell, CellArray pCArray)
		{
			int i = (int)(iFirst);
			byte* aData = pPg.aData;
			byte* pData = *ppData;
			int iEnd = (int)(iFirst + nCell);
			int k = 0;
			byte* pEnd;

			if ((iEnd) <= (iFirst))
				return (int)(0);
			for (k = (int)(0); ((pCArray.ixNx[k]) <= (i)) && ((k) < (3 * 2)); k++)
			{
			}

			pEnd = pCArray.apEnd[k];
			while ((1) != 0)
			{
				int sz = 0;
				int rc = 0;
				byte* pSlot;

				sz = (int)(pCArray.szCell[i]);
				if ((((aData[1]) == (0)) && ((aData[2]) == (0))) || ((pSlot = pageFindSlot(pPg, (int)(sz), &rc)) == (null)))
				{
					if ((pData - pBegin) < (sz))
						return (int)(1);
					pData -= sz;
					pSlot = pData;
				}


				if ((((ulong)(pCArray.apCell[i] + sz)) > ((ulong)(pEnd))) && (((ulong)(pCArray.apCell[i])) < ((ulong)(pEnd))))
				{

					(void)(sqlite3CorruptError((int)(73410)));
					return (int)(1);
				}

				CRuntime.memmove(pSlot, pCArray.apCell[i], (ulong)(sz));
				((pCellptr)[0] = ((byte)((pSlot - aData) >> 8)), (pCellptr)[1] = ((byte)(pSlot - aData)));
				pCellptr += 2;
				i++;
				if ((i) >= (iEnd))
					break;
				if ((pCArray.ixNx[k]) <= (i))
				{
					k++;
					pEnd = pCArray.apEnd[k];
				}
			}

			*ppData = pData;
			return (int)(0);
		}
		public static uint pager_cksum(Pager pPager, byte* aData)
		{
			uint cksum = (uint)(pPager.cksumInit);
			int i = (int)(pPager.pageSize - 200);
			while ((i) > (0))
			{
				cksum += (uint)(aData[i]);
				i -= (int)(200);
			}

			return (uint)(cksum);
		}
		public static int pager_delsuper(Pager pPager, sbyte* zSuper)
		{
			sqlite3_vfs pVfs = pPager.pVfs;
			int rc = 0;
			sqlite3_file pSuper;
			sqlite3_file pJournal;
			sbyte* zSuperJournal = null;
			long nSuperJournal = 0;
			sbyte* zJournal;
			sbyte* zSuperPtr;
			sbyte* zFree = null;
			int nSuperPtr = 0;
			pSuper = (sqlite3_file)(sqlite3MallocZero((ulong)(pVfs.szOsFile * 2)));
			if (pSuper == null)
			{
				rc = (int)(7);
				pJournal = null;
			}
			else
			{
				int flags = (int)(0x00000001 | 0x00004000);
				rc = (int)(sqlite3OsOpen(pVfs, zSuper, pSuper, (int)(flags), null));
				pJournal = (sqlite3_file)(((byte*)(pSuper)) + pVfs.szOsFile);
			}

			if (rc != 0)
				goto delsuper_out;
			rc = (int)(sqlite3OsFileSize(pSuper, &nSuperJournal));
			if (rc != 0)
				goto delsuper_out;
			nSuperPtr = (int)(pVfs.mxPathname + 1);
			zFree = sqlite3Malloc((ulong)(4 + nSuperJournal + nSuperPtr + 2));
			if (zFree == null)
			{
				rc = (int)(7);
				goto delsuper_out;
			}

			zFree[0] = (sbyte)(zFree[1] = (sbyte)(zFree[2] = (sbyte)(zFree[3] = (sbyte)(0))));
			zSuperJournal = &zFree[4];
			zSuperPtr = &zSuperJournal[nSuperJournal + 2];
			rc = (int)(sqlite3OsRead(pSuper, zSuperJournal, (int)(nSuperJournal), (long)(0)));
			if (rc != 0)
				goto delsuper_out;
			zSuperJournal[nSuperJournal] = (sbyte)(0);
			zSuperJournal[nSuperJournal + 1] = (sbyte)(0);
			zJournal = zSuperJournal;
			while ((zJournal - zSuperJournal) < (nSuperJournal))
			{
				int exists = 0;
				rc = (int)(sqlite3OsAccess(pVfs, zJournal, (int)(0), &exists));
				if (rc != 0)
				{
					goto delsuper_out;
				}

				if ((exists) != 0)
				{
					int c = 0;
					int flags = (int)(0x00000001 | 0x00004000);
					rc = (int)(sqlite3OsOpen(pVfs, zJournal, pJournal, (int)(flags), null));
					if (rc != 0)
					{
						goto delsuper_out;
					}

					rc = (int)(readSuperJournal(pJournal, zSuperPtr, (uint)(nSuperPtr)));
					sqlite3OsClose(pJournal);
					if (rc != 0)
					{
						goto delsuper_out;
					}

					c = (int)((zSuperPtr[0] != 0) && ((CRuntime.strcmp(zSuperPtr, zSuper)) == (0)) ? 1 : 0);
					if ((c) != 0)
					{
						goto delsuper_out;
					}
				}

				zJournal += (sqlite3Strlen30(zJournal) + 1);
			}

			sqlite3OsClose(pSuper);
			rc = (int)(sqlite3OsDelete(pVfs, zSuper, (int)(0)));
		delsuper_out:
			; sqlite3_free(zFree);
			if ((pSuper) != null)
			{
				sqlite3OsClose(pSuper);

				sqlite3_free(pSuper);
			}

			return (int)(rc);
		}
		public static int pager_end_transaction(Pager pPager, int hasSuper, int bCommit)
		{
			int rc = (int)(0);
			int rc2 = (int)(0);


			if (((pPager.eState) < (2)) && ((pPager.eLock) < (2)))
			{
				return (int)(0);
			}

			releaseAllSavepoints(pPager);

			if (((pPager.jfd).pMethods != null))
			{

				if ((sqlite3JournalIsInMemory(pPager.jfd)) != 0)
				{
					sqlite3OsClose(pPager.jfd);
				}
				else if ((pPager.journalMode) == (3))
				{
					if ((pPager.journalOff) == (0))
					{
						rc = (int)(0);
					}
					else
					{
						rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(0)));
						if (((rc) == (0)) && ((pPager.fullSync) != 0))
						{
							rc = (int)(sqlite3OsSync(pPager.jfd, (int)(pPager.syncFlags)));
						}
					}

					pPager.journalOff = (long)(0);
				}
				else if (((pPager.journalMode) == (1)) || (((pPager.exclusiveMode) != 0) && (pPager.journalMode != 5)))
				{
					rc = (int)(zeroJournalHdr(pPager, (((hasSuper) != 0) || ((pPager.tempFile) != 0) ? 1 : 0)));
					pPager.journalOff = (long)(0);
				}
				else
				{
					int bDelete = (int)(!pPager.tempFile);


					sqlite3OsClose(pPager.jfd);
					if ((bDelete) != 0)
					{
						rc = (int)(sqlite3OsDelete(pPager.pVfs, pPager.zJournal, (int)(pPager.extraSync)));
					}
				}
			}

			sqlite3BitvecDestroy(pPager.pInJournal);
			pPager.pInJournal = null;
			pPager.nRec = (int)(0);
			if ((rc) == (0))
			{
				if (((pPager.memDb) != 0) || ((pagerFlushOnCommit(pPager, (int)(bCommit))) != 0))
				{
					sqlite3PcacheCleanAll(pPager.pPCache);
				}
				else
				{
					sqlite3PcacheClearWritable(pPager.pPCache);
				}

				sqlite3PcacheTruncate(pPager.pPCache, (uint)(pPager.dbSize));
			}

			if (((pPager).pWal != null))
			{
				rc2 = (int)(sqlite3WalEndWriteTransaction(pPager.pWal));

			}
			else if ((((rc) == (0)) && ((bCommit) != 0)) && ((pPager.dbFileSize) > (pPager.dbSize)))
			{

				rc = (int)(pager_truncate(pPager, (uint)(pPager.dbSize)));
			}

			if (((rc) == (0)) && ((bCommit) != 0))
			{
				rc = (int)(sqlite3OsFileControl(pPager.fd, (int)(22), null));
				if ((rc) == (12))
					rc = (int)(0);
			}

			if ((pPager.exclusiveMode == 0) && ((!((pPager).pWal != null)) || ((sqlite3WalExclusiveMode(pPager.pWal, (int)(0))) != 0)))
			{
				rc2 = (int)(pagerUnlockDb(pPager, (int)(1)));
			}

			pPager.eState = (byte)(1);
			pPager.setSuper = (byte)(0);
			return (int)((rc) == (0) ? rc2 : rc);
		}
		public static int pager_error(Pager pPager, int rc)
		{
			int rc2 = (int)(rc & 0xff);


			if (((rc2) == (13)) || ((rc2) == (10)))
			{
				pPager.errCode = (int)(rc);
				pPager.eState = (byte)(6);
				setGetterMethod(pPager);
			}

			return (int)(rc);
		}
		public static int pager_incr_changecounter(Pager pPager, int isDirectMode)
		{
			int rc = (int)(0);



			(void)(isDirectMode);
			if ((pPager.changeCountDone == 0) && ((pPager.dbSize) > (0)))
			{
				PgHdr pPgHdr;

				rc = (int)(sqlite3PagerGet(pPager, (uint)(1), pPgHdr, (int)(0)));

				if ((0 == 0) && ((rc) == (0)))
				{
					rc = (int)(sqlite3PagerWrite(pPgHdr));
				}

				if ((rc) == (0))
				{
					pager_write_changecounter(pPgHdr);
					if ((0) != 0)
					{
						void* zBuf;

						zBuf = pPgHdr.pData;
						if ((rc) == (0))
						{
							rc = (int)(sqlite3OsWrite(pPager.fd, zBuf, (int)(pPager.pageSize), (long)(0)));
							pPager.aStat[2]++;
						}

						if ((rc) == (0))
						{
							void* pCopy = (void*)(&((sbyte*)(zBuf))[24]);
							CRuntime.memcpy(&pPager.dbFileVers, pCopy, (ulong)(16 * sizeof(sbyte)));
							pPager.changeCountDone = (byte)(1);
						}
					}
					else
					{
						pPager.changeCountDone = (byte)(1);
					}
				}

				sqlite3PagerUnref(pPgHdr);
			}

			return (int)(rc);
		}
		public static int pager_open_journal(Pager pPager)
		{
			int rc = (int)(0);
			sqlite3_vfs pVfs = pPager.pVfs;



			if ((pPager.errCode) != 0)
				return (int)(pPager.errCode);
			if ((!((pPager).pWal != null)) && (pPager.journalMode != 2))
			{
				pPager.pInJournal = sqlite3BitvecCreate((uint)(pPager.dbSize));
				if ((pPager.pInJournal) == (null))
				{
					return (int)(7);
				}

				if (!((pPager.jfd).pMethods != null))
				{
					if ((pPager.journalMode) == (4))
					{
						sqlite3MemJournalOpen(pPager.jfd);
					}
					else
					{
						int flags = (int)(0x00000002 | 0x00000004);
						int nSpill = 0;
						if ((pPager.tempFile) != 0)
						{
							flags |= (int)(0x00000008 | 0x00001000);
							nSpill = (int)(sqlite3Config.nStmtSpill);
						}
						else
						{
							flags |= (int)(0x00000800);
							nSpill = (int)(jrnlBufferSize(pPager));
						}

						rc = (int)(databaseIsUnmoved(pPager));
						if ((rc) == (0))
						{
							rc = (int)(sqlite3JournalOpen(pVfs, pPager.zJournal, pPager.jfd, (int)(flags), (int)(nSpill)));
						}
					}


				}

				if ((rc) == (0))
				{
					pPager.nRec = (int)(0);
					pPager.journalOff = (long)(0);
					pPager.setSuper = (byte)(0);
					pPager.journalHdr = (long)(0);
					rc = (int)(writeJournalHdr(pPager));
				}
			}

			if (rc != 0)
			{
				sqlite3BitvecDestroy(pPager.pInJournal);
				pPager.pInJournal = null;
			}
			else
			{

				pPager.eState = (byte)(3);
			}

			return (int)(rc);
		}
		public static int pager_playback(Pager pPager, int isHot)
		{
			sqlite3_vfs pVfs = pPager.pVfs;
			long szJ = 0;
			uint nRec = 0;
			uint u = 0;
			uint mxPg = (uint)(0);
			int rc = 0;
			int res = (int)(1);
			sbyte* zSuper = null;
			int needPagerReset = 0;
			int nPlayback = (int)(0);
			uint savedPageSize = (uint)(pPager.pageSize);

			rc = (int)(sqlite3OsFileSize(pPager.jfd, &szJ));
			if (rc != 0)
			{
				goto end_playback;
			}

			zSuper = pPager.pTmpSpace;
			rc = (int)(readSuperJournal(pPager.jfd, zSuper, (uint)(pPager.pVfs.mxPathname + 1)));
			if (((rc) == (0)) && ((zSuper[0]) != 0))
			{
				rc = (int)(sqlite3OsAccess(pVfs, zSuper, (int)(0), &res));
			}

			zSuper = null;
			if ((rc != 0) || (res == 0))
			{
				goto end_playback;
			}

			pPager.journalOff = (long)(0);
			needPagerReset = (int)(isHot);
			while ((1) != 0)
			{
				rc = (int)(readJournalHdr(pPager, (int)(isHot), (long)(szJ), &nRec, &mxPg));
				if (rc != 0)
				{
					if ((rc) == (101))
					{
						rc = (int)(0);
					}

					goto end_playback;
				}

				if ((nRec) == (0xffffffff))
				{

					nRec = (uint)((int)((szJ - (pPager.sectorSize)) / ((pPager.pageSize) + 8)));
				}

				if ((((nRec) == (0)) && (isHot == 0)) && ((pPager.journalHdr + (pPager.sectorSize)) == (pPager.journalOff)))
				{
					nRec = (uint)((int)((szJ - pPager.journalOff) / ((pPager.pageSize) + 8)));
				}

				if ((pPager.journalOff) == (pPager.sectorSize))
				{
					rc = (int)(pager_truncate(pPager, (uint)(mxPg)));
					if (rc != 0)
					{
						goto end_playback;
					}

					pPager.dbSize = (uint)(mxPg);
					if ((pPager.mxPgno) < (mxPg))
					{
						pPager.mxPgno = (uint)(mxPg);
					}
				}

				for (u = (uint)(0); (u) < (nRec); u++)
				{
					if ((needPagerReset) != 0)
					{
						pager_reset(pPager);
						needPagerReset = (int)(0);
					}

					rc = (int)(pager_playback_one_page(pPager, &pPager.journalOff, null, (int)(1), (int)(0)));
					if ((rc) == (0))
					{
						nPlayback++;
					}
					else
					{
						if ((rc) == (101))
						{
							pPager.journalOff = (long)(szJ);
							break;
						}
						else if ((rc) == (10 | (2 << 8)))
						{
							rc = (int)(0);
							goto end_playback;
						}
						else
						{
							goto end_playback;
						}
					}
				}
			}


		end_playback:
			; if ((rc) == (0)) { rc = (int)(sqlite3PagerSetPagesize(pPager, &savedPageSize, (int)(-1))); }
			pPager.changeCountDone = (byte)(pPager.tempFile);
			if ((rc) == (0))
			{
				zSuper = &pPager.pTmpSpace[4];
				rc = (int)(readSuperJournal(pPager.jfd, zSuper, (uint)(pPager.pVfs.mxPathname + 1)));
			}

			if (((rc) == (0)) && (((pPager.eState) >= (4)) || ((pPager.eState) == (0))))
			{
				rc = (int)(sqlite3PagerSync(pPager, null));
			}

			if ((rc) == (0))
			{
				rc = (int)(pager_end_transaction(pPager, (int)(zSuper[0] != 0), (int)(0)));
			}

			if ((((rc) == (0)) && ((zSuper[0]) != 0)) && ((res) != 0))
			{

				CRuntime.memset(&zSuper[-4], (int)(0), (ulong)(4));
				rc = (int)(pager_delsuper(pPager, zSuper));
			}

			if (((isHot) != 0) && ((nPlayback) != 0))
			{
				sqlite3_log((int)(27 | (2 << 8)), "recovered %d pages from %s", (int)(nPlayback), pPager.zJournal);
			}

			setSectorSize(pPager);
			return (int)(rc);
		}
		public static int pager_playback_one_page(Pager pPager, long* pOffset, Bitvec* pDone, int isMainJrnl, int isSavepnt)
		{
			int rc = 0;
			PgHdr pPg;
			uint pgno = 0;
			uint cksum = 0;
			sbyte* aData;
			sqlite3_file jfd;
			int isSynced = 0;




			aData = pPager.pTmpSpace;




			jfd = (isMainJrnl) != 0 ? pPager.jfd : pPager.sjfd;
			rc = (int)(read32bits(jfd, (long)(*pOffset), &pgno));
			if (rc != 0)
				return (int)(rc);
			rc = (int)(sqlite3OsRead(jfd, (byte*)(aData), (int)(pPager.pageSize), (long)((*pOffset) + 4)));
			if (rc != 0)
				return (int)(rc);
			*pOffset += (long)(pPager.pageSize + 4 + isMainJrnl * 4);
			if (((pgno) == (0)) || ((pgno) == ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1))))
			{

				return (int)(101);
			}

			if (((pgno) > (pPager.dbSize)) || ((sqlite3BitvecTest(pDone, (uint)(pgno))) != 0))
			{
				return (int)(0);
			}

			if ((isMainJrnl) != 0)
			{
				rc = (int)(read32bits(jfd, (long)((*pOffset) - 4), &cksum));
				if ((rc) != 0)
					return (int)(rc);
				if ((isSavepnt == 0) && (pager_cksum(pPager, (byte*)(aData)) != cksum))
				{
					return (int)(101);
				}
			}

			if (((pDone) != null) && ((rc = (int)(sqlite3BitvecSet(pDone, (uint)(pgno)))) != 0))
			{
				return (int)(rc);
			}

			if (((pgno) == (1)) && (pPager.nReserve != ((byte*)(aData))[20]))
			{
				pPager.nReserve = (short)(((byte*)(aData))[20]);
			}

			if (((pPager).pWal != null))
			{
				pPg = null;
			}
			else
			{
				pPg = sqlite3PagerLookup(pPager, (uint)(pgno));
			}



			if ((isMainJrnl) != 0)
			{
				isSynced = (int)(((pPager.noSync) != 0) || ((*pOffset) <= (pPager.journalHdr)) ? 1 : 0);
			}
			else
			{
				isSynced = (int)(((pPg) == (null)) || ((0) == (pPg.flags & 0x008)) ? 1 : 0);
			}

			if ((((pPager.fd).pMethods != null) && (((pPager.eState) >= (4)) || ((pPager.eState) == (0)))) && ((isSynced) != 0))
			{
				long ofst = (long)((pgno - 1) * pPager.pageSize);

				rc = (int)(sqlite3OsWrite(pPager.fd, (byte*)(aData), (int)(pPager.pageSize), (long)(ofst)));
				if ((pgno) > (pPager.dbFileSize))
				{
					pPager.dbFileSize = (uint)(pgno);
				}

				if ((pPager.pBackup) != null)
				{
					sqlite3BackupUpdate(pPager.pBackup, (uint)(pgno), (byte*)(aData));
				}
			}
			else if ((isMainJrnl == 0) && ((pPg) == (null)))
			{


				pPager.doNotSpill |= (byte)(0x02);
				rc = (int)(sqlite3PagerGet(pPager, (uint)(pgno), pPg, (int)(1)));

				pPager.doNotSpill &= (byte)(~0x02);
				if (rc != 0)
					return (int)(rc);
				sqlite3PcacheMakeDirty(pPg);
			}

			if ((pPg) != null)
			{
				void* pData;
				pData = pPg.pData;
				CRuntime.memcpy(pData, (byte*)(aData), (ulong)(pPager.pageSize));
				pPager.xReiniter(pPg);
				if ((pgno) == (1))
				{
					CRuntime.memcpy(&pPager.dbFileVers, &((byte*)(pData))[24], (ulong)(16 * sizeof(sbyte)));
				}

				sqlite3PcacheRelease(pPg);
			}

			return (int)(rc);
		}
		public static void pager_reset(Pager pPager)
		{
			pPager.iDataVersion++;
			sqlite3BackupRestart(pPager.pBackup);
			sqlite3PcacheClear(pPager.pPCache);
		}
		public static int pager_truncate(Pager pPager, uint nPage)
		{
			int rc = (int)(0);


			if (((pPager.fd).pMethods != null) && (((pPager.eState) >= (4)) || ((pPager.eState) == (0))))
			{
				long currentSize = 0;
				long newSize = 0;
				int szPage = (int)(pPager.pageSize);

				rc = (int)(sqlite3OsFileSize(pPager.fd, &currentSize));
				newSize = (long)(szPage * (long)(nPage));
				if (((rc) == (0)) && (currentSize != newSize))
				{
					if ((currentSize) > (newSize))
					{
						rc = (int)(sqlite3OsTruncate(pPager.fd, (long)(newSize)));
					}
					else if ((currentSize + szPage) <= (newSize))
					{
						sbyte* pTmp = pPager.pTmpSpace;
						CRuntime.memset(pTmp, (int)(0), (ulong)(szPage));
						rc = (int)(sqlite3OsWrite(pPager.fd, pTmp, (int)(szPage), (long)(newSize - szPage)));
					}

					if ((rc) == (0))
					{
						pPager.dbFileSize = (uint)(nPage);
					}
				}
			}

			return (int)(rc);
		}
		public static void pager_unlock(Pager pPager)
		{

			sqlite3BitvecDestroy(pPager.pInJournal);
			pPager.pInJournal = null;
			releaseAllSavepoints(pPager);
			if (((pPager).pWal != null))
			{

				sqlite3WalEndReadTransaction(pPager.pWal);
				pPager.eState = (byte)(0);
			}
			else if (pPager.exclusiveMode == 0)
			{
				int rc = 0;
				int iDc = (int)(((pPager.fd).pMethods != null) ? sqlite3OsDeviceCharacteristics(pPager.fd) : 0);






				if (((0) == (iDc & 0x00000800)) || (1 != (pPager.journalMode & 5)))
				{
					sqlite3OsClose(pPager.jfd);
				}

				rc = (int)(pagerUnlockDb(pPager, (int)(0)));
				if ((rc != 0) && ((pPager.eState) == (6)))
				{
					pPager.eLock = (byte)(4 + 1);
				}


				pPager.eState = (byte)(0);
			}


			if ((pPager.errCode) != 0)
			{
				if ((pPager.tempFile) == (0))
				{
					pager_reset(pPager);
					pPager.changeCountDone = (byte)(0);
					pPager.eState = (byte)(0);
				}
				else
				{
					pPager.eState = (byte)(((pPager.jfd).pMethods != null) ? 0 : 1);
				}

				if (((pPager).bUseFetch) != 0)
					sqlite3OsUnfetch(pPager.fd, (long)(0), null);
				pPager.errCode = (int)(0);
				setGetterMethod(pPager);
			}

			pPager.journalOff = (long)(0);
			pPager.journalHdr = (long)(0);
			pPager.setSuper = (byte)(0);
		}
		public static int pager_wait_on_lock(Pager pPager, int locktype)
		{
			int rc = 0;

			do
			{
				rc = (int)(pagerLockDb(pPager, (int)(locktype)));
			}
			while (((rc) == (5)) && ((pPager.xBusyHandler(pPager.pBusyHandlerArg)) != 0));
			return (int)(rc);
		}
		public static int pager_write(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;
			int rc = (int)(0);




			if ((pPager.eState) == (2))
			{
				rc = (int)(pager_open_journal(pPager));
				if (rc != 0)
					return (int)(rc);
			}



			sqlite3PcacheMakeDirty(pPg);

			if ((pPager.pInJournal != null) && ((sqlite3BitvecTestNotNull(pPager.pInJournal, (uint)(pPg.pgno))) == (0)))
			{

				if ((pPg.pgno) <= (pPager.dbOrigSize))
				{
					rc = (int)(pagerAddPageToRollbackJournal(pPg));
					if (rc != 0)
					{
						return (int)(rc);
					}
				}
				else
				{
					if (pPager.eState != 4)
					{
						pPg.flags |= (ushort)(0x008);
					}
				}
			}

			pPg.flags |= (ushort)(0x004);
			if ((pPager.nSavepoint) > (0))
			{
				rc = (int)(subjournalPageIfRequired(pPg));
			}

			if ((pPager.dbSize) < (pPg.pgno))
			{
				pPager.dbSize = (uint)(pPg.pgno);
			}

			return (int)(rc);
		}
		public static void pager_write_changecounter(PgHdr pPg)
		{
			uint change_counter = 0;
			if (((pPg) == (null)))
				return;
			change_counter = (uint)(sqlite3Get4byte((byte*)(pPg.pPager.dbFileVers)) + 1);
			sqlite3Put4byte((byte*)((sbyte*)(pPg.pData)) + 24, (uint)(change_counter));
			sqlite3Put4byte((byte*)((sbyte*)(pPg.pData)) + 92, (uint)(change_counter));
			sqlite3Put4byte((byte*)((sbyte*)(pPg.pData)) + 96, (uint)(3038002));
		}
		public static int pager_write_pagelist(Pager pPager, PgHdr pList)
		{
			int rc = (int)(0);




			if (!((pPager.fd).pMethods != null))
			{

				rc = (int)(pagerOpentemp(pPager, pPager.fd, (int)(pPager.vfsFlags)));
			}


			if ((((rc) == (0)) && ((pPager.dbHintSize) < (pPager.dbSize))) && (((pList.pDirty) != null) || ((pList.pgno) > (pPager.dbHintSize))))
			{
				long szFile = (long)(pPager.pageSize * (long)(pPager.dbSize));
				sqlite3OsFileControlHint(pPager.fd, (int)(5), &szFile);
				pPager.dbHintSize = (uint)(pPager.dbSize);
			}

			while (((rc) == (0)) && ((pList) != null))
			{
				uint pgno = (uint)(pList.pgno);
				if (((pgno) <= (pPager.dbSize)) && ((0) == (pList.flags & 0x010)))
				{
					long offset = (long)((pgno - 1) * pPager.pageSize);
					sbyte* pData;

					if ((pList.pgno) == (1))
						pager_write_changecounter(pList);
					pData = pList.pData;
					rc = (int)(sqlite3OsWrite(pPager.fd, pData, (int)(pPager.pageSize), (long)(offset)));
					if ((pgno) == (1))
					{
						CRuntime.memcpy(&pPager.dbFileVers, &pData[24], (ulong)(16 * sizeof(sbyte)));
					}

					if ((pgno) > (pPager.dbFileSize))
					{
						pPager.dbFileSize = (uint)(pgno);
					}

					pPager.aStat[2]++;
					sqlite3BackupUpdate(pPager.pBackup, (uint)(pgno), (byte*)(pList.pData));
				}
				else
				{
				}

				pList = pList.pDirty;
			}

			return (int)(rc);
		}
		public static int pagerAcquireMapPage(Pager pPager, uint pgno, void* pData, PgHdr ppPage)
		{
			PgHdr p;
			if ((pPager.pMmapFreelist) != null)
			{
				ppPage = p = pPager.pMmapFreelist;
				pPager.pMmapFreelist = p.pDirty;
				p.pDirty = null;

				CRuntime.memset(p.pExtra, (int)(0), (ulong)(8));
			}
			else
			{
				ppPage = p = (PgHdr)(sqlite3MallocZero((ulong)(sizeof(PgHdr) + pPager.nExtra)));
				if ((p) == (null))
				{
					sqlite3OsUnfetch(pPager.fd, (long)((long)(pgno - 1) * pPager.pageSize), pData);
					return (int)(7);
				}

				p.pExtra = (void*)(p[1]);
				p.flags = (ushort)(0x020);
				p.nRef = (short)(1);
				p.pPager = pPager;
			}






			p.pgno = (uint)(pgno);
			p.pData = pData;
			pPager.nMmapOut++;
			return (int)(0);
		}
		public static int pagerAddPageToRollbackJournal(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;
			int rc = 0;
			uint cksum = 0;
			sbyte* pData2;
			long iOff = (long)(pPager.journalOff);


			pData2 = pPg.pData;
			cksum = (uint)(pager_cksum(pPager, (byte*)(pData2)));
			pPg.flags |= (ushort)(0x008);
			rc = (int)(write32bits(pPager.jfd, (long)(iOff), (uint)(pPg.pgno)));
			if (rc != 0)
				return (int)(rc);
			rc = (int)(sqlite3OsWrite(pPager.jfd, pData2, (int)(pPager.pageSize), (long)(iOff + 4)));
			if (rc != 0)
				return (int)(rc);
			rc = (int)(write32bits(pPager.jfd, (long)(iOff + pPager.pageSize + 4), (uint)(cksum)));
			if (rc != 0)
				return (int)(rc);
			pPager.journalOff += (long)(8 + pPager.pageSize);
			pPager.nRec++;

			rc = (int)(sqlite3BitvecSet(pPager.pInJournal, (uint)(pPg.pgno)));

			rc |= (int)(addToSavepointBitvecs(pPager, (uint)(pPg.pgno)));

			return (int)(rc);
		}
		public static int pagerBeginReadTransaction(Pager pPager)
		{
			int rc = 0;
			int changed = (int)(0);


			sqlite3WalEndReadTransaction(pPager.pWal);
			rc = (int)(sqlite3WalBeginReadTransaction(pPager.pWal, &changed));
			if ((rc != 0) || ((changed) != 0))
			{
				pager_reset(pPager);
				if (((pPager).bUseFetch) != 0)
					sqlite3OsUnfetch(pPager.fd, (long)(0), null);
			}

			return (int)(rc);
		}
		public static void pageReinit(PgHdr pData)
		{
			MemPage pPage;
			pPage = (MemPage)(sqlite3PagerGetExtra(pData));

			if ((pPage.isInit) != 0)
			{

				pPage.isInit = (byte)(0);
				if ((sqlite3PagerPageRefcount(pData)) > (1))
				{
					btreeInitPage(pPage);
				}
			}
		}
		public static int pagerExclusiveLock(Pager pPager)
		{
			int rc = 0;

			rc = (int)(pagerLockDb(pPager, (int)(4)));
			if (rc != 0)
			{
				pagerUnlockDb(pPager, (int)(1));
			}

			return (int)(rc);
		}
		public static void pagerFixMaplimit(Pager pPager)
		{
			sqlite3_file fd = pPager.fd;
			if (((fd).pMethods != null) && ((fd.pMethods.iVersion) >= (3)))
			{
				long sz = 0;
				sz = (long)(pPager.szMmap);
				pPager.bUseFetch = (byte)((sz) > (0));
				setGetterMethod(pPager);
				sqlite3OsFileControlHint(pPager.fd, (int)(18), &sz);
			}
		}
		public static int pagerFlushOnCommit(Pager pPager, int bCommit)
		{
			if ((pPager.tempFile) == (0))
				return (int)(1);
			if (bCommit == 0)
				return (int)(0);
			if (!((pPager.fd).pMethods != null))
				return (int)(0);
			return (((sqlite3PCachePercentDirty(pPager.pPCache)) >= (25)) ? 1 : 0);
		}
		public static void pagerFreeMapHdrs(Pager pPager)
		{
			PgHdr p;
			PgHdr pNext;
			for (p = pPager.pMmapFreelist; p; p = pNext)
			{
				pNext = p.pDirty;
				sqlite3_free(p);
			}
		}
		public static int pagerLockDb(Pager pPager, int eLock)
		{
			int rc = (int)(0);

			if (((pPager.eLock) < (eLock)) || ((pPager.eLock) == (4 + 1)))
			{
				rc = (int)((pPager.noLock) != 0 ? 0 : sqlite3OsLock(pPager.fd, (int)(eLock)));
				if (((rc) == (0)) && ((pPager.eLock != (4 + 1)) || ((eLock) == (4))))
				{
					pPager.eLock = ((byte)(eLock));
				}
			}

			return (int)(rc);
		}
		public static int pagerOpenSavepoint(Pager pPager, int nSavepoint)
		{
			int rc = (int)(0);
			int nCurrent = (int)(pPager.nSavepoint);
			int ii = 0;
			PagerSavepoint* aNew;



			aNew = (PagerSavepoint*)(sqlite3Realloc(pPager.aSavepoint, (ulong)(sizeof(PagerSavepoint) * nSavepoint)));
			if (aNew == null)
			{
				return (int)(7);
			}

			CRuntime.memset(&aNew[nCurrent], (int)(0), (ulong)((nSavepoint - nCurrent) * sizeof(PagerSavepoint)));
			pPager.aSavepoint = aNew;
			for (ii = (int)(nCurrent); (ii) < (nSavepoint); ii++)
			{
				aNew[ii].nOrig = (uint)(pPager.dbSize);
				if (((pPager.jfd).pMethods != null) && ((pPager.journalOff) > (0)))
				{
					aNew[ii].iOffset = (long)(pPager.journalOff);
				}
				else
				{
					aNew[ii].iOffset = (long)(pPager.sectorSize);
				}

				aNew[ii].iSubRec = (uint)(pPager.nSubRec);
				aNew[ii].pInSavepoint = sqlite3BitvecCreate((uint)(pPager.dbSize));
				aNew[ii].bTruncateOnRelease = (int)(1);
				if (aNew[ii].pInSavepoint == null)
				{
					return (int)(7);
				}

				if (((pPager).pWal != null))
				{
					sqlite3WalSavepoint(pPager.pWal, aNew[ii].aWalData);
				}

				pPager.nSavepoint = (int)(ii + 1);
			}


			return (int)(rc);
		}
		public static int pagerOpentemp(Pager pPager, sqlite3_file pFile, int vfsFlags)
		{
			int rc = 0;
			vfsFlags |= (int)(0x00000002 | 0x00000004 | 0x00000010 | 0x00000008);
			rc = (int)(sqlite3OsOpen(pPager.pVfs, null, pFile, (int)(vfsFlags), null));

			return (int)(rc);
		}
		public static int pagerOpenWal(Pager pPager)
		{
			int rc = (int)(0);


			if ((pPager.exclusiveMode) != 0)
			{
				rc = (int)(pagerExclusiveLock(pPager));
			}

			if ((rc) == (0))
			{
				rc = (int)(sqlite3WalOpen(pPager.pVfs, pPager.fd, pPager.zWal, (int)(pPager.exclusiveMode), (long)(pPager.journalSizeLimit), pPager.pWal));
			}

			pagerFixMaplimit(pPager);
			return (int)(rc);
		}
		public static int pagerOpenWalIfPresent(Pager pPager)
		{
			int rc = (int)(0);


			if (pPager.tempFile == 0)
			{
				int isWal = 0;
				rc = (int)(sqlite3OsAccess(pPager.pVfs, pPager.zWal, (int)(0), &isWal));
				if ((rc) == (0))
				{
					if ((isWal) != 0)
					{
						uint nPage = 0;
						rc = (int)(pagerPagecount(pPager, &nPage));
						if ((rc) != 0)
							return (int)(rc);
						if ((nPage) == (0))
						{
							rc = (int)(sqlite3OsDelete(pPager.pVfs, pPager.zWal, (int)(0)));
						}
						else
						{
							rc = (int)(sqlite3PagerOpenWal(pPager, null));
						}
					}
					else if ((pPager.journalMode) == (5))
					{
						pPager.journalMode = (byte)(0);
					}
				}
			}

			return (int)(rc);
		}
		public static int pagerPagecount(Pager pPager, uint* pnPage)
		{
			uint nPage = 0;




			nPage = (uint)(sqlite3WalDbsize(pPager.pWal));
			if (((nPage) == (0)) && (((pPager.fd).pMethods != null) != 0))
			{
				long n = (long)(0);
				int rc = (int)(sqlite3OsFileSize(pPager.fd, &n));
				if (rc != 0)
				{
					return (int)(rc);
				}

				nPage = ((uint)((n + pPager.pageSize - 1) / pPager.pageSize));
			}

			if ((nPage) > (pPager.mxPgno))
			{
				pPager.mxPgno = (uint)(nPage);
			}

			*pnPage = (uint)(nPage);
			return (int)(0);
		}
		public static int pagerPlaybackSavepoint(Pager pPager, PagerSavepoint* pSavepoint)
		{
			long szJ = 0;
			long iHdrOff = 0;
			int rc = (int)(0);
			Bitvec* pDone = null;


			if ((pSavepoint) != null)
			{
				pDone = sqlite3BitvecCreate((uint)(pSavepoint->nOrig));
				if (pDone == null)
				{
					return (int)(7);
				}
			}

			pPager.dbSize = (uint)(pSavepoint ? pSavepoint->nOrig : pPager.dbOrigSize);
			pPager.changeCountDone = (byte)(pPager.tempFile);
			if ((pSavepoint == null) && ((pPager).pWal != null))
			{
				return (int)(pagerRollbackWal(pPager));
			}

			szJ = (long)(pPager.journalOff);

			if (((pSavepoint) != null) && (!((pPager).pWal != null)))
			{
				iHdrOff = (long)((pSavepoint->iHdrOffset) != 0 ? pSavepoint->iHdrOffset : szJ);
				pPager.journalOff = (long)(pSavepoint->iOffset);
				while (((rc) == (0)) && ((pPager.journalOff) < (iHdrOff)))
				{
					rc = (int)(pager_playback_one_page(pPager, &pPager.journalOff, pDone, (int)(1), (int)(1)));
				}


			}
			else
			{
				pPager.journalOff = (long)(0);
			}

			while (((rc) == (0)) && ((pPager.journalOff) < (szJ)))
			{
				uint ii = 0;
				uint nJRec = (uint)(0);
				uint dummy = 0;
				rc = (int)(readJournalHdr(pPager, (int)(0), (long)(szJ), &nJRec, &dummy));

				if (((nJRec) == (0)) && ((pPager.journalHdr + (pPager.sectorSize)) == (pPager.journalOff)))
				{
					nJRec = ((uint)((szJ - pPager.journalOff) / ((pPager.pageSize) + 8)));
				}

				for (ii = (uint)(0); (((rc) == (0)) && ((ii) < (nJRec))) && ((pPager.journalOff) < (szJ)); ii++)
				{
					rc = (int)(pager_playback_one_page(pPager, &pPager.journalOff, pDone, (int)(1), (int)(1)));
				}


			}


			if ((pSavepoint) != null)
			{
				uint ii = 0;
				long offset = (long)((long)(pSavepoint->iSubRec) * (4 + pPager.pageSize));
				if (((pPager).pWal != null))
				{
					rc = (int)(sqlite3WalSavepointUndo(pPager.pWal, pSavepoint->aWalData));
				}

				for (ii = (uint)(pSavepoint->iSubRec); ((rc) == (0)) && ((ii) < (pPager.nSubRec)); ii++)
				{

					rc = (int)(pager_playback_one_page(pPager, &offset, pDone, (int)(0), (int)(1)));
				}


			}

			sqlite3BitvecDestroy(pDone);
			if ((rc) == (0))
			{
				pPager.journalOff = (long)(szJ);
			}

			return (int)(rc);
		}
		public static void pagerReleaseMapPage(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;
			pPager.nMmapOut--;
			pPg.pDirty = pPager.pMmapFreelist;
			pPager.pMmapFreelist = pPg;

			sqlite3OsUnfetch(pPager.fd, (long)((long)(pPg.pgno - 1) * pPager.pageSize), pPg.pData);
		}
		public static int pagerRollbackWal(Pager pPager)
		{
			int rc = 0;
			PgHdr pList;
			pPager.dbSize = (uint)(pPager.dbOrigSize);
			rc = (int)(sqlite3WalUndo(pPager.pWal, pagerUndoCallback, (void*)(pPager)));
			pList = sqlite3PcacheDirtyList(pPager.pPCache);
			while (((pList) != null) && ((rc) == (0)))
			{
				PgHdr pNext = pList.pDirty;
				rc = (int)(pagerUndoCallback((void*)(pPager), (uint)(pList.pgno)));
				pList = pNext;
			}

			return (int)(rc);
		}
		public static int pagerStress(void* p, PgHdr pPg)
		{
			Pager pPager = (Pager)(p);
			int rc = (int)(0);


			if ((pPager.errCode) != 0)
				return (int)(0);
			if (((pPager.doNotSpill) != 0) && (((pPager.doNotSpill & (0x02 | 0x01)) != 0) || ((pPg.flags & 0x008) != 0)))
			{
				return (int)(0);
			}

			pPager.aStat[3]++;
			pPg.pDirty = null;
			if (((pPager).pWal != null))
			{
				rc = (int)(subjournalPageIfRequired(pPg));
				if ((rc) == (0))
				{
					rc = (int)(pagerWalFrames(pPager, pPg, (uint)(0), (int)(0)));
				}
			}
			else
			{
				if (((pPg.flags & 0x008) != 0) || ((pPager.eState) == (3)))
				{
					rc = (int)(syncJournal(pPager, (int)(1)));
				}

				if ((rc) == (0))
				{

					rc = (int)(pager_write_pagelist(pPager, pPg));
				}
			}

			if ((rc) == (0))
			{
				sqlite3PcacheMakeClean(pPg);
			}

			return (int)(pager_error(pPager, (int)(rc)));
		}
		public static int pagerSyncHotJournal(Pager pPager)
		{
			int rc = (int)(0);
			if (pPager.noSync == 0)
			{
				rc = (int)(sqlite3OsSync(pPager.jfd, (int)(0x00002)));
			}

			if ((rc) == (0))
			{
				rc = (int)(sqlite3OsFileSize(pPager.jfd, &pPager.journalHdr));
			}

			return (int)(rc);
		}
		public static int pagerUndoCallback(void* pCtx, uint iPg)
		{
			int rc = (int)(0);
			Pager pPager = (Pager)(pCtx);
			PgHdr pPg;

			pPg = sqlite3PagerLookup(pPager, (uint)(iPg));
			if ((pPg) != null)
			{
				if ((sqlite3PcachePageRefcount(pPg)) == (1))
				{
					sqlite3PcacheDrop(pPg);
				}
				else
				{
					rc = (int)(readDbPage(pPg));
					if ((rc) == (0))
					{
						pPager.xReiniter(pPg);
					}

					sqlite3PagerUnrefNotNull(pPg);
				}
			}

			sqlite3BackupRestart(pPager.pBackup);
			return (int)(rc);
		}
		public static void pagerUnlockAndRollback(Pager pPager)
		{
			if ((pPager.eState != 6) && (pPager.eState != 0))
			{

				if ((pPager.eState) >= (2))
				{
					sqlite3BeginBenignMalloc();
					sqlite3PagerRollback(pPager);
					sqlite3EndBenignMalloc();
				}
				else if (pPager.exclusiveMode == 0)
				{

					pager_end_transaction(pPager, (int)(0), (int)(0));
				}
			}

			pager_unlock(pPager);
		}
		public static int pagerUnlockDb(Pager pPager, int eLock)
		{
			int rc = (int)(0);



			if (((pPager.fd).pMethods != null))
			{

				rc = (int)((pPager.noLock) != 0 ? 0 : sqlite3OsUnlock(pPager.fd, (int)(eLock)));
				if (pPager.eLock != (4 + 1))
				{
					pPager.eLock = ((byte)(eLock));
				}
			}

			pPager.changeCountDone = (byte)(pPager.tempFile);
			return (int)(rc);
		}
		public static void pagerUnlockIfUnused(Pager pPager)
		{
			if ((sqlite3PcacheRefCount(pPager.pPCache)) == (0))
			{

				pagerUnlockAndRollback(pPager);
			}
		}
		public static int pagerWalFrames(Pager pPager, PgHdr pList, uint nTruncate, int isCommit)
		{
			int rc = 0;
			int nList = 0;
			PgHdr p;



			if ((isCommit) != 0)
			{
				PgHdr ppNext = pList;
				nList = (int)(0);
				for (p = pList; (ppNext = p) != null; p = p.pDirty)
				{
					if ((p.pgno) <= (nTruncate))
					{
						ppNext = p.pDirty;
						nList++;
					}
				}


			}
			else
			{
				nList = (int)(1);
			}

			pPager.aStat[2] += (int)(nList);
			if ((pList.pgno) == (1))
				pager_write_changecounter(pList);
			rc = (int)(sqlite3WalFrames(pPager.pWal, (int)(pPager.pageSize), pList, (uint)(nTruncate), (int)(isCommit), (int)(pPager.walSyncFlags)));
			if (((rc) == (0)) && ((pPager.pBackup) != null))
			{
				for (p = pList; p; p = p.pDirty)
				{
					sqlite3BackupUpdate(pPager.pBackup, (uint)(p.pgno), (byte*)(p.pData));
				}
			}

			return (int)(rc);
		}
		public static int pagerWriteLargeSector(PgHdr pPg)
		{
			int rc = (int)(0);
			uint nPageCount = 0;
			uint pg1 = 0;
			int nPage = (int)(0);
			int ii = 0;
			int needSync = (int)(0);
			Pager pPager = pPg.pPager;
			uint nPagePerSector = (uint)(pPager.sectorSize / pPager.pageSize);


			pPager.doNotSpill |= (byte)(0x04);
			pg1 = (uint)(((pPg.pgno - 1) & ~(nPagePerSector - 1)) + 1);
			nPageCount = (uint)(pPager.dbSize);
			if ((pPg.pgno) > (nPageCount))
			{
				nPage = (int)((pPg.pgno - pg1) + 1);
			}
			else if ((pg1 + nPagePerSector - 1) > (nPageCount))
			{
				nPage = (int)(nPageCount + 1 - pg1);
			}
			else
			{
				nPage = (int)(nPagePerSector);
			}




			for (ii = (int)(0); ((ii) < (nPage)) && ((rc) == (0)); ii++)
			{
				uint pg = (uint)(pg1 + ii);
				PgHdr pPage;
				if (((pg) == (pPg.pgno)) || (sqlite3BitvecTest(pPager.pInJournal, (uint)(pg)) == 0))
				{
					if (pg != ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1)))
					{
						rc = (int)(sqlite3PagerGet(pPager, (uint)(pg), pPage, (int)(0)));
						if ((rc) == (0))
						{
							rc = (int)(pager_write(pPage));
							if ((pPage.flags & 0x008) != 0)
							{
								needSync = (int)(1);
							}

							sqlite3PagerUnrefNotNull(pPage);
						}
					}
				}
				else if ((pPage = sqlite3PagerLookup(pPager, (uint)(pg))) != null)
				{
					if ((pPage.flags & 0x008) != 0)
					{
						needSync = (int)(1);
					}

					sqlite3PagerUnrefNotNull(pPage);
				}
			}

			if (((rc) == (0)) && ((needSync) != 0))
			{

				for (ii = (int)(0); (ii) < (nPage); ii++)
				{
					PgHdr pPage = sqlite3PagerLookup(pPager, (uint)(pg1 + ii));
					if ((pPage) != null)
					{
						pPage.flags |= (ushort)(0x008);
						sqlite3PagerUnrefNotNull(pPage);
					}
				}
			}


			pPager.doNotSpill &= (byte)(~0x04);
			return (int)(rc);
		}
		public static int parseDateOrTime(sqlite3_context context, sbyte* zDate, DateTime* p)
		{
			double r = 0;
			if ((parseYyyyMmDd(zDate, p)) == (0))
			{
				return (int)(0);
			}
			else if ((parseHhMmSs(zDate, p)) == (0))
			{
				return (int)(0);
			}
			else if (((sqlite3StrICmp(zDate, "now")) == (0)) && ((sqlite3NotPureFunc(context)) != 0))
			{
				return (int)(setDateTimeToCurrent(context, p));
			}
			else if ((sqlite3AtoF(zDate, &r, (int)(sqlite3Strlen30(zDate)), (byte)(1))) > (0))
			{
				setRawDateNumber(p, (double)(r));
				return (int)(0);
			}

			return (int)(1);
		}
		public static int parseHhMmSs(sbyte* zDate, DateTime* p)
		{
			int h = 0; int m = 0; int s = 0;
			double ms = (double)(0.0);
			if (getDigits(zDate, "20c:20e", &h, &m) != 2)
			{
				return (int)(1);
			}

			zDate += 5;
			if ((*zDate) == (58))
			{
				zDate++;
				if (getDigits(zDate, "20e", &s) != 1)
				{
					return (int)(1);
				}

				zDate += 2;
				if (((*zDate) == (46)) && ((sqlite3CtypeMap[(byte)(zDate[1])] & 0x04) != 0))
				{
					double rScale = (double)(1.0);
					zDate++;
					while ((sqlite3CtypeMap[(byte)(*zDate)] & 0x04) != 0)
					{
						ms = (double)(ms * 10.0 + *zDate - 48);
						rScale *= (double)(10.0);
						zDate++;
					}

					ms /= (double)(rScale);
				}
			}
			else
			{
				s = (int)(0);
			}

			p->validJD = (sbyte)(0);
			p->rawS = (sbyte)(0);
			p->validHMS = (sbyte)(1);
			p->h = (int)(h);
			p->m = (int)(m);
			p->s = (double)(s + ms);
			if ((parseTimezone(zDate, p)) != 0)
				return (int)(1);
			p->validTZ = (sbyte)((p->tz != 0) ? 1 : 0);
			return (int)(0);
		}
		public static int parseModifier(sqlite3_context pCtx, sbyte* z, int n, DateTime* p, int idx)
		{
			int rc = (int)(1);
			double r = 0;
			switch (sqlite3UpperToLower[(byte)(z[0])])
			{
				case 97:
					{
						if ((sqlite3_stricmp(z, "auto")) == (0))
						{
							if ((idx) > (1))
								return (int)(1);
							if ((p->rawS == 0) || ((p->validJD) != 0))
							{
								rc = (int)(0);
								p->rawS = (sbyte)(0);
							}
							else if (((p->s) >= (-21086676 * (long)(10000))) && ((p->s) <= ((25340230 * (long)(10000)) + 799)))
							{
								r = (double)(p->s * 1000.0 + 210866760000000.0);
								clearYMD_HMS_TZ(p);
								p->iJD = ((long)(r + 0.5));
								p->validJD = (sbyte)(1);
								p->rawS = (sbyte)(0);
								rc = (int)(0);
							}
						}

						break;
					}

				case 106:
					{
						if ((sqlite3_stricmp(z, "julianday")) == (0))
						{
							if ((idx) > (1))
								return (int)(1);
							if (((p->validJD) != 0) && ((p->rawS) != 0))
							{
								rc = (int)(0);
								p->rawS = (sbyte)(0);
							}
						}

						break;
					}

				case 108:
					{
						if (((sqlite3_stricmp(z, "localtime")) == (0)) && ((sqlite3NotPureFunc(pCtx)) != 0))
						{
							rc = (int)(toLocaltime(p, pCtx));
						}

						break;
					}

				case 117:
					{
						if (((sqlite3_stricmp(z, "unixepoch")) == (0)) && ((p->rawS) != 0))
						{
							if ((idx) > (1))
								return (int)(1);
							r = (double)(p->s * 1000.0 + 210866760000000.0);
							if (((r) >= (0.0)) && ((r) < (464269060800000.0)))
							{
								clearYMD_HMS_TZ(p);
								p->iJD = ((long)(r + 0.5));
								p->validJD = (sbyte)(1);
								p->rawS = (sbyte)(0);
								rc = (int)(0);
							}
						}
						else if (((sqlite3_stricmp(z, "utc")) == (0)) && ((sqlite3NotPureFunc(pCtx)) != 0))
						{
							if ((p->tzSet) == (0))
							{
								long iOrigJD = 0;
								long iGuess = 0;
								int cnt = (int)(0);
								int iErr = 0;
								computeJD(p);
								iGuess = (long)(iOrigJD = (long)(p->iJD));
								iErr = (int)(0);
								do
								{
									DateTime new = new DateTime();
									CRuntime.memset(&new, (int)(0), (ulong)(sizeof(DateTime)));
									iGuess -= (long)(iErr);
									new.iJD = (long)(iGuess);
									new.validJD = (sbyte)(1);
									rc = (int)(toLocaltime(&new, pCtx));
									if ((rc) != 0)
										return (int)(rc);
									computeJD(&new);
									iErr = (int)(new.iJD - iOrigJD);
								}
								while (((iErr) != 0) && ((cnt++) < (3)));
								CRuntime.memset(p, (int)(0), (ulong)(sizeof(DateTime)));
								p->iJD = (long)(iGuess);
								p->validJD = (sbyte)(1);
								p->tzSet = (sbyte)(1);
							}

							rc = (int)(0);
						}

						break;
					}

				case 119:
					{
						if ((((((sqlite3_strnicmp(z, "weekday ", (int)(8))) == (0)) && ((sqlite3AtoF(&z[8], &r, (int)(sqlite3Strlen30(&z[8])), (byte)(1))) > (0))) && ((n = ((int)(r))) == (r))) && ((n) >= (0))) && ((r) < (7)))
						{
							long Z = 0;
							computeYMD_HMS(p);
							p->validTZ = (sbyte)(0);
							p->validJD = (sbyte)(0);
							computeJD(p);
							Z = (long)(((p->iJD + 129600000) / 86400000) % 7);
							if ((Z) > (n))
								Z -= (long)(7);
							p->iJD += (long)((n - Z) * 86400000);
							clearYMD_HMS_TZ(p);
							rc = (int)(0);
						}

						break;
					}

				case 115:
					{
						if (sqlite3_strnicmp(z, "start of ", (int)(9)) != 0)
							break;
						if (((p->validJD == 0) && (p->validYMD == 0)) && (p->validHMS == 0))
							break;
						z += 9;
						computeYMD(p);
						p->validHMS = (sbyte)(1);
						p->h = (int)(p->m = (int)(0));
						p->s = (double)(0.0);
						p->rawS = (sbyte)(0);
						p->validTZ = (sbyte)(0);
						p->validJD = (sbyte)(0);
						if ((sqlite3_stricmp(z, "month")) == (0))
						{
							p->D = (int)(1);
							rc = (int)(0);
						}
						else if ((sqlite3_stricmp(z, "year")) == (0))
						{
							p->M = (int)(1);
							p->D = (int)(1);
							rc = (int)(0);
						}
						else if ((sqlite3_stricmp(z, "day")) == (0))
						{
							rc = (int)(0);
						}

						break;
					}

				case 43:
				case 45:
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
					{
						double rRounder = 0;
						int i = 0;
						for (n = (int)(1); (((z[n]) != 0) && (z[n] != 58)) && ((sqlite3CtypeMap[(byte)(z[n])] & 0x01) == 0); n++)
						{
						}

						if ((sqlite3AtoF(z, &r, (int)(n), (byte)(1))) <= (0))
						{
							rc = (int)(1);
							break;
						}

						if ((z[n]) == (58))
						{
							sbyte* z2 = z;
							DateTime tx = new DateTime();
							long day = 0;
							if ((sqlite3CtypeMap[(byte)(*z2)] & 0x04) == 0)
								z2++;
							CRuntime.memset(&tx, (int)(0), (ulong)(sizeof(DateTime)));
							if ((parseHhMmSs(z2, &tx)) != 0)
								break;
							computeJD(&tx);
							tx.iJD -= (long)(43200000);
							day = (long)(tx.iJD / 86400000);
							tx.iJD -= (long)(day * 86400000);
							if ((z[0]) == (45))
								tx.iJD = (long)(-tx.iJD);
							computeJD(p);
							clearYMD_HMS_TZ(p);
							p->iJD += (long)(tx.iJD);
							rc = (int)(0);
							break;
						}

						z += n;
						while ((sqlite3CtypeMap[(byte)(*z)] & 0x01) != 0)
						{
							z++;
						}

						n = (int)(sqlite3Strlen30(z));
						if (((n) > (10)) || ((n) < (3)))
							break;
						if ((sqlite3UpperToLower[(byte)(z[n - 1])]) == (115))
							n--;
						computeJD(p);
						rc = (int)(1);
						rRounder = (double)((r) < (0) ? -0.5 : +0.5);
						for (i = (int)(0); (i) < ((int)(6 * sizeof((unnamed at sqlite3.c : 23685 : 14)
                 ) 

			/ sizeof((unnamed at sqlite3.c : 
            23685 : 
            14 ) ) ) )
            ;
						i++ )
            {
							if (((((aXformType[i].nName) == (n)) && ((sqlite3_strnicmp(aXformType[i].zName, z, (int)(n))) == (0))) && ((r) > (-aXformType[i].rLimit))) && ((r) < (aXformType[i].rLimit)))
							{
								switch (i)
								{
									case 4:
										{
											int x = 0;

											computeYMD_HMS(p);
											p->M += ((int)(r));
											x = (int)((p->M) > (0) ? (p->M - 1) / 12 : (p->M - 12) / 12);
											p->Y += (int)(x);
											p->M -= (int)(x * 12);
											p->validJD = (sbyte)(0);
											r -= (double)((int)(r));
											break;
										}

									case 5:
										{
											int y = (int)(r);

											computeYMD_HMS(p);
											p->Y += (int)(y);
											p->validJD = (sbyte)(0);
											r -= (double)((int)(r));
											break;
										}
								}

								computeJD(p);
								p->iJD += ((long)(r * 1000.0 * aXformType[i].rXform + rRounder));
								rc = (int)(0);
								break;
							}
						}

						clearYMD_HMS_TZ(p);
						break;
					}

				default:
					{
						break;
					}
			}

			return (int)(rc);
		}
		public static ExprList parserAddExprIdListTerm(Parse pParse, ExprList pPrior, Token* pIdToken, int hasCollate, int sortOrder)
		{
			ExprList p = sqlite3ExprListAppend(pParse, pPrior, null);
			if ((((hasCollate) != 0) || (sortOrder != -1)) && ((pParse.db.init.busy) == (0)))
			{
				sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"", (uint)(pIdToken->n), pIdToken->z);
			}

			sqlite3ExprListSetName(pParse, p, pIdToken, (int)(1));
			return p;
		}
		public static void parserDoubleLinkSelect(Parse pParse, Select p)
		{

			if ((p.pPrior) != null)
			{
				Select pNext = null;
				Select pLoop = p;
				int mxSelect = 0;
				int cnt = (int)(1);
				while ((1) != 0)
				{
					pLoop.pNext = pNext;
					pLoop.selFlags |= (uint)(0x0000100);
					pNext = pLoop;
					pLoop = pLoop.pPrior;
					if ((pLoop) == (null))
						break;
					cnt++;
					if (((pLoop.pOrderBy) != null) || ((pLoop.pLimit) != null))
					{
						sqlite3ErrorMsg(pParse, "%s clause should come after %s not before", pLoop.pOrderBy != null ? "ORDER BY" : "LIMIT", sqlite3SelectOpName((int)(pNext.op)));
						break;
					}
				}

				if ((((p.selFlags & 0x0000400) == (0)) && ((mxSelect = (int)(pParse.db.aLimit[4])) > (0))) && ((cnt) > (mxSelect)))
				{
					sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
				}
			}
		}
		public static int parseTimezone(sbyte* zDate, DateTime* p)
		{
			int sgn = (int)(0);
			int nHr = 0; int nMn = 0;
			int c = 0;
			while ((sqlite3CtypeMap[(byte)(*zDate)] & 0x01) != 0)
			{
				zDate++;
			}

			p->tz = (int)(0);
			c = (int)(*zDate);
			if ((c) == (45))
			{
				sgn = (int)(-1);
			}
			else if ((c) == (43))
			{
				sgn = (int)(+1);
			}
			else if (((c) == (90)) || ((c) == (122)))
			{
				zDate++;
				goto zulu_time;
			}
			else
			{
				return (int)(c != 0);
			}

			zDate++;
			if (getDigits(zDate, "20b:20e", &nHr, &nMn) != 2)
			{
				return (int)(1);
			}

			zDate += 5;
			p->tz = (int)(sgn * (nMn + nHr * 60));
		zulu_time:
			; while ((sqlite3CtypeMap[(byte)(*zDate)] & 0x01) != 0) { zDate++; }
			p->tzSet = (sbyte)(1);
			return (int)(*zDate != 0);
		}
		public static int parseYyyyMmDd(sbyte* zDate, DateTime* p)
		{
			int Y = 0; int M = 0; int D = 0; int neg = 0;
			if ((zDate[0]) == (45))
			{
				zDate++;
				neg = (int)(1);
			}
			else
			{
				neg = (int)(0);
			}

			if (getDigits(zDate, "40f-21a-21d", &Y, &M, &D) != 3)
			{
				return (int)(1);
			}

			zDate += 10;
			while (((sqlite3CtypeMap[(byte)(*zDate)] & 0x01) != 0) || ((84) == (*(byte*)(zDate))))
			{
				zDate++;
			}

			if ((parseHhMmSs(zDate, p)) == (0))
			{
			}
			else if ((*zDate) == (0))
			{
				p->validHMS = (sbyte)(0);
			}
			else
			{
				return (int)(1);
			}

			p->validJD = (sbyte)(0);
			p->validYMD = (sbyte)(1);
			p->Y = (int)((neg) != 0 ? -Y : Y);
			p->M = (int)(M);
			p->D = (int)(D);
			if ((p->validTZ) != 0)
			{
				computeJD(p);
			}

			return (int)(0);
		}
		public static int patternCompare(byte* zPattern, byte* zString, compareInfo* pInfo, uint matchOther)
		{
			uint c = 0; uint c2 = 0;
			uint matchOne = (uint)(pInfo->matchOne);
			uint matchAll = (uint)(pInfo->matchAll);
			byte noCase = (byte)(pInfo->noCase);
			byte* zEscaped = null;
			while ((c = (uint)((zPattern[0]) < (0x80) ? *(zPattern++) : sqlite3Utf8Read(&zPattern))) != 0)
			{
				if ((c) == (matchAll))
				{
					while (((c = (uint)((zPattern[0]) < (0x80) ? *(zPattern++) : sqlite3Utf8Read(&zPattern))) == (matchAll)) || (((c) == (matchOne)) && (matchOne != 0)))
					{
						if (((c) == (matchOne)) && ((sqlite3Utf8Read(&zString)) == (0)))
						{
							return (int)(2);
						}
					}

					if ((c) == (0))
					{
						return (int)(0);
					}
					else if ((c) == (matchOther))
					{
						if ((pInfo->matchSet) == (0))
						{
							c = (uint)(sqlite3Utf8Read(&zPattern));
							if ((c) == (0))
								return (int)(2);
						}
						else
						{

							while ((*zString) != 0)
							{
								int bMatch = (int)(patternCompare(&zPattern[-1], zString, pInfo, (uint)(matchOther)));
								if (bMatch != 1)
									return (int)(bMatch);
								{
									if ((*(zString++)) >= (0xc0))
									{
										while ((*zString & 0xc0) == (0x80))
										{
											zString++;
										}
									}
								}
							}

							return (int)(2);
						}
					}

					if ((c) <= (0x80))
					{
						sbyte* zStop = stackalloc sbyte[3];
						int bMatch = 0;
						if ((noCase) != 0)
						{
							zStop[0] = (sbyte)((c) & ~(sqlite3CtypeMap[(byte)(c)] & 0x20));
							zStop[1] = (sbyte)(sqlite3UpperToLower[(byte)(c)]);
							zStop[2] = (sbyte)(0);
						}
						else
						{
							zStop[0] = (sbyte)(c);
							zStop[1] = (sbyte)(0);
						}

						while ((1) != 0)
						{
							zString += strcspn((sbyte*)(zString), zStop);
							if ((zString[0]) == (0))
								break;
							zString++;
							bMatch = (int)(patternCompare(zPattern, zString, pInfo, (uint)(matchOther)));
							if (bMatch != 1)
								return (int)(bMatch);
						}
					}
					else
					{
						int bMatch = 0;
						while ((c2 = (uint)((zString[0]) < (0x80) ? *(zString++) : sqlite3Utf8Read(&zString))) != 0)
						{
							if (c2 != c)
								continue;
							bMatch = (int)(patternCompare(zPattern, zString, pInfo, (uint)(matchOther)));
							if (bMatch != 1)
								return (int)(bMatch);
						}
					}

					return (int)(2);
				}

				if ((c) == (matchOther))
				{
					if ((pInfo->matchSet) == (0))
					{
						c = (uint)(sqlite3Utf8Read(&zPattern));
						if ((c) == (0))
							return (int)(1);
						zEscaped = zPattern;
					}
					else
					{
						uint prior_c = (uint)(0);
						int seen = (int)(0);
						int invert = (int)(0);
						c = (uint)(sqlite3Utf8Read(&zString));
						if ((c) == (0))
							return (int)(1);
						c2 = (uint)(sqlite3Utf8Read(&zPattern));
						if ((c2) == (94))
						{
							invert = (int)(1);
							c2 = (uint)(sqlite3Utf8Read(&zPattern));
						}

						if ((c2) == (93))
						{
							if ((c) == (93))
								seen = (int)(1);
							c2 = (uint)(sqlite3Utf8Read(&zPattern));
						}

						while (((c2) != 0) && (c2 != 93))
						{
							if (((((c2) == (45)) && (zPattern[0] != 93)) && (zPattern[0] != 0)) && ((prior_c) > (0)))
							{
								c2 = (uint)(sqlite3Utf8Read(&zPattern));
								if (((c) >= (prior_c)) && ((c) <= (c2)))
									seen = (int)(1);
								prior_c = (uint)(0);
							}
							else
							{
								if ((c) == (c2))
								{
									seen = (int)(1);
								}

								prior_c = (uint)(c2);
							}

							c2 = (uint)(sqlite3Utf8Read(&zPattern));
						}

						if (((c2) == (0)) || ((seen ^ invert) == (0)))
						{
							return (int)(1);
						}

						continue;
					}
				}

				c2 = (uint)((zString[0]) < (0x80) ? *(zString++) : sqlite3Utf8Read(&zString));
				if ((c) == (c2))
					continue;
				if (((((noCase) != 0) && ((sqlite3UpperToLower[(byte)(c)]) == (sqlite3UpperToLower[(byte)(c2)]))) && ((c) < (0x80))) && ((c2) < (0x80)))
				{
					continue;
				}

				if ((((c) == (matchOne)) && (zPattern != zEscaped)) && (c2 != 0))
					continue;
				return (int)(1);
			}

			return (int)((*zString) == (0) ? 0 : 1);
		}
		public static void* pcache1Alloc(int nByte)
		{
			void* p = null;

			if ((nByte) <= ((pcache1_g).szSlot))
			{
				sqlite3_mutex_enter((pcache1_g).mutex);
				p = (PgHdr1*)((pcache1_g).pFree);
				if ((p) != null)
				{
					(pcache1_g).pFree = (pcache1_g).pFree->pNext;
					(pcache1_g).nFreeSlot--;
					(pcache1_g).bUnderPressure = (int)(((pcache1_g).nFreeSlot) < ((pcache1_g).nReserve) ? 1 : 0);

					sqlite3StatusHighwater((int)(7), (int)(nByte));
					sqlite3StatusUp((int)(1), (int)(1));
				}

				sqlite3_mutex_leave((pcache1_g).mutex);
			}

			if ((p) == (null))
			{
				p = sqlite3Malloc((ulong)(nByte));
				if ((p) != null)
				{
					int sz = (int)(sqlite3MallocSize(p));
					sqlite3_mutex_enter((pcache1_g).mutex);
					sqlite3StatusHighwater((int)(7), (int)(nByte));
					sqlite3StatusUp((int)(2), (int)(sz));
					sqlite3_mutex_leave((pcache1_g).mutex);
				}
			}

			return p;
		}
		public static PgHdr1* pcache1AllocPage(PCache1* pCache, int benignMalloc)
		{
			PgHdr1* p = null;
			void* pPg;

			if (((pCache->pFree) != null) || (((pCache->nPage) == (0)) && ((pcache1InitBulk(pCache)) != 0)))
			{

				p = pCache->pFree;
				pCache->pFree = p->pNext;
				p->pNext = null;
			}
			else
			{
				if ((benignMalloc) != 0)
				{
					sqlite3BeginBenignMalloc();
				}

				pPg = pcache1Alloc((int)(pCache->szAlloc));
				if ((benignMalloc) != 0)
				{
					sqlite3EndBenignMalloc();
				}

				if ((pPg) == (null))
					return null;
				p = (PgHdr1*)(&((byte*)(pPg))[pCache->szPage]);
				p->page.pBuf = pPg;
				p->page.pExtra = &p[1];
				p->isBulkLocal = (ushort)(0);
				p->isAnchor = (ushort)(0);
				p->pLruPrev = null;
			}

			(*pCache->pnPurgeable)++;
			return p;
		}
		public static void pcache1Cachesize(sqlite3_pcache* p, int nMax)
		{
			PCache1* pCache = (PCache1*)(p);
			uint n = 0;

			if ((pCache->bPurgeable) != 0)
			{
				PGroup* pGroup = pCache->pGroup;

				n = ((uint)(nMax));
				if ((n) > (0x7fff0000 - pGroup->nMaxPage + pCache->nMax))
				{
					n = (uint)(0x7fff0000 - pGroup->nMaxPage + pCache->nMax);
				}

				pGroup->nMaxPage += (uint)(n - pCache->nMax);
				pGroup->mxPinned = (uint)(pGroup->nMaxPage + 10 - pGroup->nMinPage);
				pCache->nMax = (uint)(n);
				pCache->n90pct = (uint)(pCache->nMax * 9 / 10);
				pcache1EnforceMaxPage(pCache);

			}
		}
		public static sqlite3_pcache* pcache1Create(int szPage, int szExtra, int bPurgeable)
		{
			PCache1* pCache;
			PGroup* pGroup;
			int sz = 0;


			sz = (int)(sizeof(PCache1) + sizeof(PGroup) * (pcache1_g).separateCache);
			pCache = (PCache1*)(sqlite3MallocZero((ulong)(sz)));
			if ((pCache) != null)
			{
				if (((pcache1_g).separateCache) != 0)
				{
					pGroup = (PGroup*)(&pCache[1]);
					pGroup->mxPinned = (uint)(10);
				}
				else
				{
					pGroup = &(pcache1_g).grp;
				}


				if ((pGroup->lru.isAnchor) == (0))
				{
					pGroup->lru.isAnchor = (ushort)(1);
					pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
				}

				pCache->pGroup = pGroup;
				pCache->szPage = (int)(szPage);
				pCache->szExtra = (int)(szExtra);
				pCache->szAlloc = (int)(szPage + szExtra + (((sizeof(PgHdr1)) + 7) & ~7));
				pCache->bPurgeable = (int)((bPurgeable) != 0 ? 1 : 0);
				pcache1ResizeHash(pCache);
				if ((bPurgeable) != 0)
				{
					pCache->nMin = (uint)(10);
					pGroup->nMinPage += (uint)(pCache->nMin);
					pGroup->mxPinned = (uint)(pGroup->nMaxPage + 10 - pGroup->nMinPage);
					pCache->pnPurgeable = &pGroup->nPurgeable;
				}
				else
				{
					pCache->pnPurgeable = &pCache->nPurgeableDummy;
				}


				if ((pCache->nHash) == (0))
				{
					pcache1Destroy((sqlite3_pcache*)(pCache));
					pCache = null;
				}
			}

			return (sqlite3_pcache*)(pCache);
		}
		public static void pcache1Destroy(sqlite3_pcache* p)
		{
			PCache1* pCache = (PCache1*)(p);
			PGroup* pGroup = pCache->pGroup;


			if ((pCache->nPage) != 0)
				pcache1TruncateUnsafe(pCache, (uint)(0));

			pGroup->nMaxPage -= (uint)(pCache->nMax);

			pGroup->nMinPage -= (uint)(pCache->nMin);
			pGroup->mxPinned = (uint)(pGroup->nMaxPage + 10 - pGroup->nMinPage);
			pcache1EnforceMaxPage(pCache);

			sqlite3_free(pCache->pBulk);
			sqlite3_free(pCache->apHash);
			sqlite3_free(pCache);
		}
		public static void pcache1EnforceMaxPage(PCache1* pCache)
		{
			PGroup* pGroup = pCache->pGroup;
			PgHdr1* p;

			while (((pGroup->nPurgeable) > (pGroup->nMaxPage)) && (((p = pGroup->lru.pLruPrev)->isAnchor) == (0)))
			{


				pcache1PinPage(p);
				pcache1RemoveFromHash(p, (int)(1));
			}

			if (((pCache->nPage) == (0)) && ((pCache->pBulk) != null))
			{
				sqlite3_free(pCache->pBulk);
				pCache->pBulk = pCache->pFree = null;
			}
		}
		public static sqlite3_pcache_page* pcache1Fetch(sqlite3_pcache* p, uint iKey, int createFlag)
		{






			{
				return (sqlite3_pcache_page*)(pcache1FetchNoMutex(p, (uint)(iKey), (int)(createFlag)));
			}
		}
		public static PgHdr1* pcache1FetchNoMutex(sqlite3_pcache* p, uint iKey, int createFlag)
		{
			PCache1* pCache = (PCache1*)(p);
			PgHdr1* pPage = null;
			pPage = pCache->apHash[iKey % pCache->nHash];
			while (((pPage) != null) && (pPage->iKey != iKey))
			{
				pPage = pPage->pNext;
			}

			if ((pPage) != null)
			{
				if (((pPage)->pLruNext != null))
				{
					return pcache1PinPage(pPage);
				}
				else
				{
					return pPage;
				}
			}
			else if ((createFlag) != 0)
			{
				return pcache1FetchStage2(pCache, (uint)(iKey), (int)(createFlag));
			}
			else
			{
				return null;
			}
		}
		public static PgHdr1* pcache1FetchStage2(PCache1* pCache, uint iKey, int createFlag)
		{
			uint nPinned = 0;
			PGroup* pGroup = pCache->pGroup;
			PgHdr1* pPage = null;

			nPinned = (uint)(pCache->nPage - pCache->nRecyclable);


			if (((createFlag) == (1)) && ((((nPinned) >= (pGroup->mxPinned)) || ((nPinned) >= (pCache->n90pct))) || (((pcache1UnderMemoryPressure(pCache)) != 0) && ((pCache->nRecyclable) < (nPinned)))))
			{
				return null;
			}

			if ((pCache->nPage) >= (pCache->nHash))
				pcache1ResizeHash(pCache);

			if ((((pCache->bPurgeable) != 0) && (pGroup->lru.pLruPrev->isAnchor == 0)) && (((pCache->nPage + 1) >= (pCache->nMax)) || ((pcache1UnderMemoryPressure(pCache)) != 0)))
			{
				PCache1* pOther;
				pPage = pGroup->lru.pLruPrev;

				pcache1RemoveFromHash(pPage, (int)(0));
				pcache1PinPage(pPage);
				pOther = pPage->pCache;
				if (pOther->szAlloc != pCache->szAlloc)
				{
					pcache1FreePage(pPage);
					pPage = null;
				}
				else
				{
					pGroup->nPurgeable -= (uint)(pOther->bPurgeable - pCache->bPurgeable);
				}
			}

			if (pPage == null)
			{
				pPage = pcache1AllocPage(pCache, ((createFlag) == (1) ? 1 : 0));
			}

			if ((pPage) != null)
			{
				uint h = (uint)(iKey % pCache->nHash);
				pCache->nPage++;
				pPage->iKey = (uint)(iKey);
				pPage->pNext = pCache->apHash[h];
				pPage->pCache = pCache;
				pPage->pLruNext = null;
				*(void**)(pPage->page.pExtra) = null;
				pCache->apHash[h] = pPage;
				if ((iKey) > (pCache->iMaxKey))
				{
					pCache->iMaxKey = (uint)(iKey);
				}
			}

			return pPage;
		}
		public static void pcache1Free(void* p)
		{
			if ((p) == (null))
				return;
			if (((((ulong)(p)) >= ((ulong)((pcache1_g).pStart))) && (((ulong)(p)) < ((ulong)((pcache1_g).pEnd)))))
			{
				PgFreeslot* pSlot;
				sqlite3_mutex_enter((pcache1_g).mutex);
				sqlite3StatusDown((int)(1), (int)(1));
				pSlot = (PgFreeslot*)(p);
				pSlot->pNext = (pcache1_g).pFree;
				(pcache1_g).pFree = pSlot;
				(pcache1_g).nFreeSlot++;
				(pcache1_g).bUnderPressure = (int)(((pcache1_g).nFreeSlot) < ((pcache1_g).nReserve) ? 1 : 0);

				sqlite3_mutex_leave((pcache1_g).mutex);
			}
			else
			{

				{
					int nFreed = (int)(0);
					nFreed = (int)(sqlite3MallocSize(p));
					sqlite3_mutex_enter((pcache1_g).mutex);
					sqlite3StatusDown((int)(2), (int)(nFreed));
					sqlite3_mutex_leave((pcache1_g).mutex);
				}

				sqlite3_free(p);
			}
		}
		public static void pcache1FreePage(PgHdr1* p)
		{
			PCache1* pCache;

			pCache = p->pCache;

			if ((p->isBulkLocal) != 0)
			{
				p->pNext = pCache->pFree;
				pCache->pFree = p;
			}
			else
			{
				pcache1Free(p->page.pBuf);
			}

			(*pCache->pnPurgeable)--;
		}
		public static int pcache1Init(void* NotUsed)
		{
			(void)(NotUsed);

			CRuntime.memset(&(pcache1_g), (int)(0), (ulong)(sizeof(PCacheGlobal)));
			(pcache1_g).separateCache = (int)(((sqlite3Config.pPage) == (null)) || ((sqlite3Config.bCoreMutex) > (0)) ? 1 : 0);
			if ((sqlite3Config.bCoreMutex) != 0)
			{
				(pcache1_g).grp.mutex = sqlite3MutexAlloc((int)(6));
				(pcache1_g).mutex = sqlite3MutexAlloc((int)(7));
			}

			if (((((pcache1_g).separateCache) != 0) && (sqlite3Config.nPage != 0)) && ((sqlite3Config.pPage) == (null)))
			{
				(pcache1_g).nInitPage = (int)(sqlite3Config.nPage);
			}
			else
			{
				(pcache1_g).nInitPage = (int)(0);
			}

			(pcache1_g).grp.mxPinned = (uint)(10);
			(pcache1_g).isInit = (int)(1);
			return (int)(0);
		}
		public static int pcache1InitBulk(PCache1* pCache)
		{
			long szBulk = 0;
			sbyte* zBulk;
			if (((pcache1_g).nInitPage) == (0))
				return (int)(0);
			if ((pCache->nMax) < (3))
				return (int)(0);
			sqlite3BeginBenignMalloc();
			if (((pcache1_g).nInitPage) > (0))
			{
				szBulk = (long)(pCache->szAlloc * (long)((pcache1_g).nInitPage));
			}
			else
			{
				szBulk = (long)(-1024 * (long)((pcache1_g).nInitPage));
			}

			if ((szBulk) > (pCache->szAlloc * (long)(pCache->nMax)))
			{
				szBulk = (long)(pCache->szAlloc * (long)(pCache->nMax));
			}

			zBulk = pCache->pBulk = sqlite3Malloc((ulong)(szBulk));
			sqlite3EndBenignMalloc();
			if ((zBulk) != null)
			{
				int nBulk = (int)(sqlite3MallocSize(zBulk) / pCache->szAlloc);
				do
				{
					PgHdr1* pX = (PgHdr1*)(&zBulk[pCache->szPage]);
					pX->page.pBuf = zBulk;
					pX->page.pExtra = &pX[1];
					pX->isBulkLocal = (ushort)(1);
					pX->isAnchor = (ushort)(0);
					pX->pNext = pCache->pFree;
					pX->pLruPrev = null;
					pCache->pFree = pX;
					zBulk += pCache->szAlloc;
				}
				while ((--nBulk) != 0);
			}

			return (int)(pCache->pFree != null);
		}
		public static int pcache1Pagecount(sqlite3_pcache* p)
		{
			int n = 0;
			PCache1* pCache = (PCache1*)(p);

			n = (int)(pCache->nPage);

			return (int)(n);
		}
		public static PgHdr1* pcache1PinPage(PgHdr1* pPage)
		{





			pPage->pLruPrev->pLruNext = pPage->pLruNext;
			pPage->pLruNext->pLruPrev = pPage->pLruPrev;
			pPage->pLruNext = null;


			pPage->pCache->nRecyclable--;
			return pPage;
		}
		public static void pcache1Rekey(sqlite3_pcache* p, sqlite3_pcache_page* pPg, uint iOld, uint iNew)
		{
			PCache1* pCache = (PCache1*)(p);
			PgHdr1* pPage = (PgHdr1*)(pPg);
			PgHdr1** pp;
			uint h = 0;



			h = (uint)(iOld % pCache->nHash);
			pp = &pCache->apHash[h];
			while ((*pp) != pPage)
			{
				pp = &(*pp)->pNext;
			}

			*pp = pPage->pNext;
			h = (uint)(iNew % pCache->nHash);
			pPage->iKey = (uint)(iNew);
			pPage->pNext = pCache->apHash[h];
			pCache->apHash[h] = pPage;
			if ((iNew) > (pCache->iMaxKey))
			{
				pCache->iMaxKey = (uint)(iNew);
			}


		}
		public static void pcache1RemoveFromHash(PgHdr1* pPage, int freeFlag)
		{
			uint h = 0;
			PCache1* pCache = pPage->pCache;
			PgHdr1** pp;

			h = (uint)(pPage->iKey % pCache->nHash);
			for (pp = &pCache->apHash[h]; (*pp) != pPage; pp = &(*pp)->pNext)
			{
			}

			*pp = (*pp)->pNext;
			pCache->nPage--;
			if ((freeFlag) != 0)
				pcache1FreePage(pPage);
		}
		public static void pcache1ResizeHash(PCache1* p)
		{
			PgHdr1** apNew;
			uint nNew = 0;
			uint i = 0;

			nNew = (uint)(p->nHash * 2);
			if ((nNew) < (256))
			{
				nNew = (uint)(256);
			}


			if ((p->nHash) != 0)
			{
				sqlite3BeginBenignMalloc();
			}

			apNew = (PgHdr1**)(sqlite3MallocZero((ulong)(sizeof(PgHdr1) * nNew)));
			if ((p->nHash) != 0)
			{
				sqlite3EndBenignMalloc();
			}


			if ((apNew) != null)
			{
				for (i = (uint)(0); (i) < (p->nHash); i++)
				{
					PgHdr1* pPage;
					PgHdr1* pNext = p->apHash[i];
					while ((pPage = pNext) != null)
					{
						uint h = (uint)(pPage->iKey % nNew);
						pNext = pPage->pNext;
						pPage->pNext = apNew[h];
						apNew[h] = pPage;
					}
				}

				sqlite3_free(p->apHash);
				p->apHash = apNew;
				p->nHash = (uint)(nNew);
			}
		}
		public static void pcache1Shrink(sqlite3_pcache* p)
		{
			PCache1* pCache = (PCache1*)(p);
			if ((pCache->bPurgeable) != 0)
			{
				PGroup* pGroup = pCache->pGroup;
				uint savedMaxPage = 0;

				savedMaxPage = (uint)(pGroup->nMaxPage);
				pGroup->nMaxPage = (uint)(0);
				pcache1EnforceMaxPage(pCache);
				pGroup->nMaxPage = (uint)(savedMaxPage);

			}
		}
		public static void pcache1Shutdown(void* NotUsed)
		{
			(void)(NotUsed);

			CRuntime.memset(&(pcache1_g), (int)(0), (ulong)(sizeof(PCacheGlobal)));
		}
		public static void pcache1Truncate(sqlite3_pcache* p, uint iLimit)
		{
			PCache1* pCache = (PCache1*)(p);

			if ((iLimit) <= (pCache->iMaxKey))
			{
				pcache1TruncateUnsafe(pCache, (uint)(iLimit));
				pCache->iMaxKey = (uint)(iLimit - 1);
			}


		}
		public static void pcache1TruncateUnsafe(PCache1* pCache, uint iLimit)
		{
			uint h = 0; uint iStop = 0;



			if ((pCache->iMaxKey - iLimit) < (pCache->nHash))
			{
				h = (uint)(iLimit % pCache->nHash);
				iStop = (uint)(pCache->iMaxKey % pCache->nHash);
			}
			else
			{
				h = (uint)(pCache->nHash / 2);
				iStop = (uint)(h - 1);
			}

			for (; ; )
			{
				PgHdr1** pp;
				PgHdr1* pPage;

				pp = &pCache->apHash[h];
				while ((pPage = *pp) != null)
				{
					if ((pPage->iKey) >= (iLimit))
					{
						pCache->nPage--;
						*pp = pPage->pNext;
						if (((pPage)->pLruNext != null))
							pcache1PinPage(pPage);
						pcache1FreePage(pPage);
					}
					else
					{
						pp = &pPage->pNext;
					}
				}

				if ((h) == (iStop))
					break;
				h = (uint)((h + 1) % pCache->nHash);
			}


		}
		public static int pcache1UnderMemoryPressure(PCache1* pCache)
		{
			if ((((pcache1_g).nSlot) != 0) && ((pCache->szPage + pCache->szExtra) <= ((pcache1_g).szSlot)))
			{
				return (int)((pcache1_g).bUnderPressure);
			}
			else
			{
				return (int)(sqlite3HeapNearlyFull());
			}
		}
		public static void pcache1Unpin(sqlite3_pcache* p, sqlite3_pcache_page* pPg, int reuseUnlikely)
		{
			PCache1* pCache = (PCache1*)(p);
			PgHdr1* pPage = (PgHdr1*)(pPg);
			PGroup* pGroup = pCache->pGroup;




			if (((reuseUnlikely) != 0) || ((pGroup->nPurgeable) > (pGroup->nMaxPage)))
			{
				pcache1RemoveFromHash(pPage, (int)(1));
			}
			else
			{
				PgHdr1** ppFirst = &pGroup->lru.pLruNext;
				pPage->pLruPrev = &pGroup->lru;
				(pPage->pLruNext = *ppFirst)->pLruPrev = pPage;
				*ppFirst = pPage;
				pCache->nRecyclable++;
			}


		}
		public static PgHdr pcacheFetchFinishWithInit(PCache pCache, uint pgno, sqlite3_pcache_page* pPage)
		{
			PgHdr pPgHdr;

			pPgHdr = (PgHdr)(pPage->pExtra);

			CRuntime.memset(pPgHdr.pDirty, (int)(0), (ulong)(sizeof(PgHdr) - ((ulong)((0).pDirty))));
			pPgHdr.pPage = pPage;
			pPgHdr.pData = pPage->pBuf;
			pPgHdr.pExtra = (void*)(pPgHdr[1]);
			CRuntime.memset(pPgHdr.pExtra, (int)(0), (ulong)(8));
			pPgHdr.pCache = pCache;
			pPgHdr.pgno = (uint)(pgno);
			pPgHdr.flags = (ushort)(0x001);
			return sqlite3PcacheFetchFinish(pCache, (uint)(pgno), pPage);
		}
		public static void pcacheManageDirtyList(PgHdr pPage, byte addRemove)
		{
			PCache p = pPage.pCache;
			if ((addRemove & 1) != 0)
			{


				if ((p.pSynced) == (pPage))
				{
					p.pSynced = pPage.pDirtyPrev;
				}

				if ((pPage.pDirtyNext) != null)
				{
					pPage.pDirtyNext.pDirtyPrev = pPage.pDirtyPrev;
				}
				else
				{

					p.pDirtyTail = pPage.pDirtyPrev;
				}

				if ((pPage.pDirtyPrev) != null)
				{
					pPage.pDirtyPrev.pDirtyNext = pPage.pDirtyNext;
				}
				else
				{

					p.pDirty = pPage.pDirtyNext;

					if ((p.pDirty) == (null))
					{

						p.eCreate = (byte)(2);
					}
				}
			}

			if ((addRemove & 2) != 0)
			{
				pPage.pDirtyPrev = null;
				pPage.pDirtyNext = p.pDirty;
				if ((pPage.pDirtyNext) != null)
				{

					pPage.pDirtyNext.pDirtyPrev = pPage;
				}
				else
				{
					p.pDirtyTail = pPage;
					if ((p.bPurgeable) != 0)
					{

						p.eCreate = (byte)(1);
					}
				}

				p.pDirty = pPage;
				if ((p.pSynced == null) && ((0) == (pPage.flags & 0x008)))
				{
					p.pSynced = pPage;
				}
			}
		}
		public static PgHdr pcacheMergeDirtyList(PgHdr pA, PgHdr pB)
		{
			PgHdr result = new PgHdr(); PgHdr pTail;
			pTail = result;

			for (; ; )
			{
				if ((pA.pgno) < (pB.pgno))
				{
					pTail.pDirty = pA;
					pTail = pA;
					pA = pA.pDirty;
					if ((pA) == (null))
					{
						pTail.pDirty = pB;
						break;
					}
				}
				else
				{
					pTail.pDirty = pB;
					pTail = pB;
					pB = pB.pDirty;
					if ((pB) == (null))
					{
						pTail.pDirty = pA;
						break;
					}
				}
			}

			return result.pDirty;
		}
		public static PgHdr pcacheSortDirtyList(PgHdr pIn)
		{
			var a = new PgHdr[32]; a[0] = new PgHdr(); a[1] = new PgHdr(); a[2] = new PgHdr(); a[3] = new PgHdr(); a[4] = new PgHdr(); a[5] = new PgHdr(); a[6] = new PgHdr(); a[7] = new PgHdr(); a[8] = new PgHdr(); a[9] = new PgHdr(); a[10] = new PgHdr(); a[11] = new PgHdr(); a[12] = new PgHdr(); a[13] = new PgHdr(); a[14] = new PgHdr(); a[15] = new PgHdr(); a[16] = new PgHdr(); a[17] = new PgHdr(); a[18] = new PgHdr(); a[19] = new PgHdr(); a[20] = new PgHdr(); a[21] = new PgHdr(); a[22] = new PgHdr(); a[23] = new PgHdr(); a[24] = new PgHdr(); a[25] = new PgHdr(); a[26] = new PgHdr(); a[27] = new PgHdr(); a[28] = new PgHdr(); a[29] = new PgHdr(); a[30] = new PgHdr(); a[31] = new PgHdr(); PgHdr p;
			int i = 0;
			CRuntime.memset(a, (int)(0), (ulong)(32 * sizeof(PgHdr)));
			while ((pIn) != null)
			{
				p = pIn;
				pIn = p.pDirty;
				p.pDirty = null;
				for (i = (int)(0); ((i) < (32 - 1)); i++)
				{
					if ((a[i]) == (null))
					{
						a[i] = p;
						break;
					}
					else
					{
						p = pcacheMergeDirtyList(a[i], p);
						a[i] = null;
					}
				}

				if (((i) == (32 - 1)))
				{
					a[i] = pcacheMergeDirtyList(a[i], p);
				}
			}

			p = a[0];
			for (i = (int)(1); (i) < (32); i++)
			{
				if ((a[i]) == (null))
					continue;
				p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];
			}

			return p;
		}
		public static void pcacheUnpin(PgHdr p)
		{
			if ((p.pCache.bPurgeable) != 0)
			{
				sqlite3Config.pcache2.xUnpin(p.pCache.pCache, p.pPage, (int)(0));
			}
		}
		public static void percent_rankInvFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			(void)(nArg);

			(void)(apArg);
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			p->nStep++;
		}
		public static void percent_rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			(void)(nArg);

			(void)(apArg);
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nTotal++;
			}
		}
		public static void percent_rankValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nValue = (long)(p->nStep);
				if ((p->nTotal) > (1))
				{
					double r = (double)((double)(p->nValue) / (double)(p->nTotal - 1));
					sqlite3_result_double(pCtx, (double)(r));
				}
				else
				{
					sqlite3_result_double(pCtx, (double)(0.0));
				}
			}
		}
		public static void populateCellCache(CellArray p, int idx, int N)
		{

			while ((N) > (0))
			{

				if ((p.szCell[idx]) == (0))
				{
					p.szCell[idx] = (ushort)(p.pRef.xCellSize(p.pRef, p.apCell[idx]));
				}
				else
				{

				}

				idx++;
				N--;
			}
		}
		public static void pragmaFunclistLine(Vdbe v, FuncDef p, int isBuiltin, int showInternFuncs)
		{
			for (p; ; p = p.pNext)
			{
				sbyte* zType;




				if ((p.xSFunc) == (null))
					continue;
				if (((p.funcFlags & 0x00040000) != 0) && ((showInternFuncs) == (0)))
				{
					continue;
				}

				if (p.xValue != null)
				{
					zType = "w";
				}
				else if (p.xFinalize != null)
				{
					zType = "a";
				}
				else
				{
					zType = "s";
				}

				sqlite3VdbeMultiLoad(v, (int)(1), "sissii", p.zName, (int)(isBuiltin), zType, pragmaFunclistLine_azEnc[p.funcFlags & 0x0003], (int)(p.nArg), (uint)((p.funcFlags & pragmaFunclistLine_mask) ^ 0x000200000));
			}
		}
		public static PragmaName* pragmaLocate(sbyte* zName)
		{
			int upr = 0; int lwr = 0; int mid = (int)(0); int rc = 0;
			lwr = (int)(0);
			upr = (int)(((int)(67 * sizeof(PragmaName) / sizeof(PragmaName))) - 1);
			while ((lwr) <= (upr))
			{
				mid = (int)((lwr + upr) / 2);
				rc = (int)(sqlite3_stricmp(zName, aPragmaName[mid].zName));
				if ((rc) == (0))
					break;
				if ((rc) < (0))
				{
					upr = (int)(mid - 1);
				}
				else
				{
					lwr = (int)(mid + 1);
				}
			}

			return (lwr) > (upr) ? null : &aPragmaName[mid];
		}
		public static int pragmaVtabBestIndex(sqlite3_vtab tab, sqlite3_index_info* pIdxInfo)
		{
			PragmaVtab pTab = (PragmaVtab)(tab);
			sqlite3_index_constraint* pConstraint;
			int i = 0; int j = 0;
			int* seen = stackalloc int[2];
			pIdxInfo->estimatedCost = ((double)(1));
			if ((pTab.nHidden) == (0))
			{
				return (int)(0);
			}

			pConstraint = pIdxInfo->aConstraint;
			seen[0] = (int)(0);
			seen[1] = (int)(0);
			for (i = (int)(0); (i) < (pIdxInfo->nConstraint); i++, pConstraint++)
			{
				if ((pConstraint->usable) == (0))
					continue;
				if (pConstraint->op != 2)
					continue;
				if ((pConstraint->iColumn) < (pTab.iHidden))
					continue;
				j = (int)(pConstraint->iColumn - pTab.iHidden);

				seen[j] = (int)(i + 1);
			}

			if ((seen[0]) == (0))
			{
				pIdxInfo->estimatedCost = ((double)(2147483647));
				pIdxInfo->estimatedRows = (long)(2147483647);
				return (int)(0);
			}

			j = (int)(seen[0] - 1);
			pIdxInfo->aConstraintUsage[j].argvIndex = (int)(1);
			pIdxInfo->aConstraintUsage[j].omit = (byte)(1);
			if ((seen[1]) == (0))
				return (int)(0);
			pIdxInfo->estimatedCost = ((double)(20));
			pIdxInfo->estimatedRows = (long)(20);
			j = (int)(seen[1] - 1);
			pIdxInfo->aConstraintUsage[j].argvIndex = (int)(2);
			pIdxInfo->aConstraintUsage[j].omit = (byte)(1);
			return (int)(0);
		}
		public static int pragmaVtabClose(sqlite3_vtab_cursor cur)
		{
			PragmaVtabCursor pCsr = (PragmaVtabCursor)(cur);
			pragmaVtabCursorClear(pCsr);
			sqlite3_free(pCsr);
			return (int)(0);
		}
		public static int pragmaVtabColumn(sqlite3_vtab_cursor pVtabCursor, sqlite3_context ctx, int i)
		{
			PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
			PragmaVtab pTab = (PragmaVtab)(pVtabCursor.pVtab);
			if ((i) < (pTab.iHidden))
			{
				sqlite3_result_value(ctx, sqlite3_column_value(pCsr.pPragma, (int)(i)));
			}
			else
			{
				sqlite3_result_text(ctx, pCsr.azArg[i - pTab.iHidden], (int)(-1), ((Void(Void * ))(-1)));
			}

			return (int)(0);
		}
		public static int pragmaVtabConnect(sqlite3 db, void* pAux, int argc, sbyte** argv, sqlite3_vtab ppVtab, sbyte** pzErr)
		{
			PragmaName* pPragma = (PragmaName*)(pAux);
			PragmaVtab pTab = null;
			int rc = 0;
			int i = 0; int j = 0;
			sbyte cSep = (sbyte)(40);
			sqlite3_str acc = new sqlite3_str();
			sbyte* zBuf = stackalloc sbyte[200];

			(void)(argv);
			sqlite3StrAccumInit(acc, null, zBuf, (int)(200 * sizeof(sbyte)), (int)(0));
			sqlite3_str_appendall(acc, "CREATE TABLE x");
			for (i = (int)(0), j = (int)(pPragma->iPragCName); (i) < (pPragma->nPragCName); i++, j++)
			{
				sqlite3_str_appendf(acc, "%c\"%s\"", (int)(cSep), pragCName[j]);
				cSep = (sbyte)(44);
			}

			if ((i) == (0))
			{
				sqlite3_str_appendf(acc, "(\"%s\"", pPragma->zName);
				i++;
			}

			j = (int)(0);
			if ((pPragma->mPragFlg & 0x20) != 0)
			{
				sqlite3_str_appendall(acc, ",arg HIDDEN");
				j++;
			}

			if ((pPragma->mPragFlg & (0x40 | 0x80)) != 0)
			{
				sqlite3_str_appendall(acc, ",schema HIDDEN");
				j++;
			}

			sqlite3_str_append(acc, ")", (int)(1));
			sqlite3StrAccumFinish(acc);

			rc = (int)(sqlite3_declare_vtab(db, zBuf));
			if ((rc) == (0))
			{
				pTab = (PragmaVtab)(sqlite3_malloc((int)(sizeof(PragmaVtab))));
				if ((pTab) == (null))
				{
					rc = (int)(7);
				}
				else
				{
					CRuntime.memset(pTab, (int)(0), (ulong)(sizeof(PragmaVtab)));
					pTab.pName = pPragma;
					pTab.db = db;
					pTab.iHidden = (byte)(i);
					pTab.nHidden = (byte)(j);
				}
			}
			else
			{
				*pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
			}

			ppVtab = (sqlite3_vtab)(pTab);
			return (int)(rc);
		}
		public static void pragmaVtabCursorClear(PragmaVtabCursor pCsr)
		{
			int i = 0;
			sqlite3_finalize(pCsr.pPragma);
			pCsr.pPragma = null;
			for (i = (int)(0); (i) < ((int)(2 * sizeof(sbyte) / sizeof(sbyte*))); i++)
			{
				sqlite3_free(pCsr.azArg[i]);
				pCsr.azArg[i] = null;
			}
		}
		public static int pragmaVtabDisconnect(sqlite3_vtab pVtab)
		{
			PragmaVtab pTab = (PragmaVtab)(pVtab);
			sqlite3_free(pTab);
			return (int)(0);
		}
		public static int pragmaVtabEof(sqlite3_vtab_cursor pVtabCursor)
		{
			PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
			return (((pCsr.pPragma) == (null)) ? 1 : 0);
		}
		public static int pragmaVtabFilter(sqlite3_vtab_cursor pVtabCursor, int idxNum, sbyte* idxStr, int argc, sqlite3_value argv)
		{
			PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
			PragmaVtab pTab = (PragmaVtab)(pVtabCursor.pVtab);
			int rc = 0;
			int i = 0; int j = 0;
			sqlite3_str acc = new sqlite3_str();
			sbyte* zSql;
			(void)(idxNum);
			(void)(idxStr);
			pragmaVtabCursorClear(pCsr);
			j = (int)((pTab.pName->mPragFlg & 0x20) != 0 ? 0 : 1);
			for (i = (int)(0); (i) < (argc); i++, j++)
			{
				sbyte* zText = (sbyte*)(sqlite3_value_text(argv[i]));


				if ((zText) != null)
				{
					pCsr.azArg[j] = sqlite3_mprintf("%s", zText);
					if ((pCsr.azArg[j]) == (null))
					{
						return (int)(7);
					}
				}
			}

			sqlite3StrAccumInit(acc, null, null, (int)(0), (int)(pTab.db.aLimit[1]));
			sqlite3_str_appendall(acc, "PRAGMA ");
			if ((pCsr.azArg[1]) != null)
			{
				sqlite3_str_appendf(acc, "%Q.", pCsr.azArg[1]);
			}

			sqlite3_str_appendall(acc, pTab.pName->zName);
			if ((pCsr.azArg[0]) != null)
			{
				sqlite3_str_appendf(acc, "=%Q", pCsr.azArg[0]);
			}

			zSql = sqlite3StrAccumFinish(acc);
			if ((zSql) == (null))
				return (int)(7);
			rc = (int)(sqlite3_prepare_v2(pTab.db, zSql, (int)(-1), &pCsr.pPragma, null));
			sqlite3_free(zSql);
			if (rc != 0)
			{
				pTab._base_.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab.db));
				return (int)(rc);
			}

			return (int)(pragmaVtabNext(pVtabCursor));
		}
		public static int pragmaVtabNext(sqlite3_vtab_cursor pVtabCursor)
		{
			PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
			int rc = (int)(0);
			pCsr.iRowid++;

			if (100 != sqlite3_step(pCsr.pPragma))
			{
				rc = (int)(sqlite3_finalize(pCsr.pPragma));
				pCsr.pPragma = null;
				pragmaVtabCursorClear(pCsr);
			}

			return (int)(rc);
		}
		public static int pragmaVtabOpen(sqlite3_vtab pVtab, sqlite3_vtab_cursor ppCursor)
		{
			PragmaVtabCursor pCsr;
			pCsr = (PragmaVtabCursor)(sqlite3_malloc((int)(sizeof(PragmaVtabCursor))));
			if ((pCsr) == (null))
				return (int)(7);
			CRuntime.memset(pCsr, (int)(0), (ulong)(sizeof(PragmaVtabCursor)));
			pCsr._base_.pVtab = pVtab;
			ppCursor = pCsr._base_;
			return (int)(0);
		}
		public static int pragmaVtabRowid(sqlite3_vtab_cursor pVtabCursor, long* p)
		{
			PragmaVtabCursor pCsr = (PragmaVtabCursor)(pVtabCursor);
			*p = (long)(pCsr.iRowid);
			return (int)(0);
		}
		public static void preserveExpr(IdxExprTrans pTrans, Expr pExpr)
		{
			WhereExprMod pNew;
			pNew = sqlite3DbMallocRaw(pTrans.db, (ulong)(sizeof(WhereExprMod)));
			if ((pNew) == (null))
				return;
			pNew.pNext = pTrans.pWInfo.pExprMods;
			pTrans.pWInfo.pExprMods = pNew;
			pNew.pExpr = pExpr;
			CRuntime.memcpy(pNew.orig, pExpr, (ulong)(sizeof(Expr)));
		}
		public static void printfFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			PrintfArguments x = new PrintfArguments();
			sqlite3_str str = new sqlite3_str();
			sbyte* zFormat;
			int n = 0;
			sqlite3 db = sqlite3_context_db_handle(context);
			if (((argc) >= (1)) && ((zFormat = (sbyte*)(sqlite3_value_text(argv[0]))) != null))
			{
				x.nArg = (int)(argc - 1);
				x.nUsed = (int)(0);
				x.apArg = argv[1];
				sqlite3StrAccumInit(str, db, null, (int)(0), (int)(db.aLimit[0]));
				str.printfFlags = (byte)(0x02);
				sqlite3_str_appendf(str, zFormat, x);
				n = (int)(str.nChar);
				sqlite3_result_text(context, sqlite3StrAccumFinish(str), (int)(n), ((Void(Void * ))(sqlite3OomFault)));
			}
		}
		public static sbyte* printfTempBuf(sqlite3_str pAccum, long n)
		{
			sbyte* z;
			if ((pAccum.accError) != 0)
				return null;
			if (((n) > (pAccum.nAlloc)) && ((n) > (pAccum.mxAlloc)))
			{
				sqlite3StrAccumSetError(pAccum, (byte)(18));
				return null;
			}

			z = sqlite3DbMallocRaw(pAccum.db, (ulong)(n));
			if ((z) == (null))
			{
				sqlite3StrAccumSetError(pAccum, (byte)(7));
			}

			return z;
		}
		public static int propagateConstantExprRewrite(Walker pWalker, Expr pExpr)
		{
			WhereConst pConst = pWalker.u.pConst;




			if ((pConst.bHasAffBlob) != 0)
			{
				if ((((pExpr.op) >= (53)) && ((pExpr.op) <= (57))) || ((pExpr.op) == (45)))
				{
					propagateConstantExprRewriteOne(pConst, pExpr.pLeft, (int)(0));
					if ((pConst.pOomFault[0]) != 0)
						return (int)(1);
					if (sqlite3ExprAffinity(pExpr.pLeft) != 0x42)
					{
						propagateConstantExprRewriteOne(pConst, pExpr.pRight, (int)(0));
					}
				}
			}

			return (int)(propagateConstantExprRewriteOne(pConst, pExpr, (int)(pConst.bHasAffBlob)));
		}
		public static int propagateConstantExprRewriteOne(WhereConst pConst, Expr pExpr, int bIgnoreAffBlob)
		{
			int i = 0;
			if ((pConst.pOomFault[0]) != 0)
				return (int)(1);
			if (pExpr.op != 167)
				return (int)(0);
			if ((((pExpr).flags & (0x000008 | 0x000001)) != 0))
			{
				return (int)(0);
			}

			for (i = (int)(0); (i) < (pConst.nConst); i++)
			{
				Expr pColumn = pConst.apExpr[i * 2];
				if ((pColumn) == (pExpr))
					continue;
				if (pColumn.iTable != pExpr.iTable)
					continue;
				if (pColumn.iColumn != pExpr.iColumn)
					continue;
				if (((bIgnoreAffBlob) != 0) && ((sqlite3ExprAffinity(pColumn)) == (0x41)))
				{
					break;
				}

				pConst.nChng++;
				(pExpr).flags &= (uint)(~(0x800000));
				(pExpr).flags |= (uint)(0x000008);

				pExpr.pLeft = sqlite3ExprDup(pConst.pParse.db, pConst.apExpr[i * 2 + 1], (int)(0));
				if ((pConst.pParse.db.mallocFailed) != 0)
					return (int)(1);
				break;
			}

			return (int)(1);
		}
		public static int propagateConstants(Parse pParse, Select p)
		{
			WhereConst x = new WhereConst();
			Walker w = new Walker();
			int nChng = (int)(0);
			x.pParse = pParse;
			x.pOomFault = &pParse.db.mallocFailed;
			do
			{
				x.nConst = (int)(0);
				x.nChng = (int)(0);
				x.apExpr = null;
				x.bHasAffBlob = (int)(0);
				findConstInWhere(x, p.pWhere);
				if ((x.nConst) != 0)
				{
					CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
					w.pParse = pParse;
					w.xExprCallback = propagateConstantExprRewrite;
					w.xSelectCallback = sqlite3SelectWalkNoop;
					w.xSelectCallback2 = null;
					w.walkerDepth = (int)(0);
					w.u.pConst = x;
					sqlite3WalkExpr(w, p.pWhere);
					sqlite3DbFree(x.pParse.db, x.apExpr);
					nChng += (int)(x.nChng);
				}
			}
			while ((x.nChng) != 0);
			return (int)(nChng);
		}
		public static int ptrmapGet(BtShared pBt, uint key, byte* pEType, uint* pPgno)
		{
			PgHdr pDbPage;
			int iPtrmap = 0;
			byte* pPtrmap;
			int offset = 0;
			int rc = 0;

			iPtrmap = (int)(ptrmapPageno(pBt, (uint)(key)));
			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(iPtrmap), pDbPage, (int)(0)));
			if (rc != 0)
			{
				return (int)(rc);
			}

			pPtrmap = (byte*)(sqlite3PagerGetData(pDbPage));
			offset = (int)(5 * (key - iPtrmap - 1));
			if ((offset) < (0))
			{
				sqlite3PagerUnref(pDbPage);
				return (int)(sqlite3CorruptError((int)(67228)));
			}



			*pEType = (byte)(pPtrmap[offset]);
			if ((pPgno) != null)
				*pPgno = (uint)(sqlite3Get4byte(&pPtrmap[offset + 1]));
			sqlite3PagerUnref(pDbPage);
			if (((*pEType) < (1)) || ((*pEType) > (5)))
				return (int)(sqlite3CorruptError((int)(67236)));
			return (int)(0);
		}
		public static uint ptrmapPageno(BtShared pBt, uint pgno)
		{
			int nPagesPerMapPage = 0;
			uint iPtrMap = 0; uint ret = 0;

			if ((pgno) < (2))
				return (uint)(0);
			nPagesPerMapPage = (int)((pBt.usableSize / 5) + 1);
			iPtrMap = (uint)((pgno - 2) / nPagesPerMapPage);
			ret = (uint)((iPtrMap * nPagesPerMapPage) + 2);
			if ((ret) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
			{
				ret++;
			}

			return (uint)(ret);
		}
		public static void ptrmapPut(BtShared pBt, uint key, byte eType, uint parent, int* pRC)
		{
			PgHdr pDbPage;
			byte* pPtrmap;
			uint iPtrmap = 0;
			int offset = 0;
			int rc = 0;
			if ((*pRC) != 0)
				return;



			if ((key) == (0))
			{
				*pRC = (int)(sqlite3CorruptError((int)(67165)));
				return;
			}

			iPtrmap = (uint)(ptrmapPageno(pBt, (uint)(key)));
			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(iPtrmap), pDbPage, (int)(0)));
			if (rc != 0)
			{
				*pRC = (int)(rc);
				return;
			}

			if (((sbyte*)(sqlite3PagerGetExtra(pDbPage)))[0] != 0)
			{
				*pRC = (int)(sqlite3CorruptError((int)(67178)));
				goto ptrmap_exit;
			}

			offset = (int)(5 * (key - iPtrmap - 1));
			if ((offset) < (0))
			{
				*pRC = (int)(sqlite3CorruptError((int)(67183)));
				goto ptrmap_exit;
			}


			pPtrmap = (byte*)(sqlite3PagerGetData(pDbPage));
			if ((eType != pPtrmap[offset]) || (sqlite3Get4byte(&pPtrmap[offset + 1]) != parent))
			{
				*pRC = (int)(rc = (int)(sqlite3PagerWrite(pDbPage)));
				if ((rc) == (0))
				{
					pPtrmap[offset] = (byte)(eType);
					sqlite3Put4byte(&pPtrmap[offset + 1], (uint)(parent));
				}
			}

		ptrmap_exit:
			; sqlite3PagerUnref(pDbPage);
		}
		public static void ptrmapPutOvflPtr(MemPage pPage, MemPage pSrc, byte* pCell, int* pRC)
		{
			CellInfo info = new CellInfo();
			if ((*pRC) != 0)
				return;

			pPage.xParseCell(pPage, pCell, &info);
			if ((info.nLocal) < (info.nPayload))
			{
				uint ovfl = 0;
				if (((((ulong)(pSrc.aDataEnd)) >= ((ulong)(pCell))) && (((ulong)(pSrc.aDataEnd)) < ((ulong)(pCell + info.nLocal)))))
				{
					*pRC = (int)(sqlite3CorruptError((int)(67582)));
					return;
				}

				ovfl = (uint)(sqlite3Get4byte(&pCell[info.nSize - 4]));
				ptrmapPut(pPage.pBt, (uint)(ovfl), (byte)(3), (uint)(pPage.pgno), pRC);
			}
		}
		public static int pushDownWhereTerms(Parse pParse, Select pSubq, Expr pWhere, int iCursor, int isLeftJoin)
		{
			Expr pNew;
			int nChng = (int)(0);
			if ((pWhere) == (null))
				return (int)(0);
			if ((pSubq.selFlags & (0x0002000 | 0x2000000)) != 0)
				return (int)(0);
			if ((pSubq.pPrior) != null)
			{
				Select pSel;
				for (pSel = pSubq; pSel; pSel = pSel.pPrior)
				{
					if ((pSel.pWin) != null)
						return (int)(0);
				}
			}
			else
			{
				if (((pSubq.pWin) != null) && ((pSubq.pWin.pPartition) == (null)))
					return (int)(0);
			}

			if (pSubq.pLimit != null)
			{
				return (int)(0);
			}

			while ((pWhere.op) == (44))
			{
				nChng += (int)(pushDownWhereTerms(pParse, pSubq, pWhere.pRight, (int)(iCursor), (int)(isLeftJoin)));
				pWhere = pWhere.pLeft;
			}

			if (((isLeftJoin) != 0) && (((((pWhere).flags & (0x000001)) != 0) == (0)) || (pWhere.w.iRightJoinTable != iCursor)))
			{
				return (int)(0);
			}

			if ((((pWhere).flags & (0x000001)) != 0) && (pWhere.w.iRightJoinTable != iCursor))
			{
				return (int)(0);
			}

			if ((sqlite3ExprIsTableConstant(pWhere, (int)(iCursor))) != 0)
			{
				nChng++;
				pSubq.selFlags |= (uint)(0x1000000);
				while ((pSubq) != null)
				{
					SubstContext x = new SubstContext();
					pNew = sqlite3ExprDup(pParse.db, pWhere, (int)(0));
					unsetJoinExpr(pNew, (int)(-1));
					x.pParse = pParse;
					x.iTable = (int)(iCursor);
					x.iNewTable = (int)(iCursor);
					x.isLeftJoin = (int)(0);
					x.pEList = pSubq.pEList;
					pNew = substExpr(x, pNew);
					if (((pSubq.pWin) != null) && ((0) == (pushDownWindowCheck(pParse, pSubq, pNew))))
					{
						sqlite3ExprDelete(pParse.db, pNew);
						nChng--;
						break;
					}

					if ((pSubq.selFlags & 0x0000008) != 0)
					{
						pSubq.pHaving = sqlite3ExprAnd(pParse, pSubq.pHaving, pNew);
					}
					else
					{
						pSubq.pWhere = sqlite3ExprAnd(pParse, pSubq.pWhere, pNew);
					}

					pSubq = pSubq.pPrior;
				}
			}

			return (int)(nChng);
		}
		public static int pushDownWindowCheck(Parse pParse, Select pSubq, Expr pExpr)
		{



			return (int)(sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq.pWin.pPartition));
		}
		public static void pushOntoSorter(Parse pParse, SortCtx pSort, Select pSelect, int regData, int regOrigData, int nData, int nPrefixReg)
		{
			Vdbe v = pParse.pVdbe;
			int bSeq = (int)(((pSort.sortFlags & 0x01) == (0)) ? 1 : 0);
			int nExpr = (int)(pSort.pOrderBy.nExpr);
			int nBase = (int)(nExpr + bSeq + nData);
			int regBase = 0;
			int regRecord = (int)(0);
			int nOBSat = (int)(pSort.nOBSat);
			int op = 0;
			int iLimit = 0;
			int iSkip = (int)(0);


			if ((nPrefixReg) != 0)
			{

				regBase = (int)(regData - nPrefixReg);
			}
			else
			{
				regBase = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nBase);
			}


			iLimit = (int)((pSelect.iOffset) != 0 ? pSelect.iOffset + 1 : pSelect.iLimit);
			pSort.labelDone = (int)(sqlite3VdbeMakeLabel(pParse));
			sqlite3ExprCodeExprList(pParse, pSort.pOrderBy, (int)(regBase), (int)(regOrigData), (byte)(0x01 | ((regOrigData) != 0 ? 0x04 : 0)));
			if ((bSeq) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(125), (int)(pSort.iECursor), (int)(regBase + nExpr));
			}

			if (((nPrefixReg) == (0)) && ((nData) > (0)))
			{
				sqlite3ExprCodeMove(pParse, (int)(regData), (int)(regBase + nExpr + bSeq), (int)(nData));
			}

			if ((nOBSat) > (0))
			{
				int regPrevKey = 0;
				int addrFirst = 0;
				int addrJmp = 0;
				VdbeOp* pOp;
				int nKey = 0;
				KeyInfo pKI;
				regRecord = (int)(makeSorterRecord(pParse, pSort, pSelect, (int)(regBase), (int)(nBase)));
				regPrevKey = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(pSort.nOBSat);
				nKey = (int)(nExpr - pSort.nOBSat + bSeq);
				if ((bSeq) != 0)
				{
					addrFirst = (int)(sqlite3VdbeAddOp1(v, (int)(20), (int)(regBase + nExpr)));
				}
				else
				{
					addrFirst = (int)(sqlite3VdbeAddOp1(v, (int)(119), (int)(pSort.iECursor)));
				}

				sqlite3VdbeAddOp3(v, (int)(89), (int)(regPrevKey), (int)(regBase), (int)(pSort.nOBSat));
				pOp = sqlite3VdbeGetOp(v, (int)(pSort.addrSortIndex));
				if ((pParse.db.mallocFailed) != 0)
					return;
				pOp->p2 = (int)(nKey + nData);
				pKI = pOp->p4.pKeyInfo;
				CRuntime.memset(pKI.aSortFlags, (int)(0), (ulong)(pKI.nKeyField));
				sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pKI), (int)(-9));
				pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pSort.pOrderBy, (int)(nOBSat), (int)(pKI.nAllField - pKI.nKeyField - 1));
				pOp = null;
				addrJmp = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3VdbeAddOp3(v, (int)(16), (int)(addrJmp + 1), (int)(0), (int)(addrJmp + 1));
				pSort.labelBkOut = (int)(sqlite3VdbeMakeLabel(pParse));
				pSort.regReturn = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(12), (int)(pSort.regReturn), (int)(pSort.labelBkOut));
				sqlite3VdbeAddOp1(v, (int)(145), (int)(pSort.iECursor));
				if ((iLimit) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(20), (int)(iLimit), (int)(pSort.labelDone));
				}

				sqlite3VdbeJumpHere(v, (int)(addrFirst));
				sqlite3ExprCodeMove(pParse, (int)(regBase), (int)(regPrevKey), (int)(pSort.nOBSat));
				sqlite3VdbeJumpHere(v, (int)(addrJmp));
			}

			if ((iLimit) != 0)
			{
				int iCsr = (int)(pSort.iECursor);
				sqlite3VdbeAddOp2(v, (int)(59), (int)(iLimit), (int)(sqlite3VdbeCurrentAddr(v) + 4));
				sqlite3VdbeAddOp2(v, (int)(34), (int)(iCsr), (int)(0));
				iSkip = (int)(sqlite3VdbeAddOp4Int(v, (int)(39), (int)(iCsr), (int)(0), (int)(regBase + nOBSat), (int)(nExpr - nOBSat)));
				sqlite3VdbeAddOp1(v, (int)(129), (int)(iCsr));
			}

			if ((regRecord) == (0))
			{
				regRecord = (int)(makeSorterRecord(pParse, pSort, pSelect, (int)(regBase), (int)(nBase)));
			}

			if ((pSort.sortFlags & 0x01) != 0)
			{
				op = (int)(138);
			}
			else
			{
				op = (int)(137);
			}

			sqlite3VdbeAddOp4Int(v, (int)(op), (int)(pSort.iECursor), (int)(regRecord), (int)(regBase + nOBSat), (int)(nBase - nOBSat));
			if ((iSkip) != 0)
			{
				sqlite3VdbeChangeP2(v, (int)(iSkip), (int)((pSort.labelOBLopt) != 0 ? pSort.labelOBLopt : sqlite3VdbeCurrentAddr(v)));
			}
		}
		public static int putVarint64(byte* p, ulong v)
		{
			int i = 0; int j = 0; int n = 0;
			byte* buf = stackalloc byte[10];
			if ((v & (((ulong)(0xff000000)) << 32)) != 0)
			{
				p[8] = ((byte)(v));
				v >>= 8;
				for (i = (int)(7); (i) >= (0); i--)
				{
					p[i] = ((byte)((v & 0x7f) | 0x80));
					v >>= 7;
				}

				return (int)(9);
			}

			n = (int)(0);
			do
			{
				buf[n++] = ((byte)((v & 0x7f) | 0x80));
				v >>= 7;
			}
			while (v != 0);
			buf[0] &= (byte)(0x7f);

			for (i = (int)(0), j = (int)(n - 1); (j) >= (0); j--, i++)
			{
				p[i] = (byte)(buf[j]);
			}

			return (int)(n);
		}
		public static int querySharedCacheTableLock(Btree p, uint iTab, byte eLock)
		{
			BtShared pBt = p.pBt;
			BtLock pIter;






			if (p.sharable == 0)
			{
				return (int)(0);
			}

			if ((pBt.pWriter != p) && ((pBt.btsFlags & 0x0040) != 0))
			{
				return (int)(6 | (1 << 8));
			}

			for (pIter = pBt.pLock; pIter; pIter = pIter.pNext)
			{


				if (((pIter.pBtree != p) && ((pIter.iTable) == (iTab))) && (pIter.eLock != eLock))
				{
					if ((eLock) == (2))
					{

						pBt.btsFlags |= (ushort)(0x0080);
					}

					return (int)(6 | (1 << 8));
				}
			}

			return (int)(0);
		}
		public static void quoteFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sqlite3_str str = new sqlite3_str();
			sqlite3 db = sqlite3_context_db_handle(context);


			sqlite3StrAccumInit(str, db, null, (int)(0), (int)(db.aLimit[0]));
			sqlite3QuoteValue(str, argv[0]);
			sqlite3_result_text(context, sqlite3StrAccumFinish(str), (int)(str.nChar), ((Void(Void * ))(sqlite3OomFault)));
			if (str.accError != 0)
			{
				sqlite3_result_null(context);
				sqlite3_result_error_code(context, (int)(str.accError));
			}
		}
		public static void randomBlob(sqlite3_context context, int argc, sqlite3_value argv)
		{
			long n = 0;
			byte* p;


			n = (long)(sqlite3_value_int64(argv[0]));
			if ((n) < (1))
			{
				n = (long)(1);
			}

			p = contextMalloc(context, (long)(n));
			if ((p) != null)
			{
				sqlite3_randomness((int)(n), p);
				sqlite3_result_blob(context, (sbyte*)(p), (int)(n), sqlite3_free);
			}
		}
		public static void randomFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			long r = 0;
			(void)(NotUsed) ,  (void)(NotUsed2);
			sqlite3_randomness((int)(sizeof(long)), &r);
			if ((r) < (0))
			{
				r = (long)(-(r & (0xffffffff | (((long)(0x7fffffff)) << 32))));
			}

			sqlite3_result_int64(context, (long)(r));
		}
		public static void rankStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				p->nStep++;
				if ((p->nValue) == (0))
				{
					p->nValue = (long)(p->nStep);
				}
			}

			(void)(nArg);
			(void)(apArg);
		}
		public static void rankValueFunc(sqlite3_context pCtx)
		{
			CallCount* p;
			p = (CallCount*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(CallCount))));
			if ((p) != null)
			{
				sqlite3_result_int64(pCtx, (long)(p->nValue));
				p->nValue = (long)(0);
			}
		}
		public static int read32bits(sqlite3_file fd, long offset, uint* pRes)
		{
			byte* ac = stackalloc byte[4];
			int rc = (int)(sqlite3OsRead(fd, ac, (int)(4 * sizeof(byte)), (long)(offset)));
			if ((rc) == (0))
			{
				*pRes = (uint)(sqlite3Get4byte(ac));
			}

			return (int)(rc);
		}
		public static int readDbPage(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;
			int rc = (int)(0);
			uint iFrame = (uint)(0);


			if (((pPager).pWal != null))
			{
				rc = (int)(sqlite3WalFindFrame(pPager.pWal, (uint)(pPg.pgno), &iFrame));
				if ((rc) != 0)
					return (int)(rc);
			}

			if ((iFrame) != 0)
			{
				rc = (int)(sqlite3WalReadFrame(pPager.pWal, (uint)(iFrame), (int)(pPager.pageSize), pPg.pData));
			}
			else
			{
				long iOffset = (long)((pPg.pgno - 1) * pPager.pageSize);
				rc = (int)(sqlite3OsRead(pPager.fd, pPg.pData, (int)(pPager.pageSize), (long)(iOffset)));
				if ((rc) == (10 | (2 << 8)))
				{
					rc = (int)(0);
				}
			}

			if ((pPg.pgno) == (1))
			{
				if ((rc) != 0)
				{
					CRuntime.memset(pPager.dbFileVers, (int)(0xff), (ulong)(16 * sizeof(sbyte)));
				}
				else
				{
					byte* dbFileVers = &((byte*)(pPg.pData))[24];
					CRuntime.memcpy(&pPager.dbFileVers, dbFileVers, (ulong)(16 * sizeof(sbyte)));
				}
			}

			return (int)(rc);
		}
		public static int readJournalHdr(Pager pPager, int isHot, long journalSize, uint* pNRec, uint* pDbSize)
		{
			int rc = 0;
			byte* aMagic = stackalloc byte[8];
			long iHdrOff = 0;

			pPager.journalOff = (long)(journalHdrOffset(pPager));
			if ((pPager.journalOff + (pPager.sectorSize)) > (journalSize))
			{
				return (int)(101);
			}

			iHdrOff = (long)(pPager.journalOff);
			if (((isHot) != 0) || (iHdrOff != pPager.journalHdr))
			{
				rc = (int)(sqlite3OsRead(pPager.jfd, aMagic, (int)(8 * sizeof(byte)), (long)(iHdrOff)));
				if ((rc) != 0)
				{
					return (int)(rc);
				}

				if (memcmp(aMagic, aJournalMagic, (ulong)(8 * sizeof(byte))) != 0)
				{
					return (int)(101);
				}
			}

			if (((0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 8), pNRec)))) || (0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 12), &pPager.cksumInit))))) || (0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 16), pDbSize)))))
			{
				return (int)(rc);
			}

			if ((pPager.journalOff) == (0))
			{
				uint iPageSize = 0;
				uint iSectorSize = 0;
				if ((0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 20), &iSectorSize)))) || (0 != (rc = (int)(read32bits(pPager.jfd, (long)(iHdrOff + 24), &iPageSize)))))
				{
					return (int)(rc);
				}

				if ((iPageSize) == (0))
				{
					iPageSize = (uint)(pPager.pageSize);
				}

				if (((((((iPageSize) < (512)) || ((iSectorSize) < (32))) || ((iPageSize) > (65536))) || ((iSectorSize) > (0x10000))) || (((iPageSize - 1) & iPageSize) != 0)) || (((iSectorSize - 1) & iSectorSize) != 0))
				{
					return (int)(101);
				}

				rc = (int)(sqlite3PagerSetPagesize(pPager, &iPageSize, (int)(-1)));
				pPager.sectorSize = (uint)(iSectorSize);
			}

			pPager.journalOff += (long)(pPager.sectorSize);
			return (int)(rc);
		}
		public static int readsTable(Parse p, int iDb, Table pTab)
		{
			Vdbe v = sqlite3GetVdbe(p);
			int i = 0;
			int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
			VTable pVTab = (((pTab).eTabType) == (1)) ? sqlite3GetVTable(p.db, pTab) : null;
			for (i = (int)(1); (i) < (iEnd); i++)
			{
				VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(i));

				if (((pOp->opcode) == (101)) && ((pOp->p3) == (iDb)))
				{
					Index pIndex;
					uint tnum = (uint)(pOp->p2);
					if ((tnum) == (pTab.tnum))
					{
						return (int)(1);
					}

					for (pIndex = pTab.pIndex; pIndex; pIndex = pIndex.pNext)
					{
						if ((tnum) == (pIndex.tnum))
						{
							return (int)(1);
						}
					}
				}

				if (((pOp->opcode) == (172)) && ((pOp->p4.pVtab) == (pVTab)))
				{


					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int readSuperJournal(sqlite3_file pJrnl, sbyte* zSuper, uint nSuper)
		{
			int rc = 0;
			uint len = 0;
			long szJ = 0;
			uint cksum = 0;
			uint u = 0;
			byte* aMagic = stackalloc byte[8];
			zSuper[0] = (sbyte)(0);
			if ((((((((((0 != (rc = (int)(sqlite3OsFileSize(pJrnl, &szJ)))) || ((szJ) < (16))) || (0 != (rc = (int)(read32bits(pJrnl, (long)(szJ - 16), &len))))) || ((len) >= (nSuper))) || ((len) > (szJ - 16))) || ((len) == (0))) || (0 != (rc = (int)(read32bits(pJrnl, (long)(szJ - 12), &cksum))))) || (0 != (rc = (int)(sqlite3OsRead(pJrnl, aMagic, (int)(8), (long)(szJ - 8)))))) || ((memcmp(aMagic, aJournalMagic, (ulong)(8))) != 0)) || (0 != (rc = (int)(sqlite3OsRead(pJrnl, zSuper, (int)(len), (long)(szJ - 16 - len))))))
			{
				return (int)(rc);
			}

			for (u = (uint)(0); (u) < (len); u++)
			{
				cksum -= (uint)(zSuper[u]);
			}

			if ((cksum) != 0)
			{
				len = (uint)(0);
			}

			zSuper[len] = (sbyte)(0);
			zSuper[len + 1] = (sbyte)(0);
			return (int)(0);
		}
		public static int rebuildPage(CellArray pCArray, int iFirst, int nCell, MemPage pPg)
		{
			int hdr = (int)(pPg.hdrOffset);
			byte* aData = pPg.aData;
			int usableSize = (int)(pPg.pBt.usableSize);
			byte* pEnd = &aData[usableSize];
			int i = (int)(iFirst);
			uint j = 0;
			int iEnd = (int)(i + nCell);
			byte* pCellptr = pPg.aCellIdx;
			byte* pTmp = sqlite3PagerTempSpace(pPg.pBt.pPager);
			byte* pData;
			int k = 0;
			byte* pSrcEnd;

			j = (uint)((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1]);
			if ((j) > ((uint)(usableSize)))
			{
				j = (uint)(0);
			}

			CRuntime.memcpy(&pTmp[j], &aData[j], (ulong)(usableSize - j));
			for (k = (int)(0); ((pCArray.ixNx[k]) <= (i)) && ((k) < (3 * 2)); k++)
			{
			}

			pSrcEnd = pCArray.apEnd[k];
			pData = pEnd;
			while ((1) != 0)
			{
				byte* pCell = pCArray.apCell[i];
				ushort sz = (ushort)(pCArray.szCell[i]);

				if (((((ulong)(pCell)) >= ((ulong)(aData + j))) && (((ulong)(pCell)) < ((ulong)(pEnd)))))
				{
					if (((ulong)(pCell + sz)) > ((ulong)(pEnd)))
						return (int)(sqlite3CorruptError((int)(73314)));
					pCell = &pTmp[pCell - aData];
				}
				else if ((((ulong)(pCell + sz)) > ((ulong)(pSrcEnd))) && (((ulong)(pCell)) < ((ulong)(pSrcEnd))))
				{
					return (int)(sqlite3CorruptError((int)(73319)));
				}

				pData -= sz;
				((pCellptr)[0] = ((byte)((pData - aData) >> 8)), (pCellptr)[1] = ((byte)(pData - aData)));
				pCellptr += 2;
				if ((pData) < (pCellptr))
					return (int)(sqlite3CorruptError((int)(73325)));
				CRuntime.memmove(pData, pCell, (ulong)(sz));

				i++;
				if ((i) >= (iEnd))
					break;
				if ((pCArray.ixNx[k]) <= (i))
				{
					k++;
					pSrcEnd = pCArray.apEnd[k];
				}
			}

			pPg.nCell = (ushort)(nCell);
			pPg.nOverflow = (byte)(0);
			((&aData[hdr + 1])[0] = ((byte)((0) >> 8)), (&aData[hdr + 1])[1] = ((byte)(0)));
			((&aData[hdr + 3])[0] = ((byte)((pPg.nCell) >> 8)), (&aData[hdr + 3])[1] = ((byte)(pPg.nCell)));
			((&aData[hdr + 5])[0] = ((byte)((pData - aData) >> 8)), (&aData[hdr + 5])[1] = ((byte)(pData - aData)));
			aData[hdr + 7] = (byte)(0x00);
			return (int)(0);
		}
		public static void recomputeColumnsNotIndexed(Index pIdx)
		{
			ulong m = (ulong)(0);
			int j = 0;
			Table pTab = pIdx.pTable;
			for (j = (int)(pIdx.nColumn - 1); (j) >= (0); j--)
			{
				int x = (int)(pIdx.aiColumn[j]);
				if (((x) >= (0)) && ((pTab.aCol[x].colFlags & 0x0020) == (0)))
				{
					if ((x) < (((int)(sizeof(ulong) * 8)) - 1))
						m |= (ulong)(((ulong)(1)) << (x));
				}
			}

			pIdx.colNotIdxed = (ulong)(~m);

		}
		public static void recomputeColumnsUsed(Select pSelect, SrcItem pSrcItem)
		{
			Walker w = new Walker();
			if (((pSrcItem.pTab) == (null)))
				return;
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			w.xExprCallback = recomputeColumnsUsedExpr;
			w.xSelectCallback = sqlite3SelectWalkNoop;
			w.u.pSrcItem = pSrcItem;
			pSrcItem.colUsed = (ulong)(0);
			sqlite3WalkSelect(w, pSelect);
		}
		public static int recomputeColumnsUsedExpr(Walker pWalker, Expr pExpr)
		{
			SrcItem pItem;
			if (pExpr.op != 167)
				return (int)(0);
			pItem = pWalker.u.pSrcItem;
			if (pItem.iCursor != pExpr.iTable)
				return (int)(0);
			if ((pExpr.iColumn) < (0))
				return (int)(0);
			pItem.colUsed |= (ulong)(sqlite3ExprColUsed(pExpr));
			return (int)(0);
		}
		public static int rehash(Hash* pH, uint new_size)
		{
			_ht* new_ht;
			HashElem* elem; HashElem* next_elem;
			if ((new_size * sizeof(_ht)) > (1024))
			{
				new_size = (uint)(1024 / sizeof(_ht));
			}

			if ((new_size) == (pH->htsize))
				return (int)(0);
			sqlite3BeginBenignMalloc();
			new_ht = (_ht*)(sqlite3Malloc((ulong)(new_size * sizeof(_ht))));
			sqlite3EndBenignMalloc();
			if ((new_ht) == (null))
				return (int)(0);
			sqlite3_free(pH->ht);
			pH->ht = new_ht;
			pH->htsize = (uint)(new_size = (uint)(sqlite3MallocSize(new_ht) / sizeof(_ht)));
			CRuntime.memset(new_ht, (int)(0), (ulong)(new_size * sizeof(_ht)));
			for (elem = pH->first, pH->first = null; elem; elem = next_elem)
			{
				uint h = (uint)(strHash(elem->pKey) % new_size);
				next_elem = elem->next;
				insertElement(pH, &new_ht[h], elem);
			}

			return (int)(1);
		}
		public static void reindexDatabases(Parse pParse, sbyte* zColl)
		{
			Db pDb;
			int iDb = 0;
			sqlite3 db = pParse.db;
			HashElem* k;
			Table pTab;

			for (iDb = (int)(0), pDb = db.aDb; (iDb) < (db.nDb); iDb++, pDb++)
			{

				for (k = ((&pDb.pSchema.tblHash)->first); k; k = ((k)->next))
				{
					pTab = (Table)((k)->data);
					reindexTable(pParse, pTab, zColl);
				}
			}
		}
		public static void reindexTable(Parse pParse, Table pTab, sbyte* zColl)
		{
			if (!(((pTab).eTabType) == (1)))
			{
				Index pIndex;
				for (pIndex = pTab.pIndex; pIndex; pIndex = pIndex.pNext)
				{
					if (((zColl) == (null)) || ((collationMatch(zColl, pIndex)) != 0))
					{
						int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
						sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
						sqlite3RefillIndex(pParse, pIndex, (int)(-1));
					}
				}
			}
		}
		public static void releaseAllSavepoints(Pager pPager)
		{
			int ii = 0;
			for (ii = (int)(0); (ii) < (pPager.nSavepoint); ii++)
			{
				sqlite3BitvecDestroy(pPager.aSavepoint[ii].pInSavepoint);
			}

			if ((pPager.exclusiveMode == 0) || ((sqlite3JournalIsInMemory(pPager.sjfd)) != 0))
			{
				sqlite3OsClose(pPager.sjfd);
			}

			sqlite3_free(pPager.aSavepoint);
			pPager.aSavepoint = null;
			pPager.nSavepoint = (int)(0);
			pPager.nSubRec = (uint)(0);
		}
		public static void releaseMemArray(sqlite3_value p, int N)
		{
			if (((p) != null) && ((N) != 0))
			{
				sqlite3_value pEnd = p[N];
				sqlite3 db = p.db;
				if ((db.pnBytesFreed) != null)
				{
					do
					{
						if ((p.szMalloc) != 0)
							sqlite3DbFree(db, p.zMalloc);
					}
					while ((++p) < (pEnd));
					return;
				}

				do
				{


					if ((p.flags & (0x2000 | 0x0400)) != 0)
					{
						sqlite3VdbeMemRelease(p);
					}
					else if ((p.szMalloc) != 0)
					{
						sqlite3DbFreeNN(db, p.zMalloc);
						p.szMalloc = (int)(0);
					}

					p.flags = (ushort)(0x0080);
				}
				while ((++p) < (pEnd));
			}
		}
		public static void releasePage(MemPage pPage)
		{
			if ((pPage) != null)
				releasePageNotNull(pPage);
		}
		public static void releasePageNotNull(MemPage pPage)
		{






			sqlite3PagerUnrefNotNull(pPage.pDbPage);
		}
		public static void releasePageOne(MemPage pPage)
		{







			sqlite3PagerUnrefPageOne(pPage.pDbPage);
		}
		public static int relocatePage(BtShared pBt, MemPage pDbPage, byte eType, uint iPtrPage, uint iFreePage, int isCommit)
		{
			MemPage pPtrPage;
			uint iDbPage = (uint)(pDbPage.pgno);
			Pager pPager = pBt.pPager;
			int rc = 0;



			if ((iDbPage) < (3))
				return (int)(sqlite3CorruptError((int)(69888)));
			rc = (int)(sqlite3PagerMovepage(pPager, pDbPage.pDbPage, (uint)(iFreePage), (int)(isCommit)));
			if (rc != 0)
			{
				return (int)(rc);
			}

			pDbPage.pgno = (uint)(iFreePage);
			if (((eType) == (5)) || ((eType) == (1)))
			{
				rc = (int)(setChildPtrmaps(pDbPage));
				if (rc != 0)
				{
					return (int)(rc);
				}
			}
			else
			{
				uint nextOvfl = (uint)(sqlite3Get4byte(pDbPage.aData));
				if (nextOvfl != 0)
				{
					ptrmapPut(pBt, (uint)(nextOvfl), (byte)(4), (uint)(iFreePage), &rc);
					if (rc != 0)
					{
						return (int)(rc);
					}
				}
			}

			if (eType != 1)
			{
				rc = (int)(btreeGetPage(pBt, (uint)(iPtrPage), pPtrPage, (int)(0)));
				if (rc != 0)
				{
					return (int)(rc);
				}

				rc = (int)(sqlite3PagerWrite(pPtrPage.pDbPage));
				if (rc != 0)
				{
					releasePage(pPtrPage);
					return (int)(rc);
				}

				rc = (int)(modifyPagePointer(pPtrPage, (uint)(iDbPage), (uint)(iFreePage), (byte)(eType)));
				releasePage(pPtrPage);
				if ((rc) == (0))
				{
					ptrmapPut(pBt, (uint)(iFreePage), (byte)(eType), (uint)(iPtrPage), &rc);
				}
			}

			return (int)(rc);
		}
		public static void removeElementGivenHash(Hash* pH, HashElem* elem, uint h)
		{
			_ht* pEntry;
			if ((elem->prev) != null)
			{
				elem->prev->next = elem->next;
			}
			else
			{
				pH->first = elem->next;
			}

			if ((elem->next) != null)
			{
				elem->next->prev = elem->prev;
			}

			if ((pH->ht) != null)
			{
				pEntry = &pH->ht[h];
				if ((pEntry->chain) == (elem))
				{
					pEntry->chain = elem->next;
				}


				pEntry->count--;
			}

			sqlite3_free(elem);
			pH->count--;
			if ((pH->count) == (0))
			{


				sqlite3HashClear(pH);
			}
		}
		public static int removeFromSharingList(BtShared pBt)
		{
			sqlite3_mutex* pMainMtx;
			BtShared pList;
			int removed = (int)(0);

			pMainMtx = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(pMainMtx);
			pBt.nRef--;
			if ((pBt.nRef) <= (0))
			{
				if ((sqlite3SharedCacheList) == (pBt))
				{
					sqlite3SharedCacheList = pBt.pNext;
				}
				else
				{
					pList = sqlite3SharedCacheList;
					while (((pList) != null) && (pList.pNext != pBt))
					{
						pList = pList.pNext;
					}

					if ((pList) != null)
					{
						pList.pNext = pBt.pNext;
					}
				}

				if ((1) != 0)
				{
					sqlite3_mutex_free(pBt.mutex);
				}

				removed = (int)(1);
			}

			sqlite3_mutex_leave(pMainMtx);
			return (int)(removed);
		}
		public static Expr removeUnindexableInClauseTerms(Parse pParse, int iEq, WhereLoop pLoop, Expr pX)
		{
			sqlite3 db = pParse.db;
			Expr pNew;
			pNew = sqlite3ExprDup(db, pX, (int)(0));
			if ((db.mallocFailed) == (0))
			{
				ExprList pOrigRhs;
				ExprList pOrigLhs;
				ExprList pRhs = null;
				ExprList pLhs = null;
				int i = 0;
				Select pSelect;

				pOrigRhs = pNew.x.pSelect.pEList;


				pOrigLhs = pNew.pLeft.x.pList;
				for (i = (int)(iEq); (i) < (pLoop.nLTerm); i++)
				{
					if ((pLoop.aLTerm[i].pExpr) == (pX))
					{
						int iField = 0;

						iField = (int)(pLoop.aLTerm[i].u.x.iField - 1);
						if ((pOrigRhs.a[iField].pExpr) == (null))
							continue;
						pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs.a[iField].pExpr);
						pOrigRhs.a[iField].pExpr = null;

						pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs.a[iField].pExpr);
						pOrigLhs.a[iField].pExpr = null;
					}
				}

				sqlite3ExprListDelete(db, pOrigRhs);
				sqlite3ExprListDelete(db, pOrigLhs);
				pNew.pLeft.x.pList = pLhs;
				pNew.x.pSelect.pEList = pRhs;
				if (((pLhs) != null) && ((pLhs.nExpr) == (1)))
				{
					Expr p = pLhs.a[0].pExpr;
					pLhs.a[0].pExpr = null;
					sqlite3ExprDelete(db, pNew.pLeft);
					pNew.pLeft = p;
				}

				pSelect = pNew.x.pSelect;
				if ((pSelect.pOrderBy) != null)
				{
					ExprList pOrderBy = pSelect.pOrderBy;
					for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
					{
						pOrderBy.a[i].u.x.iOrderByCol = (ushort)(0);
					}
				}
			}

			return pNew;
		}
		public static void renameColumnElistNames(Parse pParse, RenameCtx pCtx, ExprList pEList, sbyte* zOld)
		{
			if ((pEList) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pEList.nExpr); i++)
				{
					sbyte* zName = pEList.a[i].zEName;
					if ((((pEList.a[i].eEName) == (0)) && (zName != null)) && ((0) == (sqlite3_stricmp(zName, zOld))))
					{
						renameTokenFind(pParse, pCtx, (void*)(zName));
					}
				}
			}
		}
		public static int renameColumnExprCb(Walker pWalker, Expr pExpr)
		{
			RenameCtx p = pWalker.u.pRename;
			if ((((pExpr.op) == (77)) && ((pExpr.iColumn) == (p.iCol))) && ((pWalker.pParse.pTriggerTab) == (p.pTab)))
			{
				renameTokenFind(pWalker.pParse, p, (void*)(pExpr));
			}
			else if (((((pExpr.op) == (167)) && ((pExpr.iColumn) == (p.iCol))) && ((((pExpr).flags & (0x1000000 | 0x2000000)) == (0)) != 0)) && ((p.pTab) == (pExpr.y.pTab)))
			{
				renameTokenFind(pWalker.pParse, p, (void*)(pExpr));
			}

			return (int)(0);
		}
		public static void renameColumnFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			RenameCtx sCtx = new RenameCtx();
			sbyte* zSql = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[3]));
			sbyte* zTable = (sbyte*)(sqlite3_value_text(argv[4]));
			int iCol = (int)(sqlite3_value_int(argv[5]));
			sbyte* zNew = (sbyte*)(sqlite3_value_text(argv[6]));
			int bQuote = (int)(sqlite3_value_int(argv[7]));
			int bTemp = (int)(sqlite3_value_int(argv[8]));
			sbyte* zOld;
			int rc = 0;
			Parse sParse = new Parse();
			Walker sWalker = new Walker();
			Index pIdx;
			int i = 0;
			Table pTab;
			delegate66 xAuth = db.xAuth;
			(void)(NotUsed);
			if ((zSql) == (null))
				return;
			if ((zTable) == (null))
				return;
			if ((zNew) == (null))
				return;
			if ((iCol) < (0))
				return;
			sqlite3BtreeEnterAll(db);
			pTab = sqlite3FindTable(db, zTable, zDb);
			if (((pTab) == (null)) || ((iCol) >= (pTab.nCol)))
			{
				sqlite3BtreeLeaveAll(db);
				return;
			}

			zOld = pTab.aCol[iCol].zCnName;
			CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
			sCtx.iCol = (int)(((iCol) == (pTab.iPKey)) ? -1 : iCol);
			db.xAuth = null;
			rc = (int)(renameParseSql(sParse, zDb, db, zSql, (int)(bTemp)));
			CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
			sWalker.pParse = sParse;
			sWalker.xExprCallback = renameColumnExprCb;
			sWalker.xSelectCallback = renameColumnSelectCb;
			sWalker.u.pRename = sCtx;
			sCtx.pTab = pTab;
			if (rc != 0)
				goto renameColumnFunc_done;
			if ((sParse.pNewTable) != null)
			{
				if ((((sParse.pNewTable).eTabType) == (2)))
				{
					Select pSelect = sParse.pNewTable.u.view.pSelect;
					pSelect.selFlags &= (uint)(~0x0200000);
					sParse.rc = (int)(0);
					sqlite3SelectPrep(sParse, pSelect, null);
					rc = (int)((db.mallocFailed) != 0 ? 7 : sParse.rc);
					if ((rc) == (0))
					{
						sqlite3WalkSelect(sWalker, pSelect);
					}

					if (rc != 0)
						goto renameColumnFunc_done;
				}
				else if ((((sParse.pNewTable).eTabType) == (0)))
				{
					int bFKOnly = (int)(sqlite3_stricmp(zTable, sParse.pNewTable.zName));
					FKey pFKey;
					sCtx.pTab = sParse.pNewTable;
					if ((bFKOnly) == (0))
					{
						if ((iCol) < (sParse.pNewTable.nCol))
						{
							renameTokenFind(sParse, sCtx, (void*)(sParse.pNewTable.aCol[iCol].zCnName));
						}

						if ((sCtx.iCol) < (0))
						{
							renameTokenFind(sParse, sCtx, (void*)(&sParse.pNewTable.iPKey));
						}

						sqlite3WalkExprList(sWalker, sParse.pNewTable.pCheck);
						for (pIdx = sParse.pNewTable.pIndex; pIdx; pIdx = pIdx.pNext)
						{
							sqlite3WalkExprList(sWalker, pIdx.aColExpr);
						}

						for (pIdx = sParse.pNewIndex; pIdx; pIdx = pIdx.pNext)
						{
							sqlite3WalkExprList(sWalker, pIdx.aColExpr);
						}

						for (i = (int)(0); (i) < (sParse.pNewTable.nCol); i++)
						{
							Expr pExpr = sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable.aCol[i]);
							sqlite3WalkExpr(sWalker, pExpr);
						}
					}


					for (pFKey = sParse.pNewTable.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
					{
						for (i = (int)(0); (i) < (pFKey.nCol); i++)
						{
							if (((bFKOnly) == (0)) && ((pFKey.aCol[i].iFrom) == (iCol)))
							{
								renameTokenFind(sParse, sCtx, (void*)(&pFKey.aCol[i]));
							}

							if (((0) == (sqlite3_stricmp(pFKey.zTo, zTable))) && ((0) == (sqlite3_stricmp(pFKey.aCol[i].zCol, zOld))))
							{
								renameTokenFind(sParse, sCtx, (void*)(pFKey.aCol[i].zCol));
							}
						}
					}
				}
			}
			else if ((sParse.pNewIndex) != null)
			{
				sqlite3WalkExprList(sWalker, sParse.pNewIndex.aColExpr);
				sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
			}
			else
			{
				TriggerStep pStep;
				rc = (int)(renameResolveTrigger(sParse));
				if (rc != 0)
					goto renameColumnFunc_done;
				for (pStep = sParse.pNewTrigger.step_list; pStep; pStep = pStep.pNext)
				{
					if ((pStep.zTarget) != null)
					{
						Table pTarget = sqlite3LocateTable(sParse, (uint)(0), pStep.zTarget, zDb);
						if ((pTarget) == (pTab))
						{
							if ((pStep.pUpsert) != null)
							{
								ExprList pUpsertSet = pStep.pUpsert.pUpsertSet;
								renameColumnElistNames(sParse, sCtx, pUpsertSet, zOld);
							}

							renameColumnIdlistNames(sParse, sCtx, pStep.pIdList, zOld);
							renameColumnElistNames(sParse, sCtx, pStep.pExprList, zOld);
						}
					}
				}

				if ((sParse.pTriggerTab) == (pTab))
				{
					renameColumnIdlistNames(sParse, sCtx, sParse.pNewTrigger.pColumns, zOld);
				}

				renameWalkTrigger(sWalker, sParse.pNewTrigger);
			}


			rc = (int)(renameEditSql(context, sCtx, zSql, zNew, (int)(bQuote)));
		renameColumnFunc_done:
			; if (rc != 0) { if (((rc) == (1)) && ((sqlite3WritableSchema(db)) != 0)) { sqlite3_result_value(context, argv[0]); } else if ((sParse.zErrMsg) != null) { renameColumnParseError(context, "", argv[1], argv[2], sParse); } else { sqlite3_result_error_code(context, (int)(rc)); } }
			renameParseCleanup(sParse);
			renameTokenFree(db, sCtx.pList);
			db.xAuth = xAuth;
			sqlite3BtreeLeaveAll(db);
		}
		public static void renameColumnIdlistNames(Parse pParse, RenameCtx pCtx, IdList* pIdList, sbyte* zOld)
		{
			if ((pIdList) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pIdList->nId); i++)
				{
					sbyte* zName = pIdList->a[i].zName;
					if ((0) == (sqlite3_stricmp(zName, zOld)))
					{
						renameTokenFind(pParse, pCtx, (void*)(zName));
					}
				}
			}
		}
		public static void renameColumnParseError(sqlite3_context pCtx, sbyte* zWhen, sqlite3_value pType, sqlite3_value pObject, Parse pParse)
		{
			sbyte* zT = (sbyte*)(sqlite3_value_text(pType));
			sbyte* zN = (sbyte*)(sqlite3_value_text(pObject));
			sbyte* zErr;
			zErr = sqlite3MPrintf(pParse.db, "error in %s %s%s%s: %s", zT, zN, ((zWhen[0]) != 0 ? " " : ""), zWhen, pParse.zErrMsg);
			sqlite3_result_error(pCtx, zErr, (int)(-1));
			sqlite3DbFree(pParse.db, zErr);
		}
		public static int renameColumnSelectCb(Walker pWalker, Select p)
		{
			if ((p.selFlags & (0x0200000 | 0x4000000)) != 0)
			{
				return (int)(1);
			}

			renameWalkWith(pWalker, p);
			return (int)(0);
		}
		public static RenameToken* renameColumnTokenNext(RenameCtx pCtx)
		{
			RenameToken* pBest = pCtx.pList;
			RenameToken* pToken;
			RenameToken** pp;
			for (pToken = pBest->pNext; pToken; pToken = pToken->pNext)
			{
				if ((pToken->t.z) > (pBest->t.z))
					pBest = pToken;
			}

			for (pp = &pCtx.pList; *pp != pBest; pp = &(*pp)->pNext)
			{
			}

			*pp = pBest->pNext;
			return pBest;
		}
		public static int renameEditSql(sqlite3_context pCtx, RenameCtx pRename, sbyte* zSql, sbyte* zNew, int bQuote)
		{
			long nNew = (long)(sqlite3Strlen30(zNew));
			long nSql = (long)(sqlite3Strlen30(zSql));
			sqlite3 db = sqlite3_context_db_handle(pCtx);
			int rc = (int)(0);
			sbyte* zQuot = null;
			sbyte* zOut;
			long nQuot = (long)(0);
			sbyte* zBuf1 = null;
			sbyte* zBuf2 = null;
			if ((zNew) != null)
			{
				zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);
				if ((zQuot) == (null))
				{
					return (int)(7);
				}
				else
				{
					nQuot = (long)(sqlite3Strlen30(zQuot) - 1);
				}


				zOut = sqlite3DbMallocZero(db, (ulong)(nSql + pRename.nList * nQuot + 1));
			}
			else
			{
				zOut = (sbyte*)(sqlite3DbMallocZero(db, (ulong)((nSql * 2 + 1) * 3)));
				if ((zOut) != null)
				{
					zBuf1 = &zOut[nSql * 2 + 1];
					zBuf2 = &zOut[nSql * 4 + 2];
				}
			}

			if ((zOut) != null)
			{
				int nOut = (int)(nSql);
				CRuntime.memcpy(zOut, zSql, (ulong)(nSql));
				while ((pRename.pList) != null)
				{
					int iOff = 0;
					uint nReplace = 0;
					sbyte* zReplace;
					RenameToken* pBest = renameColumnTokenNext(pRename);
					if ((zNew) != null)
					{
						if (((bQuote) == (0)) && ((sqlite3IsIdChar((byte)(*pBest->t.z))) != 0))
						{
							nReplace = (uint)(nNew);
							zReplace = zNew;
						}
						else
						{
							nReplace = (uint)(nQuot);
							zReplace = zQuot;
							if ((pBest->t.z[pBest->t.n]) == (34))
								nReplace++;
						}
					}
					else
					{
						CRuntime.memcpy(zBuf1, pBest->t.z, (ulong)(pBest->t.n));
						zBuf1[pBest->t.n] = (sbyte)(0);
						sqlite3Dequote(zBuf1);
						sqlite3_snprintf((int)(nSql * 2), zBuf2, "%Q%s", zBuf1, (pBest->t.z[pBest->t.n]) == (39) ? " " : "");
						zReplace = zBuf2;
						nReplace = (uint)(sqlite3Strlen30(zReplace));
					}

					iOff = (int)(pBest->t.z - zSql);
					if (pBest->t.n != nReplace)
					{
						CRuntime.memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n], (ulong)(nOut - (iOff + pBest->t.n)));
						nOut += (int)(nReplace - pBest->t.n);
						zOut[nOut] = (sbyte)(0);
					}

					CRuntime.memcpy(&zOut[iOff], zReplace, (ulong)(nReplace));
					sqlite3DbFree(db, pBest);
				}

				sqlite3_result_text(pCtx, zOut, (int)(-1), ((Void(Void * ))(-1)));
				sqlite3DbFree(db, zOut);
			}
			else
			{
				rc = (int)(7);
			}

			sqlite3_free(zQuot);
			return (int)(rc);
		}
		public static void renameFixQuotes(Parse pParse, sbyte* zDb, int bTemp)
		{
			sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_quotefix(%Q, sql)WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%'", zDb, zDb);
			if ((bTemp) == (0))
			{
				sqlite3NestedParse(pParse, "UPDATE temp.sqlite_master SET sql = sqlite_rename_quotefix('temp', sql)WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%'");
			}
		}
		public static void renameParseCleanup(Parse pParse)
		{
			sqlite3 db = pParse.db;
			Index pIdx;
			if ((pParse.pVdbe) != null)
			{
				sqlite3VdbeFinalize(pParse.pVdbe);
			}

			sqlite3DeleteTable(db, pParse.pNewTable);
			while ((pIdx = pParse.pNewIndex) != null)
			{
				pParse.pNewIndex = pIdx.pNext;
				sqlite3FreeIndex(db, pIdx);
			}

			sqlite3DeleteTrigger(db, pParse.pNewTrigger);
			sqlite3DbFree(db, pParse.zErrMsg);
			renameTokenFree(db, pParse.pRename);
			sqlite3ParseObjectReset(pParse);
		}
		public static int renameParseSql(Parse p, sbyte* zDb, sqlite3 db, sbyte* zSql, int bTemp)
		{
			int rc = 0;
			sqlite3ParseObjectInit(p, db);
			if ((zSql) == (null))
			{
				return (int)(7);
			}

			if (sqlite3_strnicmp(zSql, "CREATE ", (int)(7)) != 0)
			{
				return (int)(sqlite3CorruptError((int)(109967)));
			}

			db.init.iDb = (byte)((bTemp) != 0 ? 1 : sqlite3FindDbName(db, zDb));
			p.eParseMode = (byte)(2);
			p.db = db;
			p.nQueryLoop = (uint)(1);
			rc = (int)(sqlite3RunParser(p, zSql));
			if ((db.mallocFailed) != 0)
				rc = (int)(7);
			if (((rc) == (0)) && ((((p.pNewTable) == (null)) && ((p.pNewIndex) == (null))) && ((p.pNewTrigger) == (null))))
			{
				rc = (int)(sqlite3CorruptError((int)(109978)));
			}

			db.init.iDb = (byte)(0);
			return (int)(rc);
		}
		public static int renameQuotefixExprCb(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (117)) && ((pExpr.flags & 0x000040) != 0))
			{
				renameTokenFind(pWalker.pParse, pWalker.u.pRename, (void*)(pExpr));
			}

			return (int)(0);
		}
		public static void renameQuotefixFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[1]));
			delegate66 xAuth = db.xAuth;
			db.xAuth = null;
			sqlite3BtreeEnterAll(db);
			(void)(NotUsed);
			if (((zDb) != null) && ((zInput) != null))
			{
				int rc = 0;
				Parse sParse = new Parse();
				rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(0)));
				if ((rc) == (0))
				{
					RenameCtx sCtx = new RenameCtx();
					Walker sWalker = new Walker();
					CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
					CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
					sWalker.pParse = sParse;
					sWalker.xExprCallback = renameQuotefixExprCb;
					sWalker.xSelectCallback = renameColumnSelectCb;
					sWalker.u.pRename = sCtx;
					if ((sParse.pNewTable) != null)
					{
						if ((((sParse.pNewTable).eTabType) == (2)))
						{
							Select pSelect = sParse.pNewTable.u.view.pSelect;
							pSelect.selFlags &= (uint)(~0x0200000);
							sParse.rc = (int)(0);
							sqlite3SelectPrep(sParse, pSelect, null);
							rc = (int)((db.mallocFailed) != 0 ? 7 : sParse.rc);
							if ((rc) == (0))
							{
								sqlite3WalkSelect(sWalker, pSelect);
							}
						}
						else
						{
							int i = 0;
							sqlite3WalkExprList(sWalker, sParse.pNewTable.pCheck);
							for (i = (int)(0); (i) < (sParse.pNewTable.nCol); i++)
							{
								sqlite3WalkExpr(sWalker, sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable.aCol[i]));
							}
						}
					}
					else if ((sParse.pNewIndex) != null)
					{
						sqlite3WalkExprList(sWalker, sParse.pNewIndex.aColExpr);
						sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
					}
					else
					{
						rc = (int)(renameResolveTrigger(sParse));
						if ((rc) == (0))
						{
							renameWalkTrigger(sWalker, sParse.pNewTrigger);
						}
					}

					if ((rc) == (0))
					{
						rc = (int)(renameEditSql(context, sCtx, zInput, null, (int)(0)));
					}

					renameTokenFree(db, sCtx.pList);
				}

				if (rc != 0)
				{
					if (((sqlite3WritableSchema(db)) != 0) && ((rc) == (1)))
					{
						sqlite3_result_value(context, argv[1]);
					}
					else
					{
						sqlite3_result_error_code(context, (int)(rc));
					}
				}

				renameParseCleanup(sParse);
			}

			db.xAuth = xAuth;
			sqlite3BtreeLeaveAll(db);
		}
		public static void renameReloadSchema(Parse pParse, int iDb, ushort p5)
		{
			Vdbe v = pParse.pVdbe;
			if ((v) != null)
			{
				sqlite3ChangeCookie(pParse, (int)(iDb));
				sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, (int)(iDb), null, (ushort)(p5));
				if (iDb != 1)
					sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, (int)(1), null, (ushort)(p5));
			}
		}
		public static int renameResolveTrigger(Parse pParse)
		{
			sqlite3 db = pParse.db;
			Trigger pNew = pParse.pNewTrigger;
			TriggerStep pStep;
			NameContext sNC = new NameContext();
			int rc = (int)(0);
			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = pParse;

			pParse.pTriggerTab = sqlite3FindTable(db, pNew.table, db.aDb[sqlite3SchemaToIndex(db, pNew.pTabSchema)].zDbSName);
			pParse.eTriggerOp = (byte)(pNew.op);
			if ((pParse.pTriggerTab) != null)
			{
				rc = (int)(sqlite3ViewGetColumnNames(pParse, pParse.pTriggerTab));
			}

			if (((rc) == (0)) && ((pNew.pWhen) != null))
			{
				rc = (int)(sqlite3ResolveExprNames(sNC, pNew.pWhen));
			}

			for (pStep = pNew.step_list; ((rc) == (0)) && ((pStep) != null); pStep = pStep.pNext)
			{
				if ((pStep.pSelect) != null)
				{
					sqlite3SelectPrep(pParse, pStep.pSelect, sNC);
					if ((pParse.nErr) != 0)
						rc = (int)(pParse.rc);
				}

				if (((rc) == (0)) && ((pStep.zTarget) != null))
				{
					SrcList pSrc = sqlite3TriggerStepSrc(pParse, pStep);
					if ((pSrc) != null)
					{
						int i = 0;
						for (i = (int)(0); ((i) < (pSrc.nSrc)) && ((rc) == (0)); i++)
						{
							SrcItem p = pSrc.a[i];
							p.iCursor = (int)(pParse.nTab++);
							if ((p.pSelect) != null)
							{
								sqlite3SelectPrep(pParse, p.pSelect, null);
								sqlite3ExpandSubquery(pParse, p);


								sqlite3SelectPrep(pParse, pStep.pFrom.a[i - 1].pSelect, null);
							}
							else
							{
								p.pTab = sqlite3LocateTableItem(pParse, (uint)(0), p);
								if ((p.pTab) == (null))
								{
									rc = (int)(1);
								}
								else
								{
									p.pTab.nTabRef++;
									rc = (int)(sqlite3ViewGetColumnNames(pParse, p.pTab));
								}
							}
						}

						if (((rc) == (0)) && ((db.mallocFailed) != 0))
						{
							rc = (int)(7);
						}

						sNC.pSrcList = pSrc;
						if (((rc) == (0)) && ((pStep.pWhere) != null))
						{
							rc = (int)(sqlite3ResolveExprNames(sNC, pStep.pWhere));
						}

						if ((rc) == (0))
						{
							rc = (int)(sqlite3ResolveExprListNames(sNC, pStep.pExprList));
						}


						if (((pStep.pUpsert) != null) && ((rc) == (0)))
						{
							Upsert pUpsert = pStep.pUpsert;
							pUpsert.pUpsertSrc = pSrc;
							sNC.uNC.pUpsert = pUpsert;
							sNC.ncFlags = (int)(0x000200);
							rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsert.pUpsertTarget));
							if ((rc) == (0))
							{
								ExprList pUpsertSet = pUpsert.pUpsertSet;
								rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsertSet));
							}

							if ((rc) == (0))
							{
								rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertWhere));
							}

							if ((rc) == (0))
							{
								rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertTargetWhere));
							}

							sNC.ncFlags = (int)(0);
						}

						sNC.pSrcList = null;
						sqlite3SrcListDelete(db, pSrc);
					}
					else
					{
						rc = (int)(7);
					}
				}
			}

			return (int)(rc);
		}
		public static int renameTableExprCb(Walker pWalker, Expr pExpr)
		{
			RenameCtx p = pWalker.u.pRename;
			if ((((pExpr.op) == (167)) && ((((pExpr).flags & (0x1000000 | 0x2000000)) == (0)) != 0)) && ((p.pTab) == (pExpr.y.pTab)))
			{
				renameTokenFind(pWalker.pParse, p, (void*)(pExpr.y.pTab));
			}

			return (int)(0);
		}
		public static void renameTableFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[3]));
			sbyte* zOld = (sbyte*)(sqlite3_value_text(argv[4]));
			sbyte* zNew = (sbyte*)(sqlite3_value_text(argv[5]));
			int bTemp = (int)(sqlite3_value_int(argv[6]));
			(void)(NotUsed);
			if ((((zInput) != null) && ((zOld) != null)) && ((zNew) != null))
			{
				Parse sParse = new Parse();
				int rc = 0;
				int bQuote = (int)(1);
				RenameCtx sCtx = new RenameCtx();
				Walker sWalker = new Walker();
				delegate66 xAuth = db.xAuth;
				db.xAuth = null;
				sqlite3BtreeEnterAll(db);
				CRuntime.memset(sCtx, (int)(0), (ulong)(sizeof(RenameCtx)));
				sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
				CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
				sWalker.pParse = sParse;
				sWalker.xExprCallback = renameTableExprCb;
				sWalker.xSelectCallback = renameTableSelectCb;
				sWalker.u.pRename = sCtx;
				rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(bTemp)));
				if ((rc) == (0))
				{
					int isLegacy = (int)(db.flags & 0x04000000);
					if ((sParse.pNewTable) != null)
					{
						Table pTab = sParse.pNewTable;
						if ((((pTab).eTabType) == (2)))
						{
							if ((isLegacy) == (0))
							{
								Select pSelect = pTab.u.view.pSelect;
								NameContext sNC = new NameContext();
								CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
								sNC.pParse = sParse;

								pSelect.selFlags &= (uint)(~0x0200000);
								sqlite3SelectPrep(sParse, pTab.u.view.pSelect, sNC);
								if ((sParse.nErr) != 0)
								{
									rc = (int)(sParse.rc);
								}
								else
								{
									sqlite3WalkSelect(sWalker, pTab.u.view.pSelect);
								}
							}
						}
						else
						{
							if ((((isLegacy) == (0)) || ((db.flags & 0x00004000) != 0)) && (!(((pTab).eTabType) == (1))))
							{
								FKey pFKey;

								for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
								{
									if ((sqlite3_stricmp(pFKey.zTo, zOld)) == (0))
									{
										renameTokenFind(sParse, sCtx, (void*)(pFKey.zTo));
									}
								}
							}

							if ((sqlite3_stricmp(zOld, pTab.zName)) == (0))
							{
								sCtx.pTab = pTab;
								if ((isLegacy) == (0))
								{
									sqlite3WalkExprList(sWalker, pTab.pCheck);
								}

								renameTokenFind(sParse, sCtx, pTab.zName);
							}
						}
					}
					else if ((sParse.pNewIndex) != null)
					{
						renameTokenFind(sParse, sCtx, sParse.pNewIndex.zName);
						if ((isLegacy) == (0))
						{
							sqlite3WalkExpr(sWalker, sParse.pNewIndex.pPartIdxWhere);
						}
					}
					else
					{
						Trigger pTrigger = sParse.pNewTrigger;
						TriggerStep pStep;
						if (((0) == (sqlite3_stricmp(sParse.pNewTrigger.table, zOld))) && ((sCtx.pTab.pSchema) == (pTrigger.pTabSchema)))
						{
							renameTokenFind(sParse, sCtx, sParse.pNewTrigger.table);
						}

						if ((isLegacy) == (0))
						{
							rc = (int)(renameResolveTrigger(sParse));
							if ((rc) == (0))
							{
								renameWalkTrigger(sWalker, pTrigger);
								for (pStep = pTrigger.step_list; pStep; pStep = pStep.pNext)
								{
									if (((pStep.zTarget) != null) && ((0) == (sqlite3_stricmp(pStep.zTarget, zOld))))
									{
										renameTokenFind(sParse, sCtx, pStep.zTarget);
									}
								}
							}
						}
					}
				}

				if ((rc) == (0))
				{
					rc = (int)(renameEditSql(context, sCtx, zInput, zNew, (int)(bQuote)));
				}

				if (rc != 0)
				{
					if (((rc) == (1)) && ((sqlite3WritableSchema(db)) != 0))
					{
						sqlite3_result_value(context, argv[3]);
					}
					else if ((sParse.zErrMsg) != null)
					{
						renameColumnParseError(context, "", argv[1], argv[2], sParse);
					}
					else
					{
						sqlite3_result_error_code(context, (int)(rc));
					}
				}

				renameParseCleanup(sParse);
				renameTokenFree(db, sCtx.pList);
				sqlite3BtreeLeaveAll(db);
				db.xAuth = xAuth;
			}

			return;
		}
		public static int renameTableSelectCb(Walker pWalker, Select pSelect)
		{
			int i = 0;
			RenameCtx p = pWalker.u.pRename;
			SrcList pSrc = pSelect.pSrc;
			if ((pSelect.selFlags & (0x0200000 | 0x4000000)) != 0)
			{
				return (int)(1);
			}

			if (((pSrc) == (null)))
			{

				return (int)(2);
			}

			for (i = (int)(0); (i) < (pSrc.nSrc); i++)
			{
				SrcItem pItem = pSrc.a[i];
				if ((pItem.pTab) == (p.pTab))
				{
					renameTokenFind(pWalker.pParse, p, pItem.zName);
				}
			}

			renameWalkWith(pWalker, pSelect);
			return (int)(0);
		}
		public static void renameTableTest(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			sbyte* zDb = (sbyte*)(sqlite3_value_text(argv[0]));
			sbyte* zInput = (sbyte*)(sqlite3_value_text(argv[1]));
			int bTemp = (int)(sqlite3_value_int(argv[4]));
			int isLegacy = (int)(db.flags & 0x04000000);
			sbyte* zWhen = (sbyte*)(sqlite3_value_text(argv[5]));
			int bNoDQS = (int)(sqlite3_value_int(argv[6]));
			delegate66 xAuth = db.xAuth;
			db.xAuth = null;
			(void)(NotUsed);
			if (((zDb) != null) && ((zInput) != null))
			{
				int rc = 0;
				Parse sParse = new Parse();
				int flags = (int)(db.flags);
				if ((bNoDQS) != 0)
					db.flags &= (ulong)(~(0x40000000 | 0x20000000));
				rc = (int)(renameParseSql(sParse, zDb, db, zInput, (int)(bTemp)));
				db.flags |= (ulong)(flags & (0x40000000 | 0x20000000));
				if ((rc) == (0))
				{
					if ((((isLegacy) == (0)) && ((sParse.pNewTable) != null)) && (((sParse.pNewTable).eTabType) == (2)))
					{
						NameContext sNC = new NameContext();
						CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
						sNC.pParse = sParse;
						sqlite3SelectPrep(sParse, sParse.pNewTable.u.view.pSelect, sNC);
						if ((sParse.nErr) != 0)
							rc = (int)(sParse.rc);
					}
					else if ((sParse.pNewTrigger) != null)
					{
						if ((isLegacy) == (0))
						{
							rc = (int)(renameResolveTrigger(sParse));
						}

						if ((rc) == (0))
						{
							int i1 = (int)(sqlite3SchemaToIndex(db, sParse.pNewTrigger.pTabSchema));
							int i2 = (int)(sqlite3FindDbName(db, zDb));
							if ((i1) == (i2))
							{
								sqlite3_result_int(context, (int)(1));
							}
						}
					}
				}

				if (((rc != 0) && ((zWhen) != null)) && (sqlite3WritableSchema(db) == 0))
				{
					renameColumnParseError(context, zWhen, argv[2], argv[3], sParse);
				}

				renameParseCleanup(sParse);
			}

			db.xAuth = xAuth;
		}
		public static void renameTestSchema(Parse pParse, sbyte* zDb, int bTemp, sbyte* zWhen, int bNoDQS)
		{
			pParse.colNamesSet = (byte)(1);
			sqlite3NestedParse(pParse, "SELECT 1 FROM \"%w\".sqlite_master WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%' AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ", zDb, zDb, (int)(bTemp), zWhen, (int)(bNoDQS));
			if ((bTemp) == (0))
			{
				sqlite3NestedParse(pParse, "SELECT 1 FROM temp.sqlite_master WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' AND sql NOT LIKE 'create virtual%%' AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ", zDb, zWhen, (int)(bNoDQS));
			}
		}
		public static RenameToken* renameTokenFind(Parse pParse, RenameCtx pCtx, void* pPtr)
		{
			RenameToken** pp;
			if (((pPtr) == (null)))
			{
				return null;
			}

			for (pp = &pParse.pRename; (*pp); pp = &(*pp)->pNext)
			{
				if (((*pp)->p) == (pPtr))
				{
					RenameToken* pToken = *pp;
					if ((pCtx) != null)
					{
						*pp = pToken->pNext;
						pToken->pNext = pCtx.pList;
						pCtx.pList = pToken;
						pCtx.nList++;
					}

					return pToken;
				}
			}

			return null;
		}
		public static void renameTokenFree(sqlite3 db, RenameToken* pToken)
		{
			RenameToken* pNext;
			RenameToken* p;
			for (p = pToken; p; p = pNext)
			{
				pNext = p->pNext;
				sqlite3DbFree(db, p);
			}
		}
		public static int renameUnmapExprCb(Walker pWalker, Expr pExpr)
		{
			Parse pParse = pWalker.pParse;
			sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr));
			if ((((pExpr).flags & (0x1000000 | 0x2000000)) == (0)))
			{
				sqlite3RenameTokenRemap(pParse, null, (void*)(pExpr.y.pTab));
			}

			return (int)(0);
		}
		public static int renameUnmapSelectCb(Walker pWalker, Select p)
		{
			Parse pParse = pWalker.pParse;
			int i = 0;
			if ((pParse.nErr) != 0)
				return (int)(2);
			if ((p.selFlags & (0x0200000 | 0x4000000)) != 0)
			{
				return (int)(1);
			}

			if ((p.pEList) != null)
			{
				ExprList pList = p.pEList;
				for (i = (int)(0); (i) < (pList.nExpr); i++)
				{
					if (((pList.a[i].zEName) != null) && ((pList.a[i].eEName) == (0)))
					{
						sqlite3RenameTokenRemap(pParse, null, (void*)(pList.a[i].zEName));
					}
				}
			}

			if ((p.pSrc) != null)
			{
				SrcList pSrc = p.pSrc;
				for (i = (int)(0); (i) < (pSrc.nSrc); i++)
				{
					sqlite3RenameTokenRemap(pParse, null, (void*)(pSrc.a[i].zName));
					sqlite3WalkExpr(pWalker, pSrc.a[i].pOn);
					unmapColumnIdlistNames(pParse, pSrc.a[i].pUsing);
				}
			}

			renameWalkWith(pWalker, p);
			return (int)(0);
		}
		public static void renameWalkTrigger(Walker pWalker, Trigger pTrigger)
		{
			TriggerStep pStep;
			sqlite3WalkExpr(pWalker, pTrigger.pWhen);
			for (pStep = pTrigger.step_list; pStep; pStep = pStep.pNext)
			{
				sqlite3WalkSelect(pWalker, pStep.pSelect);
				sqlite3WalkExpr(pWalker, pStep.pWhere);
				sqlite3WalkExprList(pWalker, pStep.pExprList);
				if ((pStep.pUpsert) != null)
				{
					Upsert pUpsert = pStep.pUpsert;
					sqlite3WalkExprList(pWalker, pUpsert.pUpsertTarget);
					sqlite3WalkExprList(pWalker, pUpsert.pUpsertSet);
					sqlite3WalkExpr(pWalker, pUpsert.pUpsertWhere);
					sqlite3WalkExpr(pWalker, pUpsert.pUpsertTargetWhere);
				}

				if ((pStep.pFrom) != null)
				{
					int i = 0;
					for (i = (int)(0); (i) < (pStep.pFrom.nSrc); i++)
					{
						sqlite3WalkSelect(pWalker, pStep.pFrom.a[i].pSelect);
					}
				}
			}
		}
		public static void renameWalkWith(Walker pWalker, Select pSelect)
		{
			With pWith = pSelect.pWith;
			if ((pWith) != null)
			{
				Parse pParse = pWalker.pParse;
				int i = 0;
				With pCopy = null;

				if ((pWith.a[0].pSelect.selFlags & 0x0000040) == (0))
				{
					pCopy = sqlite3WithDup(pParse.db, pWith);
					pCopy = sqlite3WithPush(pParse, pCopy, (byte)(1));
				}

				for (i = (int)(0); (i) < (pWith.nCte); i++)
				{
					Select p = pWith.a[i].pSelect;
					NameContext sNC = new NameContext();
					CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
					sNC.pParse = pParse;
					if ((pCopy) != null)
						sqlite3SelectPrep(sNC.pParse, p, sNC);
					if ((sNC.pParse.db.mallocFailed) != 0)
						return;
					sqlite3WalkSelect(pWalker, p);
					sqlite3RenameExprlistUnmap(pParse, pWith.a[i].pCols);
				}

				if (((pCopy) != null) && ((pParse.pWith) == (pCopy)))
				{
					pParse.pWith = pCopy.pOuter;
				}
			}
		}
		public static void renderLogMsg(int iErrCode, sbyte* zFormat, sbyte* ap)
		{
			sqlite3_str acc = new sqlite3_str();
			sbyte* zMsg = stackalloc sbyte[210];
			sqlite3StrAccumInit(acc, null, zMsg, (int)(210 * sizeof(sbyte)), (int)(0));
			sqlite3_str_vappendf(acc, zFormat, ap);
			sqlite3Config.xLog(sqlite3Config.pLogArg, (int)(iErrCode), sqlite3StrAccumFinish(acc));
		}
		public static void renumberCursorDoMapping(Walker pWalker, int* piCursor)
		{
			int* aCsrMap = pWalker.u.aiCol;
			int iCsr = (int)(*piCursor);
			if (((iCsr) < (aCsrMap[0])) && ((aCsrMap[iCsr + 1]) > (0)))
			{
				*piCursor = (int)(aCsrMap[iCsr + 1]);
			}
		}
		public static void renumberCursors(Parse pParse, Select p, int iExcept, int* aCsrMap)
		{
			Walker w = new Walker();
			srclistRenumberCursors(pParse, aCsrMap, p.pSrc, (int)(iExcept));
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			w.u.aiCol = aCsrMap;
			w.xExprCallback = renumberCursorsCb;
			w.xSelectCallback = sqlite3SelectWalkNoop;
			sqlite3WalkSelect(w, p);
		}
		public static int renumberCursorsCb(Walker pWalker, Expr pExpr)
		{
			int op = (int)(pExpr.op);
			if (((op) == (167)) || ((op) == (179)))
			{
				renumberCursorDoMapping(pWalker, &pExpr.iTable);
			}

			if ((((pExpr).flags & (0x000001)) != 0))
			{
				renumberCursorDoMapping(pWalker, &pExpr.w.iRightJoinTable);
			}

			return (int)(0);
		}
		public static void replaceFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zStr;
			byte* zPattern;
			byte* zRep;
			byte* zOut;
			int nStr = 0;
			int nPattern = 0;
			int nRep = 0;
			long nOut = 0;
			int loopLimit = 0;
			int i = 0; int j = 0;
			uint cntExpand = 0;
			sqlite3 db = sqlite3_context_db_handle(context);


			zStr = sqlite3_value_text(argv[0]);
			if ((zStr) == (null))
				return;
			nStr = (int)(sqlite3_value_bytes(argv[0]));

			zPattern = sqlite3_value_text(argv[1]);
			if ((zPattern) == (null))
			{

				return;
			}

			if ((zPattern[0]) == (0))
			{

				sqlite3_result_value(context, argv[0]);
				return;
			}

			nPattern = (int)(sqlite3_value_bytes(argv[1]));

			zRep = sqlite3_value_text(argv[2]);
			if ((zRep) == (null))
				return;
			nRep = (int)(sqlite3_value_bytes(argv[2]));

			nOut = (long)(nStr + 1);

			zOut = contextMalloc(context, (long)(nOut));
			if ((zOut) == (null))
			{
				return;
			}

			loopLimit = (int)(nStr - nPattern);
			cntExpand = (uint)(0);
			for (i = (int)(j = (int)(0)); (i) <= (loopLimit); i++)
			{
				if ((zStr[i] != zPattern[0]) || ((memcmp(&zStr[i], zPattern, (ulong)(nPattern))) != 0))
				{
					zOut[j++] = (byte)(zStr[i]);
				}
				else
				{
					if ((nRep) > (nPattern))
					{
						nOut += (long)(nRep - nPattern);
						if ((nOut - 1) > (db.aLimit[0]))
						{
							sqlite3_result_error_toobig(context);
							sqlite3_free(zOut);
							return;
						}

						cntExpand++;
						if ((cntExpand & (cntExpand - 1)) == (0))
						{
							byte* zOld;
							zOld = zOut;
							zOut = sqlite3Realloc(zOut, (ulong)((int)(nOut) + (nOut - nStr - 1)));
							if ((zOut) == (null))
							{
								sqlite3_result_error_nomem(context);
								sqlite3_free(zOld);
								return;
							}
						}
					}

					CRuntime.memcpy(&zOut[j], zRep, (ulong)(nRep));
					j += (int)(nRep);
					i += (int)(nPattern - 1);
				}
			}


			CRuntime.memcpy(&zOut[j], &zStr[i], (ulong)(nStr - i));
			j += (int)(nStr - i);

			zOut[j] = (byte)(0);
			sqlite3_result_text(context, (sbyte*)(zOut), (int)(j), sqlite3_free);
		}
		public static void resetAccumulator(Parse pParse, AggInfo pAggInfo)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			AggInfo_func* pFunc;
			int nReg = (int)(pAggInfo.nFunc + pAggInfo.nColumn);


			if ((nReg) == (0))
				return;
			if ((pParse.nErr) != 0)
				return;
			sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(pAggInfo.mnReg), (int)(pAggInfo.mxReg));
			for (pFunc = pAggInfo.aFunc, i = (int)(0); (i) < (pAggInfo.nFunc); i++, pFunc++)
			{
				if ((pFunc->iDistinct) >= (0))
				{
					Expr pE = pFunc->pFExpr;

					if (((pE.x.pList) == (null)) || (pE.x.pList.nExpr != 1))
					{
						sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one argument");
						pFunc->iDistinct = (int)(-1);
					}
					else
					{
						KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE.x.pList, (int)(0), (int)(0));
						pFunc->iDistAddr = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(pFunc->iDistinct), (int)(0), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
						sqlite3VdbeExplain(pParse, (byte)(0), "USE TEMP B-TREE FOR %s(DISTINCT)", pFunc->pFunc.zName);
					}
				}
			}
		}
		public static int resizeIndexObject(sqlite3 db, Index pIdx, int N)
		{
			sbyte* zExtra;
			int nByte = 0;
			if ((pIdx.nColumn) >= (N))
				return (int)(0);

			nByte = (int)((sizeof(char*) + sizeof(short) + sizeof(short) + 1) * N);
			zExtra = sqlite3DbMallocZero(db, (ulong)(nByte));
			if ((zExtra) == (null))
				return (int)(7);
			CRuntime.memcpy(zExtra, pIdx.azColl, (ulong)(sizeof(char*) * pIdx.nColumn));
			pIdx.azColl = (sbyte**)(zExtra);
			zExtra += sizeof(char*) * N;
			CRuntime.memcpy(zExtra, pIdx.aiRowLogEst, (ulong)(sizeof(short) * (pIdx.nKeyCol + 1)));
			pIdx.aiRowLogEst = (short*)(zExtra);
			zExtra += sizeof(short) * N;
			CRuntime.memcpy(zExtra, pIdx.aiColumn, (ulong)(sizeof(short) * pIdx.nColumn));
			pIdx.aiColumn = (short*)(zExtra);
			zExtra += sizeof(short) * N;
			CRuntime.memcpy(zExtra, pIdx.aSortOrder, (ulong)(pIdx.nColumn));
			pIdx.aSortOrder = (byte*)(zExtra);
			pIdx.nColumn = (ushort)(N);
			pIdx.isResized = (uint)(1);
			return (int)(0);
		}
		public static void resizeResolveLabel(Parse p, Vdbe v, int j)
		{
			int nNewSize = (int)(10 - p.nLabel);
			p.aLabel = sqlite3DbReallocOrFree(p.db, p.aLabel, (ulong)(nNewSize * sizeof(int)));
			if ((p.aLabel) == (null))
			{
				p.nLabelAlloc = (int)(0);
			}
			else
			{
				p.nLabelAlloc = (int)(nNewSize);
				p.aLabel[j] = (int)(v.nOp);
			}
		}
		public static void resolveAlias(Parse pParse, ExprList pEList, int iCol, Expr pExpr, int nSubquery)
		{
			Expr pOrig;
			Expr pDup;
			sqlite3 db;

			pOrig = pEList.a[iCol].pExpr;

			db = pParse.db;
			pDup = sqlite3ExprDup(db, pOrig, (int)(0));
			if ((db.mallocFailed) != 0)
			{
				sqlite3ExprDelete(db, pDup);
				pDup = null;
			}
			else
			{
				incrAggFunctionDepth(pDup, (int)(nSubquery));
				if ((pExpr.op) == (113))
				{

					pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr.u.zToken);
				}

				(pExpr).flags |= (uint)(0x8000000);
				sqlite3ExprDelete(db, pExpr);
				CRuntime.memcpy(pExpr, pDup, (ulong)(sizeof(Expr)));
				if ((!(((pExpr).flags & (0x000400)) != 0)) && (pExpr.u.zToken != null))
				{

					pExpr.u.zToken = sqlite3DbStrDup(db, pExpr.u.zToken);
					pExpr.flags |= (uint)(0x010000);
				}

				if ((((pExpr).flags & (0x1000000)) != 0))
				{
					if ((pExpr.y.pWin != null))
					{
						pExpr.y.pWin.pOwner = pExpr;
					}
				}

				sqlite3DbFree(db, pDup);
			}
		}
		public static int resolveAsName(Parse pParse, ExprList pEList, Expr pE)
		{
			int i = 0;
			(void)(pParse);
			if ((pE.op) == (59))
			{
				sbyte* zCol;

				zCol = pE.u.zToken;
				for (i = (int)(0); (i) < (pEList.nExpr); i++)
				{
					if (((pEList.a[i].eEName) == (0)) && ((sqlite3_stricmp(pEList.a[i].zEName, zCol)) == (0)))
					{
						return (int)(i + 1);
					}
				}
			}

			return (int)(0);
		}
		public static int resolveAttachExpr(NameContext pName, Expr pExpr)
		{
			int rc = (int)(0);
			if ((pExpr) != null)
			{
				if (pExpr.op != 59)
				{
					rc = (int)(sqlite3ResolveExprNames(pName, pExpr));
				}
				else
				{
					pExpr.op = (byte)(117);
				}
			}

			return (int)(rc);
		}
		public static int resolveCompoundOrderBy(Parse pParse, Select pSelect)
		{
			int i = 0;
			ExprList pOrderBy;
			ExprList pEList;
			sqlite3 db;
			int moreToDo = (int)(1);
			pOrderBy = pSelect.pOrderBy;
			if ((pOrderBy) == (null))
				return (int)(0);
			db = pParse.db;
			if ((pOrderBy.nExpr) > (db.aLimit[2]))
			{
				sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
				return (int)(1);
			}

			for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
			{
				pOrderBy.a[i].done = (uint)(0);
			}

			pSelect.pNext = null;
			while ((pSelect.pPrior) != null)
			{
				pSelect.pPrior.pNext = pSelect;
				pSelect = pSelect.pPrior;
			}

			while (((pSelect) != null) && ((moreToDo) != 0))
			{
				ExprList_item* pItem;
				moreToDo = (int)(0);
				pEList = pSelect.pEList;

				for (i = (int)(0), pItem = pOrderBy.a; (i) < (pOrderBy.nExpr); i++, pItem++)
				{
					int iCol = (int)(-1);
					Expr pE;
					Expr pDup;
					if ((pItem->done) != 0)
						continue;
					pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
					if (((pE) == (null)))
						continue;
					if ((sqlite3ExprIsInteger(pE, &iCol)) != 0)
					{
						if (((iCol) <= (0)) || ((iCol) > (pEList.nExpr)))
						{
							resolveOutOfRangeError(pParse, "ORDER", (int)(i + 1), (int)(pEList.nExpr), pE);
							return (int)(1);
						}
					}
					else
					{
						iCol = (int)(resolveAsName(pParse, pEList, pE));
						if ((iCol) == (0))
						{
							pDup = sqlite3ExprDup(db, pE, (int)(0));
							if (db.mallocFailed == 0)
							{

								iCol = (int)(resolveOrderByTermToExprList(pParse, pSelect, pDup));
								if (((pParse.eParseMode) >= (2)) && ((iCol) > (0)))
								{
									resolveOrderByTermToExprList(pParse, pSelect, pE);
								}
							}

							sqlite3ExprDelete(db, pDup);
						}
					}

					if ((iCol) > (0))
					{
						if (!((pParse.eParseMode) >= (2)))
						{
							Expr pNew = sqlite3Expr(db, (int)(155), null);
							if ((pNew) == (null))
								return (int)(1);
							pNew.flags |= (uint)(0x000400);
							pNew.u.iValue = (int)(iCol);
							if ((pItem->pExpr) == (pE))
							{
								pItem->pExpr = pNew;
							}
							else
							{
								Expr pParent = pItem->pExpr;

								while ((pParent.pLeft.op) == (113))
								{
									pParent = pParent.pLeft;
								}


								pParent.pLeft = pNew;
							}

							sqlite3ExprDelete(db, pE);
							pItem->u.x.iOrderByCol = ((ushort)(iCol));
						}

						pItem->done = (uint)(1);
					}
					else
					{
						moreToDo = (int)(1);
					}
				}

				pSelect = pSelect.pNext;
			}

			for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
			{
				if ((pOrderBy.a[i].done) == (0))
				{
					sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any column in the result set", (int)(i + 1));
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int resolveExprStep(Walker pWalker, Expr pExpr)
		{
			NameContext pNC;
			Parse pParse;
			pNC = pWalker.u.pNC;

			pParse = pNC.pParse;

			switch (pExpr.op)
			{
				case 75:
					{
						SrcList pSrcList = pNC.pSrcList;
						SrcItem pItem;

						pItem = pSrcList.a;
						pExpr.op = (byte)(167);

						pExpr.y.pTab = pItem.pTab;
						pExpr.iTable = (int)(pItem.iCursor);
						pExpr.iColumn--;
						pExpr.affExpr = (sbyte)(0x44);
						break;
					}

				case 51:
				case 50:
					{
						int* anRef = stackalloc int[8];
						NameContext p;
						int i = 0;
						for (i = (int)(0), p = pNC; ((p) != null) && ((i) < ((int)(8 * sizeof(int) / sizeof(int)))); p = p.pNext, i++)
						{
							anRef[i] = (int)(p.nRef);
						}

						sqlite3WalkExpr(pWalker, pExpr.pLeft);
						if (((0) == (sqlite3ExprCanBeNull(pExpr.pLeft))) && (!((pParse.eParseMode) >= (2))))
						{

							if ((pExpr.op) == (51))
							{
								pExpr.u.zToken = "true";
								(pExpr).flags |= (uint)(0x10000000);
							}
							else
							{
								pExpr.u.zToken = "false";
								(pExpr).flags |= (uint)(0x20000000);
							}

							pExpr.op = (byte)(170);
							for (i = (int)(0), p = pNC; ((p) != null) && ((i) < ((int)(8 * sizeof(int) / sizeof(int)))); p = p.pNext, i++)
							{
								p.nRef = (int)(anRef[i]);
							}

							sqlite3ExprDelete(pParse.db, pExpr.pLeft);
							pExpr.pLeft = null;
						}

						return (int)(1);
					}

				case 59:
				case 141:
					{
						sbyte* zColumn;
						sbyte* zTable;
						sbyte* zDb;
						Expr pRight;
						if ((pExpr.op) == (59))
						{
							zDb = null;
							zTable = null;

							zColumn = pExpr.u.zToken;
						}
						else
						{
							Expr pLeft = pExpr.pLeft;

							if (((pNC).ncFlags & (0x000020 | 0x000008)) != 0)
								notValidImpl(pParse, pNC, "the \".\" operator", null, pExpr);
							pRight = pExpr.pRight;
							if ((pRight.op) == (59))
							{
								zDb = null;
							}
							else
							{


								zDb = pLeft.u.zToken;
								pLeft = pRight.pLeft;
								pRight = pRight.pRight;
							}


							zTable = pLeft.u.zToken;
							zColumn = pRight.u.zToken;

							if (((pParse.eParseMode) >= (2)))
							{
								sqlite3RenameTokenRemap(pParse, (void*)(pExpr), (void*)(pRight));
								sqlite3RenameTokenRemap(pParse, (void*)(pExpr.y.pTab), (void*)(pLeft));
							}
						}

						return (int)(lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr));
					}

				case 172:
					{
						ExprList pList = pExpr.x.pList;
						int n = (int)(pList ? pList.nExpr : 0);
						int no_such_func = (int)(0);
						int wrong_num_args = (int)(0);
						int is_agg = (int)(0);
						sbyte* zId;
						FuncDef pDef;
						byte enc = (byte)((pParse.db).enc);
						int savedAllowFlags = (int)(pNC.ncFlags & (0x000001 | 0x004000));
						Window pWin = (((((pExpr).flags & (0x1000000)) != 0) && (pExpr.y.pWin.eFrmType != 166)) ? pExpr.y.pWin : null);

						zId = pExpr.u.zToken;
						pDef = sqlite3FindFunction(pParse.db, zId, (int)(n), (byte)(enc), (byte)(0));
						if ((pDef) == (null))
						{
							pDef = sqlite3FindFunction(pParse.db, zId, (int)(-2), (byte)(enc), (byte)(0));
							if ((pDef) == (null))
							{
								no_such_func = (int)(1);
							}
							else
							{
								wrong_num_args = (int)(1);
							}
						}
						else
						{
							is_agg = (int)(pDef.xFinalize != null);
							if ((pDef.funcFlags & 0x0400) != 0)
							{
								(pExpr).flags |= (uint)(0x040000);
								if ((n) == (2))
								{
									pExpr.iTable = (int)(exprProbability(pList.a[1].pExpr));
									if ((pExpr.iTable) < (0))
									{
										sqlite3ErrorMsg(pParse, "second argument to %#T() must be a constant between 0.0 and 1.0", pExpr);
										pNC.nNcErr++;
									}
								}
								else
								{
									pExpr.iTable = (int)((pDef.zName[0]) == (117) ? 8388608 : 125829120);
								}
							}

							{
								int auth = (int)(sqlite3AuthCheck(pParse, (int)(31), null, pDef.zName, null));
								if (auth != 0)
								{
									if ((auth) == (1))
									{
										sqlite3ErrorMsg(pParse, "not authorized to use function: %#T", pExpr);
										pNC.nNcErr++;
									}

									pExpr.op = (byte)(121);
									return (int)(1);
								}
							}

							if ((pDef.funcFlags & (0x0800 | 0x2000)) != 0)
							{
								(pExpr).flags |= (uint)(0x080000);
							}

							if ((pDef.funcFlags & 0x0800) == (0))
							{

								if (((pNC).ncFlags & (0x000020 | 0x000002 | 0x000008)) != 0)
									notValidImpl(pParse, pNC, "non-deterministic functions", null, pExpr);
							}
							else
							{

								pExpr.op2 = (byte)(pNC.ncFlags & 0x00002e);
								if ((pNC.ncFlags & 0x040000) != 0)
									(pExpr).flags |= (uint)(0x40000000);
							}

							if ((((pDef.funcFlags & 0x00040000) != 0) && ((pParse.nested) == (0))) && ((pParse.db.mDbFlags & 0x0020) == (0)))
							{
								no_such_func = (int)(1);
								pDef = null;
							}
							else if (((pDef.funcFlags & (0x00080000 | 0x00200000)) != 0) && (!((pParse.eParseMode) >= (2))))
							{
								sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
							}
						}

						if ((0) == ((pParse.eParseMode) >= (2)))
						{

							if ((((pDef) != null) && ((pDef.xValue) == (null))) && ((pWin) != null))
							{
								sqlite3ErrorMsg(pParse, "%#T() may not be used as a window function", pExpr);
								pNC.nNcErr++;
							}
							else if (((((is_agg) != 0) && ((pNC.ncFlags & 0x000001) == (0))) || ((((is_agg) != 0) && ((pDef.funcFlags & 0x00010000) != 0)) && (pWin == null))) || ((((is_agg) != 0) && ((pWin) != null)) && ((pNC.ncFlags & 0x004000) == (0))))
							{
								sbyte* zType;
								if (((pDef.funcFlags & 0x00010000) != 0) || ((pWin) != null))
								{
									zType = "window";
								}
								else
								{
									zType = "aggregate";
								}

								sqlite3ErrorMsg(pParse, "misuse of %s function %#T()", zType, pExpr);
								pNC.nNcErr++;
								is_agg = (int)(0);
							}
							else if (((no_such_func) != 0) && ((pParse.db.init.busy) == (0)))
							{
								sqlite3ErrorMsg(pParse, "no such function: %#T", pExpr);
								pNC.nNcErr++;
							}
							else if ((wrong_num_args) != 0)
							{
								sqlite3ErrorMsg(pParse, "wrong number of arguments to function %#T()", pExpr);
								pNC.nNcErr++;
							}
							else if (((is_agg) == (0)) && (((pExpr).flags & (0x1000000)) != 0))
							{
								sqlite3ErrorMsg(pParse, "FILTER may not be used with non-aggregate %#T()", pExpr);
								pNC.nNcErr++;
							}

							if ((is_agg) != 0)
							{
								pNC.ncFlags &= (int)(~(0x004000 | ((!pWin) != 0 ? 0x000001 : 0)));
							}
						}
						else if ((((pExpr).flags & (0x1000000)) != 0))
						{
							is_agg = (int)(1);
						}

						sqlite3WalkExprList(pWalker, pList);
						if ((is_agg) != 0)
						{
							if ((pWin) != null)
							{
								Select pSel = pNC.pWinSelect;

								if (((pParse.eParseMode) >= (2)) == (0))
								{
									sqlite3WindowUpdate(pParse, pSel ? pSel.pWinDefn : null, pWin, pDef);
									if ((pParse.db.mallocFailed) != 0)
										break;
								}

								sqlite3WalkExprList(pWalker, pWin.pPartition);
								sqlite3WalkExprList(pWalker, pWin.pOrderBy);
								sqlite3WalkExpr(pWalker, pWin.pFilter);
								sqlite3WindowLink(pSel, pWin);
								pNC.ncFlags |= (int)(0x008000);
							}
							else
							{
								NameContext pNC2;
								pExpr.op = (byte)(168);
								pExpr.op2 = (byte)(0);
								if ((((pExpr).flags & (0x1000000)) != 0))
								{
									sqlite3WalkExpr(pWalker, pExpr.y.pWin.pFilter);
								}

								pNC2 = pNC;
								while (((pNC2) != null) && ((sqlite3ReferencesSrcList(pParse, pExpr, pNC2.pSrcList)) == (0)))
								{
									pExpr.op2++;
									pNC2 = pNC2.pNext;
								}


								if (((pNC2) != null) && ((pDef) != null))
								{


									pNC2.ncFlags |= (int)(0x000010 | ((pDef.funcFlags ^ 0x08000000) & (0x1000 | 0x08000000)));
								}
							}

							pNC.ncFlags |= (int)(savedAllowFlags);
						}

						return (int)(1);
					}

				case 138:
				case 20:
					;
				case 49:
					{
						if ((((pExpr).flags & 0x000800) != 0))
						{
							int nRef = (int)(pNC.nRef);
							if ((pNC.ncFlags & 0x00002e) != 0)
							{
								notValidImpl(pParse, pNC, "subqueries", pExpr, pExpr);
							}
							else
							{
								sqlite3WalkSelect(pWalker, pExpr.x.pSelect);
							}


							if (nRef != pNC.nRef)
							{
								(pExpr).flags |= (uint)(0x000020);
								pNC.ncFlags |= (int)(0x000040);
							}
						}

						break;
					}

				case 156:
					{

						if (((pNC).ncFlags & (0x000004 | 0x000002 | 0x000020 | 0x000008)) != 0)
							notValidImpl(pParse, pNC, "parameters", pExpr, pExpr);
						break;
					}

				case 45:
				case 171:
					{
						Expr pRight = sqlite3ExprSkipCollateAndLikely(pExpr.pRight);

						if (((pRight) != null) && (((pRight.op) == (59)) || ((pRight.op) == (170))))
						{
							int rc = (int)(resolveExprStep(pWalker, pRight));
							if ((rc) == (2))
								return (int)(2);
							if ((pRight.op) == (170))
							{
								pExpr.op2 = (byte)(pExpr.op);
								pExpr.op = (byte)(175);
								return (int)(0);
							}
						}
					}

				case 48:
				case 53:
				case 52:
				case 56:
				case 55:
				case 54:
				case 57:
					{
						int nLeft = 0;
						int nRight = 0;
						if ((pParse.db.mallocFailed) != 0)
							break;

						nLeft = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
						if ((pExpr.op) == (48))
						{

							nRight = (int)(sqlite3ExprVectorSize(pExpr.x.pList.a[0].pExpr));
							if ((nRight) == (nLeft))
							{
								nRight = (int)(sqlite3ExprVectorSize(pExpr.x.pList.a[1].pExpr));
							}
						}
						else
						{

							nRight = (int)(sqlite3ExprVectorSize(pExpr.pRight));
						}

						if (nLeft != nRight)
						{
							sqlite3ErrorMsg(pParse, "row value misused");
							sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
						}

						break;
					}
			}


			return (int)((pParse.nErr) != 0 ? 2 : 0);
		}
		public static int resolveFromTermToCte(Parse pParse, Walker pWalker, SrcItem pFrom)
		{
			Cte pCte;
			With pWith;

			if ((pParse.pWith) == (null))
			{
				return (int)(0);
			}

			if ((pParse.nErr) != 0)
			{
				return (int)(0);
			}

			if (pFrom.zDatabase != null)
			{
				return (int)(0);
			}

			if ((pFrom.fg.notCte) != 0)
			{
				return (int)(0);
			}

			pCte = searchWith(pParse.pWith, pFrom, pWith);
			if ((pCte) != null)
			{
				sqlite3 db = pParse.db;
				Table pTab;
				ExprList pEList;
				Select pSel;
				Select pLeft;
				Select pRecTerm;
				int bMayRecursive = 0;
				With pSavedWith;
				int iRecTab = (int)(-1);
				CteUse* pCteUse;
				if ((pCte.zCteErr) != null)
				{
					sqlite3ErrorMsg(pParse, pCte.zCteErr, pCte.zName);
					return (int)(2);
				}

				if ((cannotBeFunction(pParse, pFrom)) != 0)
					return (int)(2);

				pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
				if ((pTab) == (null))
					return (int)(2);
				pCteUse = pCte.pUse;
				if ((pCteUse) == (null))
				{
					pCte.pUse = pCteUse = sqlite3DbMallocZero(db, (ulong)(sizeof(CteUse)));
					if (((pCteUse) == (null)) || ((sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pCteUse)) == (null)))
					{
						sqlite3DbFree(db, pTab);
						return (int)(2);
					}

					pCteUse->eM10d = (byte)(pCte.eM10d);
				}

				pFrom.pTab = pTab;
				pTab.nTabRef = (uint)(1);
				pTab.zName = sqlite3DbStrDup(db, pCte.zName);
				pTab.iPKey = (short)(-1);
				pTab.nRowLogEst = (short)(200);

				pTab.tabFlags |= (uint)(0x00004000 | 0x00000200);
				pFrom.pSelect = sqlite3SelectDup(db, pCte.pSelect, (int)(0));
				if ((db.mallocFailed) != 0)
					return (int)(2);
				pFrom.pSelect.selFlags |= (uint)(0x4000000);

				if ((pFrom.fg.isIndexedBy) != 0)
				{
					sqlite3ErrorMsg(pParse, "no such index: \"%s\"", pFrom.u1.zIndexedBy);
					return (int)(2);
				}

				pFrom.fg.isCte = (uint)(1);
				pFrom.u2.pCteUse = pCteUse;
				pCteUse->nUse++;
				if (((pCteUse->nUse) >= (2)) && ((pCteUse->eM10d) == (1)))
				{
					pCteUse->eM10d = (byte)(0);
				}

				pRecTerm = pSel = pFrom.pSelect;
				bMayRecursive = (int)(((pSel.op) == (135)) || ((pSel.op) == (134)) ? 1 : 0);
				while (((bMayRecursive) != 0) && ((pRecTerm.op) == (pSel.op)))
				{
					int i = 0;
					SrcList pSrc = pRecTerm.pSrc;

					for (i = (int)(0); (i) < (pSrc.nSrc); i++)
					{
						SrcItem pItem = pSrc.a[i];
						if ((((pItem.zDatabase) == (null)) && (pItem.zName != null)) && ((0) == (sqlite3StrICmp(pItem.zName, pCte.zName))))
						{
							pItem.pTab = pTab;
							pTab.nTabRef++;
							pItem.fg.isRecursive = (uint)(1);
							if ((pRecTerm.selFlags & 0x0002000) != 0)
							{
								sqlite3ErrorMsg(pParse, "multiple references to recursive table: %s", pCte.zName);
								return (int)(2);
							}

							pRecTerm.selFlags |= (uint)(0x0002000);
							if ((iRecTab) < (0))
								iRecTab = (int)(pParse.nTab++);
							pItem.iCursor = (int)(iRecTab);
						}
					}

					if ((pRecTerm.selFlags & 0x0002000) == (0))
						break;
					pRecTerm = pRecTerm.pPrior;
				}

				pCte.zCteErr = "circular reference: %s";
				pSavedWith = pParse.pWith;
				pParse.pWith = pWith;
				if ((pSel.selFlags & 0x0002000) != 0)
				{
					int rc = 0;





					pRecTerm.pWith = pSel.pWith;
					rc = (int)(sqlite3WalkSelect(pWalker, pRecTerm));
					pRecTerm.pWith = null;
					if ((rc) != 0)
					{
						pParse.pWith = pSavedWith;
						return (int)(2);
					}
				}
				else
				{
					if ((sqlite3WalkSelect(pWalker, pSel)) != 0)
					{
						pParse.pWith = pSavedWith;
						return (int)(2);
					}
				}

				pParse.pWith = pWith;
				for (pLeft = pSel; pLeft.pPrior; pLeft = pLeft.pPrior)
				{
				}

				pEList = pLeft.pEList;
				if ((pCte.pCols) != null)
				{
					if (((pEList) != null) && (pEList.nExpr != pCte.pCols.nExpr))
					{
						sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns", pCte.zName, (int)(pEList.nExpr), (int)(pCte.pCols.nExpr));
						pParse.pWith = pSavedWith;
						return (int)(2);
					}

					pEList = pCte.pCols;
				}

				sqlite3ColumnsFromExprList(pParse, pEList, &pTab.nCol, &pTab.aCol);
				if ((bMayRecursive) != 0)
				{
					if ((pSel.selFlags & 0x0002000) != 0)
					{
						pCte.zCteErr = "multiple recursive references: %s";
					}
					else
					{
						pCte.zCteErr = "recursive reference in a subquery: %s";
					}

					sqlite3WalkSelect(pWalker, pSel);
				}

				pCte.zCteErr = null;
				pParse.pWith = pSavedWith;
				return (int)(1);
			}

			return (int)(0);
		}
		public static int resolveOrderByTermToExprList(Parse pParse, Select pSelect, Expr pE)
		{
			int i = 0;
			ExprList pEList;
			NameContext nc = new NameContext();
			sqlite3 db;
			int rc = 0;
			byte savedSuppErr = 0;

			pEList = pSelect.pEList;
			CRuntime.memset(nc, (int)(0), (ulong)(sizeof(NameContext)));
			nc.pParse = pParse;
			nc.pSrcList = pSelect.pSrc;
			nc.uNC.pEList = pEList;
			nc.ncFlags = (int)(0x000001 | 0x000080 | 0x080000);
			nc.nNcErr = (int)(0);
			db = pParse.db;
			savedSuppErr = (byte)(db.suppressErr);
			db.suppressErr = (byte)(1);
			rc = (int)(sqlite3ResolveExprNames(nc, pE));
			db.suppressErr = (byte)(savedSuppErr);
			if ((rc) != 0)
				return (int)(0);
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				if ((sqlite3ExprCompare(null, pEList.a[i].pExpr, pE, (int)(-1))) < (2))
				{
					return (int)(i + 1);
				}
			}

			return (int)(0);
		}
		public static int resolveOrderGroupBy(NameContext pNC, Select pSelect, ExprList pOrderBy, sbyte* zType)
		{
			int i = 0; int j = 0;
			int iCol = 0;
			ExprList_item* pItem;
			Parse pParse;
			int nResult = 0;

			nResult = (int)(pSelect.pEList.nExpr);
			pParse = pNC.pParse;
			for (i = (int)(0), pItem = pOrderBy.a; (i) < (pOrderBy.nExpr); i++, pItem++)
			{
				Expr pE = pItem->pExpr;
				Expr pE2 = sqlite3ExprSkipCollateAndLikely(pE);
				if (((pE2) == (null)))
					continue;
				if (zType[0] != 71)
				{
					iCol = (int)(resolveAsName(pParse, pSelect.pEList, pE2));
					if ((iCol) > (0))
					{
						pItem->u.x.iOrderByCol = ((ushort)(iCol));
						continue;
					}
				}

				if ((sqlite3ExprIsInteger(pE2, &iCol)) != 0)
				{
					if (((iCol) < (1)) || ((iCol) > (0xffff)))
					{
						resolveOutOfRangeError(pParse, zType, (int)(i + 1), (int)(nResult), pE2);
						return (int)(1);
					}

					pItem->u.x.iOrderByCol = ((ushort)(iCol));
					continue;
				}

				pItem->u.x.iOrderByCol = (ushort)(0);
				if ((sqlite3ResolveExprNames(pNC, pE)) != 0)
				{
					return (int)(1);
				}

				for (j = (int)(0); (j) < (pSelect.pEList.nExpr); j++)
				{
					if ((sqlite3ExprCompare(null, pE, pSelect.pEList.a[j].pExpr, (int)(-1))) == (0))
					{
						windowRemoveExprFromSelect(pSelect, pE);
						pItem->u.x.iOrderByCol = (ushort)(j + 1);
					}
				}
			}

			return (int)(sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType));
		}
		public static void resolveOutOfRangeError(Parse pParse, sbyte* zType, int i, int mx, Expr pError)
		{
			sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be between 1 and %d", (int)(i), zType, (int)(mx));
			sqlite3RecordErrorOffsetOfExpr(pParse.db, pError);
		}
		public static void resolveP2Values(Vdbe p, int* pMaxFuncArgs)
		{
			int nMaxArgs = (int)(*pMaxFuncArgs);
			VdbeOp* pOp;
			Parse pParse = p.pParse;
			int* aLabel = pParse.aLabel;
			p.readOnly = (uint)(1);
			p.bIsReader = (uint)(0);
			pOp = &p.aOp[p.nOp - 1];
			while ((1) != 0)
			{
				if ((pOp->opcode) <= (64))
				{
					switch (pOp->opcode)
					{
						case 2:
							{
								if (pOp->p2 != 0)
									p.readOnly = (uint)(0);
							}

						case 1:
						case 0:
							{
								p.bIsReader = (uint)(1);
								break;
							}

						case 6:
						case 8:
						case 7:
							{
								p.readOnly = (uint)(0);
								p.bIsReader = (uint)(1);
								break;
							}

						case 5:
						case 3:
							{
								pOp->p4.xAdvance = sqlite3BtreeNext;
								pOp->p4type = (sbyte)(-5);

								break;
							}

						case 4:
							{
								pOp->p4.xAdvance = sqlite3BtreePrevious;
								pOp->p4type = (sbyte)(-5);

								break;
							}

						case 10:
							{
								if ((pOp->p2) > (nMaxArgs))
									nMaxArgs = (int)(pOp->p2);
								break;
							}

						case 9:
							{
								int n = 0;


								n = (int)(pOp[-1].p1);
								if ((n) > (nMaxArgs))
									nMaxArgs = (int)(n);
							}

						default:
							{
								if ((pOp->p2) < (0))
								{


									pOp->p2 = (int)(aLabel[(~(pOp->p2))]);
								}

								break;
							}
					}


				}

				if ((pOp) == (p.aOp))
					break;
				pOp--;
			}

			sqlite3DbFree(p.db, pParse.aLabel);
			pParse.aLabel = null;
			pParse.nLabel = (int)(0);
			*pMaxFuncArgs = (int)(nMaxArgs);

		}
		public static int resolveRemoveWindowsCb(Walker pWalker, Expr pExpr)
		{
			(void)(pWalker);
			if ((((pExpr).flags & (0x1000000)) != 0))
			{
				Window pWin = pExpr.y.pWin;
				sqlite3WindowUnlinkFromSelect(pWin);
			}

			return (int)(0);
		}
		public static int resolveSelectStep(Walker pWalker, Select p)
		{
			NameContext pOuterNC;
			NameContext sNC = new NameContext();
			int isCompound = 0;
			int nCompound = 0;
			Parse pParse;
			int i = 0;
			ExprList pGroupBy;
			Select pLeftmost;
			sqlite3 db;

			if ((p.selFlags & 0x0000004) != 0)
			{
				return (int)(1);
			}

			pOuterNC = pWalker.u.pNC;
			pParse = pWalker.pParse;
			db = pParse.db;
			if ((p.selFlags & 0x0000040) == (0))
			{
				sqlite3SelectPrep(pParse, p, pOuterNC);
				return (int)((pParse.nErr) != 0 ? 2 : 1);
			}

			isCompound = (int)(p.pPrior != null);
			nCompound = (int)(0);
			pLeftmost = p;
			while ((p) != null)
			{



				p.selFlags |= (uint)(0x0000004);
				CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
				sNC.pParse = pParse;
				sNC.pWinSelect = p;
				if ((sqlite3ResolveExprNames(sNC, p.pLimit)) != 0)
				{
					return (int)(2);
				}

				if ((p.selFlags & 0x0010000) != 0)
				{
					Select pSub = p.pSrc.a[0].pSelect;


					pSub.pOrderBy = p.pOrderBy;
					p.pOrderBy = null;
				}

				for (i = (int)(0); (i) < (p.pSrc.nSrc); i++)
				{
					SrcItem pItem = p.pSrc.a[i];
					if (((pItem.pSelect) != null) && ((pItem.pSelect.selFlags & 0x0000004) == (0)))
					{
						int nRef = (int)(pOuterNC ? pOuterNC.nRef : 0);
						sbyte* zSavedContext = pParse.zAuthContext;
						if ((pItem.zName) != null)
							pParse.zAuthContext = pItem.zName;
						sqlite3ResolveSelectNames(pParse, pItem.pSelect, pOuterNC);
						pParse.zAuthContext = zSavedContext;
						if ((pParse.nErr) != 0)
							return (int)(2);

						if ((pOuterNC) != null)
						{

							pItem.fg.isCorrelated = (uint)((pOuterNC.nRef) > (nRef));
						}
					}
				}

				sNC.ncFlags = (int)(0x000001 | 0x004000);
				sNC.pSrcList = p.pSrc;
				sNC.pNext = pOuterNC;
				if ((sqlite3ResolveExprListNames(sNC, p.pEList)) != 0)
					return (int)(2);
				sNC.ncFlags &= (int)(~0x004000);

				pGroupBy = p.pGroupBy;
				if (((pGroupBy) != null) || ((sNC.ncFlags & 0x000010) != 0))
				{


					p.selFlags |= (uint)(0x0000008 | (sNC.ncFlags & (0x001000 | 0x8000000)));
				}
				else
				{
					sNC.ncFlags &= (int)(~0x000001);
				}


				sNC.uNC.pEList = p.pEList;
				sNC.ncFlags |= (int)(0x000080);
				if ((p.pHaving) != null)
				{
					if (pGroupBy == null)
					{
						sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
						return (int)(2);
					}

					if ((sqlite3ResolveExprNames(sNC, p.pHaving)) != 0)
						return (int)(2);
				}

				if ((sqlite3ResolveExprNames(sNC, p.pWhere)) != 0)
					return (int)(2);
				for (i = (int)(0); (i) < (p.pSrc.nSrc); i++)
				{
					SrcItem pItem = p.pSrc.a[i];
					if (((pItem.fg.isTabFunc) != 0) && ((sqlite3ResolveExprListNames(sNC, pItem.u1.pFuncArg)) != 0))
					{
						return (int)(2);
					}
				}

				if (((pParse.eParseMode) >= (2)))
				{
					Window pWin;
					for (pWin = p.pWinDefn; pWin; pWin = pWin.pNextWin)
					{
						if (((sqlite3ResolveExprListNames(sNC, pWin.pOrderBy)) != 0) || ((sqlite3ResolveExprListNames(sNC, pWin.pPartition)) != 0))
						{
							return (int)(2);
						}
					}
				}

				sNC.pNext = null;
				sNC.ncFlags |= (int)(0x000001 | 0x004000);
				if ((p.selFlags & 0x0010000) != 0)
				{
					Select pSub = p.pSrc.a[0].pSelect;
					p.pOrderBy = pSub.pOrderBy;
					pSub.pOrderBy = null;
				}

				if (((p.pOrderBy != null) && ((isCompound) <= (nCompound))) && ((resolveOrderGroupBy(sNC, p, p.pOrderBy, "ORDER")) != 0))
				{
					return (int)(2);
				}

				if ((db.mallocFailed) != 0)
				{
					return (int)(2);
				}

				sNC.ncFlags &= (int)(~0x004000);
				if ((pGroupBy) != null)
				{
					ExprList_item* pItem;
					if (((resolveOrderGroupBy(sNC, p, pGroupBy, "GROUP")) != 0) || ((db.mallocFailed) != 0))
					{
						return (int)(2);
					}

					for (i = (int)(0), pItem = pGroupBy.a; (i) < (pGroupBy.nExpr); i++, pItem++)
					{
						if ((((pItem->pExpr).flags & (0x000010)) != 0))
						{
							sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in the GROUP BY clause");
							return (int)(2);
						}
					}
				}

				if (((p.pNext) != null) && (p.pEList.nExpr != p.pNext.pEList.nExpr))
				{
					sqlite3SelectWrongNumTermsError(pParse, p.pNext);
					return (int)(2);
				}

				p = p.pPrior;
				nCompound++;
			}

			if (((isCompound) != 0) && ((resolveCompoundOrderBy(pParse, pLeftmost)) != 0))
			{
				return (int)(2);
			}

			return (int)(1);
		}
		public static void returnSingleInt(Vdbe v, long value)
		{
			sqlite3VdbeAddOp4Dup8(v, (int)(72), (int)(0), (int)(1), (int)(0), (byte*)(&value), (int)(-14));
			sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
		}
		public static void returnSingleText(Vdbe v, sbyte* zValue)
		{
			if ((zValue) != null)
			{
				sqlite3VdbeLoadString(v, (int)(1), zValue);
				sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
			}
		}
		public static void roundFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int n = (int)(0);
			double r = 0;
			sbyte* zBuf;

			if ((argc) == (2))
			{
				if ((5) == (sqlite3_value_type(argv[1])))
					return;
				n = (int)(sqlite3_value_int(argv[1]));
				if ((n) > (30))
					n = (int)(30);
				if ((n) < (0))
					n = (int)(0);
			}

			if ((sqlite3_value_type(argv[0])) == (5))
				return;
			r = (double)(sqlite3_value_double(argv[0]));
			if (((r) < (-4503599627370496.0)) || ((r) > (+4503599627370496.0)))
			{
			}
			else if ((n) == (0))
			{
				r = ((double)((long)(r + ((r) < (0) ? -0.5 : +0.5))));
			}
			else
			{
				zBuf = sqlite3_mprintf("%.*f", (int)(n), (double)(r));
				if ((zBuf) == (null))
				{
					sqlite3_result_error_nomem(context);
					return;
				}

				sqlite3AtoF(zBuf, &r, (int)(sqlite3Strlen30(zBuf)), (byte)(1));
				sqlite3_free(zBuf);
			}

			sqlite3_result_double(context, (double)(r));
		}
		public static void row_numberStepFunc(sqlite3_context pCtx, int nArg, sqlite3_value apArg)
		{
			long* p = (long*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(long))));
			if ((p) != null)
				(*p)++;
			(void)(nArg);
			(void)(apArg);
		}
		public static void row_numberValueFunc(sqlite3_context pCtx)
		{
			long* p = (long*)(sqlite3_aggregate_context(pCtx, (int)(sizeof(long))));
			sqlite3_result_int64(pCtx, (long)((p) != 0 ? *p : 0));
		}
		public static RowSetEntry* rowSetEntryAlloc(RowSet p)
		{

			if ((p.nFresh) == (0))
			{
				RowSetChunk pNew;
				pNew = sqlite3DbMallocRawNN(p.db, (ulong)(sizeof(RowSetChunk)));
				if ((pNew) == (null))
				{
					return null;
				}

				pNew.pNextChunk = p.pChunk;
				p.pChunk = pNew;
				p.pFresh = pNew.aEntry;
				p.nFresh = (ushort)((1024 - 8) / sizeof(RowSetEntry));
			}

			p.nFresh--;
			return p.pFresh++;
		}
		public static RowSetEntry* rowSetEntryMerge(RowSetEntry* pA, RowSetEntry* pB)
		{
			RowSetEntry head = new RowSetEntry();
			RowSetEntry* pTail;
			pTail = &head;

			for (; ; )
			{


				if ((pA->v) <= (pB->v))
				{
					if ((pA->v) < (pB->v))
						pTail = pTail->pRight = pA;
					pA = pA->pRight;
					if ((pA) == (null))
					{
						pTail->pRight = pB;
						break;
					}
				}
				else
				{
					pTail = pTail->pRight = pB;
					pB = pB->pRight;
					if ((pB) == (null))
					{
						pTail->pRight = pA;
						break;
					}
				}
			}

			return head.pRight;
		}
		public static RowSetEntry* rowSetEntrySort(RowSetEntry* pIn)
		{
			uint i = 0;
			RowSetEntry* pNext; RowSetEntry** aBucket = stackalloc RowSetEntry[40];
			CRuntime.memset(aBucket, (int)(0), (ulong)(40 * sizeof(RowSetEntry)));
			while ((pIn) != null)
			{
				pNext = pIn->pRight;
				pIn->pRight = null;
				for (i = (uint)(0); aBucket[i]; i++)
				{
					pIn = rowSetEntryMerge(aBucket[i], pIn);
					aBucket[i] = null;
				}

				aBucket[i] = pIn;
				pIn = pNext;
			}

			pIn = aBucket[0];
			for (i = (uint)(1); (i) < (40 * sizeof(RowSetEntry) / sizeof(RowSetEntry*)); i++)
			{
				if ((aBucket[i]) == (null))
					continue;
				pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];
			}

			return pIn;
		}
		public static RowSetEntry* rowSetListToTree(RowSetEntry* pList)
		{
			int iDepth = 0;
			RowSetEntry* p;
			RowSetEntry* pLeft;

			p = pList;
			pList = p->pRight;
			p->pLeft = p->pRight = null;
			for (iDepth = (int)(1); pList; iDepth++)
			{
				pLeft = p;
				p = pList;
				pList = p->pRight;
				p->pLeft = pLeft;
				p->pRight = rowSetNDeepTree(&pList, (int)(iDepth));
			}

			return p;
		}
		public static RowSetEntry* rowSetNDeepTree(RowSetEntry** ppList, int iDepth)
		{
			RowSetEntry* p;
			RowSetEntry* pLeft;
			if ((*ppList) == (null))
			{
				return null;
			}

			if ((iDepth) > (1))
			{
				pLeft = rowSetNDeepTree(ppList, (int)(iDepth - 1));
				p = *ppList;
				if ((p) == (null))
				{
					return pLeft;
				}

				p->pLeft = pLeft;
				*ppList = p->pRight;
				p->pRight = rowSetNDeepTree(ppList, (int)(iDepth - 1));
			}
			else
			{
				p = *ppList;
				*ppList = p->pRight;
				p->pLeft = p->pRight = null;
			}

			return p;
		}
		public static void rowSetTreeToList(RowSetEntry* pIn, RowSetEntry** ppFirst, RowSetEntry** ppLast)
		{

			if ((pIn->pLeft) != null)
			{
				RowSetEntry* p;
				rowSetTreeToList(pIn->pLeft, ppFirst, &p);
				p->pRight = pIn;
			}
			else
			{
				*ppFirst = pIn;
			}

			if ((pIn->pRight) != null)
			{
				rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);
			}
			else
			{
				*ppLast = pIn;
			}


		}
		public static int rtrimCollFunc(void* pUser, int nKey1, void* pKey1, int nKey2, void* pKey2)
		{
			byte* pK1 = (byte*)(pKey1);
			byte* pK2 = (byte*)(pKey2);
			while (((nKey1) != 0) && ((pK1[nKey1 - 1]) == (32)))
			{
				nKey1--;
			}

			while (((nKey2) != 0) && ((pK2[nKey2 - 1]) == (32)))
			{
				nKey2--;
			}

			return (int)(binCollFunc(pUser, (int)(nKey1), pKey1, (int)(nKey2), pKey2));
		}
		public static int saveAllCursors(BtShared pBt, uint iRoot, BtCursor pExcept)
		{
			BtCursor p;


			for (p = pBt.pCursor; p; p = p.pNext)
			{
				if ((p != pExcept) && (((0) == (iRoot)) || ((p.pgnoRoot) == (iRoot))))
					break;
			}

			if ((p) != null)
				return (int)(saveCursorsOnList(p, (uint)(iRoot), pExcept));
			if ((pExcept) != null)
				pExcept.curFlags &= (byte)(~0x20);
			return (int)(0);
		}
		public static int saveCursorKey(BtCursor pCur)
		{
			int rc = (int)(0);



			if ((pCur.curIntKey) != 0)
			{
				pCur.nKey = (long)(sqlite3BtreeIntegerKey(pCur));
			}
			else
			{
				void* pKey;
				pCur.nKey = (long)(sqlite3BtreePayloadSize(pCur));
				pKey = sqlite3Malloc((ulong)(pCur.nKey + 9 + 8));
				if ((pKey) != null)
				{
					rc = (int)(sqlite3BtreePayload(pCur, (uint)(0), (uint)((int)(pCur.nKey)), pKey));
					if ((rc) == (0))
					{
						CRuntime.memset(((byte*)(pKey)) + pCur.nKey, (int)(0), (ulong)(9 + 8));
						pCur.pKey = pKey;
					}
					else
					{
						sqlite3_free(pKey);
					}
				}
				else
				{
					rc = (int)(7);
				}
			}


			return (int)(rc);
		}
		public static int saveCursorPosition(BtCursor pCur)
		{
			int rc = 0;



			if ((pCur.curFlags & 0x40) != 0)
			{
				return (int)(19 | (11 << 8));
			}

			if ((pCur.eState) == (2))
			{
				pCur.eState = (byte)(0);
			}
			else
			{
				pCur.skipNext = (int)(0);
			}

			rc = (int)(saveCursorKey(pCur));
			if ((rc) == (0))
			{
				btreeReleaseAllCursorPages(pCur);
				pCur.eState = (byte)(3);
			}

			pCur.curFlags &= (byte)(~(0x02 | 0x04 | 0x08));
			return (int)(rc);
		}
		public static int saveCursorsOnList(BtCursor p, uint iRoot, BtCursor pExcept)
		{
			do
			{
				if ((p != pExcept) && (((0) == (iRoot)) || ((p.pgnoRoot) == (iRoot))))
				{
					if (((p.eState) == (0)) || ((p.eState) == (2)))
					{
						int rc = (int)(saveCursorPosition(p));
						if (0 != rc)
						{
							return (int)(rc);
						}
					}
					else
					{
						btreeReleaseAllCursorPages(p);
					}
				}

				p = p.pNext;
			}
			while ((p) != null);
			return (int)(0);
		}
		public static void schemaIsValid(Parse pParse)
		{
			sqlite3 db = pParse.db;
			int iDb = 0;
			int rc = 0;
			int cookie = 0;


			for (iDb = (int)(0); (iDb) < (db.nDb); iDb++)
			{
				int openedTransaction = (int)(0);
				Btree pBt = db.aDb[iDb].pBt;
				if ((pBt) == (null))
					continue;
				if ((sqlite3BtreeTxnState(pBt)) == (0))
				{
					rc = (int)(sqlite3BtreeBeginTrans(pBt, (int)(0), null));
					if (((rc) == (7)) || ((rc) == (10 | (12 << 8))))
					{
						sqlite3OomFault(db);
						pParse.rc = (int)(7);
					}

					if (rc != 0)
						return;
					openedTransaction = (int)(1);
				}

				sqlite3BtreeGetMeta(pBt, (int)(1), (uint*)(&cookie));

				if (cookie != db.aDb[iDb].pSchema.schema_cookie)
				{
					sqlite3ResetOneSchema(db, (int)(iDb));
					pParse.rc = (int)(17);
				}

				if ((openedTransaction) != 0)
				{
					sqlite3BtreeCommit(pBt);
				}
			}
		}
		public static Cte searchWith(With pWith, SrcItem pItem, With ppContext)
		{
			sbyte* zName = pItem.zName;
			With p;


			for (p = pWith; p; p = p.pOuter)
			{
				int i = 0;
				for (i = (int)(0); (i) < (p.nCte); i++)
				{
					if ((sqlite3StrICmp(zName, p.a[i].zName)) == (0))
					{
						ppContext = p;
						return p.a[i];
					}
				}

				if ((p.bView) != 0)
					break;
			}

			return null;
		}
		public static void selectAddSubqueryTypeInfo(Walker pWalker, Select p)
		{
			Parse pParse;
			int i = 0;
			SrcList pTabList;
			SrcItem pFrom;

			if ((p.selFlags & 0x0000080) != 0)
				return;
			p.selFlags |= (uint)(0x0000080);
			pParse = pWalker.pParse;
			pTabList = p.pSrc;
			for (i = (int)(0), pFrom = pTabList.a; (i) < (pTabList.nSrc); i++, pFrom++)
			{
				Table pTab = pFrom.pTab;

				if ((pTab.tabFlags & 0x00004000) != 0)
				{
					Select pSel = pFrom.pSelect;
					if ((pSel) != null)
					{
						while ((pSel.pPrior) != null)
						{
							pSel = pSel.pPrior;
						}

						sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel, (sbyte)(0x40));
					}
				}
			}
		}
		public static int selectExpander(Walker pWalker, Select p)
		{
			Parse pParse = pWalker.pParse;
			int i = 0; int j = 0; int k = 0; int rc = 0;
			SrcList pTabList;
			ExprList pEList;
			SrcItem pFrom;
			sqlite3 db = pParse.db;
			Expr pE; Expr pRight; Expr pExpr;
			ushort selFlags = (ushort)(p.selFlags);
			uint elistFlags = (uint)(0);
			p.selFlags |= (uint)(0x0000040);
			if ((db.mallocFailed) != 0)
			{
				return (int)(2);
			}


			if ((selFlags & 0x0000040) != 0)
			{
				return (int)(1);
			}

			if ((pWalker.eCode) != 0)
			{
				p.selId = (uint)(++pParse.nSelect);
			}

			pTabList = p.pSrc;
			pEList = p.pEList;
			if (((pParse.pWith) != null) && ((p.selFlags & 0x0200000) != 0))
			{
				if ((p.pWith) == (null))
				{
					p.pWith = (With)(sqlite3DbMallocZero(db, (ulong)(sizeof(With))));
					if ((p.pWith) == (null))
					{
						return (int)(2);
					}
				}

				p.pWith.bView = (int)(1);
			}

			sqlite3WithPush(pParse, p.pWith, (byte)(0));
			sqlite3SrcListAssignCursors(pParse, pTabList);
			for (i = (int)(0), pFrom = pTabList.a; (i) < (pTabList.nSrc); i++, pFrom++)
			{
				Table pTab;

				if ((pFrom.pTab) != null)
					continue;

				if ((pFrom.zName) == (null))
				{
					Select pSel = pFrom.pSelect;


					if ((sqlite3WalkSelect(pWalker, pSel)) != 0)
						return (int)(2);
					if ((sqlite3ExpandSubquery(pParse, pFrom)) != 0)
						return (int)(2);
				}
				else if ((rc = (int)(resolveFromTermToCte(pParse, pWalker, pFrom))) != 0)
				{
					if ((rc) > (1))
						return (int)(2);
					pTab = pFrom.pTab;

				}
				else
				{

					pFrom.pTab = pTab = sqlite3LocateTableItem(pParse, (uint)(0), pFrom);
					if ((pTab) == (null))
						return (int)(2);
					if ((pTab.nTabRef) >= (0xffff))
					{
						sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535", pTab.zName);
						pFrom.pTab = null;
						return (int)(2);
					}

					pTab.nTabRef++;
					if ((!(((pTab).eTabType) == (1))) && ((cannotBeFunction(pParse, pFrom)) != 0))
					{
						return (int)(2);
					}

					if (!(((pTab).eTabType) == (0)))
					{
						short nCol = 0;
						byte eCodeOrig = (byte)(pWalker.eCode);
						if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
							return (int)(2);

						if ((((pTab).eTabType) == (2)))
						{
							if (((db.flags & 0x80000000) == (0)) && (pTab.pSchema != db.aDb[1].pSchema))
							{
								sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited", pTab.zName);
							}

							pFrom.pSelect = sqlite3SelectDup(db, pTab.u.view.pSelect, (int)(0));
						}
						else if (((((((pTab).eTabType) == (1)) != 0) && ((pFrom.fg.fromDDL) != 0)) && (pTab.u.vtab.p != null)) && ((pTab.u.vtab.p.eVtabRisk) > ((db.flags & 0x00000080) != 0)))
						{
							sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"", pTab.zName);
						}


						nCol = (short)(pTab.nCol);
						pTab.nCol = (short)(-1);
						pWalker.eCode = (ushort)(1);
						sqlite3WalkSelect(pWalker, pFrom.pSelect);
						pWalker.eCode = (ushort)(eCodeOrig);
						pTab.nCol = (short)(nCol);
					}
				}

				if (((pFrom.fg.isIndexedBy) != 0) && ((sqlite3IndexedByLookup(pParse, pFrom)) != 0))
				{
					return (int)(2);
				}
			}


			if (((pParse.nErr) != 0) || ((sqliteProcessJoin(pParse, p)) != 0))
			{
				return (int)(2);
			}

			for (k = (int)(0); (k) < (pEList.nExpr); k++)
			{
				pE = pEList.a[k].pExpr;
				if ((pE.op) == (180))
					break;


				if (((pE.op) == (141)) && ((pE.pRight.op) == (180)))
					break;
				elistFlags |= (uint)(pE.flags);
			}

			if ((k) < (pEList.nExpr))
			{
				ExprList_item* a = pEList.a;
				ExprList pNew = null;
				int flags = (int)(pParse.db.flags);
				int longNames = (int)(((flags & 0x00000004) != 0) && ((flags & 0x00000040) == (0)) ? 1 : 0);
				for (k = (int)(0); (k) < (pEList.nExpr); k++)
				{
					pE = a[k].pExpr;
					elistFlags |= (uint)(pE.flags);
					pRight = pE.pRight;

					if ((pE.op != 180) && ((pE.op != 141) || (pRight.op != 180)))
					{
						pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
						if ((pNew) != null)
						{
							pNew.a[pNew.nExpr - 1].zEName = a[k].zEName;
							pNew.a[pNew.nExpr - 1].eEName = (uint)(a[k].eEName);
							a[k].zEName = null;
						}

						a[k].pExpr = null;
					}
					else
					{
						int tableSeen = (int)(0);
						sbyte* zTName = null;
						if ((pE.op) == (141))
						{


							zTName = pE.pLeft.u.zToken;
						}

						for (i = (int)(0), pFrom = pTabList.a; (i) < (pTabList.nSrc); i++, pFrom++)
						{
							Table pTab = pFrom.pTab;
							Select pSub = pFrom.pSelect;
							sbyte* zTabName = pFrom.zAlias;
							sbyte* zSchemaName = null;
							int iDb = 0;
							if ((zTabName) == (null))
							{
								zTabName = pTab.zName;
							}

							if ((db.mallocFailed) != 0)
								break;
							if (((pSub) == (null)) || ((pSub.selFlags & 0x0000800) == (0)))
							{
								pSub = null;
								if (((zTName) != null) && (sqlite3StrICmp(zTName, zTabName) != 0))
								{
									continue;
								}

								iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
								zSchemaName = (iDb) >= (0) ? db.aDb[iDb].zDbSName : "*";
							}

							for (j = (int)(0); (j) < (pTab.nCol); j++)
							{
								sbyte* zName = pTab.aCol[j].zCnName;
								sbyte* zColname;
								sbyte* zToFree;
								Token sColname = new Token();

								if ((((zTName) != null) && ((pSub) != null)) && ((sqlite3MatchEName(&pSub.pEList.a[j], null, zTName, null)) == (0)))
								{
									continue;
								}

								if (((p.selFlags & 0x0020000) == (0)) && (((&pTab.aCol[j])->colFlags & 0x0002) != 0))
								{
									continue;
								}

								tableSeen = (int)(1);
								if (((i) > (0)) && ((zTName) == (null)))
								{
									if (((pFrom.fg.jointype & 0x0004) != 0) && ((tableAndColumnIndex(pTabList, (int)(i), zName, null, null, (int)(1))) != 0))
									{
										continue;
									}

									if ((sqlite3IdListIndex(pFrom.pUsing, zName)) >= (0))
									{
										continue;
									}
								}

								pRight = sqlite3Expr(db, (int)(59), zName);
								zColname = zName;
								zToFree = null;
								if (((longNames) != 0) || ((pTabList.nSrc) > (1)))
								{
									Expr pLeft;
									pLeft = sqlite3Expr(db, (int)(59), zTabName);
									pExpr = sqlite3PExpr(pParse, (int)(141), pLeft, pRight);
									if ((zSchemaName) != null)
									{
										pLeft = sqlite3Expr(db, (int)(59), zSchemaName);
										pExpr = sqlite3PExpr(pParse, (int)(141), pLeft, pExpr);
									}

									if ((longNames) != 0)
									{
										zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
										zToFree = zColname;
									}
								}
								else
								{
									pExpr = pRight;
								}

								pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
								sqlite3TokenInit(&sColname, zColname);
								sqlite3ExprListSetName(pParse, pNew, &sColname, (int)(0));
								if ((((pNew) != null) && ((p.selFlags & 0x0000800) != 0)) && (!((pParse.eParseMode) >= (2))))
								{
									ExprList_item* pX = &pNew.a[pNew.nExpr - 1];
									sqlite3DbFree(db, pX->zEName);
									if ((pSub) != null)
									{
										pX->zEName = sqlite3DbStrDup(db, pSub.pEList.a[j].zEName);
									}
									else
									{
										pX->zEName = sqlite3MPrintf(db, "%s.%s.%s", zSchemaName, zTabName, zColname);
									}

									pX->eEName = (uint)(2);
								}

								sqlite3DbFree(db, zToFree);
							}
						}

						if (tableSeen == 0)
						{
							if ((zTName) != null)
							{
								sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
							}
							else
							{
								sqlite3ErrorMsg(pParse, "no tables specified");
							}
						}
					}
				}

				sqlite3ExprListDelete(db, pEList);
				p.pEList = pNew;
			}

			if ((p.pEList) != null)
			{
				if ((p.pEList.nExpr) > (db.aLimit[2]))
				{
					sqlite3ErrorMsg(pParse, "too many columns in result set");
					return (int)(2);
				}

				if ((elistFlags & (0x000004 | 0x200000)) != 0)
				{
					p.selFlags |= (uint)(0x0040000);
				}
			}

			return (int)(0);
		}
		public static void selectInnerLoop(Parse pParse, Select p, int srcTab, SortCtx pSort, DistinctCtx* pDistinct, SelectDest pDest, int iContinue, int iBreak)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			int hasDistinct = 0;
			int eDest = (int)(pDest.eDest);
			int iParm = (int)(pDest.iSDParm);
			int nResultCol = 0;
			int nPrefixReg = (int)(0);
			RowLoadInfo sRowLoadInfo = new RowLoadInfo();
			int regResult = 0;
			int regOrig = 0;


			hasDistinct = (int)(pDistinct ? pDistinct->eTnctType : 0);
			if (((pSort) != null) && ((pSort.pOrderBy) == (null)))
				pSort = null;
			if (((pSort) == (null)) && (hasDistinct == 0))
			{

				codeOffset(v, (int)(p.iOffset), (int)(iContinue));
			}

			nResultCol = (int)(p.pEList.nExpr);
			if ((pDest.iSdst) == (0))
			{
				if ((pSort) != null)
				{
					nPrefixReg = (int)(pSort.pOrderBy.nExpr);
					if ((pSort.sortFlags & 0x01) == 0)
						nPrefixReg++;
					pParse.nMem += (int)(nPrefixReg);
				}

				pDest.iSdst = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nResultCol);
			}
			else if ((pDest.iSdst + nResultCol) > (pParse.nMem))
			{
				pParse.nMem += (int)(nResultCol);
			}

			pDest.nSdst = (int)(nResultCol);
			regOrig = (int)(regResult = (int)(pDest.iSdst));
			if ((srcTab) >= (0))
			{
				for (i = (int)(0); (i) < (nResultCol); i++)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(i), (int)(regResult + i));
				}
			}
			else if (eDest != 3)
			{
				byte ecelFlags = 0;
				ExprList pEList;
				if ((((eDest) == (10)) || ((eDest) == (9))) || ((eDest) == (13)))
				{
					ecelFlags = (byte)(0x01);
				}
				else
				{
					ecelFlags = (byte)(0);
				}

				if (((((pSort) != null) && ((hasDistinct) == (0))) && (eDest != 12)) && (eDest != 14))
				{
					ecelFlags |= (byte)(0x08 | 0x04);
					for (i = (int)(pSort.nOBSat); (i) < (pSort.pOrderBy.nExpr); i++)
					{
						int j = 0;
						if ((j = (int)(pSort.pOrderBy.a[i].u.x.iOrderByCol)) > (0))
						{
							p.pEList.a[j - 1].u.x.iOrderByCol = (ushort)(i + 1 - pSort.nOBSat);
						}
					}

					pEList = p.pEList;
					for (i = (int)(0); (i) < (pEList.nExpr); i++)
					{
						if ((pEList.a[i].u.x.iOrderByCol) > (0))
						{
							nResultCol--;
							regOrig = (int)(0);
						}
					}


				}

				sRowLoadInfo.regResult = (int)(regResult);
				sRowLoadInfo.ecelFlags = (byte)(ecelFlags);
				if ((((p.iLimit) != 0) && ((ecelFlags & 0x08) != 0)) && ((nPrefixReg) > (0)))
				{


					pSort.pDeferredRowLoad = &sRowLoadInfo;
					regOrig = (int)(0);
				}
				else
				{
					innerLoopLoadRow(pParse, p, &sRowLoadInfo);
				}
			}

			if ((hasDistinct) != 0)
			{
				int eType = (int)(pDistinct->eTnctType);
				int iTab = (int)(pDistinct->tabTnct);

				iTab = (int)(codeDistinct(pParse, (int)(eType), (int)(iTab), (int)(iContinue), p.pEList, (int)(regResult)));
				fixDistinctOpenEph(pParse, (int)(eType), (int)(iTab), (int)(pDistinct->addrTnct));
				if ((pSort) == (null))
				{
					codeOffset(v, (int)(p.iOffset), (int)(iContinue));
				}
			}

			switch (eDest)
			{
				case 1:
					{
						int r1 = 0;
						r1 = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(nResultCol));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						break;
					}

				case 2:
					{
						sqlite3VdbeAddOp3(v, (int)(139), (int)(iParm), (int)(regResult), (int)(nResultCol));
						break;
					}

				case 8:
				case 5:
				case 14:
				case 12:
					{
						int r1 = (int)(sqlite3GetTempRange(pParse, (int)(nPrefixReg + 1)));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1 + nPrefixReg));
						if ((eDest) == (5))
						{
							int addr = (int)(sqlite3VdbeCurrentAddr(v) + 4);
							sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iParm + 1), (int)(addr), (int)(r1), (int)(0));
							sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm + 1), (int)(r1), (int)(regResult), (int)(nResultCol));

						}

						if ((pSort) != null)
						{

							pushOntoSorter(pParse, pSort, p, (int)(r1 + nPrefixReg), (int)(regOrig), (int)(1), (int)(nPrefixReg));
						}
						else
						{
							int r2 = (int)(sqlite3GetTempReg(pParse));
							sqlite3VdbeAddOp2(v, (int)(126), (int)(iParm), (int)(r2));
							sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(r2));
							sqlite3VdbeChangeP5(v, (ushort)(0x08));
							sqlite3ReleaseTempReg(pParse, (int)(r2));
						}

						sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(nPrefixReg + 1));
						break;
					}

				case 15:
					{
						if ((pSort) != null)
						{
							pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
						}
						else
						{
							int i2 = (int)(pDest.iSDParm2);
							int r1 = (int)(sqlite3GetTempReg(pParse));
							sqlite3VdbeAddOp2(v, (int)(50), (int)(regResult), (int)(iBreak));
							sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult + ((i2) < (0))), (int)(nResultCol - ((i2) < (0))), (int)(r1));
							if ((i2) < (0))
							{
								sqlite3VdbeAddOp3(v, (int)(127), (int)(iParm), (int)(r1), (int)(regResult));
							}
							else
							{
								sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(i2));
							}
						}

						break;
					}

				case 11:
					{
						if ((pSort) != null)
						{
							pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
						}
						else
						{
							int r1 = (int)(sqlite3GetTempReg(pParse));

							sqlite3VdbeAddOp4(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r1), pDest.zAffSdst, (int)(nResultCol));
							sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(regResult), (int)(nResultCol));
							sqlite3ReleaseTempReg(pParse, (int)(r1));
						}

						break;
					}

				case 3:
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iParm));
						break;
					}

				case 10:
					{
						if ((pSort) != null)
						{

							pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
						}
						else
						{


						}

						break;
					}

				case 13:
				case 9:
					{
						if ((pSort) != null)
						{
							pushOntoSorter(pParse, pSort, p, (int)(regResult), (int)(regOrig), (int)(nResultCol), (int)(nPrefixReg));
						}
						else if ((eDest) == (13))
						{
							sqlite3VdbeAddOp1(v, (int)(14), (int)(pDest.iSDParm));
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(83), (int)(regResult), (int)(nResultCol));
						}

						break;
					}

				case 6:
				case 7:
					{
						int nKey = 0;
						int r1 = 0;
						int r2 = 0;
						int r3 = 0;
						int addrTest = (int)(0);
						ExprList pSO;
						pSO = pDest.pOrderBy;

						nKey = (int)(pSO.nExpr);
						r1 = (int)(sqlite3GetTempReg(pParse));
						r2 = (int)(sqlite3GetTempRange(pParse, (int)(nKey + 2)));
						r3 = (int)(r2 + nKey + 1);
						if ((eDest) == (6))
						{
							addrTest = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iParm + 1), (int)(0), (int)(regResult), (int)(nResultCol)));
						}

						sqlite3VdbeAddOp3(v, (int)(96), (int)(regResult), (int)(nResultCol), (int)(r3));
						if ((eDest) == (6))
						{
							sqlite3VdbeAddOp2(v, (int)(137), (int)(iParm + 1), (int)(r3));
							sqlite3VdbeChangeP5(v, (ushort)(0x10));
						}

						for (i = (int)(0); (i) < (nKey); i++)
						{
							sqlite3VdbeAddOp2(v, (int)(80), (int)(regResult + pSO.a[i].u.x.iOrderByCol - 1), (int)(r2 + i));
						}

						sqlite3VdbeAddOp2(v, (int)(125), (int)(iParm), (int)(r2 + nKey));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(r2), (int)(nKey + 2), (int)(r1));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iParm), (int)(r1), (int)(r2), (int)(nKey + 2));
						if ((addrTest) != 0)
							sqlite3VdbeJumpHere(v, (int)(addrTest));
						sqlite3ReleaseTempReg(pParse, (int)(r1));
						sqlite3ReleaseTempRange(pParse, (int)(r2), (int)(nKey + 2));
						break;
					}

				default:
					{

						break;
					}
			}

			if (((pSort) == (null)) && ((p.iLimit) != 0))
			{
				sqlite3VdbeAddOp2(v, (int)(60), (int)(p.iLimit), (int)(iBreak));
			}
		}
		public static int selectRefEnter(Walker pWalker, Select pSelect)
		{
			RefSrcList p = pWalker.u.pRefSrcList;
			SrcList pSrc = pSelect.pSrc;
			long i = 0; long j = 0;
			int* piNew;
			if ((pSrc.nSrc) == (0))
				return (int)(0);
			j = (long)(p.nExclude);
			p.nExclude += (long)(pSrc.nSrc);
			piNew = sqlite3DbRealloc(p.db, p.aiExclude, (ulong)(p.nExclude * sizeof(int)));
			if ((piNew) == (null))
			{
				p.nExclude = (long)(0);
				return (int)(2);
			}
			else
			{
				p.aiExclude = piNew;
			}

			for (i = (long)(0); (i) < (pSrc.nSrc); i++, j++)
			{
				p.aiExclude[j] = (int)(pSrc.a[i].iCursor);
			}

			return (int)(0);
		}
		public static void selectRefLeave(Walker pWalker, Select pSelect)
		{
			RefSrcList p = pWalker.u.pRefSrcList;
			SrcList pSrc = pSelect.pSrc;
			if ((p.nExclude) != 0)
			{

				p.nExclude -= (long)(pSrc.nSrc);
			}
		}
		public static void selectWindowRewriteEList(Parse pParse, Window pWin, SrcList pSrc, ExprList pEList, Table pTab, ExprList ppSub)
		{
			Walker sWalker = new Walker();
			WindowRewrite sRewrite = new WindowRewrite();

			CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
			CRuntime.memset(sRewrite, (int)(0), (ulong)(sizeof(WindowRewrite)));
			sRewrite.pSub = ppSub;
			sRewrite.pWin = pWin;
			sRewrite.pSrc = pSrc;
			sRewrite.pTab = pTab;
			sWalker.pParse = pParse;
			sWalker.xExprCallback = selectWindowRewriteExprCb;
			sWalker.xSelectCallback = selectWindowRewriteSelectCb;
			sWalker.u.pRewrite = sRewrite;
			(void)(sqlite3WalkExprList(sWalker, pEList));
			ppSub = sRewrite.pSub;
		}
		public static int selectWindowRewriteExprCb(Walker pWalker, Expr pExpr)
		{
			WindowRewrite p = pWalker.u.pRewrite;
			Parse pParse = pWalker.pParse;


			if ((p.pSubSelect) != null)
			{
				if (pExpr.op != 167)
				{
					return (int)(0);
				}
				else
				{
					int nSrc = (int)(p.pSrc.nSrc);
					int i = 0;
					for (i = (int)(0); (i) < (nSrc); i++)
					{
						if ((pExpr.iTable) == (p.pSrc.a[i].iCursor))
							break;
					}

					if ((i) == (nSrc))
						return (int)(0);
				}
			}

			switch (pExpr.op)
			{
				case 172:
					if (!(((pExpr).flags & (0x1000000)) != 0))
					{
						break;
					}
					else
					{
						Window pWin;
						for (pWin = p.pWin; pWin; pWin = pWin.pNextWin)
						{
							if ((pExpr.y.pWin) == (pWin))
							{

								return (int)(1);
							}
						}
					}

				case 168:
				case 167:
					{
						int iCol = (int)(-1);
						if ((pParse.db.mallocFailed) != 0)
							return (int)(2);
						if ((p.pSub) != null)
						{
							int i = 0;
							for (i = (int)(0); (i) < (p.pSub.nExpr); i++)
							{
								if ((0) == (sqlite3ExprCompare(null, p.pSub.a[i].pExpr, pExpr, (int)(-1))))
								{
									iCol = (int)(i);
									break;
								}
							}
						}

						if ((iCol) < (0))
						{
							Expr pDup = sqlite3ExprDup(pParse.db, pExpr, (int)(0));
							if (((pDup) != null) && ((pDup.op) == (168)))
								pDup.op = (byte)(172);
							p.pSub = sqlite3ExprListAppend(pParse, p.pSub, pDup);
						}

						if ((p.pSub) != null)
						{
							int f = (int)(pExpr.flags & 0x000100);

							(pExpr).flags |= (uint)(0x8000000);
							sqlite3ExprDelete(pParse.db, pExpr);
							(pExpr).flags &= (uint)(~(0x8000000));
							CRuntime.memset(pExpr, (int)(0), (ulong)(sizeof(Expr)));
							pExpr.op = (byte)(167);
							pExpr.iColumn = (short)((iCol) < (0) ? p.pSub.nExpr - 1 : iCol);
							pExpr.iTable = (int)(p.pWin.iEphCsr);
							pExpr.y.pTab = p.pTab;
							pExpr.flags = (uint)(f);
						}

						if ((pParse.db.mallocFailed) != 0)
							return (int)(2);
						break;
					}

				default:
					break;
			}

			return (int)(0);
		}
		public static int selectWindowRewriteSelectCb(Walker pWalker, Select pSelect)
		{
			WindowRewrite p = pWalker.u.pRewrite;
			Select pSave = p.pSubSelect;
			if ((pSave) == (pSelect))
			{
				return (int)(0);
			}
			else
			{
				p.pSubSelect = pSelect;
				sqlite3WalkSelect(pWalker, pSelect);
				p.pSubSelect = pSave;
			}

			return (int)(1);
		}
		public static void serialGet(byte* buf, uint serial_type, sqlite3_value pMem)
		{
			ulong x = (ulong)(((uint)((buf)[0]) << 24) | ((buf)[1] << 16) | ((buf)[2] << 8) | (buf)[3]);
			uint y = (uint)(((uint)((buf + 4)[0]) << 24) | ((buf + 4)[1] << 16) | ((buf + 4)[2] << 8) | (buf + 4)[3]);
			x = (ulong)((x << 32) + y);
			if ((serial_type) == (6))
			{
				pMem.u.i = (long)(*(long*)(&x));
				pMem.flags = (ushort)(0x0004);
			}
			else
			{

				CRuntime.memcpy(&pMem.u.r, &x, (ulong)(sizeof(ulong)));
				pMem.flags = (ushort)(((((x) & (((ulong)(0x7ff)) << 52)) == (((ulong)(0x7ff)) << 52)) && (((x) & ((((ulong)(1)) << 52) - 1)) != 0)) ? 0x0001 : 0x0008);
			}
		}
		public static void setAllPagerFlags(sqlite3 db)
		{
			if ((db.autoCommit) != 0)
			{
				Db pDb = db.aDb;
				int n = (int)(db.nDb);





				while ((n--) > (0))
				{
					if ((pDb.pBt) != null)
					{
						sqlite3BtreeSetPagerFlags(pDb.pBt, (uint)(pDb.safety_level | (db.flags & 0x38)));
					}

					pDb++;
				}
			}
		}
		public static int setChildPtrmaps(MemPage pPage)
		{
			int i = 0;
			int nCell = 0;
			int rc = 0;
			BtShared pBt = pPage.pBt;
			uint pgno = (uint)(pPage.pgno);

			rc = (int)((pPage.isInit) != 0 ? 0 : btreeInitPage(pPage));
			if (rc != 0)
				return (int)(rc);
			nCell = (int)(pPage.nCell);
			for (i = (int)(0); (i) < (nCell); i++)
			{
				byte* pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (i)])))));
				ptrmapPutOvflPtr(pPage, pPage, pCell, &rc);
				if (pPage.leaf == 0)
				{
					uint childPgno = (uint)(sqlite3Get4byte(pCell));
					ptrmapPut(pBt, (uint)(childPgno), (byte)(5), (uint)(pgno), &rc);
				}
			}

			if (pPage.leaf == 0)
			{
				uint childPgno = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				ptrmapPut(pBt, (uint)(childPgno), (byte)(5), (uint)(pgno), &rc);
			}

			return (int)(rc);
		}
		public static int setDateTimeToCurrent(sqlite3_context context, DateTime* p)
		{
			p->iJD = (long)(sqlite3StmtCurrentTime(context));
			if ((p->iJD) > (0))
			{
				p->validJD = (sbyte)(1);
				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static int setDestPgsz(sqlite3_backup p)
		{
			int rc = 0;
			rc = (int)(sqlite3BtreeSetPageSize(p.pDest, (int)(sqlite3BtreeGetPageSize(p.pSrc)), (int)(0), (int)(0)));
			return (int)(rc);
		}
		public static void setDoNotMergeFlagOnCopy(Vdbe v)
		{
			if ((sqlite3VdbeGetOp(v, (int)(-1))->opcode) == (79))
			{
				sqlite3VdbeChangeP5(v, (ushort)(1));
			}
		}
		public static void setGetterMethod(Pager pPager)
		{
			if ((pPager.errCode) != 0)
			{
				pPager.xGet = getPageError;
			}
			else if (((pPager).bUseFetch) != 0)
			{
				pPager.xGet = getPageMMap;
			}
			else
			{
				pPager.xGet = getPageNormal;
			}
		}
		public static void setPageReferenced(IntegrityCk pCheck, uint iPg)
		{

			pCheck.aPgRef[iPg / 8] |= (byte)(1 << (iPg & 0x07));
		}
		public static void setPragmaResultColumnNames(Vdbe v, PragmaName* pPragma)
		{
			byte n = (byte)(pPragma->nPragCName);
			sqlite3VdbeSetNumCols(v, (int)((n) == (0) ? 1 : n));
			if ((n) == (0))
			{
				sqlite3VdbeSetColName(v, (int)(0), (int)(0), pPragma->zName, null);
			}
			else
			{
				int i = 0;
				int j = 0;
				for (i = (int)(0), j = (int)(pPragma->iPragCName); (i) < (n); i++, j++)
				{
					sqlite3VdbeSetColName(v, (int)(i), (int)(0), pragCName[j], null);
				}
			}
		}
		public static void setRawDateNumber(DateTime* p, double r)
		{
			p->s = (double)(r);
			p->rawS = (sbyte)(1);
			if (((r) >= (0.0)) && ((r) < (5373484.5)))
			{
				p->iJD = ((long)(r * 86400000.0 + 0.5));
				p->validJD = (sbyte)(1);
			}
		}
		public static void setResultStrOrError(sqlite3_context pCtx, sbyte* z, int n, byte enc, delegate17 xDel)
		{
			int rc = (int)(sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(enc), xDel));
			if ((rc) != 0)
			{
				if ((rc) == (18))
				{
					sqlite3_result_error_toobig(pCtx);
				}
				else
				{

					sqlite3_result_error_nomem(pCtx);
				}
			}
		}
		public static void setSectorSize(Pager pPager)
		{

			if (((pPager.tempFile) != 0) || ((sqlite3OsDeviceCharacteristics(pPager.fd) & 0x00001000) != 0))
			{
				pPager.sectorSize = (uint)(512);
			}
			else
			{
				pPager.sectorSize = (uint)(sqlite3SectorSize(pPager.fd));
			}
		}
		public static int setSharedCacheTableLock(Btree p, uint iTable, byte eLock)
		{
			BtShared pBt = p.pBt;
			BtLock pLock = null;
			BtLock pIter;






			for (pIter = pBt.pLock; pIter; pIter = pIter.pNext)
			{
				if (((pIter.iTable) == (iTable)) && ((pIter.pBtree) == (p)))
				{
					pLock = pIter;
					break;
				}
			}

			if (pLock == null)
			{
				pLock = (BtLock)(sqlite3MallocZero((ulong)(sizeof(BtLock))));
				if (pLock == null)
				{
					return (int)(7);
				}

				pLock.iTable = (uint)(iTable);
				pLock.pBtree = p;
				pLock.pNext = pBt.pLock;
				pBt.pLock = pLock;
			}


			if ((eLock) > (pLock.eLock))
			{
				pLock.eLock = (byte)(eLock);
			}

			return (int)(0);
		}
		public static int setupLookaside(sqlite3 db, void* pBuf, int sz, int cnt)
		{
			void* pStart;
			long szAlloc = (long)(sz * (long)(cnt));
			int nBig = 0;
			int nSm = 0;
			if ((sqlite3LookasideUsed(db, null)) > (0))
			{
				return (int)(5);
			}

			if ((db.lookaside.bMalloced) != 0)
			{
				sqlite3_free(db.lookaside.pStart);
			}

			sz = (int)((sz) & ~7);
			if ((sz) <= ((int)(sizeof(LookasideSlot))))
				sz = (int)(0);
			if ((cnt) < (0))
				cnt = (int)(0);
			if (((sz) == (0)) || ((cnt) == (0)))
			{
				sz = (int)(0);
				pStart = null;
			}
			else if ((pBuf) == (null))
			{
				sqlite3BeginBenignMalloc();
				pStart = sqlite3Malloc((ulong)(szAlloc));
				sqlite3EndBenignMalloc();
				if ((pStart) != null)
					szAlloc = (long)(sqlite3MallocSize(pStart));
			}
			else
			{
				pStart = pBuf;
			}

			if ((sz) >= (128 * 3))
			{
				nBig = (int)(szAlloc / (3 * 128 + sz));
				nSm = (int)((szAlloc - sz * nBig) / 128);
			}
			else if ((sz) >= (128 * 2))
			{
				nBig = (int)(szAlloc / (128 + sz));
				nSm = (int)((szAlloc - sz * nBig) / 128);
			}
			else if ((sz) > (0))
			{
				nBig = (int)(szAlloc / sz);
				nSm = (int)(0);
			}
			else
			{
				nBig = (int)(nSm = (int)(0));
			}

			db.lookaside.pStart = pStart;
			db.lookaside.pInit = null;
			db.lookaside.pFree = null;
			db.lookaside.sz = ((ushort)(sz));
			db.lookaside.szTrue = ((ushort)(sz));
			if ((pStart) != null)
			{
				int i = 0;
				LookasideSlot* p;

				p = (LookasideSlot*)(pStart);
				for (i = (int)(0); (i) < (nBig); i++)
				{
					p->pNext = db.lookaside.pInit;
					db.lookaside.pInit = p;
					p = (LookasideSlot*)(&((byte*)(p))[sz]);
				}

				db.lookaside.pSmallInit = null;
				db.lookaside.pSmallFree = null;
				db.lookaside.pMiddle = p;
				for (i = (int)(0); (i) < (nSm); i++)
				{
					p->pNext = db.lookaside.pSmallInit;
					db.lookaside.pSmallInit = p;
					p = (LookasideSlot*)(&((byte*)(p))[128]);
				}


				db.lookaside.pEnd = p;
				db.lookaside.bDisable = (uint)(0);
				db.lookaside.bMalloced = (byte)((pBuf) == (null) ? 1 : 0);
				db.lookaside.nSlot = (uint)(nBig + nSm);
			}
			else
			{
				db.lookaside.pStart = db;
				db.lookaside.pSmallInit = null;
				db.lookaside.pSmallFree = null;
				db.lookaside.pMiddle = db;
				db.lookaside.pEnd = db;
				db.lookaside.bDisable = (uint)(1);
				db.lookaside.sz = (ushort)(0);
				db.lookaside.bMalloced = (byte)(0);
				db.lookaside.nSlot = (uint)(0);
			}


			return (int)(0);
		}
		public static void signFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int type0 = 0;
			double x = 0;


			type0 = (int)(sqlite3_value_numeric_type(argv[0]));
			if ((type0 != 1) && (type0 != 2))
				return;
			x = (double)(sqlite3_value_double(argv[0]));
			sqlite3_result_int(context, (int)((x) < (0.0) ? -1 : (x) > (0.0) ? +1 : 0));
		}
		public static void sourceidFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			sqlite3_result_text(context, sqlite3_sourceid(), (int)(-1), null);
		}
		public static void* sqlite3_aggregate_context(sqlite3_context p, int nByte)
		{


			if ((p.pMem.flags & 0x2000) == (0))
			{
				return createAggContext(p, (int)(nByte));
			}
			else
			{
				return (void*)(p.pMem.z);
			}
		}
		public static int sqlite3_aggregate_count(sqlite3_context p)
		{

			return (int)(p.pMem.n);
		}
		public static int sqlite3_auto_extension(delegate73 xInit)
		{
			int rc = (int)(0);
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
			{
				return (int)(rc);
			}
			else
			{
				uint i = 0;
				sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
				sqlite3_mutex_enter(mutex);
				for (i = (uint)(0); (i) < (sqlite3Autoext.nExt); i++)
				{
					if ((sqlite3Autoext.aExt[i]) == (xInit))
						break;
				}

				if ((i) == (sqlite3Autoext.nExt))
				{
					ulong nByte = (ulong)((sqlite3Autoext.nExt + 1) * sizeof(Void()) )
            ;
					delegate170 aNew;
					aNew = sqlite3_realloc64(sqlite3Autoext.aExt, (ulong)(nByte));
					if ((aNew) == (null))
					{
						rc = (int)(7);
					}
					else
					{
						sqlite3Autoext.aExt = aNew;
						sqlite3Autoext.aExt[sqlite3Autoext.nExt] = xInit;
						sqlite3Autoext.nExt++;
					}
				}

				sqlite3_mutex_leave(mutex);

				return (int)(rc);
			}
		}
		public static int sqlite3_autovacuum_pages(sqlite3 db, delegate64 xCallback, void* pArg, delegate17 xDestructor)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((db.xAutovacDestr) != null)
			{
				db.xAutovacDestr(db.pAutovacPagesArg);
			}

			db.xAutovacPages = xCallback;
			db.pAutovacPagesArg = pArg;
			db.xAutovacDestr = xDestructor;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_backup_finish(sqlite3_backup p)
		{
			sqlite3_backup pp;
			sqlite3 pSrcDb;
			int rc = 0;
			if ((p) == (null))
				return (int)(0);
			pSrcDb = p.pSrcDb;
			sqlite3_mutex_enter(pSrcDb.mutex);
			sqlite3BtreeEnter(p.pSrc);
			if ((p.pDestDb) != null)
			{
				sqlite3_mutex_enter(p.pDestDb.mutex);
			}

			if ((p.pDestDb) != null)
			{
				p.pSrc.nBackup--;
			}

			if ((p.isAttached) != 0)
			{
				pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p.pSrc));

				while (pp != p)
				{
					pp = (pp).pNext;

				}

				pp = p.pNext;
			}

			sqlite3BtreeRollback(p.pDest, (int)(0), (int)(0));
			rc = (int)(((p.rc) == (101)) ? 0 : p.rc);
			if ((p.pDestDb) != null)
			{
				sqlite3Error(p.pDestDb, (int)(rc));
				sqlite3LeaveMutexAndCloseZombie(p.pDestDb);
			}

			sqlite3BtreeLeave(p.pSrc);
			if ((p.pDestDb) != null)
			{
				sqlite3_free(p);
			}

			sqlite3LeaveMutexAndCloseZombie(pSrcDb);
			return (int)(rc);
		}
		public static sqlite3_backup sqlite3_backup_init(sqlite3 pDestDb, sbyte* zDestDb, sqlite3 pSrcDb, sbyte* zSrcDb)
		{
			sqlite3_backup p;
			sqlite3_mutex_enter(pSrcDb.mutex);
			sqlite3_mutex_enter(pDestDb.mutex);
			if ((pSrcDb) == (pDestDb))
			{
				sqlite3ErrorWithMsg(pDestDb, (int)(1), "source and destination must be distinct");
				p = null;
			}
			else
			{
				p = (sqlite3_backup)(sqlite3MallocZero((ulong)(sizeof(sqlite3_backup))));
				if (p == null)
				{
					sqlite3Error(pDestDb, (int)(7));
				}
			}

			if ((p) != null)
			{
				p.pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
				p.pDest = findBtree(pDestDb, pDestDb, zDestDb);
				p.pDestDb = pDestDb;
				p.pSrcDb = pSrcDb;
				p.iNext = (uint)(1);
				p.isAttached = (int)(0);
				if ((((null) == (p.pSrc)) || ((null) == (p.pDest))) || (checkReadTransaction(pDestDb, p.pDest) != 0))
				{
					sqlite3_free(p);
					p = null;
				}
			}

			if ((p) != null)
			{
				p.pSrc.nBackup++;
			}

			sqlite3_mutex_leave(pDestDb.mutex);
			sqlite3_mutex_leave(pSrcDb.mutex);
			return p;
		}
		public static int sqlite3_backup_pagecount(sqlite3_backup p)
		{
			return (int)(p.nPagecount);
		}
		public static int sqlite3_backup_remaining(sqlite3_backup p)
		{
			return (int)(p.nRemaining);
		}
		public static int sqlite3_backup_step(sqlite3_backup p, int nPage)
		{
			int rc = 0;
			int destMode = 0;
			int pgszSrc = (int)(0);
			int pgszDest = (int)(0);
			sqlite3_mutex_enter(p.pSrcDb.mutex);
			sqlite3BtreeEnter(p.pSrc);
			if ((p.pDestDb) != null)
			{
				sqlite3_mutex_enter(p.pDestDb.mutex);
			}

			rc = (int)(p.rc);
			if (isFatalError((int)(rc)) == 0)
			{
				Pager pSrcPager = sqlite3BtreePager(p.pSrc);
				Pager pDestPager = sqlite3BtreePager(p.pDest);
				int ii = 0;
				int nSrcPage = (int)(-1);
				int bCloseTrans = (int)(0);
				if (((p.pDestDb) != null) && ((p.pSrc.pBt.inTransaction) == (2)))
				{
					rc = (int)(5);
				}
				else
				{
					rc = (int)(0);
				}

				if (((rc) == (0)) && ((0) == (sqlite3BtreeTxnState(p.pSrc))))
				{
					rc = (int)(sqlite3BtreeBeginTrans(p.pSrc, (int)(0), null));
					bCloseTrans = (int)(1);
				}

				if ((((p.bDestLocked) == (0)) && ((rc) == (0))) && ((setDestPgsz(p)) == (7)))
				{
					rc = (int)(7);
				}

				if ((((0) == (rc)) && ((p.bDestLocked) == (0))) && ((0) == (rc = (int)(sqlite3BtreeBeginTrans(p.pDest, (int)(2), (int*)(&p.iDestSchema))))))
				{
					p.bDestLocked = (int)(1);
				}

				pgszSrc = (int)(sqlite3BtreeGetPageSize(p.pSrc));
				pgszDest = (int)(sqlite3BtreeGetPageSize(p.pDest));
				destMode = (int)(sqlite3PagerGetJournalMode(sqlite3BtreePager(p.pDest)));
				if ((((0) == (rc)) && ((destMode) == (5))) && (pgszSrc != pgszDest))
				{
					rc = (int)(8);
				}

				nSrcPage = ((int)(sqlite3BtreeLastPage(p.pSrc)));

				for (ii = (int)(0); ((((nPage) < (0)) || ((ii) < (nPage))) && ((p.iNext) <= ((uint)(nSrcPage)))) && (rc == 0); ii++)
				{
					uint iSrcPg = (uint)(p.iNext);
					if (iSrcPg != ((sqlite3PendingByte / ((p.pSrc.pBt).pageSize)) + 1))
					{
						PgHdr pSrcPg;
						rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(iSrcPg), pSrcPg, (int)(0x02)));
						if ((rc) == (0))
						{
							rc = (int)(backupOnePage(p, (uint)(iSrcPg), sqlite3PagerGetData(pSrcPg), (int)(0)));
							sqlite3PagerUnref(pSrcPg);
						}
					}

					p.iNext++;
				}

				if ((rc) == (0))
				{
					p.nPagecount = (uint)(nSrcPage);
					p.nRemaining = (uint)(nSrcPage + 1 - p.iNext);
					if ((p.iNext) > ((uint)(nSrcPage)))
					{
						rc = (int)(101);
					}
					else if (p.isAttached == 0)
					{
						attachBackupObject(p);
					}
				}

				if ((rc) == (101))
				{
					if ((nSrcPage) == (0))
					{
						rc = (int)(sqlite3BtreeNewDb(p.pDest));
						nSrcPage = (int)(1);
					}

					if (((rc) == (0)) || ((rc) == (101)))
					{
						rc = (int)(sqlite3BtreeUpdateMeta(p.pDest, (int)(1), (uint)(p.iDestSchema + 1)));
					}

					if ((rc) == (0))
					{
						if ((p.pDestDb) != null)
						{
							sqlite3ResetAllSchemasOfConnection(p.pDestDb);
						}

						if ((destMode) == (5))
						{
							rc = (int)(sqlite3BtreeSetVersion(p.pDest, (int)(2)));
						}
					}

					if ((rc) == (0))
					{
						int nDestTruncate = 0;


						if ((pgszSrc) < (pgszDest))
						{
							int ratio = (int)(pgszDest / pgszSrc);
							nDestTruncate = (int)((nSrcPage + ratio - 1) / ratio);
							if ((nDestTruncate) == ((int)((sqlite3PendingByte / ((p.pDest.pBt).pageSize)) + 1)))
							{
								nDestTruncate--;
							}
						}
						else
						{
							nDestTruncate = (int)(nSrcPage * (pgszSrc / pgszDest));
						}


						if ((pgszSrc) < (pgszDest))
						{
							long iSize = (long)((long)(pgszSrc) * (long)(nSrcPage));
							sqlite3_file pFile = sqlite3PagerFile(pDestPager);
							uint iPg = 0;
							int nDstPage = 0;
							long iOff = 0;
							long iEnd = 0;


							sqlite3PagerPagecount(pDestPager, &nDstPage);
							for (iPg = (uint)(nDestTruncate); ((rc) == (0)) && ((iPg) <= ((uint)(nDstPage))); iPg++)
							{
								if (iPg != ((sqlite3PendingByte / ((p.pDest.pBt).pageSize)) + 1))
								{
									PgHdr pPg;
									rc = (int)(sqlite3PagerGet(pDestPager, (uint)(iPg), pPg, (int)(0)));
									if ((rc) == (0))
									{
										rc = (int)(sqlite3PagerWrite(pPg));
										sqlite3PagerUnref(pPg);
									}
								}
							}

							if ((rc) == (0))
							{
								rc = (int)(sqlite3PagerCommitPhaseOne(pDestPager, null, (int)(1)));
							}

							iEnd = (long)((sqlite3PendingByte + pgszDest) < (iSize) ? (sqlite3PendingByte + pgszDest) : (iSize));
							for (iOff = (long)(sqlite3PendingByte + pgszSrc); ((rc) == (0)) && ((iOff) < (iEnd)); iOff += (long)(pgszSrc))
							{
								PgHdr pSrcPg = null;
								uint iSrcPg = (uint)((iOff / pgszSrc) + 1);
								rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(iSrcPg), pSrcPg, (int)(0)));
								if ((rc) == (0))
								{
									byte* zData = sqlite3PagerGetData(pSrcPg);
									rc = (int)(sqlite3OsWrite(pFile, zData, (int)(pgszSrc), (long)(iOff)));
								}

								sqlite3PagerUnref(pSrcPg);
							}

							if ((rc) == (0))
							{
								rc = (int)(backupTruncateFile(pFile, (long)(iSize)));
							}

							if ((rc) == (0))
							{
								rc = (int)(sqlite3PagerSync(pDestPager, null));
							}
						}
						else
						{
							sqlite3PagerTruncateImage(pDestPager, (uint)(nDestTruncate));
							rc = (int)(sqlite3PagerCommitPhaseOne(pDestPager, null, (int)(0)));
						}

						if (((0) == (rc)) && ((0) == (rc = (int)(sqlite3BtreeCommitPhaseTwo(p.pDest, (int)(0))))))
						{
							rc = (int)(101);
						}
					}
				}

				if ((bCloseTrans) != 0)
				{
					sqlite3BtreeCommitPhaseOne(p.pSrc, null);
					sqlite3BtreeCommitPhaseTwo(p.pSrc, (int)(0));

				}

				if ((rc) == (10 | (12 << 8)))
				{
					rc = (int)(7);
				}

				p.rc = (int)(rc);
			}

			if ((p.pDestDb) != null)
			{
				sqlite3_mutex_leave(p.pDestDb.mutex);
			}

			sqlite3BtreeLeave(p.pSrc);
			sqlite3_mutex_leave(p.pSrcDb.mutex);
			return (int)(rc);
		}
		public static int sqlite3_bind_blob(sqlite3_stmt* pStmt, int i, void* zData, int nData, delegate17 xDel)
		{
			return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(0)));
		}
		public static int sqlite3_bind_blob64(sqlite3_stmt* pStmt, int i, void* zData, ulong nData, delegate17 xDel)
		{

			return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(0)));
		}
		public static int sqlite3_bind_double(sqlite3_stmt* pStmt, int i, double rValue)
		{
			int rc = 0;
			Vdbe p = (Vdbe)(pStmt);
			rc = (int)(vdbeUnbind(p, (int)(i)));
			if ((rc) == (0))
			{
				sqlite3VdbeMemSetDouble(p.aVar[i - 1], (double)(rValue));
				sqlite3_mutex_leave(p.db.mutex);
			}

			return (int)(rc);
		}
		public static int sqlite3_bind_int(sqlite3_stmt* p, int i, int iValue)
		{
			return (int)(sqlite3_bind_int64(p, (int)(i), (long)(iValue)));
		}
		public static int sqlite3_bind_int64(sqlite3_stmt* pStmt, int i, long iValue)
		{
			int rc = 0;
			Vdbe p = (Vdbe)(pStmt);
			rc = (int)(vdbeUnbind(p, (int)(i)));
			if ((rc) == (0))
			{
				sqlite3VdbeMemSetInt64(p.aVar[i - 1], (long)(iValue));
				sqlite3_mutex_leave(p.db.mutex);
			}

			return (int)(rc);
		}
		public static int sqlite3_bind_null(sqlite3_stmt* pStmt, int i)
		{
			int rc = 0;
			Vdbe p = (Vdbe)(pStmt);
			rc = (int)(vdbeUnbind(p, (int)(i)));
			if ((rc) == (0))
			{
				sqlite3_mutex_leave(p.db.mutex);
			}

			return (int)(rc);
		}
		public static int sqlite3_bind_parameter_count(sqlite3_stmt* pStmt)
		{
			Vdbe p = (Vdbe)(pStmt);
			return (int)(p ? p.nVar : 0);
		}
		public static int sqlite3_bind_parameter_index(sqlite3_stmt* pStmt, sbyte* zName)
		{
			return (int)(sqlite3VdbeParameterIndex((Vdbe)(pStmt), zName, (int)(sqlite3Strlen30(zName))));
		}
		public static sbyte* sqlite3_bind_parameter_name(sqlite3_stmt* pStmt, int i)
		{
			Vdbe p = (Vdbe)(pStmt);
			if ((p) == (null))
				return null;
			return sqlite3VListNumToName(p.pVList, (int)(i));
		}
		public static int sqlite3_bind_pointer(sqlite3_stmt* pStmt, int i, void* pPtr, sbyte* zPTtype, delegate17 xDestructor)
		{
			int rc = 0;
			Vdbe p = (Vdbe)(pStmt);
			rc = (int)(vdbeUnbind(p, (int)(i)));
			if ((rc) == (0))
			{
				sqlite3VdbeMemSetPointer(p.aVar[i - 1], pPtr, zPTtype, xDestructor);
				sqlite3_mutex_leave(p.db.mutex);
			}
			else if ((xDestructor) != null)
			{
				xDestructor(pPtr);
			}

			return (int)(rc);
		}
		public static int sqlite3_bind_text(sqlite3_stmt* pStmt, int i, sbyte* zData, int nData, delegate17 xDel)
		{
			return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(1)));
		}
		public static int sqlite3_bind_text16(sqlite3_stmt* pStmt, int i, void* zData, int nData, delegate17 xDel)
		{
			return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(2)));
		}
		public static int sqlite3_bind_text64(sqlite3_stmt* pStmt, int i, sbyte* zData, ulong nData, delegate17 xDel, byte enc)
		{

			if ((enc) == (4))
				enc = (byte)(2);
			return (int)(bindText(pStmt, (int)(i), zData, (long)(nData), xDel, (byte)(enc)));
		}
		public static int sqlite3_bind_value(sqlite3_stmt* pStmt, int i, sqlite3_value pValue)
		{
			int rc = 0;
			switch (sqlite3_value_type(pValue))
			{
				case 1:
					{
						rc = (int)(sqlite3_bind_int64(pStmt, (int)(i), (long)(pValue.u.i)));
						break;
					}

				case 2:
					{

						rc = (int)(sqlite3_bind_double(pStmt, (int)(i), (double)((pValue.flags & 0x0008) ? pValue.u.r : (double)(pValue.u.i))));
						break;
					}

				case 4:
					{
						if ((pValue.flags & 0x4000) != 0)
						{
							rc = (int)(sqlite3_bind_zeroblob(pStmt, (int)(i), (int)(pValue.u.nZero)));
						}
						else
						{
							rc = (int)(sqlite3_bind_blob(pStmt, (int)(i), pValue.z, (int)(pValue.n), ((Void(Void * ))(-1))));
						}

						break;
					}

				case 3:
					{
						rc = (int)(bindText(pStmt, (int)(i), pValue.z, (long)(pValue.n), ((Void(Void * ))(-1)), (byte)(pValue.enc)));
						break;
					}

				default:
					{
						rc = (int)(sqlite3_bind_null(pStmt, (int)(i)));
						break;
					}
			}

			return (int)(rc);
		}
		public static int sqlite3_bind_zeroblob(sqlite3_stmt* pStmt, int i, int n)
		{
			int rc = 0;
			Vdbe p = (Vdbe)(pStmt);
			rc = (int)(vdbeUnbind(p, (int)(i)));
			if ((rc) == (0))
			{
				sqlite3VdbeMemSetZeroBlob(p.aVar[i - 1], (int)(n));
				sqlite3_mutex_leave(p.db.mutex);
			}

			return (int)(rc);
		}
		public static int sqlite3_bind_zeroblob64(sqlite3_stmt* pStmt, int i, ulong n)
		{
			int rc = 0;
			Vdbe p = (Vdbe)(pStmt);
			sqlite3_mutex_enter(p.db.mutex);
			if ((n) > ((ulong)(p.db.aLimit[0])))
			{
				rc = (int)(18);
			}
			else
			{

				rc = (int)(sqlite3_bind_zeroblob(pStmt, (int)(i), (int)(n)));
			}

			rc = (int)(sqlite3ApiExit(p.db, (int)(rc)));
			sqlite3_mutex_leave(p.db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_blob_bytes(sqlite3_blob* pBlob)
		{
			Incrblob p = (Incrblob)(pBlob);
			return (int)((((p) != null) && ((p.pStmt) != null)) ? p.nByte : 0);
		}
		public static int sqlite3_blob_close(sqlite3_blob* pBlob)
		{
			Incrblob p = (Incrblob)(pBlob);
			int rc = 0;
			sqlite3 db;
			if ((p) != null)
			{
				sqlite3_stmt* pStmt = p.pStmt;
				db = p.db;
				sqlite3_mutex_enter(db.mutex);
				sqlite3DbFree(db, p);
				sqlite3_mutex_leave(db.mutex);
				rc = (int)(sqlite3_finalize(pStmt));
			}
			else
			{
				rc = (int)(0);
			}

			return (int)(rc);
		}
		public static int sqlite3_blob_open(sqlite3 db, sbyte* zDb, sbyte* zTable, sbyte* zColumn, long iRow, int wrFlag, sqlite3_blob** ppBlob)
		{
			int nAttempt = (int)(0);
			int iCol = 0;
			int rc = (int)(0);
			sbyte* zErr = null;
			Table pTab;
			Incrblob pBlob = null;
			Parse sParse = new Parse();
			*ppBlob = null;
			wrFlag = (int)(!!wrFlag);
			sqlite3_mutex_enter(db.mutex);
			pBlob = (Incrblob)(sqlite3DbMallocZero(db, (ulong)(sizeof(Incrblob))));
			while ((1) != 0)
			{
				sqlite3ParseObjectInit(sParse, db);
				if (pBlob == null)
					goto blob_open_out;
				sqlite3DbFree(db, zErr);
				zErr = null;
				sqlite3BtreeEnterAll(db);
				pTab = sqlite3LocateTable(sParse, (uint)(0), zTable, zDb);
				if (((pTab) != null) && (((pTab).eTabType) == (1)))
				{
					pTab = null;
					sqlite3ErrorMsg(sParse, "cannot open virtual table: %s", zTable);
				}

				if (((pTab) != null) && (!(((pTab).tabFlags & 0x00000080) == (0))))
				{
					pTab = null;
					sqlite3ErrorMsg(sParse, "cannot open table without rowid: %s", zTable);
				}

				if (((pTab) != null) && (((pTab).eTabType) == (2)))
				{
					pTab = null;
					sqlite3ErrorMsg(sParse, "cannot open view: %s", zTable);
				}

				if (pTab == null)
				{
					if ((sParse.zErrMsg) != null)
					{
						sqlite3DbFree(db, zErr);
						zErr = sParse.zErrMsg;
						sParse.zErrMsg = null;
					}

					rc = (int)(1);
					sqlite3BtreeLeaveAll(db);
					goto blob_open_out;
				}

				pBlob.pTab = pTab;
				pBlob.zDb = db.aDb[sqlite3SchemaToIndex(db, pTab.pSchema)].zDbSName;
				for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
				{
					if ((sqlite3StrICmp(pTab.aCol[iCol].zCnName, zColumn)) == (0))
					{
						break;
					}
				}

				if ((iCol) == (pTab.nCol))
				{
					sqlite3DbFree(db, zErr);
					zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
					rc = (int)(1);
					sqlite3BtreeLeaveAll(db);
					goto blob_open_out;
				}

				if ((wrFlag) != 0)
				{
					sbyte* zFault = null;
					Index pIdx;
					if ((db.flags & 0x00004000) != 0)
					{
						FKey pFKey;

						for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
						{
							int j = 0;
							for (j = (int)(0); (j) < (pFKey.nCol); j++)
							{
								if ((pFKey.aCol[j].iFrom) == (iCol))
								{
									zFault = "foreign key";
								}
							}
						}
					}

					for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
					{
						int j = 0;
						for (j = (int)(0); (j) < (pIdx.nKeyCol); j++)
						{
							if (((pIdx.aiColumn[j]) == (iCol)) || ((pIdx.aiColumn[j]) == (-2)))
							{
								zFault = "indexed";
							}
						}
					}

					if ((zFault) != null)
					{
						sqlite3DbFree(db, zErr);
						zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
						rc = (int)(1);
						sqlite3BtreeLeaveAll(db);
						goto blob_open_out;
					}
				}

				pBlob.pStmt = (sqlite3_stmt*)(sqlite3VdbeCreate(sParse));

				if ((pBlob.pStmt) != null)
				{
					Vdbe v = (Vdbe)(pBlob.pStmt);
					int iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
					VdbeOp* aOp;
					sqlite3VdbeAddOp4Int(v, (int)(2), (int)(iDb), (int)(wrFlag), (int)(pTab.pSchema.schema_cookie), (int)(pTab.pSchema.iGeneration));
					sqlite3VdbeChangeP5(v, (ushort)(1));

					aOp = sqlite3VdbeAddOpList(v, ((int)(6 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3_blob_open_openBlob, (int)(sqlite3_blob_open_iLn));
					sqlite3VdbeUsesBtree(v, (int)(iDb));
					if ((db.mallocFailed) == (0))
					{

						aOp[0].p1 = (int)(iDb);
						aOp[0].p2 = (int)(pTab.tnum);
						aOp[0].p3 = (int)(wrFlag);
						sqlite3VdbeChangeP4(v, (int)(2), pTab.zName, (int)(0));
					}

					if ((db.mallocFailed) == (0))
					{
						if ((wrFlag) != 0)
							aOp[1].opcode = (byte)(112);
						aOp[1].p2 = (int)(pTab.tnum);
						aOp[1].p3 = (int)(iDb);
						aOp[1].p4type = (sbyte)(-3);
						aOp[1].p4.i = (int)(pTab.nCol + 1);
						aOp[3].p2 = (int)(pTab.nCol);
						sParse.nVar = (short)(0);
						sParse.nMem = (int)(1);
						sParse.nTab = (int)(1);
						sqlite3VdbeMakeReady(v, sParse);
					}
				}

				pBlob.iCol = (ushort)(iCol);
				pBlob.db = db;
				sqlite3BtreeLeaveAll(db);
				if ((db.mallocFailed) != 0)
				{
					goto blob_open_out;
				}

				rc = (int)(blobSeekToRow(pBlob, (long)(iRow), &zErr));
				if (((++nAttempt) >= (50)) || (rc != 17))
					break;
				sqlite3ParseObjectReset(sParse);
			}

		blob_open_out:
			; if (((rc) == (0)) && ((db.mallocFailed) == (0))) { *ppBlob = (sqlite3_blob*)(pBlob); } else { if (((pBlob) != null) && ((pBlob.pStmt) != null)) sqlite3VdbeFinalize((Vdbe)(pBlob.pStmt)); sqlite3DbFree(db, pBlob); }
			sqlite3ErrorWithMsg(db, (int)(rc), ((zErr) != 0 ? "%s" : null), zErr);
			sqlite3DbFree(db, zErr);
			sqlite3ParseObjectReset(sParse);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_blob_read(sqlite3_blob* pBlob, void* z, int n, int iOffset)
		{
			return (int)(blobReadWrite(pBlob, z, (int)(n), (int)(iOffset), sqlite3BtreePayloadChecked));
		}
		public static int sqlite3_blob_reopen(sqlite3_blob* pBlob, long iRow)
		{
			int rc = 0;
			Incrblob p = (Incrblob)(pBlob);
			sqlite3 db;
			if ((p) == (null))
				return (int)(sqlite3MisuseError((int)(96490)));
			db = p.db;
			sqlite3_mutex_enter(db.mutex);
			if ((p.pStmt) == (null))
			{
				rc = (int)(4);
			}
			else
			{
				sbyte* zErr;
				((Vdbe)(p.pStmt)).rc = (int)(0);
				rc = (int)(blobSeekToRow(p, (long)(iRow), &zErr));
				if (rc != 0)
				{
					sqlite3ErrorWithMsg(db, (int)(rc), ((zErr) != 0 ? "%s" : null), zErr);
					sqlite3DbFree(db, zErr);
				}


			}

			rc = (int)(sqlite3ApiExit(db, (int)(rc)));

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_blob_write(sqlite3_blob* pBlob, void* z, int n, int iOffset)
		{
			return (int)(blobReadWrite(pBlob, z, (int)(n), (int)(iOffset), sqlite3BtreePutData));
		}
		public static int sqlite3_busy_handler(sqlite3 db, delegate59 xBusy, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			db.busyHandler.xBusyHandler = xBusy;
			db.busyHandler.pBusyArg = pArg;
			db.busyHandler.nBusy = (int)(0);
			db.busyTimeout = (int)(0);
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_busy_timeout(sqlite3 db, int ms)
		{
			if ((ms) > (0))
			{
				sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)(db));
				db.busyTimeout = (int)(ms);
			}
			else
			{
				sqlite3_busy_handler(db, null, null);
			}

			return (int)(0);
		}
		public static int sqlite3_cancel_auto_extension(delegate73 xInit)
		{
			sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
			int i = 0;
			int n = (int)(0);
			sqlite3_mutex_enter(mutex);
			for (i = (int)((int)(sqlite3Autoext.nExt) - 1); (i) >= (0); i--)
			{
				if ((sqlite3Autoext.aExt[i]) == (xInit))
				{
					sqlite3Autoext.nExt--;
					sqlite3Autoext.aExt[i] = sqlite3Autoext.aExt[sqlite3Autoext.nExt];
					n++;
					break;
				}
			}

			sqlite3_mutex_leave(mutex);
			return (int)(n);
		}
		public static int sqlite3_changes(sqlite3 db)
		{
			return (int)(sqlite3_changes64(db));
		}
		public static long sqlite3_changes64(sqlite3 db)
		{
			return (long)(db.nChange);
		}
		public static int sqlite3_clear_bindings(sqlite3_stmt* pStmt)
		{
			int i = 0;
			int rc = (int)(0);
			Vdbe p = (Vdbe)(pStmt);
			sqlite3_mutex* mutex = ((Vdbe)(pStmt)).db.mutex;
			sqlite3_mutex_enter(mutex);
			for (i = (int)(0); (i) < (p.nVar); i++)
			{
				sqlite3VdbeMemRelease(p.aVar[i]);
				p.aVar[i].flags = (ushort)(0x0001);
			}


			if ((p.expmask) != 0)
			{
				p.expired = (uint)(1);
			}

			sqlite3_mutex_leave(mutex);
			return (int)(rc);
		}
		public static int sqlite3_close(sqlite3 db)
		{
			return (int)(sqlite3Close(db, (int)(0)));
		}
		public static int sqlite3_close_v2(sqlite3 db)
		{
			return (int)(sqlite3Close(db, (int)(1)));
		}
		public static int sqlite3_collation_needed(sqlite3 db, void* pCollNeededArg, delegate65 xCollNeeded)
		{
			sqlite3_mutex_enter(db.mutex);
			db.xCollNeeded = xCollNeeded;
			db.xCollNeeded16 = null;
			db.pCollNeededArg = pCollNeededArg;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_collation_needed16(sqlite3 db, void* pCollNeededArg, delegate65 xCollNeeded16)
		{
			sqlite3_mutex_enter(db.mutex);
			db.xCollNeeded = null;
			db.xCollNeeded16 = xCollNeeded16;
			db.pCollNeededArg = pCollNeededArg;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static void* sqlite3_column_blob(sqlite3_stmt* pStmt, int i)
		{
			void* val;
			val = sqlite3_value_blob(columnMem(pStmt, (int)(i)));
			columnMallocFailure(pStmt);
			return val;
		}
		public static int sqlite3_column_bytes(sqlite3_stmt* pStmt, int i)
		{
			int val = (int)(sqlite3_value_bytes(columnMem(pStmt, (int)(i))));
			columnMallocFailure(pStmt);
			return (int)(val);
		}
		public static int sqlite3_column_bytes16(sqlite3_stmt* pStmt, int i)
		{
			int val = (int)(sqlite3_value_bytes16(columnMem(pStmt, (int)(i))));
			columnMallocFailure(pStmt);
			return (int)(val);
		}
		public static int sqlite3_column_count(sqlite3_stmt* pStmt)
		{
			Vdbe pVm = (Vdbe)(pStmt);
			return (int)(pVm ? pVm.nResColumn : 0);
		}
		public static sbyte* sqlite3_column_decltype(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(0), (int)(1));
		}
		public static void* sqlite3_column_decltype16(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(1), (int)(1));
		}
		public static double sqlite3_column_double(sqlite3_stmt* pStmt, int i)
		{
			double val = (double)(sqlite3_value_double(columnMem(pStmt, (int)(i))));
			columnMallocFailure(pStmt);
			return (double)(val);
		}
		public static int sqlite3_column_int(sqlite3_stmt* pStmt, int i)
		{
			int val = (int)(sqlite3_value_int(columnMem(pStmt, (int)(i))));
			columnMallocFailure(pStmt);
			return (int)(val);
		}
		public static long sqlite3_column_int64(sqlite3_stmt* pStmt, int i)
		{
			long val = (long)(sqlite3_value_int64(columnMem(pStmt, (int)(i))));
			columnMallocFailure(pStmt);
			return (long)(val);
		}
		public static sbyte* sqlite3_column_name(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(0), (int)(0));
		}
		public static void* sqlite3_column_name16(sqlite3_stmt* pStmt, int N)
		{
			return columnName(pStmt, (int)(N), (int)(1), (int)(0));
		}
		public static byte* sqlite3_column_text(sqlite3_stmt* pStmt, int i)
		{
			byte* val = sqlite3_value_text(columnMem(pStmt, (int)(i)));
			columnMallocFailure(pStmt);
			return val;
		}
		public static void* sqlite3_column_text16(sqlite3_stmt* pStmt, int i)
		{
			void* val = sqlite3_value_text16(columnMem(pStmt, (int)(i)));
			columnMallocFailure(pStmt);
			return val;
		}
		public static int sqlite3_column_type(sqlite3_stmt* pStmt, int i)
		{
			int iType = (int)(sqlite3_value_type(columnMem(pStmt, (int)(i))));
			columnMallocFailure(pStmt);
			return (int)(iType);
		}
		public static sqlite3_value sqlite3_column_value(sqlite3_stmt* pStmt, int i)
		{
			sqlite3_value pOut = columnMem(pStmt, (int)(i));
			if ((pOut.flags & 0x0800) != 0)
			{
				pOut.flags &= (ushort)(~0x0800);
				pOut.flags |= (ushort)(0x1000);
			}

			columnMallocFailure(pStmt);
			return pOut;
		}
		public static void* sqlite3_commit_hook(sqlite3 db, delegate19 xCallback, void* pArg)
		{
			void* pOld;
			sqlite3_mutex_enter(db.mutex);
			pOld = db.pCommitArg;
			db.xCommitCallback = xCallback;
			db.pCommitArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pOld;
		}
		public static sbyte* sqlite3_compileoption_get(int N)
		{
			int nOpt = 0;
			sbyte** azCompileOpt;
			azCompileOpt = sqlite3CompileOptions(&nOpt);
			if (((N) >= (0)) && ((N) < (nOpt)))
			{
				return azCompileOpt[N];
			}

			return null;
		}
		public static int sqlite3_compileoption_used(sbyte* zOptName)
		{
			int i = 0; int n = 0;
			int nOpt = 0;
			sbyte** azCompileOpt;
			azCompileOpt = sqlite3CompileOptions(&nOpt);
			if ((sqlite3_strnicmp(zOptName, "SQLITE_", (int)(7))) == (0))
				zOptName += 7;
			n = (int)(sqlite3Strlen30(zOptName));
			for (i = (int)(0); (i) < (nOpt); i++)
			{
				if (((sqlite3_strnicmp(zOptName, azCompileOpt[i], (int)(n))) == (0)) && ((sqlite3IsIdChar((byte)(azCompileOpt[i][n]))) == (0)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int sqlite3_complete(sbyte* zSql)
		{
			byte state = (byte)(0);
			byte token = 0;
			while ((*zSql) != 0)
			{
				switch (*zSql)
				{
					case 59:
						{
							token = (byte)(0);
							break;
						}

					case 32:
					case 13:
					case 9:
					case 10:
					case 12:
						{
							token = (byte)(1);
							break;
						}

					case 47:
						{
							if (zSql[1] != 42)
							{
								token = (byte)(2);
								break;
							}

							zSql += 2;
							while (((zSql[0]) != 0) && ((zSql[0] != 42) || (zSql[1] != 47)))
							{
								zSql++;
							}

							if ((zSql[0]) == (0))
								return (int)(0);
							zSql++;
							token = (byte)(1);
							break;
						}

					case 45:
						{
							if (zSql[1] != 45)
							{
								token = (byte)(2);
								break;
							}

							while (((*zSql) != 0) && (*zSql != 10))
							{
								zSql++;
							}

							if ((*zSql) == (0))
								return ((state) == (1) ? 1 : 0);
							token = (byte)(1);
							break;
						}

					case 91:
						{
							zSql++;
							while (((*zSql) != 0) && (*zSql != 93))
							{
								zSql++;
							}

							if ((*zSql) == (0))
								return (int)(0);
							token = (byte)(2);
							break;
						}

					case 96:
					case 34:
					case 39:
						{
							int c = (int)(*zSql);
							zSql++;
							while (((*zSql) != 0) && (*zSql != c))
							{
								zSql++;
							}

							if ((*zSql) == (0))
								return (int)(0);
							token = (byte)(2);
							break;
						}

					default:
						{
							if (((sqlite3CtypeMap[(byte)(*zSql)] & 0x46) != 0))
							{
								int nId = 0;
								for (nId = (int)(1); ((sqlite3CtypeMap[(byte)(zSql[nId])] & 0x46) != 0); nId++)
								{
								}

								switch (*zSql)
								{
									case 99:
									case 67:
										{
											if (((nId) == (6)) && ((sqlite3_strnicmp(zSql, "create", (int)(6))) == (0)))
											{
												token = (byte)(4);
											}
											else
											{
												token = (byte)(2);
											}

											break;
										}

									case 116:
									case 84:
										{
											if (((nId) == (7)) && ((sqlite3_strnicmp(zSql, "trigger", (int)(7))) == (0)))
											{
												token = (byte)(6);
											}
											else if (((nId) == (4)) && ((sqlite3_strnicmp(zSql, "temp", (int)(4))) == (0)))
											{
												token = (byte)(5);
											}
											else if (((nId) == (9)) && ((sqlite3_strnicmp(zSql, "temporary", (int)(9))) == (0)))
											{
												token = (byte)(5);
											}
											else
											{
												token = (byte)(2);
											}

											break;
										}

									case 101:
									case 69:
										{
											if (((nId) == (3)) && ((sqlite3_strnicmp(zSql, "end", (int)(3))) == (0)))
											{
												token = (byte)(7);
											}
											else if (((nId) == (7)) && ((sqlite3_strnicmp(zSql, "explain", (int)(7))) == (0)))
											{
												token = (byte)(3);
											}
											else
											{
												token = (byte)(2);
											}

											break;
										}

									default:
										{
											token = (byte)(2);
											break;
										}
								}

								zSql += nId - 1;
							}
							else
							{
								token = (byte)(2);
							}

							break;
						}
				}

				state = (byte)(sqlite3_complete_trans[state][token]);
				zSql++;
			}

			return ((state) == (1) ? 1 : 0);
		}
		public static int sqlite3_complete16(void* zSql)
		{
			sqlite3_value pVal;
			sbyte* zSql8;
			int rc = 0;
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			pVal = sqlite3ValueNew(null);
			sqlite3ValueSetStr(pVal, (int)(-1), zSql, (byte)(2), null);
			zSql8 = sqlite3ValueText(pVal, (byte)(1));
			if ((zSql8) != null)
			{
				rc = (int)(sqlite3_complete(zSql8));
			}
			else
			{
				rc = (int)(7);
			}

			sqlite3ValueFree(pVal);
			return (int)(rc & 0xff);
		}
		public static int sqlite3_config(int op)
		{
			sbyte* ap;
			int rc = (int)(0);
			if ((sqlite3Config.isInit) != 0)
				return (int)(sqlite3MisuseError((int)(168908)));
			(__va_start(&ap, (int)(op)));
			switch (op)
			{
				case 1:
					{
						sqlite3Config.bCoreMutex = (byte)(0);
						sqlite3Config.bFullMutex = (byte)(0);
						break;
					}

				case 2:
					{
						sqlite3Config.bCoreMutex = (byte)(1);
						sqlite3Config.bFullMutex = (byte)(0);
						break;
					}

				case 3:
					{
						sqlite3Config.bCoreMutex = (byte)(1);
						sqlite3Config.bFullMutex = (byte)(1);
						break;
					}

				case 10:
					{
						sqlite3Config.mutex = (sqlite3_mutex_methods)((((sizeof(sqlite3_mutex_methods)) > ()) || ((sizeof(sqlite3_mutex_methods) & (sizeof(sqlite3_mutex_methods) - 1)) != 0)) ? (sqlite3_mutex_methods)((ap += ) - ) : (sqlite3_mutex_methods)((ap += ) - ));
						break;
					}

				case 11:
					{
						((((sizeof(sqlite3_mutex_methods)) > ()) || ((sizeof(sqlite3_mutex_methods) & (sizeof(sqlite3_mutex_methods) - 1)) != 0)) ? (sqlite3_mutex_methods)((ap += ) - ) : (sqlite3_mutex_methods)((ap += ) - )) = (sqlite3_mutex_methods)(sqlite3Config.mutex);
						break;
					}

				case 4:
					{
						sqlite3Config.m = (sqlite3_mem_methods)((((sizeof(sqlite3_mem_methods)) > ()) || ((sizeof(sqlite3_mem_methods) & (sizeof(sqlite3_mem_methods) - 1)) != 0)) ? (sqlite3_mem_methods)((ap += ) - ) : (sqlite3_mem_methods)((ap += ) - ));
						break;
					}

				case 5:
					{
						if ((sqlite3Config.m.xMalloc) == (null))
							sqlite3MemSetDefault();
						((((sizeof(sqlite3_mem_methods)) > ()) || ((sizeof(sqlite3_mem_methods) & (sizeof(sqlite3_mem_methods) - 1)) != 0)) ? (sqlite3_mem_methods)((ap += ) - ) : (sqlite3_mem_methods)((ap += ) - )) = (sqlite3_mem_methods)(sqlite3Config.m);
						break;
					}

				case 9:
					{
						sqlite3Config.bMemstat = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 27:
					{
						sqlite3Config.bSmallMalloc = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 7:
					{
						sqlite3Config.pPage = (((() > ()) || ((&(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
						sqlite3Config.szPage = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						sqlite3Config.nPage = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 24:
					{
						*(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - )) = (int)(sqlite3HeaderSizeBtree() + sqlite3HeaderSizePcache() + sqlite3HeaderSizePcache1());
						break;
					}

				case 14:
					{
						break;
					}

				case 15:
					{
						rc = (int)(1);
						break;
					}

				case 18:
					{
						sqlite3Config.pcache2 = (sqlite3_pcache_methods2)((((sizeof(sqlite3_pcache_methods2)) > ()) || ((sizeof(sqlite3_pcache_methods2) & (sizeof(sqlite3_pcache_methods2) - 1)) != 0)) ? (sqlite3_pcache_methods2)((ap += ) - ) : (sqlite3_pcache_methods2)((ap += ) - ));
						break;
					}

				case 19:
					{
						if ((sqlite3Config.pcache2.xInit) == (null))
						{
							sqlite3PCacheSetDefault();
						}

					((((sizeof(sqlite3_pcache_methods2)) > ()) || ((sizeof(sqlite3_pcache_methods2) & (sizeof(sqlite3_pcache_methods2) - 1)) != 0)) ? (sqlite3_pcache_methods2)((ap += ) - ) : (sqlite3_pcache_methods2)((ap += ) - )) = (sqlite3_pcache_methods2)(sqlite3Config.pcache2);
						break;
					}

				case 13:
					{
						sqlite3Config.szLookaside = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						sqlite3Config.nLookaside = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 16:
					{
						sqlite3Config.xLog = ((((sizeof(Void(Void * , Void * , Void * ))) > ()) || ((sizeof(Void(Void * , Void * , Void * )) & (sizeof(Void(Void * , Void * , Void * )) - 1)) != 0 ) ) ?
            **(Void(Void * , Void * , Void * ))((ap += ) - ) : 
            *(Void(Void * , Void * , Void * ))((ap += ) - ) )
            ;
						sqlite3Config.pLogArg = (((() > ()) || ((&(-1)) != 0)) ? **(void***)((ap += ) - ) : *(void**)((ap += ) - ));
						break;
					}

				case 17:
					{
						sqlite3Config.bOpenUri = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 20:
					{
						sqlite3Config.bUseCis = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 22:
					{
						long szMmap = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
						long mxMmap = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
						if (((mxMmap) < (0)) || ((mxMmap) > (0x7fff0000)))
						{
							mxMmap = (long)(0x7fff0000);
						}

						if ((szMmap) < (0))
							szMmap = (long)(0);
						if ((szMmap) > (mxMmap))
							szMmap = (long)(mxMmap);
						sqlite3Config.mxMmap = (long)(mxMmap);
						sqlite3Config.szMmap = (long)(szMmap);
						break;
					}

				case 25:
					{
						sqlite3Config.szPma = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
						break;
					}

				case 26:
					{
						sqlite3Config.nStmtSpill = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 29:
					{
						sqlite3Config.mxMemdbSize = (long)((((sizeof(long)) > ()) || ((sizeof(long) & (sizeof(long) - 1)) != 0)) ? **(long**)((ap += ) - ) : *(long*)((ap += ) - ));
						break;
					}

				default:
					{
						rc = (int)(1);
						break;
					}
			}

			((void)(ap = null));
			return (int)(rc);
		}
		public static sqlite3 sqlite3_context_db_handle(sqlite3_context p)
		{

			return p.pOut.db;
		}
		public static int sqlite3_create_collation(sqlite3 db, sbyte* zName, int enc, void* pCtx, delegate69 xCompare)
		{
			return (int)(sqlite3_create_collation_v2(db, zName, (int)(enc), pCtx, xCompare, null));
		}
		public static int sqlite3_create_collation_v2(sqlite3 db, sbyte* zName, int enc, void* pCtx, delegate69 xCompare, delegate17 xDel)
		{
			int rc = 0;
			sqlite3_mutex_enter(db.mutex);

			rc = (int)(createCollation(db, zName, (byte)(enc), pCtx, xCompare, xDel));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_create_collation16(sqlite3 db, void* zName, int enc, void* pCtx, delegate69 xCompare)
		{
			int rc = (int)(0);
			sbyte* zName8;
			sqlite3_mutex_enter(db.mutex);

			zName8 = sqlite3Utf16to8(db, zName, (int)(-1), (byte)(2));
			if ((zName8) != null)
			{
				rc = (int)(createCollation(db, zName8, (byte)(enc), pCtx, xCompare, null));
				sqlite3DbFree(db, zName8);
			}

			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static sbyte* sqlite3_create_filename(sbyte* zDatabase, sbyte* zJournal, sbyte* zWal, int nParam, sbyte** azParam)
		{
			long nByte = 0;
			int i = 0;
			sbyte* pResult; sbyte* p;
			nByte = (long)(CRuntime.strlen(zDatabase) + CRuntime.strlen(zJournal) + CRuntime.strlen(zWal) + 10);
			for (i = (int)(0); (i) < (nParam * 2); i++)
			{
				nByte += (long)(CRuntime.strlen(azParam[i]) + 1);
			}

			pResult = p = sqlite3_malloc64((ulong)(nByte));
			if ((p) == (null))
				return null;
			CRuntime.memset(p, (int)(0), (ulong)(4));
			p += 4;
			p = appendText(p, zDatabase);
			for (i = (int)(0); (i) < (nParam * 2); i++)
			{
				p = appendText(p, azParam[i]);
			}

			*(p++) = (sbyte)(0);
			p = appendText(p, zJournal);
			p = appendText(p, zWal);
			*(p++) = (sbyte)(0);
			*(p++) = (sbyte)(0);

			return pResult + 4;
		}
		public static int sqlite3_create_function(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate67 xSFunc, delegate67 xStep, delegate68 xFinal)
		{
			return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, null, null, null));
		}
		public static int sqlite3_create_function_v2(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate67 xSFunc, delegate67 xStep, delegate68 xFinal, delegate17 xDestroy)
		{
			return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, xSFunc, xStep, xFinal, null, null, xDestroy));
		}
		public static int sqlite3_create_function16(sqlite3 db, void* zFunctionName, int nArg, int eTextRep, void* p, delegate67 xSFunc, delegate67 xStep, delegate68 xFinal)
		{
			int rc = 0;
			sbyte* zFunc8;
			sqlite3_mutex_enter(db.mutex);

			zFunc8 = sqlite3Utf16to8(db, zFunctionName, (int)(-1), (byte)(2));
			rc = (int)(sqlite3CreateFunc(db, zFunc8, (int)(nArg), (int)(eTextRep), p, xSFunc, xStep, xFinal, null, null, null));
			sqlite3DbFree(db, zFunc8);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_create_module(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux)
		{
			return (int)(createModule(db, zName, pModule, pAux, null));
		}
		public static int sqlite3_create_module_v2(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
		{
			return (int)(createModule(db, zName, pModule, pAux, xDestroy));
		}
		public static int sqlite3_create_window_function(sqlite3 db, sbyte* zFunc, int nArg, int enc, void* p, delegate67 xStep, delegate68 xFinal, delegate68 xValue, delegate67 xInverse, delegate17 xDestroy)
		{
			return (int)(createFunctionApi(db, zFunc, (int)(nArg), (int)(enc), p, null, xStep, xFinal, xValue, xInverse, xDestroy));
		}
		public static int sqlite3_data_count(sqlite3_stmt* pStmt)
		{
			Vdbe pVm = (Vdbe)(pStmt);
			if (((pVm) == (null)) || ((pVm.pResultSet) == (null)))
				return (int)(0);
			return (int)(pVm.nResColumn);
		}
		public static sqlite3_file sqlite3_database_file_object(sbyte* zName)
		{
			Pager pPager;
			while ((((zName[-1] != 0) || (zName[-2] != 0)) || (zName[-3] != 0)) || (zName[-4] != 0))
			{
				zName--;
			}

			pPager = (Pager)(zName - 4 - sizeof(Pager));
			return pPager.fd;
		}
		public static int sqlite3_db_cacheflush(sqlite3 db)
		{
			int i = 0;
			int rc = (int)(0);
			int bSeenBusy = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if (((pBt) != null) && ((sqlite3BtreeTxnState(pBt)) == (2)))
				{
					Pager pPager = sqlite3BtreePager(pBt);
					rc = (int)(sqlite3PagerFlush(pPager));
					if ((rc) == (5))
					{
						bSeenBusy = (int)(1);
						rc = (int)(0);
					}
				}
			}

			sqlite3BtreeLeaveAll(db);
			sqlite3_mutex_leave(db.mutex);
			return (int)((((rc) == (0)) && ((bSeenBusy) != 0)) ? 5 : rc);
		}
		public static sbyte* sqlite3_db_filename(sqlite3 db, sbyte* zDbName)
		{
			Btree pBt;
			pBt = sqlite3DbNameToBtree(db, zDbName);
			return pBt ? sqlite3BtreeGetFilename(pBt) : null;
		}
		public static sqlite3 sqlite3_db_handle(sqlite3_stmt* pStmt)
		{
			return pStmt ? ((Vdbe)(pStmt)).db : null;
		}
		public static sqlite3_mutex* sqlite3_db_mutex(sqlite3 db)
		{
			return db.mutex;
		}
		public static int sqlite3_db_readonly(sqlite3 db, sbyte* zDbName)
		{
			Btree pBt;
			pBt = sqlite3DbNameToBtree(db, zDbName);
			return (int)(pBt ? sqlite3BtreeIsReadonly(pBt) : -1);
		}
		public static int sqlite3_db_release_memory(sqlite3 db)
		{
			int i = 0;
			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if ((pBt) != null)
				{
					Pager pPager = sqlite3BtreePager(pBt);
					sqlite3PagerShrink(pPager);
				}
			}

			sqlite3BtreeLeaveAll(db);
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_db_status(sqlite3 db, int op, int* pCurrent, int* pHighwater, int resetFlag)
		{
			int rc = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			switch (op)
			{
				case 0:
					{
						*pCurrent = (int)(sqlite3LookasideUsed(db, pHighwater));
						if ((resetFlag) != 0)
						{
							LookasideSlot* p = db.lookaside.pFree;
							if ((p) != null)
							{
								while ((p->pNext) != null)
								{
									p = p->pNext;
								}

								p->pNext = db.lookaside.pInit;
								db.lookaside.pInit = db.lookaside.pFree;
								db.lookaside.pFree = null;
							}

							p = db.lookaside.pSmallFree;
							if ((p) != null)
							{
								while ((p->pNext) != null)
								{
									p = p->pNext;
								}

								p->pNext = db.lookaside.pSmallInit;
								db.lookaside.pSmallInit = db.lookaside.pSmallFree;
								db.lookaside.pSmallFree = null;
							}
						}

						break;
					}

				case 4:
				case 5:
				case 6:
					{


						*pCurrent = (int)(0);
						*pHighwater = (int)(db.lookaside.anStat[op - 4]);
						if ((resetFlag) != 0)
						{
							db.lookaside.anStat[op - 4] = (uint)(0);
						}

						break;
					}

				case 11:
				case 1:
					{
						int totalUsed = (int)(0);
						int i = 0;
						sqlite3BtreeEnterAll(db);
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							Btree pBt = db.aDb[i].pBt;
							if ((pBt) != null)
							{
								Pager pPager = sqlite3BtreePager(pBt);
								int nByte = (int)(sqlite3PagerMemUsed(pPager));
								if ((op) == (11))
								{
									nByte = (int)(nByte / sqlite3BtreeConnectionCount(pBt));
								}

								totalUsed += (int)(nByte);
							}
						}

						sqlite3BtreeLeaveAll(db);
						*pCurrent = (int)(totalUsed);
						*pHighwater = (int)(0);
						break;
					}

				case 2:
					{
						int i = 0;
						int nByte = (int)(0);
						sqlite3BtreeEnterAll(db);
						db.pnBytesFreed = &nByte;
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							Schema pSchema = db.aDb[i].pSchema;
							if ((pSchema != null))
							{
								HashElem* p;
								nByte += (int)(sqlite3Config.m.xRoundup((int)(sizeof(HashElem))) * (pSchema.tblHash.count + pSchema.trigHash.count + pSchema.idxHash.count + pSchema.fkeyHash.count));
								nByte += (int)(sqlite3_msize(pSchema.tblHash.ht));
								nByte += (int)(sqlite3_msize(pSchema.trigHash.ht));
								nByte += (int)(sqlite3_msize(pSchema.idxHash.ht));
								nByte += (int)(sqlite3_msize(pSchema.fkeyHash.ht));
								for (p = ((&pSchema.trigHash)->first); p; p = ((p)->next))
								{
									sqlite3DeleteTrigger(db, (Trigger)((p)->data));
								}

								for (p = ((&pSchema.tblHash)->first); p; p = ((p)->next))
								{
									sqlite3DeleteTable(db, (Table)((p)->data));
								}
							}
						}

						db.pnBytesFreed = null;
						sqlite3BtreeLeaveAll(db);
						*pHighwater = (int)(0);
						*pCurrent = (int)(nByte);
						break;
					}

				case 3:
					{
						Vdbe pVdbe;
						int nByte = (int)(0);
						db.pnBytesFreed = &nByte;
						for (pVdbe = db.pVdbe; pVdbe; pVdbe = pVdbe.pNext)
						{
							sqlite3VdbeClearObject(db, pVdbe);
							sqlite3DbFree(db, pVdbe);
						}

						db.pnBytesFreed = null;
						*pHighwater = (int)(0);
						*pCurrent = (int)(nByte);
						break;
					}

				case 12:
					op = (int)(9 + 1);
				case 7:
				case 8:
				case 9:
					{
						int i = 0;
						int nRet = (int)(0);


						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							if ((db.aDb[i].pBt) != null)
							{
								Pager pPager = sqlite3BtreePager(db.aDb[i].pBt);
								sqlite3PagerCacheStat(pPager, (int)(op), (int)(resetFlag), &nRet);
							}
						}

						*pHighwater = (int)(0);
						*pCurrent = (int)(nRet);
						break;
					}

				case 10:
					{
						*pHighwater = (int)(0);
						*pCurrent = (int)(((db.nDeferredImmCons) > (0)) || ((db.nDeferredCons) > (0)) ? 1 : 0);
						break;
					}

				default:
					{
						rc = (int)(1);
					}
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_declare_vtab(sqlite3 db, sbyte* zCreateTable)
		{
			VtabCtx pCtx;
			int rc = (int)(0);
			Table pTab;
			Parse sParse = new Parse();
			int initBusy = 0;
			sqlite3_mutex_enter(db.mutex);
			pCtx = db.pVtabCtx;
			if ((pCtx == null) || ((pCtx.bDeclared) != 0))
			{
				sqlite3Error(db, (int)(21));
				sqlite3_mutex_leave(db.mutex);
				return (int)(sqlite3MisuseError((int)(146294)));
			}

			pTab = pCtx.pTab;

			sqlite3ParseObjectInit(sParse, db);
			sParse.eParseMode = (byte)(1);
			sParse.disableTriggers = (byte)(1);

			initBusy = (int)(db.init.busy);
			db.init.busy = (byte)(0);
			sParse.nQueryLoop = (uint)(1);
			if (((((0) == (sqlite3RunParser(sParse, zCreateTable))) && (sParse.pNewTable != null)) && ((!db.mallocFailed) != 0)) && (((sParse.pNewTable).eTabType) == (0)))
			{

				if (pTab.aCol == null)
				{
					Table pNew = sParse.pNewTable;
					Index pIdx;
					pTab.aCol = pNew.aCol;
					sqlite3ExprListDelete(db, pNew.u.tab.pDfltList);
					pTab.nNVCol = (short)(pTab.nCol = (short)(pNew.nCol));
					pTab.tabFlags |= (uint)(pNew.tabFlags & (0x00000080 | 0x00000200));
					pNew.nCol = (short)(0);
					pNew.aCol = null;


					if (((!(((pNew).tabFlags & 0x00000080) == (0))) && (pCtx.pVTable.pMod.pModule.xUpdate != null)) && (sqlite3PrimaryKeyIndex(pNew).nKeyCol != 1))
					{
						rc = (int)(1);
					}

					pIdx = pNew.pIndex;
					if ((pIdx) != null)
					{

						pTab.pIndex = pIdx;
						pNew.pIndex = null;
						pIdx.pTable = pTab;
					}
				}

				pCtx.bDeclared = (int)(1);
			}
			else
			{
				sqlite3ErrorWithMsg(db, (int)(1), ((sParse.zErrMsg) != 0 ? "%s" : null), sParse.zErrMsg);
				sqlite3DbFree(db, sParse.zErrMsg);
				rc = (int)(1);
			}

			sParse.eParseMode = (byte)(0);
			if ((sParse.pVdbe) != null)
			{
				sqlite3VdbeFinalize(sParse.pVdbe);
			}

			sqlite3DeleteTable(db, sParse.pNewTable);
			sqlite3ParseObjectReset(sParse);
			db.init.busy = (byte)(initBusy);

			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_deserialize(sqlite3 db, sbyte* zSchema, byte* pData, long szDb, long szBuf, uint mFlags)
		{
			MemFile p;
			sbyte* zSql;
			sqlite3_stmt* pStmt = null;
			int rc = 0;
			int iDb = 0;
			sqlite3_mutex_enter(db.mutex);
			if ((zSchema) == (null))
				zSchema = db.aDb[0].zDbSName;
			iDb = (int)(sqlite3FindDbName(db, zSchema));
			if (((iDb) < (2)) && (iDb != 0))
			{
				rc = (int)(1);
				goto end_deserialize;
			}

			zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);
			if ((zSql) == (null))
			{
				rc = (int)(7);
			}
			else
			{
				rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, null));
				sqlite3_free(zSql);
			}

			if ((rc) != 0)
				goto end_deserialize;
			db.init.iDb = ((byte)(iDb));
			db.init.reopenMemdb = (uint)(1);
			rc = (int)(sqlite3_step(pStmt));
			db.init.reopenMemdb = (uint)(0);
			if (rc != 101)
			{
				rc = (int)(1);
				goto end_deserialize;
			}

			p = memdbFromDbSchema(db, zSchema);
			if ((p) == (null))
			{
				rc = (int)(1);
			}
			else
			{
				MemStore* pStore = p.pStore;
				pStore->aData = pData;
				pData = null;
				pStore->sz = (long)(szDb);
				pStore->szAlloc = (long)(szBuf);
				pStore->szMax = (long)(szBuf);
				if ((pStore->szMax) < (sqlite3Config.mxMemdbSize))
				{
					pStore->szMax = (long)(sqlite3Config.mxMemdbSize);
				}

				pStore->mFlags = (uint)(mFlags);
				rc = (int)(0);
			}

		end_deserialize:
			; sqlite3_finalize(pStmt);
			if (((pData) != null) && ((mFlags & 1) != 0))
			{
				sqlite3_free(pData);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_drop_modules(sqlite3 db, sbyte** azNames)
		{
			HashElem* pThis; HashElem* pNext;
			for (pThis = ((&db.aModule)->first); pThis; pThis = pNext)
			{
				Module pMod = (Module)((pThis)->data);
				pNext = ((pThis)->next);
				if ((azNames) != null)
				{
					int ii = 0;
					for (ii = (int)(0); (azNames[ii] != null) && (CRuntime.strcmp(azNames[ii], pMod.zName) != 0); ii++)
					{
					}

					if (azNames[ii] != null)
						continue;
				}

				createModule(db, pMod.zName, null, null, null);
			}

			return (int)(0);
		}
		public static int sqlite3_enable_load_extension(sqlite3 db, int onoff)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((onoff) != 0)
			{
				db.flags |= (ulong)(0x00010000 | 0x00020000);
			}
			else
			{
				db.flags &= (ulong)(~(ulong)(0x00010000 | 0x00020000));
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_enable_shared_cache(int enable)
		{
			sqlite3Config.sharedCacheEnabled = (int)(enable);
			return (int)(0);
		}
		public static int sqlite3_errcode(sqlite3 db)
		{
			if (((db) != null) && (sqlite3SafetyCheckSickOrOk(db) == 0))
			{
				return (int)(sqlite3MisuseError((int)(171132)));
			}

			if ((db == null) || ((db.mallocFailed) != 0))
			{
				return (int)(7);
			}

			return (int)(db.errCode & db.errMask);
		}
		public static sbyte* sqlite3_errmsg(sqlite3 db)
		{
			sbyte* z;
			if (db == null)
			{
				return sqlite3ErrStr((int)(7));
			}

			if (sqlite3SafetyCheckSickOrOk(db) == 0)
			{
				return sqlite3ErrStr((int)(sqlite3MisuseError((int)(171053))));
			}

			sqlite3_mutex_enter(db.mutex);
			if ((db.mallocFailed) != 0)
			{
				z = sqlite3ErrStr((int)(7));
			}
			else
			{
				z = (db.errCode) != 0 ? (sbyte*)(sqlite3_value_text(db.pErr)) : null;

				if ((z) == (null))
				{
					z = sqlite3ErrStr((int)(db.errCode));
				}
			}

			sqlite3_mutex_leave(db.mutex);
			return z;
		}
		public static void* sqlite3_errmsg16(sqlite3 db)
		{
			void* z;
			if (db == null)
			{
				return (void*)(sqlite3_errmsg16_outOfMem);
			}

			if (sqlite3SafetyCheckSickOrOk(db) == 0)
			{
				return (void*)(sqlite3_errmsg16_misuse);
			}

			sqlite3_mutex_enter(db.mutex);
			if ((db.mallocFailed) != 0)
			{
				z = (void*)(sqlite3_errmsg16_outOfMem);
			}
			else
			{
				z = sqlite3_value_text16(db.pErr);
				if ((z) == (null))
				{
					sqlite3ErrorWithMsg(db, (int)(db.errCode), sqlite3ErrStr((int)(db.errCode)));
					z = sqlite3_value_text16(db.pErr);
				}

				sqlite3OomClear(db);
			}

			sqlite3_mutex_leave(db.mutex);
			return z;
		}
		public static int sqlite3_error_offset(sqlite3 db)
		{
			int iOffset = (int)(-1);
			if ((((db) != null) && ((sqlite3SafetyCheckSickOrOk(db)) != 0)) && ((db.errCode) != 0))
			{
				sqlite3_mutex_enter(db.mutex);
				iOffset = (int)(db.errByteOffset);
				sqlite3_mutex_leave(db.mutex);
			}

			return (int)(iOffset);
		}
		public static sbyte* sqlite3_errstr(int rc)
		{
			return sqlite3ErrStr((int)(rc));
		}
		public static int sqlite3_exec(sqlite3 db, sbyte* zSql, delegate54 xCallback, void* pArg, sbyte** pzErrMsg)
		{
			int rc = (int)(0);
			sbyte* zLeftover;
			sqlite3_stmt* pStmt = null;
			sbyte** azCols = null;
			int callbackIsInit = 0;
			if (sqlite3SafetyCheckOk(db) == 0)
				return (int)(sqlite3MisuseError((int)(128104)));
			if ((zSql) == (null))
				zSql = "";
			sqlite3_mutex_enter(db.mutex);
			sqlite3Error(db, (int)(0));
			while (((rc) == (0)) && ((zSql[0]) != 0))
			{
				int nCol = (int)(0);
				sbyte** azVals = null;
				pStmt = null;
				rc = (int)(sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, &zLeftover));

				if (rc != 0)
				{
					continue;
				}

				if (pStmt == null)
				{
					zSql = zLeftover;
					continue;
				}

				callbackIsInit = (int)(0);
				while ((1) != 0)
				{
					int i = 0;
					rc = (int)(sqlite3_step(pStmt));
					if (((xCallback) != null) && (((100) == (rc)) || ((((101) == (rc)) && (callbackIsInit == 0)) && ((db.flags & 0x00000100) != 0))))
					{
						if (callbackIsInit == 0)
						{
							nCol = (int)(sqlite3_column_count(pStmt));
							azCols = sqlite3DbMallocRaw(db, (ulong)((2 * nCol + 1) * sizeof(constchar*)));
							if ((azCols) == (null))
							{
								goto exec_out;
							}

							for (i = (int)(0); (i) < (nCol); i++)
							{
								azCols[i] = sqlite3_column_name(pStmt, (int)(i));

							}

							callbackIsInit = (int)(1);
						}

						if ((rc) == (100))
						{
							azVals = &azCols[nCol];
							for (i = (int)(0); (i) < (nCol); i++)
							{
								azVals[i] = (sbyte*)(sqlite3_column_text(pStmt, (int)(i)));
								if ((azVals[i] == null) && (sqlite3_column_type(pStmt, (int)(i)) != 5))
								{
									sqlite3OomFault(db);
									goto exec_out;
								}
							}

							azVals[i] = null;
						}

						if ((xCallback(pArg, (int)(nCol), azVals, azCols)) != 0)
						{
							rc = (int)(4);
							sqlite3VdbeFinalize((Vdbe)(pStmt));
							pStmt = null;
							sqlite3Error(db, (int)(4));
							goto exec_out;
						}
					}

					if (rc != 100)
					{
						rc = (int)(sqlite3VdbeFinalize((Vdbe)(pStmt)));
						pStmt = null;
						zSql = zLeftover;
						while ((sqlite3CtypeMap[(byte)(zSql[0])] & 0x01) != 0)
						{
							zSql++;
						}

						break;
					}
				}

				sqlite3DbFree(db, azCols);
				azCols = null;
			}

		exec_out:
			; if ((pStmt) != null) sqlite3VdbeFinalize((Vdbe)(pStmt));
			sqlite3DbFree(db, azCols);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			if ((rc != 0) && ((pzErrMsg) != null))
			{
				*pzErrMsg = sqlite3DbStrDup(null, sqlite3_errmsg(db));
				if ((*pzErrMsg) == (null))
				{
					rc = (int)(7);
					sqlite3Error(db, (int)(7));
				}
			}
			else if ((pzErrMsg) != null)
			{
				*pzErrMsg = null;
			}


			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static sbyte* sqlite3_expanded_sql(sqlite3_stmt* pStmt)
		{
			sbyte* z = null;
			sbyte* zSql = sqlite3_sql(pStmt);
			if ((zSql) != null)
			{
				Vdbe p = (Vdbe)(pStmt);
				sqlite3_mutex_enter(p.db.mutex);
				z = sqlite3VdbeExpandSql(p, zSql);
				sqlite3_mutex_leave(p.db.mutex);
			}

			return z;
		}
		public static int sqlite3_expired(sqlite3_stmt* pStmt)
		{
			Vdbe p = (Vdbe)(pStmt);
			return (((p) == (null)) || ((p.expired) != 0) ? 1 : 0);
		}
		public static int sqlite3_extended_errcode(sqlite3 db)
		{
			if (((db) != null) && (sqlite3SafetyCheckSickOrOk(db) == 0))
			{
				return (int)(sqlite3MisuseError((int)(171141)));
			}

			if ((db == null) || ((db.mallocFailed) != 0))
			{
				return (int)(7);
			}

			return (int)(db.errCode);
		}
		public static int sqlite3_extended_result_codes(sqlite3 db, int onoff)
		{
			sqlite3_mutex_enter(db.mutex);
			db.errMask = (int)((onoff) != 0 ? 0xffffffff : 0xff);
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_file_control(sqlite3 db, sbyte* zDbName, int op, void* pArg)
		{
			int rc = (int)(1);
			Btree pBtree;
			sqlite3_mutex_enter(db.mutex);
			pBtree = sqlite3DbNameToBtree(db, zDbName);
			if ((pBtree) != null)
			{
				Pager pPager;
				sqlite3_file fd;
				sqlite3BtreeEnter(pBtree);
				pPager = sqlite3BtreePager(pBtree);

				fd = sqlite3PagerFile(pPager);

				if ((op) == (7))
				{
					(sqlite3_file)(pArg) = fd;
					rc = (int)(0);
				}
				else if ((op) == (27))
				{
					(sqlite3_vfs)(pArg) = sqlite3PagerVfs(pPager);
					rc = (int)(0);
				}
				else if ((op) == (28))
				{
					(sqlite3_file)(pArg) = sqlite3PagerJrnlFile(pPager);
					rc = (int)(0);
				}
				else if ((op) == (35))
				{
					*(uint*)(pArg) = (uint)(sqlite3PagerDataVersion(pPager));
					rc = (int)(0);
				}
				else if ((op) == (38))
				{
					int iNew = (int)(*(int*)(pArg));
					*(int*)(pArg) = (int)(sqlite3BtreeGetRequestedReserve(pBtree));
					if (((iNew) >= (0)) && ((iNew) <= (255)))
					{
						sqlite3BtreeSetPageSize(pBtree, (int)(0), (int)(iNew), (int)(0));
					}

					rc = (int)(0);
				}
				else
				{
					int nSave = (int)(db.busyHandler.nBusy);
					rc = (int)(sqlite3OsFileControl(fd, (int)(op), pArg));
					db.busyHandler.nBusy = (int)(nSave);
				}

				sqlite3BtreeLeave(pBtree);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static sbyte* sqlite3_filename_database(sbyte* zFilename)
		{
			if ((zFilename) == (null))
				return null;
			return databaseName(zFilename);
		}
		public static sbyte* sqlite3_filename_journal(sbyte* zFilename)
		{
			if ((zFilename) == (null))
				return null;
			zFilename = databaseName(zFilename);
			zFilename += sqlite3Strlen30(zFilename) + 1;
			while (((zFilename) != null) && ((zFilename[0]) != 0))
			{
				zFilename += sqlite3Strlen30(zFilename) + 1;
				zFilename += sqlite3Strlen30(zFilename) + 1;
			}

			return zFilename + 1;
		}
		public static sbyte* sqlite3_filename_wal(sbyte* zFilename)
		{
			zFilename = sqlite3_filename_journal(zFilename);
			if ((zFilename) != null)
				zFilename += sqlite3Strlen30(zFilename) + 1;
			return zFilename;
		}
		public static int sqlite3_finalize(sqlite3_stmt* pStmt)
		{
			int rc = 0;
			if ((pStmt) == (null))
			{
				rc = (int)(0);
			}
			else
			{
				Vdbe v = (Vdbe)(pStmt);
				sqlite3 db = v.db;
				if ((vdbeSafety(v)) != 0)
					return (int)(sqlite3MisuseError((int)(85164)));
				sqlite3_mutex_enter(db.mutex);
				if (((v).startTime) > (0))
				{
					invokeProfileCallback(db, v);
				}

				rc = (int)(sqlite3VdbeFinalize(v));
				rc = (int)(sqlite3ApiExit(db, (int)(rc)));
				sqlite3LeaveMutexAndCloseZombie(db);
			}

			return (int)(rc);
		}
		public static void sqlite3_free(void* p)
		{
			if ((p) == (null))
				return;


			if ((sqlite3Config.bMemstat) != 0)
			{
				sqlite3_mutex_enter(mem0.mutex);
				sqlite3StatusDown((int)(0), (int)(sqlite3MallocSize(p)));
				sqlite3StatusDown((int)(9), (int)(1));
				sqlite3Config.m.xFree(p);
				sqlite3_mutex_leave(mem0.mutex);
			}
			else
			{
				sqlite3Config.m.xFree(p);
			}
		}
		public static void sqlite3_free_filename(sbyte* p)
		{
			if ((p) == (null))
				return;
			p = databaseName(p);
			sqlite3_free(p - 4);
		}
		public static void sqlite3_free_table(sbyte** azResult)
		{
			if ((azResult) != null)
			{
				int i = 0;
				int n = 0;
				azResult--;

				n = ((int)((long)(azResult[0])));
				for (i = (int)(1); (i) < (n); i++)
				{
					if ((azResult[i]) != null)
						sqlite3_free(azResult[i]);
				}

				sqlite3_free(azResult);
			}
		}
		public static int sqlite3_get_autocommit(sqlite3 db)
		{
			return (int)(db.autoCommit);
		}
		public static void* sqlite3_get_auxdata(sqlite3_context pCtx, int iArg)
		{
			AuxData pAuxData;


			for (pAuxData = pCtx.pVdbe.pAuxData; pAuxData; pAuxData = pAuxData.pNextAux)
			{
				if (((pAuxData.iAuxArg) == (iArg)) && (((pAuxData.iAuxOp) == (pCtx.iOp)) || ((iArg) < (0))))
				{
					return pAuxData.pAux;
				}
			}

			return null;
		}
		public static int sqlite3_get_table(sqlite3 db, sbyte* zSql, sbyte*** pazResult, int* pnRow, int* pnColumn, sbyte** pzErrMsg)
		{
			int rc = 0;
			TabResult res = new TabResult();
			*pazResult = null;
			if ((pnColumn) != null)
				*pnColumn = (int)(0);
			if ((pnRow) != null)
				*pnRow = (int)(0);
			if ((pzErrMsg) != null)
				*pzErrMsg = null;
			res.zErrMsg = null;
			res.nRow = (uint)(0);
			res.nColumn = (uint)(0);
			res.nData = (uint)(1);
			res.nAlloc = (uint)(20);
			res.rc = (int)(0);
			res.azResult = sqlite3_malloc64((ulong)(sizeof(char*) * res.nAlloc));
			if ((res.azResult) == (null))
			{
				db.errCode = (int)(7);
				return (int)(7);
			}

			res.azResult[0] = null;
			rc = (int)(sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg));

			res.azResult[0] = ((void*)((long)(res.nData)));
			if ((rc & 0xff) == (4))
			{
				sqlite3_free_table(&res.azResult[1]);
				if ((res.zErrMsg) != null)
				{
					if ((pzErrMsg) != null)
					{
						sqlite3_free(*pzErrMsg);
						*pzErrMsg = sqlite3_mprintf("%s", res.zErrMsg);
					}

					sqlite3_free(res.zErrMsg);
				}

				db.errCode = (int)(res.rc);
				return (int)(res.rc);
			}

			sqlite3_free(res.zErrMsg);
			if (rc != 0)
			{
				sqlite3_free_table(&res.azResult[1]);
				return (int)(rc);
			}

			if ((res.nAlloc) > (res.nData))
			{
				sbyte** azNew;
				azNew = sqlite3Realloc(res.azResult, (ulong)(sizeof(char*) * res.nData));
				if ((azNew) == (null))
				{
					sqlite3_free_table(&res.azResult[1]);
					db.errCode = (int)(7);
					return (int)(7);
				}

				res.azResult = azNew;
			}

			*pazResult = &res.azResult[1];
			if ((pnColumn) != null)
				*pnColumn = (int)(res.nColumn);
			if ((pnRow) != null)
				*pnRow = (int)(res.nRow);
			return (int)(rc);
		}
		public static int sqlite3_get_table_cb(void* pArg, int nCol, sbyte** argv, sbyte** colv)
		{
			TabResult* p = (TabResult*)(pArg);
			int need = 0;
			int i = 0;
			sbyte* z;
			if (((p->nRow) == (0)) && (argv != null))
			{
				need = (int)(nCol * 2);
			}
			else
			{
				need = (int)(nCol);
			}

			if ((p->nData + need) > (p->nAlloc))
			{
				sbyte** azNew;
				p->nAlloc = (uint)(p->nAlloc * 2 + need);
				azNew = sqlite3Realloc(p->azResult, (ulong)(sizeof(char*) * p->nAlloc));
				if ((azNew) == (null))
					goto malloc_failed;
				p->azResult = azNew;
			}

			if ((p->nRow) == (0))
			{
				p->nColumn = (uint)(nCol);
				for (i = (int)(0); (i) < (nCol); i++)
				{
					z = sqlite3_mprintf("%s", colv[i]);
					if ((z) == (null))
						goto malloc_failed;
					p->azResult[p->nData++] = z;
				}
			}
			else if ((int)(p->nColumn) != nCol)
			{
				sqlite3_free(p->zErrMsg);
				p->zErrMsg = sqlite3_mprintf("sqlite3_get_table() called with two or more incompatible queries");
				p->rc = (int)(1);
				return (int)(1);
			}

			if (argv != null)
			{
				for (i = (int)(0); (i) < (nCol); i++)
				{
					if ((argv[i]) == (null))
					{
						z = null;
					}
					else
					{
						int n = (int)(sqlite3Strlen30(argv[i]) + 1);
						z = sqlite3_malloc64((ulong)(n));
						if ((z) == (null))
							goto malloc_failed;
						CRuntime.memcpy(z, argv[i], (ulong)(n));
					}

					p->azResult[p->nData++] = z;
				}

				p->nRow++;
			}

			return (int)(0);
		malloc_failed:
			; p->rc = (int)(7);
			return (int)(1);
		}
		public static int sqlite3_global_recover()
		{
			return (int)(0);
		}
		public static long sqlite3_hard_heap_limit64(long n)
		{
			long priorLimit = 0;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (long)(-1);
			sqlite3_mutex_enter(mem0.mutex);
			priorLimit = (long)(mem0.hardLimit);
			if ((n) >= (0))
			{
				mem0.hardLimit = (long)(n);
				if (((n) < (mem0.alarmThreshold)) || ((mem0.alarmThreshold) == (0)))
				{
					mem0.alarmThreshold = (long)(n);
				}
			}

			sqlite3_mutex_leave(mem0.mutex);
			return (long)(priorLimit);
		}
		public static int sqlite3_initialize()
		{
			sqlite3_mutex* pMainMtx;
			int rc = 0;

			if ((sqlite3Config.isInit) != 0)
			{
				sqlite3MemoryBarrier();
				return (int)(0);
			}

			rc = (int)(sqlite3MutexInit());
			if ((rc) != 0)
				return (int)(rc);
			pMainMtx = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(pMainMtx);
			sqlite3Config.isMutexInit = (int)(1);
			if (sqlite3Config.isMallocInit == 0)
			{
				rc = (int)(sqlite3MallocInit());
			}

			if ((rc) == (0))
			{
				sqlite3Config.isMallocInit = (int)(1);
				if (sqlite3Config.pInitMutex == null)
				{
					sqlite3Config.pInitMutex = sqlite3MutexAlloc((int)(1));
					if (((sqlite3Config.bCoreMutex) != 0) && (sqlite3Config.pInitMutex == null))
					{
						rc = (int)(7);
					}
				}
			}

			if ((rc) == (0))
			{
				sqlite3Config.nRefInitMutex++;
			}

			sqlite3_mutex_leave(pMainMtx);
			if (rc != 0)
			{
				return (int)(rc);
			}

			sqlite3_mutex_enter(sqlite3Config.pInitMutex);
			if (((sqlite3Config.isInit) == (0)) && ((sqlite3Config.inProgress) == (0)))
			{
				sqlite3Config.inProgress = (int)(1);
				CRuntime.memset(sqlite3BuiltinFunctions, (int)(0), (ulong)(sizeof(FuncDefHash)));
				sqlite3RegisterBuiltinFunctions();
				if ((sqlite3Config.isPCacheInit) == (0))
				{
					rc = (int)(sqlite3PcacheInitialize());
				}

				if ((rc) == (0))
				{
					sqlite3Config.isPCacheInit = (int)(1);
					rc = (int)(sqlite3OsInit());
				}

				if ((rc) == (0))
				{
					rc = (int)(sqlite3MemdbInit());
				}

				if ((rc) == (0))
				{
					sqlite3PCacheBufferSetup(sqlite3Config.pPage, (int)(sqlite3Config.szPage), (int)(sqlite3Config.nPage));
					sqlite3MemoryBarrier();
					sqlite3Config.isInit = (int)(1);
				}

				sqlite3Config.inProgress = (int)(0);
			}

			sqlite3_mutex_leave(sqlite3Config.pInitMutex);
			sqlite3_mutex_enter(pMainMtx);
			sqlite3Config.nRefInitMutex--;
			if ((sqlite3Config.nRefInitMutex) <= (0))
			{

				sqlite3_mutex_free(sqlite3Config.pInitMutex);
				sqlite3Config.pInitMutex = null;
			}

			sqlite3_mutex_leave(pMainMtx);
			return (int)(rc);
		}
		public static void sqlite3_interrupt(sqlite3 db)
		{
			(1);
		}
		public static int sqlite3_keyword_check(sbyte* zName, int nName)
		{
			return (int)(59 != sqlite3KeywordCode((byte*)(zName), (int)(nName)));
		}
		public static int sqlite3_keyword_count()
		{
			return (int)(147);
		}
		public static int sqlite3_keyword_name(int i, sbyte** pzName, int* pnName)
		{
			if (((i) < (0)) || ((i) >= (147)))
				return (int)(1);
			*pzName = zKWText + aKWOffset[i];
			*pnName = (int)(aKWLen[i]);
			return (int)(0);
		}
		public static long sqlite3_last_insert_rowid(sqlite3 db)
		{
			return (long)(db.lastRowid);
		}
		public static sbyte* sqlite3_libversion()
		{
			return sqlite3_version;
		}
		public static int sqlite3_libversion_number()
		{
			return (int)(3038002);
		}
		public static int sqlite3_limit(sqlite3 db, int limitId, int newLimit)
		{
			int oldLimit = 0;













			if (((limitId) < (0)) || ((limitId) >= (11 + 1)))
			{
				return (int)(-1);
			}

			oldLimit = (int)(db.aLimit[limitId]);
			if ((newLimit) >= (0))
			{
				if ((newLimit) > (aHardLimit[limitId]))
				{
					newLimit = (int)(aHardLimit[limitId]);
				}
				else if (((newLimit) < (1)) && ((limitId) == (0)))
				{
					newLimit = (int)(1);
				}

				db.aLimit[limitId] = (int)(newLimit);
			}

			return (int)(oldLimit);
		}
		public static int sqlite3_load_extension(sqlite3 db, sbyte* zFile, sbyte* zProc, sbyte** pzErrMsg)
		{
			int rc = 0;
			sqlite3_mutex_enter(db.mutex);
			rc = (int)(sqlite3LoadExtension(db, zFile, zProc, pzErrMsg));
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static void sqlite3_log(int iErrCode, sbyte* zFormat)
		{
			sbyte* ap;
			if ((sqlite3Config.xLog) != null)
			{
				(__va_start(&ap, zFormat));
				renderLogMsg((int)(iErrCode), zFormat, ap);
				((void)(ap = null));
			}
		}
		public static void* sqlite3_malloc(int n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return (n) <= (0) ? null : sqlite3Malloc((ulong)(n));
		}
		public static void* sqlite3_malloc64(ulong n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return sqlite3Malloc((ulong)(n));
		}
		public static int sqlite3_memory_alarm(delegate62 xCallback, void* pArg, long iThreshold)
		{
			(void)(xCallback);
			(void)(pArg);
			(void)(iThreshold);
			return (int)(0);
		}
		public static long sqlite3_memory_highwater(int resetFlag)
		{
			long res = 0; long mx = 0;
			sqlite3_status64((int)(0), &res, &mx, (int)(resetFlag));
			return (long)(mx);
		}
		public static long sqlite3_memory_used()
		{
			long res = 0; long mx = 0;
			sqlite3_status64((int)(0), &res, &mx, (int)(0));
			return (long)(res);
		}
		public static sbyte* sqlite3_mprintf(sbyte* zFormat)
		{
			sbyte* ap;
			sbyte* z;
			if ((sqlite3_initialize()) != 0)
				return null;
			(__va_start(&ap, zFormat));
			z = sqlite3_vmprintf(zFormat, ap);
			((void)(ap = null));
			return z;
		}
		public static ulong sqlite3_msize(void* p)
		{


			return (ulong)(p ? sqlite3Config.m.xSize(p) : 0);
		}
		public static sqlite3_mutex* sqlite3_mutex_alloc(int id)
		{
			if (((id) <= (1)) && ((sqlite3_initialize()) != 0))
				return null;
			if (((id) > (1)) && ((sqlite3MutexInit()) != 0))
				return null;

			return sqlite3Config.mutex.xMutexAlloc((int)(id));
		}
		public static void sqlite3_mutex_enter(sqlite3_mutex* p)
		{
			if ((p) != null)
			{

				sqlite3Config.mutex.xMutexEnter(p);
			}
		}
		public static void sqlite3_mutex_free(sqlite3_mutex* p)
		{
			if ((p) != null)
			{

				sqlite3Config.mutex.xMutexFree(p);
			}
		}
		public static void sqlite3_mutex_leave(sqlite3_mutex* p)
		{
			if ((p) != null)
			{

				sqlite3Config.mutex.xMutexLeave(p);
			}
		}
		public static int sqlite3_mutex_try(sqlite3_mutex* p)
		{
			int rc = (int)(0);
			if ((p) != null)
			{

				return (int)(sqlite3Config.mutex.xMutexTry(p));
			}

			return (int)(rc);
		}
		public static sqlite3_stmt* sqlite3_next_stmt(sqlite3 pDb, sqlite3_stmt* pStmt)
		{
			sqlite3_stmt* pNext;
			sqlite3_mutex_enter(pDb.mutex);
			if ((pStmt) == (null))
			{
				pNext = (sqlite3_stmt*)(pDb.pVdbe);
			}
			else
			{
				pNext = (sqlite3_stmt*)(((Vdbe)(pStmt)).pNext);
			}

			sqlite3_mutex_leave(pDb.mutex);
			return pNext;
		}
		public static int sqlite3_open(sbyte* zFilename, sqlite3 ppDb)
		{
			return (int)(openDatabase(zFilename, ppDb, (uint)(0x00000002 | 0x00000004), null));
		}
		public static int sqlite3_open_v2(sbyte* filename, sqlite3 ppDb, int flags, sbyte* zVfs)
		{
			return (int)(openDatabase(filename, ppDb, (uint)(flags), zVfs));
		}
		public static int sqlite3_open16(void* zFilename, sqlite3 ppDb)
		{
			sbyte* zFilename8;
			sqlite3_value pVal;
			int rc = 0;
			ppDb = null;
			rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			if ((zFilename) == (null))
				zFilename = "\000\000";
			pVal = sqlite3ValueNew(null);
			sqlite3ValueSetStr(pVal, (int)(-1), zFilename, (byte)(2), null);
			zFilename8 = sqlite3ValueText(pVal, (byte)(1));
			if ((zFilename8) != null)
			{
				rc = (int)(openDatabase(zFilename8, ppDb, (uint)(0x00000002 | 0x00000004), null));

				if (((rc) == (0)) && (!(((ppDb).aDb[0].pSchema.schemaFlags & (0x0001)) == (0x0001))))
				{
					((ppDb).aDb[0].pSchema.enc) = (byte)(((ppDb).enc) = (byte)(2));
				}
			}
			else
			{
				rc = (int)(7);
			}

			sqlite3ValueFree(pVal);
			return (int)(rc & 0xff);
		}
		public static int sqlite3_os_end()
		{
			winBigLock = null;
			return (int)(0);
		}
		public static int sqlite3_os_init()
		{

			CRuntime.memset(&winSysInfo, (int)(0), (ulong)(sizeof(_SYSTEM_INFO)));
			(Void(_SYSTEM_INFO * ))(aSyscall[28].pCurrent)(&winSysInfo);


			sqlite3_vfs_register(sqlite3_os_init_winVfs, (int)(1));
			sqlite3_vfs_register(sqlite3_os_init_winLongPathVfs, (int)(0));
			sqlite3_vfs_register(sqlite3_os_init_winNolockVfs, (int)(0));
			sqlite3_vfs_register(sqlite3_os_init_winLongPathNolockVfs, (int)(0));
			winBigLock = sqlite3MutexAlloc((int)(11));
			return (int)(0);
		}
		public static int sqlite3_overload_function(sqlite3 db, sbyte* zName, int nArg)
		{
			int rc = 0;
			sbyte* zCopy;
			sqlite3_mutex_enter(db.mutex);
			rc = (int)(sqlite3FindFunction(db, zName, (int)(nArg), (byte)(1), (byte)(0)) != null);
			sqlite3_mutex_leave(db.mutex);
			if ((rc) != 0)
				return (int)(0);
			zCopy = sqlite3_mprintf(zName);
			if ((zCopy) == (null))
				return (int)(7);
			return (int)(sqlite3_create_function_v2(db, zName, (int)(nArg), (int)(1), zCopy, sqlite3InvalidFunction, null, null, sqlite3_free));
		}
		public static int sqlite3_prepare(sqlite3 db, sbyte* zSql, int nBytes, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0), null, ppStmt, pzTail));

			return (int)(rc);
		}
		public static int sqlite3_prepare_v2(sqlite3 db, sbyte* zSql, int nBytes, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0x80), null, ppStmt, pzTail));

			return (int)(rc);
		}
		public static int sqlite3_prepare_v3(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(nBytes), (uint)(0x80 | (prepFlags & 0x0f)), null, ppStmt, pzTail));

			return (int)(rc);
		}
		public static int sqlite3_prepare16(sqlite3 db, void* zSql, int nBytes, sqlite3_stmt** ppStmt, void** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0), ppStmt, pzTail));

			return (int)(rc);
		}
		public static int sqlite3_prepare16_v2(sqlite3 db, void* zSql, int nBytes, sqlite3_stmt** ppStmt, void** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0x80), ppStmt, pzTail));

			return (int)(rc);
		}
		public static int sqlite3_prepare16_v3(sqlite3 db, void* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, void** pzTail)
		{
			int rc = 0;
			rc = (int)(sqlite3Prepare16(db, zSql, (int)(nBytes), (uint)(0x80 | (prepFlags & 0x0f)), ppStmt, pzTail));

			return (int)(rc);
		}
		public static void* sqlite3_profile(sqlite3 db, delegate62 xProfile, void* pArg)
		{
			void* pOld;
			sqlite3_mutex_enter(db.mutex);
			pOld = db.pProfileArg;
			db.xProfile = xProfile;
			db.pProfileArg = pArg;
			db.mTrace &= (byte)(0x0f);
			if ((db.xProfile) != null)
				db.mTrace |= (byte)(0x80);
			sqlite3_mutex_leave(db.mutex);
			return pOld;
		}
		public static void sqlite3_progress_handler(sqlite3 db, int nOps, delegate19 xProgress, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((nOps) > (0))
			{
				db.xProgress = xProgress;
				db.nProgressOps = ((uint)(nOps));
				db.pProgressArg = pArg;
			}
			else
			{
				db.xProgress = null;
				db.nProgressOps = (uint)(0);
				db.pProgressArg = null;
			}

			sqlite3_mutex_leave(db.mutex);
		}
		public static void sqlite3_randomness(int N, void* pBuf)
		{
			byte t = 0;
			byte* zBuf = pBuf;
			sqlite3_mutex* mutex;
			if ((sqlite3_initialize()) != 0)
				return;
			mutex = sqlite3MutexAlloc((int)(5));
			sqlite3_mutex_enter(mutex);
			if (((N) <= (0)) || ((pBuf) == (null)))
			{
				sqlite3Prng.isInit = (byte)(0);
				sqlite3_mutex_leave(mutex);
				return;
			}

			if (sqlite3Prng.isInit == 0)
			{
				sqlite3_vfs pVfs = sqlite3_vfs_find(null);
				int i = 0;
				sbyte* k = stackalloc sbyte[256];
				sqlite3Prng.j = (byte)(0);
				sqlite3Prng.i = (byte)(0);
				if (((pVfs) == (null)))
				{
					CRuntime.memset(k, (int)(0), (ulong)(256 * sizeof(sbyte)));
				}
				else
				{
					sqlite3OsRandomness(pVfs, (int)(256), k);
				}

				for (i = (int)(0); (i) < (256); i++)
				{
					sqlite3Prng.s[i] = ((byte)(i));
				}

				for (i = (int)(0); (i) < (256); i++)
				{
					sqlite3Prng.j += (byte)(sqlite3Prng.s[i] + k[i]);
					t = (byte)(sqlite3Prng.s[sqlite3Prng.j]);
					sqlite3Prng.s[sqlite3Prng.j] = (byte)(sqlite3Prng.s[i]);
					sqlite3Prng.s[i] = (byte)(t);
				}

				sqlite3Prng.isInit = (byte)(1);
			}


			do
			{
				sqlite3Prng.i++;
				t = (byte)(sqlite3Prng.s[sqlite3Prng.i]);
				sqlite3Prng.j += (byte)(t);
				sqlite3Prng.s[sqlite3Prng.i] = (byte)(sqlite3Prng.s[sqlite3Prng.j]);
				sqlite3Prng.s[sqlite3Prng.j] = (byte)(t);
				t += (byte)(sqlite3Prng.s[sqlite3Prng.i]);
				*(zBuf++) = (byte)(sqlite3Prng.s[t]);
			}
			while ((--N) != 0);
			sqlite3_mutex_leave(mutex);
		}
		public static void* sqlite3_realloc(void* pOld, int n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			if ((n) < (0))
				n = (int)(0);
			return sqlite3Realloc(pOld, (ulong)(n));
		}
		public static void* sqlite3_realloc64(void* pOld, ulong n)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return sqlite3Realloc(pOld, (ulong)(n));
		}
		public static int sqlite3_release_memory(int n)
		{
			(void)(n);
			return (int)(0);
		}
		public static int sqlite3_reset(sqlite3_stmt* pStmt)
		{
			int rc = 0;
			if ((pStmt) == (null))
			{
				rc = (int)(0);
			}
			else
			{
				Vdbe v = (Vdbe)(pStmt);
				sqlite3 db = v.db;
				sqlite3_mutex_enter(db.mutex);
				if (((v).startTime) > (0))
				{
					invokeProfileCallback(db, v);
				}

				rc = (int)(sqlite3VdbeReset(v));
				sqlite3VdbeRewind(v);

				rc = (int)(sqlite3ApiExit(db, (int)(rc)));
				sqlite3_mutex_leave(db.mutex);
			}

			return (int)(rc);
		}
		public static void sqlite3_reset_auto_extension()
		{
			if ((sqlite3_initialize()) == (0))
			{
				sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
				sqlite3_mutex_enter(mutex);
				sqlite3_free(sqlite3Autoext.aExt);
				sqlite3Autoext.aExt = null;
				sqlite3Autoext.nExt = (uint)(0);
				sqlite3_mutex_leave(mutex);
			}
		}
		public static void sqlite3_result_blob(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{


			setResultStrOrError(pCtx, z, (int)(n), (byte)(0), xDel);
		}
		public static void sqlite3_result_blob64(sqlite3_context pCtx, void* z, ulong n, delegate17 xDel)
		{


			if ((n) > (0x7fffffff))
			{
				(void)(invokeValueDestructor(z, xDel, pCtx));
			}
			else
			{
				setResultStrOrError(pCtx, z, (int)(n), (byte)(0), xDel);
			}
		}
		public static void sqlite3_result_double(sqlite3_context pCtx, double rVal)
		{

			sqlite3VdbeMemSetDouble(pCtx.pOut, (double)(rVal));
		}
		public static void sqlite3_result_error(sqlite3_context pCtx, sbyte* z, int n)
		{

			pCtx.isError = (int)(1);
			sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(1), ((Void(Void * ))(-1)));
		}
		public static void sqlite3_result_error_code(sqlite3_context pCtx, int errCode)
		{
			pCtx.isError = (int)((errCode) != 0 ? errCode : -1);
			if ((pCtx.pOut.flags & 0x0001) != 0)
			{
				sqlite3VdbeMemSetStr(pCtx.pOut, sqlite3ErrStr((int)(errCode)), (long)(-1), (byte)(1), null);
			}
		}
		public static void sqlite3_result_error_nomem(sqlite3_context pCtx)
		{

			sqlite3VdbeMemSetNull(pCtx.pOut);
			pCtx.isError = (int)(7);
			sqlite3OomFault(pCtx.pOut.db);
		}
		public static void sqlite3_result_error_toobig(sqlite3_context pCtx)
		{

			pCtx.isError = (int)(18);
			sqlite3VdbeMemSetStr(pCtx.pOut, "string or blob too big", (long)(-1), (byte)(1), null);
		}
		public static void sqlite3_result_error16(sqlite3_context pCtx, void* z, int n)
		{

			pCtx.isError = (int)(1);
			sqlite3VdbeMemSetStr(pCtx.pOut, z, (long)(n), (byte)(2), ((Void(Void * ))(-1)));
		}
		public static void sqlite3_result_int(sqlite3_context pCtx, int iVal)
		{

			sqlite3VdbeMemSetInt64(pCtx.pOut, (long)(iVal));
		}
		public static void sqlite3_result_int64(sqlite3_context pCtx, long iVal)
		{

			sqlite3VdbeMemSetInt64(pCtx.pOut, (long)(iVal));
		}
		public static void sqlite3_result_null(sqlite3_context pCtx)
		{

			sqlite3VdbeMemSetNull(pCtx.pOut);
		}
		public static void sqlite3_result_pointer(sqlite3_context pCtx, void* pPtr, sbyte* zPType, delegate17 xDestructor)
		{
			sqlite3_value pOut = pCtx.pOut;

			sqlite3VdbeMemRelease(pOut);
			pOut.flags = (ushort)(0x0001);
			sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
		}
		public static void sqlite3_result_subtype(sqlite3_context pCtx, uint eSubtype)
		{
			sqlite3_value pOut = pCtx.pOut;

			pOut.eSubtype = (byte)(eSubtype & 0xff);
			pOut.flags |= (ushort)(0x8000);
		}
		public static void sqlite3_result_text(sqlite3_context pCtx, sbyte* z, int n, delegate17 xDel)
		{

			setResultStrOrError(pCtx, z, (int)(n), (byte)(1), xDel);
		}
		public static void sqlite3_result_text16(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{

			setResultStrOrError(pCtx, z, (int)(n), (byte)(2), xDel);
		}
		public static void sqlite3_result_text16be(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{

			setResultStrOrError(pCtx, z, (int)(n), (byte)(3), xDel);
		}
		public static void sqlite3_result_text16le(sqlite3_context pCtx, void* z, int n, delegate17 xDel)
		{

			setResultStrOrError(pCtx, z, (int)(n), (byte)(2), xDel);
		}
		public static void sqlite3_result_text64(sqlite3_context pCtx, sbyte* z, ulong n, delegate17 xDel, byte enc)
		{


			if ((enc) == (4))
				enc = (byte)(2);
			if ((n) > (0x7fffffff))
			{
				(void)(invokeValueDestructor(z, xDel, pCtx));
			}
			else
			{
				setResultStrOrError(pCtx, z, (int)(n), (byte)(enc), xDel);
			}
		}
		public static void sqlite3_result_value(sqlite3_context pCtx, sqlite3_value pValue)
		{

			sqlite3VdbeMemCopy(pCtx.pOut, pValue);
		}
		public static void sqlite3_result_zeroblob(sqlite3_context pCtx, int n)
		{

			sqlite3VdbeMemSetZeroBlob(pCtx.pOut, (int)(n));
		}
		public static int sqlite3_result_zeroblob64(sqlite3_context pCtx, ulong n)
		{
			sqlite3_value pOut = pCtx.pOut;

			if ((n) > ((ulong)(pOut.db.aLimit[0])))
			{
				return (int)(18);
			}

			sqlite3VdbeMemSetZeroBlob(pCtx.pOut, (int)(n));
			return (int)(0);
		}
		public static void* sqlite3_rollback_hook(sqlite3 db, delegate17 xCallback, void* pArg)
		{
			void* pRet;
			sqlite3_mutex_enter(db.mutex);
			pRet = db.pRollbackArg;
			db.xRollbackCallback = xCallback;
			db.pRollbackArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pRet;
		}
		public static byte* sqlite3_serialize(sqlite3 db, sbyte* zSchema, long* piSize, uint mFlags)
		{
			MemFile p;
			int iDb = 0;
			Btree pBt;
			long sz = 0;
			int szPage = (int)(0);
			sqlite3_stmt* pStmt = null;
			byte* pOut;
			sbyte* zSql;
			int rc = 0;
			if ((zSchema) == (null))
				zSchema = db.aDb[0].zDbSName;
			p = memdbFromDbSchema(db, zSchema);
			iDb = (int)(sqlite3FindDbName(db, zSchema));
			if ((piSize) != null)
				*piSize = (long)(-1);
			if ((iDb) < (0))
				return null;
			if ((p) != null)
			{
				MemStore* pStore = p.pStore;

				if ((piSize) != null)
					*piSize = (long)(pStore->sz);
				if ((mFlags & 0x001) != 0)
				{
					pOut = pStore->aData;
				}
				else
				{
					pOut = sqlite3_malloc64((ulong)(pStore->sz));
					if ((pOut) != null)
						CRuntime.memcpy(pOut, pStore->aData, (ulong)(pStore->sz));
				}

				return pOut;
			}

			pBt = db.aDb[iDb].pBt;
			if ((pBt) == (null))
				return null;
			szPage = (int)(sqlite3BtreeGetPageSize(pBt));
			zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);
			rc = (int)((zSql) != 0 ? sqlite3_prepare_v2(db, zSql, (int)(-1), &pStmt, null) : 7);
			sqlite3_free(zSql);
			if ((rc) != 0)
				return null;
			rc = (int)(sqlite3_step(pStmt));
			if (rc != 100)
			{
				pOut = null;
			}
			else
			{
				sz = (long)(sqlite3_column_int64(pStmt, (int)(0)) * szPage);
				if ((piSize) != null)
					*piSize = (long)(sz);
				if ((mFlags & 0x001) != 0)
				{
					pOut = null;
				}
				else
				{
					pOut = sqlite3_malloc64((ulong)(sz));
					if ((pOut) != null)
					{
						int nPage = (int)(sqlite3_column_int(pStmt, (int)(0)));
						Pager pPager = sqlite3BtreePager(pBt);
						int pgno = 0;
						for (pgno = (int)(1); (pgno) <= (nPage); pgno++)
						{
							PgHdr pPage = null;
							byte* pTo = pOut + szPage * (long)(pgno - 1);
							rc = (int)(sqlite3PagerGet(pPager, (uint)(pgno), pPage, (int)(0)));
							if ((rc) == (0))
							{
								CRuntime.memcpy(pTo, sqlite3PagerGetData(pPage), (ulong)(szPage));
							}
							else
							{
								CRuntime.memset(pTo, (int)(0), (ulong)(szPage));
							}

							sqlite3PagerUnref(pPage);
						}
					}
				}
			}

			sqlite3_finalize(pStmt);
			return pOut;
		}
		public static int sqlite3_set_authorizer(sqlite3 db, delegate66 xAuth, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			db.xAuth = xAuth;
			db.pAuthArg = pArg;
			if ((db.xAuth) != null)
				sqlite3ExpirePreparedStatements(db, (int)(1));
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static void sqlite3_set_auxdata(sqlite3_context pCtx, int iArg, void* pAux, delegate17 xDelete)
		{
			AuxData pAuxData;
			Vdbe pVdbe = pCtx.pVdbe;


			for (pAuxData = pVdbe.pAuxData; pAuxData; pAuxData = pAuxData.pNextAux)
			{
				if (((pAuxData.iAuxArg) == (iArg)) && (((pAuxData.iAuxOp) == (pCtx.iOp)) || ((iArg) < (0))))
				{
					break;
				}
			}

			if ((pAuxData) == (null))
			{
				pAuxData = sqlite3DbMallocZero(pVdbe.db, (ulong)(sizeof(AuxData)));
				if (pAuxData == null)
					goto failed;
				pAuxData.iAuxOp = (int)(pCtx.iOp);
				pAuxData.iAuxArg = (int)(iArg);
				pAuxData.pNextAux = pVdbe.pAuxData;
				pVdbe.pAuxData = pAuxData;
				if ((pCtx.isError) == (0))
					pCtx.isError = (int)(-1);
			}
			else if ((pAuxData.xDeleteAux) != null)
			{
				pAuxData.xDeleteAux(pAuxData.pAux);
			}

			pAuxData.pAux = pAux;
			pAuxData.xDeleteAux = xDelete;
			return;
		failed:
			; if ((xDelete) != null) { xDelete(pAux); }
		}
		public static void sqlite3_set_last_insert_rowid(sqlite3 db, long iRowid)
		{
			sqlite3_mutex_enter(db.mutex);
			db.lastRowid = (long)(iRowid);
			sqlite3_mutex_leave(db.mutex);
		}
		public static int sqlite3_shutdown()
		{
			if ((sqlite3Config.isInit) != 0)
			{
				sqlite3_os_end();
				sqlite3_reset_auto_extension();
				sqlite3Config.isInit = (int)(0);
			}

			if ((sqlite3Config.isPCacheInit) != 0)
			{
				sqlite3PcacheShutdown();
				sqlite3Config.isPCacheInit = (int)(0);
			}

			if ((sqlite3Config.isMallocInit) != 0)
			{
				sqlite3MallocEnd();
				sqlite3Config.isMallocInit = (int)(0);
				sqlite3_data_directory = null;
				sqlite3_temp_directory = null;
			}

			if ((sqlite3Config.isMutexInit) != 0)
			{
				sqlite3MutexEnd();
				sqlite3Config.isMutexInit = (int)(0);
			}

			return (int)(0);
		}
		public static int sqlite3_sleep(int ms)
		{
			sqlite3_vfs pVfs;
			int rc = 0;
			pVfs = sqlite3_vfs_find(null);
			if ((pVfs) == (null))
				return (int)(0);
			rc = (int)(sqlite3OsSleep(pVfs, (int)(1000 * ms)) / 1000);
			return (int)(rc);
		}
		public static sbyte* sqlite3_snprintf(int n, sbyte* zBuf, sbyte* zFormat)
		{
			sbyte* z;
			sbyte* ap;
			(__va_start(&ap, zFormat));
			z = sqlite3_vsnprintf((int)(n), zBuf, zFormat, ap);
			((void)(ap = null));
			return z;
		}
		public static void sqlite3_soft_heap_limit(int n)
		{
			if ((n) < (0))
				n = (int)(0);
			sqlite3_soft_heap_limit64((long)(n));
		}
		public static long sqlite3_soft_heap_limit64(long n)
		{
			long priorLimit = 0;
			long excess = 0;
			long nUsed = 0;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (long)(-1);
			sqlite3_mutex_enter(mem0.mutex);
			priorLimit = (long)(mem0.alarmThreshold);
			if ((n) < (0))
			{
				sqlite3_mutex_leave(mem0.mutex);
				return (long)(priorLimit);
			}

			if (((mem0.hardLimit) > (0)) && (((n) > (mem0.hardLimit)) || ((n) == (0))))
			{
				n = (long)(mem0.hardLimit);
			}

			mem0.alarmThreshold = (long)(n);
			nUsed = (long)(sqlite3StatusValue((int)(0)));
			(((n) > (0)) && ((n) <= (nUsed)));
			sqlite3_mutex_leave(mem0.mutex);
			excess = (long)(sqlite3_memory_used() - n);
			if ((excess) > (0))
				sqlite3_release_memory((int)(excess & 0x7fffffff));
			return (long)(priorLimit);
		}
		public static sbyte* sqlite3_sourceid()
		{
			return "2022-03-26 13:51:10 d33c709cc0af66bc5b6dc6216eba9f1f0b40960b9ae83694c986fbf4c1d6f08f";
		}
		public static sbyte* sqlite3_sql(sqlite3_stmt* pStmt)
		{
			Vdbe p = (Vdbe)(pStmt);
			return p ? p.zSql : null;
		}
		public static int sqlite3_status(int op, int* pCurrent, int* pHighwater, int resetFlag)
		{
			long iCur = (long)(0); long iHwtr = (long)(0);
			int rc = 0;
			rc = (int)(sqlite3_status64((int)(op), &iCur, &iHwtr, (int)(resetFlag)));
			if ((rc) == (0))
			{
				*pCurrent = ((int)(iCur));
				*pHighwater = ((int)(iHwtr));
			}

			return (int)(rc);
		}
		public static int sqlite3_status64(int op, long* pCurrent, long* pHighwater, int resetFlag)
		{
			sqlite3_mutex* pMutex;
			if (((op) < (0)) || ((op) >= ((int)(10 * sizeof(long) / sizeof(long)))))
			{
				return (int)(sqlite3MisuseError((int)(22808)));
			}

			pMutex = (statMutex[op]) != 0 ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
			sqlite3_mutex_enter(pMutex);
			*pCurrent = (long)(sqlite3Stat.nowValue[op]);
			*pHighwater = (long)(sqlite3Stat.mxValue[op]);
			if ((resetFlag) != 0)
			{
				sqlite3Stat.mxValue[op] = (long)(sqlite3Stat.nowValue[op]);
			}

			sqlite3_mutex_leave(pMutex);
			(void)(pMutex);
			return (int)(0);
		}
		public static int sqlite3_step(sqlite3_stmt* pStmt)
		{
			int rc = (int)(0);
			Vdbe v = (Vdbe)(pStmt);
			int cnt = (int)(0);
			sqlite3 db;
			if ((vdbeSafetyNotNull(v)) != 0)
			{
				return (int)(sqlite3MisuseError((int)(85824)));
			}

			db = v.db;
			sqlite3_mutex_enter(db.mutex);
			v.doingRerun = (byte)(0);
			while (((rc = (int)(sqlite3Step(v))) == (17)) && ((cnt++) < (50)))
			{
				int savedPc = (int)(v.pc);
				rc = (int)(sqlite3Reprepare(v));
				if (rc != 0)
				{
					sbyte* zErr = (sbyte*)(sqlite3_value_text(db.pErr));
					sqlite3DbFree(db, v.zErrMsg);
					if (db.mallocFailed == 0)
					{
						v.zErrMsg = sqlite3DbStrDup(db, zErr);
						v.rc = (int)(rc = (int)(sqlite3ApiExit(db, (int)(rc))));
					}
					else
					{
						v.zErrMsg = null;
						v.rc = (int)(rc = (int)(7));
					}

					break;
				}

				sqlite3_reset(pStmt);
				if ((savedPc) >= (0))
					v.doingRerun = (byte)(1);

			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_stmt_busy(sqlite3_stmt* pStmt)
		{
			Vdbe v = (Vdbe)(pStmt);
			return (((v != null) && ((v.iVdbeMagic) == (0x2df20da3))) && ((v.pc) >= (0)) ? 1 : 0);
		}
		public static int sqlite3_stmt_isexplain(sqlite3_stmt* pStmt)
		{
			return (int)(pStmt ? ((Vdbe)(pStmt)).explain : 0);
		}
		public static int sqlite3_stmt_readonly(sqlite3_stmt* pStmt)
		{
			return (int)(pStmt ? ((Vdbe)(pStmt)).readOnly : 1);
		}
		public static int sqlite3_stmt_status(sqlite3_stmt* pStmt, int op, int resetFlag)
		{
			Vdbe pVdbe = (Vdbe)(pStmt);
			uint v = 0;
			if ((op) == (99))
			{
				sqlite3 db = pVdbe.db;
				sqlite3_mutex_enter(db.mutex);
				v = (uint)(0);
				db.pnBytesFreed = (int*)(&v);
				sqlite3VdbeClearObject(db, pVdbe);
				sqlite3DbFree(db, pVdbe);
				db.pnBytesFreed = null;
				sqlite3_mutex_leave(db.mutex);
			}
			else
			{
				v = (uint)(pVdbe.aCounter[op]);
				if ((resetFlag) != 0)
					pVdbe.aCounter[op] = (uint)(0);
			}

			return (int)(v);
		}
		public static void sqlite3_str_append(sqlite3_str p, sbyte* z, int N)
		{




			if ((p.nChar + N) >= (p.nAlloc))
			{
				enlargeAndAppend(p, z, (int)(N));
			}
			else if ((N) != 0)
			{

				p.nChar += (uint)(N);
				CRuntime.memcpy(&p.zText[p.nChar - N], z, (ulong)(N));
			}
		}
		public static void sqlite3_str_appendall(sqlite3_str p, sbyte* z)
		{
			sqlite3_str_append(p, z, (int)(sqlite3Strlen30(z)));
		}
		public static void sqlite3_str_appendchar(sqlite3_str p, int N, sbyte c)
		{
			if (((p.nChar + (long)(N)) >= (p.nAlloc)) && ((N = (int)(sqlite3StrAccumEnlarge(p, (int)(N)))) <= (0)))
			{
				return;
			}

			while ((N--) > (0))
			{
				p.zText[p.nChar++] = (sbyte)(c);
			}
		}
		public static void sqlite3_str_appendf(sqlite3_str p, sbyte* zFormat)
		{
			sbyte* ap;
			(__va_start(&ap, zFormat));
			sqlite3_str_vappendf(p, zFormat, ap);
			((void)(ap = null));
		}
		public static int sqlite3_str_errcode(sqlite3_str p)
		{
			return (int)(p ? p.accError : 7);
		}
		public static sbyte* sqlite3_str_finish(sqlite3_str p)
		{
			sbyte* z;
			if ((p != null) && (p != sqlite3OomStr))
			{
				z = sqlite3StrAccumFinish(p);
				sqlite3_free(p);
			}
			else
			{
				z = null;
			}

			return z;
		}
		public static int sqlite3_str_length(sqlite3_str p)
		{
			return (int)(p ? p.nChar : 0);
		}
		public static sqlite3_str sqlite3_str_new(sqlite3 db)
		{
			sqlite3_str p = sqlite3_malloc64((ulong)(sizeof(sqlite3_str)));
			if ((p) != null)
			{
				sqlite3StrAccumInit(p, null, null, (int)(0), (int)(db ? db.aLimit[0] : 1000000000));
			}
			else
			{
				p = sqlite3OomStr;
			}

			return p;
		}
		public static void sqlite3_str_reset(sqlite3_str p)
		{
			if ((((p).printfFlags & 0x04) != 0))
			{
				sqlite3DbFree(p.db, p.zText);
				p.printfFlags &= (byte)(~0x04);
			}

			p.nAlloc = (uint)(0);
			p.nChar = (uint)(0);
			p.zText = null;
		}
		public static sbyte* sqlite3_str_value(sqlite3_str p)
		{
			if (((p) == (null)) || ((p.nChar) == (0)))
				return null;
			p.zText[p.nChar] = (sbyte)(0);
			return p.zText;
		}
		public static void sqlite3_str_vappendf(sqlite3_str pAccum, sbyte* fmt, sbyte* ap)
		{
		}
		public static int sqlite3_strlike(sbyte* zPattern, sbyte* zStr, uint esc)
		{
			return (int)(patternCompare((byte*)(zPattern), (byte*)(zStr), &likeInfoNorm, (uint)(esc)));
		}
		public static int sqlite3_strnicmp(sbyte* zLeft, sbyte* zRight, int N)
		{
			byte* a; byte* b;
			if ((zLeft) == (null))
			{
				return (int)((zRight) != 0 ? -1 : 0);
			}
			else if ((zRight) == (null))
			{
				return (int)(1);
			}

			a = (byte*)(zLeft);
			b = (byte*)(zRight);
			while ((((N--) > (0)) && (*a != 0)) && ((sqlite3UpperToLower[*a]) == (sqlite3UpperToLower[*b])))
			{
				a++;
				b++;
			}

			return (int)((N) < (0) ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b]);
		}
		public static int sqlite3_system_errno(sqlite3 db)
		{
			return (int)(db ? db.iSysErrno : 0);
		}
		public static int sqlite3_table_column_metadata(sqlite3 db, sbyte* zDbName, sbyte* zTableName, sbyte* zColumnName, sbyte** pzDataType, sbyte** pzCollSeq, int* pNotNull, int* pPrimaryKey, int* pAutoinc)
		{
			int rc = 0;
			sbyte* zErrMsg = null;
			Table pTab = null;
			Column* pCol = null;
			int iCol = (int)(0);
			sbyte* zDataType = null;
			sbyte* zCollSeq = null;
			int notnull = (int)(0);
			int primarykey = (int)(0);
			int autoinc = (int)(0);
			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			rc = (int)(sqlite3Init(db, &zErrMsg));
			if (0 != rc)
			{
				goto error_out;
			}

			pTab = sqlite3FindTable(db, zTableName, zDbName);
			if ((pTab == null) || (((pTab).eTabType) == (2)))
			{
				pTab = null;
				goto error_out;
			}

			if ((zColumnName) == (null))
			{
			}
			else
			{
				for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
				{
					pCol = &pTab.aCol[iCol];
					if ((0) == (sqlite3StrICmp(pCol->zCnName, zColumnName)))
					{
						break;
					}
				}

				if ((iCol) == (pTab.nCol))
				{
					if ((((pTab).tabFlags & 0x00000080) == (0)) && ((sqlite3IsRowid(zColumnName)) != 0))
					{
						iCol = (int)(pTab.iPKey);
						pCol = (iCol) >= (0) ? &pTab.aCol[iCol] : null;
					}
					else
					{
						pTab = null;
						goto error_out;
					}
				}
			}

			if ((pCol) != null)
			{
				zDataType = sqlite3ColumnType(pCol, null);
				zCollSeq = sqlite3ColumnColl(pCol);
				notnull = (int)(pCol->notNull != 0);
				primarykey = (int)((pCol->colFlags & 0x0001) != 0);
				autoinc = (int)(((pTab.iPKey) == (iCol)) && ((pTab.tabFlags & 0x00000008) != 0) ? 1 : 0);
			}
			else
			{
				zDataType = "INTEGER";
				primarykey = (int)(1);
			}

			if (zCollSeq == null)
			{
				zCollSeq = sqlite3StrBINARY;
			}

		error_out:
			; sqlite3BtreeLeaveAll(db);
			if ((pzDataType) != null)
				*pzDataType = zDataType;
			if ((pzCollSeq) != null)
				*pzCollSeq = zCollSeq;
			if ((pNotNull) != null)
				*pNotNull = (int)(notnull);
			if ((pPrimaryKey) != null)
				*pPrimaryKey = (int)(primarykey);
			if ((pAutoinc) != null)
				*pAutoinc = (int)(autoinc);
			if (((0) == (rc)) && (pTab == null))
			{
				sqlite3DbFree(db, zErrMsg);
				zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName, zColumnName);
				rc = (int)(1);
			}

			sqlite3ErrorWithMsg(db, (int)(rc), ((zErrMsg) != 0 ? "%s" : null), zErrMsg);
			sqlite3DbFree(db, zErrMsg);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_test_control(int op)
		{
			int rc = (int)(0);
			sbyte* ap;
			(__va_start(&ap, (int)(op)));
			switch (op)
			{
				case 5:
					{
						sqlite3PrngSaveState();
						break;
					}

				case 6:
					{
						sqlite3PrngRestoreState();
						break;
					}

				case 28:
					{
						int x = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						int y = 0;
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));

						if (((db) != null) && ((y = (int)(db.aDb[0].pSchema.schema_cookie)) != 0))
						{
							x = (int)(y);
						}

						sqlite3Config.iPrngSeed = (uint)(x);
						sqlite3_randomness((int)(0), null);
						break;
					}

				case 8:
					{
						int sz = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						int* aProg = (((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ));
						rc = (int)(sqlite3BitvecBuiltinTest((int)(sz), aProg));
						break;
					}

				case 9:
					{
						sqlite3Config.xTestCallback = ((((sizeof(Int(Int))) > ()) || ((sizeof(Int(Int)) & (sizeof(Int(Int)) - 1)) != 0 ) ) ?
				**(Int(Int))((ap += ) - ) : 
            *(Int(Int))((ap += ) - ) )
            ;
						rc = (int)(sqlite3FaultSim((int)(0)));
						break;
					}

				case 10:
					{
						delegate73 xBenignBegin;
						delegate73 xBenignEnd;
						xBenignBegin = ((((sizeof(Void())) > ()) || ((sizeof(Void()) & (sizeof(Void()) - 1)) != 0 ) ) ?
            **(Void())((ap += ) - ) : 
            *(Void())((ap += ) - ) )
            ;
						xBenignEnd = ((((sizeof(Void())) > ()) || ((sizeof(Void()) & (sizeof(Void()) - 1)) != 0 ) ) ?
            **(Void())((ap += ) - ) : 
            *(Void())((ap += ) - ) )
            ;
						sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
						break;
					}

				case 11:
					{
						rc = (int)(sqlite3PendingByte);
						{
							uint newVal = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
							if ((newVal) != 0)
								sqlite3PendingByte = (int)(newVal);
						}

						break;
					}

				case 12:
					{
						int x = (int)(0);

						rc = (int)(x);
						break;
					}

				case 13:
					{
						int x = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						rc = (int)((x) != 0 ? (x) : 0);
						break;
					}

				case 22:
					{
						rc = (int)(1234 * 100 + 1 * 10 + 0);
						break;
					}

				case 15:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						db.dbOptFlags = (uint)((((sizeof(uint)) > ()) || ((sizeof(uint) & (sizeof(uint) - 1)) != 0)) ? **(uint**)((ap += ) - ) : *(uint*)((ap += ) - ));
						break;
					}

				case 18:
					{
						sqlite3Config.bLocaltimeFault = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						if ((sqlite3Config.bLocaltimeFault) == (2))
						{
							sqlite3Config.xAltLocaltime = ((((sizeof(Int(Void * , Void * ))) > ()) || ((sizeof(Int(Void * , Void * )) & (sizeof(Int(Void * , Void * )) - 1)) != 0 ) ) ?
                **(Int(Void * , Void * ))((ap += ) - ) : 
                *(Int(Void * , Void * ))((ap += ) - ) )
                ;
						}
						else
						{
							sqlite3Config.xAltLocaltime = null;
						}

						break;
					}

				case 17:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						db.mDbFlags ^= (uint)(0x0020);
						break;
					}

				case 20:
					{
						sqlite3Config.neverCorrupt = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 29:
					{
						sqlite3Config.bExtraSchemaChecks = (byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 19:
					{
						sqlite3Config.iOnceResetThreshold = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 21:
					{
						break;
					}

				case 24:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						db.nMaxSorterMmap = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						break;
					}

				case 23:
					{
						if ((sqlite3Config.isInit) == (0))
							rc = (int)(1);
						break;
					}

				case 25:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						int iDb = 0;
						sqlite3_mutex_enter(db.mutex);
						iDb = (int)(sqlite3FindDbName(db, (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ))));
						if ((iDb) >= (0))
						{
							db.init.iDb = (byte)(iDb);
							db.init.busy = (byte)(db.init.imposterTable = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )));
							db.init.newTnum = (uint)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
							if (((db.init.busy) == (0)) && ((db.init.newTnum) > (0)))
							{
								sqlite3ResetAllSchemasOfConnection(db);
							}
						}

						sqlite3_mutex_leave(db.mutex);
						break;
					}

				case 27:
					{
						sqlite3_context pCtx = ((((sizeof(sqlite3_context)) > ()) || ((sizeof(sqlite3_context) & (sizeof(sqlite3_context) - 1)) != 0)) ? (sqlite3_context)((ap += ) - ) : (sqlite3_context)((ap += ) - ));
						sqlite3ResultIntReal(pCtx);
						break;
					}

				case 30:
					{
						sqlite3 db = ((((sizeof(sqlite3)) > ()) || ((sizeof(sqlite3) & (sizeof(sqlite3) - 1)) != 0)) ? (sqlite3)((ap += ) - ) : (sqlite3)((ap += ) - ));
						ulong* pn = ((((sizeof(ulong)) > ()) || ((sizeof(ulong) & (sizeof(ulong) - 1)) != 0)) ? **(ulong***)((ap += ) - ) : *(ulong**)((ap += ) - ));
						*pn = (ulong)(0);
						(void)(db);
						break;
					}

				case 31:
					{
						int opTrace = (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - ));
						uint* ptr = ((((sizeof(uint)) > ()) || ((sizeof(uint) & (sizeof(uint) - 1)) != 0)) ? **(uint***)((ap += ) - ) : *(uint**)((ap += ) - ));
						switch (opTrace)
						{
							case 0:
								*ptr = (uint)(sqlite3SelectTrace);
								break;
							case 1:
								sqlite3SelectTrace = (uint)(*ptr);
								break;
							case 2:
								*ptr = (uint)(sqlite3WhereTrace);
								break;
							case 3:
								sqlite3WhereTrace = (uint)(*ptr);
								break;
						}

						break;
					}

				case 33:
					{
						double rIn = (double)(((() > ()) || ((&(-1)) != 0)) ? **(double**)((ap += ) - ) : *(double*)((ap += ) - ));
						short rLogEst = (short)(sqlite3LogEstFromDouble((double)(rIn)));
						ulong iInt = (ulong)(sqlite3LogEstToInt((short)(rLogEst)));
						(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ))[0] = (int)(rLogEst);
						((((sizeof(ulong)) > ()) || ((sizeof(ulong) & (sizeof(ulong) - 1)) != 0)) ? **(ulong***)((ap += ) - ) : *(ulong**)((ap += ) - ))[0] = (ulong)(iInt);
						(((() > ()) || ((&(-1)) != 0)) ? **(int***)((ap += ) - ) : *(int**)((ap += ) - ))[0] = (int)(sqlite3LogEst((ulong)(iInt)));
						break;
					}
			}

			((void)(ap = null));
			return (int)(rc);
		}
		public static void sqlite3_thread_cleanup()
		{
		}
		public static int sqlite3_threadsafe()
		{
			return (int)(1);
		}
		public static int sqlite3_total_changes(sqlite3 db)
		{
			return (int)(sqlite3_total_changes64(db));
		}
		public static long sqlite3_total_changes64(sqlite3 db)
		{
			return (long)(db.nTotalChange);
		}
		public static void* sqlite3_trace(sqlite3 db, delegate60 xTrace, void* pArg)
		{
			void* pOld;
			sqlite3_mutex_enter(db.mutex);
			pOld = db.pTraceArg;
			db.mTrace = (byte)(xTrace ? 0x40 : 0);
			db.trace.xLegacy = xTrace;
			db.pTraceArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pOld;
		}
		public static int sqlite3_trace_v2(sqlite3 db, uint mTrace, delegate61 xTrace, void* pArg)
		{
			sqlite3_mutex_enter(db.mutex);
			if ((mTrace) == (0))
				xTrace = null;
			if ((xTrace) == (null))
				mTrace = (uint)(0);
			db.mTrace = (byte)(mTrace);
			db.trace.xV2 = xTrace;
			db.pTraceArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return (int)(0);
		}
		public static int sqlite3_transfer_bindings(sqlite3_stmt* pFromStmt, sqlite3_stmt* pToStmt)
		{
			Vdbe pFrom = (Vdbe)(pFromStmt);
			Vdbe pTo = (Vdbe)(pToStmt);
			if (pFrom.nVar != pTo.nVar)
			{
				return (int)(1);
			}


			if ((pTo.expmask) != 0)
			{
				pTo.expired = (uint)(1);
			}


			if ((pFrom.expmask) != 0)
			{
				pFrom.expired = (uint)(1);
			}

			return (int)(sqlite3TransferBindings(pFromStmt, pToStmt));
		}
		public static int sqlite3_txn_state(sqlite3 db, sbyte* zSchema)
		{
			int iDb = 0; int nDb = 0;
			int iTxn = (int)(-1);
			sqlite3_mutex_enter(db.mutex);
			if ((zSchema) != null)
			{
				nDb = (int)(iDb = (int)(sqlite3FindDbName(db, zSchema)));
				if ((iDb) < (0))
					nDb--;
			}
			else
			{
				iDb = (int)(0);
				nDb = (int)(db.nDb - 1);
			}

			for (; (iDb) <= (nDb); iDb++)
			{
				Btree pBt = db.aDb[iDb].pBt;
				int x = (int)(pBt != null ? sqlite3BtreeTxnState(pBt) : 0);
				if ((x) > (iTxn))
					iTxn = (int)(x);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(iTxn);
		}
		public static void* sqlite3_update_hook(sqlite3 db, delegate63 xCallback, void* pArg)
		{
			void* pRet;
			sqlite3_mutex_enter(db.mutex);
			pRet = db.pUpdateArg;
			db.xUpdateCallback = xCallback;
			db.pUpdateArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pRet;
		}
		public static int sqlite3_uri_boolean(sbyte* zFilename, sbyte* zParam, int bDflt)
		{
			sbyte* z = sqlite3_uri_parameter(zFilename, zParam);
			bDflt = (int)(bDflt != 0);
			return (int)((z) != 0 ? sqlite3GetBoolean(z, (byte)(bDflt)) : bDflt);
		}
		public static long sqlite3_uri_int64(sbyte* zFilename, sbyte* zParam, long bDflt)
		{
			sbyte* z = sqlite3_uri_parameter(zFilename, zParam);
			long v = 0;
			if (((z) != null) && ((sqlite3DecOrHexToI64(z, &v)) == (0)))
			{
				bDflt = (long)(v);
			}

			return (long)(bDflt);
		}
		public static sbyte* sqlite3_uri_key(sbyte* zFilename, int N)
		{
			if (((zFilename) == (null)) || ((N) < (0)))
				return null;
			zFilename = databaseName(zFilename);
			zFilename += sqlite3Strlen30(zFilename) + 1;
			while ((((zFilename) != null) && ((zFilename[0]) != 0)) && ((N--) > (0)))
			{
				zFilename += sqlite3Strlen30(zFilename) + 1;
				zFilename += sqlite3Strlen30(zFilename) + 1;
			}

			return (zFilename[0]) != 0 ? zFilename : null;
		}
		public static sbyte* sqlite3_uri_parameter(sbyte* zFilename, sbyte* zParam)
		{
			if (((zFilename) == (null)) || ((zParam) == (null)))
				return null;
			zFilename = databaseName(zFilename);
			return uriParameter(zFilename, zParam);
		}
		public static void* sqlite3_user_data(sqlite3_context p)
		{

			return p.pFunc.pUserData;
		}
		public static void* sqlite3_value_blob(sqlite3_value pVal)
		{
			sqlite3_value p = pVal;
			if ((p.flags & (0x0010 | 0x0002)) != 0)
			{
				if ((((p).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(p) : 0) != 0)
				{

					return null;
				}

				p.flags |= (ushort)(0x0010);
				return (p.n) != 0 ? p.z : null;
			}
			else
			{
				return sqlite3_value_text(pVal);
			}
		}
		public static int sqlite3_value_bytes(sqlite3_value pVal)
		{
			return (int)(sqlite3ValueBytes(pVal, (byte)(1)));
		}
		public static int sqlite3_value_bytes16(sqlite3_value pVal)
		{
			return (int)(sqlite3ValueBytes(pVal, (byte)(2)));
		}
		public static double sqlite3_value_double(sqlite3_value pVal)
		{
			return (double)(sqlite3VdbeRealValue(pVal));
		}
		public static sqlite3_value sqlite3_value_dup(sqlite3_value pOrig)
		{
			sqlite3_value pNew;
			if ((pOrig) == (null))
				return null;
			pNew = sqlite3_malloc((int)(sizeof(sqlite3_value)));
			if ((pNew) == (null))
				return null;
			CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(sqlite3_value)));
			CRuntime.memcpy(pNew, pOrig, ((ulong)(&((0).zMalloc))));
			pNew.flags &= (ushort)(~0x0400);
			pNew.db = null;
			if ((pNew.flags & (0x0002 | 0x0010)) != 0)
			{
				pNew.flags &= (ushort)(~(0x0800 | 0x0400));
				pNew.flags |= (ushort)(0x1000);
				if (sqlite3VdbeMemMakeWriteable(pNew) != 0)
				{
					sqlite3ValueFree(pNew);
					pNew = null;
				}
			}

			return pNew;
		}
		public static void sqlite3_value_free(sqlite3_value pOld)
		{
			sqlite3ValueFree(pOld);
		}
		public static int sqlite3_value_frombind(sqlite3_value pVal)
		{
			return (int)((pVal.flags & 0x0040) != 0);
		}
		public static int sqlite3_value_int(sqlite3_value pVal)
		{
			return (int)(sqlite3VdbeIntValue(pVal));
		}
		public static long sqlite3_value_int64(sqlite3_value pVal)
		{
			return (long)(sqlite3VdbeIntValue(pVal));
		}
		public static int sqlite3_value_nochange(sqlite3_value pVal)
		{
			return ((pVal.flags & (0x0001 | 0x4000)) == (0x0001 | 0x4000) ? 1 : 0);
		}
		public static int sqlite3_value_numeric_type(sqlite3_value pVal)
		{
			int eType = (int)(sqlite3_value_type(pVal));
			if ((eType) == (3))
			{
				sqlite3_value pMem = pVal;
				applyNumericAffinity(pMem, (int)(0));
				eType = (int)(sqlite3_value_type(pVal));
			}

			return (int)(eType);
		}
		public static void* sqlite3_value_pointer(sqlite3_value pVal, sbyte* zPType)
		{
			sqlite3_value p = pVal;
			if (((((p.flags & (0xc1bf | 0x0200 | 0x8000)) == (0x0001 | 0x0200 | 0x8000)) && (zPType != null)) && ((p.eSubtype) == (112))) && ((CRuntime.strcmp(p.u.zPType, zPType)) == (0)))
			{
				return (void*)(p.z);
			}
			else
			{
				return null;
			}
		}
		public static uint sqlite3_value_subtype(sqlite3_value pVal)
		{
			sqlite3_value pMem = pVal;
			return (uint)((pMem.flags & 0x8000) ? pMem.eSubtype : 0);
		}
		public static byte* sqlite3_value_text(sqlite3_value pVal)
		{
			return (byte*)(sqlite3ValueText(pVal, (byte)(1)));
		}
		public static void* sqlite3_value_text16(sqlite3_value pVal)
		{
			return sqlite3ValueText(pVal, (byte)(2));
		}
		public static void* sqlite3_value_text16be(sqlite3_value pVal)
		{
			return sqlite3ValueText(pVal, (byte)(3));
		}
		public static void* sqlite3_value_text16le(sqlite3_value pVal)
		{
			return sqlite3ValueText(pVal, (byte)(2));
		}
		public static int sqlite3_value_type(sqlite3_value pVal)
		{
			return (int)(sqlite3_value_type_aType[pVal.flags & 0x003f]);
		}
		public static sqlite3_vfs sqlite3_vfs_find(sbyte* zVfs)
		{
			sqlite3_vfs pVfs = null;
			sqlite3_mutex* mutex;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return null;
			mutex = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(mutex);
			for (pVfs = vfsList; pVfs; pVfs = pVfs.pNext)
			{
				if ((zVfs) == (null))
					break;
				if ((CRuntime.strcmp(zVfs, pVfs.zName)) == (0))
					break;
			}

			sqlite3_mutex_leave(mutex);
			return pVfs;
		}
		public static int sqlite3_vfs_register(sqlite3_vfs pVfs, int makeDflt)
		{
			sqlite3_mutex* mutex;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			mutex = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(mutex);
			vfsUnlink(pVfs);
			if (((makeDflt) != 0) || ((vfsList) == (null)))
			{
				pVfs.pNext = vfsList;
				vfsList = pVfs;
			}
			else
			{
				pVfs.pNext = vfsList.pNext;
				vfsList.pNext = pVfs;
			}


			sqlite3_mutex_leave(mutex);
			return (int)(0);
		}
		public static int sqlite3_vfs_unregister(sqlite3_vfs pVfs)
		{
			sqlite3_mutex* mutex;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			mutex = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(mutex);
			vfsUnlink(pVfs);
			sqlite3_mutex_leave(mutex);
			return (int)(0);
		}
		public static sbyte* sqlite3_vmprintf(sbyte* zFormat, sbyte* ap)
		{
			sbyte* z;
			sbyte* zBase = stackalloc sbyte[70];
			sqlite3_str acc = new sqlite3_str();
			if ((sqlite3_initialize()) != 0)
				return null;
			sqlite3StrAccumInit(acc, null, zBase, (int)(70 * sizeof(sbyte)), (int)(1000000000));
			sqlite3_str_vappendf(acc, zFormat, ap);
			z = sqlite3StrAccumFinish(acc);
			return z;
		}
		public static sbyte* sqlite3_vsnprintf(int n, sbyte* zBuf, sbyte* zFormat, sbyte* ap)
		{
			sqlite3_str acc = new sqlite3_str();
			if ((n) <= (0))
				return zBuf;
			sqlite3StrAccumInit(acc, null, zBuf, (int)(n), (int)(0));
			sqlite3_str_vappendf(acc, zFormat, ap);
			zBuf[acc.nChar] = (sbyte)(0);
			return zBuf;
		}
		public static sbyte* sqlite3_vtab_collation(sqlite3_index_info* pIdxInfo, int iCons)
		{
			HiddenIndexInfo pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			sbyte* zRet = null;
			if (((iCons) >= (0)) && ((iCons) < (pIdxInfo->nConstraint)))
			{
				CollSeq pC = null;
				int iTerm = (int)(pIdxInfo->aConstraint[iCons].iTermOffset);
				Expr pX = pHidden.pWC.a[iTerm].pExpr;
				if ((pX.pLeft) != null)
				{
					pC = sqlite3ExprCompareCollSeq(pHidden.pParse, pX);
				}

				zRet = (pC ? pC.zName : sqlite3StrBINARY);
			}

			return zRet;
		}
		public static int sqlite3_vtab_config(sqlite3 db, int op)
		{
			sbyte* ap;
			int rc = (int)(0);
			VtabCtx p;
			sqlite3_mutex_enter(db.mutex);
			p = db.pVtabCtx;
			if (p == null)
			{
				rc = (int)(sqlite3MisuseError((int)(146785)));
			}
			else
			{

				(__va_start(&ap, (int)(op)));
				switch (op)
				{
					case 1:
						{
							p.pVTable.bConstraint = ((byte)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )));
							break;
						}

					case 2:
						{
							p.pVTable.eVtabRisk = (byte)(0);
							break;
						}

					case 3:
						{
							p.pVTable.eVtabRisk = (byte)(2);
							break;
						}

					default:
						{
							rc = (int)(sqlite3MisuseError((int)(146803)));
							break;
						}
				}

				((void)(ap = null));
			}

			if (rc != 0)
				sqlite3Error(db, (int)(rc));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static int sqlite3_vtab_distinct(sqlite3_index_info* pIdxInfo)
		{
			HiddenIndexInfo pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);

			return (int)(pHidden.eDistinct);
		}
		public static int sqlite3_vtab_in(sqlite3_index_info* pIdxInfo, int iCons, int bHandle)
		{
			HiddenIndexInfo pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			uint m = (uint)((iCons) <= (31) ? ((uint)(1)) << (iCons) : 0);
			if ((m & pHidden.mIn) != 0)
			{
				if ((bHandle) == (0))
				{
					pHidden.mHandleIn &= (uint)(~m);
				}
				else if ((bHandle) > (0))
				{
					pHidden.mHandleIn |= (uint)(m);
				}

				return (int)(1);
			}

			return (int)(0);
		}
		public static int sqlite3_vtab_in_first(sqlite3_value pVal, sqlite3_value ppOut)
		{
			return (int)(valueFromValueList(pVal, ppOut, (int)(0)));
		}
		public static int sqlite3_vtab_in_next(sqlite3_value pVal, sqlite3_value ppOut)
		{
			return (int)(valueFromValueList(pVal, ppOut, (int)(1)));
		}
		public static int sqlite3_vtab_nochange(sqlite3_context p)
		{

			return (int)(sqlite3_value_nochange(p.pOut));
		}
		public static int sqlite3_vtab_on_conflict(sqlite3 db)
		{



			return (int)(sqlite3_vtab_on_conflict_aMap[db.vtabOnConflict - 1]);
		}
		public static int sqlite3_vtab_rhs_value(sqlite3_index_info* pIdxInfo, int iCons, sqlite3_value ppVal)
		{
			HiddenIndexInfo pH = (HiddenIndexInfo)(&pIdxInfo[1]);
			sqlite3_value pVal = null;
			int rc = (int)(0);
			if (((iCons) < (0)) || ((iCons) >= (pIdxInfo->nConstraint)))
			{
				rc = (int)(21);
			}
			else
			{
				if ((pH.aRhs[iCons]) == (null))
				{
					WhereTerm pTerm = pH.pWC.a[pIdxInfo->aConstraint[iCons].iTermOffset];
					rc = (int)(sqlite3ValueFromExpr(pH.pParse.db, pTerm.pExpr.pRight, (byte)((pH.pParse.db).enc), (byte)(0x41), pH.aRhs[iCons]));
				}

				pVal = pH.aRhs[iCons];
			}

			ppVal = pVal;
			if (((rc) == (0)) && ((pVal) == (null)))
			{
				rc = (int)(12);
			}

			return (int)(rc);
		}
		public static int sqlite3_wal_autocheckpoint(sqlite3 db, int nFrame)
		{
			if ((nFrame) > (0))
			{
				sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void*)((long)(nFrame))));
			}
			else
			{
				sqlite3_wal_hook(db, null, null);
			}

			return (int)(0);
		}
		public static int sqlite3_wal_checkpoint(sqlite3 db, sbyte* zDb)
		{
			return (int)(sqlite3_wal_checkpoint_v2(db, zDb, (int)(0), null, null));
		}
		public static int sqlite3_wal_checkpoint_v2(sqlite3 db, sbyte* zDb, int eMode, int* pnLog, int* pnCkpt)
		{
			int rc = 0;
			int iDb = 0;
			if ((pnLog) != null)
				*pnLog = (int)(-1);
			if ((pnCkpt) != null)
				*pnCkpt = (int)(-1);




			if (((eMode) < (0)) || ((eMode) > (3)))
			{
				return (int)(21);
			}

			sqlite3_mutex_enter(db.mutex);
			if (((zDb) != null) && ((zDb[0]) != 0))
			{
				iDb = (int)(sqlite3FindDbName(db, zDb));
			}
			else
			{
				iDb = (int)(10 + 2);
			}

			if ((iDb) < (0))
			{
				rc = (int)(1);
				sqlite3ErrorWithMsg(db, (int)(1), "unknown database: %s", zDb);
			}
			else
			{
				db.busyHandler.nBusy = (int)(0);
				rc = (int)(sqlite3Checkpoint(db, (int)(iDb), (int)(eMode), pnLog, pnCkpt));
				sqlite3Error(db, (int)(rc));
			}

			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			if ((db.nVdbeActive) == (0))
			{
				(0);
			}

			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static void* sqlite3_wal_hook(sqlite3 db, delegate54 xCallback, void* pArg)
		{
			void* pRet;
			sqlite3_mutex_enter(db.mutex);
			pRet = db.pWalArg;
			db.xWalCallback = xCallback;
			db.pWalArg = pArg;
			sqlite3_mutex_leave(db.mutex);
			return pRet;
		}
		public static int sqlite3_win32_is_nt()
		{
			return (int)(1);
		}
		public static sbyte* sqlite3_win32_mbcs_to_utf8(sbyte* zText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winMbcsToUtf8(zText, (int)((Int())(aSyscall[0].pCurrent)()));
		}
		public static sbyte* sqlite3_win32_mbcs_to_utf8_v2(sbyte* zText, int useAnsi)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winMbcsToUtf8(zText, (int)(useAnsi));
		}
		public static int sqlite3_win32_set_directory(uint type, void* zValue)
		{
			return (int)(sqlite3_win32_set_directory16((uint)(type), zValue));
		}
		public static int sqlite3_win32_set_directory16(uint type, void* zValue)
		{
			int rc = 0;
			sbyte* zUtf8 = null;
			if ((zValue) != null)
			{
				zUtf8 = sqlite3_win32_unicode_to_utf8(zValue);
				if ((zUtf8) == (null))
					return (int)(7);
			}

			rc = (int)(sqlite3_win32_set_directory8((uint)(type), zUtf8));
			if ((zUtf8) != null)
				sqlite3_free(zUtf8);
			return (int)(rc);
		}
		public static int sqlite3_win32_set_directory8(uint type, sbyte* zValue)
		{
			sbyte** ppDirectory = null;
			int rc = (int)(sqlite3_initialize());
			if ((rc) != 0)
				return (int)(rc);
			if ((type) == (1))
			{
				ppDirectory = &sqlite3_data_directory;
			}
			else if ((type) == (2))
			{
				ppDirectory = &sqlite3_temp_directory;
			}



			if ((ppDirectory) != null)
			{
				sbyte* zCopy = null;
				if (((zValue) != null) && ((zValue[0]) != 0))
				{
					zCopy = sqlite3_mprintf("%s", zValue);
					if ((zCopy) == (null))
					{
						return (int)(7);
					}
				}

				sqlite3_free(*ppDirectory);
				*ppDirectory = zCopy;
				return (int)(0);
			}

			return (int)(1);
		}
		public static void sqlite3_win32_sleep(uint milliseconds)
		{
			(Void(Uint))(aSyscall[55].pCurrent)((uint)(milliseconds));
		}
		public static sbyte* sqlite3_win32_unicode_to_utf8(ushort* zWideText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUnicodeToUtf8(zWideText);
		}
		public static sbyte* sqlite3_win32_utf8_to_mbcs(sbyte* zText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUtf8ToMbcs(zText, (int)((Int())(aSyscall[0].pCurrent)()));
		}
		public static sbyte* sqlite3_win32_utf8_to_mbcs_v2(sbyte* zText, int useAnsi)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUtf8ToMbcs(zText, (int)(useAnsi));
		}
		public static ushort* sqlite3_win32_utf8_to_unicode(sbyte* zText)
		{
			if ((sqlite3_initialize()) != 0)
				return null;
			return winUtf8ToUnicode(zText);
		}
		public static void sqlite3_win32_write_debug(sbyte* zBuf, int nBuf)
		{
			sbyte* zDbgBuf = stackalloc sbyte[4092];
			int nMin = (int)((nBuf) < (((int)(4096 - sizeof(uint))) - 1) ? (nBuf) : (((int)(4096 - sizeof(uint))) - 1));
			if ((nMin) < (-1))
				nMin = (int)(-1);

			if ((nMin) > (0))
			{
				CRuntime.memset(zDbgBuf, (int)(0), (ulong)((int)(4096 - sizeof(uint))));
				CRuntime.memcpy(zDbgBuf, zBuf, (ulong)(nMin));
				(Void(Sbyte * ))(aSyscall[72].pCurrent)(zDbgBuf);
			}
			else
			{
				(Void(Sbyte * ))(aSyscall[72].pCurrent)(zBuf);
			}
		}
		public static int sqlite3AbsInt32(int x)
		{
			if ((x) >= (0))
				return (int)(x);
			if ((x) == ((int)(0x80000000)))
				return (int)(0x7fffffff);
			return (int)(-x);
		}
		public static void sqlite3AddCheckConstraint(Parse pParse, Expr pCheckExpr, sbyte* zStart, sbyte* zEnd)
		{
			Table pTab = pParse.pNewTable;
			sqlite3 db = pParse.db;
			if ((((pTab) != null) && (!((pParse.eParseMode) == (1)))) && (sqlite3BtreeIsReadonly(db.aDb[db.init.iDb].pBt) == 0))
			{
				pTab.pCheck = sqlite3ExprListAppend(pParse, pTab.pCheck, pCheckExpr);
				if ((pParse.constraintName.n) != 0)
				{
					sqlite3ExprListSetName(pParse, pTab.pCheck, &pParse.constraintName, (int)(1));
				}
				else
				{
					Token t = new Token();
					for (zStart++; (sqlite3CtypeMap[(byte)(zStart[0])] & 0x01); zStart++)
					{
					}

					while ((sqlite3CtypeMap[(byte)(zEnd[-1])] & 0x01) != 0)
					{
						zEnd--;
					}

					t.z = zStart;
					t.n = (uint)((int)(zEnd - t.z));
					sqlite3ExprListSetName(pParse, pTab.pCheck, &t, (int)(1));
				}
			}
			else
			{
				sqlite3ExprDelete(pParse.db, pCheckExpr);
			}
		}
		public static void sqlite3AddCollateType(Parse pParse, Token* pToken)
		{
			Table p;
			int i = 0;
			sbyte* zColl;
			sqlite3 db;
			if (((p = pParse.pNewTable) == (null)) || ((pParse.eParseMode) >= (2)))
				return;
			i = (int)(p.nCol - 1);
			db = pParse.db;
			zColl = sqlite3NameFromToken(db, pToken);
			if (zColl == null)
				return;
			if ((sqlite3LocateCollSeq(pParse, zColl)) != null)
			{
				Index pIdx;
				sqlite3ColumnSetColl(db, &p.aCol[i], zColl);
				for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
				{

					if ((pIdx.aiColumn[0]) == (i))
					{
						pIdx.azColl[0] = sqlite3ColumnColl(&p.aCol[i]);
					}
				}
			}

			sqlite3DbFree(db, zColl);
		}
		public static void sqlite3AddColumn(Parse pParse, Token sName, Token sType)
		{
			Table p;
			int i = 0;
			sbyte* z;
			sbyte* zType;
			Column* pCol;
			sqlite3 db = pParse.db;
			byte hName = 0;
			Column* aNew;
			byte eType = (byte)(0);
			byte szEst = (byte)(1);
			sbyte affinity = (sbyte)(0x41);
			if ((p = pParse.pNewTable) == (null))
				return;
			if ((p.nCol + 1) > (db.aLimit[2]))
			{
				sqlite3ErrorMsg(pParse, "too many columns on %s", p.zName);
				return;
			}

			if (!((pParse.eParseMode) >= (2)))
				sqlite3DequoteToken(&sName);
			if (((sType.n) >= (16)) && ((sqlite3_strnicmp(sType.z + (sType.n - 6), "always", (int)(6))) == (0)))
			{
				sType.n -= (uint)(6);
				while (((sType.n) > (0)) && ((sqlite3CtypeMap[(byte)(sType.z[sType.n - 1])] & 0x01) != 0))
				{
					sType.n--;
				}

				if (((sType.n) >= (9)) && ((sqlite3_strnicmp(sType.z + (sType.n - 9), "generated", (int)(9))) == (0)))
				{
					sType.n -= (uint)(9);
					while (((sType.n) > (0)) && ((sqlite3CtypeMap[(byte)(sType.z[sType.n - 1])] & 0x01) != 0))
					{
						sType.n--;
					}
				}
			}

			if ((sType.n) >= (3))
			{
				sqlite3DequoteToken(&sType);
				for (i = (int)(0); (i) < (6); i++)
				{
					if (((sType.n) == (sqlite3StdTypeLen[i])) && ((sqlite3_strnicmp(sType.z, sqlite3StdType[i], (int)(sType.n))) == (0)))
					{
						sType.n = (uint)(0);
						eType = (byte)(i + 1);
						affinity = (sbyte)(sqlite3StdTypeAffinity[i]);
						if ((affinity) <= (0x42))
							szEst = (byte)(5);
						break;
					}
				}
			}

			z = sqlite3DbMallocRaw(db, (ulong)((long)(sName.n) + 1 + (long)(sType.n) + ((sType.n) > (0))));
			if ((z) == (null))
				return;
			if (((pParse.eParseMode) >= (2)))
				sqlite3RenameTokenMap(pParse, (void*)(z), &sName);
			CRuntime.memcpy(z, sName.z, (ulong)(sName.n));
			z[sName.n] = (sbyte)(0);
			sqlite3Dequote(z);
			hName = (byte)(sqlite3StrIHash(z));
			for (i = (int)(0); (i) < (p.nCol); i++)
			{
				if (((p.aCol[i].hName) == (hName)) && ((sqlite3StrICmp(z, p.aCol[i].zCnName)) == (0)))
				{
					sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
					sqlite3DbFree(db, z);
					return;
				}
			}

			aNew = sqlite3DbRealloc(db, p.aCol, (ulong)(((long)(p.nCol) + 1) * sizeof(Column)));
			if ((aNew) == (null))
			{
				sqlite3DbFree(db, z);
				return;
			}

			p.aCol = aNew;
			pCol = &p.aCol[p.nCol];
			CRuntime.memset(pCol, (int)(0), (ulong)(sizeof(Column)));
			pCol->zCnName = z;
			pCol->hName = (byte)(hName);
			if ((sType.n) == (0))
			{
				pCol->affinity = (sbyte)(affinity);
				pCol->eCType = (uint)(eType);
				pCol->szEst = (byte)(szEst);
			}
			else
			{
				zType = z + sqlite3Strlen30(z) + 1;
				CRuntime.memcpy(zType, sType.z, (ulong)(sType.n));
				zType[sType.n] = (sbyte)(0);
				sqlite3Dequote(zType);
				pCol->affinity = (sbyte)(sqlite3AffinityType(zType, pCol));
				pCol->colFlags |= (ushort)(0x0004);
			}

			p.nCol++;
			p.nNVCol++;
			pParse.constraintName.n = (uint)(0);
		}
		public static void sqlite3AddDefaultValue(Parse pParse, Expr pExpr, sbyte* zStart, sbyte* zEnd)
		{
			Table p;
			Column* pCol;
			sqlite3 db = pParse.db;
			p = pParse.pNewTable;
			if (p != null)
			{
				int isInit = (int)(((db.init.busy) != 0) && (db.init.iDb != 1) ? 1 : 0);
				pCol = &(p.aCol[p.nCol - 1]);
				if (sqlite3ExprIsConstantOrFunction(pExpr, (byte)(isInit)) == 0)
				{
					sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", pCol->zCnName);
				}
				else if ((pCol->colFlags & 0x0060) != 0)
				{
					sqlite3ErrorMsg(pParse, "cannot use DEFAULT on a generated column");
				}
				else
				{
					Expr x = new Expr();
					Expr pDfltExpr;
					CRuntime.memset(x, (int)(0), (ulong)(sizeof(Expr)));
					x.op = (byte)(181);
					x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
					x.pLeft = pExpr;
					x.flags = (uint)(0x001000);
					pDfltExpr = sqlite3ExprDup(db, x, (int)(0x0001));
					sqlite3DbFree(db, x.u.zToken);
					sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr);
				}
			}

			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameExprUnmap(pParse, pExpr);
			}

			sqlite3ExprDelete(db, pExpr);
		}
		public static void sqlite3AddGenerated(Parse pParse, Expr pExpr, Token* pType)
		{
			byte eType = (byte)(0x0020);
			Table pTab = pParse.pNewTable;
			Column* pCol;
			if ((pTab) == (null))
			{
				goto generated_done;
			}

			pCol = &(pTab.aCol[pTab.nCol - 1]);
			if (((pParse.eParseMode) == (1)))
			{
				sqlite3ErrorMsg(pParse, "virtual tables cannot use computed columns");
				goto generated_done;
			}

			if ((pCol->iDflt) > (0))
				goto generated_error;
			if ((pType) != null)
			{
				if (((pType->n) == (7)) && ((sqlite3_strnicmp("virtual", pType->z, (int)(7))) == (0)))
				{
				}
				else if (((pType->n) == (6)) && ((sqlite3_strnicmp("stored", pType->z, (int)(6))) == (0)))
				{
					eType = (byte)(0x0040);
				}
				else
				{
					goto generated_error;
				}
			}

			if ((eType) == (0x0020))
				pTab.nNVCol--;
			pCol->colFlags |= (ushort)(eType);


			pTab.tabFlags |= (uint)(eType);
			if ((pCol->colFlags & 0x0001) != 0)
			{
				makeColumnPartOfPrimaryKey(pParse, pCol);
			}

			sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);
			pExpr = null;
			goto generated_done;
		generated_error:
			; sqlite3ErrorMsg(pParse, "error in generated column \"%s\"", pCol->zCnName);
		generated_done:
			; sqlite3ExprDelete(pParse.db, pExpr);
		}
		public static int sqlite3AddInt64(long* pA, long iB)
		{
			long iA = (long)(*pA);
			if ((iB) >= (0))
			{
				if (((iA) > (0)) && (((0xffffffff | (((long)(0x7fffffff)) << 32)) - iA) < (iB)))
					return (int)(1);
			}
			else
			{
				if (((iA) < (0)) && ((-(iA + (0xffffffff | (((long)(0x7fffffff)) << 32)))) > (iB + 1)))
					return (int)(1);
			}

			*pA += (long)(iB);
			return (int)(0);
		}
		public static void sqlite3AddNotNull(Parse pParse, int onError)
		{
			Table p;
			Column* pCol;
			p = pParse.pNewTable;
			if (((p) == (null)) || ((p.nCol) < (1)))
				return;
			pCol = &p.aCol[p.nCol - 1];
			pCol->notNull = (uint)((byte)(onError));
			p.tabFlags |= (uint)(0x00000800);
			if ((pCol->colFlags & 0x0008) != 0)
			{
				Index pIdx;
				for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
				{

					if ((pIdx.aiColumn[0]) == (p.nCol - 1))
					{
						pIdx.uniqNotNull = (uint)(1);
					}
				}
			}
		}
		public static void sqlite3AddPrimaryKey(Parse pParse, ExprList pList, int onError, int autoInc, int sortOrder)
		{
			Table pTab = pParse.pNewTable;
			Column* pCol = null;
			int iCol = (int)(-1); int i = 0;
			int nTerm = 0;
			if ((pTab) == (null))
				goto primary_key_exit;
			if ((pTab.tabFlags & 0x00000004) != 0)
			{
				sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", pTab.zName);
				goto primary_key_exit;
			}

			pTab.tabFlags |= (uint)(0x00000004);
			if ((pList) == (null))
			{
				iCol = (int)(pTab.nCol - 1);
				pCol = &pTab.aCol[iCol];
				makeColumnPartOfPrimaryKey(pParse, pCol);
				nTerm = (int)(1);
			}
			else
			{
				nTerm = (int)(pList.nExpr);
				for (i = (int)(0); (i) < (nTerm); i++)
				{
					Expr pCExpr = sqlite3ExprSkipCollate(pList.a[i].pExpr);

					sqlite3StringToId(pCExpr);
					if ((pCExpr.op) == (59))
					{
						sbyte* zCName;

						zCName = pCExpr.u.zToken;
						for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
						{
							if ((sqlite3StrICmp(zCName, pTab.aCol[iCol].zCnName)) == (0))
							{
								pCol = &pTab.aCol[iCol];
								makeColumnPartOfPrimaryKey(pParse, pCol);
								break;
							}
						}
					}
				}
			}

			if (((((nTerm) == (1)) && ((pCol) != null)) && ((pCol->eCType) == (4))) && (sortOrder != 1))
			{
				if (((pParse.eParseMode) >= (2)) && ((pList) != null))
				{
					Expr pCExpr = sqlite3ExprSkipCollate(pList.a[0].pExpr);
					sqlite3RenameTokenRemap(pParse, &pTab.iPKey, pCExpr);
				}

				pTab.iPKey = (short)(iCol);
				pTab.keyConf = ((byte)(onError));

				pTab.tabFlags |= (uint)(autoInc * 0x00000008);
				if ((pList) != null)
					pParse.iPkSortOrder = (byte)(pList.a[0].sortFlags);
				(void)(sqlite3HasExplicitNulls(pParse, pList));
			}
			else if ((autoInc) != 0)
			{
				sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY");
			}
			else
			{
				sqlite3CreateIndex(pParse, null, null, null, pList, (int)(onError), null, null, (int)(sortOrder), (int)(0), (byte)(2));
				pList = null;
			}

		primary_key_exit:
			; sqlite3ExprListDelete(pParse.db, pList);
			return;
		}
		public static void sqlite3AddReturning(Parse pParse, ExprList pList)
		{
			Returning pRet;
			Hash* pHash;
			sqlite3 db = pParse.db;
			if ((pParse.pNewTrigger) != null)
			{
				sqlite3ErrorMsg(pParse, "cannot use RETURNING in a trigger");
			}
			else
			{

			}

			pParse.bReturning = (byte)(1);
			pRet = sqlite3DbMallocZero(db, (ulong)(sizeof(Returning)));
			if ((pRet) == (null))
			{
				sqlite3ExprListDelete(db, pList);
				return;
			}

			pParse.u1.pReturning = pRet;
			pRet.pParse = pParse;
			pRet.pReturnEL = pList;
			sqlite3ParserAddCleanup(pParse, sqlite3DeleteReturning, pRet);
			if ((db.mallocFailed) != 0)
				return;
			pRet.retTrig.zName = "sqlite_returning";
			pRet.retTrig.op = (byte)(150);
			pRet.retTrig.tr_tm = (byte)(2);
			pRet.retTrig.bReturning = (byte)(1);
			pRet.retTrig.pSchema = db.aDb[1].pSchema;
			pRet.retTrig.pTabSchema = db.aDb[1].pSchema;
			pRet.retTrig.step_list = pRet.retTStep;
			pRet.retTStep.op = (byte)(150);
			pRet.retTStep.pTrig = pRet.retTrig;
			pRet.retTStep.pExprList = pList;
			pHash = &(db.aDb[1].pSchema.trigHash);

			if ((sqlite3HashInsert(pHash, "sqlite_returning", pRet.retTrig)) == (pRet.retTrig))
			{
				sqlite3OomFault(db);
			}
		}
		public static sbyte sqlite3AffinityType(sbyte* zIn, Column* pCol)
		{
			uint h = (uint)(0);
			sbyte aff = (sbyte)(0x43);
			sbyte* zChar = null;

			while ((zIn[0]) != 0)
			{
				h = (uint)((h << 8) + sqlite3UpperToLower[(*zIn) & 0xff]);
				zIn++;
				if ((h) == ((99 << 24) + (104 << 16) + (97 << 8) + 114))
				{
					aff = (sbyte)(0x42);
					zChar = zIn;
				}
				else if ((h) == ((99 << 24) + (108 << 16) + (111 << 8) + 98))
				{
					aff = (sbyte)(0x42);
				}
				else if ((h) == ((116 << 24) + (101 << 16) + (120 << 8) + 116))
				{
					aff = (sbyte)(0x42);
				}
				else if (((h) == ((98 << 24) + (108 << 16) + (111 << 8) + 98)) && (((aff) == (0x43)) || ((aff) == (0x45))))
				{
					aff = (sbyte)(0x41);
					if ((zIn[0]) == (40))
						zChar = zIn;
				}
				else if (((h) == ((114 << 24) + (101 << 16) + (97 << 8) + 108)) && ((aff) == (0x43)))
				{
					aff = (sbyte)(0x45);
				}
				else if (((h) == ((102 << 24) + (108 << 16) + (111 << 8) + 97)) && ((aff) == (0x43)))
				{
					aff = (sbyte)(0x45);
				}
				else if (((h) == ((100 << 24) + (111 << 16) + (117 << 8) + 98)) && ((aff) == (0x43)))
				{
					aff = (sbyte)(0x45);
				}
				else if ((h & 0x00FFFFFF) == ((105 << 16) + (110 << 8) + 116))
				{
					aff = (sbyte)(0x44);
					break;
				}
			}

			if ((pCol) != null)
			{
				int v = (int)(0);
				if ((aff) < (0x43))
				{
					if ((zChar) != null)
					{
						while ((zChar[0]) != 0)
						{
							if ((sqlite3CtypeMap[(byte)(zChar[0])] & 0x04) != 0)
							{
								sqlite3GetInt32(zChar, &v);
								break;
							}

							zChar++;
						}
					}
					else
					{
						v = (int)(16);
					}
				}

				v = (int)(v / 4 + 1);
				if ((v) > (255))
					v = (int)(255);
				pCol->szEst = (byte)(v);
			}

			return (sbyte)(aff);
		}
		public static void sqlite3AggInfoPersistWalkerInit(Walker pWalker, Parse pParse)
		{
			CRuntime.memset(pWalker, (int)(0), (ulong)(sizeof(Walker)));
			pWalker.pParse = pParse;
			pWalker.xExprCallback = agginfoPersistExprCb;
			pWalker.xSelectCallback = sqlite3SelectWalkNoop;
		}
		public static Index sqlite3AllocateIndexObject(sqlite3 db, short nCol, int nExtra, sbyte** ppExtra)
		{
			Index p;
			int nByte = 0;
			nByte = (int)((((sizeof(Index)) + 7) & ~7) + (((sizeof(char*) * nCol) + 7) & ~7) + (((sizeof(short) * (nCol + 1) + sizeof(short) * nCol + sizeof(byte) * nCol) + 7) & ~7));
			p = sqlite3DbMallocZero(db, (ulong)(nByte + nExtra));
			if ((p) != null)
			{
				sbyte* pExtra = ((sbyte*)(p)) + (((sizeof(Index)) + 7) & ~7);
				p.azColl = (sbyte**)(pExtra);
				pExtra += (((sizeof(char*) * nCol) + 7) & ~7);
				p.aiRowLogEst = (short*)(pExtra);
				pExtra += sizeof(short) * (nCol + 1);
				p.aiColumn = (short*)(pExtra);
				pExtra += sizeof(short) * nCol;
				p.aSortOrder = (byte*)(pExtra);
				p.nColumn = (ushort)(nCol);
				p.nKeyCol = (ushort)(nCol - 1);
				*ppExtra = ((sbyte*)(p)) + nByte;
			}

			return p;
		}
		public static void sqlite3AlterBeginAddColumn(Parse pParse, SrcList pSrc)
		{
			Table pNew;
			Table pTab;
			int iDb = 0;
			int i = 0;
			int nAlloc = 0;
			sqlite3 db = pParse.db;


			if ((db.mallocFailed) != 0)
				goto exit_begin_add_column;
			pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
			if (pTab == null)
				goto exit_begin_add_column;
			if ((((pTab).eTabType) == (1)))
			{
				sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
				goto exit_begin_add_column;
			}

			if ((((pTab).eTabType) == (2)))
			{
				sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
				goto exit_begin_add_column;
			}

			if (0 != isAlterableTable(pParse, pTab))
			{
				goto exit_begin_add_column;
			}

			sqlite3MayAbort(pParse);


			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			pNew = (Table)(sqlite3DbMallocZero(db, (ulong)(sizeof(Table))));
			if (pNew == null)
				goto exit_begin_add_column;
			pParse.pNewTable = pNew;
			pNew.nTabRef = (uint)(1);
			pNew.nCol = (short)(pTab.nCol);

			nAlloc = (int)((((pNew.nCol - 1) / 8) * 8) + 8);

			pNew.aCol = (Column*)(sqlite3DbMallocZero(db, (ulong)(sizeof(Column) * nAlloc)));
			pNew.zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab.zName);
			if ((pNew.aCol == null) || (pNew.zName == null))
			{

				goto exit_begin_add_column;
			}

			CRuntime.memcpy(pNew.aCol, pTab.aCol, (ulong)(sizeof(Column) * pNew.nCol));
			for (i = (int)(0); (i) < (pNew.nCol); i++)
			{
				Column* pCol = &pNew.aCol[i];
				pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);
				pCol->hName = (byte)(sqlite3StrIHash(pCol->zCnName));
			}


			pNew.u.tab.pDfltList = sqlite3ExprListDup(db, pTab.u.tab.pDfltList, (int)(0));
			pNew.pSchema = db.aDb[iDb].pSchema;
			pNew.u.tab.addColOffset = (int)(pTab.u.tab.addColOffset);
			pNew.nTabRef = (uint)(1);
		exit_begin_add_column:
			; sqlite3SrcListDelete(db, pSrc);
			return;
		}
		public static void sqlite3AlterDropColumn(Parse pParse, SrcList pSrc, Token* pName)
		{
			sqlite3 db = pParse.db;
			Table pTab;
			int iDb = 0;
			sbyte* zDb;
			sbyte* zCol = null;
			int iCol = 0;


			if ((db.mallocFailed) != 0)
				goto exit_drop_column;
			pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
			if (pTab == null)
				goto exit_drop_column;
			if (0 != isAlterableTable(pParse, pTab))
				goto exit_drop_column;
			if (0 != isRealTable(pParse, pTab, (int)(1)))
				goto exit_drop_column;
			zCol = sqlite3NameFromToken(db, pName);
			if ((zCol) == (null))
			{

				goto exit_drop_column;
			}

			iCol = (int)(sqlite3ColumnIndex(pTab, zCol));
			if ((iCol) < (0))
			{
				sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pName);
				goto exit_drop_column;
			}

			if ((pTab.aCol[iCol].colFlags & (0x0001 | 0x0008)) != 0)
			{
				sqlite3ErrorMsg(pParse, "cannot drop %s column: \"%s\"", (pTab.aCol[iCol].colFlags & 0x0001) ? "PRIMARY KEY" : "UNIQUE", zCol);
				goto exit_drop_column;
			}

			if ((pTab.nCol) <= (1))
			{
				sqlite3ErrorMsg(pParse, "cannot drop column \"%s\": no other columns exist", zCol);
				goto exit_drop_column;
			}

			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));

			zDb = db.aDb[iDb].zDbSName;
			if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, zCol)) != 0)
			{
				goto exit_drop_column;
			}

			renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "", (int)(0));
			renameFixQuotes(pParse, zDb, ((iDb) == (1) ? 1 : 0));
			sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_drop_column(%d, sql, %d) WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)", zDb, (int)(iDb), (int)(iCol), pTab.zName);
			renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0002));
			renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "after drop column", (int)(1));
			if (((pParse.nErr) == (0)) && ((pTab.aCol[iCol].colFlags & 0x0020) == (0)))
			{
				int i = 0;
				int addr = 0;
				int reg = 0;
				int regRec = 0;
				Index pPk = null;
				int nField = (int)(0);
				int iCur = 0;
				Vdbe v = sqlite3GetVdbe(pParse);
				iCur = (int)(pParse.nTab++);
				sqlite3OpenTable(pParse, (int)(iCur), (int)(iDb), pTab, (int)(112));
				addr = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
				reg = (int)(++pParse.nMem);
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(reg));
					pParse.nMem += (int)(pTab.nCol);
				}
				else
				{
					pPk = sqlite3PrimaryKeyIndex(pTab);
					pParse.nMem += (int)(pPk.nColumn);
					for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(i), (int)(reg + i + 1));
					}

					nField = (int)(pPk.nKeyCol);
				}

				regRec = (int)(++pParse.nMem);
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					if ((i != iCol) && ((pTab.aCol[i].colFlags & 0x0020) == (0)))
					{
						int regOut = 0;
						if ((pPk) != null)
						{
							int iPos = (int)(sqlite3TableColumnToIndex(pPk, (short)(i)));
							int iColPos = (int)(sqlite3TableColumnToIndex(pPk, (short)(iCol)));
							if ((iPos) < (pPk.nKeyCol))
								continue;
							regOut = (int)(reg + 1 + iPos - ((iPos) > (iColPos)));
						}
						else
						{
							regOut = (int)(reg + 1 + nField);
						}

						if ((i) == (pTab.iPKey))
						{
							sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regOut));
						}
						else
						{
							sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(i), (int)(regOut));
						}

						nField++;
					}
				}

				if ((nField) == (0))
				{
					pParse.nMem++;
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(reg + 1));
					nField = (int)(1);
				}

				sqlite3VdbeAddOp3(v, (int)(96), (int)(reg + 1), (int)(nField), (int)(regRec));
				if ((pPk) != null)
				{
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iCur), (int)(regRec), (int)(reg + 1), (int)(pPk.nKeyCol));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(127), (int)(iCur), (int)(regRec), (int)(reg));
				}

				sqlite3VdbeChangeP5(v, (ushort)(0x02));
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iCur), (int)(addr + 1));
				sqlite3VdbeJumpHere(v, (int)(addr));
			}

		exit_drop_column:
			; sqlite3DbFree(db, zCol);
			sqlite3SrcListDelete(db, pSrc);
		}
		public static void sqlite3AlterFinishAddColumn(Parse pParse, Token* pColDef)
		{
			Table pNew;
			Table pTab;
			int iDb = 0;
			sbyte* zDb;
			sbyte* zTab;
			sbyte* zCol;
			Column* pCol;
			Expr pDflt;
			sqlite3 db;
			Vdbe v;
			int r1 = 0;
			db = pParse.db;

			if ((pParse.nErr) != 0)
				return;

			pNew = pParse.pNewTable;


			iDb = (int)(sqlite3SchemaToIndex(db, pNew.pSchema));
			zDb = db.aDb[iDb].zDbSName;
			zTab = &pNew.zName[16];
			pCol = &pNew.aCol[pNew.nCol - 1];
			pDflt = sqlite3ColumnExpr(pNew, pCol);
			pTab = sqlite3FindTable(db, zTab, zDb);

			if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
			{
				return;
			}

			if ((pCol->colFlags & 0x0001) != 0)
			{
				sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
				return;
			}

			if ((pNew.pIndex) != null)
			{
				sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
				return;
			}

			if ((pCol->colFlags & 0x0060) == (0))
			{

				if (((pDflt) != null) && ((pDflt.pLeft.op) == (121)))
				{
					pDflt = null;
				}


				if ((((db.flags & 0x00004000) != 0) && ((pNew.u.tab.pFKey) != null)) && ((pDflt) != null))
				{
					sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a REFERENCES column with non-NULL default value");
				}

				if (((pCol->notNull) != 0) && (pDflt == null))
				{
					sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a NOT NULL column with default value NULL");
				}

				if ((pDflt) != null)
				{
					sqlite3_value pVal = null;
					int rc = 0;
					rc = (int)(sqlite3ValueFromExpr(db, pDflt, (byte)(1), (byte)(0x41), pVal));

					if (rc != 0)
					{

						return;
					}

					if (pVal == null)
					{
						sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "Cannot add a column with non-constant default");
					}

					sqlite3ValueFree(pVal);
				}
			}
			else if ((pCol->colFlags & 0x0040) != 0)
			{
				sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "cannot add a STORED column");
			}

			zCol = sqlite3DbStrNDup(db, pColDef->z, (ulong)(pColDef->n));
			if ((zCol) != null)
			{
				sbyte* zEnd = &zCol[pColDef->n - 1];
				while (((zEnd) > (zCol)) && (((*zEnd) == (59)) || ((sqlite3CtypeMap[(byte)(*zEnd)] & 0x01) != 0)))
				{
					*zEnd-- = (sbyte)(0);
				}



				sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = printf('%%.%ds, ',sql) || %Q || substr(sql,1+length(printf('%%.%ds',sql))) WHERE type = 'table' AND name = %Q", zDb, (int)(pNew.u.tab.addColOffset), zCol, (int)(pNew.u.tab.addColOffset), zTab);
				sqlite3DbFree(db, zCol);
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) != null)
			{
				r1 = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp3(v, (int)(98), (int)(iDb), (int)(r1), (int)(2));
				sqlite3VdbeUsesBtree(v, (int)(iDb));
				sqlite3VdbeAddOp2(v, (int)(85), (int)(r1), (int)(-2));
				sqlite3VdbeAddOp2(v, (int)(49), (int)(r1), (int)(sqlite3VdbeCurrentAddr(v) + 2));
				sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(2), (int)(3));
				sqlite3ReleaseTempReg(pParse, (int)(r1));
				renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0003));
				if ((pNew.pCheck != null) || (((pCol->notNull) != 0) && ((pCol->colFlags & 0x0060) != 0)))
				{
					sqlite3NestedParse(pParse, "SELECT CASE WHEN quick_check GLOB 'CHECK*' THEN raise(ABORT,'CHECK constraint failed') ELSE raise(ABORT,'NOT NULL constraint failed') END  FROM pragma_quick_check(%Q,%Q) WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'", zTab, zDb);
				}
			}
		}
		public static void sqlite3AlterFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3AlterFunctions_aAlterTableFuncs, ((int)(5 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3AlterRenameColumn(Parse pParse, SrcList pSrc, Token* pOld, Token* pNew)
		{
			sqlite3 db = pParse.db;
			Table pTab;
			int iCol = 0;
			sbyte* zOld = null;
			sbyte* zNew = null;
			sbyte* zDb;
			int iSchema = 0;
			int bQuote = 0;
			pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
			if (pTab == null)
				goto exit_rename_column;
			if (0 != isAlterableTable(pParse, pTab))
				goto exit_rename_column;
			if (0 != isRealTable(pParse, pTab, (int)(0)))
				goto exit_rename_column;
			iSchema = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));

			zDb = db.aDb[iSchema].zDbSName;
			if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
			{
				goto exit_rename_column;
			}

			zOld = sqlite3NameFromToken(db, pOld);
			if (zOld == null)
				goto exit_rename_column;
			for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
			{
				if ((0) == (sqlite3StrICmp(pTab.aCol[iCol].zCnName, zOld)))
					break;
			}

			if ((iCol) == (pTab.nCol))
			{
				sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pOld);
				goto exit_rename_column;
			}

			renameTestSchema(pParse, zDb, ((iSchema) == (1) ? 1 : 0), "", (int)(0));
			renameFixQuotes(pParse, zDb, ((iSchema) == (1) ? 1 : 0));
			sqlite3MayAbort(pParse);
			zNew = sqlite3NameFromToken(db, pNew);
			if (zNew == null)
				goto exit_rename_column;

			bQuote = (int)(sqlite3CtypeMap[(byte)(pNew->z[0])] & 0x80);
			sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'  AND (type != 'index' OR tbl_name = %Q)", zDb, zDb, pTab.zName, (int)(iCol), zNew, (int)(bQuote), ((iSchema) == (1) ? 1 : 0), pTab.zName);
			sqlite3NestedParse(pParse, "UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN ('trigger', 'view')", zDb, pTab.zName, (int)(iCol), zNew, (int)(bQuote));
			renameReloadSchema(pParse, (int)(iSchema), (ushort)(0x0001));
			renameTestSchema(pParse, zDb, ((iSchema) == (1) ? 1 : 0), "after rename", (int)(1));
		exit_rename_column:
			; sqlite3SrcListDelete(db, pSrc);
			sqlite3DbFree(db, zOld);
			sqlite3DbFree(db, zNew);
			return;
		}
		public static void sqlite3AlterRenameTable(Parse pParse, SrcList pSrc, Token* pName)
		{
			int iDb = 0;
			sbyte* zDb;
			Table pTab;
			sbyte* zName = null;
			sqlite3 db = pParse.db;
			int nTabName = 0;
			sbyte* zTabName;
			Vdbe v;
			VTable pVTab = null;
			if ((db.mallocFailed) != 0)
				goto exit_rename_table;


			pTab = sqlite3LocateTableItem(pParse, (uint)(0), pSrc.a[0]);
			if (pTab == null)
				goto exit_rename_table;
			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
			zDb = db.aDb[iDb].zDbSName;
			zName = sqlite3NameFromToken(db, pName);
			if (zName == null)
				goto exit_rename_table;
			if ((((sqlite3FindTable(db, zName, zDb)) != null) || ((sqlite3FindIndex(db, zName, zDb)) != null)) || ((sqlite3IsShadowTableOf(db, pTab, zName)) != 0))
			{
				sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s", zName);
				goto exit_rename_table;
			}

			if (0 != isAlterableTable(pParse, pTab))
			{
				goto exit_rename_table;
			}

			if (0 != sqlite3CheckObjectName(pParse, zName, "table", zName))
			{
				goto exit_rename_table;
			}

			if ((((pTab).eTabType) == (2)))
			{
				sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab.zName);
				goto exit_rename_table;
			}

			if ((sqlite3AuthCheck(pParse, (int)(26), zDb, pTab.zName, null)) != 0)
			{
				goto exit_rename_table;
			}

			if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
			{
				goto exit_rename_table;
			}

			if ((((pTab).eTabType) == (1)))
			{
				pVTab = sqlite3GetVTable(db, pTab);
				if ((pVTab.pVtab.pModule.xRename) == (null))
				{
					pVTab = null;
				}
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
			{
				goto exit_rename_table;
			}

			sqlite3MayAbort(pParse);
			zTabName = pTab.zName;
			nTabName = (int)(sqlite3Utf8CharLen(zTabName, (int)(-1)));
			sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'", zDb, zDb, zTabName, zName, (((iDb) == (1)) ? 1 : 0), zTabName);
			sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X'      AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type='table' OR type='index' OR type='trigger');", zDb, zName, zName, zName, (int)(nTabName), zTabName);
			if ((sqlite3FindTable(db, "sqlite_sequence", zDb)) != null)
			{
				sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q", zDb, zName, pTab.zName);
			}

			if (iDb != 1)
			{
				sqlite3NestedParse(pParse, "UPDATE sqlite_temp_schema SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND   sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) THEN %Q ELSE tbl_name END WHERE type IN ('view', 'trigger')", zDb, zTabName, zName, zTabName, zDb, zName);
			}

			if ((pVTab) != null)
			{
				int i = (int)(++pParse.nMem);
				sqlite3VdbeLoadString(v, (int)(i), zName);
				sqlite3VdbeAddOp4(v, (int)(175), (int)(i), (int)(0), (int)(0), (sbyte*)(pVTab), (int)(-12));
			}

			renameReloadSchema(pParse, (int)(iDb), (ushort)(0x0001));
			renameTestSchema(pParse, zDb, ((iDb) == (1) ? 1 : 0), "after rename", (int)(0));
		exit_rename_table:
			; sqlite3SrcListDelete(db, pSrc);
			sqlite3DbFree(db, zName);
		}
		public static int sqlite3AnalysisLoad(sqlite3 db, int iDb)
		{
			analysisInfo sInfo = new analysisInfo();
			HashElem* i;
			sbyte* zSql;
			int rc = (int)(0);
			Schema pSchema = db.aDb[iDb].pSchema;
			Table pStat1;



			for (i = ((&pSchema.tblHash)->first); i; i = ((i)->next))
			{
				Table pTab = ((i)->data);
				pTab.tabFlags &= (uint)(~0x00000010);
			}

			for (i = ((&pSchema.idxHash)->first); i; i = ((i)->next))
			{
				Index pIdx = ((i)->data);
				pIdx.hasStat1 = (uint)(0);
			}

			sInfo.db = db;
			sInfo.zDatabase = db.aDb[iDb].zDbSName;
			if ((pStat1 = sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase)) && (((pStat1).eTabType) == (0)))
			{
				zSql = sqlite3MPrintf(db, "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
				if ((zSql) == (null))
				{
					rc = (int)(7);
				}
				else
				{
					rc = (int)(sqlite3_exec(db, zSql, analysisLoader, sInfo, null));
					sqlite3DbFree(db, zSql);
				}
			}


			for (i = ((&pSchema.idxHash)->first); i; i = ((i)->next))
			{
				Index pIdx = ((i)->data);
				if (pIdx.hasStat1 == 0)
					sqlite3DefaultRowEst(pIdx);
			}

			if ((rc) == (7))
			{
				sqlite3OomFault(db);
			}

			return (int)(rc);
		}
		public static void sqlite3Analyze(Parse pParse, Token* pName1, Token* pName2)
		{
			sqlite3 db = pParse.db;
			int iDb = 0;
			int i = 0;
			sbyte* z; sbyte* zDb;
			Table pTab;
			Index pIdx;
			Token* pTableName;
			Vdbe v;

			if (0 != sqlite3ReadSchema(pParse))
			{
				return;
			}


			if ((pName1) == (null))
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((i) == (1))
						continue;
					analyzeDatabase(pParse, (int)(i));
				}
			}
			else if (((pName2->n) == (0)) && ((iDb = (int)(sqlite3FindDb(db, pName1))) >= (0)))
			{
				analyzeDatabase(pParse, (int)(iDb));
			}
			else
			{
				iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pTableName));
				if ((iDb) >= (0))
				{
					zDb = (pName2->n) != 0 ? db.aDb[iDb].zDbSName : null;
					z = sqlite3NameFromToken(db, pTableName);
					if ((z) != null)
					{
						if ((pIdx = sqlite3FindIndex(db, z, zDb)) != null)
						{
							analyzeTable(pParse, pIdx.pTable, pIdx);
						}
						else if ((pTab = sqlite3LocateTable(pParse, (uint)(0), z, zDb)) != null)
						{
							analyzeTable(pParse, pTab, null);
						}

						sqlite3DbFree(db, z);
					}
				}
			}

			if (((db.nSqlExec) == (0)) && ((v = sqlite3GetVdbe(pParse)) != null))
			{
				sqlite3VdbeAddOp0(v, (int)(165));
			}
		}
		public static int sqlite3ApiExit(sqlite3 db, int rc)
		{


			if (((db.mallocFailed) != 0) || ((rc) != 0))
			{
				return (int)(apiHandleError(db, (int)(rc)));
			}

			return (int)(rc & db.errMask);
		}
		public static void* sqlite3ArrayAllocate(sqlite3 db, void* pArray, int szEntry, int* pnEntry, int* pIdx)
		{
			sbyte* z;
			long n = (long)(*pIdx = (int)(*pnEntry));
			if ((n & (n - 1)) == (0))
			{
				long sz = (long)(((n) == (0)) ? 1 : 2 * n);
				void* pNew = sqlite3DbRealloc(db, pArray, (ulong)(sz * szEntry));
				if ((pNew) == (null))
				{
					*pIdx = (int)(-1);
					return pArray;
				}

				pArray = pNew;
			}

			z = (sbyte*)(pArray);
			CRuntime.memset(&z[n * szEntry], (int)(0), (ulong)(szEntry));
			++*pnEntry;
			return pArray;
		}
		public static int sqlite3AtoF(sbyte* z, double* pResult, int length, byte enc)
		{
			int incr = 0;
			sbyte* zEnd;
			int sign = (int)(1);
			long s = (long)(0);
			int d = (int)(0);
			int esign = (int)(1);
			int e = (int)(0);
			int eValid = (int)(1);
			double result = 0;
			int nDigit = (int)(0);
			int eType = (int)(1);

			*pResult = (double)(0.0);
			if ((length) == (0))
				return (int)(0);
			if ((enc) == (1))
			{
				incr = (int)(1);
				zEnd = z + length;
			}
			else
			{
				int i = 0;
				incr = (int)(2);
				length &= (int)(~1);

				for (i = (int)(3 - enc); ((i) < (length)) && ((z[i]) == (0)); i += (int)(2))
				{
				}

				if ((i) < (length))
					eType = (int)(-100);
				zEnd = &z[i ^ 1];
				z += (enc & 1);
			}

			while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x01) != 0))
			{
				z += incr;
			}

			if ((z) >= (zEnd))
				return (int)(0);
			if ((*z) == (45))
			{
				sign = (int)(-1);
				z += incr;
			}
			else if ((*z) == (43))
			{
				z += incr;
			}

			while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
			{
				s = (long)(s * 10 + (*z - 48));
				z += incr;
				nDigit++;
				if ((s) >= (((0xffffffff | (((long)(0x7fffffff)) << 32)) - 9) / 10))
				{
					while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
					{
						z += incr;
						d++;
					}
				}
			}

			if ((z) >= (zEnd))
				goto do_atof_calc;
			if ((*z) == (46))
			{
				z += incr;
				eType++;
				while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
				{
					if ((s) < (((0xffffffff | (((long)(0x7fffffff)) << 32)) - 9) / 10))
					{
						s = (long)(s * 10 + (*z - 48));
						d--;
						nDigit++;
					}

					z += incr;
				}
			}

			if ((z) >= (zEnd))
				goto do_atof_calc;
			if (((*z) == (101)) || ((*z) == (69)))
			{
				z += incr;
				eValid = (int)(0);
				eType++;
				if ((z) >= (zEnd))
					goto do_atof_calc;
				if ((*z) == (45))
				{
					esign = (int)(-1);
					z += incr;
				}
				else if ((*z) == (43))
				{
					z += incr;
				}

				while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x04) != 0))
				{
					e = (int)((e) < (10000) ? (e * 10 + (*z - 48)) : 10000);
					z += incr;
					eValid = (int)(1);
				}
			}

			while (((z) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*z)] & 0x01) != 0))
			{
				z += incr;
			}

		do_atof_calc:
			; e = (int)((e * esign) + d);
			if ((e) < (0))
			{
				esign = (int)(-1);
				e *= (int)(-1);
			}
			else
			{
				esign = (int)(1);
			}

			if ((s) == (0))
			{
				result = (double)((sign) < (0) ? -(double)(0) : (double)(0));
			}
			else
			{
				while ((e) > (0))
				{
					if ((esign) > (0))
					{
						if ((s) >= ((0xffffffff | (((long)(0x7fffffff)) << 32)) / 10))
							break;
						s *= (long)(10);
					}
					else
					{
						if (s % 10 != 0)
							break;
						s /= (long)(10);
					}

					e--;
				}

				s = (long)((sign) < (0) ? -s : s);
				if ((e) == (0))
				{
					result = ((double)(s));
				}
				else
				{
					if ((e) > (307))
					{
						if ((e) < (342))
						{
							long double scale = (long double )
                    (sqlite3Pow10((int)(e - 308)));
							if ((esign) < (0))
							{
								result = (double)(s / scale);
								result /= (double)(1.0e+308);
							}
							else
							{
								result = (double)(s * scale);
								result *= (double)(1.0e+308);
							}
						}

						else
						{

							if ((esign) < (0))
							{
								result = (double)(0.0 * s);
							}
							else
							{
								result = (double)(((float)(1e+300 * 1e+300)) * s);
							}
						}
					}

					else
					{
						long double scale = (long double )
                (sqlite3Pow10((int)(e)));
						if ((esign) < (0))
						{
							result = (double)(s / scale);
						}
						else
						{
							result = (double)(s * scale);
						}
					}
				}
			}

			*pResult = (double)(result);
			if (((((z) == (zEnd)) && ((nDigit) > (0))) && ((eValid) != 0)) && ((eType) > (0)))
			{
				return (int)(eType);
			}
			else if ((((eType) >= (2)) && (((eType) == (3)) || ((eValid) != 0))) && ((nDigit) > (0)))
			{
				return (int)(-1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static int sqlite3Atoi(sbyte* z)
		{
			int x = (int)(0);
			sqlite3GetInt32(z, &x);
			return (int)(x);
		}
		public static int sqlite3Atoi64(sbyte* zNum, long* pNum, int length, byte enc)
		{
			int incr = 0;
			ulong u = (ulong)(0);
			int neg = (int)(0);
			int i = 0;
			int c = (int)(0);
			int nonNum = (int)(0);
			int rc = 0;
			sbyte* zStart;
			sbyte* zEnd = zNum + length;

			if ((enc) == (1))
			{
				incr = (int)(1);
			}
			else
			{
				incr = (int)(2);
				length &= (int)(~1);

				for (i = (int)(3 - enc); ((i) < (length)) && ((zNum[i]) == (0)); i += (int)(2))
				{
				}

				nonNum = (int)((i) < (length) ? 1 : 0);
				zEnd = &zNum[i ^ 1];
				zNum += (enc & 1);
			}

			while (((zNum) < (zEnd)) && ((sqlite3CtypeMap[(byte)(*zNum)] & 0x01) != 0))
			{
				zNum += incr;
			}

			if ((zNum) < (zEnd))
			{
				if ((*zNum) == (45))
				{
					neg = (int)(1);
					zNum += incr;
				}
				else if ((*zNum) == (43))
				{
					zNum += incr;
				}
			}

			zStart = zNum;
			while (((zNum) < (zEnd)) && ((zNum[0]) == (48)))
			{
				zNum += incr;
			}

			for (i = (int)(0); (((&zNum[i]) < (zEnd)) && ((c = (int)(zNum[i])) >= (48))) && ((c) <= (57)); i += (int)(incr))
			{
				u = (ulong)(u * 10 + c - 48);
			}

			if ((u) > (0xffffffff | (((long)(0x7fffffff)) << 32)))
			{
				*pNum = (long)((neg) != 0 ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) : (0xffffffff | (((long)(0x7fffffff)) << 32)));
			}
			else if ((neg) != 0)
			{
				*pNum = (long)(-(long)(u));
			}
			else
			{
				*pNum = ((long)(u));
			}

			rc = (int)(0);
			if (((i) == (0)) && ((zStart) == (zNum)))
			{
				rc = (int)(-1);
			}
			else if ((nonNum) != 0)
			{
				rc = (int)(1);
			}
			else if ((&zNum[i]) < (zEnd))
			{
				int jj = (int)(i);
				do
				{
					if ((sqlite3CtypeMap[(byte)(zNum[jj])] & 0x01) == 0)
					{
						rc = (int)(1);
						break;
					}

					jj += (int)(incr);
				}
				while ((&zNum[jj]) < (zEnd));
			}

			if ((i) < (19 * incr))
			{

				return (int)(rc);
			}
			else
			{
				c = (int)((i) > (19 * incr) ? 1 : compare2pow63(zNum, (int)(incr)));
				if ((c) < (0))
				{

					return (int)(rc);
				}
				else
				{
					*pNum = (long)((neg) != 0 ? (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) : (0xffffffff | (((long)(0x7fffffff)) << 32)));
					if ((c) > (0))
					{
						return (int)(2);
					}
					else
					{

						return (int)((neg) != 0 ? rc : 3);
					}
				}
			}
		}
		public static void sqlite3Attach(Parse pParse, Expr p, Expr pDbname, Expr pKey)
		{
			codeAttach(pParse, (int)(24), sqlite3Attach_attach_func, p, p, pDbname, pKey);
		}
		public static int sqlite3AuthCheck(Parse pParse, int code, sbyte* zArg1, sbyte* zArg2, sbyte* zArg3)
		{
			sqlite3 db = pParse.db;
			int rc = 0;

			if ((((db.xAuth) == (null)) || ((db.init.busy) != 0)) || (pParse.eParseMode != 0))
			{
				return (int)(0);
			}

			rc = (int)(db.xAuth(db.pAuthArg, (int)(code), zArg1, zArg2, zArg3, pParse.zAuthContext));
			if ((rc) == (1))
			{
				sqlite3ErrorMsg(pParse, "not authorized");
				pParse.rc = (int)(23);
			}
			else if ((rc != 0) && (rc != 2))
			{
				rc = (int)(1);
				sqliteAuthBadReturnCode(pParse);
			}

			return (int)(rc);
		}
		public static void sqlite3AuthContextPop(AuthContext pContext)
		{
			if ((pContext.pParse) != null)
			{
				pContext.pParse.zAuthContext = pContext.zAuthContext;
				pContext.pParse = null;
			}
		}
		public static void sqlite3AuthContextPush(Parse pParse, AuthContext pContext, sbyte* zContext)
		{

			pContext.pParse = pParse;
			pContext.zAuthContext = pParse.zAuthContext;
			pParse.zAuthContext = zContext;
		}
		public static void sqlite3AuthRead(Parse pParse, Expr pExpr, Schema pSchema, SrcList pTabList)
		{
			Table pTab = null;
			sbyte* zCol;
			int iSrc = 0;
			int iDb = 0;
			int iCol = 0;



			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pSchema));
			if ((iDb) < (0))
			{
				return;
			}

			if ((pExpr.op) == (77))
			{
				pTab = pParse.pTriggerTab;
			}
			else
			{

				for (iSrc = (int)(0); (iSrc) < (pTabList.nSrc); iSrc++)
				{
					if ((pExpr.iTable) == (pTabList.a[iSrc].iCursor))
					{
						pTab = pTabList.a[iSrc].pTab;
						break;
					}
				}
			}

			iCol = (int)(pExpr.iColumn);
			if ((pTab) == (null))
				return;
			if ((iCol) >= (0))
			{

				zCol = pTab.aCol[iCol].zCnName;
			}
			else if ((pTab.iPKey) >= (0))
			{

				zCol = pTab.aCol[pTab.iPKey].zCnName;
			}
			else
			{
				zCol = "ROWID";
			}


			if ((2) == (sqlite3AuthReadCol(pParse, pTab.zName, zCol, (int)(iDb))))
			{
				pExpr.op = (byte)(121);
			}
		}
		public static int sqlite3AuthReadCol(Parse pParse, sbyte* zTab, sbyte* zCol, int iDb)
		{
			sqlite3 db = pParse.db;
			sbyte* zDb = db.aDb[iDb].zDbSName;
			int rc = 0;
			if ((db.init.busy) != 0)
				return (int)(0);
			rc = (int)(db.xAuth(db.pAuthArg, (int)(20), zTab, zCol, zDb, pParse.zAuthContext));
			if ((rc) == (1))
			{
				sbyte* z = sqlite3_mprintf("%s.%s", zTab, zCol);
				if (((db.nDb) > (2)) || (iDb != 0))
					z = sqlite3_mprintf("%s.%z", zDb, z);
				sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);
				pParse.rc = (int)(23);
			}
			else if ((rc != 2) && (rc != 0))
			{
				sqliteAuthBadReturnCode(pParse);
			}

			return (int)(rc);
		}
		public static void sqlite3AutoincrementBegin(Parse pParse)
		{
			AutoincInfo p;
			sqlite3 db = pParse.db;
			Db pDb;
			int memId = 0;
			Vdbe v = pParse.pVdbe;



			for (p = pParse.pAinc; p; p = p.pNext)
			{
				VdbeOp* aOp;
				pDb = db.aDb[p.iDb];
				memId = (int)(p.regCtr);

				sqlite3OpenTable(pParse, (int)(0), (int)(p.iDb), pDb.pSchema.pSeqTab, (int)(101));
				sqlite3VdbeLoadString(v, (int)(memId - 1), p.pTab.zName);
				aOp = sqlite3VdbeAddOpList(v, ((int)(12 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3AutoincrementBegin_autoInc, (int)(sqlite3AutoincrementBegin_iLn));
				if ((aOp) == (null))
					break;
				aOp[0].p2 = (int)(memId);
				aOp[0].p3 = (int)(memId + 2);
				aOp[2].p3 = (int)(memId);
				aOp[3].p1 = (int)(memId - 1);
				aOp[3].p3 = (int)(memId);
				aOp[3].p5 = (ushort)(0x10);
				aOp[4].p2 = (int)(memId + 1);
				aOp[5].p3 = (int)(memId);
				aOp[6].p1 = (int)(memId);
				aOp[7].p2 = (int)(memId + 2);
				aOp[7].p1 = (int)(memId);
				aOp[10].p2 = (int)(memId);
				if ((pParse.nTab) == (0))
					pParse.nTab = (int)(1);
			}
		}
		public static void sqlite3AutoincrementEnd(Parse pParse)
		{
			if ((pParse.pAinc) != null)
				autoIncrementEnd(pParse);
		}
		public static void sqlite3AutoLoadExtensions(sqlite3 db)
		{
			uint i = 0;
			int go = (int)(1);
			int rc = 0;
			delegate87 xInit;
			if ((sqlite3Autoext.nExt) == (0))
			{
				return;
			}

			for (i = (uint)(0); go; i++)
			{
				sbyte* zErrmsg;
				sqlite3_mutex* mutex = sqlite3MutexAlloc((int)(2));
				sqlite3_api_routines pThunk = sqlite3Apis;
				sqlite3_mutex_enter(mutex);
				if ((i) >= (sqlite3Autoext.nExt))
				{
					xInit = null;
					go = (int)(0);
				}
				else
				{
					xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3Autoext.aExt[i]);
				}

				sqlite3_mutex_leave(mutex);
				zErrmsg = null;
				if (((xInit) != null) && ((rc = (int)(xInit(db, &zErrmsg, pThunk))) != 0))
				{
					sqlite3ErrorWithMsg(db, (int)(rc), "automatic extension loading failed: %s", zErrmsg);
					go = (int)(0);
				}

				sqlite3_free(zErrmsg);
			}
		}
		public static void sqlite3BackupRestart(sqlite3_backup pBackup)
		{
			sqlite3_backup p;
			for (p = pBackup; p; p = p.pNext)
			{

				p.iNext = (uint)(1);
			}
		}
		public static void sqlite3BackupUpdate(sqlite3_backup pBackup, uint iPage, byte* aData)
		{
			if ((pBackup) != null)
				backupUpdate(pBackup, (uint)(iPage), aData);
		}
		public static void sqlite3BeginBenignMalloc()
		{
			if ((sqlite3Hooks.xBenignBegin) != null)
			{
				sqlite3Hooks.xBenignBegin();
			}
		}
		public static void sqlite3BeginTransaction(Parse pParse, int type)
		{
			sqlite3 db;
			Vdbe v;
			int i = 0;

			db = pParse.db;

			if ((sqlite3AuthCheck(pParse, (int)(22), "BEGIN", null, null)) != 0)
			{
				return;
			}

			v = sqlite3GetVdbe(pParse);
			if (v == null)
				return;
			if (type != 7)
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					int eTxnType = 0;
					Btree pBt = db.aDb[i].pBt;
					if (((pBt) != null) && ((sqlite3BtreeIsReadonly(pBt)) != 0))
					{
						eTxnType = (int)(0);
					}
					else if ((type) == (9))
					{
						eTxnType = (int)(2);
					}
					else
					{
						eTxnType = (int)(1);
					}

					sqlite3VdbeAddOp2(v, (int)(2), (int)(i), (int)(eTxnType));
					sqlite3VdbeUsesBtree(v, (int)(i));
				}
			}

			sqlite3VdbeAddOp0(v, (int)(1));
		}
		public static void sqlite3BeginTrigger(Parse pParse, Token* pName1, Token* pName2, int tr_tm, int op, IdList* pColumns, SrcList pTableName, Expr pWhen, int isTemp, int noErr)
		{
			Trigger pTrigger = null;
			Table pTab;
			sbyte* zName = null;
			sqlite3 db = pParse.db;
			int iDb = 0;
			Token* pName;
			DbFixer sFix = new DbFixer();




			if ((isTemp) != 0)
			{
				if ((pName2->n) > (0))
				{
					sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
					goto trigger_cleanup;
				}

				iDb = (int)(1);
				pName = pName1;
			}
			else
			{
				iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pName));
				if ((iDb) < (0))
				{
					goto trigger_cleanup;
				}
			}

			if ((pTableName == null) || ((db.mallocFailed) != 0))
			{
				goto trigger_cleanup;
			}

			if (((db.init.busy) != 0) && (iDb != 1))
			{
				sqlite3DbFree(db, pTableName.a[0].zDatabase);
				pTableName.a[0].zDatabase = null;
			}

			pTab = sqlite3SrcListLookup(pParse, pTableName);
			if (((((db.init.busy) == (0)) && ((pName2->n) == (0))) && ((pTab) != null)) && ((pTab.pSchema) == (db.aDb[1].pSchema)))
			{
				iDb = (int)(1);
			}

			if ((db.mallocFailed) != 0)
				goto trigger_cleanup;

			sqlite3FixInit(sFix, pParse, (int)(iDb), "trigger", pName);
			if ((sqlite3FixSrcList(sFix, pTableName)) != 0)
			{
				goto trigger_cleanup;
			}

			pTab = sqlite3SrcListLookup(pParse, pTableName);
			if (pTab == null)
			{
				goto trigger_orphan_error;
			}

			if ((((pTab).eTabType) == (1)))
			{
				sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
				goto trigger_orphan_error;
			}

			zName = sqlite3NameFromToken(db, pName);
			if ((zName) == (null))
			{

				goto trigger_cleanup;
			}

			if ((sqlite3CheckObjectName(pParse, zName, "trigger", pTab.zName)) != 0)
			{
				goto trigger_cleanup;
			}


			if (!((pParse.eParseMode) >= (2)))
			{
				if ((sqlite3HashFind(&(db.aDb[iDb].pSchema.trigHash), zName)) != null)
				{
					if (noErr == 0)
					{
						sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
					}
					else
					{

						sqlite3CodeVerifySchema(pParse, (int)(iDb));
					}

					goto trigger_cleanup;
				}
			}

			if ((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0))
			{
				sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
				goto trigger_cleanup;
			}

			if ((((pTab).eTabType) == (2)) && (tr_tm != 65))
			{
				sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", ((tr_tm) == (33)) ? "BEFORE" : "AFTER", pTableName.a);
				goto trigger_orphan_error;
			}

			if ((!(((pTab).eTabType) == (2))) && ((tr_tm) == (65)))
			{
				sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF trigger on table: %S", pTableName.a);
				goto trigger_orphan_error;
			}

			if (!((pParse.eParseMode) >= (2)))
			{
				int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
				int code = (int)(7);
				sbyte* zDb = db.aDb[iTabDb].zDbSName;
				sbyte* zDbTrig = (isTemp) != 0 ? db.aDb[1].zDbSName : zDb;
				if (((iTabDb) == (1)) || ((isTemp) != 0))
					code = (int)(5);
				if ((sqlite3AuthCheck(pParse, (int)(code), zName, pTab.zName, zDbTrig)) != 0)
				{
					goto trigger_cleanup;
				}

				if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) && ((iTabDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
				{
					goto trigger_cleanup;
				}
			}

			if ((tr_tm) == (65))
			{
				tr_tm = (int)(33);
			}

			pTrigger = (Trigger)(sqlite3DbMallocZero(db, (ulong)(sizeof(Trigger))));
			if ((pTrigger) == (null))
				goto trigger_cleanup;
			pTrigger.zName = zName;
			zName = null;
			pTrigger.table = sqlite3DbStrDup(db, pTableName.a[0].zName);
			pTrigger.pSchema = db.aDb[iDb].pSchema;
			pTrigger.pTabSchema = pTab.pSchema;
			pTrigger.op = ((byte)(op));
			pTrigger.tr_tm = (byte)((tr_tm) == (33) ? 1 : 2);
			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameTokenRemap(pParse, pTrigger.table, pTableName.a[0].zName);
				pTrigger.pWhen = pWhen;
				pWhen = null;
			}
			else
			{
				pTrigger.pWhen = sqlite3ExprDup(db, pWhen, (int)(0x0001));
			}

			pTrigger.pColumns = pColumns;
			pColumns = null;

			pParse.pNewTrigger = pTrigger;
		trigger_cleanup:
			; sqlite3DbFree(db, zName);
			sqlite3SrcListDelete(db, pTableName);
			sqlite3IdListDelete(db, pColumns);
			sqlite3ExprDelete(db, pWhen);
			if (pParse.pNewTrigger == null)
			{
				sqlite3DeleteTrigger(db, pTrigger);
			}
			else
			{

			}

			return;
		trigger_orphan_error:
			; if ((db.init.iDb) == (1)) { db.init.orphanTrigger = (uint)(1); }
			goto trigger_cleanup;
		}
		public static void sqlite3BeginWriteOperation(Parse pParse, int setStatement, int iDb)
		{
			Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			sqlite3CodeVerifySchemaAtToplevel(pToplevel, (int)(iDb));
			(pToplevel.writeMask) |= (uint)(((uint)(1)) << (iDb));
			pToplevel.isMultiWrite |= (byte)(setStatement);
		}
		public static void sqlite3BenignMallocHooks(delegate73 xBenignBegin, delegate73 xBenignEnd)
		{
			sqlite3Hooks.xBenignBegin = xBenignBegin;
			sqlite3Hooks.xBenignEnd = xBenignEnd;
		}
		public static CollSeq sqlite3BinaryCompareCollSeq(Parse pParse, Expr pLeft, Expr pRight)
		{
			CollSeq pColl;

			if ((pLeft.flags & 0x000100) != 0)
			{
				pColl = sqlite3ExprCollSeq(pParse, pLeft);
			}
			else if (((pRight) != null) && ((pRight.flags & 0x000100) != 0))
			{
				pColl = sqlite3ExprCollSeq(pParse, pRight);
			}
			else
			{
				pColl = sqlite3ExprCollSeq(pParse, pLeft);
				if (pColl == null)
				{
					pColl = sqlite3ExprCollSeq(pParse, pRight);
				}
			}

			return pColl;
		}
		public static int sqlite3BitvecBuiltinTest(int sz, int* aOp)
		{
			Bitvec* pBitvec = null;
			byte* pV = null;
			int rc = (int)(-1);
			int i = 0; int nx = 0; int pc = 0; int op = 0;
			void* pTmpSpace;
			pBitvec = sqlite3BitvecCreate((uint)(sz));
			pV = sqlite3MallocZero((ulong)((sz + 7) / 8 + 1));
			pTmpSpace = sqlite3_malloc64((ulong)(512));
			if ((((pBitvec) == (null)) || ((pV) == (null))) || ((pTmpSpace) == (null)))
				goto bitvec_end;
			sqlite3BitvecSet(null, (uint)(1));
			sqlite3BitvecClear(null, (uint)(1), pTmpSpace);
			pc = (int)(i = (int)(0));
			while ((op = (int)(aOp[pc])) != 0)
			{
				switch (op)
				{
					case 1:
					case 2:
					case 5:
						{
							nx = (int)(4);
							i = (int)(aOp[pc + 2] - 1);
							aOp[pc + 2] += (int)(aOp[pc + 3]);
							break;
						}

					case 3:
					case 4:
					default:
						{
							nx = (int)(2);
							sqlite3_randomness((int)(sizeof(int)), &i);
							break;
						}
				}

				if ((--aOp[pc + 1]) > (0))
					nx = (int)(0);
				pc += (int)(nx);
				i = (int)((i & 0x7fffffff) % sz);
				if ((op & 1) != 0)
				{
					pV[(i + 1) >> 3] |= (byte)(1 << ((i + 1) & 7));
					if (op != 5)
					{
						if ((sqlite3BitvecSet(pBitvec, (uint)(i + 1))) != 0)
							goto bitvec_end;
					}
				}
				else
				{
					pV[(i + 1) >> 3] &= (byte)(~(1 << ((i + 1) & 7)));
					sqlite3BitvecClear(pBitvec, (uint)(i + 1), pTmpSpace);
				}
			}

			rc = (int)(sqlite3BitvecTest(null, (uint)(0)) + sqlite3BitvecTest(pBitvec, (uint)(sz + 1)) + sqlite3BitvecTest(pBitvec, (uint)(0)) + (sqlite3BitvecSize(pBitvec) - sz));
			for (i = (int)(1); (i) <= (sz); i++)
			{
				if (((pV[i >> 3] & (1 << (i & 7))) != 0) != sqlite3BitvecTest(pBitvec, (uint)(i)))
				{
					rc = (int)(i);
					break;
				}
			}

		bitvec_end:
			; sqlite3_free(pTmpSpace);
			sqlite3_free(pV);
			sqlite3BitvecDestroy(pBitvec);
			return (int)(rc);
		}
		public static void sqlite3BitvecClear(Bitvec* p, uint i, void* pBuf)
		{
			if ((p) == (null))
				return;

			i--;
			while ((p->iDivisor) != 0)
			{
				uint bin = (uint)(i / p->iDivisor);
				i = (uint)(i % p->iDivisor);
				p = p->u.apSub[bin];
				if (p == null)
				{
					return;
				}
			}

			if ((p->iSize) <= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
			{
				p->u.aBitmap[i / 8] &= (byte)(~(1 << (i & (8 - 1))));
			}
			else
			{
				uint j = 0;
				uint* aiValues = pBuf;
				CRuntime.memcpy(aiValues, p->u.aHash, (ulong)(124 * sizeof(uint)));
				CRuntime.memset(p->u.aHash, (int)(0), (ulong)(124 * sizeof(uint)));
				p->nSet = (uint)(0);
				for (j = (uint)(0); (j) < ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)); j++)
				{
					if (((aiValues[j]) != 0) && (aiValues[j] != (i + 1)))
					{
						uint h = (uint)(((aiValues[j] - 1) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
						p->nSet++;
						while ((p->u.aHash[h]) != 0)
						{
							h++;
							if ((h) >= ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)))
								h = (uint)(0);
						}

						p->u.aHash[h] = (uint)(aiValues[j]);
					}
				}
			}
		}
		public static Bitvec* sqlite3BitvecCreate(uint iSize)
		{
			Bitvec* p;

			p = sqlite3MallocZero((ulong)(sizeof(Bitvec)));
			if ((p) != null)
			{
				p->iSize = (uint)(iSize);
			}

			return p;
		}
		public static void sqlite3BitvecDestroy(Bitvec* p)
		{
			if ((p) == (null))
				return;
			if ((p->iDivisor) != 0)
			{
				uint i = 0;
				for (i = (uint)(0); (i) < ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec)); i++)
				{
					sqlite3BitvecDestroy(p->u.apSub[i]);
				}
			}

			sqlite3_free(p);
		}
		public static int sqlite3BitvecSet(Bitvec* p, uint i)
		{
			uint h = 0;
			if ((p) == (null))
				return (int)(0);


			i--;
			while (((p->iSize) > (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8)) && ((p->iDivisor) != 0))
			{
				uint bin = (uint)(i / p->iDivisor);
				i = (uint)(i % p->iDivisor);
				if ((p->u.apSub[bin]) == (null))
				{
					p->u.apSub[bin] = sqlite3BitvecCreate((uint)(p->iDivisor));
					if ((p->u.apSub[bin]) == (null))
						return (int)(7);
				}

				p = p->u.apSub[bin];
			}

			if ((p->iSize) <= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
			{
				p->u.aBitmap[i / 8] |= (byte)(1 << (i & (8 - 1)));
				return (int)(0);
			}

			h = (uint)(((i++) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
			if (p->u.aHash[h] == 0)
			{
				if ((p->nSet) < (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)) - 1))
				{
					goto bitvec_set_end;
				}
				else
				{
					goto bitvec_set_rehash;
				}
			}

			do
			{
				if ((p->u.aHash[h]) == (i))
					return (int)(0);
				h++;
				if ((h) >= ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)))
					h = (uint)(0);
			}
			while ((p->u.aHash[h]) != 0);
		bitvec_set_rehash:
			; if ((p->nSet) >= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)) / 2)) { uint j = 0; int rc = 0; uint* aiValues = sqlite3DbMallocRaw(null, (ulong)(124 * sizeof(uint))); if ((aiValues) == (null)) { return (int)(7); } else { CRuntime.memcpy(aiValues, p->u.aHash, (ulong)(124 * sizeof(uint))); CRuntime.memset(p->u.apSub, (int)(0), (ulong)(62 * sizeof(Bitvec))); p->iDivisor = (uint)((p->iSize + ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec)) - 1) / ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(Bitvec))); rc = (int)(sqlite3BitvecSet(p, (uint)(i))); for (j = (uint)(0); (j) < ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)); j++) { if ((aiValues[j]) != 0) rc |= (int)(sqlite3BitvecSet(p, (uint)(aiValues[j]))); } sqlite3DbFree(null, aiValues); return (int)(rc); } }
		bitvec_set_end:
			; p->nSet++;
			p->u.aHash[h] = (uint)(i);
			return (int)(0);
		}
		public static uint sqlite3BitvecSize(Bitvec* p)
		{
			return (uint)(p->iSize);
		}
		public static int sqlite3BitvecTest(Bitvec* p, uint i)
		{
			return ((p != null) && ((sqlite3BitvecTestNotNull(p, (uint)(i))) != 0) ? 1 : 0);
		}
		public static int sqlite3BitvecTestNotNull(Bitvec* p, uint i)
		{

			i--;
			if ((i) >= (p->iSize))
				return (int)(0);
			while ((p->iDivisor) != 0)
			{
				uint bin = (uint)(i / p->iDivisor);
				i = (uint)(i % p->iDivisor);
				p = p->u.apSub[bin];
				if (p == null)
				{
					return (int)(0);
				}
			}

			if ((p->iSize) <= (((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(byte)) * 8))
			{
				return (int)((p->u.aBitmap[i / 8] & (1 << (i & (8 - 1)))) != 0);
			}
			else
			{
				uint h = (uint)(((i++) * 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
				while ((p->u.aHash[h]) != 0)
				{
					if ((p->u.aHash[h]) == (i))
						return (int)(1);
					h = (uint)((h + 1) % ((((512 - (3 * sizeof(uint))) / sizeof(Bitvec)) * sizeof(Bitvec)) / sizeof(uint)));
				}

				return (int)(0);
			}
		}
		public static int sqlite3BlobCompare(sqlite3_value pB1, sqlite3_value pB2)
		{
			int c = 0;
			int n1 = (int)(pB1.n);
			int n2 = (int)(pB2.n);


			if (((pB1.flags | pB2.flags) & 0x4000) != 0)
			{
				if ((pB1.flags & pB2.flags & 0x4000) != 0)
				{
					return (int)(pB1.u.nZero - pB2.u.nZero);
				}
				else if ((pB1.flags & 0x4000) != 0)
				{
					if (isAllZero(pB2.z, (int)(pB2.n)) == 0)
						return (int)(-1);
					return (int)(pB1.u.nZero - n2);
				}
				else
				{
					if (isAllZero(pB1.z, (int)(pB1.n)) == 0)
						return (int)(+1);
					return (int)(n1 - pB2.u.nZero);
				}
			}

			c = (int)(memcmp(pB1.z, pB2.z, (ulong)((n1) > (n2) ? n2 : n1)));
			if ((c) != 0)
				return (int)(c);
			return (int)(n1 - n2);
		}
		public static int sqlite3BtreeBeginStmt(Btree p, int iStatement)
		{
			int rc = 0;
			BtShared pBt = p.pBt;
			sqlite3BtreeEnter(p);





			rc = (int)(sqlite3PagerOpenSavepoint(pBt.pPager, (int)(iStatement)));
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeBeginTrans(Btree p, int wrflag, int* pSchemaVersion)
		{
			BtShared pBt = p.pBt;
			Pager pPager = pBt.pPager;
			int rc = (int)(0);
			sqlite3BtreeEnter(p);


			if (((p.inTrans) == (2)) || (((p.inTrans) == (1)) && (wrflag == 0)))
			{
				goto trans_begun;
			}


			if (((p.db.flags & 0x02000000) != 0) && ((sqlite3PagerIsreadonly(pPager)) == (0)))
			{
				pBt.btsFlags &= (ushort)(~0x0001);
			}

			if (((pBt.btsFlags & 0x0001) != 0) && ((wrflag) != 0))
			{
				rc = (int)(8);
				goto trans_begun;
			}

			{
				sqlite3 pBlock = null;
				if ((((wrflag) != 0) && ((pBt.inTransaction) == (2))) || ((pBt.btsFlags & 0x0080) != 0))
				{
					pBlock = pBt.pWriter.db;
				}
				else if ((wrflag) > (1))
				{
					BtLock pIter;
					for (pIter = pBt.pLock; pIter; pIter = pIter.pNext)
					{
						if (pIter.pBtree != p)
						{
							pBlock = pIter.pBtree.db;
							break;
						}
					}
				}

				if ((pBlock) != null)
				{
					rc = (int)(6 | (1 << 8));
					goto trans_begun;
				}
			}

			rc = (int)(querySharedCacheTableLock(p, (uint)(1), (byte)(1)));
			if (0 != rc)
				goto trans_begun;
			pBt.btsFlags &= (ushort)(~0x0010);
			if ((pBt.nPage) == (0))
				pBt.btsFlags |= (ushort)(0x0010);
			do
			{
				while (((pBt.pPage1) == (null)) && ((0) == (rc = (int)(lockBtree(pBt)))))
				{
				}

				if (((rc) == (0)) && ((wrflag) != 0))
				{
					if ((pBt.btsFlags & 0x0001) != 0)
					{
						rc = (int)(8);
					}
					else
					{
						rc = (int)(sqlite3PagerBegin(pPager, ((wrflag) > (1) ? 1 : 0), (int)(sqlite3TempInMemory(p.db))));
						if ((rc) == (0))
						{
							rc = (int)(newDatabase(pBt));
						}
						else if (((rc) == (5 | (2 << 8))) && ((pBt.inTransaction) == (0)))
						{
							rc = (int)(5);
						}
					}
				}

				if (rc != 0)
				{
					(void)(0);
					unlockBtreeIfUnused(pBt);
				}
			}
			while ((((rc & 0xFF) == (5)) && ((pBt.inTransaction) == (0))) && ((btreeInvokeBusyHandler(pBt)) != 0));
			if ((rc) == (0))
			{
				if ((p.inTrans) == (0))
				{
					pBt.nTransaction++;
					if ((p.sharable) != 0)
					{

						p.lock.eLock = (byte)(1);
						p.lock.pNext = pBt.pLock;
						pBt.pLock = p.lock;
					}
				}

				p.inTrans = (byte)((wrflag) != 0 ? 2 : 1);
				if ((p.inTrans) > (pBt.inTransaction))
				{
					pBt.inTransaction = (byte)(p.inTrans);
				}

				if ((wrflag) != 0)
				{
					MemPage pPage1 = pBt.pPage1;

					pBt.pWriter = p;
					pBt.btsFlags &= (ushort)(~0x0040);
					if ((wrflag) > (1))
						pBt.btsFlags |= (ushort)(0x0040);
					if (pBt.nPage != sqlite3Get4byte(&pPage1.aData[28]))
					{
						rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
						if ((rc) == (0))
						{
							sqlite3Put4byte(&pPage1.aData[28], (uint)(pBt.nPage));
						}
					}
				}
			}

		trans_begun:
			; if ((rc) == (0)) { if ((pSchemaVersion) != null) { *pSchemaVersion = (int)(sqlite3Get4byte(&pBt.pPage1.aData[40])); } if ((wrflag) != 0) { rc = (int)(sqlite3PagerOpenSavepoint(pPager, (int)(p.db.nSavepoint))); } }


			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeCheckpoint(Btree p, int eMode, int* pnLog, int* pnCkpt)
		{
			int rc = (int)(0);
			if ((p) != null)
			{
				BtShared pBt = p.pBt;
				sqlite3BtreeEnter(p);
				if (pBt.inTransaction != 0)
				{
					rc = (int)(6);
				}
				else
				{
					rc = (int)(sqlite3PagerCheckpoint(pBt.pPager, p.db, (int)(eMode), pnLog, pnCkpt));
				}

				sqlite3BtreeLeave(p);
			}

			return (int)(rc);
		}
		public static void sqlite3BtreeClearCursor(BtCursor pCur)
		{

			sqlite3_free(pCur.pKey);
			pCur.pKey = null;
			pCur.eState = (byte)(1);
		}
		public static int sqlite3BtreeClearTable(Btree p, int iTable, long* pnChange)
		{
			int rc = 0;
			BtShared pBt = p.pBt;
			sqlite3BtreeEnter(p);

			rc = (int)(saveAllCursors(pBt, (uint)(iTable), null));
			if ((0) == (rc))
			{
				if ((p.hasIncrblobCur) != 0)
				{
					invalidateIncrblobCursors(p, (uint)(iTable), (long)(0), (int)(1));
				}

				rc = (int)(clearDatabasePage(pBt, (uint)(iTable), (int)(0), pnChange));
			}

			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeClearTableOfCursor(BtCursor pCur)
		{
			return (int)(sqlite3BtreeClearTable(pCur.pBtree, (int)(pCur.pgnoRoot), null));
		}
		public static int sqlite3BtreeClose(Btree p)
		{
			BtShared pBt = p.pBt;

			sqlite3BtreeEnter(p);
			sqlite3BtreeRollback(p, (int)(0), (int)(0));
			sqlite3BtreeLeave(p);

			if ((p.sharable == 0) || ((removeFromSharingList(pBt)) != 0))
			{

				sqlite3PagerClose(pBt.pPager, p.db);
				if (((pBt.xFreeSchema) != null) && ((pBt.pSchema) != null))
				{
					pBt.xFreeSchema(pBt.pSchema);
				}

				sqlite3DbFree(null, pBt.pSchema);
				freeTempSpace(pBt);
				sqlite3_free(pBt);
			}



			if ((p.pPrev) != null)
				p.pPrev.pNext = p.pNext;
			if ((p.pNext) != null)
				p.pNext.pPrev = p.pPrev;
			sqlite3_free(p);
			return (int)(0);
		}
		public static int sqlite3BtreeCloseCursor(BtCursor pCur)
		{
			Btree pBtree = pCur.pBtree;
			if ((pBtree) != null)
			{
				BtShared pBt = pCur.pBt;
				sqlite3BtreeEnter(pBtree);

				if ((pBt.pCursor) == (pCur))
				{
					pBt.pCursor = pCur.pNext;
				}
				else
				{
					BtCursor pPrev = pBt.pCursor;
					do
					{
						if ((pPrev.pNext) == (pCur))
						{
							pPrev.pNext = pCur.pNext;
							break;
						}

						pPrev = pPrev.pNext;
					}
					while ((pPrev) != null);
				}

				btreeReleaseAllCursorPages(pCur);
				unlockBtreeIfUnused(pBt);
				sqlite3_free(pCur.aOverflow);
				sqlite3_free(pCur.pKey);
				if (((pBt.openFlags & 4) != 0) && ((pBt.pCursor) == (null)))
				{

					sqlite3BtreeClose(pBtree);
				}
				else
				{
					sqlite3BtreeLeave(pBtree);
				}

				pCur.pBtree = null;
			}

			return (int)(0);
		}
		public static int sqlite3BtreeCommit(Btree p)
		{
			int rc = 0;
			sqlite3BtreeEnter(p);
			rc = (int)(sqlite3BtreeCommitPhaseOne(p, null));
			if ((rc) == (0))
			{
				rc = (int)(sqlite3BtreeCommitPhaseTwo(p, (int)(0)));
			}

			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeCommitPhaseOne(Btree p, sbyte* zSuperJrnl)
		{
			int rc = (int)(0);
			if ((p.inTrans) == (2))
			{
				BtShared pBt = p.pBt;
				sqlite3BtreeEnter(p);
				if ((pBt.autoVacuum) != 0)
				{
					rc = (int)(autoVacuumCommit(p));
					if (rc != 0)
					{
						sqlite3BtreeLeave(p);
						return (int)(rc);
					}
				}

				if ((pBt.bDoTruncate) != 0)
				{
					sqlite3PagerTruncateImage(pBt.pPager, (uint)(pBt.nPage));
				}

				rc = (int)(sqlite3PagerCommitPhaseOne(pBt.pPager, zSuperJrnl, (int)(0)));
				sqlite3BtreeLeave(p);
			}

			return (int)(rc);
		}
		public static int sqlite3BtreeCommitPhaseTwo(Btree p, int bCleanup)
		{
			if ((p.inTrans) == (0))
				return (int)(0);
			sqlite3BtreeEnter(p);


			if ((p.inTrans) == (2))
			{
				int rc = 0;
				BtShared pBt = p.pBt;


				rc = (int)(sqlite3PagerCommitPhaseTwo(pBt.pPager));
				if ((rc != 0) && ((bCleanup) == (0)))
				{
					sqlite3BtreeLeave(p);
					return (int)(rc);
				}

				p.iBDataVersion--;
				pBt.inTransaction = (byte)(1);
				btreeClearHasContent(pBt);
			}

			btreeEndTransaction(p);
			sqlite3BtreeLeave(p);
			return (int)(0);
		}
		public static int sqlite3BtreeConnectionCount(Btree p)
		{
			return (int)(p.pBt.nRef);
		}
		public static int sqlite3BtreeCopyFile(Btree pTo, Btree pFrom)
		{
			int rc = 0;
			sqlite3_file pFd;
			sqlite3_backup b = new sqlite3_backup();
			sqlite3BtreeEnter(pTo);
			sqlite3BtreeEnter(pFrom);

			pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));
			if ((pFd.pMethods) != null)
			{
				long nByte = (long)(sqlite3BtreeGetPageSize(pFrom) * (long)(sqlite3BtreeLastPage(pFrom)));
				rc = (int)(sqlite3OsFileControl(pFd, (int)(11), &nByte));
				if ((rc) == (12))
					rc = (int)(0);
				if ((rc) != 0)
					goto copy_finished;
			}

			CRuntime.memset(b, (int)(0), (ulong)(sizeof(sqlite3_backup)));
			b.pSrcDb = pFrom.db;
			b.pSrc = pFrom;
			b.pDest = pTo;
			b.iNext = (uint)(1);
			sqlite3_backup_step(b, (int)(0x7FFFFFFF));

			rc = (int)(sqlite3_backup_finish(b));
			if ((rc) == (0))
			{
				pTo.pBt.btsFlags &= (ushort)(~0x0002);
			}
			else
			{
				sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
			}


		copy_finished:
			; sqlite3BtreeLeave(pFrom);
			sqlite3BtreeLeave(pTo);
			return (int)(rc);
		}
		public static int sqlite3BtreeCount(sqlite3 db, BtCursor pCur, long* pnEntry)
		{
			long nEntry = (long)(0);
			int rc = 0;
			rc = (int)(moveToRoot(pCur));
			if ((rc) == (16))
			{
				*pnEntry = (long)(0);
				return (int)(0);
			}

			while (((rc) == (0)) && (0 == 0))
			{
				int iIdx = 0;
				MemPage pPage;
				pPage = pCur.pPage;
				if (((pPage.leaf) != 0) || (pPage.intKey == 0))
				{
					nEntry += (long)(pPage.nCell);
				}

				if ((pPage.leaf) != 0)
				{
					do
					{
						if ((pCur.iPage) == (0))
						{
							*pnEntry = (long)(nEntry);
							return (int)(moveToRoot(pCur));
						}

						moveToParent(pCur);
					}
					while ((pCur.ix) >= (pCur.pPage.nCell));
					pCur.ix++;
					pPage = pCur.pPage;
				}

				iIdx = (int)(pCur.ix);
				if ((iIdx) == (pPage.nCell))
				{
					rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]))));
				}
				else
				{
					rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (iIdx)])))))))));
				}
			}

			return (int)(rc);
		}
		public static int sqlite3BtreeCreateTable(Btree p, uint* piTable, int flags)
		{
			int rc = 0;
			sqlite3BtreeEnter(p);
			rc = (int)(btreeCreateTable(p, piTable, (int)(flags)));
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeCursor(Btree p, uint iTable, int wrFlag, KeyInfo pKeyInfo, BtCursor pCur)
		{
			if ((p.sharable) != 0)
			{
				return (int)(btreeCursorWithLock(p, (uint)(iTable), (int)(wrFlag), pKeyInfo, pCur));
			}
			else
			{
				return (int)(btreeCursor(p, (uint)(iTable), (int)(wrFlag), pKeyInfo, pCur));
			}
		}
		public static int sqlite3BtreeCursorHasHint(BtCursor pCsr, uint mask)
		{
			return (int)((pCsr.hints & mask) != 0);
		}
		public static int sqlite3BtreeCursorHasMoved(BtCursor pCur)
		{



			return (int)(0 != *(byte*)(pCur));
		}
		public static void sqlite3BtreeCursorHintFlags(BtCursor pCur, uint x)
		{

			pCur.hints = (byte)(x);
		}
		public static int sqlite3BtreeCursorIsValidNN(BtCursor pCur)
		{

			return ((pCur.eState) == (0) ? 1 : 0);
		}
		public static void sqlite3BtreeCursorPin(BtCursor pCur)
		{

			pCur.curFlags |= (byte)(0x40);
		}
		public static int sqlite3BtreeCursorRestore(BtCursor pCur, int* pDifferentRow)
		{
			int rc = 0;


			rc = (int)((pCur.eState) >= (3) ? btreeRestoreCursorPosition(pCur) : 0);
			if ((rc) != 0)
			{
				*pDifferentRow = (int)(1);
				return (int)(rc);
			}

			if (pCur.eState != 0)
			{
				*pDifferentRow = (int)(1);
			}
			else
			{
				*pDifferentRow = (int)(0);
			}

			return (int)(0);
		}
		public static int sqlite3BtreeCursorSize()
		{
			return (int)(((sizeof(BtCursor)) + 7) & ~7);
		}
		public static void sqlite3BtreeCursorUnpin(BtCursor pCur)
		{

			pCur.curFlags &= (byte)(~0x40);
		}
		public static void sqlite3BtreeCursorZero(BtCursor p)
		{
			CRuntime.memset(p, (int)(0), ((ulong)((0).pBt)));
		}
		public static int sqlite3BtreeDelete(BtCursor pCur, byte flags)
		{
			Btree p = pCur.pBtree;
			BtShared pBt = p.pBt;
			int rc = 0;
			MemPage pPage;
			byte* pCell;
			int iCellIdx = 0;
			int iCellDepth = 0;
			CellInfo info = new CellInfo();
			byte bPreserve = 0;







			if (pCur.eState != 0)
			{
				if ((pCur.eState) >= (3))
				{
					rc = (int)(btreeRestoreCursorPosition(pCur));

					if (((rc) != 0) || (pCur.eState != 0))
						return (int)(rc);
				}
				else
				{
					return (int)(sqlite3CorruptError((int)(75429)));
				}
			}


			iCellDepth = (int)(pCur.iPage);
			iCellIdx = (int)(pCur.ix);
			pPage = pCur.pPage;
			if ((pPage.nCell) <= (iCellIdx))
			{
				return (int)(sqlite3CorruptError((int)(75438)));
			}

			pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (iCellIdx)])))));
			if (((pPage.nFree) < (0)) && ((btreeComputeFreeSpace(pPage)) != 0))
			{
				return (int)(sqlite3CorruptError((int)(75442)));
			}

			bPreserve = (byte)((flags & 0x02) != 0);
			if ((bPreserve) != 0)
			{
				if (((pPage.leaf == 0) || ((pPage.nFree + cellSizePtr(pPage, pCell) + 2) > ((int)(pBt.usableSize * 2 / 3)))) || ((pPage.nCell) == (1)))
				{
					rc = (int)(saveCursorKey(pCur));
					if ((rc) != 0)
						return (int)(rc);
				}
				else
				{
					bPreserve = (byte)(2);
				}
			}

			if (pPage.leaf == 0)
			{
				rc = (int)(sqlite3BtreePrevious(pCur, (int)(0)));

				if ((rc) != 0)
					return (int)(rc);
			}

			if ((pCur.curFlags & 0x20) != 0)
			{
				rc = (int)(saveAllCursors(pBt, (uint)(pCur.pgnoRoot), pCur));
				if ((rc) != 0)
					return (int)(rc);
			}

			if (((pCur.pKeyInfo) == (null)) && ((p.hasIncrblobCur) != 0))
			{
				invalidateIncrblobCursors(p, (uint)(pCur.pgnoRoot), (long)(pCur.info.nKey), (int)(0));
			}

			rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
			if ((rc) != 0)
				return (int)(rc);
			pPage.xParseCell(pPage, pCell, &info);
			if (info.nLocal != info.nPayload)
			{
				rc = (int)(clearCellOverflow(pPage, pCell, &info));
			}
			else
			{
				rc = (int)(0);
			}

			dropCell(pPage, (int)(iCellIdx), (int)(info.nSize), &rc);
			if ((rc) != 0)
				return (int)(rc);
			if (pPage.leaf == 0)
			{
				MemPage pLeaf = pCur.pPage;
				int nCell = 0;
				uint n = 0;
				byte* pTmp;
				if ((pLeaf.nFree) < (0))
				{
					rc = (int)(btreeComputeFreeSpace(pLeaf));
					if ((rc) != 0)
						return (int)(rc);
				}

				if ((iCellDepth) < (pCur.iPage - 1))
				{
					n = (uint)(pCur.apPage[iCellDepth + 1].pgno);
				}
				else
				{
					n = (uint)(pCur.pPage.pgno);
				}

				pCell = ((pLeaf).aData + ((pLeaf).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pLeaf).aCellIdx[2 * (pLeaf.nCell - 1)])))));
				if ((pCell) < (&pLeaf.aData[4]))
					return (int)(sqlite3CorruptError((int)(75532)));
				nCell = (int)(pLeaf.xCellSize(pLeaf, pCell));

				pTmp = pBt.pTmpSpace;

				rc = (int)(sqlite3PagerWrite(pLeaf.pDbPage));
				if ((rc) == (0))
				{
					insertCell(pPage, (int)(iCellIdx), pCell - 4, (int)(nCell + 4), pTmp, (uint)(n), &rc);
				}

				dropCell(pLeaf, (int)(pLeaf.nCell - 1), (int)(nCell), &rc);
				if ((rc) != 0)
					return (int)(rc);
			}

			rc = (int)(balance(pCur));
			if (((rc) == (0)) && ((pCur.iPage) > (iCellDepth)))
			{
				releasePageNotNull(pCur.pPage);
				pCur.iPage--;
				while ((pCur.iPage) > (iCellDepth))
				{
					releasePage(pCur.apPage[pCur.iPage--]);
				}

				pCur.pPage = pCur.apPage[pCur.iPage];
				rc = (int)(balance(pCur));
			}

			if ((rc) == (0))
			{
				if ((bPreserve) > (1))
				{



					pCur.eState = (byte)(2);
					if ((iCellIdx) >= (pPage.nCell))
					{
						pCur.skipNext = (int)(-1);
						pCur.ix = (ushort)(pPage.nCell - 1);
					}
					else
					{
						pCur.skipNext = (int)(1);
					}
				}
				else
				{
					rc = (int)(moveToRoot(pCur));
					if ((bPreserve) != 0)
					{
						btreeReleaseAllCursorPages(pCur);
						pCur.eState = (byte)(3);
					}

					if ((rc) == (16))
						rc = (int)(0);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3BtreeDropTable(Btree p, int iTable, int* piMoved)
		{
			int rc = 0;
			sqlite3BtreeEnter(p);
			rc = (int)(btreeDropTable(p, (uint)(iTable), piMoved));
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static void sqlite3BtreeEnter(Btree p)
		{









			if (p.sharable == 0)
				return;
			p.wantToLock++;
			if ((p.locked) != 0)
				return;
			btreeLockCarefully(p);
		}
		public static void sqlite3BtreeEnterAll(sqlite3 db)
		{
			if ((db.noSharedCache) == (0))
				btreeEnterAll(db);
		}
		public static void sqlite3BtreeEnterCursor(BtCursor pCur)
		{
			sqlite3BtreeEnter(pCur.pBtree);
		}
		public static int sqlite3BtreeEof(BtCursor pCur)
		{
			return (int)(0 != pCur.eState);
		}
		public static BtCursor sqlite3BtreeFakeValidCursor()
		{

			return (BtCursor)(&sqlite3BtreeFakeValidCursor_fakeCursor);
		}
		public static int sqlite3BtreeFirst(BtCursor pCur, int* pRes)
		{
			int rc = 0;


			rc = (int)(moveToRoot(pCur));
			if ((rc) == (0))
			{

				*pRes = (int)(0);
				rc = (int)(moveToLeftmost(pCur));
			}
			else if ((rc) == (16))
			{

				*pRes = (int)(1);
				rc = (int)(0);
			}

			return (int)(rc);
		}
		public static int sqlite3BtreeGetAutoVacuum(Btree p)
		{
			int rc = 0;
			sqlite3BtreeEnter(p);
			rc = (int)((!p.pBt.autoVacuum) ? 0 : (!p.pBt.incrVacuum) ? 1 : 2);
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static sbyte* sqlite3BtreeGetFilename(Btree p)
		{

			return sqlite3PagerFilename(p.pBt.pPager, (int)(1));
		}
		public static sbyte* sqlite3BtreeGetJournalname(Btree p)
		{

			return sqlite3PagerJournalname(p.pBt.pPager);
		}
		public static void sqlite3BtreeGetMeta(Btree p, int idx, uint* pMeta)
		{
			BtShared pBt = p.pBt;
			sqlite3BtreeEnter(p);




			if ((idx) == (15))
			{
				*pMeta = (uint)(sqlite3PagerDataVersion(pBt.pPager) + p.iBDataVersion);
			}
			else
			{
				*pMeta = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36 + idx * 4]));
			}

			sqlite3BtreeLeave(p);
		}
		public static int sqlite3BtreeGetPageSize(Btree p)
		{
			return (int)(p.pBt.pageSize);
		}
		public static int sqlite3BtreeGetRequestedReserve(Btree p)
		{
			int n1 = 0; int n2 = 0;
			sqlite3BtreeEnter(p);
			n1 = ((int)(p.pBt.nReserveWanted));
			n2 = (int)(sqlite3BtreeGetReserveNoMutex(p));
			sqlite3BtreeLeave(p);
			return (int)((n1) > (n2) ? n1 : n2);
		}
		public static int sqlite3BtreeGetReserveNoMutex(Btree p)
		{
			int n = 0;

			n = (int)(p.pBt.pageSize - p.pBt.usableSize);
			return (int)(n);
		}
		public static void sqlite3BtreeIncrblobCursor(BtCursor pCur)
		{
			pCur.curFlags |= (byte)(0x10);
			pCur.pBtree.hasIncrblobCur = (byte)(1);
		}
		public static int sqlite3BtreeIncrVacuum(Btree p)
		{
			int rc = 0;
			BtShared pBt = p.pBt;
			sqlite3BtreeEnter(p);

			if (pBt.autoVacuum == 0)
			{
				rc = (int)(101);
			}
			else
			{
				uint nOrig = (uint)(btreePagecount(pBt));
				uint nFree = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36]));
				uint nFin = (uint)(finalDbSize(pBt, (uint)(nOrig), (uint)(nFree)));
				if (((nOrig) < (nFin)) || ((nFree) >= (nOrig)))
				{
					rc = (int)(sqlite3CorruptError((int)(70101)));
				}
				else if ((nFree) > (0))
				{
					rc = (int)(saveAllCursors(pBt, (uint)(0), null));
					if ((rc) == (0))
					{
						invalidateAllOverflowCache(pBt);
						rc = (int)(incrVacuumStep(pBt, (uint)(nFin), (uint)(nOrig), (int)(0)));
					}

					if ((rc) == (0))
					{
						rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
						sqlite3Put4byte(&pBt.pPage1.aData[28], (uint)(pBt.nPage));
					}
				}
				else
				{
					rc = (int)(101);
				}
			}

			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeIndexMoveto(BtCursor pCur, UnpackedRecord pIdxKey, int* pRes)
		{
			int rc = 0;
			delegate156 xRecordCompare;




			xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
			pIdxKey.errCode = (byte)(0);

			rc = (int)(moveToRoot(pCur));
			if ((rc) != 0)
			{
				if ((rc) == (16))
				{

					*pRes = (int)(-1);
					return (int)(0);
				}

				return (int)(rc);
			}







			for (; ; )
			{
				int lwr = 0;
				int upr = 0;
				int idx = 0;
				int c = 0;
				uint chldPg = 0;
				MemPage pPage = pCur.pPage;
				byte* pCell;


				lwr = (int)(0);
				upr = (int)(pPage.nCell - 1);
				idx = (int)(upr >> 1);
				for (; ; )
				{
					int nCell = 0;
					pCell = ((pPage).aDataOfst + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))));
					nCell = (int)(pCell[0]);
					if ((nCell) <= (pPage.max1bytePayload))
					{
						c = (int)(xRecordCompare((int)(nCell), (void*)(&pCell[1]), pIdxKey));
					}
					else if (((pCell[1] & 0x80) == 0) && ((nCell = (int)(((nCell & 0x7f) << 7) + pCell[1])) <= (pPage.maxLocal)))
					{
						c = (int)(xRecordCompare((int)(nCell), (void*)(&pCell[2]), pIdxKey));
					}
					else
					{
						void* pCellKey;
						byte* pCellBody = pCell - pPage.childPtrSize;
						int nOverrun = (int)(18);
						pPage.xParseCell(pPage, pCellBody, &pCur.info);
						nCell = ((int)(pCur.info.nKey));
						if (((nCell) < (2)) || ((nCell / pCur.pBt.usableSize) > (pCur.pBt.nPage)))
						{
							rc = (int)(sqlite3CorruptError((int)(71924)));
							goto moveto_index_finish;
						}

						pCellKey = sqlite3Malloc((ulong)(nCell + nOverrun));
						if ((pCellKey) == (null))
						{
							rc = (int)(7);
							goto moveto_index_finish;
						}

						pCur.ix = ((ushort)(idx));
						rc = (int)(accessPayload(pCur, (uint)(0), (uint)(nCell), (byte*)(pCellKey), (int)(0)));
						CRuntime.memset(((byte*)(pCellKey)) + nCell, (int)(0), (ulong)(nOverrun));
						pCur.curFlags &= (byte)(~0x04);
						if ((rc) != 0)
						{
							sqlite3_free(pCellKey);
							goto moveto_index_finish;
						}

						c = (int)(sqlite3VdbeRecordCompare((int)(nCell), pCellKey, pIdxKey));
						sqlite3_free(pCellKey);
					}


					if ((c) < (0))
					{
						lwr = (int)(idx + 1);
					}
					else if ((c) > (0))
					{
						upr = (int)(idx - 1);
					}
					else
					{

						*pRes = (int)(0);
						rc = (int)(0);
						pCur.ix = ((ushort)(idx));
						if ((pIdxKey.errCode) != 0)
							rc = (int)(sqlite3CorruptError((int)(71956)));
						goto moveto_index_finish;
					}

					if ((lwr) > (upr))
						break;

					idx = (int)((lwr + upr) >> 1);
				}



				if ((pPage.leaf) != 0)
				{

					pCur.ix = ((ushort)(idx));
					*pRes = (int)(c);
					rc = (int)(0);
					goto moveto_index_finish;
				}

				if ((lwr) >= (pPage.nCell))
				{
					chldPg = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				}
				else
				{
					chldPg = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (lwr)])))))));
				}

				pCur.ix = ((ushort)(lwr));
				rc = (int)(moveToChild(pCur, (uint)(chldPg)));
				if ((rc) != 0)
					break;
			}

		moveto_index_finish:
			; pCur.info.nSize = (ushort)(0);

			return (int)(rc);
		}
		public static int sqlite3BtreeInsert(BtCursor pCur, BtreePayload pX, int flags, int seekResult)
		{
			int rc = 0;
			int loc = (int)(seekResult);
			int szNew = (int)(0);
			int idx = 0;
			MemPage pPage;
			Btree p = pCur.pBtree;
			BtShared pBt = p.pBt;
			byte* oldCell;
			byte* newCell = null;


			if ((pCur.curFlags & 0x20) != 0)
			{
				rc = (int)(saveAllCursors(pBt, (uint)(pCur.pgnoRoot), pCur));
				if ((rc) != 0)
					return (int)(rc);
				if (((loc) != 0) && ((pCur.iPage) < (0)))
				{
					return (int)(sqlite3CorruptError((int)(75026)));
				}
			}

			if ((pCur.eState) >= (3))
			{
				rc = (int)(moveToRoot(pCur));
				if (((rc) != 0) && (rc != 16))
					return (int)(rc);
			}





			if ((pCur.pKeyInfo) == (null))
			{

				if ((p.hasIncrblobCur) != 0)
				{
					invalidateIncrblobCursors(p, (uint)(pCur.pgnoRoot), (long)(pX.nKey), (int)(0));
				}

				if (((pCur.curFlags & 0x02) != 0) && ((pX.nKey) == (pCur.info.nKey)))
				{

					if ((pCur.info.nSize != 0) && ((pCur.info.nPayload) == ((uint)(pX.nData) + pX.nZero)))
					{
						return (int)(btreeOverwriteCell(pCur, pX));
					}


				}
				else if ((loc) == (0))
				{
					rc = (int)(sqlite3BtreeTableMoveto(pCur, (long)(pX.nKey), (int)((flags & 0x08) != 0), &loc));
					if ((rc) != 0)
						return (int)(rc);
				}
			}
			else
			{

				if (((loc) == (0)) && ((flags & 0x02) == (0)))
				{
					if ((pX.nMem) != 0)
					{
						UnpackedRecord r = new UnpackedRecord();
						r.pKeyInfo = pCur.pKeyInfo;
						r.aMem = pX.aMem;
						r.nField = (ushort)(pX.nMem);
						r.default_rc = (sbyte)(0);
						r.eqSeen = (byte)(0);
						rc = (int)(sqlite3BtreeIndexMoveto(pCur, r, &loc));
					}
					else
					{
						rc = (int)(btreeMoveto(pCur, pX.pKey, (long)(pX.nKey), (int)((flags & 0x08) != 0), &loc));
					}

					if ((rc) != 0)
						return (int)(rc);
				}

				if ((loc) == (0))
				{
					getCellInfo(pCur);
					if ((pCur.info.nKey) == (pX.nKey))
					{
						BtreePayload x2 = new BtreePayload();
						x2.pData = pX.pKey;
						x2.nData = (int)(pX.nKey);
						x2.nZero = (int)(0);
						return (int)(btreeOverwriteCell(pCur, x2));
					}
				}
			}


			pPage = pCur.pPage;


			if ((pPage.nFree) < (0))
			{
				if ((pCur.eState) > (1))
				{
					rc = (int)(sqlite3CorruptError((int)(75143)));
				}
				else
				{
					rc = (int)(btreeComputeFreeSpace(pPage));
				}

				if ((rc) != 0)
					return (int)(rc);
			}


			newCell = pBt.pTmpSpace;

			if ((flags & 0x80) != 0)
			{
				rc = (int)(0);
				szNew = (int)(pBt.nPreformatSize);
				if ((szNew) < (4))
					szNew = (int)(4);
				if (((pBt.autoVacuum) != 0) && ((szNew) > (pPage.maxLocal)))
				{
					CellInfo info = new CellInfo();
					pPage.xParseCell(pPage, newCell, &info);
					if (info.nPayload != info.nLocal)
					{
						uint ovfl = (uint)(sqlite3Get4byte(&newCell[szNew - 4]));
						ptrmapPut(pBt, (uint)(ovfl), (byte)(3), (uint)(pPage.pgno), &rc);
					}
				}
			}
			else
			{
				rc = (int)(fillInCell(pPage, newCell, pX, &szNew));
			}

			if ((rc) != 0)
				goto end_insert;


			idx = (int)(pCur.ix);
			if ((loc) == (0))
			{
				CellInfo info = new CellInfo();

				if ((idx) >= (pPage.nCell))
				{
					return (int)(sqlite3CorruptError((int)(75179)));
				}

				rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
				if ((rc) != 0)
				{
					goto end_insert;
				}

				oldCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))));
				if (pPage.leaf == 0)
				{
					CRuntime.memcpy(newCell, oldCell, (ulong)(4));
				}

				pPage.xParseCell(pPage, oldCell, &info);
				if (info.nLocal != info.nPayload)
				{
					rc = (int)(clearCellOverflow(pPage, oldCell, &info));
				}
				else
				{
					rc = (int)(0);
				}

				(pCur.curFlags &= (byte)(~0x04));
				if ((((info.nSize) == (szNew)) && ((info.nLocal) == (info.nPayload))) && (((pBt.autoVacuum) == 0) || ((szNew) < (pPage.minLocal))))
				{

					if ((oldCell) < (pPage.aData + pPage.hdrOffset + 10))
					{
						return (int)(sqlite3CorruptError((int)(75206)));
					}

					if ((oldCell + szNew) > (pPage.aDataEnd))
					{
						return (int)(sqlite3CorruptError((int)(75209)));
					}

					CRuntime.memcpy(oldCell, newCell, (ulong)(szNew));
					return (int)(0);
				}

				dropCell(pPage, (int)(idx), (int)(info.nSize), &rc);
				if ((rc) != 0)
					goto end_insert;
			}
			else if (((loc) < (0)) && ((pPage.nCell) > (0)))
			{

				idx = (int)(++pCur.ix);
				pCur.curFlags &= (byte)(~0x02);
			}
			else
			{

			}

			insertCell(pPage, (int)(idx), newCell, (int)(szNew), null, (uint)(0), &rc);


			pCur.info.nSize = (ushort)(0);
			if ((pPage.nOverflow) != 0)
			{

				pCur.curFlags &= (byte)(~(0x02));
				rc = (int)(balance(pCur));
				pCur.pPage.nOverflow = (byte)(0);
				pCur.eState = (byte)(1);
				if (((flags & 0x02) != 0) && ((rc) == (0)))
				{
					btreeReleaseAllCursorPages(pCur);
					if ((pCur.pKeyInfo) != null)
					{

						pCur.pKey = sqlite3Malloc((ulong)(pX.nKey));
						if ((pCur.pKey) == (null))
						{
							rc = (int)(7);
						}
						else
						{
							CRuntime.memcpy(pCur.pKey, pX.pKey, (ulong)(pX.nKey));
						}
					}

					pCur.eState = (byte)(3);
					pCur.nKey = (long)(pX.nKey);
				}
			}


		end_insert:
			; return (int)(rc);
		}
		public static long sqlite3BtreeIntegerKey(BtCursor pCur)
		{



			getCellInfo(pCur);
			return (long)(pCur.info.nKey);
		}
		public static sbyte* sqlite3BtreeIntegrityCheck(sqlite3 db, Btree p, uint* aRoot, int nRoot, int mxErr, int* pnErr)
		{
			uint i = 0;
			IntegrityCk sCheck = new IntegrityCk();
			BtShared pBt = p.pBt;
			ulong savedDbFlags = (ulong)(pBt.db.flags);
			sbyte* zErr = stackalloc sbyte[100];
			int bPartial = (int)(0);
			int bCkFreelist = (int)(1);

			if ((aRoot[0]) == (0))
			{

				bPartial = (int)(1);
				if (aRoot[1] != 1)
					bCkFreelist = (int)(0);
			}

			sqlite3BtreeEnter(p);


			sCheck.db = db;
			sCheck.pBt = pBt;
			sCheck.pPager = pBt.pPager;
			sCheck.nPage = (uint)(btreePagecount(sCheck.pBt));
			sCheck.mxErr = (int)(mxErr);
			sCheck.nErr = (int)(0);
			sCheck.bOomFault = (int)(0);
			sCheck.zPfx = null;
			sCheck.v1 = (uint)(0);
			sCheck.v2 = (int)(0);
			sCheck.aPgRef = null;
			sCheck.heap = null;
			sqlite3StrAccumInit(sCheck.errMsg, null, zErr, (int)(100 * sizeof(sbyte)), (int)(1000000000));
			sCheck.errMsg.printfFlags = (byte)(0x01);
			if ((sCheck.nPage) == (0))
			{
				goto integrity_ck_cleanup;
			}

			sCheck.aPgRef = sqlite3MallocZero((ulong)((sCheck.nPage / 8) + 1));
			if (sCheck.aPgRef == null)
			{
				sCheck.bOomFault = (int)(1);
				goto integrity_ck_cleanup;
			}

			sCheck.heap = (uint*)(sqlite3PageMalloc((int)(pBt.pageSize)));
			if ((sCheck.heap) == (null))
			{
				sCheck.bOomFault = (int)(1);
				goto integrity_ck_cleanup;
			}

			i = (uint)((sqlite3PendingByte / ((pBt).pageSize)) + 1);
			if ((i) <= (sCheck.nPage))
				setPageReferenced(sCheck, (uint)(i));
			if ((bCkFreelist) != 0)
			{
				sCheck.zPfx = "Main freelist: ";
				checkList(sCheck, (int)(1), (uint)(sqlite3Get4byte(&pBt.pPage1.aData[32])), (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36])));
				sCheck.zPfx = null;
			}

			if (bPartial == 0)
			{
				if ((pBt.autoVacuum) != 0)
				{
					uint mx = (uint)(0);
					uint mxInHdr = 0;
					for (i = (uint)(0); ((int)(i)) < (nRoot); i++)
					{
						if ((mx) < (aRoot[i]))
							mx = (uint)(aRoot[i]);
					}

					mxInHdr = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[52]));
					if (mx != mxInHdr)
					{
						checkAppendMsg(sCheck, "max rootpage (%d) disagrees with header (%d)", (uint)(mx), (uint)(mxInHdr));
					}
				}
				else if (sqlite3Get4byte(&pBt.pPage1.aData[64]) != 0)
				{
					checkAppendMsg(sCheck, "incremental_vacuum enabled with a max rootpage of zero");
				}
			}

			pBt.db.flags &= (ulong)(~(ulong)(0x00200000));
			for (i = (uint)(0); (((int)(i)) < (nRoot)) && ((sCheck.mxErr) != 0); i++)
			{
				long notUsed = 0;
				if ((aRoot[i]) == (0))
					continue;
				if ((((pBt.autoVacuum) != 0) && ((aRoot[i]) > (1))) && (bPartial == 0))
				{
					checkPtrmap(sCheck, (uint)(aRoot[i]), (byte)(1), (uint)(0));
				}

				checkTreePage(sCheck, (uint)(aRoot[i]), &notUsed, (long)(0xffffffff | (((long)(0x7fffffff)) << 32)));
			}

			pBt.db.flags = (ulong)(savedDbFlags);
			if (bPartial == 0)
			{
				for (i = (uint)(1); ((i) <= (sCheck.nPage)) && ((sCheck.mxErr) != 0); i++)
				{
					if (((getPageReferenced(sCheck, (uint)(i))) == (0)) && ((ptrmapPageno(pBt, (uint)(i)) != i) || (pBt.autoVacuum == 0)))
					{
						checkAppendMsg(sCheck, "Page %d is never used", (uint)(i));
					}

					if ((getPageReferenced(sCheck, (uint)(i)) != 0) && (((ptrmapPageno(pBt, (uint)(i))) == (i)) && ((pBt.autoVacuum) != 0)))
					{
						checkAppendMsg(sCheck, "Pointer map page %d is referenced", (uint)(i));
					}
				}
			}

		integrity_ck_cleanup:
			; sqlite3PageFree(sCheck.heap);
			sqlite3_free(sCheck.aPgRef);
			if ((sCheck.bOomFault) != 0)
			{
				sqlite3_str_reset(sCheck.errMsg);
				sCheck.nErr++;
			}

			*pnErr = (int)(sCheck.nErr);
			if ((sCheck.nErr) == (0))
				sqlite3_str_reset(sCheck.errMsg);

			sqlite3BtreeLeave(p);
			return sqlite3StrAccumFinish(sCheck.errMsg);
		}
		public static int sqlite3BtreeIsInBackup(Btree p)
		{


			return (int)(p.nBackup != 0);
		}
		public static int sqlite3BtreeIsReadonly(Btree p)
		{
			return (int)((p.pBt.btsFlags & 0x0001) != 0);
		}
		public static int sqlite3BtreeLast(BtCursor pCur, int* pRes)
		{
			int rc = 0;


			if (((0) == (pCur.eState)) && ((pCur.curFlags & 0x08) != 0))
			{
				*pRes = (int)(0);
				return (int)(0);
			}

			rc = (int)(moveToRoot(pCur));
			if ((rc) == (0))
			{

				*pRes = (int)(0);
				rc = (int)(moveToRightmost(pCur));
				if ((rc) == (0))
				{
					pCur.curFlags |= (byte)(0x08);
				}
				else
				{
					pCur.curFlags &= (byte)(~0x08);
				}
			}
			else if ((rc) == (16))
			{

				*pRes = (int)(1);
				rc = (int)(0);
			}

			return (int)(rc);
		}
		public static uint sqlite3BtreeLastPage(Btree p)
		{

			return (uint)(btreePagecount(p.pBt));
		}
		public static void sqlite3BtreeLeave(Btree p)
		{

			if ((p.sharable) != 0)
			{

				p.wantToLock--;
				if ((p.wantToLock) == (0))
				{
					unlockBtreeMutex(p);
				}
			}
		}
		public static void sqlite3BtreeLeaveAll(sqlite3 db)
		{
			if ((db.noSharedCache) == (0))
				btreeLeaveAll(db);
		}
		public static void sqlite3BtreeLeaveCursor(BtCursor pCur)
		{
			sqlite3BtreeLeave(pCur.pBtree);
		}
		public static int sqlite3BtreeLockTable(Btree p, int iTab, byte isWriteLock)
		{
			int rc = (int)(0);

			if ((p.sharable) != 0)
			{
				byte lockType = (byte)(1 + isWriteLock);


				sqlite3BtreeEnter(p);
				rc = (int)(querySharedCacheTableLock(p, (uint)(iTab), (byte)(lockType)));
				if ((rc) == (0))
				{
					rc = (int)(setSharedCacheTableLock(p, (uint)(iTab), (byte)(lockType)));
				}

				sqlite3BtreeLeave(p);
			}

			return (int)(rc);
		}
		public static uint sqlite3BtreeMaxPageCount(Btree p, uint mxPage)
		{
			uint n = 0;
			sqlite3BtreeEnter(p);
			n = (uint)(sqlite3PagerMaxPageCount(p.pBt.pPager, (uint)(mxPage)));
			sqlite3BtreeLeave(p);
			return (uint)(n);
		}
		public static long sqlite3BtreeMaxRecordSize(BtCursor pCur)
		{


			return (long)(pCur.pBt.pageSize * (long)(pCur.pBt.nPage));
		}
		public static int sqlite3BtreeNewDb(Btree p)
		{
			int rc = 0;
			sqlite3BtreeEnter(p);
			p.pBt.nPage = (uint)(0);
			rc = (int)(newDatabase(p.pBt));
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeNext(BtCursor pCur, int flags)
		{
			MemPage pPage;
			(void)(flags);


			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x02 | 0x04));
			if (pCur.eState != 0)
				return (int)(btreeNext(pCur));
			pPage = pCur.pPage;
			if ((++pCur.ix) >= (pPage.nCell))
			{
				pCur.ix--;
				return (int)(btreeNext(pCur));
			}

			if ((pPage.leaf) != 0)
			{
				return (int)(0);
			}
			else
			{
				return (int)(moveToLeftmost(pCur));
			}
		}
		public static int sqlite3BtreeOpen(sqlite3_vfs pVfs, sbyte* zFilename, sqlite3 db, Btree ppBtree, int flags, int vfsFlags)
		{
			BtShared pBt = null;
			Btree p;
			sqlite3_mutex* mutexOpen = null;
			int rc = (int)(0);
			byte nReserve = 0;
			byte* zDbHeader = stackalloc byte[100];
			int isTempDb = (int)(((zFilename) == (null)) || ((zFilename[0]) == (0)) ? 1 : 0);
			int isMemdb = (int)(((((zFilename) != null) && ((CRuntime.strcmp(zFilename, ":memory:")) == (0))) || (((isTempDb) != 0) && ((sqlite3TempInMemory(db)) != 0))) || ((vfsFlags & 0x00000080) != 0) ? 1 : 0);






			if ((isMemdb) != 0)
			{
				flags |= (int)(2);
			}

			if (((vfsFlags & 0x00000100) != 0) && (((isMemdb) != 0) || ((isTempDb) != 0)))
			{
				vfsFlags = (int)((vfsFlags & ~0x00000100) | 0x00000200);
			}

			p = sqlite3MallocZero((ulong)(sizeof(Btree)));
			if (p == null)
			{
				return (int)(7);
			}

			p.inTrans = (byte)(0);
			p.db = db;
			p. lock .pBtree = p ;
			p. lock .iTable = (uint)(1) ;
			if (((isTempDb) == (0)) && (((isMemdb) == (0)) || ((vfsFlags & 0x00000040) != 0)))
			{
				if ((vfsFlags & 0x00020000) != 0)
				{
					int nFilename = (int)(sqlite3Strlen30(zFilename) + 1);
					int nFullPathname = (int)(pVfs.mxPathname + 1);
					sbyte* zFullPathname = sqlite3Malloc((ulong)((nFullPathname) > (nFilename) ? (nFullPathname) : (nFilename)));
					sqlite3_mutex* mutexShared;
					p.sharable = (byte)(1);
					if (zFullPathname == null)
					{
						sqlite3_free(p);
						return (int)(7);
					}

					if ((isMemdb) != 0)
					{
						CRuntime.memcpy(zFullPathname, zFilename, (ulong)(nFilename));
					}
					else
					{
						rc = (int)(sqlite3OsFullPathname(pVfs, zFilename, (int)(nFullPathname), zFullPathname));
						if ((rc) != 0)
						{
							if ((rc) == (0 | (2 << 8)))
							{
								rc = (int)(0);
							}
							else
							{
								sqlite3_free(zFullPathname);
								sqlite3_free(p);
								return (int)(rc);
							}
						}
					}

					mutexOpen = sqlite3MutexAlloc((int)(4));
					sqlite3_mutex_enter(mutexOpen);
					mutexShared = sqlite3MutexAlloc((int)(2));
					sqlite3_mutex_enter(mutexShared);
					for (pBt = sqlite3SharedCacheList; pBt; pBt = pBt.pNext)
					{

						if (((0) == (CRuntime.strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager, (int)(0))))) && ((sqlite3PagerVfs(pBt.pPager)) == (pVfs)))
						{
							int iDb = 0;
							for (iDb = (int)(db.nDb - 1); (iDb) >= (0); iDb--)
							{
								Btree pExisting = db.aDb[iDb].pBt;
								if (((pExisting) != null) && ((pExisting.pBt) == (pBt)))
								{
									sqlite3_mutex_leave(mutexShared);
									sqlite3_mutex_leave(mutexOpen);
									sqlite3_free(zFullPathname);
									sqlite3_free(p);
									return (int)(19);
								}
							}

							p.pBt = pBt;
							pBt.nRef++;
							break;
						}
					}

					sqlite3_mutex_leave(mutexShared);
					sqlite3_free(zFullPathname);
				}
			}

			if ((pBt) == (null))
			{





				pBt = sqlite3MallocZero((ulong)(sizeof(BtShared)));
				if ((pBt) == (null))
				{
					rc = (int)(7);
					goto btree_open_out;
				}

				rc = (int)(sqlite3PagerOpen(pVfs, pBt.pPager, zFilename, (int)(sizeof(MemPage)), (int)(flags), (int)(vfsFlags), pageReinit));
				if ((rc) == (0))
				{
					sqlite3PagerSetMmapLimit(pBt.pPager, (long)(db.szMmap));
					rc = (int)(sqlite3PagerReadFileheader(pBt.pPager, (int)(100 * sizeof(byte)), zDbHeader));
				}

				if (rc != 0)
				{
					goto btree_open_out;
				}

				pBt.openFlags = ((byte)(flags));
				pBt.db = db;
				sqlite3PagerSetBusyHandler(pBt.pPager, btreeInvokeBusyHandler, pBt);
				p.pBt = pBt;
				pBt.pCursor = null;
				pBt.pPage1 = null;
				if ((sqlite3PagerIsreadonly(pBt.pPager)) != 0)
					pBt.btsFlags |= (ushort)(0x0001);
				pBt.pageSize = (uint)((zDbHeader[16] << 8) | (zDbHeader[17] << 16));
				if ((((pBt.pageSize) < (512)) || ((pBt.pageSize) > (65536))) || (((pBt.pageSize - 1) & pBt.pageSize) != 0))
				{
					pBt.pageSize = (uint)(0);
					if (((zFilename) != null) && (isMemdb == 0))
					{
						pBt.autoVacuum = (byte)((0) != 0 ? 1 : 0);
						pBt.incrVacuum = (byte)((0) == (2) ? 1 : 0);
					}

					nReserve = (byte)(0);
				}
				else
				{
					nReserve = (byte)(zDbHeader[20]);
					pBt.btsFlags |= (ushort)(0x0002);
					pBt.autoVacuum = (byte)((sqlite3Get4byte(&zDbHeader[36 + 4 * 4])) != 0 ? 1 : 0);
					pBt.incrVacuum = (byte)((sqlite3Get4byte(&zDbHeader[36 + 7 * 4])) != 0 ? 1 : 0);
				}

				rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, (int)(nReserve)));
				if ((rc) != 0)
					goto btree_open_out;
				pBt.usableSize = (uint)(pBt.pageSize - nReserve);

				pBt.nRef = (int)(1);
				if ((p.sharable) != 0)
				{
					sqlite3_mutex* mutexShared;
					mutexShared = sqlite3MutexAlloc((int)(2));
					if (((1) != 0) && ((sqlite3Config.bCoreMutex) != 0))
					{
						pBt.mutex = sqlite3MutexAlloc((int)(0));
						if ((pBt.mutex) == (null))
						{
							rc = (int)(7);
							goto btree_open_out;
						}
					}

					sqlite3_mutex_enter(mutexShared);
					pBt.pNext = sqlite3SharedCacheList;
					sqlite3SharedCacheList = pBt;
					sqlite3_mutex_leave(mutexShared);
				}
			}

			if ((p.sharable) != 0)
			{
				int i = 0;
				Btree pSib;
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if (((pSib = db.aDb[i].pBt) != null) && ((pSib.sharable) != 0))
					{
						while ((pSib.pPrev) != null)
						{
							pSib = pSib.pPrev;
						}

						if (((ulong)(p.pBt)) < ((ulong)(pSib.pBt)))
						{
							p.pNext = pSib;
							p.pPrev = null;
							pSib.pPrev = p;
						}
						else
						{
							while (((pSib.pNext) != null) && (((ulong)(pSib.pNext.pBt)) < ((ulong)(p.pBt))))
							{
								pSib = pSib.pNext;
							}

							p.pNext = pSib.pNext;
							p.pPrev = pSib;
							if ((p.pNext) != null)
							{
								p.pNext.pPrev = p;
							}

							pSib.pNext = p;
						}

						break;
					}
				}
			}

			ppBtree = p;
		btree_open_out:
			; if (rc != 0) { if (((pBt) != null) && ((pBt.pPager) != null)) { sqlite3PagerClose(pBt.pPager, null); } sqlite3_free(pBt); sqlite3_free(p); ppBtree = null; } else { sqlite3_file pFile; if ((sqlite3BtreeSchema(p, (int)(0), null)) == (null)) { sqlite3BtreeSetCacheSize(p, (int)(-2000)); } pFile = sqlite3PagerFile(pBt.pPager); if ((pFile.pMethods) != null) { sqlite3OsFileControlHint(pFile, (int)(30), (void*)(pBt.db)); } }
			if ((mutexOpen) != null)
			{

				sqlite3_mutex_leave(mutexOpen);
			}


			return (int)(rc);
		}
		public static Pager sqlite3BtreePager(Btree p)
		{
			return p.pBt.pPager;
		}
		public static int sqlite3BtreePayload(BtCursor pCur, uint offset, uint amt, void* pBuf)
		{



			return (int)(accessPayload(pCur, (uint)(offset), (uint)(amt), (byte*)(pBuf), (int)(0)));
		}
		public static int sqlite3BtreePayloadChecked(BtCursor pCur, uint offset, uint amt, void* pBuf)
		{
			if ((pCur.eState) == (0))
			{

				return (int)(accessPayload(pCur, (uint)(offset), (uint)(amt), pBuf, (int)(0)));
			}
			else
			{
				return (int)(accessPayloadChecked(pCur, (uint)(offset), (uint)(amt), pBuf));
			}
		}
		public static void* sqlite3BtreePayloadFetch(BtCursor pCur, uint* pAmt)
		{
			return fetchPayload(pCur, pAmt);
		}
		public static uint sqlite3BtreePayloadSize(BtCursor pCur)
		{


			getCellInfo(pCur);
			return (uint)(pCur.info.nPayload);
		}
		public static int sqlite3BtreePrevious(BtCursor pCur, int flags)
		{


			(void)(flags);
			pCur.curFlags &= (byte)(~(0x08 | 0x04 | 0x02));
			pCur.info.nSize = (ushort)(0);
			if (((pCur.eState != 0) || ((pCur.ix) == (0))) || ((pCur.pPage.leaf) == (0)))
			{
				return (int)(btreePrevious(pCur));
			}

			pCur.ix--;
			return (int)(0);
		}
		public static int sqlite3BtreePutData(BtCursor pCsr, uint offset, uint amt, void* z)
		{
			int rc = 0;



			rc = (int)((pCsr.eState) >= (3) ? btreeRestoreCursorPosition(pCsr) : 0);
			if (rc != 0)
			{
				return (int)(rc);
			}


			if (pCsr.eState != 0)
			{
				return (int)(4);
			}

			saveAllCursors(pCsr.pBt, (uint)(pCsr.pgnoRoot), pCsr);

			if ((pCsr.curFlags & 0x01) == (0))
			{
				return (int)(8);
			}





			return (int)(accessPayload(pCsr, (uint)(offset), (uint)(amt), (byte*)(z), (int)(1)));
		}
		public static int sqlite3BtreeRollback(Btree p, int tripCode, int writeOnly)
		{
			int rc = 0;
			BtShared pBt = p.pBt;
			MemPage pPage1;


			sqlite3BtreeEnter(p);
			if ((tripCode) == (0))
			{
				rc = (int)(tripCode = (int)(saveAllCursors(pBt, (uint)(0), null)));
				if ((rc) != 0)
					writeOnly = (int)(0);
			}
			else
			{
				rc = (int)(0);
			}

			if ((tripCode) != 0)
			{
				int rc2 = (int)(sqlite3BtreeTripAllCursors(p, (int)(tripCode), (int)(writeOnly)));

				if (rc2 != 0)
					rc = (int)(rc2);
			}



			if ((p.inTrans) == (2))
			{
				int rc2 = 0;

				rc2 = (int)(sqlite3PagerRollback(pBt.pPager));
				if (rc2 != 0)
				{
					rc = (int)(rc2);
				}

				if ((btreeGetPage(pBt, (uint)(1), pPage1, (int)(0))) == (0))
				{
					btreeSetNPage(pBt, pPage1);
					releasePageOne(pPage1);
				}


				pBt.inTransaction = (byte)(1);
				btreeClearHasContent(pBt);
			}

			btreeEndTransaction(p);
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static long sqlite3BtreeRowCountEst(BtCursor pCur)
		{
			long n = 0;
			byte i = 0;


			if ((pCur.eState != 0))
				return (long)(-1);
			if (((pCur.pPage.leaf) == (0)))
				return (long)(-1);
			n = (long)(pCur.pPage.nCell);
			for (i = (byte)(0); (i) < (pCur.iPage); i++)
			{
				n *= (long)(pCur.apPage[i].nCell);
			}

			return (long)(n);
		}
		public static int sqlite3BtreeSavepoint(Btree p, int op, int iSavepoint)
		{
			int rc = (int)(0);
			if (((p) != null) && ((p.inTrans) == (2)))
			{
				BtShared pBt = p.pBt;


				sqlite3BtreeEnter(p);
				if ((op) == (2))
				{
					rc = (int)(saveAllCursors(pBt, (uint)(0), null));
				}

				if ((rc) == (0))
				{
					rc = (int)(sqlite3PagerSavepoint(pBt.pPager, (int)(op), (int)(iSavepoint)));
				}

				if ((rc) == (0))
				{
					if (((iSavepoint) < (0)) && ((pBt.btsFlags & 0x0010) != 0))
					{
						pBt.nPage = (uint)(0);
					}

					rc = (int)(newDatabase(pBt));
					btreeSetNPage(pBt, pBt.pPage1);

				}

				sqlite3BtreeLeave(p);
			}

			return (int)(rc);
		}
		public static void* sqlite3BtreeSchema(Btree p, int nBytes, delegate17 xFree)
		{
			BtShared pBt = p.pBt;
			sqlite3BtreeEnter(p);
			if ((pBt.pSchema == null) && ((nBytes) != 0))
			{
				pBt.pSchema = sqlite3DbMallocZero(null, (ulong)(nBytes));
				pBt.xFreeSchema = xFree;
			}

			sqlite3BtreeLeave(p);
			return pBt.pSchema;
		}
		public static int sqlite3BtreeSchemaLocked(Btree p)
		{
			int rc = 0;

			sqlite3BtreeEnter(p);
			rc = (int)(querySharedCacheTableLock(p, (uint)(1), (byte)(1)));

			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeSecureDelete(Btree p, int newFlag)
		{
			int b = 0;
			if ((p) == (null))
				return (int)(0);
			sqlite3BtreeEnter(p);


			if ((newFlag) >= (0))
			{
				p.pBt.btsFlags &= (ushort)(~0x000c);
				p.pBt.btsFlags |= (ushort)(0x0004 * newFlag);
			}

			b = (int)((p.pBt.btsFlags & 0x000c) / 0x0004);
			sqlite3BtreeLeave(p);
			return (int)(b);
		}
		public static int sqlite3BtreeSetAutoVacuum(Btree p, int autoVacuum)
		{
			BtShared pBt = p.pBt;
			int rc = (int)(0);
			byte av = (byte)(autoVacuum);
			sqlite3BtreeEnter(p);
			if (((pBt.btsFlags & 0x0002) != 0) && (((av) != 0 ? 1 : 0) != pBt.autoVacuum))
			{
				rc = (int)(8);
			}
			else
			{
				pBt.autoVacuum = (byte)((av) != 0 ? 1 : 0);
				pBt.incrVacuum = (byte)((av) == (2) ? 1 : 0);
			}

			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeSetCacheSize(Btree p, int mxPage)
		{
			BtShared pBt = p.pBt;

			sqlite3BtreeEnter(p);
			sqlite3PagerSetCachesize(pBt.pPager, (int)(mxPage));
			sqlite3BtreeLeave(p);
			return (int)(0);
		}
		public static int sqlite3BtreeSetMmapLimit(Btree p, long szMmap)
		{
			BtShared pBt = p.pBt;

			sqlite3BtreeEnter(p);
			sqlite3PagerSetMmapLimit(pBt.pPager, (long)(szMmap));
			sqlite3BtreeLeave(p);
			return (int)(0);
		}
		public static int sqlite3BtreeSetPagerFlags(Btree p, uint pgFlags)
		{
			BtShared pBt = p.pBt;

			sqlite3BtreeEnter(p);
			sqlite3PagerSetFlags(pBt.pPager, (uint)(pgFlags));
			sqlite3BtreeLeave(p);
			return (int)(0);
		}
		public static int sqlite3BtreeSetPageSize(Btree p, int pageSize, int nReserve, int iFix)
		{
			int rc = (int)(0);
			int x = 0;
			BtShared pBt = p.pBt;

			sqlite3BtreeEnter(p);
			pBt.nReserveWanted = (byte)(nReserve);
			x = (int)(pBt.pageSize - pBt.usableSize);
			if ((nReserve) < (x))
				nReserve = (int)(x);
			if ((pBt.btsFlags & 0x0002) != 0)
			{
				sqlite3BtreeLeave(p);
				return (int)(8);
			}


			if ((((pageSize) >= (512)) && ((pageSize) <= (65536))) && (((pageSize - 1) & pageSize) == (0)))
			{


				if (((nReserve) > (32)) && ((pageSize) == (512)))
					pageSize = (int)(1024);
				pBt.pageSize = ((uint)(pageSize));
				freeTempSpace(pBt);
			}

			rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, (int)(nReserve)));
			pBt.usableSize = (uint)(pBt.pageSize - (ushort)(nReserve));
			if ((iFix) != 0)
				pBt.btsFlags |= (ushort)(0x0002);
			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3BtreeSetSpillSize(Btree p, int mxPage)
		{
			BtShared pBt = p.pBt;
			int res = 0;

			sqlite3BtreeEnter(p);
			res = (int)(sqlite3PagerSetSpillsize(pBt.pPager, (int)(mxPage)));
			sqlite3BtreeLeave(p);
			return (int)(res);
		}
		public static int sqlite3BtreeSetVersion(Btree pBtree, int iVersion)
		{
			BtShared pBt = pBtree.pBt;
			int rc = 0;

			pBt.btsFlags &= (ushort)(~0x0020);
			if ((iVersion) == (1))
				pBt.btsFlags |= (ushort)(0x0020);
			rc = (int)(sqlite3BtreeBeginTrans(pBtree, (int)(0), null));
			if ((rc) == (0))
			{
				byte* aData = pBt.pPage1.aData;
				if ((aData[18] != (byte)(iVersion)) || (aData[19] != (byte)(iVersion)))
				{
					rc = (int)(sqlite3BtreeBeginTrans(pBtree, (int)(2), null));
					if ((rc) == (0))
					{
						rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
						if ((rc) == (0))
						{
							aData[18] = ((byte)(iVersion));
							aData[19] = ((byte)(iVersion));
						}
					}
				}
			}

			pBt.btsFlags &= (ushort)(~0x0020);
			return (int)(rc);
		}
		public static int sqlite3BtreeSharable(Btree p)
		{
			return (int)(p.sharable);
		}
		public static int sqlite3BtreeTableMoveto(BtCursor pCur, long intKey, int biasRight, int* pRes)
		{
			int rc = 0;





			if (((pCur.eState) == (0)) && ((pCur.curFlags & 0x02) != 0))
			{
				if ((pCur.info.nKey) == (intKey))
				{
					*pRes = (int)(0);
					return (int)(0);
				}

				if ((pCur.info.nKey) < (intKey))
				{
					if ((pCur.curFlags & 0x08) != 0)
					{
						*pRes = (int)(-1);
						return (int)(0);
					}

					if ((pCur.info.nKey + 1) == (intKey))
					{
						*pRes = (int)(0);
						rc = (int)(sqlite3BtreeNext(pCur, (int)(0)));
						if ((rc) == (0))
						{
							getCellInfo(pCur);
							if ((pCur.info.nKey) == (intKey))
							{
								return (int)(0);
							}
						}
						else if (rc != 101)
						{
							return (int)(rc);
						}
					}
				}
			}

			rc = (int)(moveToRoot(pCur));
			if ((rc) != 0)
			{
				if ((rc) == (16))
				{

					*pRes = (int)(-1);
					return (int)(0);
				}

				return (int)(rc);
			}







			for (; ; )
			{
				int lwr = 0;
				int upr = 0;
				int idx = 0;
				int c = 0;
				uint chldPg = 0;
				MemPage pPage = pCur.pPage;
				byte* pCell;


				lwr = (int)(0);
				upr = (int)(pPage.nCell - 1);

				idx = (int)(upr >> (1 - biasRight));
				for (; ; )
				{
					long nCellKey = 0;
					pCell = ((pPage).aDataOfst + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))));
					if ((pPage.intKeyLeaf) != 0)
					{
						while ((0x80) <= (*(pCell++)))
						{
							if ((pCell) >= (pPage.aDataEnd))
							{
								return (int)(sqlite3CorruptError((int)(71743)));
							}
						}
					}

					sqlite3GetVarint(pCell, (ulong*)(&nCellKey));
					if ((nCellKey) < (intKey))
					{
						lwr = (int)(idx + 1);
						if ((lwr) > (upr))
						{
							c = (int)(-1);
							break;
						}
					}
					else if ((nCellKey) > (intKey))
					{
						upr = (int)(idx - 1);
						if ((lwr) > (upr))
						{
							c = (int)(+1);
							break;
						}
					}
					else
					{

						pCur.ix = ((ushort)(idx));
						if (pPage.leaf == 0)
						{
							lwr = (int)(idx);
							goto moveto_table_next_layer;
						}
						else
						{
							pCur.curFlags |= (byte)(0x02);
							pCur.info.nKey = (long)(nCellKey);
							pCur.info.nSize = (ushort)(0);
							*pRes = (int)(0);
							return (int)(0);
						}
					}


					idx = (int)((lwr + upr) >> 1);
				}



				if ((pPage.leaf) != 0)
				{

					pCur.ix = ((ushort)(idx));
					*pRes = (int)(c);
					rc = (int)(0);
					goto moveto_table_finish;
				}

			moveto_table_next_layer:
				;
				if ((lwr) >= (pPage.nCell))
				{
					chldPg = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				}
				else
				{
					chldPg = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (lwr)])))))));
				}

				pCur.ix = ((ushort)(lwr));
				rc = (int)(moveToChild(pCur, (uint)(chldPg)));
				if ((rc) != 0)
					break;
			}

		moveto_table_finish:
			; pCur.info.nSize = (ushort)(0);

			return (int)(rc);
		}
		public static int sqlite3BtreeTransferRow(BtCursor pDest, BtCursor pSrc, long iKey)
		{
			int rc = (int)(0);
			BtShared pBt = pDest.pBt;
			byte* aOut = pBt.pTmpSpace;
			byte* aIn;
			uint nIn = 0;
			uint nRem = 0;
			getCellInfo(pSrc);
			aOut += (byte)(((pSrc.info.nPayload) < ((uint)(0x80))) ? (*(aOut) = ((byte)(pSrc.info.nPayload))), 1 :  sqlite3PutVarint((aOut), (ulong)(pSrc.info.nPayload)) ) ;
			if ((pDest.pKeyInfo) == (null))
				aOut += sqlite3PutVarint(aOut, (ulong)(iKey));
			nIn = (uint)(pSrc.info.nLocal);
			aIn = pSrc.info.pPayload;
			if ((aIn + nIn) > (pSrc.pPage.aDataEnd))
			{
				return (int)(sqlite3CorruptError((int)(75309)));
			}

			nRem = (uint)(pSrc.info.nPayload);
			if (((nIn) == (nRem)) && ((nIn) < (pDest.pPage.maxLocal)))
			{
				CRuntime.memcpy(aOut, aIn, (ulong)(nIn));
				pBt.nPreformatSize = (int)(nIn + (aOut - pBt.pTmpSpace));
			}
			else
			{
				Pager pSrcPager = pSrc.pBt.pPager;
				byte* pPgnoOut = null;
				uint ovflIn = (uint)(0);
				PgHdr pPageIn = null;
				MemPage pPageOut = null;
				uint nOut = 0;
				nOut = (uint)(btreePayloadToLocal(pDest.pPage, (long)(pSrc.info.nPayload)));
				pBt.nPreformatSize = (int)(nOut + (aOut - pBt.pTmpSpace));
				if ((nOut) < (pSrc.info.nPayload))
				{
					pPgnoOut = &aOut[nOut];
					pBt.nPreformatSize += (int)(4);
				}

				if ((nRem) > (nIn))
				{
					if ((aIn + nIn + 4) > (pSrc.pPage.aDataEnd))
					{
						return (int)(sqlite3CorruptError((int)(75332)));
					}

					ovflIn = (uint)(sqlite3Get4byte(&pSrc.info.pPayload[nIn]));
				}

				do
				{
					nRem -= (uint)(nOut);
					do
					{

						if ((nIn) > (0))
						{
							int nCopy = (int)((nOut) < (nIn) ? (nOut) : (nIn));
							CRuntime.memcpy(aOut, aIn, (ulong)(nCopy));
							nOut -= (uint)(nCopy);
							nIn -= (uint)(nCopy);
							aOut += nCopy;
							aIn += nCopy;
						}

						if ((nOut) > (0))
						{
							sqlite3PagerUnref(pPageIn);
							pPageIn = null;
							rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(ovflIn), pPageIn, (int)(0x02)));
							if ((rc) == (0))
							{
								aIn = (byte*)(sqlite3PagerGetData(pPageIn));
								ovflIn = (uint)(sqlite3Get4byte(aIn));
								aIn += 4;
								nIn = (uint)(pSrc.pBt.usableSize - 4);
							}
						}
					}
					while (((rc) == (0)) && ((nOut) > (0)));
					if ((((rc) == (0)) && ((nRem) > (0))) && ((pPgnoOut) != null))
					{
						uint pgnoNew = 0;
						MemPage pNew = null;
						rc = (int)(allocateBtreePage(pBt, pNew, &pgnoNew, (uint)(0), (byte)(0)));
						sqlite3Put4byte(pPgnoOut, (uint)(pgnoNew));
						if (((pBt.autoVacuum) != 0) && ((pPageOut) != null))
						{
							ptrmapPut(pBt, (uint)(pgnoNew), (byte)(4), (uint)(pPageOut.pgno), &rc);
						}

						releasePage(pPageOut);
						pPageOut = pNew;
						if ((pPageOut) != null)
						{
							pPgnoOut = pPageOut.aData;
							sqlite3Put4byte(pPgnoOut, (uint)(0));
							aOut = &pPgnoOut[4];
							nOut = (uint)((pBt.usableSize - 4) < (nRem) ? (pBt.usableSize - 4) : (nRem));
						}
					}
				}
				while (((nRem) > (0)) && ((rc) == (0)));
				releasePage(pPageOut);
				sqlite3PagerUnref(pPageIn);
			}

			return (int)(rc);
		}
		public static int sqlite3BtreeTripAllCursors(Btree pBtree, int errCode, int writeOnly)
		{
			BtCursor p;
			int rc = (int)(0);

			if ((pBtree) != null)
			{
				sqlite3BtreeEnter(pBtree);
				for (p = pBtree.pBt.pCursor; p; p = p.pNext)
				{
					if (((writeOnly) != 0) && ((p.curFlags & 0x01) == (0)))
					{
						if (((p.eState) == (0)) || ((p.eState) == (2)))
						{
							rc = (int)(saveCursorPosition(p));
							if (rc != 0)
							{
								(void)(sqlite3BtreeTripAllCursors(pBtree, (int)(rc), (int)(0)));
								break;
							}
						}
					}
					else
					{
						sqlite3BtreeClearCursor(p);
						p.eState = (byte)(4);
						p.skipNext = (int)(errCode);
					}

					btreeReleaseAllCursorPages(p);
				}

				sqlite3BtreeLeave(pBtree);
			}

			return (int)(rc);
		}
		public static int sqlite3BtreeTxnState(Btree p)
		{

			return (int)(p ? p.inTrans : 0);
		}
		public static int sqlite3BtreeUpdateMeta(Btree p, int idx, uint iMeta)
		{
			BtShared pBt = p.pBt;
			byte* pP1;
			int rc = 0;

			sqlite3BtreeEnter(p);


			pP1 = pBt.pPage1.aData;
			rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
			if ((rc) == (0))
			{
				sqlite3Put4byte(&pP1[36 + idx * 4], (uint)(iMeta));
				if ((idx) == (7))
				{


					pBt.incrVacuum = ((byte)(iMeta));
				}
			}

			sqlite3BtreeLeave(p);
			return (int)(rc);
		}
		public static int sqlite3CantopenError(int lineno)
		{
			return (int)(sqlite3ReportError((int)(14), (int)(lineno), "cannot open file"));
		}
		public static void sqlite3ChangeCookie(Parse pParse, int iDb)
		{
			sqlite3 db = pParse.db;
			Vdbe v = pParse.pVdbe;

			sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(1), (int)(1 + (uint)(db.aDb[iDb].pSchema.schema_cookie)));
		}
		public static int sqlite3CheckCollSeq(Parse pParse, CollSeq pColl)
		{
			if (((pColl) != null) && ((pColl.xCmp) == (null)))
			{
				sbyte* zName = pColl.zName;
				sqlite3 db = pParse.db;
				CollSeq p = sqlite3GetCollSeq(pParse, (byte)((db).enc), pColl, zName);
				if (p == null)
				{
					return (int)(1);
				}


			}

			return (int)(0);
		}
		public static int sqlite3CheckObjectName(Parse pParse, sbyte* zName, sbyte* zType, sbyte* zTblName)
		{
			sqlite3 db = pParse.db;
			if ((((sqlite3WritableSchema(db)) != 0) || ((db.init.imposterTable) != 0)) || (sqlite3Config.bExtraSchemaChecks == 0))
			{
				return (int)(0);
			}

			if ((db.init.busy) != 0)
			{
				if ((((sqlite3_stricmp(zType, db.init.azInit[0])) != 0) || ((sqlite3_stricmp(zName, db.init.azInit[1])) != 0)) || ((sqlite3_stricmp(zTblName, db.init.azInit[2])) != 0))
				{
					sqlite3ErrorMsg(pParse, "");
					return (int)(1);
				}
			}
			else
			{
				if ((((pParse.nested) == (0)) && ((0) == (sqlite3_strnicmp(zName, "sqlite_", (int)(7))))) || (((sqlite3ReadOnlyShadowTables(db)) != 0) && ((sqlite3ShadowTableName(db, zName)) != 0)))
				{
					sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int sqlite3Checkpoint(sqlite3 db, int iDb, int eMode, int* pnLog, int* pnCkpt)
		{
			int rc = (int)(0);
			int i = 0;
			int bBusy = (int)(0);



			for (i = (int)(0); ((i) < (db.nDb)) && ((rc) == (0)); i++)
			{
				if (((i) == (iDb)) || ((iDb) == (10 + 2)))
				{
					rc = (int)(sqlite3BtreeCheckpoint(db.aDb[i].pBt, (int)(eMode), pnLog, pnCkpt));
					pnLog = null;
					pnCkpt = null;
					if ((rc) == (5))
					{
						bBusy = (int)(1);
						rc = (int)(0);
					}
				}
			}

			return (int)((((rc) == (0)) && ((bBusy) != 0)) ? 5 : rc);
		}
		public static void sqlite3ClearStatTables(Parse pParse, int iDb, sbyte* zType, sbyte* zName)
		{
			int i = 0;
			sbyte* zDbName = pParse.db.aDb[iDb].zDbSName;
			for (i = (int)(1); (i) <= (4); i++)
			{
				sbyte* zTab = stackalloc sbyte[24];
				sqlite3_snprintf((int)(24 * sizeof(sbyte)), zTab, "sqlite_stat%d", (int)(i));
				if ((sqlite3FindTable(pParse.db, zTab, zDbName)) != null)
				{
					sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", zDbName, zTab, zType, zName);
				}
			}
		}
		public static void sqlite3ClearTempRegCache(Parse pParse)
		{
			pParse.nTempReg = (byte)(0);
			pParse.nRangeReg = (int)(0);
		}
		public static int sqlite3Close(sqlite3 db, int forceZombie)
		{
			if (db == null)
			{
				return (int)(0);
			}

			if (sqlite3SafetyCheckSickOrOk(db) == 0)
			{
				return (int)(sqlite3MisuseError((int)(169679)));
			}

			sqlite3_mutex_enter(db.mutex);
			if ((db.mTrace & 0x08) != 0)
			{
				db.trace.xV2((uint)(0x08), db.pTraceArg, db, null);
			}

			disconnectAllVtab(db);
			sqlite3VtabRollback(db);
			if ((forceZombie == 0) && ((connectionIsBusy(db)) != 0))
			{
				sqlite3ErrorWithMsg(db, (int)(5), "unable to close due to unfinalized statements or unfinished backups");
				sqlite3_mutex_leave(db.mutex);
				return (int)(5);
			}

			db.eOpenState = (byte)(0xa7);
			sqlite3LeaveMutexAndCloseZombie(db);
			return (int)(0);
		}
		public static void sqlite3CloseExtensions(sqlite3 db)
		{
			int i = 0;

			for (i = (int)(0); (i) < (db.nExtension); i++)
			{
				sqlite3OsDlClose(db.pVfs, db.aExtension[i]);
			}

			sqlite3DbFree(db, db.aExtension);
		}
		public static void sqlite3CloseSavepoints(sqlite3 db)
		{
			while ((db.pSavepoint) != null)
			{
				Savepoint* pTmp = db.pSavepoint;
				db.pSavepoint = pTmp->pNext;
				sqlite3DbFree(db, pTmp);
			}

			db.nSavepoint = (int)(0);
			db.nStatement = (int)(0);
			db.isTransactionSavepoint = (byte)(0);
		}
		public static void sqlite3CodeChangeCount(Vdbe v, int regCounter, sbyte* zColName)
		{
			sqlite3VdbeAddOp0(v, (int)(82));
			sqlite3VdbeAddOp2(v, (int)(83), (int)(regCounter), (int)(1));
			sqlite3VdbeSetNumCols(v, (int)(1));
			sqlite3VdbeSetColName(v, (int)(0), (int)(0), zColName, null);
		}
		public static void sqlite3CodeDropTable(Parse pParse, Table pTab, int iDb, int isView)
		{
			Vdbe v;
			sqlite3 db = pParse.db;
			Trigger pTrigger;
			Db pDb = db.aDb[iDb];
			v = sqlite3GetVdbe(pParse);

			sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
			if ((((pTab).eTabType) == (1)))
			{
				sqlite3VdbeAddOp0(v, (int)(169));
			}

			pTrigger = sqlite3TriggerList(pParse, pTab);
			while ((pTrigger) != null)
			{

				sqlite3DropTriggerPtr(pParse, pTrigger);
				pTrigger = pTrigger.pNext;
			}

			if ((pTab.tabFlags & 0x00000008) != 0)
			{
				sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_sequence WHERE name=%Q", pDb.zDbSName, pTab.zName);
			}

			sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE tbl_name=%Q and type!='trigger'", pDb.zDbSName, pTab.zName);
			if ((isView == 0) && (!(((pTab).eTabType) == (1))))
			{
				destroyTable(pParse, pTab);
			}

			if ((((pTab).eTabType) == (1)))
			{
				sqlite3VdbeAddOp4(v, (int)(171), (int)(iDb), (int)(0), (int)(0), pTab.zName, (int)(0));
				sqlite3MayAbort(pParse);
			}

			sqlite3VdbeAddOp4(v, (int)(150), (int)(iDb), (int)(0), (int)(0), pTab.zName, (int)(0));
			sqlite3ChangeCookie(pParse, (int)(iDb));
			sqliteViewResetAll(db, (int)(iDb));
		}
		public static void sqlite3CodeRhsOfIN(Parse pParse, Expr pExpr, int iTab)
		{
			int addrOnce = (int)(0);
			int addr = 0;
			Expr pLeft;
			KeyInfo pKeyInfo = null;
			int nVal = 0;
			Vdbe v;
			v = pParse.pVdbe;

			if ((!(((pExpr).flags & (0x000020)) != 0)) && ((pParse.iSelfTab) == (0)))
			{
				if ((((pExpr).flags & (0x2000000)) != 0))
				{
					addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
					if ((((pExpr).flags & 0x000800) != 0))
					{
						sqlite3VdbeExplain(pParse, (byte)(0), "REUSE LIST SUBQUERY %d", (uint)(pExpr.x.pSelect.selId));
					}


					sqlite3VdbeAddOp2(v, (int)(12), (int)(pExpr.y.sub.regReturn), (int)(pExpr.y.sub.iAddr));
					sqlite3VdbeAddOp2(v, (int)(113), (int)(iTab), (int)(pExpr.iTable));
					sqlite3VdbeJumpHere(v, (int)(addrOnce));
					return;
				}


				(pExpr).flags |= (uint)(0x2000000);

				pExpr.y.sub.regReturn = (int)(++pParse.nMem);
				pExpr.y.sub.iAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pExpr.y.sub.regReturn)) + 1);
				addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			}

			pLeft = pExpr.pLeft;
			nVal = (int)(sqlite3ExprVectorSize(pLeft));
			pExpr.iTable = (int)(iTab);
			addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(pExpr.iTable), (int)(nVal)));
			pKeyInfo = sqlite3KeyInfoAlloc(pParse.db, (int)(nVal), (int)(1));
			if ((((pExpr).flags & 0x000800) != 0))
			{
				Select pSelect = pExpr.x.pSelect;
				ExprList pEList = pSelect.pEList;
				sqlite3VdbeExplain(pParse, (byte)(1), "%sLIST SUBQUERY %d", (addrOnce) != 0 ? "" : "CORRELATED ", (uint)(pSelect.selId));
				if (((pEList.nExpr) == (nVal)))
				{
					Select pCopy;
					SelectDest dest = new SelectDest();
					int i = 0;
					int rc = 0;
					sqlite3SelectDestInit(dest, (int)(11), (int)(iTab));
					dest.zAffSdst = exprINAffinity(pParse, pExpr);
					pSelect.iLimit = (int)(0);
					pCopy = sqlite3SelectDup(pParse.db, pSelect, (int)(0));
					rc = (int)((pParse.db.mallocFailed) != 0 ? 1 : sqlite3Select(pParse, pCopy, dest));
					sqlite3SelectDelete(pParse.db, pCopy);
					sqlite3DbFree(pParse.db, dest.zAffSdst);
					if ((rc) != 0)
					{
						sqlite3KeyInfoUnref(pKeyInfo);
						return;
					}





					for (i = (int)(0); (i) < (nVal); i++)
					{
						Expr p = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
						pKeyInfo.aColl[i] = sqlite3BinaryCompareCollSeq(pParse, p, pEList.a[i].pExpr);
					}
				}
			}
			else if ((pExpr.x.pList != null))
			{
				sbyte affinity = 0;
				int i = 0;
				ExprList pList = pExpr.x.pList;
				ExprList_item* pItem;
				int r1 = 0;
				int r2 = 0;
				affinity = (sbyte)(sqlite3ExprAffinity(pLeft));
				if ((affinity) <= (0x40))
				{
					affinity = (sbyte)(0x41);
				}
				else if ((affinity) == (0x45))
				{
					affinity = (sbyte)(0x43);
				}

				if ((pKeyInfo) != null)
				{

					pKeyInfo.aColl[0] = sqlite3ExprCollSeq(pParse, pExpr.pLeft);
				}

				r1 = (int)(sqlite3GetTempReg(pParse));
				r2 = (int)(sqlite3GetTempReg(pParse));
				for (i = (int)(pList.nExpr), pItem = pList.a; (i) > (0); i--, pItem++)
				{
					Expr pE2 = pItem->pExpr;
					if (((addrOnce) != 0) && (sqlite3ExprIsConstant(pE2) == 0))
					{
						sqlite3VdbeChangeToNoop(v, (int)(addrOnce));
						(pExpr).flags &= (uint)(~(0x2000000));
						addrOnce = (int)(0);
					}

					sqlite3ExprCode(pParse, pE2, (int)(r1));
					sqlite3VdbeAddOp4(v, (int)(96), (int)(r1), (int)(1), (int)(r2), &affinity, (int)(1));
					sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iTab), (int)(r2), (int)(r1), (int)(1));
				}

				sqlite3ReleaseTempReg(pParse, (int)(r1));
				sqlite3ReleaseTempReg(pParse, (int)(r2));
			}

			if ((pKeyInfo) != null)
			{
				sqlite3VdbeChangeP4(v, (int)(addr), (void*)(pKeyInfo), (int)(-9));
			}

			if ((addrOnce) != 0)
			{
				sqlite3VdbeJumpHere(v, (int)(addrOnce));

				sqlite3VdbeAddOp1(v, (int)(67), (int)(pExpr.y.sub.regReturn));
				sqlite3VdbeChangeP1(v, (int)(pExpr.y.sub.iAddr - 1), (int)(sqlite3VdbeCurrentAddr(v) - 1));
				sqlite3ClearTempRegCache(pParse);
			}
		}
		public static void sqlite3CodeRowTrigger(Parse pParse, Trigger pTrigger, int op, ExprList pChanges, int tr_tm, Table pTab, int reg, int orconf, int ignoreJump)
		{
			Trigger p;



			for (p = pTrigger; p; p = p.pNext)
			{



				if (((((p.op) == (op)) || ((((p.bReturning) != 0) && ((p.op) == (127))) && ((op) == (129)))) && ((p.tr_tm) == (tr_tm))) && ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
				{
					if (p.bReturning == 0)
					{
						sqlite3CodeRowTriggerDirect(pParse, p, pTab, (int)(reg), (int)(orconf), (int)(ignoreJump));
					}
					else if ((((pParse).pToplevel) == (null)))
					{
						codeReturningTrigger(pParse, p, pTab, (int)(reg));
					}
				}
			}
		}
		public static void sqlite3CodeRowTriggerDirect(Parse pParse, Trigger p, Table pTab, int reg, int orconf, int ignoreJump)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			TriggerPrg pPrg;
			pPrg = getRowTrigger(pParse, p, pTab, (int)(orconf));

			if ((pPrg) != null)
			{
				int bRecursive = (int)((((p.zName) != null) && ((0) == (pParse.db.flags & 0x00002000))) ? 1 : 0);
				sqlite3VdbeAddOp4(v, (int)(47), (int)(reg), (int)(ignoreJump), (int)(++pParse.nMem), (sbyte*)(pPrg.pProgram), (int)(-4));
				sqlite3VdbeChangeP5(v, (ushort)((byte)(bRecursive)));
			}
		}
		public static int sqlite3CodeSubselect(Parse pParse, Expr pExpr)
		{
			int addrOnce = (int)(0);
			int rReg = (int)(0);
			Select pSel;
			SelectDest dest = new SelectDest();
			int nReg = 0;
			Expr pLimit;
			Vdbe v = pParse.pVdbe;

			if ((pParse.nErr) != 0)
				return (int)(0);


			pSel = pExpr.x.pSelect;
			if ((((pExpr).flags & (0x2000000)) != 0))
			{
				sqlite3VdbeExplain(pParse, (byte)(0), "REUSE SUBQUERY %d", (uint)(pSel.selId));

				sqlite3VdbeAddOp2(v, (int)(12), (int)(pExpr.y.sub.regReturn), (int)(pExpr.y.sub.iAddr));
				return (int)(pExpr.iTable);
			}



			(pExpr).flags |= (uint)(0x2000000);
			pExpr.y.sub.regReturn = (int)(++pParse.nMem);
			pExpr.y.sub.iAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pExpr.y.sub.regReturn)) + 1);
			if (!(((pExpr).flags & (0x000020)) != 0))
			{
				addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			}

			sqlite3VdbeExplain(pParse, (byte)(1), "%sSCALAR SUBQUERY %d", (addrOnce) != 0 ? "" : "CORRELATED ", (uint)(pSel.selId));
			nReg = (int)((pExpr.op) == (138) ? pSel.pEList.nExpr : 1);
			sqlite3SelectDestInit(dest, (int)(0), (int)(pParse.nMem + 1));
			pParse.nMem += (int)(nReg);
			if ((pExpr.op) == (138))
			{
				dest.eDest = (byte)(10);
				dest.iSdst = (int)(dest.iSDParm);
				dest.nSdst = (int)(nReg);
				sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(dest.iSDParm), (int)(dest.iSDParm + nReg - 1));
			}
			else
			{
				dest.eDest = (byte)(3);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(dest.iSDParm));
			}

			if ((pSel.pLimit) != null)
			{
				sqlite3 db = pParse.db;
				pLimit = sqlite3Expr(db, (int)(155), "0");
				if ((pLimit) != null)
				{
					pLimit.affExpr = (sbyte)(0x43);
					pLimit = sqlite3PExpr(pParse, (int)(52), sqlite3ExprDup(db, pSel.pLimit.pLeft, (int)(0)), pLimit);
				}

				sqlite3ExprDelete(db, pSel.pLimit.pLeft);
				pSel.pLimit.pLeft = pLimit;
			}
			else
			{
				pLimit = sqlite3Expr(pParse.db, (int)(155), "1");
				pSel.pLimit = sqlite3PExpr(pParse, (int)(148), pLimit, null);
			}

			pSel.iLimit = (int)(0);
			if ((sqlite3Select(pParse, pSel, dest)) != 0)
			{
				pExpr.op2 = (byte)(pExpr.op);
				pExpr.op = (byte)(182);
				return (int)(0);
			}

			pExpr.iTable = (int)(rReg = (int)(dest.iSDParm));
			if ((addrOnce) != 0)
			{
				sqlite3VdbeJumpHere(v, (int)(addrOnce));
			}


			sqlite3VdbeAddOp1(v, (int)(67), (int)(pExpr.y.sub.regReturn));
			sqlite3VdbeChangeP1(v, (int)(pExpr.y.sub.iAddr - 1), (int)(sqlite3VdbeCurrentAddr(v) - 1));
			sqlite3ClearTempRegCache(pParse);
			return (int)(rReg);
		}
		public static void sqlite3CodeVerifyNamedSchema(Parse pParse, sbyte* zDb)
		{
			sqlite3 db = pParse.db;
			int i = 0;
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Db pDb = db.aDb[i];
				if (((pDb.pBt) != null) && ((zDb == null) || ((0) == (sqlite3StrICmp(zDb, pDb.zDbSName)))))
				{
					sqlite3CodeVerifySchema(pParse, (int)(i));
				}
			}
		}
		public static void sqlite3CodeVerifySchema(Parse pParse, int iDb)
		{
			sqlite3CodeVerifySchemaAtToplevel(((pParse).pToplevel ? (pParse).pToplevel : (pParse)), (int)(iDb));
		}
		public static void sqlite3CodeVerifySchemaAtToplevel(Parse pToplevel, int iDb)
		{




			if ((((pToplevel.cookieMask) & (((uint)(1)) << (iDb))) != 0) == (0))
			{
				(pToplevel.cookieMask) |= (uint)(((uint)(1)) << (iDb));
				if ((0 == 0) && ((iDb) == (1)))
				{
					sqlite3OpenTempDatabase(pToplevel);
				}
			}
		}
		public static void sqlite3CollapseDatabaseArray(sqlite3 db)
		{
			int i = 0; int j = 0;
			for (i = (int)(j = (int)(2)); (i) < (db.nDb); i++)
			{
				Db pDb = db.aDb[i];
				if ((pDb.pBt) == (null))
				{
					sqlite3DbFree(db, pDb.zDbSName);
					pDb.zDbSName = null;
					continue;
				}

				if ((j) < (i))
				{
					db.aDb[j] = (Db)(db.aDb[i]);
				}

				j++;
			}

			db.nDb = (int)(j);
			if (((db.nDb) <= (2)) && (db.aDb != db.aDbStatic))
			{
				CRuntime.memcpy(db.aDbStatic, db.aDb, (ulong)(2 * sizeof(Db)));
				sqlite3DbFree(db, db.aDb);
				db.aDb = db.aDbStatic;
			}
		}
		public static sbyte* sqlite3ColumnColl(Column* pCol)
		{
			sbyte* z;
			if ((pCol->colFlags & 0x0200) == (0))
				return null;
			z = pCol->zCnName;
			while ((*z) != 0)
			{
				z++;
			}

			if ((pCol->colFlags & 0x0004) != 0)
			{
				do
				{
					z++;
				}
				while ((*z) != 0);
			}

			return z + 1;
		}
		public static void sqlite3ColumnDefault(Vdbe v, Table pTab, int i, int iReg)
		{

			if (!(((pTab).eTabType) == (2)))
			{
				sqlite3_value pValue = null;
				byte enc = (byte)((sqlite3VdbeDb(v)).enc);
				Column* pCol = &pTab.aCol[i];

				sqlite3ValueFromExpr(sqlite3VdbeDb(v), sqlite3ColumnExpr(pTab, pCol), (byte)(enc), (byte)(pCol->affinity), pValue);
				if ((pValue) != null)
				{
					sqlite3VdbeAppendP4(v, pValue, (int)(-11));
				}
			}

			if (((pTab.aCol[i].affinity) == (0x45)) && (!(((pTab).eTabType) == (1))))
			{
				sqlite3VdbeAddOp1(v, (int)(86), (int)(iReg));
			}
		}
		public static Expr sqlite3ColumnExpr(Table pTab, Column* pCol)
		{
			if ((pCol->iDflt) == (0))
				return null;
			if ((!(((pTab).eTabType) == (0))) != 0)
				return null;
			if (((pTab.u.tab.pDfltList) == (null)))
				return null;
			if (((pTab.u.tab.pDfltList.nExpr) < (pCol->iDflt)))
				return null;
			return pTab.u.tab.pDfltList.a[pCol->iDflt - 1].pExpr;
		}
		public static int sqlite3ColumnIndex(Table pTab, sbyte* zCol)
		{
			int i = 0;
			byte h = (byte)(sqlite3StrIHash(zCol));
			Column* pCol;
			for (pCol = pTab.aCol, i = (int)(0); (i) < (pTab.nCol); pCol++, i++)
			{
				if (((pCol->hName) == (h)) && ((sqlite3StrICmp(pCol->zCnName, zCol)) == (0)))
					return (int)(i);
			}

			return (int)(-1);
		}
		public static void sqlite3ColumnSetColl(sqlite3 db, Column* pCol, sbyte* zColl)
		{
			long nColl = 0;
			long n = 0;
			sbyte* zNew;

			n = (long)(sqlite3Strlen30(pCol->zCnName) + 1);
			if ((pCol->colFlags & 0x0004) != 0)
			{
				n += (long)(sqlite3Strlen30(pCol->zCnName + n) + 1);
			}

			nColl = (long)(sqlite3Strlen30(zColl) + 1);
			zNew = sqlite3DbRealloc(db, pCol->zCnName, (ulong)(nColl + n));
			if ((zNew) != null)
			{
				pCol->zCnName = zNew;
				CRuntime.memcpy(pCol->zCnName + n, zColl, (ulong)(nColl));
				pCol->colFlags |= (ushort)(0x0200);
			}
		}
		public static void sqlite3ColumnSetExpr(Parse pParse, Table pTab, Column* pCol, Expr pExpr)
		{
			ExprList pList;

			pList = pTab.u.tab.pDfltList;
			if ((((pCol->iDflt) == (0)) || ((pList) == (null))) || ((pList.nExpr) < (pCol->iDflt)))
			{
				pCol->iDflt = (ushort)((pList) == (null) ? 1 : pList.nExpr + 1);
				pTab.u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr);
			}
			else
			{
				sqlite3ExprDelete(pParse.db, pList.a[pCol->iDflt - 1].pExpr);
				pList.a[pCol->iDflt - 1].pExpr = pExpr;
			}
		}
		public static int sqlite3ColumnsFromExprList(Parse pParse, ExprList pEList, short* pnCol, Column** paCol)
		{
			sqlite3 db = pParse.db;
			int i = 0; int j = 0;
			uint cnt = 0;
			Column* aCol; Column* pCol;
			int nCol = 0;
			sbyte* zName;
			int nName = 0;
			Hash ht = new Hash();
			Table pTab;
			sqlite3HashInit(&ht);
			if ((pEList) != null)
			{
				nCol = (int)(pEList.nExpr);
				aCol = sqlite3DbMallocZero(db, (ulong)(sizeof(Column) * nCol));
				if (((nCol) > (32767)))
					nCol = (int)(32767);
			}
			else
			{
				nCol = (int)(0);
				aCol = null;
			}


			*pnCol = (short)(nCol);
			*paCol = aCol;
			for (i = (int)(0), pCol = aCol; ((i) < (nCol)) && (db.mallocFailed == 0); i++, pCol++)
			{
				if (((zName = pEList.a[i].zEName) != null) && ((pEList.a[i].eEName) == (0)))
				{
				}
				else
				{
					Expr pColExpr = sqlite3ExprSkipCollateAndLikely(pEList.a[i].pExpr);
					while ((pColExpr != null) && ((pColExpr.op) == (141)))
					{
						pColExpr = pColExpr.pRight;

					}

					if ((((pColExpr.op) == (167)) && ((((pColExpr).flags & (0x1000000 | 0x2000000)) == (0)) != 0)) && ((pTab = pColExpr.y.pTab) != null))
					{
						int iCol = (int)(pColExpr.iColumn);
						if ((iCol) < (0))
							iCol = (int)(pTab.iPKey);
						zName = (iCol) >= (0) ? pTab.aCol[iCol].zCnName : "rowid";
					}
					else if ((pColExpr.op) == (59))
					{

						zName = pColExpr.u.zToken;
					}
					else
					{
						zName = pEList.a[i].zEName;
					}
				}

				if (((zName) != null) && (sqlite3IsTrueOrFalse(zName) == 0))
				{
					zName = sqlite3DbStrDup(db, zName);
				}
				else
				{
					zName = sqlite3MPrintf(db, "column%d", (int)(i + 1));
				}

				cnt = (uint)(0);
				while (((zName) != null) && (sqlite3HashFind(&ht, zName) != null))
				{
					nName = (int)(sqlite3Strlen30(zName));
					if ((nName) > (0))
					{
						for (j = (int)(nName - 1); ((j) > (0)) && ((sqlite3CtypeMap[(byte)(zName[j])] & 0x04) != 0); j--)
						{
						}

						if ((zName[j]) == (58))
							nName = (int)(j);
					}

					zName = sqlite3MPrintf(db, "%.*z:%u", (int)(nName), zName, (uint)(++cnt));
					if ((cnt) > (3))
						sqlite3_randomness((int)(sizeof(uint)), &cnt);
				}

				pCol->zCnName = zName;
				pCol->hName = (byte)(sqlite3StrIHash(zName));
				if (((zName) != null) && ((sqlite3HashInsert(&ht, zName, pCol)) == (pCol)))
				{
					sqlite3OomFault(db);
				}
			}

			sqlite3HashClear(&ht);
			if ((db.mallocFailed) != 0)
			{
				for (j = (int)(0); (j) < (i); j++)
				{
					sqlite3DbFree(db, aCol[j].zCnName);
				}

				sqlite3DbFree(db, aCol);
				*paCol = null;
				*pnCol = (short)(0);
				return (int)(7);
			}

			return (int)(0);
		}
		public static sbyte* sqlite3ColumnType(Column* pCol, sbyte* zDflt)
		{
			if ((pCol->colFlags & 0x0004) != 0)
			{
				return pCol->zCnName + CRuntime.strlen(pCol->zCnName) + 1;
			}
			else if ((pCol->eCType) != 0)
			{

				return sqlite3StdType[pCol->eCType - 1];
			}
			else
			{
				return zDflt;
			}
		}
		public static void sqlite3CommitInternalChanges(sqlite3 db)
		{
			db.mDbFlags &= (uint)(~0x0001);
		}
		public static sbyte sqlite3CompareAffinity(Expr pExpr, sbyte aff2)
		{
			sbyte aff1 = (sbyte)(sqlite3ExprAffinity(pExpr));
			if (((aff1) > (0x40)) && ((aff2) > (0x40)))
			{
				if (((aff1) >= (0x43)) || ((aff2) >= (0x43)))
				{
					return (sbyte)(0x43);
				}
				else
				{
					return (sbyte)(0x41);
				}
			}
			else
			{

				return (sbyte)(((aff1) <= (0x40) ? aff2 : aff1) | 0x40);
			}
		}
		public static sbyte** sqlite3CompileOptions(int* pnOpt)
		{
			*pnOpt = (int)(36 * sizeof(sbyte) / sizeof(sbyte*));
			return sqlite3azCompileOpt;
		}
		public static void sqlite3CompleteInsertion(Parse pParse, Table pTab, int iDataCur, int iIdxCur, int regNewData, int* aRegIdx, int update_flags, int appendBias, int useSeekResult)
		{
			Vdbe v;
			Index pIdx;
			byte pik_flags = 0;
			int i = 0;

			v = pParse.pVdbe;


			for (i = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, i++)
			{

				if ((aRegIdx[i]) == (0))
					continue;
				if ((pIdx.pPartIdxWhere) != null)
				{
					sqlite3VdbeAddOp2(v, (int)(50), (int)(aRegIdx[i]), (int)(sqlite3VdbeCurrentAddr(v) + 2));
				}

				pik_flags = (byte)((useSeekResult) != 0 ? 0x10 : 0);
				if ((((pIdx).idxType) == (2)) && (!(((pTab).tabFlags & 0x00000080) == (0))))
				{
					pik_flags |= (byte)(0x01);
					pik_flags |= (byte)(update_flags & 0x02);
					if ((update_flags) == (0))
					{
					}
				}

				sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iIdxCur + i), (int)(aRegIdx[i]), (int)(aRegIdx[i] + 1), (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol : pIdx.nColumn));
				sqlite3VdbeChangeP5(v, (ushort)(pik_flags));
			}

			if (!(((pTab).tabFlags & 0x00000080) == (0)))
				return;
			if ((pParse.nested) != 0)
			{
				pik_flags = (byte)(0);
			}
			else
			{
				pik_flags = (byte)(0x01);
				pik_flags |= (byte)((update_flags) != 0 ? update_flags : 0x20);
			}

			if ((appendBias) != 0)
			{
				pik_flags |= (byte)(0x08);
			}

			if ((useSeekResult) != 0)
			{
				pik_flags |= (byte)(0x10);
			}

			sqlite3VdbeAddOp3(v, (int)(127), (int)(iDataCur), (int)(aRegIdx[i]), (int)(regNewData));
			if (pParse.nested == 0)
			{
				sqlite3VdbeAppendP4(v, pTab, (int)(-6));
			}

			sqlite3VdbeChangeP5(v, (ushort)(pik_flags));
		}
		public static void sqlite3ComputeGeneratedColumns(Parse pParse, int iRegStore, Table pTab)
		{
			int i = 0;
			Walker w = new Walker();
			Column* pRedo;
			int eProgress = 0;
			VdbeOp* pOp;

			sqlite3TableAffinity(pParse.pVdbe, pTab, (int)(iRegStore));
			if ((pTab.tabFlags & 0x00000040) != 0)
			{
				pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(-1));
				if ((pOp->opcode) == (95))
				{
					int ii = 0;
					int jj = 0;
					sbyte* zP4 = pOp->p4.z;


					for (ii = (int)(jj = (int)(0)); zP4[jj]; ii++)
					{
						if ((pTab.aCol[ii].colFlags & 0x0020) != 0)
						{
							continue;
						}

						if ((pTab.aCol[ii].colFlags & 0x0040) != 0)
						{
							zP4[jj] = (sbyte)(0x40);
						}

						jj++;
					}
				}
				else if ((pOp->opcode) == (94))
				{
					pOp->p3 = (int)(1);
				}
			}

			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((pTab.aCol[i].colFlags & 0x0060) != 0)
				{
					pTab.aCol[i].colFlags |= (ushort)(0x0080);
				}
			}

			w.u.pTab = pTab;
			w.xExprCallback = exprColumnFlagUnion;
			w.xSelectCallback = null;
			w.xSelectCallback2 = null;
			pParse.iSelfTab = (int)(-iRegStore);
			do
			{
				eProgress = (int)(0);
				pRedo = null;
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					Column* pCol = pTab.aCol + i;
					if ((pCol->colFlags & 0x0080) != 0)
					{
						int x = 0;
						pCol->colFlags |= (ushort)(0x0100);
						w.eCode = (ushort)(0);
						sqlite3WalkExpr(w, sqlite3ColumnExpr(pTab, pCol));
						pCol->colFlags &= (ushort)(~0x0100);
						if ((w.eCode & 0x0080) != 0)
						{
							pRedo = pCol;
							continue;
						}

						eProgress = (int)(1);

						x = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + iRegStore);
						sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(x));
						pCol->colFlags &= (ushort)(~0x0080);
					}
				}
			}
			while (((pRedo) != null) && ((eProgress) != 0));
			if ((pRedo) != null)
			{
				sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pRedo->zCnName);
			}

			pParse.iSelfTab = (int)(0);
		}
		public static void sqlite3ConstructBloomFilter(WhereInfo pWInfo, int iLevel, WhereLevel pLevel, ulong notReady)
		{
			int addrOnce = 0;
			int addrTop = 0;
			int addrCont = 0;
			WhereTerm pTerm;
			WhereTerm pWCEnd;
			Parse pParse = pWInfo.pParse;
			Vdbe v = pParse.pVdbe;
			WhereLoop pLoop = pLevel.pWLoop;
			int iCur = 0;



			addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
			do
			{
				SrcItem pItem;
				Table pTab;
				ulong sz = 0;
				sqlite3WhereExplainBloomFilter(pParse, pWInfo, pLevel);
				addrCont = (int)(sqlite3VdbeMakeLabel(pParse));
				iCur = (int)(pLevel.iTabCur);
				pLevel.regFilter = (int)(++pParse.nMem);
				pItem = pWInfo.pTabList.a[pLevel.iFrom];

				pTab = pItem.pTab;

				sz = (ulong)(sqlite3LogEstToInt((short)(pTab.nRowLogEst)));
				if ((sz) < (10000))
				{
					sz = (ulong)(10000);
				}
				else if ((sz) > (10000000))
				{
					sz = (ulong)(10000000);
				}

				sqlite3VdbeAddOp2(v, (int)(76), (int)(sz), (int)(pLevel.regFilter));
				addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
				pWCEnd = pWInfo.sWC.a[pWInfo.sWC.nTerm];
				for (pTerm = pWInfo.sWC.a; (pTerm) < (pWCEnd); pTerm++)
				{
					Expr pExpr = pTerm.pExpr;
					if (((pTerm.wtFlags & 0x0002) == (0)) && ((sqlite3ExprIsTableConstant(pExpr, (int)(iCur))) != 0))
					{
						sqlite3ExprIfFalse(pParse, pTerm.pExpr, (int)(addrCont), (int)(0x10));
					}
				}

				if ((pLoop.wsFlags & 0x00000100) != 0)
				{
					int r1 = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(r1));
					sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(r1), (int)(1));
					sqlite3ReleaseTempReg(pParse, (int)(r1));
				}
				else
				{
					Index pIdx = pLoop.u.btree.pIndex;
					int n = (int)(pLoop.u.btree.nEq);
					int r1 = (int)(sqlite3GetTempRange(pParse, (int)(n)));
					int jj = 0;
					for (jj = (int)(0); (jj) < (n); jj++)
					{
						int iCol = (int)(pIdx.aiColumn[jj]);

						sqlite3ExprCodeGetColumnOfTable(v, pIdx.pTable, (int)(iCur), (int)(iCol), (int)(r1 + jj));
					}

					sqlite3VdbeAddOp4Int(v, (int)(178), (int)(pLevel.regFilter), (int)(0), (int)(r1), (int)(n));
					sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(n));
				}

				sqlite3VdbeResolveLabel(v, (int)(addrCont));
				sqlite3VdbeAddOp2(v, (int)(5), (int)(pLevel.iTabCur), (int)(addrTop + 1));
				sqlite3VdbeJumpHere(v, (int)(addrTop));
				pLoop.wsFlags &= (uint)(~0x00400000);
				if ((((pParse.db).dbOptFlags & (0x00100000)) != 0))
					break;
				while ((++iLevel) < (pWInfo.nLevel))
				{
					SrcItem pTabItem;
					pLevel = pWInfo.a[iLevel];
					pTabItem = pWInfo.pTabList.a[pLevel.iFrom];
					if ((pTabItem.fg.jointype & 0x0008) != 0)
						continue;
					pLoop = pLevel.pWLoop;
					if (((pLoop) == (null)))
						continue;
					if ((pLoop.prereq & notReady) != 0)
						continue;
					if ((pLoop.wsFlags & (0x00400000 | 0x00000004)) == (0x00400000))
					{
						break;
					}
				}
			}
			while ((iLevel) < (pWInfo.nLevel));
			sqlite3VdbeJumpHere(v, (int)(addrOnce));
		}
		public static int sqlite3CorruptError(int lineno)
		{
			return (int)(sqlite3ReportError((int)(11), (int)(lineno), "database corruption"));
		}
		public static Expr sqlite3CreateColumnExpr(sqlite3 db, SrcList pSrc, int iSrc, int iCol)
		{
			Expr p = sqlite3ExprAlloc(db, (int)(167), null, (int)(0));
			if ((p) != null)
			{
				SrcItem pItem = pSrc.a[iSrc];
				Table pTab;

				pTab = p.y.pTab = pItem.pTab;
				p.iTable = (int)(pItem.iCursor);
				if ((p.y.pTab.iPKey) == (iCol))
				{
					p.iColumn = (short)(-1);
				}
				else
				{
					p.iColumn = ((short)(iCol));
					if (((pTab.tabFlags & 0x00000060) != 0) && ((pTab.aCol[iCol].colFlags & 0x0060) != 0))
					{
						pItem.colUsed = (ulong)((pTab.nCol) >= (64) ? ((ulong)(-1)) : (((ulong)(1)) << (pTab.nCol)) - 1);
					}
					else
					{
						pItem.colUsed |= (ulong)(((ulong)(1)) << ((iCol) >= ((int)(sizeof(ulong) * 8)) ? ((int)(sizeof(ulong) * 8)) - 1 : iCol));
					}
				}
			}

			return p;
		}
		public static void sqlite3CreateForeignKey(Parse pParse, ExprList pFromCol, Token* pTo, ExprList pToCol, int flags)
		{
			sqlite3 db = pParse.db;
			FKey pFKey = null;
			FKey pNextTo;
			Table p = pParse.pNewTable;
			long nByte = 0;
			int i = 0;
			int nCol = 0;
			sbyte* z;

			if (((p) == (null)) || ((pParse.eParseMode) == (1)))
				goto fk_end;
			if ((pFromCol) == (null))
			{
				int iCol = (int)(p.nCol - 1);
				if (((iCol) < (0)))
					goto fk_end;
				if (((pToCol) != null) && (pToCol.nExpr != 1))
				{
					sqlite3ErrorMsg(pParse, "foreign key on %s should reference only one column of table %T", p.aCol[iCol].zCnName, pTo);
					goto fk_end;
				}

				nCol = (int)(1);
			}
			else if (((pToCol) != null) && (pToCol.nExpr != pFromCol.nExpr))
			{
				sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of columns in the referenced table");
				goto fk_end;
			}
			else
			{
				nCol = (int)(pFromCol.nExpr);
			}

			nByte = (long)(sizeof(FKey) + (nCol - 1) * sizeof(sColMap) + pTo->n + 1);
			if ((pToCol) != null)
			{
				for (i = (int)(0); (i) < (pToCol.nExpr); i++)
				{
					nByte += (long)(sqlite3Strlen30(pToCol.a[i].zEName) + 1);
				}
			}

			pFKey = sqlite3DbMallocZero(db, (ulong)(nByte));
			if ((pFKey) == (null))
			{
				goto fk_end;
			}

			pFKey.pFrom = p;

			pFKey.pNextFrom = p.u.tab.pFKey;
			z = (sbyte*)(&pFKey.aCol[nCol]);
			pFKey.zTo = z;
			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameTokenMap(pParse, (void*)(z), pTo);
			}

			CRuntime.memcpy(z, pTo->z, (ulong)(pTo->n));
			z[pTo->n] = (sbyte)(0);
			sqlite3Dequote(z);
			z += pTo->n + 1;
			pFKey.nCol = (int)(nCol);
			if ((pFromCol) == (null))
			{
				pFKey.aCol[0].iFrom = (int)(p.nCol - 1);
			}
			else
			{
				for (i = (int)(0); (i) < (nCol); i++)
				{
					int j = 0;
					for (j = (int)(0); (j) < (p.nCol); j++)
					{
						if ((sqlite3StrICmp(p.aCol[j].zCnName, pFromCol.a[i].zEName)) == (0))
						{
							pFKey.aCol[i].iFrom = (int)(j);
							break;
						}
					}

					if ((j) >= (p.nCol))
					{
						sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition", pFromCol.a[i].zEName);
						goto fk_end;
					}

					if (((pParse.eParseMode) >= (2)))
					{
						sqlite3RenameTokenRemap(pParse, &pFKey.aCol[i], pFromCol.a[i].zEName);
					}
				}
			}

			if ((pToCol) != null)
			{
				for (i = (int)(0); (i) < (nCol); i++)
				{
					int n = (int)(sqlite3Strlen30(pToCol.a[i].zEName));
					pFKey.aCol[i].zCol = z;
					if (((pParse.eParseMode) >= (2)))
					{
						sqlite3RenameTokenRemap(pParse, z, pToCol.a[i].zEName);
					}

					CRuntime.memcpy(z, pToCol.a[i].zEName, (ulong)(n));
					z[n] = (sbyte)(0);
					z += n + 1;
				}
			}

			pFKey.isDeferred = (byte)(0);
			pFKey.aAction[0] = ((byte)(flags & 0xff));
			pFKey.aAction[1] = ((byte)((flags >> 8) & 0xff));

			pNextTo = (FKey)(sqlite3HashInsert(&p.pSchema.fkeyHash, pFKey.zTo, (void*)(pFKey)));
			if ((pNextTo) == (pFKey))
			{
				sqlite3OomFault(db);
				goto fk_end;
			}

			if ((pNextTo) != null)
			{

				pFKey.pNextTo = pNextTo;
				pNextTo.pPrevTo = pFKey;
			}


			p.u.tab.pFKey = pFKey;
			pFKey = null;
		fk_end:
			; sqlite3DbFree(db, pFKey);
			sqlite3ExprListDelete(db, pFromCol);
			sqlite3ExprListDelete(db, pToCol);
		}
		public static int sqlite3CreateFunc(sqlite3 db, sbyte* zFunctionName, int nArg, int enc, void* pUserData, delegate67 xSFunc, delegate67 xStep, delegate68 xFinal, delegate68 xValue, delegate67 xInverse, FuncDestructor pDestructor)
		{
			FuncDef p;
			int extraFlags = 0;


			if (((((((zFunctionName) == (null)) || ((xSFunc != null) && (xFinal != null))) || (((xFinal) == (null)) != ((xStep) == (null)))) || (((xValue) == (null)) != ((xInverse) == (null)))) || (((nArg) < (-1)) || ((nArg) > (127)))) || ((255) < (sqlite3Strlen30(zFunctionName))))
			{
				return (int)(sqlite3MisuseError((int)(170308)));
			}



			extraFlags = (int)(enc & (0x000000800 | 0x000080000 | 0x000100000 | 0x000200000));
			enc &= (int)(0x0003 | 5);

			extraFlags ^= (int)(0x00200000);
			switch (enc)
			{
				case 4:
					enc = (int)(2);
					break;
				case 5:
					{
						int rc = 0;
						rc = (int)(sqlite3CreateFunc(db, zFunctionName, (int)(nArg), (int)((1 | extraFlags) ^ 0x00200000), pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor));
						if ((rc) == (0))
						{
							rc = (int)(sqlite3CreateFunc(db, zFunctionName, (int)(nArg), (int)((2 | extraFlags) ^ 0x00200000), pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor));
						}

						if (rc != 0)
						{
							return (int)(rc);
						}

						enc = (int)(3);
						break;
					}

				case 1:
				case 2:
				case 3:
					break;
				default:
					enc = (int)(1);
					break;
			}

			p = sqlite3FindFunction(db, zFunctionName, (int)(nArg), (byte)(enc), (byte)(0));
			if ((((p) != null) && ((p.funcFlags & 0x0003) == ((uint)(enc)))) && ((p.nArg) == (nArg)))
			{
				if ((db.nVdbeActive) != 0)
				{
					sqlite3ErrorWithMsg(db, (int)(5), "unable to delete/modify user-function due to active statements");

					return (int)(5);
				}
				else
				{
					sqlite3ExpirePreparedStatements(db, (int)(0));
				}
			}
			else if (((xSFunc) == (null)) && ((xFinal) == (null)))
			{
				return (int)(0);
			}

			p = sqlite3FindFunction(db, zFunctionName, (int)(nArg), (byte)(enc), (byte)(1));

			if (p == null)
			{
				return (int)(7);
			}

			functionDestroy(db, p);
			if ((pDestructor) != null)
			{
				pDestructor.nRef++;
			}

			p.u.pDestructor = pDestructor;
			p.funcFlags = (uint)((p.funcFlags & 0x0003) | extraFlags);
			p.xSFunc = xSFunc ? xSFunc : xStep;
			p.xFinalize = xFinal;
			p.xValue = xValue;
			p.xInverse = xInverse;
			p.pUserData = pUserData;
			p.nArg = (sbyte)((ushort)(nArg));
			return (int)(0);
		}
		public static void sqlite3CreateIndex(Parse pParse, Token* pName1, Token* pName2, SrcList pTblName, ExprList pList, int onError, Token* pStart, Expr pPIWhere, int sortOrder, int ifNotExist, byte idxType)
		{
			Table pTab = null;
			Index pIndex = null;
			sbyte* zName = null;
			int nName = 0;
			int i = 0; int j = 0;
			DbFixer sFix = new DbFixer();
			int sortOrderMask = 0;
			sqlite3 db = pParse.db;
			Db pDb;
			int iDb = 0;
			Token* pName = null;
			ExprList_item* pListItem;
			int nExtra = (int)(0);
			int nExtraCol = 0;
			sbyte* zExtra = null;
			Index pPk = null;

			if ((pParse.nErr) != 0)
			{
				goto exit_create_index;
			}


			if (((pParse.eParseMode) == (1)) && (idxType != 2))
			{
				goto exit_create_index;
			}

			if (0 != sqlite3ReadSchema(pParse))
			{
				goto exit_create_index;
			}

			if ((sqlite3HasExplicitNulls(pParse, pList)) != 0)
			{
				goto exit_create_index;
			}

			if (pTblName != null)
			{

				iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pName));
				if ((iDb) < (0))
					goto exit_create_index;

				if (db.init.busy == 0)
				{
					pTab = sqlite3SrcListLookup(pParse, pTblName);
					if ((((pName2->n) == (0)) && ((pTab) != null)) && ((pTab.pSchema) == (db.aDb[1].pSchema)))
					{
						iDb = (int)(1);
					}
				}

				sqlite3FixInit(sFix, pParse, (int)(iDb), "index", pName);
				if ((sqlite3FixSrcList(sFix, pTblName)) != 0)
				{

				}

				pTab = sqlite3LocateTableItem(pParse, (uint)(0), pTblName.a[0]);

				if ((pTab) == (null))
					goto exit_create_index;
				if (((iDb) == (1)) && (db.aDb[iDb].pSchema != pTab.pSchema))
				{
					sqlite3ErrorMsg(pParse, "cannot create a TEMP index on non-TEMP table \"%s\"", pTab.zName);
					goto exit_create_index;
				}

				if (!(((pTab).tabFlags & 0x00000080) == (0)))
					pPk = sqlite3PrimaryKeyIndex(pTab);
			}
			else
			{


				pTab = pParse.pNewTable;
				if (pTab == null)
					goto exit_create_index;
				iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			}

			pDb = db.aDb[iDb];

			if ((((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0)) && ((db.init.busy) == (0))) && (pTblName != null))
			{
				sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab.zName);
				goto exit_create_index;
			}

			if ((((pTab).eTabType) == (2)))
			{
				sqlite3ErrorMsg(pParse, "views may not be indexed");
				goto exit_create_index;
			}

			if ((((pTab).eTabType) == (1)))
			{
				sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
				goto exit_create_index;
			}

			if ((pName) != null)
			{
				zName = sqlite3NameFromToken(db, pName);
				if ((zName) == (null))
					goto exit_create_index;

				if (0 != sqlite3CheckObjectName(pParse, zName, "index", pTab.zName))
				{
					goto exit_create_index;
				}

				if (!((pParse.eParseMode) >= (2)))
				{
					if (db.init.busy == 0)
					{
						if (sqlite3FindTable(db, zName, null) != null)
						{
							sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
							goto exit_create_index;
						}
					}

					if (sqlite3FindIndex(db, zName, pDb.zDbSName) != null)
					{
						if (ifNotExist == 0)
						{
							sqlite3ErrorMsg(pParse, "index %s already exists", zName);
						}
						else
						{

							sqlite3CodeVerifySchema(pParse, (int)(iDb));
							sqlite3ForceNotReadOnly(pParse);
						}

						goto exit_create_index;
					}
				}
			}
			else
			{
				int n = 0;
				Index pLoop;
				for (pLoop = pTab.pIndex, n = (int)(1); pLoop; pLoop = pLoop.pNext, n++)
				{
				}

				zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab.zName, (int)(n));
				if ((zName) == (null))
				{
					goto exit_create_index;
				}

				if ((pParse.eParseMode != 0))
					zName[7]++;
			}

			if (!((pParse.eParseMode) >= (2)))
			{
				sbyte* zDb = pDb.zDbSName;
				if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
				{
					goto exit_create_index;
				}

				i = (int)(1);
				if ((0 == 0) && ((iDb) == (1)))
					i = (int)(3);
				if ((sqlite3AuthCheck(pParse, (int)(i), zName, pTab.zName, zDb)) != 0)
				{
					goto exit_create_index;
				}
			}

			if ((pList) == (null))
			{
				Token prevCol = new Token();
				Column* pCol = &pTab.aCol[pTab.nCol - 1];
				pCol->colFlags |= (ushort)(0x0008);
				sqlite3TokenInit(&prevCol, pCol->zCnName);
				pList = sqlite3ExprListAppend(pParse, null, sqlite3ExprAlloc(db, (int)(59), &prevCol, (int)(0)));
				if ((pList) == (null))
					goto exit_create_index;

				sqlite3ExprListSetSortOrder(pList, (int)(sortOrder), (int)(-1));
			}
			else
			{
				sqlite3ExprListCheckLength(pParse, pList, "index");
				if ((pParse.nErr) != 0)
					goto exit_create_index;
			}

			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				Expr pExpr = pList.a[i].pExpr;

				if ((pExpr.op) == (113))
				{

					nExtra += (int)(1 + sqlite3Strlen30(pExpr.u.zToken));
				}
			}

			nName = (int)(sqlite3Strlen30(zName));
			nExtraCol = (int)(pPk ? pPk.nKeyCol : 1);

			pIndex = sqlite3AllocateIndexObject(db, (short)(pList.nExpr + nExtraCol), (int)(nName + nExtra + 1), &zExtra);
			if ((db.mallocFailed) != 0)
			{
				goto exit_create_index;
			}



			pIndex.zName = zExtra;
			zExtra += nName + 1;
			CRuntime.memcpy(pIndex.zName, zName, (ulong)(nName + 1));
			pIndex.pTable = pTab;
			pIndex.onError = ((byte)(onError));
			pIndex.uniqNotNull = (uint)(onError != 0);
			pIndex.idxType = (uint)(idxType);
			pIndex.pSchema = db.aDb[iDb].pSchema;
			pIndex.nKeyCol = (ushort)(pList.nExpr);
			if ((pPIWhere) != null)
			{
				sqlite3ResolveSelfReference(pParse, pTab, (int)(0x000002), pPIWhere, null);
				pIndex.pPartIdxWhere = pPIWhere;
				pPIWhere = null;
			}


			if ((pDb.pSchema.file_format) >= (4))
			{
				sortOrderMask = (int)(-1);
			}
			else
			{
				sortOrderMask = (int)(0);
			}

			pListItem = pList.a;
			if (((pParse.eParseMode) >= (2)))
			{
				pIndex.aColExpr = pList;
				pList = null;
			}

			for (i = (int)(0); (i) < (pIndex.nKeyCol); i++, pListItem++)
			{
				Expr pCExpr;
				int requestedSortOrder = 0;
				sbyte* zColl;
				sqlite3StringToId(pListItem->pExpr);
				sqlite3ResolveSelfReference(pParse, pTab, (int)(0x000020), pListItem->pExpr, null);
				if ((pParse.nErr) != 0)
					goto exit_create_index;
				pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
				if (pCExpr.op != 167)
				{
					if ((pTab) == (pParse.pNewTable))
					{
						sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and UNIQUE constraints");
						goto exit_create_index;
					}

					if ((pIndex.aColExpr) == (null))
					{
						pIndex.aColExpr = pList;
						pList = null;
					}

					j = (int)(-2);
					pIndex.aiColumn[i] = (short)(-2);
					pIndex.uniqNotNull = (uint)(0);
				}
				else
				{
					j = (int)(pCExpr.iColumn);

					if ((j) < (0))
					{
						j = (int)(pTab.iPKey);
					}
					else
					{
						if ((pTab.aCol[j].notNull) == (0))
						{
							pIndex.uniqNotNull = (uint)(0);
						}

						if ((pTab.aCol[j].colFlags & 0x0020) != 0)
						{
							pIndex.bHasVCol = (uint)(1);
						}
					}

					pIndex.aiColumn[i] = ((short)(j));
				}

				zColl = null;
				if ((pListItem->pExpr.op) == (113))
				{
					int nColl = 0;

					zColl = pListItem->pExpr.u.zToken;
					nColl = (int)(sqlite3Strlen30(zColl) + 1);

					CRuntime.memcpy(zExtra, zColl, (ulong)(nColl));
					zColl = zExtra;
					zExtra += nColl;
					nExtra -= (int)(nColl);
				}
				else if ((j) >= (0))
				{
					zColl = sqlite3ColumnColl(&pTab.aCol[j]);
				}

				if (zColl == null)
					zColl = sqlite3StrBINARY;
				if ((db.init.busy == 0) && (sqlite3LocateCollSeq(pParse, zColl) == null))
				{
					goto exit_create_index;
				}

				pIndex.azColl[i] = zColl;
				requestedSortOrder = (int)(pListItem->sortFlags & sortOrderMask);
				pIndex.aSortOrder[i] = ((byte)(requestedSortOrder));
			}

			if ((pPk) != null)
			{
				for (j = (int)(0); (j) < (pPk.nKeyCol); j++)
				{
					int x = (int)(pPk.aiColumn[j]);

					if ((isDupColumn(pIndex, (int)(pIndex.nKeyCol), pPk, (int)(j))) != 0)
					{
						pIndex.nColumn--;
					}
					else
					{
						pIndex.aiColumn[i] = (short)(x);
						pIndex.azColl[i] = pPk.azColl[j];
						pIndex.aSortOrder[i] = (byte)(pPk.aSortOrder[j]);
						i++;
					}
				}


			}
			else
			{
				pIndex.aiColumn[i] = (short)(-1);
				pIndex.azColl[i] = sqlite3StrBINARY;
			}

			sqlite3DefaultRowEst(pIndex);
			if ((pParse.pNewTable) == (null))
				estimateIndexWidth(pIndex);

			recomputeColumnsNotIndexed(pIndex);
			if ((pTblName != null) && ((pIndex.nColumn) >= (pTab.nCol)))
			{
				pIndex.isCovering = (uint)(1);
				for (j = (int)(0); (j) < (pTab.nCol); j++)
				{
					if ((j) == (pTab.iPKey))
						continue;
					if ((sqlite3TableColumnToIndex(pIndex, (short)(j))) >= (0))
						continue;
					pIndex.isCovering = (uint)(0);
					break;
				}
			}

			if ((pTab) == (pParse.pNewTable))
			{
				Index pIdx;
				for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
				{
					int k = 0;



					if (pIdx.nKeyCol != pIndex.nKeyCol)
						continue;
					for (k = (int)(0); (k) < (pIdx.nKeyCol); k++)
					{
						sbyte* z1;
						sbyte* z2;

						if (pIdx.aiColumn[k] != pIndex.aiColumn[k])
							break;
						z1 = pIdx.azColl[k];
						z2 = pIndex.azColl[k];
						if ((sqlite3StrICmp(z1, z2)) != 0)
							break;
					}

					if ((k) == (pIdx.nKeyCol))
					{
						if (pIdx.onError != pIndex.onError)
						{
							if (!(((pIdx.onError) == (11)) || ((pIndex.onError) == (11))))
							{
								sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified", (int)(0));
							}

							if ((pIdx.onError) == (11))
							{
								pIdx.onError = (byte)(pIndex.onError);
							}
						}

						if ((idxType) == (2))
							pIdx.idxType = (uint)(idxType);
						if (((pParse.eParseMode) >= (2)))
						{
							pIndex.pNext = pParse.pNewIndex;
							pParse.pNewIndex = pIndex;
							pIndex = null;
						}

						goto exit_create_index;
					}
				}
			}

			if (!((pParse.eParseMode) >= (2)))
			{

				if ((db.init.busy) != 0)
				{
					Index p;


					if (pTblName != null)
					{
						pIndex.tnum = (uint)(db.init.newTnum);
						if ((sqlite3IndexHasDuplicateRootPage(pIndex)) != 0)
						{
							sqlite3ErrorMsg(pParse, "invalid rootpage");
							pParse.rc = (int)(sqlite3CorruptError((int)(118252)));
							goto exit_create_index;
						}
					}

					p = sqlite3HashInsert(&pIndex.pSchema.idxHash, pIndex.zName, pIndex);
					if ((p) != null)
					{

						sqlite3OomFault(db);
						goto exit_create_index;
					}

					db.mDbFlags |= (uint)(0x0001);
				}
				else if ((((pTab).tabFlags & 0x00000080) == (0)) || (pTblName != null))
				{
					Vdbe v;
					sbyte* zStmt;
					int iMem = (int)(++pParse.nMem);
					v = sqlite3GetVdbe(pParse);
					if ((v) == (null))
						goto exit_create_index;
					sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
					pIndex.tnum = ((uint)(sqlite3VdbeAddOp0(v, (int)(182))));
					sqlite3VdbeAddOp3(v, (int)(146), (int)(iDb), (int)(iMem), (int)(2));

					if ((pStart) != null)
					{
						int n = (int)((int)(pParse.sLastToken.z - pName->z) + pParse.sLastToken.n);
						if ((pName->z[n - 1]) == (59))
							n--;
						zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s", (onError) == (0) ? "" : " UNIQUE", (int)(n), pName->z);
					}
					else
					{
						zStmt = null;
					}

					sqlite3NestedParse(pParse, "INSERT INTO %Q.sqlite_master VALUES('index',%Q,%Q,#%d,%Q);", db.aDb[iDb].zDbSName, pIndex.zName, pTab.zName, (int)(iMem), zStmt);
					sqlite3DbFree(db, zStmt);
					if ((pTblName) != null)
					{
						sqlite3RefillIndex(pParse, pIndex, (int)(iMem));
						sqlite3ChangeCookie(pParse, (int)(iDb));
						sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex.zName), (ushort)(0));
						sqlite3VdbeAddOp2(v, (int)(165), (int)(0), (int)(1));
					}

					sqlite3VdbeJumpHere(v, (int)(pIndex.tnum));
				}
			}

			if (((db.init.busy) != 0) || ((pTblName) == (null)))
			{
				pIndex.pNext = pTab.pIndex;
				pTab.pIndex = pIndex;
				pIndex = null;
			}
			else if (((pParse.eParseMode) >= (2)))
			{

				pParse.pNewIndex = pIndex;
				pIndex = null;
			}

		exit_create_index:
			; if ((pIndex) != null) sqlite3FreeIndex(db, pIndex);
			if ((pTab) != null)
			{
				Index ppFrom;
				Index pThis;
				for (ppFrom = pTab.pIndex; (pThis = ppFrom) != null; ppFrom = pThis.pNext)
				{
					Index pNext;
					if (pThis.onError != 5)
						continue;
					while (((pNext = pThis.pNext) != null) && (pNext.onError != 5))
					{
						ppFrom = pNext;
						pThis.pNext = pNext.pNext;
						pNext.pNext = pThis;
						ppFrom = pNext.pNext;
					}

					break;
				}
			}

			sqlite3ExprDelete(db, pPIWhere);
			sqlite3ExprListDelete(db, pList);
			sqlite3SrcListDelete(db, pTblName);
			sqlite3DbFree(db, zName);
		}
		public static void sqlite3CreateView(Parse pParse, Token* pBegin, Token* pName1, Token* pName2, ExprList pCNames, Select pSelect, int isTemp, int noErr)
		{
			Table p;
			int n = 0;
			sbyte* z;
			Token sEnd = new Token();
			DbFixer sFix = new DbFixer();
			Token* pName = null;
			int iDb = 0;
			sqlite3 db = pParse.db;
			if ((pParse.nVar) > (0))
			{
				sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
				goto create_view_fail;
			}

			sqlite3StartTable(pParse, pName1, pName2, (int)(isTemp), (int)(1), (int)(0), (int)(noErr));
			p = pParse.pNewTable;
			if (((p) == (null)) || ((pParse.nErr) != 0))
				goto create_view_fail;
			p.tabFlags |= (uint)(0x00000200);
			sqlite3TwoPartName(pParse, pName1, pName2, &pName);
			iDb = (int)(sqlite3SchemaToIndex(db, p.pSchema));
			sqlite3FixInit(sFix, pParse, (int)(iDb), "view", pName);
			if ((sqlite3FixSelect(sFix, pSelect)) != 0)
				goto create_view_fail;
			pSelect.selFlags |= (uint)(0x0200000);
			if (((pParse.eParseMode) >= (2)))
			{
				p.u.view.pSelect = pSelect;
				pSelect = null;
			}
			else
			{
				p.u.view.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001));
			}

			p.pCheck = sqlite3ExprListDup(db, pCNames, (int)(0x0001));
			p.eTabType = (byte)(2);
			if ((db.mallocFailed) != 0)
				goto create_view_fail;
			sEnd = (Token)(pParse.sLastToken);

			if (sEnd.z[0] != 59)
			{
				sEnd.z += sEnd.n;
			}

			sEnd.n = (uint)(0);
			n = ((int)(sEnd.z - pBegin->z));

			z = pBegin->z;
			while ((sqlite3CtypeMap[(byte)(z[n - 1])] & 0x01) != 0)
			{
				n--;
			}

			sEnd.z = &z[n - 1];
			sEnd.n = (uint)(1);
			sqlite3EndTable(pParse, null, &sEnd, (uint)(0), null);
		create_view_fail:
			; sqlite3SelectDelete(db, pSelect);
			if (((pParse.eParseMode) >= (2)))
			{
				sqlite3RenameExprlistUnmap(pParse, pCNames);
			}

			sqlite3ExprListDelete(db, pCNames);
			return;
		}
		public static void sqlite3CteDelete(sqlite3 db, Cte pCte)
		{

			cteClear(db, pCte);
			sqlite3DbFree(db, pCte);
		}
		public static Cte sqlite3CteNew(Parse pParse, Token* pName, ExprList pArglist, Select pQuery, byte eM10d)
		{
			Cte pNew;
			sqlite3 db = pParse.db;
			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Cte)));

			if ((db.mallocFailed) != 0)
			{
				sqlite3ExprListDelete(db, pArglist);
				sqlite3SelectDelete(db, pQuery);
			}
			else
			{
				pNew.pSelect = pQuery;
				pNew.pCols = pArglist;
				pNew.zName = sqlite3NameFromToken(pParse.db, pName);
				pNew.eM10d = (byte)(eM10d);
			}

			return pNew;
		}
		public static void sqlite3DbFree(sqlite3 db, void* p)
		{

			if ((p) != null)
				sqlite3DbFreeNN(db, p);
		}
		public static void sqlite3DbFreeNN(sqlite3 db, void* p)
		{


			if ((db) != null)
			{
				if ((db.pnBytesFreed) != null)
				{
					measureAllocationSize(db, p);
					return;
				}

				if (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))
				{
					if (((ulong)(p)) >= ((ulong)(db.lookaside.pMiddle)))
					{
						LookasideSlot* pBuf = (LookasideSlot*)(p);
						pBuf->pNext = db.lookaside.pSmallFree;
						db.lookaside.pSmallFree = pBuf;
						return;
					}

					if (((ulong)(p)) >= ((ulong)(db.lookaside.pStart)))
					{
						LookasideSlot* pBuf = (LookasideSlot*)(p);
						pBuf->pNext = db.lookaside.pFree;
						db.lookaside.pFree = pBuf;
						return;
					}
				}
			}




			sqlite3_free(p);
		}
		public static int sqlite3DbIsNamed(sqlite3 db, int iDb, sbyte* zName)
		{
			return ((((sqlite3StrICmp(db.aDb[iDb].zDbSName, zName)) == (0)) || (((iDb) == (0)) && ((sqlite3StrICmp("main", zName)) == (0)))) ? 1 : 0);
		}
		public static void* sqlite3DbMallocRaw(sqlite3 db, ulong n)
		{
			void* p;
			if ((db) != null)
				return sqlite3DbMallocRawNN(db, (ulong)(n));
			p = sqlite3Malloc((ulong)(n));
			return p;
		}
		public static void* sqlite3DbMallocRawNN(sqlite3 db, ulong n)
		{
			LookasideSlot* pBuf;



			if ((n) > (db.lookaside.sz))
			{
				if (db.lookaside.bDisable == 0)
				{
					db.lookaside.anStat[1]++;
				}
				else if ((db.mallocFailed) != 0)
				{
					return null;
				}

				return dbMallocRawFinish(db, (ulong)(n));
			}

			if ((n) <= (128))
			{
				if ((pBuf = db.lookaside.pSmallFree) != null)
				{
					db.lookaside.pSmallFree = pBuf->pNext;
					db.lookaside.anStat[0]++;
					return (void*)(pBuf);
				}
				else if ((pBuf = db.lookaside.pSmallInit) != null)
				{
					db.lookaside.pSmallInit = pBuf->pNext;
					db.lookaside.anStat[0]++;
					return (void*)(pBuf);
				}
			}

			if ((pBuf = db.lookaside.pFree) != null)
			{
				db.lookaside.pFree = pBuf->pNext;
				db.lookaside.anStat[0]++;
				return (void*)(pBuf);
			}
			else if ((pBuf = db.lookaside.pInit) != null)
			{
				db.lookaside.pInit = pBuf->pNext;
				db.lookaside.anStat[0]++;
				return (void*)(pBuf);
			}
			else
			{
				db.lookaside.anStat[2]++;
			}

			return dbMallocRawFinish(db, (ulong)(n));
		}
		public static int sqlite3DbMallocSize(sqlite3 db, void* p)
		{

			if ((db) != null)
			{
				if (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))
				{
					if (((ulong)(p)) >= ((ulong)(db.lookaside.pMiddle)))
					{

						return (int)(128);
					}

					if (((ulong)(p)) >= ((ulong)(db.lookaside.pStart)))
					{

						return (int)(db.lookaside.szTrue);
					}
				}
			}

			return (int)(sqlite3Config.m.xSize(p));
		}
		public static void* sqlite3DbMallocZero(sqlite3 db, ulong n)
		{
			void* p;
			p = sqlite3DbMallocRaw(db, (ulong)(n));
			if ((p) != null)
				CRuntime.memset(p, (int)(0), (ulong)(n));
			return p;
		}
		public static Btree sqlite3DbNameToBtree(sqlite3 db, sbyte* zDbName)
		{
			int iDb = (int)((zDbName) != 0 ? sqlite3FindDbName(db, zDbName) : 0);
			return (iDb) < (0) ? null : db.aDb[iDb].pBt;
		}
		public static void* sqlite3DbRealloc(sqlite3 db, void* p, ulong n)
		{

			if ((p) == (null))
				return sqlite3DbMallocRawNN(db, (ulong)(n));

			if (((ulong)(p)) < ((ulong)(db.lookaside.pEnd)))
			{
				if (((ulong)(p)) >= ((ulong)(db.lookaside.pMiddle)))
				{
					if ((n) <= (128))
						return p;
				}
				else if (((ulong)(p)) >= ((ulong)(db.lookaside.pStart)))
				{
					if ((n) <= (db.lookaside.szTrue))
						return p;
				}
			}

			return dbReallocFinish(db, p, (ulong)(n));
		}
		public static void* sqlite3DbReallocOrFree(sqlite3 db, void* p, ulong n)
		{
			void* pNew;
			pNew = sqlite3DbRealloc(db, p, (ulong)(n));
			if (pNew == null)
			{
				sqlite3DbFree(db, p);
			}

			return pNew;
		}
		public static sbyte* sqlite3DbSpanDup(sqlite3 db, sbyte* zStart, sbyte* zEnd)
		{
			int n = 0;
			while ((sqlite3CtypeMap[(byte)(zStart[0])] & 0x01) != 0)
			{
				zStart++;
			}

			n = ((int)(zEnd - zStart));
			while (((n) > (0)) && ((sqlite3CtypeMap[(byte)(zStart[n - 1])] & 0x01) != 0))
			{
				n--;
			}

			return sqlite3DbStrNDup(db, zStart, (ulong)(n));
		}
		public static sbyte* sqlite3DbStrDup(sqlite3 db, sbyte* z)
		{
			sbyte* zNew;
			ulong n = 0;
			if ((z) == (null))
			{
				return null;
			}

			n = (ulong)(CRuntime.strlen(z) + 1);
			zNew = sqlite3DbMallocRaw(db, (ulong)(n));
			if ((zNew) != null)
			{
				CRuntime.memcpy(zNew, z, (ulong)(n));
			}

			return zNew;
		}
		public static sbyte* sqlite3DbStrNDup(sqlite3 db, sbyte* z, ulong n)
		{
			sbyte* zNew;



			zNew = (z) != 0 ? sqlite3DbMallocRawNN(db, (ulong)(n + 1)) : null;
			if ((zNew) != null)
			{
				CRuntime.memcpy(zNew, z, (ulong)(n));
				zNew[n] = (sbyte)(0);
			}

			return zNew;
		}
		public static int sqlite3DecOrHexToI64(sbyte* z, long* pOut)
		{
			if (((z[0]) == (48)) && (((z[1]) == (120)) || ((z[1]) == (88))))
			{
				ulong u = (ulong)(0);
				int i = 0;
				int k = 0;
				for (i = (int)(2); (z[i]) == (48); i++)
				{
				}

				for (k = (int)(i); (sqlite3CtypeMap[(byte)(z[k])] & 0x08); k++)
				{
					u = (ulong)(u * 16 + sqlite3HexToInt((int)(z[k])));
				}

				CRuntime.memcpy(pOut, &u, (ulong)(8));
				return (int)((((z[k]) == (0)) && ((k - i) <= (16))) ? 0 : 2);
			}
			else
			{
				return (int)(sqlite3Atoi64(z, pOut, (int)(sqlite3Strlen30(z)), (byte)(1)));
			}
		}
		public static sqlite3_mutex_methods sqlite3DefaultMutex()
		{
			return sqlite3DefaultMutex_sMutex;
		}
		public static void sqlite3DefaultRowEst(Index pIdx)
		{
			short* a = pIdx.aiRowLogEst;
			short x = 0;
			int nCopy = (int)(((int)(5 * sizeof(short) / sizeof(short))) < (pIdx.nKeyCol) ? ((int)(5 * sizeof(short) / sizeof(short))) : (pIdx.nKeyCol));
			int i = 0;

			x = (short)(pIdx.pTable.nRowLogEst);

			if ((x) < (99))
			{
				pIdx.pTable.nRowLogEst = (short)(x = (short)(99));
			}

			if (pIdx.pPartIdxWhere != null)
			{
				x -= (short)(10);

			}

			a[0] = (short)(x);
			CRuntime.memcpy(&a[1], sqlite3DefaultRowEst_aVal, (ulong)(nCopy * sizeof(short)));
			for (i = (int)(nCopy + 1); (i) <= (pIdx.nKeyCol); i++)
			{
				a[i] = (short)(23);

			}


			if (((pIdx).onError != 0))
				a[pIdx.nKeyCol] = (short)(0);
		}
		public static void sqlite3DeferForeignKey(Parse pParse, int isDeferred)
		{
			Table pTab;
			FKey pFKey;
			if ((pTab = pParse.pNewTable) == (null))
				return;
			if ((!(((pTab).eTabType) == (0))) != 0)
				return;
			if ((pFKey = pTab.u.tab.pFKey) == (null))
				return;

			pFKey.isDeferred = ((byte)(isDeferred));
		}
		public static void sqlite3DeleteColumnNames(sqlite3 db, Table pTable)
		{
			int i = 0;
			Column* pCol;

			if ((pCol = pTable.aCol) != null)
			{
				for (i = (int)(0); (i) < (pTable.nCol); i++, pCol++)
				{

					sqlite3DbFree(db, pCol->zCnName);
				}

				sqlite3DbFree(db, pTable.aCol);
				if ((((pTable).eTabType) == (0)))
				{
					sqlite3ExprListDelete(db, pTable.u.tab.pDfltList);
				}

				if (((db) == (null)) || ((db.pnBytesFreed) == (null)))
				{
					pTable.aCol = null;
					pTable.nCol = (short)(0);
					if ((((pTable).eTabType) == (0)))
					{
						pTable.u.tab.pDfltList = null;
					}
				}
			}
		}
		public static void sqlite3DeleteFrom(Parse pParse, SrcList pTabList, Expr pWhere, ExprList pOrderBy, Expr pLimit)
		{
			Vdbe v;
			Table pTab;
			int i = 0;
			WhereInfo pWInfo;
			Index pIdx;
			int iTabCur = 0;
			int iDataCur = (int)(0);
			int iIdxCur = (int)(0);
			int nIdx = 0;
			sqlite3 db;
			AuthContext sContext = new AuthContext();
			NameContext sNC = new NameContext();
			int iDb = 0;
			int memCnt = (int)(0);
			int rcauth = 0;
			int eOnePass = 0;
			int* aiCurOnePass = stackalloc int[2];
			byte* aToOpen = null;
			Index pPk;
			int iPk = (int)(0);
			short nPk = (short)(1);
			int iKey = 0;
			short nKey = 0;
			int iEphCur = (int)(0);
			int iRowSet = (int)(0);
			int addrBypass = (int)(0);
			int addrLoop = (int)(0);
			int addrEphOpen = (int)(0);
			int bComplex = 0;
			int isView = 0;
			Trigger pTrigger;
			CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(AuthContext)));
			db = pParse.db;

			if ((pParse.nErr) != 0)
			{
				goto delete_from_cleanup;
			}



			pTab = sqlite3SrcListLookup(pParse, pTabList);
			if ((pTab) == (null))
				goto delete_from_cleanup;
			pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(128), null, null);
			isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);
			bComplex = (int)(((pTrigger) != null) || ((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) ? 1 : 0);
			if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
			{
				goto delete_from_cleanup;
			}

			if ((sqlite3IsReadOnly(pParse, pTab, (int)(pTrigger ? 1 : 0))) != 0)
			{
				goto delete_from_cleanup;
			}

			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));

			rcauth = (int)(sqlite3AuthCheck(pParse, (int)(9), pTab.zName, null, db.aDb[iDb].zDbSName));

			if ((rcauth) == (1))
			{
				goto delete_from_cleanup;
			}



			iTabCur = (int)(pTabList.a[0].iCursor = (int)(pParse.nTab++));
			for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
			{
				pParse.nTab++;
			}

			if ((isView) != 0)
			{
				sqlite3AuthContextPush(pParse, sContext, pTab.zName);
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
			{
				goto delete_from_cleanup;
			}

			if ((pParse.nested) == (0))
				sqlite3VdbeCountChanges(v);
			sqlite3BeginWriteOperation(pParse, (int)(bComplex), (int)(iDb));
			if ((isView) != 0)
			{
				sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, (int)(iTabCur));
				iDataCur = (int)(iIdxCur = (int)(iTabCur));
				pOrderBy = null;
				pLimit = null;
			}

			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = pParse;
			sNC.pSrcList = pTabList;
			if ((sqlite3ResolveExprNames(sNC, pWhere)) != 0)
			{
				goto delete_from_cleanup;
			}

			if (((((db.flags & ((ulong)(0x00001) << 32)) != 0) && (pParse.nested == 0)) && (pParse.pTriggerTab == null)) && (pParse.bReturning == 0))
			{
				memCnt = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(memCnt));
			}

			if (((((rcauth) == (0)) && ((pWhere) == (null))) && (bComplex == 0)) && (!(((pTab).eTabType) == (1))))
			{

				sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(1), pTab.zName);
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					sqlite3VdbeAddOp4(v, (int)(144), (int)(pTab.tnum), (int)(iDb), (int)((memCnt) != 0 ? memCnt : -1), pTab.zName, (int)(-1));
				}

				for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
				{

					sqlite3VdbeAddOp2(v, (int)(144), (int)(pIdx.tnum), (int)(iDb));
					if ((((pIdx).idxType) == (2)) && (!(((pTab).tabFlags & 0x00000080) == (0))))
					{
						sqlite3VdbeChangeP3(v, (int)(-1), (int)((memCnt) != 0 ? memCnt : -1));
					}
				}
			}
			else
			{
				ushort wcf = (ushort)(0x0004 | 0x0010);
				if ((sNC.ncFlags & 0x000040) != 0)
					bComplex = (int)(1);
				wcf |= (ushort)((bComplex) != 0 ? 0 : 0x0008);
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					pPk = null;
					nPk = (short)(1);
					iRowSet = (int)(++pParse.nMem);
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(iRowSet));
				}
				else
				{
					pPk = sqlite3PrimaryKeyIndex(pTab);

					nPk = (short)(pPk.nKeyCol);
					iPk = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(nPk);
					iEphCur = (int)(pParse.nTab++);
					addrEphOpen = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iEphCur), (int)(nPk)));
					sqlite3VdbeSetP4KeyInfo(pParse, pPk);
				}

				pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, null, null, null, (ushort)(wcf), (int)(iTabCur + 1));
				if ((pWInfo) == (null))
					goto delete_from_cleanup;
				eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aiCurOnePass));


				if (eOnePass != 1)
					sqlite3MultiWrite(pParse);
				if ((sqlite3WhereUsesDeferredSeek(pWInfo)) != 0)
				{
					sqlite3VdbeAddOp1(v, (int)(142), (int)(iTabCur));
				}

				if ((memCnt) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(85), (int)(memCnt), (int)(1));
				}

				if ((pPk) != null)
				{
					for (i = (int)(0); (i) < (nPk); i++)
					{

						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iTabCur), (int)(pPk.aiColumn[i]), (int)(iPk + i));
					}

					iKey = (int)(iPk);
				}
				else
				{
					iKey = (int)(++pParse.nMem);
					sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iTabCur), (int)(-1), (int)(iKey));
				}

				if (eOnePass != 0)
				{
					nKey = (short)(nPk);
					aToOpen = sqlite3DbMallocRawNN(db, (ulong)(nIdx + 2));
					if ((aToOpen) == (null))
					{
						sqlite3WhereEnd(pWInfo);
						goto delete_from_cleanup;
					}

					CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
					aToOpen[nIdx + 1] = (byte)(0);
					if ((aiCurOnePass[0]) >= (0))
						aToOpen[aiCurOnePass[0] - iTabCur] = (byte)(0);
					if ((aiCurOnePass[1]) >= (0))
						aToOpen[aiCurOnePass[1] - iTabCur] = (byte)(0);
					if ((addrEphOpen) != 0)
						sqlite3VdbeChangeToNoop(v, (int)(addrEphOpen));
					addrBypass = (int)(sqlite3VdbeMakeLabel(pParse));
				}
				else
				{
					if ((pPk) != null)
					{
						iKey = (int)(++pParse.nMem);
						nKey = (short)(0);
						sqlite3VdbeAddOp4(v, (int)(96), (int)(iPk), (int)(nPk), (int)(iKey), sqlite3IndexAffinityStr(pParse.db, pPk), (int)(nPk));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iEphCur), (int)(iKey), (int)(iPk), (int)(nPk));
					}
					else
					{
						nKey = (short)(1);
						sqlite3VdbeAddOp2(v, (int)(155), (int)(iRowSet), (int)(iKey));
					}

					sqlite3WhereEnd(pWInfo);
				}

				if (isView == 0)
				{
					int iAddrOnce = (int)(0);
					if ((eOnePass) == (2))
					{
						iAddrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
					}

					sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0x08), (int)(iTabCur), aToOpen, &iDataCur, &iIdxCur);


					if ((eOnePass) == (2))
					{
						sqlite3VdbeJumpHereOrPopInst(v, (int)(iAddrOnce));
					}
				}

				if (eOnePass != 0)
				{

					if ((!(((pTab).eTabType) == (1))) && ((aToOpen[iDataCur - iTabCur]) != 0))
					{

						sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(addrBypass), (int)(iKey), (int)(nKey));
					}
				}
				else if ((pPk) != null)
				{
					addrLoop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iEphCur)));
					if ((((pTab).eTabType) == (1)))
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iEphCur), (int)(0), (int)(iKey));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(133), (int)(iEphCur), (int)(iKey));
					}


				}
				else
				{
					addrLoop = (int)(sqlite3VdbeAddOp3(v, (int)(45), (int)(iRowSet), (int)(0), (int)(iKey)));

				}

				if ((((pTab).eTabType) == (1)))
				{
					sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
					sqlite3VtabMakeWritable(pParse, pTab);

					sqlite3MayAbort(pParse);
					if ((eOnePass) == (1))
					{
						sqlite3VdbeAddOp1(v, (int)(121), (int)(iTabCur));
						if ((((pParse).pToplevel) == (null)))
						{
							pParse.isMultiWrite = (byte)(0);
						}
					}

					sqlite3VdbeAddOp4(v, (int)(10), (int)(0), (int)(1), (int)(iKey), pVTab, (int)(-12));
					sqlite3VdbeChangeP5(v, (ushort)(2));
				}
				else
				{
					int count = (int)(((pParse.nested) == (0)) ? 1 : 0);
					sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(iKey), (short)(nKey), (byte)(count), (byte)(11), (byte)(eOnePass), (int)(aiCurOnePass[1]));
				}

				if (eOnePass != 0)
				{
					sqlite3VdbeResolveLabel(v, (int)(addrBypass));
					sqlite3WhereEnd(pWInfo);
				}
				else if ((pPk) != null)
				{
					sqlite3VdbeAddOp2(v, (int)(5), (int)(iEphCur), (int)(addrLoop + 1));
					sqlite3VdbeJumpHere(v, (int)(addrLoop));
				}
				else
				{
					sqlite3VdbeGoto(v, (int)(addrLoop));
					sqlite3VdbeJumpHere(v, (int)(addrLoop));
				}
			}

			if (((pParse.nested) == (0)) && ((pParse.pTriggerTab) == (null)))
			{
				sqlite3AutoincrementEnd(pParse);
			}

			if ((memCnt) != 0)
			{
				sqlite3CodeChangeCount(v, (int)(memCnt), "rows deleted");
			}

		delete_from_cleanup:
			; sqlite3AuthContextPop(sContext);
			sqlite3SrcListDelete(db, pTabList);
			sqlite3ExprDelete(db, pWhere);
			sqlite3DbFree(db, aToOpen);
			return;
		}
		public static void sqlite3DeleteIndexSamples(sqlite3 db, Index pIdx)
		{
			(void)(db);
			(void)(pIdx);
		}
		public static void sqlite3DeleteReturning(sqlite3 db, Returning pRet)
		{
			Hash* pHash;
			pHash = &(db.aDb[1].pSchema.trigHash);
			sqlite3HashInsert(pHash, "sqlite_returning", null);
			sqlite3ExprListDelete(db, pRet.pReturnEL);
			sqlite3DbFree(db, pRet);
		}
		public static void sqlite3DeleteTable(sqlite3 db, Table pTable)
		{
			if (pTable == null)
				return;
			if ((((db == null) || ((db.pnBytesFreed) == (null))) && ((--pTable.nTabRef) > (0))))
				return;
			deleteTable(db, pTable);
		}
		public static void sqlite3DeleteTrigger(sqlite3 db, Trigger pTrigger)
		{
			if (((pTrigger) == (null)) || ((pTrigger.bReturning) != 0))
				return;
			sqlite3DeleteTriggerStep(db, pTrigger.step_list);
			sqlite3DbFree(db, pTrigger.zName);
			sqlite3DbFree(db, pTrigger.table);
			sqlite3ExprDelete(db, pTrigger.pWhen);
			sqlite3IdListDelete(db, pTrigger.pColumns);
			sqlite3DbFree(db, pTrigger);
		}
		public static void sqlite3DeleteTriggerStep(sqlite3 db, TriggerStep pTriggerStep)
		{
			while ((pTriggerStep) != null)
			{
				TriggerStep pTmp = pTriggerStep;
				pTriggerStep = pTriggerStep.pNext;
				sqlite3ExprDelete(db, pTmp.pWhere);
				sqlite3ExprListDelete(db, pTmp.pExprList);
				sqlite3SelectDelete(db, pTmp.pSelect);
				sqlite3IdListDelete(db, pTmp.pIdList);
				sqlite3UpsertDelete(db, pTmp.pUpsert);
				sqlite3SrcListDelete(db, pTmp.pFrom);
				sqlite3DbFree(db, pTmp.zSpan);
				sqlite3DbFree(db, pTmp);
			}
		}
		public static void sqlite3Dequote(sbyte* z)
		{
			sbyte quote = 0;
			int i = 0; int j = 0;
			if ((z) == (null))
				return;
			quote = (sbyte)(z[0]);
			if ((sqlite3CtypeMap[(byte)(quote)] & 0x80) == 0)
				return;
			if ((quote) == (91))
				quote = (sbyte)(93);
			for (i = (int)(1), j = (int)(0); ; i++)
			{

				if ((z[i]) == (quote))
				{
					if ((z[i + 1]) == (quote))
					{
						z[j++] = (sbyte)(quote);
						i++;
					}
					else
					{
						break;
					}
				}
				else
				{
					z[j++] = (sbyte)(z[i]);
				}
			}

			z[j] = (sbyte)(0);
		}
		public static void sqlite3DequoteExpr(Expr p)
		{


			p.flags |= (uint)((p.u.zToken[0]) == (34) ? 0x4000000 | 0x000040 : 0x4000000);
			sqlite3Dequote(p.u.zToken);
		}
		public static void sqlite3DequoteToken(Token* p)
		{
			uint i = 0;
			if ((p->n) < (2))
				return;
			if ((sqlite3CtypeMap[(byte)(p->z[0])] & 0x80) == 0)
				return;
			for (i = (uint)(1); (i) < (p->n - 1); i++)
			{
				if ((sqlite3CtypeMap[(byte)(p->z[i])] & 0x80) != 0)
					return;
			}

			p->n -= (uint)(2);
			p->z++;
		}
		public static void sqlite3Detach(Parse pParse, Expr pDbname)
		{
			codeAttach(pParse, (int)(25), sqlite3Detach_detach_func, pDbname, null, null, pDbname);
		}
		public static void sqlite3DropIndex(Parse pParse, SrcList pName, int ifExists)
		{
			Index pIndex;
			Vdbe v;
			sqlite3 db = pParse.db;
			int iDb = 0;
			if ((db.mallocFailed) != 0)
			{
				goto exit_drop_index;
			}



			if (0 != sqlite3ReadSchema(pParse))
			{
				goto exit_drop_index;
			}

			pIndex = sqlite3FindIndex(db, pName.a[0].zName, pName.a[0].zDatabase);
			if ((pIndex) == (null))
			{
				if (ifExists == 0)
				{
					sqlite3ErrorMsg(pParse, "no such index: %S", pName.a);
				}
				else
				{
					sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
					sqlite3ForceNotReadOnly(pParse);
				}

				pParse.checkSchema = (byte)(1);
				goto exit_drop_index;
			}

			if (pIndex.idxType != 0)
			{
				sqlite3ErrorMsg(pParse, "index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped", (int)(0));
				goto exit_drop_index;
			}

			iDb = (int)(sqlite3SchemaToIndex(db, pIndex.pSchema));
			{
				int code = (int)(10);
				Table pTab = pIndex.pTable;
				sbyte* zDb = db.aDb[iDb].zDbSName;
				sbyte* zTab = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
				if ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0)
				{
					goto exit_drop_index;
				}

				if ((0 == 0) && ((iDb) == (1)))
					code = (int)(12);
				if ((sqlite3AuthCheck(pParse, (int)(code), pIndex.zName, pTab.zName, zDb)) != 0)
				{
					goto exit_drop_index;
				}
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) != null)
			{
				sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
				sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='index'", db.aDb[iDb].zDbSName, pIndex.zName);
				sqlite3ClearStatTables(pParse, (int)(iDb), "idx", pIndex.zName);
				sqlite3ChangeCookie(pParse, (int)(iDb));
				destroyRootPage(pParse, (int)(pIndex.tnum), (int)(iDb));
				sqlite3VdbeAddOp4(v, (int)(151), (int)(iDb), (int)(0), (int)(0), pIndex.zName, (int)(0));
			}

		exit_drop_index:
			; sqlite3SrcListDelete(db, pName);
		}
		public static void sqlite3DropTable(Parse pParse, SrcList pName, int isView, int noErr)
		{
			Table pTab;
			Vdbe v;
			sqlite3 db = pParse.db;
			int iDb = 0;
			if ((db.mallocFailed) != 0)
			{
				goto exit_drop_table;
			}



			if ((sqlite3ReadSchema(pParse)) != 0)
				goto exit_drop_table;
			if ((noErr) != 0)
				db.suppressErr++;

			pTab = sqlite3LocateTableItem(pParse, (uint)(isView), pName.a[0]);
			if ((noErr) != 0)
				db.suppressErr--;
			if ((pTab) == (null))
			{
				if ((noErr) != 0)
				{
					sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
					sqlite3ForceNotReadOnly(pParse);
				}

				goto exit_drop_table;
			}

			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));

			if ((((pTab).eTabType) == (1)) && ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0))
			{
				goto exit_drop_table;
			}

			{
				int code = 0;
				sbyte* zTab = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
				sbyte* zDb = db.aDb[iDb].zDbSName;
				sbyte* zArg2 = null;
				if ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0)
				{
					goto exit_drop_table;
				}

				if ((isView) != 0)
				{
					if ((0 == 0) && ((iDb) == (1)))
					{
						code = (int)(15);
					}
					else
					{
						code = (int)(17);
					}
				}
				else if ((((pTab).eTabType) == (1)))
				{
					code = (int)(30);
					zArg2 = sqlite3GetVTable(db, pTab).pMod.zName;
				}
				else
				{
					if ((0 == 0) && ((iDb) == (1)))
					{
						code = (int)(13);
					}
					else
					{
						code = (int)(11);
					}
				}

				if ((sqlite3AuthCheck(pParse, (int)(code), pTab.zName, zArg2, zDb)) != 0)
				{
					goto exit_drop_table;
				}

				if ((sqlite3AuthCheck(pParse, (int)(9), pTab.zName, null, zDb)) != 0)
				{
					goto exit_drop_table;
				}
			}

			if ((tableMayNotBeDropped(db, pTab)) != 0)
			{
				sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab.zName);
				goto exit_drop_table;
			}

			if (((isView) != 0) && (!(((pTab).eTabType) == (2))))
			{
				sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab.zName);
				goto exit_drop_table;
			}

			if ((isView == 0) && (((pTab).eTabType) == (2)))
			{
				sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab.zName);
				goto exit_drop_table;
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) != null)
			{
				sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
				if (isView == 0)
				{
					sqlite3ClearStatTables(pParse, (int)(iDb), "tbl", pTab.zName);
					sqlite3FkDropTable(pParse, pName, pTab);
				}

				sqlite3CodeDropTable(pParse, pTab, (int)(iDb), (int)(isView));
			}

		exit_drop_table:
			; sqlite3SrcListDelete(db, pName);
		}
		public static void sqlite3DropTrigger(Parse pParse, SrcList pName, int noErr)
		{
			Trigger pTrigger = null;
			int i = 0;
			sbyte* zDb;
			sbyte* zName;
			sqlite3 db = pParse.db;
			if ((db.mallocFailed) != 0)
				goto drop_trigger_cleanup;
			if (0 != sqlite3ReadSchema(pParse))
			{
				goto drop_trigger_cleanup;
			}


			zDb = pName.a[0].zDatabase;
			zName = pName.a[0].zName;

			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				int j = (int)(((i) < (2)) ? i ^ 1 : i);
				if (((zDb) != null) && ((sqlite3DbIsNamed(db, (int)(j), zDb)) == (0)))
					continue;

				pTrigger = sqlite3HashFind(&(db.aDb[j].pSchema.trigHash), zName);
				if ((pTrigger) != null)
					break;
			}

			if (pTrigger == null)
			{
				if (noErr == 0)
				{
					sqlite3ErrorMsg(pParse, "no such trigger: %S", pName.a);
				}
				else
				{
					sqlite3CodeVerifyNamedSchema(pParse, zDb);
				}

				pParse.checkSchema = (byte)(1);
				goto drop_trigger_cleanup;
			}

			sqlite3DropTriggerPtr(pParse, pTrigger);
		drop_trigger_cleanup:
			; sqlite3SrcListDelete(db, pName);
		}
		public static void sqlite3DropTriggerPtr(Parse pParse, Trigger pTrigger)
		{
			Table pTable;
			Vdbe v;
			sqlite3 db = pParse.db;
			int iDb = 0;
			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTrigger.pSchema));

			pTable = tableOfTrigger(pTrigger);

			if ((pTable) != null)
			{
				int code = (int)(16);
				sbyte* zDb = db.aDb[iDb].zDbSName;
				sbyte* zTab = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
				if ((iDb) == (1))
					code = (int)(14);
				if (((sqlite3AuthCheck(pParse, (int)(code), pTrigger.zName, pTable.zName, zDb)) != 0) || ((sqlite3AuthCheck(pParse, (int)(9), zTab, null, zDb)) != 0))
				{
					return;
				}
			}

			if ((v = sqlite3GetVdbe(pParse)) != null)
			{
				sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='trigger'", db.aDb[iDb].zDbSName, pTrigger.zName);
				sqlite3ChangeCookie(pParse, (int)(iDb));
				sqlite3VdbeAddOp4(v, (int)(152), (int)(iDb), (int)(0), (int)(0), pTrigger.zName, (int)(0));
			}
		}
		public static void sqlite3EndBenignMalloc()
		{
			if ((sqlite3Hooks.xBenignEnd) != null)
			{
				sqlite3Hooks.xBenignEnd();
			}
		}
		public static void sqlite3EndTable(Parse pParse, Token* pCons, Token* pEnd, uint tabOpts, Select pSelect)
		{
			Table p;
			sqlite3 db = pParse.db;
			int iDb = 0;
			Index pIdx;
			if (((pEnd) == (null)) && ((pSelect) == (null)))
			{
				return;
			}

			p = pParse.pNewTable;
			if ((p) == (null))
				return;
			if (((pSelect) == (null)) && ((sqlite3ShadowTableName(db, p.zName)) != 0))
			{
				p.tabFlags |= (uint)(0x00001000);
			}

			if ((db.init.busy) != 0)
			{
				if (((pSelect) != null) || ((!(((p).eTabType) == (0))) && ((db.init.newTnum) != 0)))
				{
					sqlite3ErrorMsg(pParse, "");
					return;
				}

				p.tnum = (uint)(db.init.newTnum);
				if ((p.tnum) == (1))
					p.tabFlags |= (uint)(0x00000001);
			}

			if ((tabOpts & 0x00010000) != 0)
			{
				int ii = 0;
				p.tabFlags |= (uint)(0x00010000);
				for (ii = (int)(0); (ii) < (p.nCol); ii++)
				{
					Column* pCol = &p.aCol[ii];
					if ((pCol->eCType) == (0))
					{
						if ((pCol->colFlags & 0x0004) != 0)
						{
							sqlite3ErrorMsg(pParse, "unknown datatype for %s.%s: \"%s\"", p.zName, pCol->zCnName, sqlite3ColumnType(pCol, ""));
						}
						else
						{
							sqlite3ErrorMsg(pParse, "missing datatype for %s.%s", p.zName, pCol->zCnName);
						}

						return;
					}
					else if ((pCol->eCType) == (1))
					{
						pCol->affinity = (sbyte)(0x41);
					}

					if ((((pCol->colFlags & 0x0001) != 0) && (p.iPKey != ii)) && ((pCol->notNull) == (0)))
					{
						pCol->notNull = (uint)(2);
						p.tabFlags |= (uint)(0x00000800);
					}
				}
			}



			if ((tabOpts & 0x00000080) != 0)
			{
				if ((p.tabFlags & 0x00000008) != 0)
				{
					sqlite3ErrorMsg(pParse, "AUTOINCREMENT not allowed on WITHOUT ROWID tables");
					return;
				}

				if ((p.tabFlags & 0x00000004) == (0))
				{
					sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p.zName);
					return;
				}

				p.tabFlags |= (uint)(0x00000080 | 0x00000200);
				convertToWithoutRowidTable(pParse, p);
			}

			iDb = (int)(sqlite3SchemaToIndex(db, p.pSchema));
			if ((p.pCheck) != null)
			{
				sqlite3ResolveSelfReference(pParse, p, (int)(0x000004), null, p.pCheck);
				if ((pParse.nErr) != 0)
				{
					sqlite3ExprListDelete(db, p.pCheck);
					p.pCheck = null;
				}
				else
				{
				}
			}

			if ((p.tabFlags & 0x00000060) != 0)
			{
				int ii = 0;
				int nNG = (int)(0);
				for (ii = (int)(0); (ii) < (p.nCol); ii++)
				{
					uint colFlags = (uint)(p.aCol[ii].colFlags);
					if ((colFlags & 0x0060) != 0)
					{
						Expr pX = sqlite3ColumnExpr(p, &p.aCol[ii]);
						if ((sqlite3ResolveSelfReference(pParse, p, (int)(0x000008), pX, null)) != 0)
						{
							sqlite3ColumnSetExpr(pParse, p, &p.aCol[ii], sqlite3ExprAlloc(db, (int)(121), null, (int)(0)));
						}
					}
					else
					{
						nNG++;
					}
				}

				if ((nNG) == (0))
				{
					sqlite3ErrorMsg(pParse, "must have at least one non-generated column");
					return;
				}
			}

			estimateTableWidth(p);
			for (pIdx = p.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				estimateIndexWidth(pIdx);
			}

			if (db.init.busy == 0)
			{
				int n = 0;
				Vdbe v;
				sbyte* zType;
				sbyte* zType2;
				sbyte* zStmt;
				v = sqlite3GetVdbe(pParse);
				if (((v) == (null)))
					return;
				sqlite3VdbeAddOp1(v, (int)(121), (int)(0));
				if ((((p).eTabType) == (0)))
				{
					zType = "table";
					zType2 = "TABLE";
				}
				else
				{
					zType = "view";
					zType2 = "VIEW";
				}

				if ((pSelect) != null)
				{
					SelectDest dest = new SelectDest();
					int regYield = 0;
					int addrTop = 0;
					int regRec = 0;
					int regRowid = 0;
					int addrInsLoop = 0;
					Table pSelTab;
					if ((pParse.eParseMode != 0))
					{
						pParse.rc = (int)(1);
						pParse.nErr++;
						return;
					}

					regYield = (int)(++pParse.nMem);
					regRec = (int)(++pParse.nMem);
					regRowid = (int)(++pParse.nMem);

					sqlite3MayAbort(pParse);
					sqlite3VdbeAddOp3(v, (int)(112), (int)(1), (int)(pParse.regRoot), (int)(iDb));
					sqlite3VdbeChangeP5(v, (ushort)(0x10));
					pParse.nTab = (int)(2);
					addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
					sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(addrTop));
					if ((pParse.nErr) != 0)
						return;
					pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, (sbyte)(0x41));
					if ((pSelTab) == (null))
						return;

					p.nCol = (short)(p.nNVCol = (short)(pSelTab.nCol));
					p.aCol = pSelTab.aCol;
					pSelTab.nCol = (short)(0);
					pSelTab.aCol = null;
					sqlite3DeleteTable(db, pSelTab);
					sqlite3SelectDestInit(dest, (int)(13), (int)(regYield));
					sqlite3Select(pParse, pSelect, dest);
					if ((pParse.nErr) != 0)
						return;
					sqlite3VdbeEndCoroutine(v, (int)(regYield));
					sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
					addrInsLoop = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm)));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(dest.iSdst), (int)(dest.nSdst), (int)(regRec));
					sqlite3TableAffinity(v, p, (int)(0));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(1), (int)(regRowid));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(1), (int)(regRec), (int)(regRowid));
					sqlite3VdbeGoto(v, (int)(addrInsLoop));
					sqlite3VdbeJumpHere(v, (int)(addrInsLoop));
					sqlite3VdbeAddOp1(v, (int)(121), (int)(1));
				}

				if ((pSelect) != null)
				{
					zStmt = createTableStmt(db, p);
				}
				else
				{
					Token* pEnd2 = (tabOpts) != 0 ? &pParse.sLastToken : pEnd;
					n = ((int)(pEnd2->z - pParse.sNameToken.z));
					if (pEnd2->z[0] != 59)
						n += (int)(pEnd2->n);
					zStmt = sqlite3MPrintf(db, "CREATE %s %.*s", zType2, (int)(n), pParse.sNameToken.z);
				}

				sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q WHERE rowid=#%d", db.aDb[iDb].zDbSName, zType, p.zName, p.zName, (int)(pParse.regRoot), zStmt, (int)(pParse.regRowid));
				sqlite3DbFree(db, zStmt);
				sqlite3ChangeCookie(pParse, (int)(iDb));
				if (((p.tabFlags & 0x00000008) != 0) && (!(pParse.eParseMode != 0)))
				{
					Db pDb = db.aDb[iDb];

					if ((pDb.pSchema.pSeqTab) == (null))
					{
						sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", pDb.zDbSName);
					}
				}

				sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p.zName), (ushort)(0));
			}

			if ((db.init.busy) != 0)
			{
				Table pOld;
				Schema pSchema = p.pSchema;


				pOld = sqlite3HashInsert(&pSchema.tblHash, p.zName, p);
				if ((pOld) != null)
				{

					sqlite3OomFault(db);
					return;
				}

				pParse.pNewTable = null;
				db.mDbFlags |= (uint)(0x0001);

				if ((CRuntime.strcmp(p.zName, "sqlite_sequence")) == (0))
				{

					p.pSchema.pSeqTab = p;
				}
			}

			if ((pSelect == null) && (((p).eTabType) == (0)))
			{

				if ((pCons->z) == (null))
				{
					pCons = pEnd;
				}

				p.u.tab.addColOffset = (int)(13 + (int)(pCons->z - pParse.sNameToken.z));
			}
		}
		public static void sqlite3EndTransaction(Parse pParse, int eType)
		{
			Vdbe v;
			int isRollback = 0;



			isRollback = (int)((eType) == (12) ? 1 : 0);
			if ((sqlite3AuthCheck(pParse, (int)(22), (isRollback) != 0 ? "ROLLBACK" : "COMMIT", null, null)) != 0)
			{
				return;
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) != null)
			{
				sqlite3VdbeAddOp2(v, (int)(1), (int)(1), (int)(isRollback));
			}
		}
		public static void sqlite3Error(sqlite3 db, int err_code)
		{

			db.errCode = (int)(err_code);
			if (((err_code) != 0) || ((db.pErr) != null))
			{
				sqlite3ErrorFinish(db, (int)(err_code));
			}
			else
			{
				db.errByteOffset = (int)(-1);
			}
		}
		public static void sqlite3ErrorClear(sqlite3 db)
		{

			db.errCode = (int)(0);
			db.errByteOffset = (int)(-1);
			if ((db.pErr) != null)
				sqlite3ValueSetNull(db.pErr);
		}
		public static void sqlite3ErrorFinish(sqlite3 db, int err_code)
		{
			if ((db.pErr) != null)
				sqlite3ValueSetNull(db.pErr);
			sqlite3SystemError(db, (int)(err_code));
		}
		public static void sqlite3ErrorIfNotEmpty(Parse pParse, sbyte* zDb, sbyte* zTab, sbyte* zErr)
		{
			sqlite3NestedParse(pParse, "SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"", zErr, zDb, zTab);
		}
		public static void sqlite3ErrorMsg(Parse pParse, sbyte* zFormat)
		{
			sbyte* zMsg;
			sbyte* ap;
			sqlite3 db = pParse.db;


			db.errByteOffset = (int)(-2);
			(__va_start(&ap, zFormat));
			zMsg = sqlite3VMPrintf(db, zFormat, ap);
			((void)(ap = null));
			if ((db.errByteOffset) < (-1))
				db.errByteOffset = (int)(-1);
			if ((db.suppressErr) != 0)
			{
				sqlite3DbFree(db, zMsg);
				if ((db.mallocFailed) != 0)
				{
					pParse.nErr++;
					pParse.rc = (int)(7);
				}
			}
			else
			{
				pParse.nErr++;
				sqlite3DbFree(db, pParse.zErrMsg);
				pParse.zErrMsg = zMsg;
				pParse.rc = (int)(1);
				pParse.pWith = null;
			}
		}
		public static int sqlite3ErrorToParser(sqlite3 db, int errCode)
		{
			Parse pParse;
			if (((db) == (null)) || ((pParse = db.pParse) == (null)))
				return (int)(errCode);
			pParse.rc = (int)(errCode);
			pParse.nErr++;
			return (int)(errCode);
		}
		public static void sqlite3ErrorWithMsg(sqlite3 db, int err_code, sbyte* zFormat)
		{

			db.errCode = (int)(err_code);
			sqlite3SystemError(db, (int)(err_code));
			if ((zFormat) == (null))
			{
				sqlite3Error(db, (int)(err_code));
			}
			else if (((db.pErr) != null) || ((db.pErr = sqlite3ValueNew(db)) != null))
			{
				sbyte* z;
				sbyte* ap;
				(__va_start(&ap, zFormat));
				z = sqlite3VMPrintf(db, zFormat, ap);
				((void)(ap = null));
				sqlite3ValueSetStr(db.pErr, (int)(-1), z, (byte)(1), ((Void(Void * ))(sqlite3OomFault)));
			}
		}
		public static sbyte* sqlite3ErrStr(int rc)
		{
			sbyte* zErr = "unknown error";
			switch (rc)
			{
				case (4 | (2 << 8)):
					{
						zErr = "abort due to ROLLBACK";
						break;
					}

				case 100:
					{
						zErr = "another row available";
						break;
					}

				case 101:
					{
						zErr = "no more rows available";
						break;
					}

				default:
					{
						rc &= (int)(0xff);
						if ((((rc) >= (0)) && ((rc) < ((int)(29 * sizeof(sbyte) / sizeof(sbyte*))))) && (sqlite3ErrStr_aMsg[rc] != null))
						{
							zErr = sqlite3ErrStr_aMsg[rc];
						}

						break;
					}
			}

			return zErr;
		}
		public static ExprList sqlite3ExpandReturning(Parse pParse, ExprList pList, Table pTab)
		{
			ExprList pNew = null;
			sqlite3 db = pParse.db;
			int i = 0;
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				Expr pOldExpr = pList.a[i].pExpr;
				if (((pOldExpr) == (null)))
					continue;
				if ((isAsteriskTerm(pParse, pOldExpr)) != 0)
				{
					int jj = 0;
					for (jj = (int)(0); (jj) < (pTab.nCol); jj++)
					{
						Expr pNewExpr;
						if ((((pTab.aCol + jj)->colFlags & 0x0002) != 0))
							continue;
						pNewExpr = sqlite3Expr(db, (int)(59), pTab.aCol[jj].zCnName);
						pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
						if (db.mallocFailed == 0)
						{
							ExprList_item* pItem = &pNew.a[pNew.nExpr - 1];
							pItem->zEName = sqlite3DbStrDup(db, pTab.aCol[jj].zCnName);
							pItem->eEName = (uint)(0);
						}
					}
				}
				else
				{
					Expr pNewExpr = sqlite3ExprDup(db, pOldExpr, (int)(0));
					pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
					if ((db.mallocFailed == 0) && (pList.a[i].zEName != null))
					{
						ExprList_item* pItem = &pNew.a[pNew.nExpr - 1];
						pItem->zEName = sqlite3DbStrDup(db, pList.a[i].zEName);
						pItem->eEName = (uint)(pList.a[i].eEName);
					}
				}
			}

			return pNew;
		}
		public static int sqlite3ExpandSubquery(Parse pParse, SrcItem pFrom)
		{
			Select pSel = pFrom.pSelect;
			Table pTab;

			pFrom.pTab = pTab = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(Table)));
			if ((pTab) == (null))
				return (int)(7);
			pTab.nTabRef = (uint)(1);
			if ((pFrom.zAlias) != null)
			{
				pTab.zName = sqlite3DbStrDup(pParse.db, pFrom.zAlias);
			}
			else
			{
				pTab.zName = sqlite3MPrintf(pParse.db, "subquery_%u", (uint)(pSel.selId));
			}

			while ((pSel.pPrior) != null)
			{
				pSel = pSel.pPrior;
			}

			sqlite3ColumnsFromExprList(pParse, pSel.pEList, &pTab.nCol, &pTab.aCol);
			pTab.iPKey = (short)(-1);
			pTab.nRowLogEst = (short)(200);

			pTab.tabFlags |= (uint)(0x00004000 | 0x00000200);
			return (int)((pParse.nErr) != 0 ? 1 : 0);
		}
		public static void sqlite3ExpirePreparedStatements(sqlite3 db, int iCode)
		{
			Vdbe p;
			for (p = db.pVdbe; p; p = p.pNext)
			{
				p.expired = (uint)(iCode + 1);
			}
		}
		public static Expr sqlite3Expr(sqlite3 db, int op, sbyte* zToken)
		{
			Token x = new Token();
			x.z = zToken;
			x.n = (uint)(sqlite3Strlen30(zToken));
			return sqlite3ExprAlloc(db, (int)(op), &x, (int)(0));
		}
		public static Expr sqlite3ExprAddCollateString(Parse pParse, Expr pExpr, sbyte* zC)
		{
			Token s = new Token();

			sqlite3TokenInit(&s, zC);
			return sqlite3ExprAddCollateToken(pParse, pExpr, &s, (int)(0));
		}
		public static Expr sqlite3ExprAddCollateToken(Parse pParse, Expr pExpr, Token* pCollName, int dequote)
		{
			if ((pCollName->n) > (0))
			{
				Expr pNew = sqlite3ExprAlloc(pParse.db, (int)(113), pCollName, (int)(dequote));
				if ((pNew) != null)
				{
					pNew.pLeft = pExpr;
					pNew.flags |= (uint)(0x000100 | 0x001000);
					pExpr = pNew;
				}
			}

			return pExpr;
		}
		public static sbyte sqlite3ExprAffinity(Expr pExpr)
		{
			int op = 0;
			while ((((pExpr).flags & (0x001000 | 0x020000)) != 0))
			{

				pExpr = pExpr.pLeft;

			}

			op = (int)(pExpr.op);
			if ((op) == (176))
				op = (int)(pExpr.op2);
			if (((op) == (167)) || ((op) == (169)))
			{

				if ((pExpr.y.pTab) != null)
				{
					return (sbyte)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
				}
			}

			if ((op) == (138))
			{




				return (sbyte)(sqlite3ExprAffinity(pExpr.x.pSelect.pEList.a[0].pExpr));
			}

			if ((op) == (36))
			{

				return (sbyte)(sqlite3AffinityType(pExpr.u.zToken, null));
			}

			if ((op) == (178))
			{



				return (sbyte)(sqlite3ExprAffinity(pExpr.pLeft.x.pSelect.pEList.a[pExpr.iColumn].pExpr));
			}

			if ((op) == (177))
			{

				return (sbyte)(sqlite3ExprAffinity(pExpr.x.pList.a[0].pExpr));
			}

			return (sbyte)(pExpr.affExpr);
		}
		public static Expr sqlite3ExprAlloc(sqlite3 db, int op, Token* pToken, int dequote)
		{
			Expr pNew;
			int nExtra = (int)(0);
			int iValue = (int)(0);

			if ((pToken) != null)
			{
				if (((op != 155) || ((pToken->z) == (null))) || ((sqlite3GetInt32(pToken->z, &iValue)) == (0)))
				{
					nExtra = (int)(pToken->n + 1);

				}
			}

			pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Expr) + nExtra));
			if ((pNew) != null)
			{
				CRuntime.memset(pNew, (int)(0), (ulong)(sizeof(Expr)));
				pNew.op = ((byte)(op));
				pNew.iAgg = (short)(-1);
				if ((pToken) != null)
				{
					if ((nExtra) == (0))
					{
						pNew.flags |= (uint)(0x000400 | 0x800000 | ((iValue) != 0 ? 0x10000000 : 0x20000000));
						pNew.u.iValue = (int)(iValue);
					}
					else
					{
						pNew.u.zToken = (sbyte*)(pNew[1]);

						if ((pToken->n) != 0)
							CRuntime.memcpy(pNew.u.zToken, pToken->z, (ulong)(pToken->n));
						pNew.u.zToken[pToken->n] = (sbyte)(0);
						if (((dequote) != 0) && ((sqlite3CtypeMap[(byte)(pNew.u.zToken[0])] & 0x80) != 0))
						{
							sqlite3DequoteExpr(pNew);
						}
					}
				}

				pNew.nHeight = (int)(1);
			}

			return pNew;
		}
		public static void sqlite3ExprAnalyzeAggList(NameContext pNC, ExprList pList)
		{
			ExprList_item* pItem;
			int i = 0;
			if ((pList) != null)
			{
				for (pItem = pList.a, i = (int)(0); (i) < (pList.nExpr); i++, pItem++)
				{
					sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
				}
			}
		}
		public static void sqlite3ExprAnalyzeAggregates(NameContext pNC, Expr pExpr)
		{
			Walker w = new Walker();
			w.xExprCallback = analyzeAggregate;
			w.xSelectCallback = sqlite3WalkerDepthIncrease;
			w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
			w.walkerDepth = (int)(0);
			w.u.pNC = pNC;
			w.pParse = null;

			sqlite3WalkExpr(w, pExpr);
		}
		public static Expr sqlite3ExprAnd(Parse pParse, Expr pLeft, Expr pRight)
		{
			sqlite3 db = pParse.db;
			if ((pLeft) == (null))
			{
				return pRight;
			}
			else if ((pRight) == (null))
			{
				return pLeft;
			}
			else if (((((pLeft).flags & (0x000001 | 0x20000000)) == (0x20000000)) || (((pRight).flags & (0x000001 | 0x20000000)) == (0x20000000))) && (!((pParse.eParseMode) >= (2))))
			{
				sqlite3ExprDeferredDelete(pParse, pLeft);
				sqlite3ExprDeferredDelete(pParse, pRight);
				return sqlite3Expr(db, (int)(155), "0");
			}
			else
			{
				return sqlite3PExpr(pParse, (int)(44), pLeft, pRight);
			}
		}
		public static void sqlite3ExprAssignVarNumber(Parse pParse, Expr pExpr, uint n)
		{
			sqlite3 db = pParse.db;
			sbyte* z;
			short x = 0;
			if ((pExpr) == (null))
				return;

			z = pExpr.u.zToken;



			if ((z[1]) == (0))
			{

				x = (short)(++pParse.nVar);
			}
			else
			{
				int doAdd = (int)(0);
				if ((z[0]) == (63))
				{
					long i = 0;
					int bOk = 0;
					if ((n) == (2))
					{
						i = (long)(z[1] - 48);
						bOk = (int)(1);
					}
					else
					{
						bOk = (int)((0) == (sqlite3Atoi64(&z[1], &i, (int)(n - 1), (byte)(1))) ? 1 : 0);
					}

					if ((((bOk) == (0)) || ((i) < (1))) || ((i) > (db.aLimit[9])))
					{
						sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", (int)(db.aLimit[9]));
						sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
						return;
					}

					x = ((short)(i));
					if ((x) > (pParse.nVar))
					{
						pParse.nVar = (short)((int)(x));
						doAdd = (int)(1);
					}
					else if ((sqlite3VListNumToName(pParse.pVList, (int)(x))) == (null))
					{
						doAdd = (int)(1);
					}
				}
				else
				{
					x = ((short)(sqlite3VListNameToNum(pParse.pVList, z, (int)(n))));
					if ((x) == (0))
					{
						x = (short)(++pParse.nVar);
						doAdd = (int)(1);
					}
				}

				if ((doAdd) != 0)
				{
					pParse.pVList = sqlite3VListAdd(db, pParse.pVList, z, (int)(n), (int)(x));
				}
			}

			pExpr.iColumn = (short)(x);
			if ((x) > (db.aLimit[9]))
			{
				sqlite3ErrorMsg(pParse, "too many SQL variables");
				sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr);
			}
		}
		public static void sqlite3ExprAttachSubtrees(sqlite3 db, Expr pRoot, Expr pLeft, Expr pRight)
		{
			if ((pRoot) == (null))
			{

				sqlite3ExprDelete(db, pLeft);
				sqlite3ExprDelete(db, pRight);
			}
			else
			{
				if ((pRight) != null)
				{
					pRoot.pRight = pRight;
					pRoot.flags |= (uint)((0x000100 | 0x200000 | 0x000004) & pRight.flags);
				}

				if ((pLeft) != null)
				{
					pRoot.pLeft = pLeft;
					pRoot.flags |= (uint)((0x000100 | 0x200000 | 0x000004) & pLeft.flags);
				}

				exprSetHeight(pRoot);
			}
		}
		public static int sqlite3ExprCanBeNull(Expr p)
		{
			byte op = 0;

			while (((p.op) == (174)) || ((p.op) == (173)))
			{
				p = p.pLeft;

			}

			op = (byte)(p.op);
			if ((op) == (176))
				op = (byte)(p.op2);
			switch (op)
			{
				case 155:
				case 117:
				case 153:
				case 154:
					return (int)(0);
				case 167:

					return (((((p).flags & (0x100000)) != 0) || ((p.y.pTab) == (null))) || ((((p.iColumn) >= (0)) && (p.y.pTab.aCol != null)) && ((p.y.pTab.aCol[p.iColumn].notNull) == (0))) ? 1 : 0);
				default:
					return (int)(1);
			}
		}
		public static int sqlite3ExprCheckHeight(Parse pParse, int nHeight)
		{
			int rc = (int)(0);
			int mxHeight = (int)(pParse.db.aLimit[3]);
			if ((nHeight) > (mxHeight))
			{
				sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", (int)(mxHeight));
				rc = (int)(1);
			}

			return (int)(rc);
		}
		public static int sqlite3ExprCheckIN(Parse pParse, Expr pIn)
		{
			int nVector = (int)(sqlite3ExprVectorSize(pIn.pLeft));
			if ((((pIn).flags & 0x000800) != 0) && (pParse.db.mallocFailed == 0))
			{
				if (nVector != pIn.x.pSelect.pEList.nExpr)
				{
					sqlite3SubselectError(pParse, (int)(pIn.x.pSelect.pEList.nExpr), (int)(nVector));
					return (int)(1);
				}
			}
			else if (nVector != 1)
			{
				sqlite3VectorErrorMsg(pParse, pIn.pLeft);
				return (int)(1);
			}

			return (int)(0);
		}
		public static void sqlite3ExprCode(Parse pParse, Expr pExpr, int target)
		{
			int inReg = 0;



			if ((pParse.pVdbe) == (null))
				return;
			inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(target)));
			if (inReg != target)
			{
				byte op = 0;
				if (((pExpr) != null) && (((pExpr).flags & (0x200000)) != 0))
				{
					op = (byte)(79);
				}
				else
				{
					op = (byte)(80);
				}

				sqlite3VdbeAddOp2(pParse.pVdbe, (int)(op), (int)(inReg), (int)(target));
			}
		}
		public static void sqlite3ExprCodeCopy(Parse pParse, Expr pExpr, int target)
		{
			sqlite3 db = pParse.db;
			pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
			if (db.mallocFailed == 0)
				sqlite3ExprCode(pParse, pExpr, (int)(target));
			sqlite3ExprDelete(db, pExpr);
		}
		public static int sqlite3ExprCodeExprList(Parse pParse, ExprList pList, int target, int srcReg, byte flags)
		{
			ExprList_item* pItem;
			int i = 0; int j = 0; int n = 0;
			byte copyOp = (byte)((flags & 0x01) ? 79 : 80);
			Vdbe v = pParse.pVdbe;



			n = (int)(pList.nExpr);
			if (((pParse).okConstFactor) == 0)
				flags &= (byte)(~0x02);
			for (pItem = pList.a, i = (int)(0); (i) < (n); i++, pItem++)
			{
				Expr pExpr = pItem->pExpr;
				if (((flags & 0x04) != 0) && ((j = (int)(pItem->u.x.iOrderByCol)) > (0)))
				{
					if ((flags & 0x08) != 0)
					{
						i--;
						n--;
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(copyOp), (int)(j + srcReg - 1), (int)(target + i));
					}
				}
				else if (((flags & 0x02) != 0) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
				{
					sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(target + i));
				}
				else
				{
					int inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(target + i)));
					if (inReg != target + i)
					{
						VdbeOp* pOp;
						if ((((((copyOp) == (79)) && (((pOp = sqlite3VdbeGetOp(v, (int)(-1)))->opcode) == (79))) && ((pOp->p1 + pOp->p3 + 1) == (inReg))) && ((pOp->p2 + pOp->p3 + 1) == (target + i))) && ((pOp->p5) == (0)))
						{
							pOp->p3++;
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(copyOp), (int)(inReg), (int)(target + i));
						}
					}
				}
			}

			return (int)(n);
		}
		public static void sqlite3ExprCodeFactorable(Parse pParse, Expr pExpr, int target)
		{
			if (((pParse.okConstFactor) != 0) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
			{
				sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(target));
			}
			else
			{
				sqlite3ExprCodeCopy(pParse, pExpr, (int)(target));
			}
		}
		public static void sqlite3ExprCodeGeneratedColumn(Parse pParse, Table pTab, Column* pCol, int regOut)
		{
			int iAddr = 0;
			Vdbe v = pParse.pVdbe;


			if ((pParse.iSelfTab) > (0))
			{
				iAddr = (int)(sqlite3VdbeAddOp3(v, (int)(22), (int)(pParse.iSelfTab - 1), (int)(0), (int)(regOut)));
			}
			else
			{
				iAddr = (int)(0);
			}

			sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), (int)(regOut));
			if ((pCol->affinity) >= (0x42))
			{
				sqlite3VdbeAddOp4(v, (int)(95), (int)(regOut), (int)(1), (int)(0), &pCol->affinity, (int)(1));
			}

			if ((iAddr) != 0)
				sqlite3VdbeJumpHere(v, (int)(iAddr));
		}
		public static int sqlite3ExprCodeGetColumn(Parse pParse, Table pTab, int iColumn, int iTable, int iReg, byte p5)
		{

			sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pTab, (int)(iTable), (int)(iColumn), (int)(iReg));
			if ((p5) != 0)
			{
				VdbeOp* pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(-1));
				if ((pOp->opcode) == (93))
					pOp->p5 = (ushort)(p5);
			}

			return (int)(iReg);
		}
		public static void sqlite3ExprCodeGetColumnOfTable(Vdbe v, Table pTab, int iTabCur, int iCol, int regOut)
		{
			Column* pCol;

			if ((pTab) == (null))
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(iTabCur), (int)(iCol), (int)(regOut));
				return;
			}

			if (((iCol) < (0)) || ((iCol) == (pTab.iPKey)))
			{
				sqlite3VdbeAddOp2(v, (int)(134), (int)(iTabCur), (int)(regOut));
			}
			else
			{
				int op = 0;
				int x = 0;
				if ((((pTab).eTabType) == (1)))
				{
					op = (int)(174);
					x = (int)(iCol);
				}
				else if (((pCol = &pTab.aCol[iCol])->colFlags & 0x0020) != 0)
				{
					Parse pParse = sqlite3VdbeParser(v);
					if ((pCol->colFlags & 0x0100) != 0)
					{
						sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol->zCnName);
					}
					else
					{
						int savedSelfTab = (int)(pParse.iSelfTab);
						pCol->colFlags |= (ushort)(0x0100);
						pParse.iSelfTab = (int)(iTabCur + 1);
						sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(regOut));
						pParse.iSelfTab = (int)(savedSelfTab);
						pCol->colFlags &= (ushort)(~0x0100);
					}

					return;
				}
				else if (!(((pTab).tabFlags & 0x00000080) == (0)))
				{
					x = (int)(sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), (short)(iCol)));
					op = (int)(93);
				}
				else
				{
					x = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)));
					op = (int)(93);
				}

				sqlite3VdbeAddOp3(v, (int)(op), (int)(iTabCur), (int)(x), (int)(regOut));
				sqlite3ColumnDefault(v, pTab, (int)(iCol), (int)(regOut));
			}
		}
		public static void sqlite3ExprCodeIN(Parse pParse, Expr pExpr, int destIfFalse, int destIfNull)
		{
			int rRhsHasNull = (int)(0);
			int eType = 0;
			int rLhs = 0;
			int rLhsOrig = 0;
			Vdbe v;
			int* aiMap = null;
			sbyte* zAff = null;
			int nVector = 0;
			int iDummy = 0;
			Expr pLeft;
			int i = 0;
			int destStep2 = 0;
			int destStep6 = (int)(0);
			int addrTruthOp = 0;
			int destNotNull = 0;
			int addrTop = 0;
			int iTab = (int)(0);
			byte okConstFactor = (byte)(pParse.okConstFactor);

			pLeft = pExpr.pLeft;
			if ((sqlite3ExprCheckIN(pParse, pExpr)) != 0)
				return;
			zAff = exprINAffinity(pParse, pExpr);
			nVector = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
			aiMap = (int*)(sqlite3DbMallocZero(pParse.db, (ulong)(nVector * (sizeof(int) + sizeof(char)) + 1)));
			if ((pParse.db.mallocFailed) != 0)
				goto sqlite3ExprCodeIN_oom_error;
			v = pParse.pVdbe;

			eType = (int)(sqlite3FindInIndex(pParse, pExpr, (uint)(0x0002 | 0x0001), (destIfFalse) == (destIfNull) ? null : &rRhsHasNull, aiMap, &iTab));


			pParse.okConstFactor = (byte)(0);
			rLhsOrig = (int)(exprCodeVector(pParse, pLeft, &iDummy));
			pParse.okConstFactor = (byte)(okConstFactor);
			for (i = (int)(0); ((i) < (nVector)) && ((aiMap[i]) == (i)); i++)
			{
			}

			if ((i) == (nVector))
			{
				rLhs = (int)(rLhsOrig);
			}
			else
			{
				rLhs = (int)(sqlite3GetTempRange(pParse, (int)(nVector)));
				for (i = (int)(0); (i) < (nVector); i++)
				{
					sqlite3VdbeAddOp3(v, (int)(79), (int)(rLhsOrig + i), (int)(rLhs + aiMap[i]), (int)(0));
				}
			}

			if ((eType) == (5))
			{
				ExprList pList;
				CollSeq pColl;
				int labelOk = (int)(sqlite3VdbeMakeLabel(pParse));
				int r2 = 0;
				int regToFree = 0;
				int regCkNull = (int)(0);
				int ii = 0;

				pList = pExpr.x.pList;
				pColl = sqlite3ExprCollSeq(pParse, pExpr.pLeft);
				if (destIfNull != destIfFalse)
				{
					regCkNull = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp3(v, (int)(102), (int)(rLhs), (int)(rLhs), (int)(regCkNull));
				}

				for (ii = (int)(0); (ii) < (pList.nExpr); ii++)
				{
					r2 = (int)(sqlite3ExprCodeTemp(pParse, pList.a[ii].pExpr, &regToFree));
					if (((regCkNull) != 0) && ((sqlite3ExprCanBeNull(pList.a[ii].pExpr)) != 0))
					{
						sqlite3VdbeAddOp3(v, (int)(102), (int)(regCkNull), (int)(r2), (int)(regCkNull));
					}

					sqlite3ReleaseTempReg(pParse, (int)(regToFree));
					if (((ii) < (pList.nExpr - 1)) || (destIfNull != destIfFalse))
					{
						int op = (int)(rLhs != r2 ? 53 : 51);
						sqlite3VdbeAddOp4(v, (int)(op), (int)(rLhs), (int)(labelOk), (int)(r2), (void*)(pColl), (int)(-2));
						sqlite3VdbeChangeP5(v, (ushort)(zAff[0]));
					}
					else
					{
						int op = (int)(rLhs != r2 ? 52 : 50);

						sqlite3VdbeAddOp4(v, (int)(op), (int)(rLhs), (int)(destIfFalse), (int)(r2), (void*)(pColl), (int)(-2));
						sqlite3VdbeChangeP5(v, (ushort)(zAff[0] | 0x10));
					}
				}

				if ((regCkNull) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(50), (int)(regCkNull), (int)(destIfNull));
					sqlite3VdbeGoto(v, (int)(destIfFalse));
				}

				sqlite3VdbeResolveLabel(v, (int)(labelOk));
				sqlite3ReleaseTempReg(pParse, (int)(regCkNull));
				goto sqlite3ExprCodeIN_finished;
			}

			if ((destIfNull) == (destIfFalse))
			{
				destStep2 = (int)(destIfFalse);
			}
			else
			{
				destStep2 = (int)(destStep6 = (int)(sqlite3VdbeMakeLabel(pParse)));
			}

			for (i = (int)(0); (i) < (nVector); i++)
			{
				Expr p = sqlite3VectorFieldSubexpr(pExpr.pLeft, (int)(i));
				if ((pParse.nErr) != 0)
					goto sqlite3ExprCodeIN_oom_error;
				if ((sqlite3ExprCanBeNull(p)) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(50), (int)(rLhs + i), (int)(destStep2));
				}
			}

			if ((eType) == (1))
			{
				sqlite3VdbeAddOp3(v, (int)(32), (int)(iTab), (int)(destIfFalse), (int)(rLhs));
				addrTruthOp = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
			}
			else
			{
				sqlite3VdbeAddOp4(v, (int)(95), (int)(rLhs), (int)(nVector), (int)(0), zAff, (int)(nVector));
				if ((destIfFalse) == (destIfNull))
				{
					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iTab), (int)(destIfFalse), (int)(rLhs), (int)(nVector));
					goto sqlite3ExprCodeIN_finished;
				}

				addrTruthOp = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iTab), (int)(0), (int)(rLhs), (int)(nVector)));
			}

			if (((rRhsHasNull) != 0) && ((nVector) == (1)))
			{
				sqlite3VdbeAddOp2(v, (int)(51), (int)(rRhsHasNull), (int)(destIfFalse));
			}

			if ((destIfFalse) == (destIfNull))
				sqlite3VdbeGoto(v, (int)(destIfFalse));
			if ((destStep6) != 0)
				sqlite3VdbeResolveLabel(v, (int)(destStep6));
			addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iTab), (int)(destIfFalse)));
			if ((nVector) > (1))
			{
				destNotNull = (int)(sqlite3VdbeMakeLabel(pParse));
			}
			else
			{
				destNotNull = (int)(destIfFalse);
			}

			for (i = (int)(0); (i) < (nVector); i++)
			{
				Expr p;
				CollSeq pColl;
				int r3 = (int)(sqlite3GetTempReg(pParse));
				p = sqlite3VectorFieldSubexpr(pLeft, (int)(i));
				pColl = sqlite3ExprCollSeq(pParse, p);
				sqlite3VdbeAddOp3(v, (int)(93), (int)(iTab), (int)(i), (int)(r3));
				sqlite3VdbeAddOp4(v, (int)(52), (int)(rLhs + i), (int)(destNotNull), (int)(r3), (void*)(pColl), (int)(-2));
				sqlite3ReleaseTempReg(pParse, (int)(r3));
			}

			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(destIfNull));
			if ((nVector) > (1))
			{
				sqlite3VdbeResolveLabel(v, (int)(destNotNull));
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addrTop + 1));
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(destIfFalse));
			}

			sqlite3VdbeJumpHere(v, (int)(addrTruthOp));
		sqlite3ExprCodeIN_finished:
			; if (rLhs != rLhsOrig) sqlite3ReleaseTempReg(pParse, (int)(rLhs));
			sqlite3ExprCodeIN_oom_error:
			; sqlite3DbFree(pParse.db, aiMap);
			sqlite3DbFree(pParse.db, zAff);
		}
		public static void sqlite3ExprCodeLoadIndexColumn(Parse pParse, Index pIdx, int iTabCur, int iIdxCol, int regOut)
		{
			short iTabCol = (short)(pIdx.aiColumn[iIdxCol]);
			if ((iTabCol) == (-2))
			{


				pParse.iSelfTab = (int)(iTabCur + 1);
				sqlite3ExprCodeCopy(pParse, pIdx.aColExpr.a[iIdxCol].pExpr, (int)(regOut));
				pParse.iSelfTab = (int)(0);
			}
			else
			{
				sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pIdx.pTable, (int)(iTabCur), (int)(iTabCol), (int)(regOut));
			}
		}
		public static void sqlite3ExprCodeMove(Parse pParse, int iFrom, int iTo, int nReg)
		{
			sqlite3VdbeAddOp3(pParse.pVdbe, (int)(78), (int)(iFrom), (int)(iTo), (int)(nReg));
		}
		public static int sqlite3ExprCodeRunJustOnce(Parse pParse, Expr pExpr, int regDest)
		{
			ExprList p;

			p = pParse.pConstExpr;
			if (((regDest) < (0)) && ((p) != null))
			{
				ExprList_item* pItem;
				int i = 0;
				for (pItem = p.a, i = (int)(p.nExpr); (i) > (0); pItem++, i--)
				{
					if (((pItem->reusable) != 0) && ((sqlite3ExprCompare(null, pItem->pExpr, pExpr, (int)(-1))) == (0)))
					{
						return (int)(pItem->u.iConstExprReg);
					}
				}
			}

			pExpr = sqlite3ExprDup(pParse.db, pExpr, (int)(0));
			if ((pExpr != null) && (((pExpr).flags & (0x000004)) != 0))
			{
				Vdbe v = pParse.pVdbe;
				int addr = 0;

				addr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
				pParse.okConstFactor = (byte)(0);
				if (pParse.db.mallocFailed == 0)
				{
					if ((regDest) < (0))
						regDest = (int)(++pParse.nMem);
					sqlite3ExprCode(pParse, pExpr, (int)(regDest));
				}

				pParse.okConstFactor = (byte)(1);
				sqlite3ExprDelete(pParse.db, pExpr);
				sqlite3VdbeJumpHere(v, (int)(addr));
			}
			else
			{
				p = sqlite3ExprListAppend(pParse, p, pExpr);
				if ((p) != null)
				{
					ExprList_item* pItem = &p.a[p.nExpr - 1];
					pItem->reusable = (uint)((regDest) < (0));
					if ((regDest) < (0))
						regDest = (int)(++pParse.nMem);
					pItem->u.iConstExprReg = (int)(regDest);
				}

				pParse.pConstExpr = p;
			}

			return (int)(regDest);
		}
		public static int sqlite3ExprCodeTarget(Parse pParse, Expr pExpr, int target)
		{
			Vdbe v = pParse.pVdbe;
			int op = 0;
			int inReg = (int)(target);
			int regFree1 = (int)(0);
			int regFree2 = (int)(0);
			int r1 = 0; int r2 = 0;
			Expr tempX = new Expr();
			int p5 = (int)(0);


		expr_code_doover:
			; if ((pExpr) == (null)) { op = (int)(121); } else { ((void)(0)); op = (int)(pExpr.op); }
			switch (op)
			{
				case 169:
					{
						AggInfo pAggInfo = pExpr.pAggInfo;
						AggInfo_col* pCol;


						pCol = &pAggInfo.aCol[pExpr.iAgg];
						if (pAggInfo.directMode == 0)
						{

							return (int)(pCol->iMem);
						}
						else if ((pAggInfo.useSortingIdx) != 0)
						{
							Table pTab = pCol->pTab;
							sqlite3VdbeAddOp3(v, (int)(93), (int)(pAggInfo.sortingIdxPTab), (int)(pCol->iSorterColumn), (int)(target));
							if ((pCol->iColumn) < (0))
							{
							}
							else
							{
								if ((pTab.aCol[pCol->iColumn].affinity) == (0x45))
								{
									sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
								}
							}

							return (int)(target);
						}
					}

				case 167:
					{
						int iTab = (int)(pExpr.iTable);
						int iReg = 0;
						if ((((pExpr).flags & (0x000008)) != 0))
						{
							int aff = 0;
							iReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));

							if ((pExpr.y.pTab) != null)
							{
								aff = (int)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
							}
							else
							{
								aff = (int)(pExpr.affExpr);
							}

							if ((aff) > (0x41))
							{


								sqlite3VdbeAddOp4(v, (int)(95), (int)(iReg), (int)(1), (int)(0), &sqlite3ExprCodeTarget_zAff[(aff - 66) * 2], (int)(-1));
							}

							return (int)(iReg);
						}

						if ((iTab) < (0))
						{
							if ((pParse.iSelfTab) < (0))
							{
								Column* pCol;
								Table pTab;
								int iSrc = 0;
								int iCol = (int)(pExpr.iColumn);

								pTab = pExpr.y.pTab;



								if ((iCol) < (0))
								{
									return (int)(-1 - pParse.iSelfTab);
								}

								pCol = pTab.aCol + iCol;
								iSrc = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)) - pParse.iSelfTab);
								if ((pCol->colFlags & 0x0060) != 0)
								{
									if ((pCol->colFlags & 0x0100) != 0)
									{
										sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol->zCnName);
										return (int)(0);
									}

									pCol->colFlags |= (ushort)(0x0100);
									if ((pCol->colFlags & 0x0080) != 0)
									{
										sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, (int)(iSrc));
									}

									pCol->colFlags &= (ushort)(~(0x0100 | 0x0080));
									return (int)(iSrc);
								}
								else if ((pCol->affinity) == (0x45))
								{
									sqlite3VdbeAddOp2(v, (int)(80), (int)(iSrc), (int)(target));
									sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
									return (int)(target);
								}
								else
								{
									return (int)(iSrc);
								}
							}
							else
							{
								iTab = (int)(pParse.iSelfTab - 1);
							}
						}


						iReg = (int)(sqlite3ExprCodeGetColumn(pParse, pExpr.y.pTab, (int)(pExpr.iColumn), (int)(iTab), (int)(target), (byte)(pExpr.op2)));
						if (((pExpr.y.pTab) == (null)) && ((pExpr.affExpr) == (0x45)))
						{
							sqlite3VdbeAddOp1(v, (int)(86), (int)(iReg));
						}

						return (int)(iReg);
					}

				case 155:
					{
						codeInteger(pParse, pExpr, (int)(0), (int)(target));
						return (int)(target);
					}

				case 170:
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(sqlite3ExprTruthValue(pExpr)), (int)(target));
						return (int)(target);
					}

				case 153:
					{

						codeReal(v, pExpr.u.zToken, (int)(0), (int)(target));
						return (int)(target);
					}

				case 117:
					{

						sqlite3VdbeLoadString(v, (int)(target), pExpr.u.zToken);
						return (int)(target);
					}

				default:
					{

						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
						return (int)(target);
					}

				case 154:
					{
						int n = 0;
						sbyte* z;
						sbyte* zBlob;



						z = &pExpr.u.zToken[2];
						n = (int)(sqlite3Strlen30(z) - 1);

						zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, (int)(n));
						sqlite3VdbeAddOp4(v, (int)(76), (int)(n / 2), (int)(target), (int)(0), zBlob, (int)(-7));
						return (int)(target);
					}

				case 156:
					{



						sqlite3VdbeAddOp2(v, (int)(77), (int)(pExpr.iColumn), (int)(target));
						if (pExpr.u.zToken[1] != 0)
						{
							sbyte* z = sqlite3VListNumToName(pParse.pVList, (int)(pExpr.iColumn));

							pParse.pVList[0] = (int)(0);
							sqlite3VdbeAppendP4(v, z, (int)(-1));
						}

						return (int)(target);
					}

				case 176:
					{
						return (int)(pExpr.iTable);
					}

				case 36:
					{
						inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
						if (inReg != target)
						{
							sqlite3VdbeAddOp2(v, (int)(80), (int)(inReg), (int)(target));
							inReg = (int)(target);
						}


						sqlite3VdbeAddOp2(v, (int)(87), (int)(target), (int)(sqlite3AffinityType(pExpr.u.zToken, null)));
						return (int)(inReg);
					}

				case 45:
				case 171:
					op = (int)(((op) == (45)) ? 53 : 52);
					p5 = (int)(0x80);
				case 56:
				case 55:
				case 54:
				case 57:
				case 52:
				case 53:
					{
						Expr pLeft = pExpr.pLeft;
						if ((sqlite3ExprIsVector(pLeft)) != 0)
						{
							codeVectorCompare(pParse, pExpr, (int)(target), (byte)(op), (byte)(p5));
						}
						else
						{
							r1 = (int)(sqlite3ExprCodeTemp(pParse, pLeft, &regFree1));
							r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
							sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(inReg));
							codeCompare(pParse, pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(p5), (int)(((pExpr).flags & (0x000200)) != 0));






							if ((p5) == (0x80))
							{
								sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(inReg));
							}
							else
							{
								sqlite3VdbeAddOp3(v, (int)(91), (int)(r1), (int)(inReg), (int)(r2));
							}
						}

						break;
					}

				case 44:
				case 43:
				case 106:
				case 108:
				case 107:
				case 110:
				case 102:
				case 103:
				case 109:
				case 104:
				case 105:
				case 111:
					{











						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
						sqlite3VdbeAddOp3(v, (int)(op), (int)(r2), (int)(r1), (int)(target));
						break;
					}

				case 173:
					{
						Expr pLeft = pExpr.pLeft;

						if ((pLeft.op) == (155))
						{
							codeInteger(pParse, pLeft, (int)(1), (int)(target));
							return (int)(target);
						}
						else if ((pLeft.op) == (153))
						{

							codeReal(v, pLeft.u.zToken, (int)(1), (int)(target));
							return (int)(target);
						}
						else
						{
							tempX.op = (byte)(155);
							tempX.flags = (uint)(0x000400 | 0x004000);
							tempX.u.iValue = (int)(0);
							r1 = (int)(sqlite3ExprCodeTemp(pParse, tempX, &regFree1));
							r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree2));
							sqlite3VdbeAddOp3(v, (int)(107), (int)(r2), (int)(r1), (int)(target));
						}

						break;
					}

				case 114:
				case 19:
					{


						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(inReg));
						break;
					}

				case 175:
					{
						int isTrue = 0;
						int bNormal = 0;
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
						bNormal = (int)((pExpr.op2) == (45) ? 1 : 0);
						sqlite3VdbeAddOp4Int(v, (int)(90), (int)(r1), (int)(inReg), (int)(!isTrue), (int)(isTrue ^ bNormal));
						break;
					}

				case 50:
				case 51:
					{
						int addr = 0;


						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(target));
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						addr = (int)(sqlite3VdbeAddOp1(v, (int)(op), (int)(r1)));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(target));
						sqlite3VdbeJumpHere(v, (int)(addr));
						break;
					}

				case 168:
					{
						AggInfo pInfo = pExpr.pAggInfo;
						if ((((pInfo) == (null)) || ((pExpr.iAgg) < (0))) || ((pExpr.iAgg) >= (pInfo.nFunc)))
						{

							sqlite3ErrorMsg(pParse, "misuse of aggregate: %#T()", pExpr);
						}
						else
						{
							return (int)(pInfo.aFunc[pExpr.iAgg].iMem);
						}

						break;
					}

				case 172:
					{
						ExprList pFarg;
						int nFarg = 0;
						FuncDef pDef;
						sbyte* zId;
						uint constMask = (uint)(0);
						int i = 0;
						sqlite3 db = pParse.db;
						byte enc = (byte)((db).enc);
						CollSeq pColl = null;
						if ((((pExpr).flags & (0x1000000)) != 0))
						{
							return (int)(pExpr.y.pWin.regResult);
						}

						if ((((pParse).okConstFactor) != 0) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
						{
							return (int)(sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(-1)));
						}



						pFarg = pExpr.x.pList;
						nFarg = (int)(pFarg ? pFarg.nExpr : 0);

						zId = pExpr.u.zToken;
						pDef = sqlite3FindFunction(db, zId, (int)(nFarg), (byte)(enc), (byte)(0));
						if (((pDef) == (null)) || (pDef.xFinalize != null))
						{
							sqlite3ErrorMsg(pParse, "unknown function: %#T()", pExpr);
							break;
						}

						if ((pDef.funcFlags & 0x00400000) != 0)
						{


							return (int)(exprCodeInlineFunction(pParse, pFarg, ((int)((long)(pDef.pUserData))), (int)(target)));
						}
						else if ((pDef.funcFlags & (0x00080000 | 0x00200000)) != 0)
						{
							sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
						}

						for (i = (int)(0); (i) < (nFarg); i++)
						{
							if (((i) < (32)) && ((sqlite3ExprIsConstant(pFarg.a[i].pExpr)) != 0))
							{
								constMask |= (uint)(((uint)(1)) << (i));
							}

							if (((pDef.funcFlags & 0x0020) != 0) && (pColl == null))
							{
								pColl = sqlite3ExprCollSeq(pParse, pFarg.a[i].pExpr);
							}
						}

						if ((pFarg) != null)
						{
							if ((constMask) != 0)
							{
								r1 = (int)(pParse.nMem + 1);
								pParse.nMem += (int)(nFarg);
							}
							else
							{
								r1 = (int)(sqlite3GetTempRange(pParse, (int)(nFarg)));
							}

							if ((pDef.funcFlags & (0x0040 | 0x0080)) != 0)
							{
								byte exprOp = 0;


								exprOp = (byte)(pFarg.a[0].pExpr.op);
								if (((exprOp) == (167)) || ((exprOp) == (169)))
								{


									pFarg.a[0].pExpr.op2 = (byte)(pDef.funcFlags & (0x40 | 0x80));
								}
							}

							sqlite3ExprCodeExprList(pParse, pFarg, (int)(r1), (int)(0), (byte)(0x01 | 0x02));
						}
						else
						{
							r1 = (int)(0);
						}

						if (((nFarg) >= (2)) && (((pExpr).flags & (0x000080)) != 0))
						{
							pDef = sqlite3VtabOverloadFunction(db, pDef, (int)(nFarg), pFarg.a[1].pExpr);
						}
						else if ((nFarg) > (0))
						{
							pDef = sqlite3VtabOverloadFunction(db, pDef, (int)(nFarg), pFarg.a[0].pExpr);
						}

						if ((pDef.funcFlags & 0x0020) != 0)
						{
							if (pColl == null)
								pColl = db.pDfltColl;
							sqlite3VdbeAddOp4(v, (int)(84), (int)(0), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
						}

						{
							sqlite3VdbeAddFunctionCall(pParse, (int)(constMask), (int)(r1), (int)(target), (int)(nFarg), pDef, (int)(pExpr.op2));
						}

						if ((nFarg) != 0)
						{
							if ((constMask) == (0))
							{
								sqlite3ReleaseTempRange(pParse, (int)(r1), (int)(nFarg));
							}
							else
							{
							}
						}

						return (int)(target);
					}

				case 20:
				case 138:
					{
						int nCol = 0;
						if ((pParse.db.mallocFailed) != 0)
						{
							return (int)(0);
						}
						else if ((((op) == (138)) && ((((pExpr).flags & 0x000800) != 0) != 0)) && ((nCol = (int)(pExpr.x.pSelect.pEList.nExpr)) != 1))
						{
							sqlite3SubselectError(pParse, (int)(nCol), (int)(1));
						}
						else
						{
							return (int)(sqlite3CodeSubselect(pParse, pExpr));
						}

						break;
					}

				case 178:
					{
						int n = 0;
						if ((pExpr.pLeft.iTable) == (0))
						{
							pExpr.pLeft.iTable = (int)(sqlite3CodeSubselect(pParse, pExpr.pLeft));
						}


						n = (int)(sqlite3ExprVectorSize(pExpr.pLeft));
						if (pExpr.iTable != n)
						{
							sqlite3ErrorMsg(pParse, "%d columns assigned %d values", (int)(pExpr.iTable), (int)(n));
						}

						return (int)(pExpr.pLeft.iTable + pExpr.iColumn);
					}

				case 49:
					{
						int destIfFalse = (int)(sqlite3VdbeMakeLabel(pParse));
						int destIfNull = (int)(sqlite3VdbeMakeLabel(pParse));
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
						sqlite3ExprCodeIN(pParse, pExpr, (int)(destIfFalse), (int)(destIfNull));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(target));
						sqlite3VdbeResolveLabel(v, (int)(destIfFalse));
						sqlite3VdbeAddOp2(v, (int)(85), (int)(target), (int)(0));
						sqlite3VdbeResolveLabel(v, (int)(destIfNull));
						return (int)(target);
					}

				case 48:
					{
						exprCodeBetween(pParse, pExpr, (int)(target), null, (int)(0));
						return (int)(target);
					}

				case 181:
				case 113:
				case 174:
					{
						pExpr = pExpr.pLeft;
						goto expr_code_doover;
					}

				case 77:
					{
						Table pTab;
						int iCol = 0;
						int p1 = 0;

						pTab = pExpr.y.pTab;
						iCol = (int)(pExpr.iColumn);
						p1 = (int)(pExpr.iTable * (pTab.nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, (short)(iCol)));




						sqlite3VdbeAddOp2(v, (int)(156), (int)(p1), (int)(target));
						if (((iCol) >= (0)) && ((pTab.aCol[iCol].affinity) == (0x45)))
						{
							sqlite3VdbeAddOp1(v, (int)(86), (int)(target));
						}

						break;
					}

				case 177:
					{
						sqlite3ErrorMsg(pParse, "row value misused");
						break;
					}

				case 179:
					{
						int addrINR = 0;
						byte okConstFactor = (byte)(pParse.okConstFactor);
						addrINR = (int)(sqlite3VdbeAddOp1(v, (int)(22), (int)(pExpr.iTable)));
						pParse.okConstFactor = (byte)(0);
						inReg = (int)(sqlite3ExprCodeTarget(pParse, pExpr.pLeft, (int)(target)));
						pParse.okConstFactor = (byte)(okConstFactor);
						sqlite3VdbeJumpHere(v, (int)(addrINR));
						sqlite3VdbeChangeP3(v, (int)(addrINR), (int)(inReg));
						break;
					}

				case 157:
					{
						int endLabel = 0;
						int nextCase = 0;
						int nExpr = 0;
						int i = 0;
						ExprList pEList;
						ExprList_item* aListelem;
						Expr opCompare = new Expr();
						Expr pX;
						Expr pTest = null;
						Expr pDel = null;
						sqlite3 db = pParse.db;


						pEList = pExpr.x.pList;
						aListelem = pEList.a;
						nExpr = (int)(pEList.nExpr);
						endLabel = (int)(sqlite3VdbeMakeLabel(pParse));
						if ((pX = pExpr.pLeft) != null)
						{
							pDel = sqlite3ExprDup(db, pX, (int)(0));
							if ((db.mallocFailed) != 0)
							{
								sqlite3ExprDelete(db, pDel);
								break;
							}

							exprToRegister(pDel, (int)(exprCodeVector(pParse, pDel, &regFree1)));
							CRuntime.memset(opCompare, (int)(0), (ulong)(sizeof(Expr)));
							opCompare.op = (byte)(53);
							opCompare.pLeft = pDel;
							pTest = opCompare;
							regFree1 = (int)(0);
						}

						for (i = (int)(0); (i) < (nExpr - 1); i = (int)(i + 2))
						{
							if ((pX) != null)
							{

								opCompare.pRight = aListelem[i].pExpr;
							}
							else
							{
								pTest = aListelem[i].pExpr;
							}

							nextCase = (int)(sqlite3VdbeMakeLabel(pParse));
							sqlite3ExprIfFalse(pParse, pTest, (int)(nextCase), (int)(0x10));
							sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, (int)(target));
							sqlite3VdbeGoto(v, (int)(endLabel));
							sqlite3VdbeResolveLabel(v, (int)(nextCase));
						}

						if ((nExpr & 1) != 0)
						{
							sqlite3ExprCode(pParse, pEList.a[nExpr - 1].pExpr, (int)(target));
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(target));
						}

						sqlite3ExprDelete(db, pDel);
						setDoNotMergeFlagOnCopy(v);
						sqlite3VdbeResolveLabel(v, (int)(endLabel));
						break;
					}

				case 71:
					{

						if ((pParse.pTriggerTab == null) && (pParse.nested == 0))
						{
							sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program");
							return (int)(0);
						}

						if ((pExpr.affExpr) == (2))
						{
							sqlite3MayAbort(pParse);
						}


						if ((pExpr.affExpr) == (4))
						{
							sqlite3VdbeAddOp4(v, (int)(70), (int)(0), (int)(4), (int)(0), pExpr.u.zToken, (int)(0));
						}
						else
						{
							sqlite3HaltConstraint(pParse, (int)(pParse.pTriggerTab ? (19 | (7 << 8)) : 1), (int)(pExpr.affExpr), pExpr.u.zToken, (sbyte)(0), (byte)(0));
						}

						break;
					}
			}

			sqlite3ReleaseTempReg(pParse, (int)(regFree1));
			sqlite3ReleaseTempReg(pParse, (int)(regFree2));
			return (int)(inReg);
		}
		public static int sqlite3ExprCodeTemp(Parse pParse, Expr pExpr, int* pReg)
		{
			int r2 = 0;
			pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
			if ((((((pParse).okConstFactor) != 0) && (pExpr != null)) && (pExpr.op != 176)) && ((sqlite3ExprIsConstantNotJoin(pExpr)) != 0))
			{
				*pReg = (int)(0);
				r2 = (int)(sqlite3ExprCodeRunJustOnce(pParse, pExpr, (int)(-1)));
			}
			else
			{
				int r1 = (int)(sqlite3GetTempReg(pParse));
				r2 = (int)(sqlite3ExprCodeTarget(pParse, pExpr, (int)(r1)));
				if ((r2) == (r1))
				{
					*pReg = (int)(r1);
				}
				else
				{
					sqlite3ReleaseTempReg(pParse, (int)(r1));
					*pReg = (int)(0);
				}
			}

			return (int)(r2);
		}
		public static CollSeq sqlite3ExprCollSeq(Parse pParse, Expr pExpr)
		{
			sqlite3 db = pParse.db;
			CollSeq pColl = null;
			Expr p = pExpr;
			while ((p) != null)
			{
				int op = (int)(p.op);
				if ((op) == (176))
					op = (int)(p.op2);
				if ((((op) == (169)) || ((op) == (167))) || ((op) == (77)))
				{

					if (p.y.pTab != null)
					{
						int j = (int)(p.iColumn);
						if ((j) >= (0))
						{
							sbyte* zColl = sqlite3ColumnColl(&p.y.pTab.aCol[j]);
							pColl = sqlite3FindCollSeq(db, (byte)((db).enc), zColl, (int)(0));
						}

						break;
					}
				}

				if (((op) == (36)) || ((op) == (174)))
				{
					p = p.pLeft;
					continue;
				}

				if ((op) == (177))
				{

					p = p.x.pList.a[0].pExpr;
					continue;
				}

				if ((op) == (113))
				{

					pColl = sqlite3GetCollSeq(pParse, (byte)((db).enc), null, p.u.zToken);
					break;
				}

				if ((p.flags & 0x000100) != 0)
				{
					if (((p.pLeft) != null) && ((p.pLeft.flags & 0x000100) != 0))
					{
						p = p.pLeft;
					}
					else
					{
						Expr pNext = p.pRight;


						if ((p.x.pList != null) && (db.mallocFailed == 0))
						{
							int i = 0;
							for (i = (int)(0); ((i) < (p.x.pList.nExpr)); i++)
							{
								if ((((p.x.pList.a[i].pExpr).flags & (0x000100)) != 0))
								{
									pNext = p.x.pList.a[i].pExpr;
									break;
								}
							}
						}

						p = pNext;
					}
				}
				else
				{
					break;
				}
			}

			if ((sqlite3CheckCollSeq(pParse, pColl)) != 0)
			{
				pColl = null;
			}

			return pColl;
		}
		public static int sqlite3ExprCollSeqMatch(Parse pParse, Expr pE1, Expr pE2)
		{
			CollSeq pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
			CollSeq pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
			return ((sqlite3StrICmp(pColl1.zName, pColl2.zName)) == (0) ? 1 : 0);
		}
		public static ulong sqlite3ExprColUsed(Expr pExpr)
		{
			int n = 0;
			Table pExTab;
			n = (int)(pExpr.iColumn);

			pExTab = pExpr.y.pTab;

			if (((pExTab.tabFlags & 0x00000060) != 0) && ((pExTab.aCol[n].colFlags & 0x0060) != 0))
			{
				return (ulong)((pExTab.nCol) >= ((int)(sizeof(ulong) * 8)) ? ((ulong)(-1)) : (((ulong)(1)) << (pExTab.nCol)) - 1);
			}
			else
			{
				if ((n) >= ((int)(sizeof(ulong) * 8)))
					n = (int)(((int)(sizeof(ulong) * 8)) - 1);
				return (ulong)(((ulong)(1)) << n);
			}
		}
		public static int sqlite3ExprCompare(Parse pParse, Expr pA, Expr pB, int iTab)
		{
			uint combinedFlags = 0;
			if (((pA) == (null)) || ((pB) == (null)))
			{
				return (int)((pB) == (pA) ? 0 : 2);
			}

			if ((((pParse) != null) && ((pA.op) == (156))) && ((exprCompareVariable(pParse, pA, pB)) != 0))
			{
				return (int)(0);
			}

			combinedFlags = (uint)(pA.flags | pB.flags);
			if ((combinedFlags & 0x000400) != 0)
			{
				if (((pA.flags & pB.flags & 0x000400) != 0) && ((pA.u.iValue) == (pB.u.iValue)))
				{
					return (int)(0);
				}

				return (int)(2);
			}

			if ((pA.op != pB.op) || ((pA.op) == (71)))
			{
				if (((pA.op) == (113)) && ((sqlite3ExprCompare(pParse, pA.pLeft, pB, (int)(iTab))) < (2)))
				{
					return (int)(1);
				}

				if (((pB.op) == (113)) && ((sqlite3ExprCompare(pParse, pA, pB.pLeft, (int)(iTab))) < (2)))
				{
					return (int)(1);
				}

				return (int)(2);
			}



			if ((pA.u.zToken) != null)
			{
				if (((pA.op) == (172)) || ((pA.op) == (168)))
				{
					if (sqlite3StrICmp(pA.u.zToken, pB.u.zToken) != 0)
						return (int)(2);

					if ((((pA).flags & (0x1000000)) != 0) != (((pB).flags & (0x1000000)) != 0))
					{
						return (int)(2);
					}

					if ((((pA).flags & (0x1000000)) != 0))
					{
						if (sqlite3WindowCompare(pParse, pA.y.pWin, pB.y.pWin, (int)(1)) != 0)
						{
							return (int)(2);
						}
					}
				}
				else if ((pA.op) == (121))
				{
					return (int)(0);
				}
				else if ((pA.op) == (113))
				{
					if (sqlite3_stricmp(pA.u.zToken, pB.u.zToken) != 0)
						return (int)(2);
				}
				else if ((((pB.u.zToken != null) && (pA.op != 167)) && (pA.op != 169)) && (CRuntime.strcmp(pA.u.zToken, pB.u.zToken) != 0))
				{
					return (int)(2);
				}
			}

			if ((pA.flags & (0x000002 | 0x000200)) != (pB.flags & (0x000002 | 0x000200)))
				return (int)(2);
			if (((combinedFlags & 0x004000) == (0)))
			{
				if ((combinedFlags & 0x000800) != 0)
					return (int)(2);
				if (((combinedFlags & 0x000008) == (0)) && ((sqlite3ExprCompare(pParse, pA.pLeft, pB.pLeft, (int)(iTab))) != 0))
					return (int)(2);
				if ((sqlite3ExprCompare(pParse, pA.pRight, pB.pRight, (int)(iTab))) != 0)
					return (int)(2);
				if ((sqlite3ExprListCompare(pA.x.pList, pB.x.pList, (int)(iTab))) != 0)
					return (int)(2);
				if (((pA.op != 117) && (pA.op != 170)) && ((combinedFlags & 0x002000) == (0)))
				{
					if (pA.iColumn != pB.iColumn)
						return (int)(2);
					if ((pA.op2 != pB.op2) && ((pA.op) == (175)))
						return (int)(2);
					if (((pA.op != 49) && (pA.iTable != pB.iTable)) && (pA.iTable != iTab))
					{
						return (int)(2);
					}
				}
			}

			return (int)(0);
		}
		public static CollSeq sqlite3ExprCompareCollSeq(Parse pParse, Expr p)
		{
			if ((((p).flags & (0x000200)) != 0))
			{
				return sqlite3BinaryCompareCollSeq(pParse, p.pRight, p.pLeft);
			}
			else
			{
				return sqlite3BinaryCompareCollSeq(pParse, p.pLeft, p.pRight);
			}
		}
		public static int sqlite3ExprCompareSkip(Expr pA, Expr pB, int iTab)
		{
			return (int)(sqlite3ExprCompare(null, sqlite3ExprSkipCollateAndLikely(pA), sqlite3ExprSkipCollateAndLikely(pB), (int)(iTab)));
		}
		public static int sqlite3ExprCoveredByIndex(Expr pExpr, int iCur, Index pIdx)
		{
			Walker w = new Walker();
			IdxCover xcov = new IdxCover();
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			xcov.iCur = (int)(iCur);
			xcov.pIdx = pIdx;
			w.xExprCallback = exprIdxCover;
			w.u.pIdxCover = xcov;
			sqlite3WalkExpr(w, pExpr);
			return (int)(!w.eCode);
		}
		public static void sqlite3ExprDeferredDelete(Parse pParse, Expr pExpr)
		{
			pParse.pConstExpr = sqlite3ExprListAppend(pParse, pParse.pConstExpr, pExpr);
		}
		public static void sqlite3ExprDelete(sqlite3 db, Expr p)
		{
			if ((p) != null)
				sqlite3ExprDeleteNN(db, p);
		}
		public static void sqlite3ExprDeleteNN(sqlite3 db, Expr p)
		{





			if (!(((p).flags & (0x004000 | 0x800000)) != 0))
			{

				if (((p.pLeft) != null) && (p.op != 178))
					sqlite3ExprDeleteNN(db, p.pLeft);
				if ((p.pRight) != null)
				{

					sqlite3ExprDeleteNN(db, p.pRight);
				}
				else if ((((p).flags & 0x000800) != 0))
				{

					sqlite3SelectDelete(db, p.x.pSelect);
				}
				else
				{
					sqlite3ExprListDelete(db, p.x.pList);
					if ((((p).flags & (0x1000000)) != 0))
					{
						sqlite3WindowDelete(db, p.y.pWin);
					}
				}
			}

			if ((((p).flags & (0x010000)) != 0))
			{

				sqlite3DbFree(db, p.u.zToken);
			}

			if (!(((p).flags & (0x8000000)) != 0))
			{
				sqlite3DbFreeNN(db, p);
			}
		}
		public static Expr sqlite3ExprDup(sqlite3 db, Expr p, int flags)
		{

			return p ? exprDup(db, p, (int)(flags), null) : null;
		}
		public static Expr sqlite3ExprForVectorField(Parse pParse, Expr pVector, int iField, int nField)
		{
			Expr pRet;
			if ((pVector.op) == (138))
			{

				pRet = sqlite3PExpr(pParse, (int)(178), null, null);
				if ((pRet) != null)
				{
					pRet.iTable = (int)(nField);
					pRet.iColumn = (short)(iField);
					pRet.pLeft = pVector;
				}
			}
			else
			{
				if ((pVector.op) == (177))
				{
					Expr ppVector;

					ppVector = pVector.x.pList.a[iField].pExpr;
					pVector = ppVector;
					if (((pParse.eParseMode) >= (2)))
					{
						ppVector = null;
						return pVector;
					}
				}

				pRet = sqlite3ExprDup(pParse.db, pVector, (int)(0));
			}

			return pRet;
		}
		public static Expr sqlite3ExprFunction(Parse pParse, ExprList pList, Token* pToken, int eDistinct)
		{
			Expr pNew;
			sqlite3 db = pParse.db;

			pNew = sqlite3ExprAlloc(db, (int)(172), pToken, (int)(1));
			if ((pNew) == (null))
			{
				sqlite3ExprListDelete(db, pList);
				return null;
			}

			pNew.w.iOfst = ((int)(pToken->z - pParse.zTail));
			if ((((pList) != null) && ((pList.nExpr) > (pParse.db.aLimit[6]))) && (pParse.nested == 0))
			{
				sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
			}

			pNew.x.pList = pList;
			(pNew).flags |= (uint)(0x000004);

			sqlite3ExprSetHeightAndFlags(pParse, pNew);
			if ((eDistinct) == (0x0000001))
				(pNew).flags |= (uint)(0x000002);
			return pNew;
		}
		public static void sqlite3ExprFunctionUsable(Parse pParse, Expr pExpr, FuncDef pDef)
		{


			if ((((pExpr).flags & (0x40000000)) != 0))
			{
				if (((pDef.funcFlags & 0x00080000) != 0) || ((pParse.db.flags & 0x00000080) == (0)))
				{
					sqlite3ErrorMsg(pParse, "unsafe use of %#T()", pExpr);
				}
			}
		}
		public static int sqlite3ExprIdToTrueFalse(Expr pExpr)
		{
			uint v = 0;

			if ((!(((pExpr).flags & (0x4000000 | 0x000400)) != 0)) && ((v = (uint)(sqlite3IsTrueOrFalse(pExpr.u.zToken))) != 0))
			{
				pExpr.op = (byte)(170);
				(pExpr).flags |= (uint)(v);
				return (int)(1);
			}

			return (int)(0);
		}
		public static void sqlite3ExprIfFalse(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
		{
			Vdbe v = pParse.pVdbe;
			int op = (int)(0);
			int regFree1 = (int)(0);
			int regFree2 = (int)(0);
			int r1 = 0; int r2 = 0;

			if (((v) == (null)))
				return;
			if ((pExpr) == (null))
				return;

			op = (int)(((pExpr.op + (50 & 1)) ^ 1) - (50 & 1));








			switch (pExpr.op)
			{
				case 44:
				case 43:
					{
						Expr pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
						if (pAlt != pExpr)
						{
							sqlite3ExprIfFalse(pParse, pAlt, (int)(dest), (int)(jumpIfNull));
						}
						else if ((pExpr.op) == (44))
						{
							sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
							sqlite3ExprIfFalse(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
						}
						else
						{
							int d2 = (int)(sqlite3VdbeMakeLabel(pParse));
							sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(d2), (int)(jumpIfNull ^ 0x10));
							sqlite3ExprIfFalse(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
							sqlite3VdbeResolveLabel(v, (int)(d2));
						}

						break;
					}

				case 19:
					{
						sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
						break;
					}

				case 175:
					{
						int isNot = 0;
						int isTrue = 0;
						isNot = (int)((pExpr.op2) == (171) ? 1 : 0);
						isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
						if (isTrue ^ isNot)
						{
							sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0 : 0x10));
						}
						else
						{
							sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0 : 0x10));
						}

						break;
					}

				case 45:
				case 171:
					;
					op = (int)(((pExpr.op) == (45)) ? 52 : 53);
					jumpIfNull = (int)(0x80);
				case 56:
				case 55:
				case 54:
				case 57:
				case 52:
				case 53:
					{
						if ((sqlite3ExprIsVector(pExpr.pLeft)) != 0)
							goto default_expr;
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
						codeCompare(pParse, pExpr.pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(dest), (int)(jumpIfNull), (int)(((pExpr).flags & (0x000200)) != 0));






						break;
					}

				case 50:
				case 51:
					{
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(dest));
						break;
					}

				case 48:
					{
						exprCodeBetween(pParse, pExpr, (int)(dest), sqlite3ExprIfFalse, (int)(jumpIfNull));
						break;
					}

				case 49:
					{
						if ((jumpIfNull) != 0)
						{
							sqlite3ExprCodeIN(pParse, pExpr, (int)(dest), (int)(dest));
						}
						else
						{
							int destIfNull = (int)(sqlite3VdbeMakeLabel(pParse));
							sqlite3ExprCodeIN(pParse, pExpr, (int)(dest), (int)(destIfNull));
							sqlite3VdbeResolveLabel(v, (int)(destIfNull));
						}

						break;
					}

				default:
					{
					default_expr:
						;
						if ((((pExpr).flags & (0x000001 | 0x20000000)) == (0x20000000)))
						{
							sqlite3VdbeGoto(v, (int)(dest));
						}
						else if ((((pExpr).flags & (0x000001 | 0x10000000)) == (0x10000000)))
						{
						}
						else
						{
							r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr, &regFree1));
							sqlite3VdbeAddOp3(v, (int)(20), (int)(r1), (int)(dest), (int)(jumpIfNull != 0));
						}

						break;
					}
			}

			sqlite3ReleaseTempReg(pParse, (int)(regFree1));
			sqlite3ReleaseTempReg(pParse, (int)(regFree2));
		}
		public static void sqlite3ExprIfFalseDup(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
		{
			sqlite3 db = pParse.db;
			Expr pCopy = sqlite3ExprDup(db, pExpr, (int)(0));
			if ((db.mallocFailed) == (0))
			{
				sqlite3ExprIfFalse(pParse, pCopy, (int)(dest), (int)(jumpIfNull));
			}

			sqlite3ExprDelete(db, pCopy);
		}
		public static void sqlite3ExprIfTrue(Parse pParse, Expr pExpr, int dest, int jumpIfNull)
		{
			Vdbe v = pParse.pVdbe;
			int op = (int)(0);
			int regFree1 = (int)(0);
			int regFree2 = (int)(0);
			int r1 = 0; int r2 = 0;

			if (((v) == (null)))
				return;
			if (((pExpr) == (null)))
				return;

			op = (int)(pExpr.op);
			switch (op)
			{
				case 44:
				case 43:
					{
						Expr pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
						if (pAlt != pExpr)
						{
							sqlite3ExprIfTrue(pParse, pAlt, (int)(dest), (int)(jumpIfNull));
						}
						else if ((op) == (44))
						{
							int d2 = (int)(sqlite3VdbeMakeLabel(pParse));
							sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(d2), (int)(jumpIfNull ^ 0x10));
							sqlite3ExprIfTrue(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
							sqlite3VdbeResolveLabel(v, (int)(d2));
						}
						else
						{
							sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
							sqlite3ExprIfTrue(pParse, pExpr.pRight, (int)(dest), (int)(jumpIfNull));
						}

						break;
					}

				case 19:
					{
						sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)(jumpIfNull));
						break;
					}

				case 175:
					{
						int isNot = 0;
						int isTrue = 0;
						isNot = (int)((pExpr.op2) == (171) ? 1 : 0);
						isTrue = (int)(sqlite3ExprTruthValue(pExpr.pRight));
						if (isTrue ^ isNot)
						{
							sqlite3ExprIfTrue(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0x10 : 0));
						}
						else
						{
							sqlite3ExprIfFalse(pParse, pExpr.pLeft, (int)(dest), (int)((isNot) != 0 ? 0x10 : 0));
						}

						break;
					}

				case 45:
				case 171:
					;
					op = (int)(((op) == (45)) ? 53 : 52);
					jumpIfNull = (int)(0x80);
				case 56:
				case 55:
				case 54:
				case 57:
				case 52:
				case 53:
					{
						if ((sqlite3ExprIsVector(pExpr.pLeft)) != 0)
							goto default_expr;
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						r2 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2));
						codeCompare(pParse, pExpr.pLeft, pExpr.pRight, (int)(op), (int)(r1), (int)(r2), (int)(dest), (int)(jumpIfNull), (int)(((pExpr).flags & (0x000200)) != 0));






						break;
					}

				case 50:
				case 51:
					{


						r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1));
						sqlite3VdbeAddOp2(v, (int)(op), (int)(r1), (int)(dest));
						break;
					}

				case 48:
					{
						exprCodeBetween(pParse, pExpr, (int)(dest), sqlite3ExprIfTrue, (int)(jumpIfNull));
						break;
					}

				case 49:
					{
						int destIfFalse = (int)(sqlite3VdbeMakeLabel(pParse));
						int destIfNull = (int)((jumpIfNull) != 0 ? dest : destIfFalse);
						sqlite3ExprCodeIN(pParse, pExpr, (int)(destIfFalse), (int)(destIfNull));
						sqlite3VdbeGoto(v, (int)(dest));
						sqlite3VdbeResolveLabel(v, (int)(destIfFalse));
						break;
					}

				default:
					{
					default_expr:
						;
						if ((((pExpr).flags & (0x000001 | 0x10000000)) == (0x10000000)))
						{
							sqlite3VdbeGoto(v, (int)(dest));
						}
						else if ((((pExpr).flags & (0x000001 | 0x20000000)) == (0x20000000)))
						{
						}
						else
						{
							r1 = (int)(sqlite3ExprCodeTemp(pParse, pExpr, &regFree1));
							sqlite3VdbeAddOp3(v, (int)(18), (int)(r1), (int)(dest), (int)(jumpIfNull != 0));
						}

						break;
					}
			}

			sqlite3ReleaseTempReg(pParse, (int)(regFree1));
			sqlite3ReleaseTempReg(pParse, (int)(regFree2));
		}
		public static int sqlite3ExprImpliesExpr(Parse pParse, Expr pE1, Expr pE2, int iTab)
		{
			if ((sqlite3ExprCompare(pParse, pE1, pE2, (int)(iTab))) == (0))
			{
				return (int)(1);
			}

			if (((pE2.op) == (43)) && (((sqlite3ExprImpliesExpr(pParse, pE1, pE2.pLeft, (int)(iTab))) != 0) || ((sqlite3ExprImpliesExpr(pParse, pE1, pE2.pRight, (int)(iTab))) != 0)))
			{
				return (int)(1);
			}

			if (((pE2.op) == (51)) && ((exprImpliesNotNull(pParse, pE1, pE2.pLeft, (int)(iTab), (int)(0))) != 0))
			{
				return (int)(1);
			}

			return (int)(0);
		}
		public static int sqlite3ExprImpliesNonNullRow(Expr p, int iTab)
		{
			Walker w = new Walker();
			p = sqlite3ExprSkipCollateAndLikely(p);
			if ((p) == (null))
				return (int)(0);
			if ((p.op) == (51))
			{
				p = p.pLeft;
			}
			else
			{
				while ((p.op) == (44))
				{
					if ((sqlite3ExprImpliesNonNullRow(p.pLeft, (int)(iTab))) != 0)
						return (int)(1);
					p = p.pRight;
				}
			}

			w.xExprCallback = impliesNotNullRow;
			w.xSelectCallback = null;
			w.xSelectCallback2 = null;
			w.eCode = (ushort)(0);
			w.u.iCur = (int)(iTab);
			sqlite3WalkExpr(w, p);
			return (int)(w.eCode);
		}
		public static int sqlite3ExprIsConstant(Expr p)
		{
			return (int)(exprIsConst(p, (int)(1), (int)(0)));
		}
		public static int sqlite3ExprIsConstantNotJoin(Expr p)
		{
			return (int)(exprIsConst(p, (int)(2), (int)(0)));
		}
		public static int sqlite3ExprIsConstantOrFunction(Expr p, byte isInit)
		{

			return (int)(exprIsConst(p, (int)(4 + isInit), (int)(0)));
		}
		public static int sqlite3ExprIsConstantOrGroupBy(Parse pParse, Expr p, ExprList pGroupBy)
		{
			Walker w = new Walker();
			w.eCode = (ushort)(1);
			w.xExprCallback = exprNodeIsConstantOrGroupBy;
			w.xSelectCallback = null;
			w.u.pGroupBy = pGroupBy;
			w.pParse = pParse;
			sqlite3WalkExpr(w, p);
			return (int)(w.eCode);
		}
		public static int sqlite3ExprIsInteger(Expr p, int* pValue)
		{
			int rc = (int)(0);
			if (((p) == (null)))
				return (int)(0);

			if ((p.flags & 0x000400) != 0)
			{
				*pValue = (int)(p.u.iValue);
				return (int)(1);
			}

			switch (p.op)
			{
				case 174:
					{
						rc = (int)(sqlite3ExprIsInteger(p.pLeft, pValue));
						break;
					}

				case 173:
					{
						int v = (int)(0);
						if ((sqlite3ExprIsInteger(p.pLeft, &v)) != 0)
						{

							*pValue = (int)(-v);
							rc = (int)(1);
						}

						break;
					}

				default:
					break;
			}

			return (int)(rc);
		}
		public static int sqlite3ExprIsTableConstant(Expr p, int iCur)
		{
			return (int)(exprIsConst(p, (int)(3), (int)(iCur)));
		}
		public static int sqlite3ExprIsVector(Expr pExpr)
		{
			return ((sqlite3ExprVectorSize(pExpr)) > (1) ? 1 : 0);
		}
		public static ExprList sqlite3ExprListAppend(Parse pParse, ExprList pList, Expr pExpr)
		{
			ExprList_item* pItem;
			if ((pList) == (null))
			{
				return sqlite3ExprListAppendNew(pParse.db, pExpr);
			}

			if ((pList.nAlloc) < (pList.nExpr + 1))
			{
				return sqlite3ExprListAppendGrow(pParse.db, pList, pExpr);
			}

			pItem = &pList.a[pList.nExpr++];
			*pItem = (ExprList_item)(zeroItem);
			pItem->pExpr = pExpr;
			return pList;
		}
		public static ExprList sqlite3ExprListAppendGrow(sqlite3 db, ExprList pList, Expr pExpr)
		{
			ExprList_item* pItem;
			ExprList pNew;
			pList.nAlloc *= (int)(2);
			pNew = sqlite3DbRealloc(db, pList, (ulong)(sizeof(ExprList) + (pList.nAlloc - 1) * sizeof(ExprList_item)));
			if ((pNew) == (null))
			{
				sqlite3ExprListDelete(db, pList);
				sqlite3ExprDelete(db, pExpr);
				return null;
			}
			else
			{
				pList = pNew;
			}

			pItem = &pList.a[pList.nExpr++];
			*pItem = (ExprList_item)(zeroItem);
			pItem->pExpr = pExpr;
			return pList;
		}
		public static ExprList sqlite3ExprListAppendNew(sqlite3 db, Expr pExpr)
		{
			ExprList_item* pItem;
			ExprList pList;
			pList = sqlite3DbMallocRawNN(db, (ulong)(sizeof(ExprList) + sizeof(ExprList_item) * 4));
			if ((pList) == (null))
			{
				sqlite3ExprDelete(db, pExpr);
				return null;
			}

			pList.nAlloc = (int)(4);
			pList.nExpr = (int)(1);
			pItem = &pList.a[0];
			*pItem = (ExprList_item)(zeroItem);
			pItem->pExpr = pExpr;
			return pList;
		}
		public static ExprList sqlite3ExprListAppendVector(Parse pParse, ExprList pList, IdList* pColumns, Expr pExpr)
		{
			sqlite3 db = pParse.db;
			int n = 0;
			int i = 0;
			int iFirst = (int)(pList ? pList.nExpr : 0);
			if (((pColumns) == (null)))
				goto vector_append_error;
			if ((pExpr) == (null))
				goto vector_append_error;
			if ((pExpr.op != 138) && (pColumns->nId != (n = (int)(sqlite3ExprVectorSize(pExpr)))))
			{
				sqlite3ErrorMsg(pParse, "%d columns assigned %d values", (int)(pColumns->nId), (int)(n));
				goto vector_append_error;
			}

			for (i = (int)(0); (i) < (pColumns->nId); i++)
			{
				Expr pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, (int)(i), (int)(pColumns->nId));

				if ((pSubExpr) == (null))
					continue;
				pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
				if ((pList) != null)
				{

					pList.a[pList.nExpr - 1].zEName = pColumns->a[i].zName;
					pColumns->a[i].zName = null;
				}
			}

			if (((db.mallocFailed == 0) && ((pExpr.op) == (138))) && (pList != null))
			{
				Expr pFirst = pList.a[iFirst].pExpr;


				pFirst.pRight = pExpr;
				pExpr = null;
				pFirst.iTable = (int)(pColumns->nId);
			}

		vector_append_error:
			; sqlite3ExprUnmapAndDelete(pParse, pExpr);
			sqlite3IdListDelete(db, pColumns);
			return pList;
		}
		public static void sqlite3ExprListCheckLength(Parse pParse, ExprList pEList, sbyte* zObject)
		{
			int mx = (int)(pParse.db.aLimit[2]);
			if (((pEList) != null) && ((pEList.nExpr) > (mx)))
			{
				sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
			}
		}
		public static int sqlite3ExprListCompare(ExprList pA, ExprList pB, int iTab)
		{
			int i = 0;
			if (((pA) == (null)) && ((pB) == (null)))
				return (int)(0);
			if (((pA) == (null)) || ((pB) == (null)))
				return (int)(1);
			if (pA.nExpr != pB.nExpr)
				return (int)(1);
			for (i = (int)(0); (i) < (pA.nExpr); i++)
			{
				int res = 0;
				Expr pExprA = pA.a[i].pExpr;
				Expr pExprB = pB.a[i].pExpr;
				if (pA.a[i].sortFlags != pB.a[i].sortFlags)
					return (int)(1);
				if ((res = (int)(sqlite3ExprCompare(null, pExprA, pExprB, (int)(iTab)))))
					return (int)(res);
			}

			return (int)(0);
		}
		public static void sqlite3ExprListDelete(sqlite3 db, ExprList pList)
		{
			if ((pList) != null)
				exprListDeleteNN(db, pList);
		}
		public static ExprList sqlite3ExprListDup(sqlite3 db, ExprList p, int flags)
		{
			return null;
		}
		public static uint sqlite3ExprListFlags(ExprList pList)
		{
			int i = 0;
			uint m = (uint)(0);

			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				Expr pExpr = pList.a[i].pExpr;

				m |= (uint)(pExpr.flags);
			}

			return (uint)(m);
		}
		public static void sqlite3ExprListSetName(Parse pParse, ExprList pList, Token* pName, int dequote)
		{


			if ((pList) != null)
			{
				ExprList_item* pItem;

				pItem = &pList.a[pList.nExpr - 1];


				pItem->zEName = sqlite3DbStrNDup(pParse.db, pName->z, (ulong)(pName->n));
				if ((dequote) != 0)
				{
					sqlite3Dequote(pItem->zEName);
					if (((pParse.eParseMode) >= (2)))
					{
						sqlite3RenameTokenMap(pParse, (void*)(pItem->zEName), pName);
					}
				}
			}
		}
		public static void sqlite3ExprListSetSortOrder(ExprList p, int iSortOrder, int eNulls)
		{
			ExprList_item* pItem;
			if ((p) == (null))
				return;




			pItem = &p.a[p.nExpr - 1];

			if ((iSortOrder) == (-1))
			{
				iSortOrder = (int)(0);
			}

			pItem->sortFlags = ((byte)(iSortOrder));
			if (eNulls != -1)
			{
				pItem->bNulls = (uint)(1);
				if (iSortOrder != eNulls)
				{
					pItem->sortFlags |= (byte)(0x02);
				}
			}
		}
		public static void sqlite3ExprListSetSpan(Parse pParse, ExprList pList, sbyte* zStart, sbyte* zEnd)
		{
			sqlite3 db = pParse.db;

			if ((pList) != null)
			{
				ExprList_item* pItem = &pList.a[pList.nExpr - 1];

				if ((pItem->zEName) == (null))
				{
					pItem->zEName = sqlite3DbSpanDup(db, zStart, zEnd);
					pItem->eEName = (uint)(1);
				}
			}
		}
		public static Select sqlite3ExprListToValues(Parse pParse, int nElem, ExprList pEList)
		{
			int ii = 0;
			Select pRet = null;

			for (ii = (int)(0); (ii) < (pEList.nExpr); ii++)
			{
				Select pSel;
				Expr pExpr = pEList.a[ii].pExpr;
				int nExprElem = 0;
				if ((pExpr.op) == (177))
				{

					nExprElem = (int)(pExpr.x.pList.nExpr);
				}
				else
				{
					nExprElem = (int)(1);
				}

				if (nExprElem != nElem)
				{
					sqlite3ErrorMsg(pParse, "IN(...) element has %d term%s - expected %d", (int)(nExprElem), (nExprElem) > (1) ? "s" : "", (int)(nElem));
					break;
				}


				pSel = sqlite3SelectNew(pParse, pExpr.x.pList, null, null, null, null, null, (uint)(0x0000200), null);
				pExpr.x.pList = null;
				if ((pSel) != null)
				{
					if ((pRet) != null)
					{
						pSel.op = (byte)(135);
						pSel.pPrior = pRet;
					}

					pRet = pSel;
				}
			}

			if (((pRet) != null) && ((pRet.pPrior) != null))
			{
				pRet.selFlags |= (uint)(0x0000400);
			}

			sqlite3ExprListDelete(pParse.db, pEList);
			return pRet;
		}
		public static int sqlite3ExprNeedsNoAffinityChange(Expr p, sbyte aff)
		{
			byte op = 0;
			int unaryMinus = (int)(0);
			if ((aff) == (0x41))
				return (int)(1);
			while (((p.op) == (174)) || ((p.op) == (173)))
			{
				if ((p.op) == (173))
					unaryMinus = (int)(1);
				p = p.pLeft;
			}

			op = (byte)(p.op);
			if ((op) == (176))
				op = (byte)(p.op2);
			switch (op)
			{
				case 155:
					{
						return ((aff) >= (0x43) ? 1 : 0);
					}

				case 153:
					{
						return ((aff) >= (0x43) ? 1 : 0);
					}

				case 117:
					{
						return ((unaryMinus == 0) && ((aff) == (0x42)) ? 1 : 0);
					}

				case 154:
					{
						return (int)(!unaryMinus);
					}

				case 167:
					{

						return (((aff) >= (0x43)) && ((p.iColumn) < (0)) ? 1 : 0);
					}

				default:
					{
						return (int)(0);
					}
			}
		}
		public static CollSeq sqlite3ExprNNCollSeq(Parse pParse, Expr pExpr)
		{
			CollSeq p = sqlite3ExprCollSeq(pParse, pExpr);
			if ((p) == (null))
				p = pParse.db.pDfltColl;

			return p;
		}
		public static int sqlite3ExprReferencesUpdatedColumn(Expr pExpr, int* aiChng, int chngRowid)
		{
			Walker w = new Walker();
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			w.eCode = (ushort)(0);
			w.xExprCallback = checkConstraintExprNode;
			w.u.aiCol = aiChng;
			sqlite3WalkExpr(w, pExpr);
			if (chngRowid == 0)
			{
				w.eCode &= (ushort)(~0x02);
			}

			return (int)(w.eCode != 0);
		}
		public static void sqlite3ExprSetHeightAndFlags(Parse pParse, Expr p)
		{
			if ((pParse.nErr) != 0)
				return;
			exprSetHeight(p);
			sqlite3ExprCheckHeight(pParse, (int)(p.nHeight));
		}
		public static Expr sqlite3ExprSimplifiedAndOr(Expr pExpr)
		{

			if (((pExpr.op) == (44)) || ((pExpr.op) == (43)))
			{
				Expr pRight = sqlite3ExprSimplifiedAndOr(pExpr.pRight);
				Expr pLeft = sqlite3ExprSimplifiedAndOr(pExpr.pLeft);
				if ((((pLeft).flags & (0x000001 | 0x10000000)) == (0x10000000)) || (((pRight).flags & (0x000001 | 0x20000000)) == (0x20000000)))
				{
					pExpr = (pExpr.op) == (44) ? pRight : pLeft;
				}
				else if ((((pRight).flags & (0x000001 | 0x10000000)) == (0x10000000)) || (((pLeft).flags & (0x000001 | 0x20000000)) == (0x20000000)))
				{
					pExpr = (pExpr.op) == (44) ? pLeft : pRight;
				}
			}

			return pExpr;
		}
		public static Expr sqlite3ExprSkipCollate(Expr pExpr)
		{
			while (((pExpr) != null) && (((pExpr).flags & (0x001000)) != 0))
			{

				pExpr = pExpr.pLeft;
			}

			return pExpr;
		}
		public static Expr sqlite3ExprSkipCollateAndLikely(Expr pExpr)
		{
			while (((pExpr) != null) && (((pExpr).flags & (0x001000 | 0x040000)) != 0))
			{
				if ((((pExpr).flags & (0x040000)) != 0))
				{



					pExpr = pExpr.x.pList.a[0].pExpr;
				}
				else
				{

					pExpr = pExpr.pLeft;
				}
			}

			return pExpr;
		}
		public static int sqlite3ExprTruthValue(Expr pExpr)
		{
			pExpr = sqlite3ExprSkipCollate(pExpr);



			return ((pExpr.u.zToken[4]) == (0) ? 1 : 0);
		}
		public static void sqlite3ExprUnmapAndDelete(Parse pParse, Expr p)
		{
			if ((p) != null)
			{
				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameExprUnmap(pParse, p);
				}

				sqlite3ExprDeleteNN(pParse.db, p);
			}
		}
		public static int sqlite3ExprVectorSize(Expr pExpr)
		{
			byte op = (byte)(pExpr.op);
			if ((op) == (176))
				op = (byte)(pExpr.op2);
			if ((op) == (177))
			{

				return (int)(pExpr.x.pList.nExpr);
			}
			else if ((op) == (138))
			{

				return (int)(pExpr.x.pSelect.pEList.nExpr);
			}
			else
			{
				return (int)(1);
			}
		}
		public static int sqlite3ExprWalkNoop(Walker NotUsed, Expr NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			return (int)(0);
		}
		public static int sqlite3FaultSim(int iTest)
		{
			delegate20 xCallback = sqlite3Config.xTestCallback;
			return (int)(xCallback ? xCallback((int)(iTest)) : 0);
		}
		public static CollSeq sqlite3FindCollSeq(sqlite3 db, byte enc, sbyte* zName, int create)
		{
			CollSeq pColl;


			if ((zName) != null)
			{
				pColl = findCollSeqEntry(db, zName, (int)(create));
				if ((pColl) != null)
					pColl += enc - 1;
			}
			else
			{
				pColl = db.pDfltColl;
			}

			return pColl;
		}
		public static int sqlite3FindDb(sqlite3 db, Token* pName)
		{
			int i = 0;
			sbyte* zName;
			zName = sqlite3NameFromToken(db, pName);
			i = (int)(sqlite3FindDbName(db, zName));
			sqlite3DbFree(db, zName);
			return (int)(i);
		}
		public static int sqlite3FindDbName(sqlite3 db, sbyte* zName)
		{
			int i = (int)(-1);
			if ((zName) != null)
			{
				Db pDb;
				for (i = (int)(db.nDb - 1), pDb = db.aDb[i]; (i) >= (0); i--, pDb--)
				{
					if ((0) == (sqlite3_stricmp(pDb.zDbSName, zName)))
						break;
					if (((i) == (0)) && ((0) == (sqlite3_stricmp("main", zName))))
						break;
				}
			}

			return (int)(i);
		}
		public static FuncDef sqlite3FindFunction(sqlite3 db, sbyte* zName, int nArg, byte enc, byte createFlag)
		{
			FuncDef p;
			FuncDef pBest = null;
			int bestScore = (int)(0);
			int h = 0;
			int nName = 0;


			nName = (int)(sqlite3Strlen30(zName));
			p = (FuncDef)(sqlite3HashFind(&db.aFunc, zName));
			while ((p) != null)
			{
				int score = (int)(matchQuality(p, (int)(nArg), (byte)(enc)));
				if ((score) > (bestScore))
				{
					pBest = p;
					bestScore = (int)(score);
				}

				p = p.pNext;
			}

			if ((createFlag == 0) && (((pBest) == (null)) || ((db.mDbFlags & 0x0002) != 0)))
			{
				bestScore = (int)(0);
				h = (int)(((sqlite3UpperToLower[(byte)(zName[0])]) + (nName)) % 23);
				p = sqlite3FunctionSearch((int)(h), zName);
				while ((p) != null)
				{
					int score = (int)(matchQuality(p, (int)(nArg), (byte)(enc)));
					if ((score) > (bestScore))
					{
						pBest = p;
						bestScore = (int)(score);
					}

					p = p.pNext;
				}
			}

			if ((((createFlag) != 0) && ((bestScore) < (6))) && ((pBest = sqlite3DbMallocZero(db, (ulong)(sizeof(FuncDef) + nName + 1))) != null))
			{
				FuncDef pOther;
				byte* z;
				pBest.zName = (sbyte*)(pBest[1]);
				pBest.nArg = (sbyte)((ushort)(nArg));
				pBest.funcFlags = (uint)(enc);
				CRuntime.memcpy((sbyte*)(pBest[1]), zName, (ulong)(nName + 1));
				for (z = (byte*)(pBest.zName); *z; z++)
				{
					*z = (byte)(sqlite3UpperToLower[*z]);
				}

				pOther = (FuncDef)(sqlite3HashInsert(&db.aFunc, pBest.zName, pBest));
				if ((pOther) == (pBest))
				{
					sqlite3DbFree(db, pBest);
					sqlite3OomFault(db);
					return null;
				}
				else
				{
					pBest.pNext = pOther;
				}
			}

			if (((pBest) != null) && (((pBest.xSFunc) != null) || ((createFlag) != 0)))
			{
				return pBest;
			}

			return null;
		}
		public static Index sqlite3FindIndex(sqlite3 db, sbyte* zName, sbyte* zDb)
		{
			Index p = null;
			int i = 0;

			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				int j = (int)(((i) < (2)) ? i ^ 1 : i);
				Schema pSchema = db.aDb[j].pSchema;

				if (((zDb) != null) && ((sqlite3DbIsNamed(db, (int)(j), zDb)) == (0)))
					continue;

				p = sqlite3HashFind(&pSchema.idxHash, zName);
				if ((p) != null)
					break;
			}

			return p;
		}
		public static int sqlite3FindInIndex(Parse pParse, Expr pX, uint inFlags, int* prRhsHasNull, int* aiMap, int* piTab)
		{
			Select p;
			int eType = (int)(0);
			int iTab = (int)(pParse.nTab++);
			int mustBeUnique = 0;
			Vdbe v = sqlite3GetVdbe(pParse);

			mustBeUnique = (int)((inFlags & 0x0004) != 0);
			if (((prRhsHasNull) != null) && (((pX).flags & 0x000800) != 0))
			{
				int i = 0;
				ExprList pEList = pX.x.pSelect.pEList;
				for (i = (int)(0); (i) < (pEList.nExpr); i++)
				{
					if ((sqlite3ExprCanBeNull(pEList.a[i].pExpr)) != 0)
						break;
				}

				if ((i) == (pEList.nExpr))
				{
					prRhsHasNull = null;
				}
			}

			if (((pParse.nErr) == (0)) && ((p = isCandidateForInOpt(pX)) != null))
			{
				sqlite3 db = pParse.db;
				Table pTab;
				int iDb = 0;
				ExprList pEList = p.pEList;
				int nExpr = (int)(pEList.nExpr);



				pTab = p.pSrc.a[0].pTab;
				iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));

				sqlite3CodeVerifySchema(pParse, (int)(iDb));
				sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);

				if (((nExpr) == (1)) && ((pEList.a[0].pExpr.iColumn) < (0)))
				{
					int iAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
					sqlite3OpenTable(pParse, (int)(iTab), (int)(iDb), pTab, (int)(101));
					eType = (int)(1);
					sqlite3VdbeExplain(pParse, (byte)(0), "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR", pTab.zName);
					sqlite3VdbeJumpHere(v, (int)(iAddr));
				}
				else
				{
					Index pIdx;
					int affinity_ok = (int)(1);
					int i = 0;
					for (i = (int)(0); ((i) < (nExpr)) && ((affinity_ok) != 0); i++)
					{
						Expr pLhs = sqlite3VectorFieldSubexpr(pX.pLeft, (int)(i));
						int iCol = (int)(pEList.a[i].pExpr.iColumn);
						sbyte idxaff = (sbyte)(sqlite3TableColumnAffinity(pTab, (int)(iCol)));
						sbyte cmpaff = (sbyte)(sqlite3CompareAffinity(pLhs, (sbyte)(idxaff)));
						switch (cmpaff)
						{
							case 0x41:
								break;
							case 0x42:

								break;
							default:
								affinity_ok = (int)((idxaff) >= (0x43) ? 1 : 0);
						}
					}

					if ((affinity_ok) != 0)
					{
						for (pIdx = pTab.pIndex; ((pIdx) != null) && ((eType) == (0)); pIdx = pIdx.pNext)
						{
							ulong colUsed = 0;
							ulong mCol = 0;
							if ((pIdx.nColumn) < (nExpr))
								continue;
							if (pIdx.pPartIdxWhere != null)
								continue;
							if ((pIdx.nColumn) >= (((int)(sizeof(ulong) * 8)) - 1))
								continue;
							if ((mustBeUnique) != 0)
							{
								if (((pIdx.nKeyCol) > (nExpr)) || (((pIdx.nColumn) > (nExpr)) && (!((pIdx).onError != 0))))
								{
									continue;
								}
							}

							colUsed = (ulong)(0);
							for (i = (int)(0); (i) < (nExpr); i++)
							{
								Expr pLhs = sqlite3VectorFieldSubexpr(pX.pLeft, (int)(i));
								Expr pRhs = pEList.a[i].pExpr;
								CollSeq pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
								int j = 0;

								for (j = (int)(0); (j) < (nExpr); j++)
								{
									if (pIdx.aiColumn[j] != pRhs.iColumn)
										continue;

									if ((pReq != null) && (sqlite3StrICmp(pReq.zName, pIdx.azColl[j]) != 0))
									{
										continue;
									}

									break;
								}

								if ((j) == (nExpr))
									break;
								mCol = (ulong)(((ulong)(1)) << (j));
								if ((mCol & colUsed) != 0)
									break;
								colUsed |= (ulong)(mCol);
								if ((aiMap) != null)
									aiMap[i] = (int)(j);
							}


							if ((colUsed) == ((((ulong)(1)) << (nExpr)) - 1))
							{
								int iAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
								sqlite3VdbeExplain(pParse, (byte)(0), "USING INDEX %s FOR IN-OPERATOR", pIdx.zName);
								sqlite3VdbeAddOp3(v, (int)(101), (int)(iTab), (int)(pIdx.tnum), (int)(iDb));
								sqlite3VdbeSetP4KeyInfo(pParse, pIdx);

								eType = (int)(3 + pIdx.aSortOrder[0]);
								if ((prRhsHasNull) != null)
								{
									*prRhsHasNull = (int)(++pParse.nMem);
									if ((nExpr) == (1))
									{
										sqlite3SetHasNullFlag(v, (int)(iTab), (int)(*prRhsHasNull));
									}
								}

								sqlite3VdbeJumpHere(v, (int)(iAddr));
							}
						}
					}
				}
			}

			if (((((eType) == (0)) && ((inFlags & 0x0001) != 0)) && (((pX).flags & 0x000800) == (0))) && ((sqlite3InRhsIsConstant(pX) == 0) || ((pX.x.pList.nExpr) <= (2))))
			{
				eType = (int)(5);
			}

			if ((eType) == (0))
			{
				uint savedNQueryLoop = (uint)(pParse.nQueryLoop);
				int rMayHaveNull = (int)(0);
				eType = (int)(2);
				if ((inFlags & 0x0004) != 0)
				{
					pParse.nQueryLoop = (uint)(0);
				}
				else if ((prRhsHasNull) != null)
				{
					*prRhsHasNull = (int)(rMayHaveNull = (int)(++pParse.nMem));
				}


				sqlite3CodeRhsOfIN(pParse, pX, (int)(iTab));
				if ((rMayHaveNull) != 0)
				{
					sqlite3SetHasNullFlag(v, (int)(iTab), (int)(rMayHaveNull));
				}

				pParse.nQueryLoop = (uint)(savedNQueryLoop);
			}

			if ((((aiMap) != null) && (eType != 3)) && (eType != 4))
			{
				int i = 0;
				int n = 0;
				n = (int)(sqlite3ExprVectorSize(pX.pLeft));
				for (i = (int)(0); (i) < (n); i++)
				{
					aiMap[i] = (int)(i);
				}
			}

			*piTab = (int)(iTab);
			return (int)(eType);
		}
		public static Table sqlite3FindTable(sqlite3 db, sbyte* zName, sbyte* zDatabase)
		{
			Table p = null;
			int i = 0;

			if ((zDatabase) != null)
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((sqlite3StrICmp(zDatabase, db.aDb[i].zDbSName)) == (0))
						break;
				}

				if ((i) >= (db.nDb))
				{
					if ((sqlite3StrICmp(zDatabase, "main")) == (0))
					{
						i = (int)(0);
					}
					else
					{
						return null;
					}
				}

				p = sqlite3HashFind(&db.aDb[i].pSchema.tblHash, zName);
				if (((p) == (null)) && ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0)))
				{
					if ((i) == (1))
					{
						if ((((sqlite3StrICmp(zName + 7, &"sqlite_temp_schema"[7])) == (0)) || ((sqlite3StrICmp(zName + 7, &"sqlite_schema"[7])) == (0))) || ((sqlite3StrICmp(zName + 7, &"sqlite_master"[7])) == (0)))
						{
							p = sqlite3HashFind(&db.aDb[1].pSchema.tblHash, "sqlite_temp_master");
						}
					}
					else
					{
						if ((sqlite3StrICmp(zName + 7, &"sqlite_schema"[7])) == (0))
						{
							p = sqlite3HashFind(&db.aDb[i].pSchema.tblHash, "sqlite_master");
						}
					}
				}
			}
			else
			{
				p = sqlite3HashFind(&db.aDb[1].pSchema.tblHash, zName);
				if ((p) != null)
					return p;
				p = sqlite3HashFind(&db.aDb[0].pSchema.tblHash, zName);
				if ((p) != null)
					return p;
				for (i = (int)(2); (i) < (db.nDb); i++)
				{

					p = sqlite3HashFind(&db.aDb[i].pSchema.tblHash, zName);
					if ((p) != null)
						break;
				}

				if (((p) == (null)) && ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0)))
				{
					if ((sqlite3StrICmp(zName + 7, &"sqlite_schema"[7])) == (0))
					{
						p = sqlite3HashFind(&db.aDb[0].pSchema.tblHash, "sqlite_master");
					}
					else if ((sqlite3StrICmp(zName + 7, &"sqlite_temp_schema"[7])) == (0))
					{
						p = sqlite3HashFind(&db.aDb[1].pSchema.tblHash, "sqlite_temp_master");
					}
				}
			}

			return p;
		}
		public static void sqlite3FinishCoding(Parse pParse)
		{
			sqlite3 db;
			Vdbe v;

			db = pParse.db;

			if ((pParse.nested) != 0)
				return;
			if ((pParse.nErr) != 0)
			{
				if ((db.mallocFailed) != 0)
					pParse.rc = (int)(7);
				return;
			}


			v = pParse.pVdbe;
			if ((v) == (null))
			{
				if ((db.init.busy) != 0)
				{
					pParse.rc = (int)(101);
					return;
				}

				v = sqlite3GetVdbe(pParse);
				if ((v) == (null))
					pParse.rc = (int)(1);
			}


			if ((v) != null)
			{
				if ((pParse.bReturning) != 0)
				{
					Returning pReturning = pParse.u1.pReturning;
					int addrRewind = 0;
					int i = 0;
					int reg = 0;
					if (((pReturning.nRetCol) == (0)))
					{

					}
					else
					{
						sqlite3VdbeAddOp0(v, (int)(82));
						addrRewind = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(pReturning.iRetCur)));
						reg = (int)(pReturning.iRetReg);
						for (i = (int)(0); (i) < (pReturning.nRetCol); i++)
						{
							sqlite3VdbeAddOp3(v, (int)(93), (int)(pReturning.iRetCur), (int)(i), (int)(reg + i));
						}

						sqlite3VdbeAddOp2(v, (int)(83), (int)(reg), (int)(i));
						sqlite3VdbeAddOp2(v, (int)(5), (int)(pReturning.iRetCur), (int)(addrRewind + 1));
						sqlite3VdbeJumpHere(v, (int)(addrRewind));
					}
				}

				sqlite3VdbeAddOp0(v, (int)(70));
				if (((db.mallocFailed) == (0)) && (((pParse.cookieMask) != 0) || ((pParse.pConstExpr) != null)))
				{
					int iDb = 0;
					int i = 0;

					sqlite3VdbeJumpHere(v, (int)(0));
					for (iDb = (int)(0); (iDb) < (db.nDb); iDb++)
					{
						Schema pSchema;
						if ((((pParse.cookieMask) & (((uint)(1)) << (iDb))) != 0) == (0))
							continue;
						sqlite3VdbeUsesBtree(v, (int)(iDb));
						pSchema = db.aDb[iDb].pSchema;
						sqlite3VdbeAddOp4Int(v, (int)(2), (int)(iDb), (int)(((pParse.writeMask) & (((uint)(1)) << (iDb))) != 0), (int)(pSchema.schema_cookie), (int)(pSchema.iGeneration));
						if ((db.init.busy) == (0))
							sqlite3VdbeChangeP5(v, (ushort)(1));
					}

					for (i = (int)(0); (i) < (pParse.nVtabLock); i++)
					{
						sbyte* vtab = (sbyte*)(sqlite3GetVTable(db, pParse.apVtabLock[i]));
						sqlite3VdbeAddOp4(v, (int)(169), (int)(0), (int)(0), (int)(0), vtab, (int)(-12));
					}

					pParse.nVtabLock = (int)(0);
					codeTableLocks(pParse);
					sqlite3AutoincrementBegin(pParse);
					if ((pParse.pConstExpr) != null)
					{
						ExprList pEL = pParse.pConstExpr;
						pParse.okConstFactor = (byte)(0);
						for (i = (int)(0); (i) < (pEL.nExpr); i++)
						{
							int iReg = (int)(pEL.a[i].u.iConstExprReg);
							if ((iReg) > (0))
							{
								sqlite3ExprCode(pParse, pEL.a[i].pExpr, (int)(iReg));
							}
						}
					}

					if ((pParse.bReturning) != 0)
					{
						Returning pRet = pParse.u1.pReturning;
						if (((pRet.nRetCol) == (0)))
						{

						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(116), (int)(pRet.iRetCur), (int)(pRet.nRetCol));
						}
					}

					sqlite3VdbeGoto(v, (int)(1));
				}
			}



			if ((pParse.nErr) == (0))
			{

				sqlite3VdbeMakeReady(v, pParse);
				pParse.rc = (int)(101);
			}
			else
			{
				pParse.rc = (int)(1);
			}
		}
		public static void sqlite3FinishTrigger(Parse pParse, TriggerStep pStepList, Token* pAll)
		{
			Trigger pTrig = pParse.pNewTrigger;
			sbyte* zName;
			sqlite3 db = pParse.db;
			DbFixer sFix = new DbFixer();
			int iDb = 0;
			Token nameToken = new Token();
			pParse.pNewTrigger = null;
			if (((pParse.nErr) != 0) || (pTrig == null))
				goto triggerfinish_cleanup;
			zName = pTrig.zName;
			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTrig.pSchema));
			pTrig.step_list = pStepList;
			while ((pStepList) != null)
			{
				pStepList.pTrig = pTrig;
				pStepList = pStepList.pNext;
			}

			sqlite3TokenInit(&nameToken, pTrig.zName);
			sqlite3FixInit(sFix, pParse, (int)(iDb), "trigger", &nameToken);
			if (((sqlite3FixTriggerStep(sFix, pTrig.step_list)) != 0) || ((sqlite3FixExpr(sFix, pTrig.pWhen)) != 0))
			{
				goto triggerfinish_cleanup;
			}

			if (((pParse.eParseMode) >= (2)))
			{

				pParse.pNewTrigger = pTrig;
				pTrig = null;
			}
			else if (db.init.busy == 0)
			{
				Vdbe v;
				sbyte* z;
				v = sqlite3GetVdbe(pParse);
				if ((v) == (null))
					goto triggerfinish_cleanup;
				sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
				z = sqlite3DbStrNDup(db, pAll->z, (ulong)(pAll->n));
				sqlite3NestedParse(pParse, "INSERT INTO %Q.sqlite_master VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')", db.aDb[iDb].zDbSName, zName, pTrig.table, z);
				sqlite3DbFree(db, z);
				sqlite3ChangeCookie(pParse, (int)(iDb));
				sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName), (ushort)(0));
			}

			if ((db.init.busy) != 0)
			{
				Trigger pLink = pTrig;
				Hash* pHash = &db.aDb[iDb].pSchema.trigHash;


				pTrig = sqlite3HashInsert(pHash, zName, pTrig);
				if ((pTrig) != null)
				{
					sqlite3OomFault(db);
				}
				else if ((pLink.pSchema) == (pLink.pTabSchema))
				{
					Table pTab;
					pTab = sqlite3HashFind(&pLink.pTabSchema.tblHash, pLink.table);

					pLink.pNext = pTab.pTrigger;
					pTab.pTrigger = pLink;
				}
			}

		triggerfinish_cleanup:
			; sqlite3DeleteTrigger(db, pTrig);

			sqlite3DeleteTriggerStep(db, pStepList);
		}
		public static int sqlite3FixExpr(DbFixer pFix, Expr pExpr)
		{
			return (int)(sqlite3WalkExpr(pFix.w, pExpr));
		}
		public static void sqlite3FixInit(DbFixer pFix, Parse pParse, int iDb, sbyte* zType, Token* pName)
		{
			sqlite3 db = pParse.db;

			pFix.pParse = pParse;
			pFix.zDb = db.aDb[iDb].zDbSName;
			pFix.pSchema = db.aDb[iDb].pSchema;
			pFix.zType = zType;
			pFix.pName = pName;
			pFix.bTemp = (byte)((iDb) == (1));
			pFix.w.pParse = pParse;
			pFix.w.xExprCallback = fixExprCb;
			pFix.w.xSelectCallback = fixSelectCb;
			pFix.w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;
			pFix.w.walkerDepth = (int)(0);
			pFix.w.eCode = (ushort)(0);
			pFix.w.u.pFix = pFix;
		}
		public static int sqlite3FixSelect(DbFixer pFix, Select pSelect)
		{
			return (int)(sqlite3WalkSelect(pFix.w, pSelect));
		}
		public static int sqlite3FixSrcList(DbFixer pFix, SrcList pList)
		{
			int res = (int)(0);
			if ((pList) != null)
			{
				Select s = new Select();
				CRuntime.memset(s, (int)(0), (ulong)(sizeof(Select)));
				s.pSrc = pList;
				res = (int)(sqlite3WalkSelect(pFix.w, s));
			}

			return (int)(res);
		}
		public static int sqlite3FixTriggerStep(DbFixer pFix, TriggerStep pStep)
		{
			while ((pStep) != null)
			{
				if (((((sqlite3WalkSelect(pFix.w, pStep.pSelect)) != 0) || ((sqlite3WalkExpr(pFix.w, pStep.pWhere)) != 0)) || ((sqlite3WalkExprList(pFix.w, pStep.pExprList)) != 0)) || ((sqlite3FixSrcList(pFix, pStep.pFrom)) != 0))
				{
					return (int)(1);
				}

				{
					Upsert pUp;
					for (pUp = pStep.pUpsert; pUp; pUp = pUp.pNextUpsert)
					{
						if (((((sqlite3WalkExprList(pFix.w, pUp.pUpsertTarget)) != 0) || ((sqlite3WalkExpr(pFix.w, pUp.pUpsertTargetWhere)) != 0)) || ((sqlite3WalkExprList(pFix.w, pUp.pUpsertSet)) != 0)) || ((sqlite3WalkExpr(pFix.w, pUp.pUpsertWhere)) != 0))
						{
							return (int)(1);
						}
					}
				}

				pStep = pStep.pNext;
			}

			return (int)(0);
		}
		public static void sqlite3FkActions(Parse pParse, Table pTab, ExprList pChanges, int regOld, int* aChange, int bChngRowid)
		{
			if ((pParse.db.flags & 0x00004000) != 0)
			{
				FKey pFKey;
				for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey.pNextTo)
				{
					if (((aChange) == (null)) || ((fkParentIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) != 0))
					{
						Trigger pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
						if ((pAct) != null)
						{
							sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, (int)(regOld), (int)(2), (int)(0));
						}
					}
				}
			}
		}
		public static void sqlite3FkCheck(Parse pParse, Table pTab, int regOld, int regNew, int* aChange, int bChngRowid)
		{
			sqlite3 db = pParse.db;
			FKey pFKey;
			int iDb = 0;
			sbyte* zDb;
			int isIgnoreErrors = (int)(pParse.disableTriggers);

			if ((db.flags & 0x00004000) == (0))
				return;
			if (!(((pTab).eTabType) == (0)))
				return;
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			zDb = db.aDb[iDb].zDbSName;
			for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
			{
				Table pTo;
				Index pIdx = null;
				int* aiFree = null;
				int* aiCol;
				int iCol = 0;
				int i = 0;
				int bIgnore = (int)(0);
				if ((((aChange) != null) && (sqlite3_stricmp(pTab.zName, pFKey.zTo) != 0)) && ((fkChildIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) == (0)))
				{
					continue;
				}

				if ((pParse.disableTriggers) != 0)
				{
					pTo = sqlite3FindTable(db, pFKey.zTo, zDb);
				}
				else
				{
					pTo = sqlite3LocateTable(pParse, (uint)(0), pFKey.zTo, zDb);
				}

				if ((pTo == null) || ((sqlite3FkLocateIndex(pParse, pTo, pFKey, pIdx, &aiFree)) != 0))
				{

					if ((isIgnoreErrors == 0) || ((db.mallocFailed) != 0))
						return;
					if ((pTo) == (null))
					{
						Vdbe v = sqlite3GetVdbe(pParse);
						int iJump = (int)(sqlite3VdbeCurrentAddr(v) + pFKey.nCol + 1);
						for (i = (int)(0); (i) < (pFKey.nCol); i++)
						{
							int iFromCol = 0;
							int iReg = 0;
							iFromCol = (int)(pFKey.aCol[i].iFrom);
							iReg = (int)(sqlite3TableColumnToStorage(pFKey.pFrom, (short)(iFromCol)) + regOld + 1);
							sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(iJump));
						}

						sqlite3VdbeAddOp2(v, (int)(157), (int)(pFKey.isDeferred), (int)(-1));
					}

					continue;
				}


				if ((aiFree) != null)
				{
					aiCol = aiFree;
				}
				else
				{
					iCol = (int)(pFKey.aCol[0].iFrom);
					aiCol = &iCol;
				}

				for (i = (int)(0); (i) < (pFKey.nCol); i++)
				{
					if ((aiCol[i]) == (pTab.iPKey))
					{
						aiCol[i] = (int)(-1);
					}


					if ((db.xAuth) != null)
					{
						int rcauth = 0;
						sbyte* zCol = pTo.aCol[pIdx ? pIdx.aiColumn[i] : pTo.iPKey].zCnName;
						rcauth = (int)(sqlite3AuthReadCol(pParse, pTo.zName, zCol, (int)(iDb)));
						bIgnore = (int)((rcauth) == (2) ? 1 : 0);
					}
				}

				sqlite3TableLock(pParse, (int)(iDb), (uint)(pTo.tnum), (byte)(0), pTo.zName);
				pParse.nTab++;
				if (regOld != 0)
				{
					fkLookupParent(pParse, (int)(iDb), pTo, pIdx, pFKey, aiCol, (int)(regOld), (int)(-1), (int)(bIgnore));
				}

				if ((regNew != 0) && (isSetNullAction(pParse, pFKey) == 0))
				{
					fkLookupParent(pParse, (int)(iDb), pTo, pIdx, pFKey, aiCol, (int)(regNew), (int)(+1), (int)(bIgnore));
				}

				sqlite3DbFree(db, aiFree);
			}

			for (pFKey = sqlite3FkReferences(pTab); pFKey; pFKey = pFKey.pNextTo)
			{
				Index pIdx = null;
				SrcList pSrc;
				int* aiCol = null;
				if (((aChange) != null) && ((fkParentIsModified(pTab, pFKey, aChange, (int)(bChngRowid))) == (0)))
				{
					continue;
				}

				if ((((pFKey.isDeferred == 0) && ((db.flags & 0x00080000) == 0)) && (pParse.pToplevel == null)) && (pParse.isMultiWrite == 0))
				{

					continue;
				}

				if ((sqlite3FkLocateIndex(pParse, pTab, pFKey, pIdx, &aiCol)) != 0)
				{
					if ((isIgnoreErrors == 0) || ((db.mallocFailed) != 0))
						return;
					continue;
				}


				pSrc = sqlite3SrcListAppend(pParse, null, null, null);
				if ((pSrc) != null)
				{
					SrcItem pItem = pSrc.a;
					pItem.pTab = pFKey.pFrom;
					pItem.zName = pFKey.pFrom.zName;
					pItem.pTab.nTabRef++;
					pItem.iCursor = (int)(pParse.nTab++);
					if (regNew != 0)
					{
						fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, (int)(regNew), (int)(-1));
					}

					if (regOld != 0)
					{
						int eAction = (int)(pFKey.aAction[aChange != null]);
						fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, (int)(regOld), (int)(1));
						if (((pFKey.isDeferred == 0) && (eAction != 10)) && (eAction != 8))
						{
							sqlite3MayAbort(pParse);
						}
					}

					pItem.zName = null;
					sqlite3SrcListDelete(db, pSrc);
				}

				sqlite3DbFree(db, aiCol);
			}
		}
		public static void sqlite3FkClearTriggerCache(sqlite3 db, int iDb)
		{
			HashElem* k;
			Hash* pHash = &db.aDb[iDb].pSchema.tblHash;
			for (k = ((pHash)->first); k; k = ((k)->next))
			{
				Table pTab = ((k)->data);
				FKey pFKey;
				if (!(((pTab).eTabType) == (0)))
					continue;
				for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pFKey.pNextFrom)
				{
					fkTriggerDelete(db, pFKey.apTrigger[0]);
					pFKey.apTrigger[0] = null;
					fkTriggerDelete(db, pFKey.apTrigger[1]);
					pFKey.apTrigger[1] = null;
				}
			}
		}
		public static void sqlite3FkDelete(sqlite3 db, Table pTab)
		{
			FKey pFKey;
			FKey pNext;

			for (pFKey = pTab.u.tab.pFKey; pFKey; pFKey = pNext)
			{

				if ((db == null) || ((db.pnBytesFreed) == (null)))
				{
					if ((pFKey.pPrevTo) != null)
					{
						pFKey.pPrevTo.pNextTo = pFKey.pNextTo;
					}
					else
					{
						void* p = (void*)(pFKey.pNextTo);
						sbyte* z = (p ? pFKey.pNextTo.zTo : pFKey.zTo);
						sqlite3HashInsert(&pTab.pSchema.fkeyHash, z, p);
					}

					if ((pFKey.pNextTo) != null)
					{
						pFKey.pNextTo.pPrevTo = pFKey.pPrevTo;
					}
				}


				fkTriggerDelete(db, pFKey.apTrigger[0]);
				fkTriggerDelete(db, pFKey.apTrigger[1]);
				pNext = pFKey.pNextFrom;
				sqlite3DbFree(db, pFKey);
			}
		}
		public static void sqlite3FkDropTable(Parse pParse, SrcList pName, Table pTab)
		{
			sqlite3 db = pParse.db;
			if (((db.flags & 0x00004000) != 0) && (((pTab).eTabType) == (0)))
			{
				int iSkip = (int)(0);
				Vdbe v = sqlite3GetVdbe(pParse);


				if ((sqlite3FkReferences(pTab)) == (null))
				{
					FKey p;
					for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
					{
						if (((p.isDeferred) != 0) || ((db.flags & 0x00080000) != 0))
							break;
					}

					if (p == null)
						return;
					iSkip = (int)(sqlite3VdbeMakeLabel(pParse));
					sqlite3VdbeAddOp2(v, (int)(48), (int)(1), (int)(iSkip));
				}

				pParse.disableTriggers = (byte)(1);
				sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, (int)(0)), null, null, null);
				pParse.disableTriggers = (byte)(0);
				if ((db.flags & 0x00080000) == (0))
				{
					sqlite3VdbeAddOp2(v, (int)(48), (int)(0), (int)(sqlite3VdbeCurrentAddr(v) + 2));
					sqlite3HaltConstraint(pParse, (int)(19 | (3 << 8)), (int)(2), null, (sbyte)(-1), (byte)(4));
				}

				if ((iSkip) != 0)
				{
					sqlite3VdbeResolveLabel(v, (int)(iSkip));
				}
			}
		}
		public static int sqlite3FkLocateIndex(Parse pParse, Table pParent, FKey pFKey, Index ppIdx, int** paiCol)
		{
			Index pIdx = null;
			int* aiCol = null;
			int nCol = (int)(pFKey.nCol);
			sbyte* zKey = pFKey.aCol[0].zCol;



			if ((nCol) == (1))
			{
				if ((pParent.iPKey) >= (0))
				{
					if (zKey == null)
						return (int)(0);
					if (sqlite3StrICmp(pParent.aCol[pParent.iPKey].zCnName, zKey) == 0)
					{
						return (int)(0);
					}
				}
			}
			else if ((paiCol) != null)
			{

				aiCol = (int*)(sqlite3DbMallocRawNN(pParse.db, (ulong)(nCol * sizeof(int))));
				if (aiCol == null)
					return (int)(1);
				*paiCol = aiCol;
			}

			for (pIdx = pParent.pIndex; pIdx; pIdx = pIdx.pNext)
			{
				if ((((pIdx.nKeyCol) == (nCol)) && ((pIdx).onError != 0)) && ((pIdx.pPartIdxWhere) == (null)))
				{
					if ((zKey) == (null))
					{
						if ((((pIdx).idxType) == (2)))
						{
							if ((aiCol) != null)
							{
								int i = 0;
								for (i = (int)(0); (i) < (nCol); i++)
								{
									aiCol[i] = (int)(pFKey.aCol[i].iFrom);
								}
							}

							break;
						}
					}
					else
					{
						int i = 0;
						int j = 0;
						for (i = (int)(0); (i) < (nCol); i++)
						{
							short iCol = (short)(pIdx.aiColumn[i]);
							sbyte* zDfltColl;
							sbyte* zIdxCol;
							if ((iCol) < (0))
								break;
							zDfltColl = sqlite3ColumnColl(&pParent.aCol[iCol]);
							if (zDfltColl == null)
								zDfltColl = sqlite3StrBINARY;
							if ((sqlite3StrICmp(pIdx.azColl[i], zDfltColl)) != 0)
								break;
							zIdxCol = pParent.aCol[iCol].zCnName;
							for (j = (int)(0); (j) < (nCol); j++)
							{
								if ((sqlite3StrICmp(pFKey.aCol[j].zCol, zIdxCol)) == (0))
								{
									if ((aiCol) != null)
										aiCol[i] = (int)(pFKey.aCol[j].iFrom);
									break;
								}
							}

							if ((j) == (nCol))
								break;
						}

						if ((i) == (nCol))
							break;
					}
				}
			}

			if (pIdx == null)
			{
				if (pParse.disableTriggers == 0)
				{
					sqlite3ErrorMsg(pParse, "foreign key mismatch - \"%w\" referencing \"%w\"", pFKey.pFrom.zName, pFKey.zTo);
				}

				sqlite3DbFree(pParse.db, aiCol);
				return (int)(1);
			}

			ppIdx = pIdx;
			return (int)(0);
		}
		public static uint sqlite3FkOldmask(Parse pParse, Table pTab)
		{
			uint mask = (uint)(0);
			if (((pParse.db.flags & 0x00004000) != 0) && (((pTab).eTabType) == (0)))
			{
				FKey p;
				int i = 0;
				for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
				{
					for (i = (int)(0); (i) < (p.nCol); i++)
					{
						mask |= (uint)(((p.aCol[i].iFrom) > (31)) ? 0xffffffff : ((uint)(1) << (p.aCol[i].iFrom)));
					}
				}

				for (p = sqlite3FkReferences(pTab); p; p = p.pNextTo)
				{
					Index pIdx = null;
					sqlite3FkLocateIndex(pParse, pTab, p, pIdx, null);
					if ((pIdx) != null)
					{
						for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
						{

							mask |= (uint)(((pIdx.aiColumn[i]) > (31)) ? 0xffffffff : ((uint)(1) << (pIdx.aiColumn[i])));
						}
					}
				}
			}

			return (uint)(mask);
		}
		public static FKey sqlite3FkReferences(Table pTab)
		{
			return (FKey)(sqlite3HashFind(&pTab.pSchema.fkeyHash, pTab.zName));
		}
		public static int sqlite3FkRequired(Parse pParse, Table pTab, int* aChange, int chngRowid)
		{
			int eRet = (int)(1);
			int bHaveFK = (int)(0);
			if (((pParse.db.flags & 0x00004000) != 0) && (((pTab).eTabType) == (0)))
			{
				if (aChange == null)
				{
					bHaveFK = (int)(((sqlite3FkReferences(pTab)) != null) || ((pTab.u.tab.pFKey) != null) ? 1 : 0);
				}
				else
				{
					FKey p;
					for (p = pTab.u.tab.pFKey; p; p = p.pNextFrom)
					{
						if ((fkChildIsModified(pTab, p, aChange, (int)(chngRowid))) != 0)
						{
							if ((0) == (sqlite3_stricmp(pTab.zName, p.zTo)))
								eRet = (int)(2);
							bHaveFK = (int)(1);
						}
					}

					for (p = sqlite3FkReferences(pTab); p; p = p.pNextTo)
					{
						if ((fkParentIsModified(pTab, p, aChange, (int)(chngRowid))) != 0)
						{
							if (p.aAction[1] != 0)
								return (int)(2);
							bHaveFK = (int)(1);
						}
					}
				}
			}

			return (int)((bHaveFK) != 0 ? eRet : 0);
		}
		public static void sqlite3ForceNotReadOnly(Parse pParse)
		{
			int iReg = (int)(++pParse.nMem);
			Vdbe v = sqlite3GetVdbe(pParse);
			if ((v) != null)
			{
				sqlite3VdbeAddOp3(v, (int)(7), (int)(0), (int)(iReg), (int)(-1));
				sqlite3VdbeUsesBtree(v, (int)(0));
			}
		}
		public static void sqlite3FreeIndex(sqlite3 db, Index p)
		{
			sqlite3DeleteIndexSamples(db, p);
			sqlite3ExprDelete(db, p.pPartIdxWhere);
			sqlite3ExprListDelete(db, p.aColExpr);
			sqlite3DbFree(db, p.zColAff);
			if ((p.isResized) != 0)
				sqlite3DbFree(db, (void*)(p.azColl));
			sqlite3DbFree(db, p);
		}
		public static FuncDef sqlite3FunctionSearch(int h, sbyte* zFunc)
		{
			FuncDef p;
			for (p = sqlite3BuiltinFunctions.a[h]; p; p = p.u.pHash)
			{

				if ((sqlite3StrICmp(p.zName, zFunc)) == (0))
				{
					return p;
				}
			}

			return null;
		}
		public static void sqlite3GenerateColumnNames(Parse pParse, Select pSelect)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			Table pTab;
			SrcList pTabList;
			ExprList pEList;
			sqlite3 db = pParse.db;
			int fullName = 0;
			int srcName = 0;
			if ((pParse.explain) != 0)
			{
				return;
			}

			if ((pParse.colNamesSet) != 0)
				return;
			while ((pSelect.pPrior) != null)
			{
				pSelect = pSelect.pPrior;
			}

			pTabList = pSelect.pSrc;
			pEList = pSelect.pEList;


			pParse.colNamesSet = (byte)(1);
			fullName = (int)((db.flags & 0x00000004) != 0);
			srcName = (int)(((db.flags & 0x00000040) != 0) || ((fullName) != 0) ? 1 : 0);
			sqlite3VdbeSetNumCols(v, (int)(pEList.nExpr));
			for (i = (int)(0); (i) < (pEList.nExpr); i++)
			{
				Expr p = pEList.a[i].pExpr;



				if (((pEList.a[i].zEName) != null) && ((pEList.a[i].eEName) == (0)))
				{
					sbyte* zName = pEList.a[i].zEName;
					sqlite3VdbeSetColName(v, (int)(i), (int)(0), zName, ((Void(Void * ))(-1)));
				}
				else if (((srcName) != 0) && ((p.op) == (167)))
				{
					sbyte* zCol;
					int iCol = (int)(p.iColumn);
					pTab = p.y.pTab;

					if ((iCol) < (0))
						iCol = (int)(pTab.iPKey);

					if ((iCol) < (0))
					{
						zCol = "rowid";
					}
					else
					{
						zCol = pTab.aCol[iCol].zCnName;
					}

					if ((fullName) != 0)
					{
						sbyte* zName = null;
						zName = sqlite3MPrintf(db, "%s.%s", pTab.zName, zCol);
						sqlite3VdbeSetColName(v, (int)(i), (int)(0), zName, ((Void(Void * ))(sqlite3OomFault)));
					}
					else
					{
						sqlite3VdbeSetColName(v, (int)(i), (int)(0), zCol, ((Void(Void * ))(-1)));
					}
				}
				else
				{
					sbyte* z = pEList.a[i].zEName;
					z = (z) == (null) ? sqlite3MPrintf(db, "column%d", (int)(i + 1)) : sqlite3DbStrDup(db, z);
					sqlite3VdbeSetColName(v, (int)(i), (int)(0), z, ((Void(Void * ))(sqlite3OomFault)));
				}
			}

			generateColumnTypes(pParse, pTabList, pEList);
		}
		public static void sqlite3GenerateConstraintChecks(Parse pParse, Table pTab, int* aRegIdx, int iDataCur, int iIdxCur, int regNewData, int regOldData, byte pkChng, byte overrideError, int ignoreDest, int* pbMayReplace, int* aiChng, Upsert pUpsert)
		{
			Vdbe v;
			Index pIdx;
			Index pPk = null;
			sqlite3 db;
			int i = 0;
			int ix = 0;
			int nCol = 0;
			int onError = 0;
			int seenReplace = (int)(0);
			int nPkField = 0;
			Upsert pUpsertClause = null;
			byte isUpdate = 0;
			byte bAffinityDone = (byte)(0);
			int upsertIpkReturn = (int)(0);
			int upsertIpkDelay = (int)(0);
			int ipkTop = (int)(0);
			int ipkBottom = (int)(0);
			int regTrigCnt = 0;
			int addrRecheck = (int)(0);
			int lblRecheckOk = (int)(0);
			Trigger pTrigger;
			int nReplaceTrig = (int)(0);
			IndexIterator sIdxIter = new IndexIterator();
			isUpdate = (byte)(regOldData != 0);
			db = pParse.db;
			v = pParse.pVdbe;


			nCol = (int)(pTab.nCol);
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				pPk = null;
				nPkField = (int)(1);
			}
			else
			{
				pPk = sqlite3PrimaryKeyIndex(pTab);
				nPkField = (int)(pPk.nKeyCol);
			}

			if ((pTab.tabFlags & 0x00000800) != 0)
			{
				int b2ndPass = (int)(0);
				int nSeenReplace = (int)(0);
				int nGenerated = (int)(0);
				while ((1) != 0)
				{
					for (i = (int)(0); (i) < (nCol); i++)
					{
						int iReg = 0;
						Column* pCol = &pTab.aCol[i];
						int isGenerated = 0;
						onError = (int)(pCol->notNull);
						if ((onError) == (0))
							continue;
						if ((i) == (pTab.iPKey))
						{
							continue;
						}

						isGenerated = (int)(pCol->colFlags & 0x0060);
						if (((isGenerated) != 0) && (b2ndPass == 0))
						{
							nGenerated++;
							continue;
						}

						if ((((aiChng) != null) && ((aiChng[i]) < (0))) && (isGenerated == 0))
						{
							continue;
						}

						if (overrideError != 11)
						{
							onError = (int)(overrideError);
						}
						else if ((onError) == (11))
						{
							onError = (int)(2);
						}

						if ((onError) == (5))
						{
							if (((b2ndPass) != 0) || ((pCol->iDflt) == (0)))
							{
								onError = (int)(2);
							}
							else
							{

							}
						}
						else if (((b2ndPass) != 0) && (isGenerated == 0))
						{
							continue;
						}


						iReg = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + regNewData + 1);
						switch (onError)
						{
							case 5:
								{
									int addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(iReg)));

									nSeenReplace++;
									sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), (int)(iReg));
									sqlite3VdbeJumpHere(v, (int)(addr1));
									break;
								}

							case 2:
								sqlite3MayAbort(pParse);
							case 1:
							case 3:
								{
									sbyte* zMsg = sqlite3MPrintf(db, "%s.%s", pTab.zName, pCol->zCnName);
									sqlite3VdbeAddOp3(v, (int)(69), (int)(19 | (5 << 8)), (int)(onError), (int)(iReg));
									sqlite3VdbeAppendP4(v, zMsg, (int)(-7));
									sqlite3VdbeChangeP5(v, (ushort)(1));
									break;
								}

							default:
								{

									sqlite3VdbeAddOp2(v, (int)(50), (int)(iReg), (int)(ignoreDest));
									break;
								}
						}
					}

					if (((nGenerated) == (0)) && ((nSeenReplace) == (0)))
					{
						break;
					}

					if ((b2ndPass) != 0)
						break;
					b2ndPass = (int)(1);
					if (((nSeenReplace) > (0)) && ((pTab.tabFlags & 0x00000060) != 0))
					{
						sqlite3ComputeGeneratedColumns(pParse, (int)(regNewData + 1), pTab);
					}
				}
			}

			if (((pTab.pCheck) != null) && ((db.flags & 0x00000200) == (0)))
			{
				ExprList pCheck = pTab.pCheck;
				pParse.iSelfTab = (int)(-(regNewData + 1));
				onError = (int)(overrideError != 11 ? overrideError : 2);
				for (i = (int)(0); (i) < (pCheck.nExpr); i++)
				{
					int allOk = 0;
					Expr pCopy;
					Expr pExpr = pCheck.a[i].pExpr;
					if (((aiChng) != null) && (sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, (int)(pkChng)) == 0))
					{
						continue;
					}

					if ((bAffinityDone) == (0))
					{
						sqlite3TableAffinity(v, pTab, (int)(regNewData + 1));
						bAffinityDone = (byte)(1);
					}

					allOk = (int)(sqlite3VdbeMakeLabel(pParse));
					pCopy = sqlite3ExprDup(db, pExpr, (int)(0));
					if (db.mallocFailed == 0)
					{
						sqlite3ExprIfTrue(pParse, pCopy, (int)(allOk), (int)(0x10));
					}

					sqlite3ExprDelete(db, pCopy);
					if ((onError) == (4))
					{
						sqlite3VdbeGoto(v, (int)(ignoreDest));
					}
					else
					{
						sbyte* zName = pCheck.a[i].zEName;

						if ((onError) == (5))
							onError = (int)(2);
						sqlite3HaltConstraint(pParse, (int)(19 | (1 << 8)), (int)(onError), zName, (sbyte)(0), (byte)(3));
					}

					sqlite3VdbeResolveLabel(v, (int)(allOk));
				}

				pParse.iSelfTab = (int)(0);
			}

			sIdxIter.eType = (int)(0);
			sIdxIter.i = (int)(0);
			sIdxIter.u.ax.aIdx = null;
			sIdxIter.u.lx.pIdx = pTab.pIndex;
			if ((pUpsert) != null)
			{
				if ((pUpsert.pUpsertTarget) == (null))
				{

					if ((pUpsert.isDoUpdate) == (0))
					{
						overrideError = (byte)(4);
						pUpsert = null;
					}
					else
					{
						overrideError = (byte)(6);
					}
				}
				else if (pTab.pIndex != null)
				{
					int nIdx = 0;
					int jj = 0;
					ulong nByte = 0;
					Upsert pTerm;
					byte* bUsed;
					for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
					{

					}

					sIdxIter.eType = (int)(1);
					sIdxIter.u.ax.nIdx = (int)(nIdx);
					nByte = (ulong)((sizeof(IndexListTerm) + 1) * nIdx + nIdx);
					sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, (ulong)(nByte));
					if ((sIdxIter.u.ax.aIdx) == (null))
						return;
					bUsed = (byte*)(sIdxIter.u.ax.aIdx[nIdx]);
					pUpsert.pToFree = sIdxIter.u.ax.aIdx;
					for (i = (int)(0), pTerm = pUpsert; pTerm; pTerm = pTerm.pNextUpsert)
					{
						if ((pTerm.pUpsertTarget) == (null))
							break;
						if ((pTerm.pUpsertIdx) == (null))
							continue;
						jj = (int)(0);
						pIdx = pTab.pIndex;
						while ((pIdx != null) && (pIdx != pTerm.pUpsertIdx))
						{
							pIdx = pIdx.pNext;
							jj++;
						}

						if ((bUsed[jj]) != 0)
							continue;
						bUsed[jj] = (byte)(1);
						sIdxIter.u.ax.aIdx[i].p = pIdx;
						sIdxIter.u.ax.aIdx[i].ix = (int)(jj);
						i++;
					}

					for (jj = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, jj++)
					{
						if ((bUsed[jj]) != 0)
							continue;
						sIdxIter.u.ax.aIdx[i].p = pIdx;
						sIdxIter.u.ax.aIdx[i].ix = (int)(jj);
						i++;
					}


				}
			}

			if ((db.flags & (0x00002000 | 0x00004000)) == (0))
			{
				pTrigger = null;
				regTrigCnt = (int)(0);
			}
			else
			{
				if ((db.flags & 0x00002000) != 0)
				{
					pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(128), null, null);
					regTrigCnt = (int)((pTrigger != null) || ((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) ? 1 : 0);
				}
				else
				{
					pTrigger = null;
					regTrigCnt = (int)(sqlite3FkRequired(pParse, pTab, null, (int)(0)));
				}

				if ((regTrigCnt) != 0)
				{
					regTrigCnt = (int)(++pParse.nMem);
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regTrigCnt));
					lblRecheckOk = (int)(sqlite3VdbeMakeLabel(pParse));
					addrRecheck = (int)(lblRecheckOk);
				}
			}

			if (((pkChng) != 0) && ((pPk) == (null)))
			{
				int addrRowidOk = (int)(sqlite3VdbeMakeLabel(pParse));
				onError = (int)(pTab.keyConf);
				if (overrideError != 11)
				{
					onError = (int)(overrideError);
				}
				else if ((onError) == (11))
				{
					onError = (int)(2);
				}

				if ((pUpsert) != null)
				{
					pUpsertClause = sqlite3UpsertOfIndex(pUpsert, null);
					if (pUpsertClause != null)
					{
						if ((pUpsertClause.isDoUpdate) == (0))
						{
							onError = (int)(4);
						}
						else
						{
							onError = (int)(6);
						}
					}

					if (pUpsertClause != pUpsert)
					{
						upsertIpkDelay = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
					}
				}

				if (((((onError) == (5)) && (onError != overrideError)) && ((pTab.pIndex) != null)) && (upsertIpkDelay == 0))
				{
					ipkTop = (int)(sqlite3VdbeAddOp0(v, (int)(11)) + 1);
				}

				if ((isUpdate) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(53), (int)(regNewData), (int)(addrRowidOk), (int)(regOldData));
					sqlite3VdbeChangeP5(v, (ushort)(0x90));
				}

				sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(addrRowidOk), (int)(regNewData));
				switch (onError)
				{
					default:
						{
							onError = (int)(2);
						}

					case 1:
					case 2:
					case 3:
						{
							sqlite3RowidConstraint(pParse, (int)(onError), pTab);
							break;
						}

					case 5:
						{
							if ((regTrigCnt) != 0)
							{
								sqlite3MultiWrite(pParse);
								sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(regNewData), (short)(1), (byte)(0), (byte)(5), (byte)(1), (int)(-1));
								sqlite3VdbeAddOp2(v, (int)(85), (int)(regTrigCnt), (int)(1));
								nReplaceTrig++;
							}
							else
							{
								if ((pTab.pIndex) != null)
								{
									sqlite3MultiWrite(pParse);
									sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), null, (int)(-1));
								}
							}

							seenReplace = (int)(1);
							break;
						}

					case 6:
						{
							sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, null, (int)(iDataCur));
						}

					case 4:
						{
							sqlite3VdbeGoto(v, (int)(ignoreDest));
							break;
						}
				}

				sqlite3VdbeResolveLabel(v, (int)(addrRowidOk));
				if (((pUpsert) != null) && (pUpsertClause != pUpsert))
				{
					upsertIpkReturn = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
				}
				else if ((ipkTop) != 0)
				{
					ipkBottom = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
					sqlite3VdbeJumpHere(v, (int)(ipkTop - 1));
				}
			}

			for (pIdx = indexIteratorFirst(&sIdxIter, &ix); pIdx; pIdx = indexIteratorNext(&sIdxIter, &ix))
			{
				int regIdx = 0;
				int regR = 0;
				int iThisCur = 0;
				int addrUniqueOk = 0;
				int addrConflictCk = 0;
				if ((aRegIdx[ix]) == (0))
					continue;
				if ((pUpsert) != null)
				{
					pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);
					if (((upsertIpkDelay) != 0) && ((pUpsertClause) == (pUpsert)))
					{
						sqlite3VdbeJumpHere(v, (int)(upsertIpkDelay));
					}
				}

				addrUniqueOk = (int)(sqlite3VdbeMakeLabel(pParse));
				if ((bAffinityDone) == (0))
				{
					sqlite3TableAffinity(v, pTab, (int)(regNewData + 1));
					bAffinityDone = (byte)(1);
				}

				iThisCur = (int)(iIdxCur + ix);
				if ((pIdx.pPartIdxWhere) != null)
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(aRegIdx[ix]));
					pParse.iSelfTab = (int)(-(regNewData + 1));
					sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, (int)(addrUniqueOk), (int)(0x10));
					pParse.iSelfTab = (int)(0);
				}

				regIdx = (int)(aRegIdx[ix] + 1);
				for (i = (int)(0); (i) < (pIdx.nColumn); i++)
				{
					int iField = (int)(pIdx.aiColumn[i]);
					int x = 0;
					if ((iField) == (-2))
					{
						pParse.iSelfTab = (int)(-(regNewData + 1));
						sqlite3ExprCodeCopy(pParse, pIdx.aColExpr.a[i].pExpr, (int)(regIdx + i));
						pParse.iSelfTab = (int)(0);
					}
					else if (((iField) == (-1)) || ((iField) == (pTab.iPKey)))
					{
						x = (int)(regNewData);
						sqlite3VdbeAddOp2(v, (int)(81), (int)(x), (int)(regIdx + i));
					}
					else
					{
						x = (int)(sqlite3TableColumnToStorage(pTab, (short)(iField)) + regNewData + 1);
						sqlite3VdbeAddOp2(v, (int)(80), (int)(x), (int)(regIdx + i));
					}
				}

				sqlite3VdbeAddOp3(v, (int)(96), (int)(regIdx), (int)(pIdx.nColumn), (int)(aRegIdx[ix]));
				if ((((isUpdate) != 0) && ((pPk) == (pIdx))) && ((pkChng) == (0)))
				{
					sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
					continue;
				}

				onError = (int)(pIdx.onError);
				if ((onError) == (0))
				{
					sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
					continue;
				}

				if (overrideError != 11)
				{
					onError = (int)(overrideError);
				}
				else if ((onError) == (11))
				{
					onError = (int)(2);
				}

				if ((pUpsertClause) != null)
				{
					if ((pUpsertClause.isDoUpdate) == (0))
					{
						onError = (int)(4);
					}
					else
					{
						onError = (int)(6);
					}
				}


				if (((((((ix) == (0)) && ((pIdx.pNext) == (null))) && ((pPk) == (pIdx))) && ((onError) == (5))) && (((0) == (db.flags & 0x00002000)) || ((null) == (sqlite3TriggersExist(pParse, pTab, (int)(128), null, null))))) && (((0) == (db.flags & 0x00004000)) || (((null) == (pTab.u.tab.pFKey)) && ((null) == (sqlite3FkReferences(pTab))))))
				{
					sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
					continue;
				}

				addrConflictCk = (int)(sqlite3VdbeAddOp4Int(v, (int)(29), (int)(iThisCur), (int)(addrUniqueOk), (int)(regIdx), (int)(pIdx.nKeyCol)));
				regR = (int)((pIdx) == (pPk) ? regIdx : sqlite3GetTempRange(pParse, (int)(nPkField)));
				if (((isUpdate) != 0) || ((onError) == (5)))
				{
					if ((((pTab).tabFlags & 0x00000080) == (0)))
					{
						sqlite3VdbeAddOp2(v, (int)(141), (int)(iThisCur), (int)(regR));
						if ((isUpdate) != 0)
						{
							sqlite3VdbeAddOp3(v, (int)(53), (int)(regR), (int)(addrUniqueOk), (int)(regOldData));
							sqlite3VdbeChangeP5(v, (ushort)(0x90));
						}
					}
					else
					{
						int x = 0;
						if (pIdx != pPk)
						{
							for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
							{

								x = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[i])));
								sqlite3VdbeAddOp3(v, (int)(93), (int)(iThisCur), (int)(x), (int)(regR + i));
							}
						}

						if ((isUpdate) != 0)
						{
							int addrJump = (int)(sqlite3VdbeCurrentAddr(v) + pPk.nKeyCol);
							int op = (int)(52);
							int regCmp = (int)((((pIdx).idxType) == (2)) ? regIdx : regR);
							for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
							{
								sbyte* p4 = (sbyte*)(sqlite3LocateCollSeq(pParse, pPk.azColl[i]));
								x = (int)(pPk.aiColumn[i]);

								if ((i) == (pPk.nKeyCol - 1))
								{
									addrJump = (int)(addrUniqueOk);
									op = (int)(53);
								}

								x = (int)(sqlite3TableColumnToStorage(pTab, (short)(x)));
								sqlite3VdbeAddOp4(v, (int)(op), (int)(regOldData + 1 + x), (int)(addrJump), (int)(regCmp + i), p4, (int)(-2));
								sqlite3VdbeChangeP5(v, (ushort)(0x90));
							}
						}
					}
				}


				switch (onError)
				{
					case 1:
					case 2:
					case 3:
						{
							sqlite3UniqueConstraint(pParse, (int)(onError), pIdx);
							break;
						}

					case 6:
						{
							sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, (int)(iIdxCur + ix));
						}

					case 4:
						{
							sqlite3VdbeGoto(v, (int)(ignoreDest));
							break;
						}

					default:
						{
							int nConflictCk = 0;

							nConflictCk = (int)(sqlite3VdbeCurrentAddr(v) - addrConflictCk);

							if ((regTrigCnt) != 0)
							{
								sqlite3MultiWrite(pParse);
								nReplaceTrig++;
							}

							if (((pTrigger) != null) && ((isUpdate) != 0))
							{
								sqlite3VdbeAddOp1(v, (int)(166), (int)(iDataCur));
							}

							sqlite3GenerateRowDelete(pParse, pTab, pTrigger, (int)(iDataCur), (int)(iIdxCur), (int)(regR), (short)(nPkField), (byte)(0), (byte)(5), (byte)((pIdx) == (pPk) ? 1 : 0), (int)(iThisCur));
							if (((pTrigger) != null) && ((isUpdate) != 0))
							{
								sqlite3VdbeAddOp1(v, (int)(167), (int)(iDataCur));
							}

							if ((regTrigCnt) != 0)
							{
								int addrBypass = 0;
								sqlite3VdbeAddOp2(v, (int)(85), (int)(regTrigCnt), (int)(1));
								addrBypass = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
								sqlite3VdbeResolveLabel(v, (int)(lblRecheckOk));
								lblRecheckOk = (int)(sqlite3VdbeMakeLabel(pParse));
								if ((pIdx.pPartIdxWhere) != null)
								{
									sqlite3VdbeAddOp2(v, (int)(50), (int)(regIdx - 1), (int)(lblRecheckOk));
								}

								while ((nConflictCk) > (0))
								{
									VdbeOp x = new VdbeOp();
									x = (VdbeOp)(*sqlite3VdbeGetOp(v, (int)(addrConflictCk)));
									if (x.opcode != 141)
									{
										int p2 = 0;
										sbyte* zP4;
										if ((sqlite3OpcodeProperty[x.opcode] & 0x01) != 0)
										{
											p2 = (int)(lblRecheckOk);
										}
										else
										{
											p2 = (int)(x.p2);
										}

										zP4 = (x.p4type) == (-3) ? ((void*)((long)(x.p4.i))) : x.p4.z;
										sqlite3VdbeAddOp4(v, (int)(x.opcode), (int)(x.p1), (int)(p2), (int)(x.p3), zP4, (int)(x.p4type));
										sqlite3VdbeChangeP5(v, (ushort)(x.p5));
									}

									nConflictCk--;
									addrConflictCk++;
								}

								sqlite3UniqueConstraint(pParse, (int)(2), pIdx);
								sqlite3VdbeJumpHere(v, (int)(addrBypass));
							}

							seenReplace = (int)(1);
							break;
						}
				}

				sqlite3VdbeResolveLabel(v, (int)(addrUniqueOk));
				if (regR != regIdx)
					sqlite3ReleaseTempRange(pParse, (int)(regR), (int)(nPkField));
				if ((((pUpsertClause) != null) && ((upsertIpkReturn) != 0)) && ((sqlite3UpsertNextIsIPK(pUpsertClause)) != 0))
				{
					sqlite3VdbeGoto(v, (int)(upsertIpkDelay + 1));
					sqlite3VdbeJumpHere(v, (int)(upsertIpkReturn));
					upsertIpkReturn = (int)(0);
				}
			}

			if ((ipkTop) != 0)
			{
				sqlite3VdbeGoto(v, (int)(ipkTop));

				sqlite3VdbeJumpHere(v, (int)(ipkBottom));
			}


			if ((nReplaceTrig) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(20), (int)(regTrigCnt), (int)(lblRecheckOk));
				if (pPk == null)
				{
					if ((isUpdate) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(53), (int)(regNewData), (int)(addrRecheck), (int)(regOldData));
						sqlite3VdbeChangeP5(v, (ushort)(0x90));
					}

					sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(addrRecheck), (int)(regNewData));
					sqlite3RowidConstraint(pParse, (int)(2), pTab);
				}
				else
				{
					sqlite3VdbeGoto(v, (int)(addrRecheck));
				}

				sqlite3VdbeResolveLabel(v, (int)(lblRecheckOk));
			}

			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				int regRec = (int)(aRegIdx[ix]);
				sqlite3VdbeAddOp3(v, (int)(96), (int)(regNewData + 1), (int)(pTab.nNVCol), (int)(regRec));
				if (bAffinityDone == 0)
				{
					sqlite3TableAffinity(v, pTab, (int)(0));
				}
			}

			*pbMayReplace = (int)(seenReplace);
		}
		public static int sqlite3GenerateIndexKey(Parse pParse, Index pIdx, int iDataCur, int regOut, int prefixOnly, int* piPartIdxLabel, Index pPrior, int regPrior)
		{
			Vdbe v = pParse.pVdbe;
			int j = 0;
			int regBase = 0;
			int nCol = 0;
			if ((piPartIdxLabel) != null)
			{
				if ((pIdx.pPartIdxWhere) != null)
				{
					*piPartIdxLabel = (int)(sqlite3VdbeMakeLabel(pParse));
					pParse.iSelfTab = (int)(iDataCur + 1);
					sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, (int)(*piPartIdxLabel), (int)(0x10));
					pParse.iSelfTab = (int)(0);
					pPrior = null;
				}
				else
				{
					*piPartIdxLabel = (int)(0);
				}
			}

			nCol = (int)((((prefixOnly) != 0) && ((pIdx.uniqNotNull) != 0)) ? pIdx.nKeyCol : pIdx.nColumn);
			regBase = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
			if (((pPrior) != null) && ((regBase != regPrior) || ((pPrior.pPartIdxWhere) != null)))
				pPrior = null;
			for (j = (int)(0); (j) < (nCol); j++)
			{
				if ((((pPrior) != null) && ((pPrior.aiColumn[j]) == (pIdx.aiColumn[j]))) && (pPrior.aiColumn[j] != (-2)))
				{
					continue;
				}

				sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, (int)(iDataCur), (int)(j), (int)(regBase + j));
				if ((pIdx.aiColumn[j]) >= (0))
				{
					sqlite3VdbeDeletePriorOpcode(v, (byte)(86));
				}
			}

			if ((regOut) != 0)
			{
				sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase), (int)(nCol), (int)(regOut));
			}

			sqlite3ReleaseTempRange(pParse, (int)(regBase), (int)(nCol));
			return (int)(regBase);
		}
		public static void sqlite3GenerateRowDelete(Parse pParse, Table pTab, Trigger pTrigger, int iDataCur, int iIdxCur, int iPk, short nPk, byte count, byte onconf, byte eMode, int iIdxNoSeek)
		{
			Vdbe v = pParse.pVdbe;
			int iOld = (int)(0);
			int iLabel = 0;
			byte opSeek = 0;

			iLabel = (int)(sqlite3VdbeMakeLabel(pParse));
			opSeek = (byte)((((pTab).tabFlags & 0x00000080) == (0)) ? 33 : 30);
			if ((eMode) == (0))
			{
				sqlite3VdbeAddOp4Int(v, (int)(opSeek), (int)(iDataCur), (int)(iLabel), (int)(iPk), (int)(nPk));
			}

			if (((sqlite3FkRequired(pParse, pTab, null, (int)(0))) != 0) || ((pTrigger) != null))
			{
				uint mask = 0;
				int iCol = 0;
				int addrStart = 0;
				mask = (uint)(sqlite3TriggerColmask(pParse, pTrigger, null, (int)(0), (int)(1 | 2), pTab, (int)(onconf)));
				mask |= (uint)(sqlite3FkOldmask(pParse, pTab));
				iOld = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(1 + pTab.nCol);
				sqlite3VdbeAddOp2(v, (int)(79), (int)(iPk), (int)(iOld));
				for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
				{
					if (((mask) == (0xffffffff)) || (((iCol) <= (31)) && ((mask & (((uint)(1)) << (iCol))) != 0)))
					{
						int kk = (int)(sqlite3TableColumnToStorage(pTab, (short)(iCol)));
						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(iCol), (int)(iOld + kk + 1));
					}
				}

				addrStart = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3CodeRowTrigger(pParse, pTrigger, (int)(128), null, (int)(1), pTab, (int)(iOld), (int)(onconf), (int)(iLabel));
				if ((addrStart) < (sqlite3VdbeCurrentAddr(v)))
				{
					sqlite3VdbeAddOp4Int(v, (int)(opSeek), (int)(iDataCur), (int)(iLabel), (int)(iPk), (int)(nPk));
					iIdxNoSeek = (int)(-1);
				}

				sqlite3FkCheck(pParse, pTab, (int)(iOld), (int)(0), null, (int)(0));
			}

			if (!(((pTab).eTabType) == (2)))
			{
				byte p5 = (byte)(0);
				sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), null, (int)(iIdxNoSeek));
				sqlite3VdbeAddOp2(v, (int)(129), (int)(iDataCur), (int)((count) != 0 ? 0x01 : 0));
				if (((pParse.nested) == (0)) || ((0) == (sqlite3_stricmp(pTab.zName, "sqlite_stat1"))))
				{
					sqlite3VdbeAppendP4(v, (sbyte*)(pTab), (int)(-6));
				}

				if (eMode != 0)
				{
					sqlite3VdbeChangeP5(v, (ushort)(0x04));
				}

				if (((iIdxNoSeek) >= (0)) && (iIdxNoSeek != iDataCur))
				{
					sqlite3VdbeAddOp1(v, (int)(129), (int)(iIdxNoSeek));
				}

				if ((eMode) == (2))
					p5 |= (byte)(0x02);
				sqlite3VdbeChangeP5(v, (ushort)(p5));
			}

			sqlite3FkActions(pParse, pTab, null, (int)(iOld), null, (int)(0));
			sqlite3CodeRowTrigger(pParse, pTrigger, (int)(128), null, (int)(2), pTab, (int)(iOld), (int)(onconf), (int)(iLabel));
			sqlite3VdbeResolveLabel(v, (int)(iLabel));
		}
		public static void sqlite3GenerateRowIndexDelete(Parse pParse, Table pTab, int iDataCur, int iIdxCur, int* aRegIdx, int iIdxNoSeek)
		{
			int i = 0;
			int r1 = (int)(-1);
			int iPartIdxLabel = 0;
			Index pIdx;
			Index pPrior = null;
			Vdbe v;
			Index pPk;
			v = pParse.pVdbe;
			pPk = (((pTab).tabFlags & 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
			for (i = (int)(0), pIdx = pTab.pIndex; pIdx; i++, pIdx = pIdx.pNext)
			{

				if ((aRegIdx != null) && ((aRegIdx[i]) == (0)))
					continue;
				if ((pIdx) == (pPk))
					continue;
				if ((iIdxCur + i) == (iIdxNoSeek))
					continue;
				r1 = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(iDataCur), (int)(0), (int)(1), &iPartIdxLabel, pPrior, (int)(r1)));
				sqlite3VdbeAddOp3(v, (int)(139), (int)(iIdxCur + i), (int)(r1), (int)((pIdx.uniqNotNull) != 0 ? pIdx.nKeyCol : pIdx.nColumn));
				sqlite3VdbeChangeP5(v, (ushort)(1));
				sqlite3ResolvePartIdxLabel(pParse, (int)(iPartIdxLabel));
				pPrior = pIdx;
			}
		}
		public static uint sqlite3Get4byte(byte* p)
		{
			uint x = 0;
			CRuntime.memcpy(&x, p, (ulong)(4));
			return (uint)(_byteswap_ulong((uint)(x)));
		}
		public static byte sqlite3GetBoolean(sbyte* z, byte dflt)
		{
			return (byte)(getSafetyLevel(z, (int)(1), (byte)(dflt)) != 0);
		}
		public static CollSeq sqlite3GetCollSeq(Parse pParse, byte enc, CollSeq pColl, sbyte* zName)
		{
			CollSeq p;
			sqlite3 db = pParse.db;
			p = pColl;
			if (p == null)
			{
				p = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(0));
			}

			if ((p == null) || (p.xCmp == null))
			{
				callCollNeeded(db, (int)(enc), zName);
				p = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(0));
			}

			if ((((p) != null) && (p.xCmp == null)) && ((synthCollSeq(db, p)) != 0))
			{
				p = null;
			}


			if ((p) == (null))
			{
				sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
				pParse.rc = (int)(1 | (1 << 8));
			}

			return p;
		}
		public static CollSeq sqlite3GetFuncCollSeq(sqlite3_context context)
		{
			VdbeOp* pOp;

			pOp = &context.pVdbe.aOp[context.iOp - 1];


			return pOp->p4.pColl;
		}
		public static int sqlite3GetInt32(sbyte* zNum, int* pValue)
		{
			long v = (long)(0);
			int i = 0; int c = 0;
			int neg = (int)(0);
			if ((zNum[0]) == (45))
			{
				neg = (int)(1);
				zNum++;
			}
			else if ((zNum[0]) == (43))
			{
				zNum++;
			}
			else if ((((zNum[0]) == (48)) && (((zNum[1]) == (120)) || ((zNum[1]) == (88)))) && ((sqlite3CtypeMap[(byte)(zNum[2])] & 0x08) != 0))
			{
				uint u = (uint)(0);
				zNum += 2;
				while ((zNum[0]) == (48))
				{
					zNum++;
				}

				for (i = (int)(0); ((sqlite3CtypeMap[(byte)(zNum[i])] & 0x08) != 0) && ((i) < (8)); i++)
				{
					u = (uint)(u * 16 + sqlite3HexToInt((int)(zNum[i])));
				}

				if (((u & 0x80000000) == (0)) && ((sqlite3CtypeMap[(byte)(zNum[i])] & 0x08) == (0)))
				{
					CRuntime.memcpy(pValue, &u, (ulong)(4));
					return (int)(1);
				}
				else
				{
					return (int)(0);
				}
			}

			if ((sqlite3CtypeMap[(byte)(zNum[0])] & 0x04) == 0)
				return (int)(0);
			while ((zNum[0]) == (48))
			{
				zNum++;
			}

			for (i = (int)(0); (((i) < (11)) && ((c = (int)(zNum[i] - 48)) >= (0))) && ((c) <= (9)); i++)
			{
				v = (long)(v * 10 + c);
			}

			if ((i) > (10))
			{
				return (int)(0);
			}

			if ((v - neg) > (2147483647))
			{
				return (int)(0);
			}

			if ((neg) != 0)
			{
				v = (long)(-v);
			}

			*pValue = ((int)(v));
			return (int)(1);
		}
		public static int sqlite3GetTempRange(Parse pParse, int nReg)
		{
			int i = 0; int n = 0;
			if ((nReg) == (1))
				return (int)(sqlite3GetTempReg(pParse));
			i = (int)(pParse.iRangeReg);
			n = (int)(pParse.nRangeReg);
			if ((nReg) <= (n))
			{
				pParse.iRangeReg += (int)(nReg);
				pParse.nRangeReg -= (int)(nReg);
			}
			else
			{
				i = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nReg);
			}

			return (int)(i);
		}
		public static int sqlite3GetTempReg(Parse pParse)
		{
			if ((pParse.nTempReg) == (0))
			{
				return (int)(++pParse.nMem);
			}

			return (int)(pParse.aTempReg[--pParse.nTempReg]);
		}
		public static int sqlite3GetToken(byte* z, int* tokenType)
		{
			int i = 0; int c = 0;
			switch (aiClass[*z])
			{
				case 7:
					{
						for (i = (int)(1); (sqlite3CtypeMap[(z[i])] & 0x01); i++)
						{
						}

						*tokenType = (int)(183);
						return (int)(i);
					}

				case 11:
					{
						if ((z[1]) == (45))
						{
							for (i = (int)(2); ((c = (int)(z[i])) != 0) && (c != 10); i++)
							{
							}

							*tokenType = (int)(183);
							return (int)(i);
						}
						else if ((z[1]) == (62))
						{
							*tokenType = (int)(112);
							return (int)(2 + ((z[2]) == (62)));
						}

						*tokenType = (int)(107);
						return (int)(1);
					}

				case 17:
					{
						*tokenType = (int)(22);
						return (int)(1);
					}

				case 18:
					{
						*tokenType = (int)(23);
						return (int)(1);
					}

				case 19:
					{
						*tokenType = (int)(1);
						return (int)(1);
					}

				case 20:
					{
						*tokenType = (int)(106);
						return (int)(1);
					}

				case 21:
					{
						*tokenType = (int)(108);
						return (int)(1);
					}

				case 16:
					{
						if ((z[1] != 42) || ((z[2]) == (0)))
						{
							*tokenType = (int)(109);
							return (int)(1);
						}

						for (i = (int)(3), c = (int)(z[2]); ((c != 42) || (z[i] != 47)) && ((c = (int)(z[i])) != 0); i++)
						{
						}

						if ((c) != 0)
							i++;
						*tokenType = (int)(183);
						return (int)(i);
					}

				case 22:
					{
						*tokenType = (int)(110);
						return (int)(1);
					}

				case 14:
					{
						*tokenType = (int)(53);
						return (int)(1 + ((z[1]) == (61)));
					}

				case 12:
					{
						if ((c = (int)(z[1])) == (61))
						{
							*tokenType = (int)(55);
							return (int)(2);
						}
						else if ((c) == (62))
						{
							*tokenType = (int)(52);
							return (int)(2);
						}
						else if ((c) == (60))
						{
							*tokenType = (int)(104);
							return (int)(2);
						}
						else
						{
							*tokenType = (int)(56);
							return (int)(1);
						}
					}

				case 13:
					{
						if ((c = (int)(z[1])) == (61))
						{
							*tokenType = (int)(57);
							return (int)(2);
						}
						else if ((c) == (62))
						{
							*tokenType = (int)(105);
							return (int)(2);
						}
						else
						{
							*tokenType = (int)(54);
							return (int)(1);
						}
					}

				case 15:
					{
						if (z[1] != 61)
						{
							*tokenType = (int)(184);
							return (int)(1);
						}
						else
						{
							*tokenType = (int)(52);
							return (int)(2);
						}
					}

				case 10:
					{
						if (z[1] != 124)
						{
							*tokenType = (int)(103);
							return (int)(1);
						}
						else
						{
							*tokenType = (int)(111);
							return (int)(2);
						}
					}

				case 23:
					{
						*tokenType = (int)(25);
						return (int)(1);
					}

				case 24:
					{
						*tokenType = (int)(102);
						return (int)(1);
					}

				case 25:
					{
						*tokenType = (int)(114);
						return (int)(1);
					}

				case 8:
					{
						int delim = (int)(z[0]);
						for (i = (int)(1); (c = (int)(z[i])) != 0; i++)
						{
							if ((c) == (delim))
							{
								if ((z[i + 1]) == (delim))
								{
									i++;
								}
								else
								{
									break;
								}
							}
						}

						if ((c) == (39))
						{
							*tokenType = (int)(117);
							return (int)(i + 1);
						}
						else if (c != 0)
						{
							*tokenType = (int)(59);
							return (int)(i + 1);
						}
						else
						{
							*tokenType = (int)(184);
							return (int)(i);
						}
					}

				case 26:
					{
						if ((sqlite3CtypeMap[(z[1])] & 0x04) == 0)
						{
							*tokenType = (int)(141);
							return (int)(1);
						}
					}

				case 3:
					{
						*tokenType = (int)(155);
						if ((((z[0]) == (48)) && (((z[1]) == (120)) || ((z[1]) == (88)))) && ((sqlite3CtypeMap[(z[2])] & 0x08) != 0))
						{
							for (i = (int)(3); (sqlite3CtypeMap[(z[i])] & 0x08); i++)
							{
							}

							return (int)(i);
						}

						for (i = (int)(0); (sqlite3CtypeMap[(z[i])] & 0x04); i++)
						{
						}

						if ((z[i]) == (46))
						{
							i++;
							while ((sqlite3CtypeMap[(z[i])] & 0x04) != 0)
							{
								i++;
							}

							*tokenType = (int)(153);
						}

						if ((((z[i]) == (101)) || ((z[i]) == (69))) && (((sqlite3CtypeMap[(z[i + 1])] & 0x04) != 0) || ((((z[i + 1]) == (43)) || ((z[i + 1]) == (45))) && ((sqlite3CtypeMap[(z[i + 2])] & 0x04) != 0))))
						{
							i += (int)(2);
							while ((sqlite3CtypeMap[(z[i])] & 0x04) != 0)
							{
								i++;
							}

							*tokenType = (int)(153);
						}

						while (((sqlite3CtypeMap[z[i]] & 0x46) != 0))
						{
							*tokenType = (int)(184);
							i++;
						}

						return (int)(i);
					}

				case 9:
					{
						for (i = (int)(1), c = (int)(z[0]); (c != 93) && ((c = (int)(z[i])) != 0); i++)
						{
						}

						*tokenType = (int)((c) == (93) ? 59 : 184);
						return (int)(i);
					}

				case 6:
					{
						*tokenType = (int)(156);
						for (i = (int)(1); (sqlite3CtypeMap[(z[i])] & 0x04); i++)
						{
						}

						return (int)(i);
					}

				case 4:
				case 5:
					{
						int n = (int)(0);
						*tokenType = (int)(156);
						for (i = (int)(1); (c = (int)(z[i])) != 0; i++)
						{
							if (((sqlite3CtypeMap[(byte)(c)] & 0x46) != 0))
							{
								n++;
							}
							else if (((c) == (40)) && ((n) > (0)))
							{
								do
								{
									i++;
								}
								while ((((c = (int)(z[i])) != 0) && ((sqlite3CtypeMap[(byte)(c)] & 0x01) == 0)) && (c != 41));
								if ((c) == (41))
								{
									i++;
								}
								else
								{
									*tokenType = (int)(184);
								}

								break;
							}
							else if (((c) == (58)) && ((z[i + 1]) == (58)))
							{
								i++;
							}
							else
							{
								break;
							}
						}

						if ((n) == (0))
							*tokenType = (int)(184);
						return (int)(i);
					}

				case 1:
					{
						for (i = (int)(1); (aiClass[z[i]]) <= (2); i++)
						{
						}

						if (((sqlite3CtypeMap[z[i]] & 0x46) != 0))
						{
							i++;
							break;
						}

						*tokenType = (int)(59);
						return (int)(keywordCode((sbyte*)(z), (int)(i), tokenType));
					}

				case 0:
					{
						if ((z[1]) == (39))
						{
							*tokenType = (int)(154);
							for (i = (int)(2); (sqlite3CtypeMap[(z[i])] & 0x08); i++)
							{
							}

							if ((z[i] != 39) || (i % 2))
							{
								*tokenType = (int)(184);
								while (((z[i]) != 0) && (z[i] != 39))
								{
									i++;
								}
							}

							if ((z[i]) != 0)
								i++;
							return (int)(i);
						}
					}

				case 2:
				case 27:
					{
						i = (int)(1);
						break;
					}

				case 30:
					{
						if (((z[1]) == (0xbb)) && ((z[2]) == (0xbf)))
						{
							*tokenType = (int)(183);
							return (int)(3);
						}

						i = (int)(1);
						break;
					}

				case 29:
					{
						*tokenType = (int)(184);
						return (int)(0);
					}

				default:
					{
						*tokenType = (int)(184);
						return (int)(1);
					}
			}

			while (((sqlite3CtypeMap[z[i]] & 0x46) != 0))
			{
				i++;
			}

			*tokenType = (int)(59);
			return (int)(i);
		}
		public static int sqlite3GetUInt32(sbyte* z, uint* pI)
		{

			return (int)(1);
		}
		public static byte sqlite3GetVarint(byte* p, ulong* v)
		{
			uint a = 0; uint b = 0; uint s = 0;
			if ((((sbyte*)(p))[0]) >= (0))
			{
				*v = (ulong)(*p);
				return (byte)(1);
			}

			if ((((sbyte*)(p))[1]) >= (0))
			{
				*v = (ulong)(((uint)(p[0] & 0x7f) << 7) | p[1]);
				return (byte)(2);
			}



			a = (uint)(((uint)(p[0])) << 14);
			b = (uint)(p[1]);
			p += 2;
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				a &= (uint)(0x001fc07f);
				b &= (uint)(0x7f);
				b = (uint)(b << 7);
				a |= (uint)(b);
				*v = (ulong)(a);
				return (byte)(3);
			}

			a &= (uint)(0x001fc07f);
			p++;
			b = (uint)(b << 14);
			b |= (uint)(*p);
			if ((b & 0x80) == 0)
			{
				b &= (uint)(0x001fc07f);
				a = (uint)(a << 7);
				a |= (uint)(b);
				*v = (ulong)(a);
				return (byte)(4);
			}

			b &= (uint)(0x001fc07f);
			s = (uint)(a);
			p++;
			a = (uint)(a << 14);
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				b = (uint)(b << 7);
				a |= (uint)(b);
				s = (uint)(s >> 18);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(5);
			}

			s = (uint)(s << 7);
			s |= (uint)(b);
			p++;
			b = (uint)(b << 14);
			b |= (uint)(*p);
			if ((b & 0x80) == 0)
			{
				a &= (uint)(0x001fc07f);
				a = (uint)(a << 7);
				a |= (uint)(b);
				s = (uint)(s >> 18);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(6);
			}

			p++;
			a = (uint)(a << 14);
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				a &= (uint)(0xf01fc07f);
				b &= (uint)(0x001fc07f);
				b = (uint)(b << 7);
				a |= (uint)(b);
				s = (uint)(s >> 11);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(7);
			}

			a &= (uint)(0x001fc07f);
			p++;
			b = (uint)(b << 14);
			b |= (uint)(*p);
			if ((b & 0x80) == 0)
			{
				b &= (uint)(0xf01fc07f);
				a = (uint)(a << 7);
				a |= (uint)(b);
				s = (uint)(s >> 4);
				*v = (ulong)(((ulong)(s)) << 32 | a);
				return (byte)(8);
			}

			p++;
			a = (uint)(a << 15);
			a |= (uint)(*p);
			b &= (uint)(0x001fc07f);
			b = (uint)(b << 8);
			a |= (uint)(b);
			s = (uint)(s << 4);
			b = (uint)(p[-4]);
			b &= (uint)(0x7f);
			b = (uint)(b >> 3);
			s |= (uint)(b);
			*v = (ulong)(((ulong)(s)) << 32 | a);
			return (byte)(9);
		}
		public static byte sqlite3GetVarint32(byte* p, uint* v)
		{
			uint a = 0; uint b = 0;
			a = (uint)(*p);
			p++;
			b = (uint)(*p);
			if ((b & 0x80) == 0)
			{
				a &= (uint)(0x7f);
				a = (uint)(a << 7);
				*v = (uint)(a | b);
				return (byte)(2);
			}

			p++;
			a = (uint)(a << 14);
			a |= (uint)(*p);
			if ((a & 0x80) == 0)
			{
				a &= (uint)((0x7f << 14) | (0x7f));
				b &= (uint)(0x7f);
				b = (uint)(b << 7);
				*v = (uint)(a | b);
				return (byte)(3);
			}

			{
				ulong v64 = 0;
				byte n = 0;
				n = (byte)(sqlite3GetVarint(p - 2, &v64));

				if ((v64 & ((((ulong)(1)) << 32) - 1)) != v64)
				{
					*v = (uint)(0xffffffff);
				}
				else
				{
					*v = ((uint)(v64));
				}

				return (byte)(n);
			}
		}
		public static Vdbe sqlite3GetVdbe(Parse pParse)
		{
			if ((pParse.pVdbe) != null)
			{
				return pParse.pVdbe;
			}

			if (((pParse.pToplevel) == (null)) && (((pParse.db).dbOptFlags & (0x00000008)) == (0)))
			{
				pParse.okConstFactor = (byte)(1);
			}

			return sqlite3VdbeCreate(pParse);
		}
		public static VTable sqlite3GetVTable(sqlite3 db, Table pTab)
		{
			VTable pVtab;

			for (pVtab = pTab.u.vtab.p; ((pVtab) != null) && (pVtab.db != db); pVtab = pVtab.pNext)
			{
			}

			return pVtab;
		}
		public static void sqlite3HaltConstraint(Parse pParse, int errCode, int onError, sbyte* p4, sbyte p4type, byte p5Errmsg)
		{
			Vdbe v;

			v = sqlite3GetVdbe(pParse);

			if ((onError) == (2))
			{
				sqlite3MayAbort(pParse);
			}

			sqlite3VdbeAddOp4(v, (int)(70), (int)(errCode), (int)(onError), (int)(0), p4, (int)(p4type));
			sqlite3VdbeChangeP5(v, (ushort)(p5Errmsg));
		}
		public static int sqlite3HasExplicitNulls(Parse pParse, ExprList pList)
		{
			if ((pList) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pList.nExpr); i++)
				{
					if ((pList.a[i].bNulls) != 0)
					{
						byte sf = (byte)(pList.a[i].sortFlags);
						sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s", (((sf) == (0)) || ((sf) == (3))) ? "FIRST" : "LAST");
						return (int)(1);
					}
				}
			}

			return (int)(0);
		}
		public static void sqlite3HashClear(Hash* pH)
		{
			HashElem* elem;

			elem = pH->first;
			pH->first = null;
			sqlite3_free(pH->ht);
			pH->ht = null;
			pH->htsize = (uint)(0);
			while ((elem) != null)
			{
				HashElem* next_elem = elem->next;
				sqlite3_free(elem);
				elem = next_elem;
			}

			pH->count = (uint)(0);
		}
		public static void* sqlite3HashFind(Hash* pH, sbyte* pKey)
		{


			return findElementWithHash(pH, pKey, null)->data;
		}
		public static void sqlite3HashInit(Hash* pNew)
		{

			pNew->first = null;
			pNew->count = (uint)(0);
			pNew->htsize = (uint)(0);
			pNew->ht = null;
		}
		public static void* sqlite3HashInsert(Hash* pH, sbyte* pKey, void* data)
		{
			uint h = 0;
			HashElem* elem;
			HashElem* new_elem;


			elem = findElementWithHash(pH, pKey, &h);
			if ((elem->data) != null)
			{
				void* old_data = elem->data;
				if ((data) == (null))
				{
					removeElementGivenHash(pH, elem, (uint)(h));
				}
				else
				{
					elem->data = data;
					elem->pKey = pKey;
				}

				return old_data;
			}

			if ((data) == (null))
				return null;
			new_elem = (HashElem*)(sqlite3Malloc((ulong)(sizeof(HashElem))));
			if ((new_elem) == (null))
				return data;
			new_elem->pKey = pKey;
			new_elem->data = data;
			pH->count++;
			if (((pH->count) >= (10)) && ((pH->count) > (2 * pH->htsize)))
			{
				if ((rehash(pH, (uint)(pH->count * 2))) != 0)
				{

					h = (uint)(strHash(pKey) % pH->htsize);
				}
			}

			insertElement(pH, pH->ht ? &pH->ht[h] : null, new_elem);
			return null;
		}
		public static int sqlite3HeaderSizeBtree()
		{
			return (int)(((sizeof(MemPage)) + 7) & ~7);
		}
		public static int sqlite3HeaderSizePcache()
		{
			return (int)(((sizeof(PgHdr)) + 7) & ~7);
		}
		public static int sqlite3HeaderSizePcache1()
		{
			return (int)(((sizeof(PgHdr1)) + 7) & ~7);
		}
		public static int sqlite3HeapNearlyFull()
		{
			return (int)(0);
		}
		public static void* sqlite3HexToBlob(sqlite3 db, sbyte* z, int n)
		{
			sbyte* zBlob;
			int i = 0;
			zBlob = (sbyte*)(sqlite3DbMallocRawNN(db, (ulong)(n / 2 + 1)));
			n--;
			if ((zBlob) != null)
			{
				for (i = (int)(0); (i) < (n); i += (int)(2))
				{
					zBlob[i / 2] = (sbyte)((sqlite3HexToInt((int)(z[i])) << 4) | sqlite3HexToInt((int)(z[i + 1])));
				}

				zBlob[i / 2] = (sbyte)(0);
			}

			return zBlob;
		}
		public static byte sqlite3HexToInt(int h)
		{

			h += (int)(9 * (1 & (h >> 6)));
			return (byte)(h & 0xf);
		}
		public static IdList* sqlite3IdListAppend(Parse pParse, IdList* pList, Token* pToken)
		{
			sqlite3 db = pParse.db;
			int i = 0;
			if ((pList) == (null))
			{
				pList = sqlite3DbMallocZero(db, (ulong)(sizeof(IdList)));
				if ((pList) == (null))
					return null;
			}

			pList->a = sqlite3ArrayAllocate(db, pList->a, (int)(sizeof(IdList_item)), &pList->nId, &i);
			if ((i) < (0))
			{
				sqlite3IdListDelete(db, pList);
				return null;
			}

			pList->a[i].zName = sqlite3NameFromToken(db, pToken);
			if (((pParse.eParseMode) >= (2)) && ((pList->a[i].zName) != null))
			{
				sqlite3RenameTokenMap(pParse, (void*)(pList->a[i].zName), pToken);
			}

			return pList;
		}
		public static void sqlite3IdListDelete(sqlite3 db, IdList* pList)
		{
			int i = 0;
			if ((pList) == (null))
				return;
			for (i = (int)(0); (i) < (pList->nId); i++)
			{
				sqlite3DbFree(db, pList->a[i].zName);
			}

			sqlite3DbFree(db, pList->a);
			sqlite3DbFreeNN(db, pList);
		}
		public static IdList* sqlite3IdListDup(sqlite3 db, IdList* p)
		{
			IdList* pNew;
			int i = 0;

			if ((p) == (null))
				return null;
			pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(IdList)));
			if ((pNew) == (null))
				return null;
			pNew->nId = (int)(p->nId);
			pNew->a = sqlite3DbMallocRawNN(db, (ulong)(p->nId * sizeof(IdList_item)));
			if ((pNew->a) == (null))
			{
				sqlite3DbFreeNN(db, pNew);
				return null;
			}

			for (i = (int)(0); (i) < (p->nId); i++)
			{
				IdList_item* pNewItem = &pNew->a[i];
				IdList_item* pOldItem = &p->a[i];
				pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
				pNewItem->idx = (int)(pOldItem->idx);
			}

			return pNew;
		}
		public static int sqlite3IdListIndex(IdList* pList, sbyte* zName)
		{
			int i = 0;
			if ((pList) == (null))
				return (int)(-1);
			for (i = (int)(0); (i) < (pList->nId); i++)
			{
				if ((sqlite3StrICmp(pList->a[i].zName, zName)) == (0))
					return (int)(i);
			}

			return (int)(-1);
		}
		public static int sqlite3IndexAffinityOk(Expr pExpr, sbyte idx_affinity)
		{
			sbyte aff = (sbyte)(comparisonAffinity(pExpr));
			if ((aff) < (0x42))
			{
				return (int)(1);
			}

			if ((aff) == (0x42))
			{
				return ((idx_affinity) == (0x42) ? 1 : 0);
			}

			return (((idx_affinity) >= (0x43)) ? 1 : 0);
		}
		public static sbyte* sqlite3IndexAffinityStr(sqlite3 db, Index pIdx)
		{
			if (pIdx.zColAff == null)
			{
				int n = 0;
				Table pTab = pIdx.pTable;
				pIdx.zColAff = (sbyte*)(sqlite3DbMallocRaw(null, (ulong)(pIdx.nColumn + 1)));
				if (pIdx.zColAff == null)
				{
					sqlite3OomFault(db);
					return null;
				}

				for (n = (int)(0); (n) < (pIdx.nColumn); n++)
				{
					short x = (short)(pIdx.aiColumn[n]);
					sbyte aff = 0;
					if ((x) >= (0))
					{
						aff = (sbyte)(pTab.aCol[x].affinity);
					}
					else if ((x) == (-1))
					{
						aff = (sbyte)(0x44);
					}
					else
					{


						aff = (sbyte)(sqlite3ExprAffinity(pIdx.aColExpr.a[n].pExpr));
					}

					if ((aff) < (0x41))
						aff = (sbyte)(0x41);
					if ((aff) > (0x43))
						aff = (sbyte)(0x43);
					pIdx.zColAff[n] = (sbyte)(aff);
				}

				pIdx.zColAff[n] = (sbyte)(0);
			}

			return pIdx.zColAff;
		}
		public static int sqlite3IndexedByLookup(Parse pParse, SrcItem pFrom)
		{
			Table pTab = pFrom.pTab;
			sbyte* zIndexedBy = pFrom.u1.zIndexedBy;
			Index pIdx;


			for (pIdx = pTab.pIndex; ((pIdx) != null) && ((sqlite3StrICmp(pIdx.zName, zIndexedBy)) != 0); pIdx = pIdx.pNext)
			{
			}

			if (pIdx == null)
			{
				sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, (int)(0));
				pParse.checkSchema = (byte)(1);
				return (int)(1);
			}


			pFrom.u2.pIBIndex = pIdx;
			return (int)(0);
		}
		public static int sqlite3IndexHasDuplicateRootPage(Index pIndex)
		{
			Index p;
			for (p = pIndex.pTable.pIndex; p; p = p.pNext)
			{
				if (((p.tnum) == (pIndex.tnum)) && (p != pIndex))
					return (int)(1);
			}

			return (int)(0);
		}
		public static int sqlite3Init(sqlite3 db, sbyte** pzErrMsg)
		{
			int i = 0; int rc = 0;
			int commit_internal = (int)(!(db.mDbFlags & 0x0001));



			((db).enc) = (byte)((db).aDb[0].pSchema.enc);

			if (!(((db).aDb[0].pSchema.schemaFlags & (0x0001)) == (0x0001)))
			{
				rc = (int)(sqlite3InitOne(db, (int)(0), pzErrMsg, (uint)(0)));
				if ((rc) != 0)
					return (int)(rc);
			}

			for (i = (int)(db.nDb - 1); (i) > (0); i--)
			{

				if (!(((db).aDb[i].pSchema.schemaFlags & (0x0001)) == (0x0001)))
				{
					rc = (int)(sqlite3InitOne(db, (int)(i), pzErrMsg, (uint)(0)));
					if ((rc) != 0)
						return (int)(rc);
				}
			}

			if ((commit_internal) != 0)
			{
				sqlite3CommitInternalChanges(db);
			}

			return (int)(0);
		}
		public static int sqlite3InitCallback(void* pInit, int argc, sbyte** argv, sbyte** NotUsed)
		{
			InitData pData = (InitData)(pInit);
			sqlite3 db = pData.db;
			int iDb = (int)(pData.iDb);

			(void)(NotUsed) ,  (void)(argc);

			db.mDbFlags |= (uint)(0x0040);
			if ((argv) == (null))
				return (int)(0);
			pData.nInitRow++;
			if ((db.mallocFailed) != 0)
			{
				corruptSchema(pData, argv, null);
				return (int)(1);
			}


			if ((argv[3]) == (null))
			{
				corruptSchema(pData, argv, null);
			}
			else if ((((argv[4]) != null) && ((99) == (sqlite3UpperToLower[(byte)(argv[4][0])]))) && ((114) == (sqlite3UpperToLower[(byte)(argv[4][1])])))
			{
				int rc = 0;
				byte saved_iDb = (byte)(db.init.iDb);
				sqlite3_stmt* pStmt;

				db.init.iDb = (byte)(iDb);
				if (((sqlite3GetUInt32(argv[3], &db.init.newTnum)) == (0)) || (((db.init.newTnum) > (pData.mxPage)) && ((pData.mxPage) > (0))))
				{
					if ((sqlite3Config.bExtraSchemaChecks) != 0)
					{
						corruptSchema(pData, argv, "invalid rootpage");
					}
				}

				db.init.orphanTrigger = (uint)(0);
				db.init.azInit = argv;
				pStmt = null;
				sqlite3Prepare(db, argv[4], (int)(-1), (uint)(0), null, &pStmt, null);
				rc = (int)(db.errCode);

				db.init.iDb = (byte)(saved_iDb);
				if (0 != rc)
				{
					if ((db.init.orphanTrigger) != 0)
					{

					}
					else
					{
						if ((rc) > (pData.rc))
							pData.rc = (int)(rc);
						if ((rc) == (7))
						{
							sqlite3OomFault(db);
						}
						else if ((rc != 9) && ((rc & 0xFF) != 6))
						{
							corruptSchema(pData, argv, sqlite3_errmsg(db));
						}
					}
				}

				db.init.azInit = sqlite3StdType;
				sqlite3_finalize(pStmt);
			}
			else if (((argv[1]) == (null)) || ((argv[4] != null) && (argv[4][0] != 0)))
			{
				corruptSchema(pData, argv, null);
			}
			else
			{
				Index pIndex;
				pIndex = sqlite3FindIndex(db, argv[1], db.aDb[iDb].zDbSName);
				if ((pIndex) == (null))
				{
					corruptSchema(pData, argv, "orphan index");
				}
				else if (((((sqlite3GetUInt32(argv[3], &pIndex.tnum)) == (0)) || ((pIndex.tnum) < (2))) || ((pIndex.tnum) > (pData.mxPage))) || ((sqlite3IndexHasDuplicateRootPage(pIndex)) != 0))
				{
					if ((sqlite3Config.bExtraSchemaChecks) != 0)
					{
						corruptSchema(pData, argv, "invalid rootpage");
					}
				}
			}

			return (int)(0);
		}
		public static int sqlite3InitOne(sqlite3 db, int iDb, sbyte** pzErrMsg, uint mFlags)
		{
			int rc = 0;
			int i = 0;
			int size = 0;
			Db pDb;
			sbyte** azArg = stackalloc sbyte[6];
			int* meta = stackalloc int[5];
			InitData initData = new InitData();
			sbyte* zSchemaTabName;
			int openedTransaction = (int)(0);
			int mask = (int)((db.mDbFlags & 0x0040) | ~0x0040);





			db.init.busy = (byte)(1);
			azArg[0] = "table";
			azArg[1] = zSchemaTabName = (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master");
			azArg[2] = azArg[1];
			azArg[3] = "1";
			azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)";
			azArg[5] = null;
			initData.db = db;
			initData.iDb = (int)(iDb);
			initData.rc = (int)(0);
			initData.pzErrMsg = pzErrMsg;
			initData.mInitFlags = (uint)(mFlags);
			initData.nInitRow = (uint)(0);
			initData.mxPage = (uint)(0);
			sqlite3InitCallback(initData, (int)(5), azArg, null);
			db.mDbFlags &= (uint)(mask);
			if ((initData.rc) != 0)
			{
				rc = (int)(initData.rc);
				goto error_out;
			}

			pDb = db.aDb[iDb];
			if ((pDb.pBt) == (null))
			{

				(db).aDb[1].pSchema.schemaFlags |= (ushort)(0x0001);
				rc = (int)(0);
				goto error_out;
			}

			sqlite3BtreeEnter(pDb.pBt);
			if ((sqlite3BtreeTxnState(pDb.pBt)) == (0))
			{
				rc = (int)(sqlite3BtreeBeginTrans(pDb.pBt, (int)(0), null));
				if (rc != 0)
				{
					sqlite3SetString(pzErrMsg, db, sqlite3ErrStr((int)(rc)));
					goto initone_error_out;
				}

				openedTransaction = (int)(1);
			}

			for (i = (int)(0); (i) < ((int)(5 * sizeof(int) / sizeof(int))); i++)
			{
				sqlite3BtreeGetMeta(pDb.pBt, (int)(i + 1), (uint*)(&meta[i]));
			}

			if ((db.flags & 0x02000000) != 0)
			{
				CRuntime.memset(meta, (int)(0), (ulong)(5 * sizeof(int)));
			}

			pDb.pSchema.schema_cookie = (int)(meta[1 - 1]);
			if ((meta[5 - 1]) != 0)
			{
				if (((iDb) == (0)) && ((db.mDbFlags & 0x0040) == (0)))
				{
					byte encoding = 0;
					encoding = (byte)((byte)(meta[5 - 1]) & 3);
					if ((encoding) == (0))
						encoding = (byte)(1);
					sqlite3SetTextEncoding(db, (byte)(encoding));
				}
				else
				{
					if ((meta[5 - 1] & 3) != ((db).enc))
					{
						sqlite3SetString(pzErrMsg, db, "attached databases must use the same text encoding as main database");
						rc = (int)(1);
						goto initone_error_out;
					}
				}
			}

			pDb.pSchema.enc = (byte)((db).enc);
			if ((pDb.pSchema.cache_size) == (0))
			{
				size = (int)(sqlite3AbsInt32((int)(meta[3 - 1])));
				if ((size) == (0))
				{
					size = (int)(-2000);
				}

				pDb.pSchema.cache_size = (int)(size);
				sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
			}

			pDb.pSchema.file_format = ((byte)(meta[2 - 1]));
			if ((pDb.pSchema.file_format) == (0))
			{
				pDb.pSchema.file_format = (byte)(1);
			}

			if ((pDb.pSchema.file_format) > (4))
			{
				sqlite3SetString(pzErrMsg, db, "unsupported file format");
				rc = (int)(1);
				goto initone_error_out;
			}

			if (((iDb) == (0)) && ((meta[2 - 1]) >= (4)))
			{
				db.flags &= (ulong)(~(ulong)(0x00000002));
			}


			initData.mxPage = (uint)(sqlite3BtreeLastPage(pDb.pBt));
			{
				sbyte* zSql;
				zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\".%s ORDER BY rowid", db.aDb[iDb].zDbSName, zSchemaTabName);
				{
					delegate66 xAuth;
					xAuth = db.xAuth;
					db.xAuth = null;
					rc = (int)(sqlite3_exec(db, zSql, sqlite3InitCallback, initData, null));
					db.xAuth = xAuth;
				}

				if ((rc) == (0))
					rc = (int)(initData.rc);
				sqlite3DbFree(db, zSql);
				if ((rc) == (0))
				{
					sqlite3AnalysisLoad(db, (int)(iDb));
				}
			}


			if ((db.mallocFailed) != 0)
			{
				rc = (int)(7);
				sqlite3ResetAllSchemasOfConnection(db);
				pDb = db.aDb[iDb];
			}
			else if (((rc) == (0)) || (((db.flags & 0x08000000) != 0) && (rc != 7)))
			{
				(db).aDb[iDb].pSchema.schemaFlags |= (ushort)(0x0001);
				rc = (int)(0);
			}

		initone_error_out:
			; if ((openedTransaction) != 0) { sqlite3BtreeCommit(pDb.pBt); }
			sqlite3BtreeLeave(pDb.pBt);
		error_out:
			; if ((rc) != 0) { if (((rc) == (7)) || ((rc) == (10 | (12 << 8)))) { sqlite3OomFault(db); } sqlite3ResetOneSchema(db, (int)(iDb)); }
			db.init.busy = (byte)(0);
			return (int)(rc);
		}
		public static int sqlite3InRhsIsConstant(Expr pIn)
		{
			Expr pLHS;
			int res = 0;

			pLHS = pIn.pLeft;
			pIn.pLeft = null;
			res = (int)(sqlite3ExprIsConstant(pIn));
			pIn.pLeft = pLHS;
			return (int)(res);
		}
		public static void sqlite3Insert(Parse pParse, SrcList pTabList, Select pSelect, IdList* pColumn, int onError, Upsert pUpsert)
		{
			sqlite3 db;
			Table pTab;
			int i = 0; int j = 0;
			Vdbe v;
			Index pIdx;
			int nColumn = 0;
			int nHidden = (int)(0);
			int iDataCur = (int)(0);
			int iIdxCur = (int)(0);
			int ipkColumn = (int)(-1);
			int endOfLoop = 0;
			int srcTab = (int)(0);
			int addrInsTop = (int)(0);
			int addrCont = (int)(0);
			SelectDest dest = new SelectDest();
			int iDb = 0;
			byte useTempTable = (byte)(0);
			byte appendFlag = (byte)(0);
			byte withoutRowid = 0;
			byte bIdListInOrder = 0;
			ExprList pList = null;
			int iRegStore = 0;
			int regFromSelect = (int)(0);
			int regAutoinc = (int)(0);
			int regRowCount = (int)(0);
			int regIns = 0;
			int regRowid = 0;
			int regData = 0;
			int* aRegIdx = null;
			int isView = 0;
			Trigger pTrigger;
			int tmask = 0;
			db = pParse.db;

			if ((pParse.nErr) != 0)
			{
				goto insert_cleanup;
			}


			dest.iSDParm = (int)(0);
			if ((((pSelect) != null) && ((pSelect.selFlags & 0x0000200) != 0)) && ((pSelect.pPrior) == (null)))
			{
				pList = pSelect.pEList;
				pSelect.pEList = null;
				sqlite3SelectDelete(db, pSelect);
				pSelect = null;
			}


			pTab = sqlite3SrcListLookup(pParse, pTabList);
			if ((pTab) == (null))
			{
				goto insert_cleanup;
			}

			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));

			if ((sqlite3AuthCheck(pParse, (int)(18), pTab.zName, null, db.aDb[iDb].zDbSName)) != 0)
			{
				goto insert_cleanup;
			}

			withoutRowid = (byte)(!(((pTab).tabFlags & 0x00000080) == (0)));
			pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(127), null, &tmask);
			isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);

			if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
			{
				goto insert_cleanup;
			}

			if ((sqlite3IsReadOnly(pParse, pTab, (int)(tmask))) != 0)
			{
				goto insert_cleanup;
			}

			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
				goto insert_cleanup;
			if ((pParse.nested) == (0))
				sqlite3VdbeCountChanges(v);
			sqlite3BeginWriteOperation(pParse, (((pSelect) != null) || ((pTrigger) != null) ? 1 : 0), (int)(iDb));
			if (((((pColumn) == (null)) && (pSelect != null)) && ((pTrigger) == (null))) && ((xferOptimization(pParse, pTab, pSelect, (int)(onError), (int)(iDb))) != 0))
			{


				goto insert_end;
			}

			regAutoinc = (int)(autoIncBegin(pParse, (int)(iDb), pTab));
			regRowid = (int)(regIns = (int)(pParse.nMem + 1));
			pParse.nMem += (int)(pTab.nCol + 1);
			if ((((pTab).eTabType) == (1)))
			{
				regRowid++;
				pParse.nMem++;
			}

			regData = (int)(regRowid + 1);
			bIdListInOrder = (byte)((pTab.tabFlags & (0x00000400 | 0x00000040)) == (0));
			if ((pColumn) != null)
			{
				for (i = (int)(0); (i) < (pColumn->nId); i++)
				{
					pColumn->a[i].idx = (int)(-1);
				}

				for (i = (int)(0); (i) < (pColumn->nId); i++)
				{
					for (j = (int)(0); (j) < (pTab.nCol); j++)
					{
						if ((sqlite3StrICmp(pColumn->a[i].zName, pTab.aCol[j].zCnName)) == (0))
						{
							pColumn->a[i].idx = (int)(j);
							if (i != j)
								bIdListInOrder = (byte)(0);
							if ((j) == (pTab.iPKey))
							{
								ipkColumn = (int)(i);

							}

							if ((pTab.aCol[j].colFlags & (0x0040 | 0x0020)) != 0)
							{
								sqlite3ErrorMsg(pParse, "cannot INSERT into generated column \"%s\"", pTab.aCol[j].zCnName);
								goto insert_cleanup;
							}

							break;
						}
					}

					if ((j) >= (pTab.nCol))
					{
						if (((sqlite3IsRowid(pColumn->a[i].zName)) != 0) && (withoutRowid == 0))
						{
							ipkColumn = (int)(i);
							bIdListInOrder = (byte)(0);
						}
						else
						{
							sqlite3ErrorMsg(pParse, "table %S has no column named %s", pTabList.a, pColumn->a[i].zName);
							pParse.checkSchema = (byte)(1);
							goto insert_cleanup;
						}
					}
				}
			}

			if ((pSelect) != null)
			{
				int regYield = 0;
				int addrTop = 0;
				int rc = 0;
				regYield = (int)(++pParse.nMem);
				addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
				sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(addrTop));
				sqlite3SelectDestInit(dest, (int)(13), (int)(regYield));
				dest.iSdst = (int)((bIdListInOrder) != 0 ? regData : 0);
				dest.nSdst = (int)(pTab.nCol);
				rc = (int)(sqlite3Select(pParse, pSelect, dest));
				regFromSelect = (int)(dest.iSdst);

				if (((rc) != 0) || ((pParse.nErr) != 0))
					goto insert_cleanup;

				sqlite3VdbeEndCoroutine(v, (int)(regYield));
				sqlite3VdbeJumpHere(v, (int)(addrTop - 1));

				nColumn = (int)(pSelect.pEList.nExpr);
				if (((pTrigger) != null) || ((readsTable(pParse, (int)(iDb), pTab)) != 0))
				{
					useTempTable = (byte)(1);
				}

				if ((useTempTable) != 0)
				{
					int regRec = 0;
					int regTempRowid = 0;
					int addrL = 0;
					srcTab = (int)(pParse.nTab++);
					regRec = (int)(sqlite3GetTempReg(pParse));
					regTempRowid = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp2(v, (int)(116), (int)(srcTab), (int)(nColumn));
					addrL = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm)));
					sqlite3VdbeAddOp3(v, (int)(96), (int)(regFromSelect), (int)(nColumn), (int)(regRec));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(srcTab), (int)(regTempRowid));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(srcTab), (int)(regRec), (int)(regTempRowid));
					sqlite3VdbeGoto(v, (int)(addrL));
					sqlite3VdbeJumpHere(v, (int)(addrL));
					sqlite3ReleaseTempReg(pParse, (int)(regRec));
					sqlite3ReleaseTempReg(pParse, (int)(regTempRowid));
				}
			}
			else
			{
				NameContext sNC = new NameContext();
				CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
				sNC.pParse = pParse;
				srcTab = (int)(-1);

				if ((pList) != null)
				{
					nColumn = (int)(pList.nExpr);
					if ((sqlite3ResolveExprListNames(sNC, pList)) != 0)
					{
						goto insert_cleanup;
					}
				}
				else
				{
					nColumn = (int)(0);
				}
			}

			if (((pColumn) == (null)) && ((nColumn) > (0)))
			{
				ipkColumn = (int)(pTab.iPKey);
				if (((ipkColumn) >= (0)) && ((pTab.tabFlags & 0x00000060) != 0))
				{
					for (i = (int)(ipkColumn - 1); (i) >= (0); i--)
					{
						if ((pTab.aCol[i].colFlags & 0x0060) != 0)
						{
							ipkColumn--;
						}
					}
				}




				if ((pTab.tabFlags & (0x00000060 | 0x00000002)) != 0)
				{
					for (i = (int)(0); (i) < (pTab.nCol); i++)
					{
						if ((pTab.aCol[i].colFlags & 0x0062) != 0)
							nHidden++;
					}
				}

				if (nColumn != (pTab.nCol - nHidden))
				{
					sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied", pTabList.a, (int)(pTab.nCol - nHidden), (int)(nColumn));
					goto insert_cleanup;
				}
			}

			if ((pColumn != null) && (nColumn != pColumn->nId))
			{
				sqlite3ErrorMsg(pParse, "%d values for %d columns", (int)(nColumn), (int)(pColumn->nId));
				goto insert_cleanup;
			}

			if (((((db.flags & ((ulong)(0x00001) << 32)) != 0) && (pParse.nested == 0)) && (pParse.pTriggerTab == null)) && (pParse.bReturning == 0))
			{
				regRowCount = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regRowCount));
			}

			if (isView == 0)
			{
				int nIdx = 0;
				nIdx = (int)(sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0), (int)(-1), null, &iDataCur, &iIdxCur));
				aRegIdx = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (nIdx + 2)));
				if ((aRegIdx) == (null))
				{
					goto insert_cleanup;
				}

				for (i = (int)(0), pIdx = pTab.pIndex; (i) < (nIdx); pIdx = pIdx.pNext, i++)
				{

					aRegIdx[i] = (int)(++pParse.nMem);
					pParse.nMem += (int)(pIdx.nColumn);
				}

				aRegIdx[i] = (int)(++pParse.nMem);
			}

			if ((pUpsert) != null)
			{
				Upsert pNx;
				if ((((pTab).eTabType) == (1)))
				{
					sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"", pTab.zName);
					goto insert_cleanup;
				}

				if ((((pTab).eTabType) == (2)))
				{
					sqlite3ErrorMsg(pParse, "cannot UPSERT a view");
					goto insert_cleanup;
				}

				if ((sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget)) != 0)
				{
					goto insert_cleanup;
				}

				pTabList.a[0].iCursor = (int)(iDataCur);
				pNx = pUpsert;
				do
				{
					pNx.pUpsertSrc = pTabList;
					pNx.regData = (int)(regData);
					pNx.iDataCur = (int)(iDataCur);
					pNx.iIdxCur = (int)(iIdxCur);
					if ((pNx.pUpsertTarget) != null)
					{
						if ((sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx)) != 0)
						{
							goto insert_cleanup;
						}
					}

					pNx = pNx.pNextUpsert;
				}
				while (pNx != null);
			}

			if ((useTempTable) != 0)
			{
				addrInsTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(srcTab)));
				addrCont = (int)(sqlite3VdbeCurrentAddr(v));
			}
			else if ((pSelect) != null)
			{
				addrInsTop = (int)(addrCont = (int)(sqlite3VdbeAddOp1(v, (int)(14), (int)(dest.iSDParm))));
				if ((ipkColumn) >= (0))
				{
					sqlite3VdbeAddOp2(v, (int)(79), (int)(regFromSelect + ipkColumn), (int)(regRowid));
				}
			}

			nHidden = (int)(0);
			iRegStore = (int)(regData);

			for (i = (int)(0); (i) < (pTab.nCol); i++, iRegStore++)
			{
				int k = 0;
				uint colFlags = 0;

				if ((i) == (pTab.iPKey))
				{
					sqlite3VdbeAddOp1(v, (int)(75), (int)(iRegStore));
					continue;
				}

				if (((colFlags = (uint)(pTab.aCol[i].colFlags)) & 0x0062) != 0)
				{
					nHidden++;
					if ((colFlags & 0x0020) != 0)
					{
						iRegStore--;
						continue;
					}
					else if ((colFlags & 0x0040) != 0)
					{
						if ((tmask & 1) != 0)
						{
							sqlite3VdbeAddOp1(v, (int)(75), (int)(iRegStore));
						}

						continue;
					}
					else if ((pColumn) == (null))
					{
						sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab.aCol[i]), (int)(iRegStore));
						continue;
					}
				}

				if ((pColumn) != null)
				{
					for (j = (int)(0); ((j) < (pColumn->nId)) && (pColumn->a[j].idx != i); j++)
					{
					}

					if ((j) >= (pColumn->nId))
					{
						sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab.aCol[i]), (int)(iRegStore));
						continue;
					}

					k = (int)(j);
				}
				else if ((nColumn) == (0))
				{
					sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab.aCol[i]), (int)(iRegStore));
					continue;
				}
				else
				{
					k = (int)(i - nHidden);
				}

				if ((useTempTable) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(k), (int)(iRegStore));
				}
				else if ((pSelect) != null)
				{
					if (regFromSelect != regData)
					{
						sqlite3VdbeAddOp2(v, (int)(80), (int)(regFromSelect + k), (int)(iRegStore));
					}
				}
				else
				{
					sqlite3ExprCode(pParse, pList.a[k].pExpr, (int)(iRegStore));
				}
			}

			endOfLoop = (int)(sqlite3VdbeMakeLabel(pParse));
			if ((tmask & 1) != 0)
			{
				int regCols = (int)(sqlite3GetTempRange(pParse, (int)(pTab.nCol + 1)));
				if ((ipkColumn) < (0))
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(-1), (int)(regCols));
				}
				else
				{
					int addr1 = 0;

					if ((useTempTable) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(ipkColumn), (int)(regCols));
					}
					else
					{

						sqlite3ExprCode(pParse, pList.a[ipkColumn].pExpr, (int)(regCols));
					}

					addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(regCols)));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(-1), (int)(regCols));
					sqlite3VdbeJumpHere(v, (int)(addr1));
					sqlite3VdbeAddOp1(v, (int)(15), (int)(regCols));
				}


				sqlite3VdbeAddOp3(v, (int)(79), (int)(regRowid + 1), (int)(regCols + 1), (int)(pTab.nNVCol - 1));
				if ((pTab.tabFlags & 0x00000060) != 0)
				{
					sqlite3ComputeGeneratedColumns(pParse, (int)(regCols + 1), pTab);
				}

				if (isView == 0)
				{
					sqlite3TableAffinity(v, pTab, (int)(regCols + 1));
				}

				sqlite3CodeRowTrigger(pParse, pTrigger, (int)(127), null, (int)(1), pTab, (int)(regCols - pTab.nCol - 1), (int)(onError), (int)(endOfLoop));
				sqlite3ReleaseTempRange(pParse, (int)(regCols), (int)(pTab.nCol + 1));
			}

			if (isView == 0)
			{
				if ((((pTab).eTabType) == (1)))
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regIns));
				}

				if ((ipkColumn) >= (0))
				{
					if ((useTempTable) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(srcTab), (int)(ipkColumn), (int)(regRowid));
					}
					else if ((pSelect) != null)
					{
					}
					else
					{
						Expr pIpk = pList.a[ipkColumn].pExpr;
						if (((pIpk.op) == (121)) && (!(((pTab).eTabType) == (1))))
						{
							sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
							appendFlag = (byte)(1);
						}
						else
						{
							sqlite3ExprCode(pParse, pList.a[ipkColumn].pExpr, (int)(regRowid));
						}
					}

					if (appendFlag == 0)
					{
						int addr1 = 0;
						if (!(((pTab).eTabType) == (1)))
						{
							addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(regRowid)));
							sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
							sqlite3VdbeJumpHere(v, (int)(addr1));
						}
						else
						{
							addr1 = (int)(sqlite3VdbeCurrentAddr(v));
							sqlite3VdbeAddOp2(v, (int)(50), (int)(regRowid), (int)(addr1 + 2));
						}

						sqlite3VdbeAddOp1(v, (int)(15), (int)(regRowid));
					}
				}
				else if ((((pTab).eTabType) == (1)) || ((withoutRowid) != 0))
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regRowid));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(126), (int)(iDataCur), (int)(regRowid), (int)(regAutoinc));
					appendFlag = (byte)(1);
				}

				autoIncStep(pParse, (int)(regAutoinc), (int)(regRowid));
				if ((pTab.tabFlags & 0x00000060) != 0)
				{
					sqlite3ComputeGeneratedColumns(pParse, (int)(regRowid + 1), pTab);
				}

				if ((((pTab).eTabType) == (1)))
				{
					sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
					sqlite3VtabMakeWritable(pParse, pTab);
					sqlite3VdbeAddOp4(v, (int)(10), (int)(1), (int)(pTab.nCol + 2), (int)(regIns), pVTab, (int)(-12));
					sqlite3VdbeChangeP5(v, (ushort)((onError) == (11) ? 2 : onError));
					sqlite3MayAbort(pParse);
				}
				else
				{
					int isReplace = (int)(0);
					int bUseSeek = 0;
					sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, (int)(iDataCur), (int)(iIdxCur), (int)(regIns), (int)(0), (byte)((ipkColumn) >= (0)), (byte)(onError), (int)(endOfLoop), &isReplace, null, pUpsert);
					sqlite3FkCheck(pParse, pTab, (int)(0), (int)(regIns), null, (int)(0));
					bUseSeek = (int)(((isReplace) == (0)) || (sqlite3VdbeHasSubProgram(v) == 0) ? 1 : 0);
					sqlite3CompleteInsertion(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), (int)(regIns), aRegIdx, (int)(0), (int)(appendFlag), (int)(bUseSeek));
				}
			}

			if ((regRowCount) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(85), (int)(regRowCount), (int)(1));
			}

			if ((pTrigger) != null)
			{
				sqlite3CodeRowTrigger(pParse, pTrigger, (int)(127), null, (int)(2), pTab, (int)(regData - 2 - pTab.nCol), (int)(onError), (int)(endOfLoop));
			}

			sqlite3VdbeResolveLabel(v, (int)(endOfLoop));
			if ((useTempTable) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(srcTab), (int)(addrCont));
				sqlite3VdbeJumpHere(v, (int)(addrInsTop));
				sqlite3VdbeAddOp1(v, (int)(121), (int)(srcTab));
			}
			else if ((pSelect) != null)
			{
				sqlite3VdbeGoto(v, (int)(addrCont));
				sqlite3VdbeJumpHere(v, (int)(addrInsTop));
			}

		insert_end:
			; if (((pParse.nested) == (0)) && ((pParse.pTriggerTab) == (null))) { sqlite3AutoincrementEnd(pParse); }
			if ((regRowCount) != 0)
			{
				sqlite3CodeChangeCount(v, (int)(regRowCount), "rows inserted");
			}

		insert_cleanup:
			; sqlite3SrcListDelete(db, pTabList);
			sqlite3ExprListDelete(db, pList);
			sqlite3UpsertDelete(db, pUpsert);
			sqlite3SelectDelete(db, pSelect);
			sqlite3IdListDelete(db, pColumn);
			sqlite3DbFree(db, aRegIdx);
		}
		public static void sqlite3InsertBuiltinFuncs(FuncDef aDef, int nDef)
		{
			int i = 0;
			for (i = (int)(0); (i) < (nDef); i++)
			{
				FuncDef pOther;
				sbyte* zName = aDef[i].zName;
				int nName = (int)(sqlite3Strlen30(zName));
				int h = (int)(((zName[0]) + (nName)) % 23);

				pOther = sqlite3FunctionSearch((int)(h), zName);
				if ((pOther) != null)
				{

					aDef[i].pNext = pOther.pNext;
					pOther.pNext = aDef[i];
				}
				else
				{
					aDef[i].pNext = null;
					aDef[i].u.pHash = sqlite3BuiltinFunctions.a[h];
					sqlite3BuiltinFunctions.a[h] = aDef[i];
				}
			}
		}
		public static void sqlite3Int64ToText(long v, sbyte* zOut)
		{
			int i = 0;
			ulong x = 0;
			sbyte* zTemp = stackalloc sbyte[22];
			if ((v) < (0))
			{
				x = (ulong)(((v) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32)))) ? ((ulong)(1)) << 63 : (ulong)(-v));
			}
			else
			{
				x = (ulong)(v);
			}

			i = (int)(22 * sizeof(sbyte) - 2);
			zTemp[22 * sizeof(sbyte) - 1] = (sbyte)(0);
			do
			{
				zTemp[i--] = (sbyte)((x % 10) + 48);
				x = (ulong)(x / 10);
			}
			while ((x) != 0);
			if ((v) < (0))
				zTemp[i--] = (sbyte)(45);
			CRuntime.memcpy(zOut, &zTemp[i + 1], (ulong)(22 * sizeof(sbyte) - 1 - i));
		}
		public static int sqlite3IntFloatCompare(long i, double r)
		{
			if ((sizeof(LONGDOUBLE_TYPE)) > (8))
			{
				long double x = (long double )
        ((long double )
        (i) )
        ;
				if ((x) < (r))
					return (int)(-1);
				if ((x) > (r))
					return (int)(+1);
				return (int)(0);
			}

			else
			{
				long y = 0;
				double s = 0;
				if ((r) < (-9223372036854775808.0))
					return (int)(+1);
				if ((r) >= (9223372036854775808.0))
					return (int)(-1);
				y = ((long)(r));
				if ((i) < (y))
					return (int)(-1);
				if ((i) > (y))
					return (int)(+1);
				s = ((double)(i));
				if ((s) < (r))
					return (int)(-1);
				if ((s) > (r))
					return (int)(+1);
				return (int)(0);
			}
		}
		public static void sqlite3InvalidFunction(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sbyte* zName = (sbyte*)(sqlite3_user_data(context));
			sbyte* zErr;
			(void)(NotUsed) ,  (void)(NotUsed2);
			zErr = sqlite3_mprintf("unable to use function %s in the requested context", zName);
			sqlite3_result_error(context, zErr, (int)(-1));
			sqlite3_free(zErr);
		}
		public static int sqlite3InvokeBusyHandler(BusyHandler p)
		{
			int rc = 0;
			if (((p.xBusyHandler) == (null)) || ((p.nBusy) < (0)))
				return (int)(0);
			rc = (int)(p.xBusyHandler(p.pBusyArg, (int)(p.nBusy)));
			if ((rc) == (0))
			{
				p.nBusy = (int)(-1);
			}
			else
			{
				p.nBusy++;
			}

			return (int)(rc);
		}
		public static int sqlite3IsBinary(CollSeq p)
		{

			return (((p) == (null)) || ((p.xCmp) == (binCollFunc)) ? 1 : 0);
		}
		public static int sqlite3IsIdChar(byte c)
		{
			return (int)((sqlite3CtypeMap[c] & 0x46) != 0);
		}
		public static int sqlite3IsLikeFunction(sqlite3 db, Expr pExpr, int* pIsNocase, sbyte* aWc)
		{
			FuncDef pDef;
			int nExpr = 0;



			if (pExpr.x.pList == null)
			{
				return (int)(0);
			}

			nExpr = (int)(pExpr.x.pList.nExpr);

			pDef = sqlite3FindFunction(db, pExpr.u.zToken, (int)(nExpr), (byte)(1), (byte)(0));
			if (((pDef) == (null)) || ((pDef.funcFlags & 0x0004) == (0)))
			{
				return (int)(0);
			}

			CRuntime.memcpy(aWc, pDef.pUserData, (ulong)(3));



			if ((nExpr) < (3))
			{
				aWc[3] = (sbyte)(0);
			}
			else
			{
				Expr pEscape = pExpr.x.pList.a[2].pExpr;
				sbyte* zEscape;
				if (pEscape.op != 117)
					return (int)(0);

				zEscape = pEscape.u.zToken;
				if (((zEscape[0]) == (0)) || (zEscape[1] != 0))
					return (int)(0);
				if ((zEscape[0]) == (aWc[0]))
					return (int)(0);
				if ((zEscape[0]) == (aWc[1]))
					return (int)(0);
				aWc[3] = (sbyte)(zEscape[0]);
			}

			*pIsNocase = (int)((pDef.funcFlags & 0x0008) == (0) ? 1 : 0);
			return (int)(1);
		}
		public static int sqlite3IsNaN(double x)
		{
			int rc = 0;
			ulong y = 0;
			CRuntime.memcpy(&y, &x, (ulong)(sizeof(ulong)));
			rc = (int)((((y) & (((ulong)(0x7ff)) << 52)) == (((ulong)(0x7ff)) << 52)) && (((y) & ((((ulong)(1)) << 52) - 1)) != 0) ? 1 : 0);
			return (int)(rc);
		}
		public static int sqlite3IsReadOnly(Parse pParse, Table pTab, int viewOk)
		{
			if ((tabIsReadOnly(pParse, pTab)) != 0)
			{
				sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab.zName);
				return (int)(1);
			}

			if ((viewOk == 0) && (((pTab).eTabType) == (2)))
			{
				sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", pTab.zName);
				return (int)(1);
			}

			return (int)(0);
		}
		public static int sqlite3IsRowid(sbyte* z)
		{
			if ((sqlite3StrICmp(z, "_ROWID_")) == (0))
				return (int)(1);
			if ((sqlite3StrICmp(z, "ROWID")) == (0))
				return (int)(1);
			if ((sqlite3StrICmp(z, "OID")) == (0))
				return (int)(1);
			return (int)(0);
		}
		public static int sqlite3IsShadowTableOf(sqlite3 db, Table pTab, sbyte* zName)
		{
			int nName = 0;
			Module pMod;
			if (!(((pTab).eTabType) == (1)))
				return (int)(0);
			nName = (int)(sqlite3Strlen30(pTab.zName));
			if (sqlite3_strnicmp(zName, pTab.zName, (int)(nName)) != 0)
				return (int)(0);
			if (zName[nName] != 95)
				return (int)(0);
			pMod = (Module)(sqlite3HashFind(&db.aModule, pTab.u.vtab.azArg[0]));
			if ((pMod) == (null))
				return (int)(0);
			if ((pMod.pModule.iVersion) < (3))
				return (int)(0);
			if ((pMod.pModule.xShadowName) == (null))
				return (int)(0);
			return (int)(pMod.pModule.xShadowName(zName + nName + 1));
		}
		public static uint sqlite3IsTrueOrFalse(sbyte* zIn)
		{
			if ((sqlite3StrICmp(zIn, "true")) == (0))
				return (uint)(0x10000000);
			if ((sqlite3StrICmp(zIn, "false")) == (0))
				return (uint)(0x20000000);
			return (uint)(0);
		}
		public static int sqlite3JournalIsInMemory(sqlite3_file p)
		{
			return ((p.pMethods) == (MemJournalMethods) ? 1 : 0);
		}
		public static sbyte* sqlite3JournalModename(int eMode)
		{







			if ((eMode) == ((int)(6 * sizeof(sbyte) / sizeof(sbyte*))))
				return null;
			return sqlite3JournalModename_azModeName[eMode];
		}
		public static int sqlite3JournalOpen(sqlite3_vfs pVfs, sbyte* zName, sqlite3_file pJfd, int flags, int nSpill)
		{
			MemJournal p = (MemJournal)(pJfd);
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(MemJournal)));
			if ((nSpill) == (0))
			{
				return (int)(sqlite3OsOpen(pVfs, zName, pJfd, (int)(flags), null));
			}

			if ((nSpill) > (0))
			{
				p.nChunkSize = (int)(nSpill);
			}
			else
			{
				p.nChunkSize = (int)(8 + 1024 - sizeof(FileChunk));

			}

			pJfd.pMethods = MemJournalMethods;
			p.nSpill = (int)(nSpill);
			p.flags = (int)(flags);
			p.zJournal = zName;
			p.pVfs = pVfs;
			return (int)(0);
		}
		public static int sqlite3JournalSize(sqlite3_vfs pVfs)
		{
			return (int)((pVfs.szOsFile) > ((int)(sizeof(MemJournal))) ? (pVfs.szOsFile) : ((int)(sizeof(MemJournal))));
		}
		public static KeyInfo sqlite3KeyInfoAlloc(sqlite3 db, int N, int X)
		{
			int nExtra = (int)((N + X) * (sizeof(CollSeq) + 1) - sizeof(CollSeq));
			KeyInfo p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(KeyInfo) + nExtra));
			if ((p) != null)
			{
				p.aSortFlags = (byte*)(p.aColl[N + X]);
				p.nKeyField = ((ushort)(N));
				p.nAllField = ((ushort)(N + X));
				p.enc = (byte)((db).enc);
				p.db = db;
				p.nRef = (uint)(1);
				CRuntime.memset(p[1], (int)(0), (ulong)(nExtra));
			}
			else
			{
				return (KeyInfo)(sqlite3OomFault(db));
			}

			return p;
		}
		public static KeyInfo sqlite3KeyInfoFromExprList(Parse pParse, ExprList pList, int iStart, int nExtra)
		{
			int nExpr = 0;
			KeyInfo pInfo;
			ExprList_item* pItem;
			sqlite3 db = pParse.db;
			int i = 0;
			nExpr = (int)(pList.nExpr);
			pInfo = sqlite3KeyInfoAlloc(db, (int)(nExpr - iStart), (int)(nExtra + 1));
			if ((pInfo) != null)
			{

				for (i = (int)(iStart), pItem = pList.a + iStart; (i) < (nExpr); i++, pItem++)
				{
					pInfo.aColl[i - iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
					pInfo.aSortFlags[i - iStart] = (byte)(pItem->sortFlags);
				}
			}

			return pInfo;
		}
		public static KeyInfo sqlite3KeyInfoOfIndex(Parse pParse, Index pIdx)
		{
			int i = 0;
			int nCol = (int)(pIdx.nColumn);
			int nKey = (int)(pIdx.nKeyCol);
			KeyInfo pKey;
			if ((pParse.nErr) != 0)
				return null;
			if ((pIdx.uniqNotNull) != 0)
			{
				pKey = sqlite3KeyInfoAlloc(pParse.db, (int)(nKey), (int)(nCol - nKey));
			}
			else
			{
				pKey = sqlite3KeyInfoAlloc(pParse.db, (int)(nCol), (int)(0));
			}

			if ((pKey) != null)
			{

				for (i = (int)(0); (i) < (nCol); i++)
				{
					sbyte* zColl = pIdx.azColl[i];
					pKey.aColl[i] = (zColl) == (sqlite3StrBINARY) ? null : sqlite3LocateCollSeq(pParse, zColl);
					pKey.aSortFlags[i] = (byte)(pIdx.aSortOrder[i]);

				}

				if ((pParse.nErr) != 0)
				{

					if ((pIdx.bNoQuery) == (0))
					{
						pIdx.bNoQuery = (uint)(1);
						pParse.rc = (int)(1 | (2 << 8));
					}

					sqlite3KeyInfoUnref(pKey);
					pKey = null;
				}
			}

			return pKey;
		}
		public static KeyInfo sqlite3KeyInfoRef(KeyInfo p)
		{
			if ((p) != null)
			{

				p.nRef++;
			}

			return p;
		}
		public static void sqlite3KeyInfoUnref(KeyInfo p)
		{
			if ((p) != null)
			{

				p.nRef--;
				if ((p.nRef) == (0))
					sqlite3DbFreeNN(p.db, p);
			}
		}
		public static int sqlite3KeywordCode(byte* z, int n)
		{
			int id = (int)(59);
			keywordCode((sbyte*)(z), (int)(n), &id);
			return (int)(id);
		}
		public static void sqlite3LeaveMutexAndCloseZombie(sqlite3 db)
		{
			HashElem* i;
			int j = 0;
			if ((db.eOpenState != 0xa7) || ((connectionIsBusy(db)) != 0))
			{
				sqlite3_mutex_leave(db.mutex);
				return;
			}

			sqlite3RollbackAll(db, (int)(0));
			sqlite3CloseSavepoints(db);
			for (j = (int)(0); (j) < (db.nDb); j++)
			{
				Db pDb = db.aDb[j];
				if ((pDb.pBt) != null)
				{
					sqlite3BtreeClose(pDb.pBt);
					pDb.pBt = null;
					if (j != 1)
					{
						pDb.pSchema = null;
					}
				}
			}

			if ((db.aDb[1].pSchema) != null)
			{
				sqlite3SchemaClear(db.aDb[1].pSchema);
			}

			sqlite3VtabUnlockList(db);
			sqlite3CollapseDatabaseArray(db);


			for (i = ((&db.aFunc)->first); i; i = ((i)->next))
			{
				FuncDef pNext;
				FuncDef p;
				p = ((i)->data);
				do
				{
					functionDestroy(db, p);
					pNext = p.pNext;
					sqlite3DbFree(db, p);
					p = pNext;
				}
				while ((p) != null);
			}

			sqlite3HashClear(&db.aFunc);
			for (i = ((&db.aCollSeq)->first); i; i = ((i)->next))
			{
				CollSeq pColl = (CollSeq)((i)->data);
				for (j = (int)(0); (j) < (3); j++)
				{
					if ((pColl[j].xDel) != null)
					{
						pColl[j].xDel(pColl[j].pUser);
					}
				}

				sqlite3DbFree(db, pColl);
			}

			sqlite3HashClear(&db.aCollSeq);
			for (i = ((&db.aModule)->first); i; i = ((i)->next))
			{
				Module pMod = (Module)((i)->data);
				sqlite3VtabEponymousTableClear(db, pMod);
				sqlite3VtabModuleUnref(db, pMod);
			}

			sqlite3HashClear(&db.aModule);
			sqlite3Error(db, (int)(0));
			sqlite3ValueFree(db.pErr);
			sqlite3CloseExtensions(db);
			db.eOpenState = (byte)(0xd5);
			sqlite3DbFree(db, db.aDb[1].pSchema);
			if ((db.xAutovacDestr) != null)
			{
				db.xAutovacDestr(db.pAutovacPagesArg);
			}

			sqlite3_mutex_leave(db.mutex);
			db.eOpenState = (byte)(0xce);
			sqlite3_mutex_free(db.mutex);

			if ((db.lookaside.bMalloced) != 0)
			{
				sqlite3_free(db.lookaside.pStart);
			}

			sqlite3_free(db);
		}
		public static int sqlite3LoadExtension(sqlite3 db, sbyte* zFile, sbyte* zProc, sbyte** pzErrMsg)
		{
			sqlite3_vfs pVfs = db.pVfs;
			void* handle;
			delegate87 xInit;
			sbyte* zErrmsg = null;
			sbyte* zEntry;
			sbyte* zAltEntry = null;
			void** aHandle;
			ulong nMsg = (ulong)(CRuntime.strlen(zFile));
			int ii = 0;
			int rc = 0;
			if ((pzErrMsg) != null)
				*pzErrMsg = null;
			if ((db.flags & 0x00010000) == (0))
			{
				if ((pzErrMsg) != null)
				{
					*pzErrMsg = sqlite3_mprintf("not authorized");
				}

				return (int)(1);
			}

			zEntry = (zProc) != 0 ? zProc : "sqlite3_extension_init";
			if ((nMsg) > (260))
				goto extension_not_found;
			handle = sqlite3OsDlOpen(pVfs, zFile);
			for (ii = (int)(0); ((ii) < ((int)(1 * sizeof(sbyte) / sizeof(sbyte*)))) && ((handle) == (null)); ii++)
			{
				sbyte* zAltFile = sqlite3_mprintf("%s.%s", zFile, sqlite3LoadExtension_azEndings[ii]);
				if ((zAltFile) == (null))
					return (int)(7);
				handle = sqlite3OsDlOpen(pVfs, zAltFile);
				sqlite3_free(zAltFile);
			}

			if ((handle) == (null))
				goto extension_not_found;
			xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3OsDlSym(pVfs, handle, zEntry));
			if (((xInit) == (null)) && ((zProc) == (null)))
			{
				int iFile = 0;
				int iEntry = 0;
				int c = 0;
				int ncFile = (int)(sqlite3Strlen30(zFile));
				zAltEntry = sqlite3_malloc64((ulong)(ncFile + 30));
				if ((zAltEntry) == (null))
				{
					sqlite3OsDlClose(pVfs, handle);
					return (int)(7);
				}

				CRuntime.memcpy(zAltEntry, "sqlite3_", (ulong)(8));
				for (iFile = (int)(ncFile - 1); ((iFile) >= (0)) && (!(((zFile[iFile]) == (47)) || ((zFile[iFile]) == (92)))); iFile--)
				{
				}

				iFile++;
				if ((sqlite3_strnicmp(zFile + iFile, "lib", (int)(3))) == (0))
					iFile += (int)(3);
				for (iEntry = (int)(8); ((c = (int)(zFile[iFile])) != 0) && (c != 46); iFile++)
				{
					if ((sqlite3CtypeMap[(byte)(c)] & 0x02) != 0)
					{
						zAltEntry[iEntry++] = ((sbyte)(sqlite3UpperToLower[(uint)(c)]));
					}
				}

				CRuntime.memcpy(zAltEntry + iEntry, "_init", (ulong)(6));
				zEntry = zAltEntry;
				xInit = (Int(sqlite3 * , sqlite3 * , sqlite3 * ))(sqlite3OsDlSym(pVfs, handle, zEntry));
			}

			if ((xInit) == (null))
			{
				if ((pzErrMsg) != null)
				{
					nMsg += (ulong)(CRuntime.strlen(zEntry) + 300);
					*pzErrMsg = zErrmsg = sqlite3_malloc64((ulong)(nMsg));
					if ((zErrmsg) != null)
					{

						sqlite3_snprintf((int)(nMsg), zErrmsg, "no entry point [%s] in shared library [%s]", zEntry, zFile);
						sqlite3OsDlError(pVfs, (int)(nMsg - 1), zErrmsg);
					}
				}

				sqlite3OsDlClose(pVfs, handle);
				sqlite3_free(zAltEntry);
				return (int)(1);
			}

			sqlite3_free(zAltEntry);
			rc = (int)(xInit(db, &zErrmsg, sqlite3Apis));
			if ((rc) != 0)
			{
				if ((rc) == (0 | (1 << 8)))
					return (int)(0);
				if ((pzErrMsg) != null)
				{
					*pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
				}

				sqlite3_free(zErrmsg);
				sqlite3OsDlClose(pVfs, handle);
				return (int)(1);
			}

			aHandle = sqlite3DbMallocZero(db, (ulong)(sizeof(void*) * (db.nExtension + 1)));
			if ((aHandle) == (null))
			{
				return (int)(7);
			}

			if ((db.nExtension) > (0))
			{
				CRuntime.memcpy(aHandle, db.aExtension, (ulong)(sizeof(void*) * db.nExtension));
			}

			sqlite3DbFree(db, db.aExtension);
			db.aExtension = aHandle;
			db.aExtension[db.nExtension++] = handle;
			return (int)(0);
		extension_not_found:
			; if ((pzErrMsg) != null) { nMsg += (ulong)(300); *pzErrMsg = zErrmsg = sqlite3_malloc64((ulong)(nMsg)); if ((zErrmsg) != null) { ((void)(0)); sqlite3_snprintf((int)(nMsg), zErrmsg, "unable to open shared library [%.*s]", (int)(260), zFile); sqlite3OsDlError(pVfs, (int)(nMsg - 1), zErrmsg); } }
			return (int)(1);
		}
		public static CollSeq sqlite3LocateCollSeq(Parse pParse, sbyte* zName)
		{
			sqlite3 db = pParse.db;
			byte enc = (byte)((db).enc);
			byte initbusy = (byte)(db.init.busy);
			CollSeq pColl;
			pColl = sqlite3FindCollSeq(db, (byte)(enc), zName, (int)(initbusy));
			if ((initbusy == 0) && ((pColl == null) || (pColl.xCmp == null)))
			{
				pColl = sqlite3GetCollSeq(pParse, (byte)(enc), pColl, zName);
			}

			return pColl;
		}
		public static Table sqlite3LocateTable(Parse pParse, uint flags, sbyte* zName, sbyte* zDbase)
		{
			Table p;
			sqlite3 db = pParse.db;
			if (((db.mDbFlags & 0x0010) == (0)) && (0 != sqlite3ReadSchema(pParse)))
			{
				return null;
			}

			p = sqlite3FindTable(db, zName, zDbase);
			if ((p) == (null))
			{
				if (((pParse.disableVtab) == (0)) && ((db.init.busy) == (0)))
				{
					Module pMod = (Module)(sqlite3HashFind(&db.aModule, zName));
					if (((pMod) == (null)) && ((sqlite3_strnicmp(zName, "pragma_", (int)(7))) == (0)))
					{
						pMod = sqlite3PragmaVtabRegister(db, zName);
					}

					if (((pMod) != null) && ((sqlite3VtabEponymousTableInit(pParse, pMod)) != 0))
					{
						return pMod.pEpoTab;
					}
				}

				if ((flags & 0x02) != 0)
					return null;
				pParse.checkSchema = (byte)(1);
			}
			else if ((((p).eTabType) == (1)) && ((pParse.disableVtab) != 0))
			{
				p = null;
			}

			if ((p) == (null))
			{
				sbyte* zMsg = (flags & 0x01) != 0 ? "no such view" : "no such table";
				if ((zDbase) != null)
				{
					sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
				}
				else
				{
					sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
				}
			}
			else
			{

			}

			return p;
		}
		public static Table sqlite3LocateTableItem(Parse pParse, uint flags, SrcItem p)
		{
			sbyte* zDb;

			if ((p.pSchema) != null)
			{
				int iDb = (int)(sqlite3SchemaToIndex(pParse.db, p.pSchema));
				zDb = pParse.db.aDb[iDb].zDbSName;
			}
			else
			{
				zDb = p.zDatabase;
			}

			return sqlite3LocateTable(pParse, (uint)(flags), p.zName, zDb);
		}
		public static int sqlite3LockAndPrepare(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, Vdbe pOld, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = 0;
			int cnt = (int)(0);
			*ppStmt = null;
			if ((sqlite3SafetyCheckOk(db) == 0) || ((zSql) == (null)))
			{
				return (int)(sqlite3MisuseError((int)(133992)));
			}

			sqlite3_mutex_enter(db.mutex);
			sqlite3BtreeEnterAll(db);
			do
			{
				rc = (int)(sqlite3Prepare(db, zSql, (int)(nBytes), (uint)(prepFlags), pOld, ppStmt, pzTail));

				if (((rc) == (0)) || ((db.mallocFailed) != 0))
					break;
			}
			while (((rc) == (1 | (2 << 8))) || (((rc) == (17)) && ((sqlite3ResetOneSchema(db, (int)(-1)), cnt++) == (0))));
			sqlite3BtreeLeaveAll(db);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));

			db.busyHandler.nBusy = (int)(0);
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static short sqlite3LogEst(ulong x)
		{
			short y = (short)(40);
			if ((x) < (8))
			{
				if ((x) < (2))
					return (short)(0);
				while ((x) < (8))
				{
					y -= (short)(10);
					x <<= 1;
				}
			}
			else
			{
				while ((x) > (255))
				{
					y += (short)(40);
					x >>= 4;
				}

				while ((x) > (15))
				{
					y += (short)(10);
					x >>= 1;
				}
			}

			return (short)(sqlite3LogEst_a[x & 7] + y - 10);
		}
		public static short sqlite3LogEstAdd(short a, short b)
		{
			if ((a) >= (b))
			{
				if ((a) > (b + 49))
					return (short)(a);
				if ((a) > (b + 31))
					return (short)(a + 1);
				return (short)(a + sqlite3LogEstAdd_x[a - b]);
			}
			else
			{
				if ((b) > (a + 49))
					return (short)(b);
				if ((b) > (a + 31))
					return (short)(b + 1);
				return (short)(b + sqlite3LogEstAdd_x[b - a]);
			}
		}
		public static short sqlite3LogEstFromDouble(double x)
		{
			ulong a = 0;
			short e = 0;

			if ((x) <= (1))
				return (short)(0);
			if ((x) <= (2000000000))
				return (short)(sqlite3LogEst((ulong)(x)));
			CRuntime.memcpy(&a, &x, (ulong)(8));
			e = (short)((a >> 52) - 1022);
			return (short)(e * 10);
		}
		public static ulong sqlite3LogEstToInt(short x)
		{
			ulong n = 0;
			n = (ulong)(x % 10);
			x /= (short)(10);
			if ((n) >= (5))
				n -= (ulong)(2);
			else if ((n) >= (1))
				n -= (ulong)(1);
			if ((x) > (60))
				return (ulong)(0xffffffff | (((long)(0x7fffffff)) << 32));
			return (ulong)((x) >= (3) ? (n + 8) << (x - 3) : (n + 8) >> (3 - x));
		}
		public static int sqlite3LookasideUsed(sqlite3 db, int* pHighwater)
		{
			uint nInit = (uint)(countLookasideSlots(db.lookaside.pInit));
			uint nFree = (uint)(countLookasideSlots(db.lookaside.pFree));
			nInit += (uint)(countLookasideSlots(db.lookaside.pSmallInit));
			nFree += (uint)(countLookasideSlots(db.lookaside.pSmallFree));
			if ((pHighwater) != null)
				*pHighwater = (int)(db.lookaside.nSlot - nInit);
			return (int)(db.lookaside.nSlot - (nInit + nFree));
		}
		public static void* sqlite3Malloc(ulong n)
		{
			void* p;
			if (((n) == (0)) || ((n) >= (0x7fffff00)))
			{
				p = null;
			}
			else if ((sqlite3Config.bMemstat) != 0)
			{
				sqlite3_mutex_enter(mem0.mutex);
				mallocWithAlarm((int)(n), &p);
				sqlite3_mutex_leave(mem0.mutex);
			}
			else
			{
				p = sqlite3Config.m.xMalloc((int)(n));
			}


			return p;
		}
		public static void sqlite3MallocAlarm(int nByte)
		{
			if ((mem0.alarmThreshold) <= (0))
				return;
			sqlite3_mutex_leave(mem0.mutex);
			sqlite3_release_memory((int)(nByte));
			sqlite3_mutex_enter(mem0.mutex);
		}
		public static void sqlite3MallocEnd()
		{
			if ((sqlite3Config.m.xShutdown) != null)
			{
				sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData);
			}

			CRuntime.memset(&mem0, (int)(0), (ulong)(sizeof(Mem0Global)));
		}
		public static int sqlite3MallocInit()
		{
			int rc = 0;
			if ((sqlite3Config.m.xMalloc) == (null))
			{
				sqlite3MemSetDefault();
			}

			mem0.mutex = sqlite3MutexAlloc((int)(3));
			if ((((sqlite3Config.pPage) == (null)) || ((sqlite3Config.szPage) < (512))) || ((sqlite3Config.nPage) <= (0)))
			{
				sqlite3Config.pPage = null;
				sqlite3Config.szPage = (int)(0);
			}

			rc = (int)(sqlite3Config.m.xInit(sqlite3Config.m.pAppData));
			if (rc != 0)
				CRuntime.memset(&mem0, (int)(0), (ulong)(sizeof(Mem0Global)));
			return (int)(rc);
		}
		public static sqlite3_mutex* sqlite3MallocMutex()
		{
			return mem0.mutex;
		}
		public static int sqlite3MallocSize(void* p)
		{

			return (int)(sqlite3Config.m.xSize(p));
		}
		public static void* sqlite3MallocZero(ulong n)
		{
			void* p = sqlite3Malloc((ulong)(n));
			if ((p) != null)
			{
				CRuntime.memset(p, (int)(0), (ulong)(n));
			}

			return p;
		}
		public static void sqlite3MarkAllShadowTablesOf(sqlite3 db, Table pTab)
		{
			int nName = 0;
			Module pMod;
			HashElem* k;

			pMod = (Module)(sqlite3HashFind(&db.aModule, pTab.u.vtab.azArg[0]));
			if ((pMod) == (null))
				return;
			if (((pMod.pModule) == (null)))
				return;
			if ((pMod.pModule.iVersion) < (3))
				return;
			if ((pMod.pModule.xShadowName) == (null))
				return;

			nName = (int)(sqlite3Strlen30(pTab.zName));
			for (k = ((&pTab.pSchema.tblHash)->first); k; k = ((k)->next))
			{
				Table pOther = ((k)->data);

				if (!(((pOther).eTabType) == (0)))
					continue;
				if ((pOther.tabFlags & 0x00001000) != 0)
					continue;
				if ((((sqlite3_strnicmp(pOther.zName, pTab.zName, (int)(nName))) == (0)) && ((pOther.zName[nName]) == (95))) && ((pMod.pModule.xShadowName(pOther.zName + nName + 1)) != 0))
				{
					pOther.tabFlags |= (uint)(0x00001000);
				}
			}
		}
		public static int sqlite3MatchEName(ExprList_item* pItem, sbyte* zCol, sbyte* zTab, sbyte* zDb)
		{
			int n = 0;
			sbyte* zSpan;
			if (pItem->eEName != 2)
				return (int)(0);
			zSpan = pItem->zEName;
			for (n = (int)(0); ((zSpan[n]) != 0) && (zSpan[n] != 46); n++)
			{
			}

			if (((zDb) != null) && ((sqlite3_strnicmp(zSpan, zDb, (int)(n)) != 0) || (zDb[n] != 0)))
			{
				return (int)(0);
			}

			zSpan += n + 1;
			for (n = (int)(0); ((zSpan[n]) != 0) && (zSpan[n] != 46); n++)
			{
			}

			if (((zTab) != null) && ((sqlite3_strnicmp(zSpan, zTab, (int)(n)) != 0) || (zTab[n] != 0)))
			{
				return (int)(0);
			}

			zSpan += n + 1;
			if (((zCol) != null) && (sqlite3StrICmp(zSpan, zCol) != 0))
			{
				return (int)(0);
			}

			return (int)(1);
		}
		public static void sqlite3MaterializeView(Parse pParse, Table pView, Expr pWhere, ExprList pOrderBy, Expr pLimit, int iCur)
		{
			SelectDest dest = new SelectDest();
			Select pSel;
			SrcList pFrom;
			sqlite3 db = pParse.db;
			int iDb = (int)(sqlite3SchemaToIndex(db, pView.pSchema));
			pWhere = sqlite3ExprDup(db, pWhere, (int)(0));
			pFrom = sqlite3SrcListAppend(pParse, null, null, null);
			if ((pFrom) != null)
			{

				pFrom.a[0].zName = sqlite3DbStrDup(db, pView.zName);
				pFrom.a[0].zDatabase = sqlite3DbStrDup(db, db.aDb[iDb].zDbSName);


			}

			pSel = sqlite3SelectNew(pParse, null, pFrom, pWhere, null, null, pOrderBy, (uint)(0x0020000), pLimit);
			sqlite3SelectDestInit(dest, (int)(12), (int)(iCur));
			sqlite3Select(pParse, pSel, dest);
			sqlite3SelectDelete(db, pSel);
		}
		public static void sqlite3MayAbort(Parse pParse)
		{
			Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			pToplevel.mayAbort = (byte)(1);
		}
		public static int sqlite3MemCompare(sqlite3_value pMem1, sqlite3_value pMem2, CollSeq pColl)
		{
			int f1 = 0; int f2 = 0;
			int combined_flags = 0;
			f1 = (int)(pMem1.flags);
			f2 = (int)(pMem2.flags);
			combined_flags = (int)(f1 | f2);

			if ((combined_flags & 0x0001) != 0)
			{
				return (int)((f2 & 0x0001) - (f1 & 0x0001));
			}

			if ((combined_flags & (0x0004 | 0x0008 | 0x0020)) != 0)
			{
				if ((f1 & f2 & (0x0004 | 0x0020)) != 0)
				{
					if ((pMem1.u.i) < (pMem2.u.i))
						return (int)(-1);
					if ((pMem1.u.i) > (pMem2.u.i))
						return (int)(+1);
					return (int)(0);
				}

				if ((f1 & f2 & 0x0008) != 0)
				{
					if ((pMem1.u.r) < (pMem2.u.r))
						return (int)(-1);
					if ((pMem1.u.r) > (pMem2.u.r))
						return (int)(+1);
					return (int)(0);
				}

				if ((f1 & (0x0004 | 0x0020)) != 0)
				{
					if ((f2 & 0x0008) != 0)
					{
						return (int)(sqlite3IntFloatCompare((long)(pMem1.u.i), (double)(pMem2.u.r)));
					}
					else if ((f2 & (0x0004 | 0x0020)) != 0)
					{
						if ((pMem1.u.i) < (pMem2.u.i))
							return (int)(-1);
						if ((pMem1.u.i) > (pMem2.u.i))
							return (int)(+1);
						return (int)(0);
					}
					else
					{
						return (int)(-1);
					}
				}

				if ((f1 & 0x0008) != 0)
				{
					if ((f2 & (0x0004 | 0x0020)) != 0)
					{
						return (int)(-sqlite3IntFloatCompare((long)(pMem2.u.i), (double)(pMem1.u.r)));
					}
					else
					{
						return (int)(-1);
					}
				}

				return (int)(+1);
			}

			if ((combined_flags & 0x0002) != 0)
			{
				if ((f1 & 0x0002) == (0))
				{
					return (int)(1);
				}

				if ((f2 & 0x0002) == (0))
				{
					return (int)(-1);
				}




				if ((pColl) != null)
				{
					return (int)(vdbeCompareMemString(pMem1, pMem2, pColl, null));
				}
			}

			return (int)(sqlite3BlobCompare(pMem1, pMem2));
		}
		public static int sqlite3MemdbInit()
		{
			sqlite3_vfs pLower = sqlite3_vfs_find(null);
			uint sz = 0;
			if (((pLower) == (null)))
				return (int)(1);
			sz = (uint)(pLower.szOsFile);
			memdb_vfs.pAppData = pLower;
			if ((sz) < (sizeof(MemFile)))
				sz = (uint)(sizeof(MemFile));
			memdb_vfs.szOsFile = (int)(sz);
			return (int)(sqlite3_vfs_register(memdb_vfs, (int)(0)));
		}
		public static void sqlite3MemFree(void* pPrior)
		{
			CRuntime.free(pPrior);
		}
		public static int sqlite3MemInit(void* NotUsed)
		{
			(void)(NotUsed);
			return (int)(0);
		}
		public static void sqlite3MemJournalOpen(sqlite3_file pJfd)
		{
			sqlite3JournalOpen(null, null, pJfd, (int)(0), (int)(-1));
		}
		public static void* sqlite3MemMalloc(int nByte)
		{
			void* p;
			p = CRuntime.malloc((ulong)(nByte));
			if ((p) == (null))
			{
				sqlite3_log((int)(7), "failed to allocate %u bytes of memory", (int)(nByte));
			}

			return p;
		}
		public static void sqlite3MemoryBarrier()
		{
			_ReadWriteBarrier();
		}
		public static void* sqlite3MemRealloc(void* pPrior, int nByte)
		{
			void* p = CRuntime.realloc((pPrior), (ulong)(nByte));
			if ((p) == (null))
			{
				sqlite3_log((int)(7), "failed memory resize %u to %u bytes", (ulong)(_msize(pPrior)), (int)(nByte));
			}

			return p;
		}
		public static int sqlite3MemRoundup(int n)
		{
			return (int)(((n) + 7) & ~7);
		}
		public static void sqlite3MemSetDefault()
		{
			sqlite3_config((int)(4), sqlite3MemSetDefault_defaultMethods);
		}
		public static void sqlite3MemShutdown(void* NotUsed)
		{
			(void)(NotUsed);
			return;
		}
		public static int sqlite3MemSize(void* pPrior)
		{

			return (int)(_msize(pPrior));
		}
		public static int sqlite3MisuseError(int lineno)
		{
			return (int)(sqlite3ReportError((int)(21), (int)(lineno), "misuse"));
		}
		public static sbyte* sqlite3MPrintf(sqlite3 db, sbyte* zFormat)
		{
			sbyte* ap;
			sbyte* z;
			(__va_start(&ap, zFormat));
			z = sqlite3VMPrintf(db, zFormat, ap);
			((void)(ap = null));
			return z;
		}
		public static int sqlite3MulInt64(long* pA, long iB)
		{
			long iA = (long)(*pA);
			if ((iB) > (0))
			{
				if ((iA) > ((0xffffffff | (((long)(0x7fffffff)) << 32)) / iB))
					return (int)(1);
				if ((iA) < ((((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) / iB))
					return (int)(1);
			}
			else if ((iB) < (0))
			{
				if ((iA) > (0))
				{
					if ((iB) < ((((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))) / iA))
						return (int)(1);
				}
				else if ((iA) < (0))
				{
					if ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
						return (int)(1);
					if ((iA) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
						return (int)(1);
					if ((-iA) > ((0xffffffff | (((long)(0x7fffffff)) << 32)) / -iB))
						return (int)(1);
				}
			}

			*pA = (long)(iA * iB);
			return (int)(0);
		}
		public static void sqlite3MultiWrite(Parse pParse)
		{
			Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			pToplevel.isMultiWrite = (byte)(1);
		}
		public static sqlite3_mutex* sqlite3MutexAlloc(int id)
		{
			if (sqlite3Config.bCoreMutex == 0)
			{
				return null;
			}



			return sqlite3Config.mutex.xMutexAlloc((int)(id));
		}
		public static int sqlite3MutexEnd()
		{
			int rc = (int)(0);
			if ((sqlite3Config.mutex.xMutexEnd) != null)
			{
				rc = (int)(sqlite3Config.mutex.xMutexEnd());
			}

			return (int)(rc);
		}
		public static int sqlite3MutexInit()
		{
			int rc = (int)(0);
			if (sqlite3Config.mutex.xMutexAlloc == null)
			{
				sqlite3_mutex_methods pFrom;
				sqlite3_mutex_methods pTo = sqlite3Config.mutex;
				if ((sqlite3Config.bCoreMutex) != 0)
				{
					pFrom = sqlite3DefaultMutex();
				}
				else
				{
					pFrom = sqlite3NoopMutex();
				}

				pTo.xMutexInit = pFrom.xMutexInit;
				pTo.xMutexEnd = pFrom.xMutexEnd;
				pTo.xMutexFree = pFrom.xMutexFree;
				pTo.xMutexEnter = pFrom.xMutexEnter;
				pTo.xMutexTry = pFrom.xMutexTry;
				pTo.xMutexLeave = pFrom.xMutexLeave;
				pTo.xMutexHeld = pFrom.xMutexHeld;
				pTo.xMutexNotheld = pFrom.xMutexNotheld;
				sqlite3MemoryBarrier();
				pTo.xMutexAlloc = pFrom.xMutexAlloc;
			}


			rc = (int)(sqlite3Config.mutex.xMutexInit());
			sqlite3MemoryBarrier();
			return (int)(rc);
		}
		public static sbyte* sqlite3NameFromToken(sqlite3 db, Token* pName)
		{
			sbyte* zName;
			if ((pName) != null)
			{
				zName = sqlite3DbStrNDup(db, pName->z, (ulong)(pName->n));
				sqlite3Dequote(zName);
			}
			else
			{
				zName = null;
			}

			return zName;
		}
		public static void sqlite3NestedParse(Parse pParse, sbyte* zFormat)
		{
			sbyte* ap;
			sbyte* zSql;
			sqlite3 db = pParse.db;
			uint savedDbFlags = (uint)(db.mDbFlags);
			char[(sizeof(Parse) - ((size_t) & (((Parse*)0)->sLastToken)))] saveBuf = (char[(sizeof(Parse) - ((size_t) & (((Parse*)0)->sLastToken)))])(sizeof(Parse) - ((ulong)(&((0).sLastToken))));
			if ((pParse.nErr) != 0)
				return;

			(__va_start(&ap, zFormat));
			zSql = sqlite3VMPrintf(db, zFormat, ap);
			((void)(ap = null));
			if ((zSql) == (null))
			{
				if (db.mallocFailed == 0)
					pParse.rc = (int)(18);
				pParse.nErr++;
				return;
			}

			pParse.nested++;
			CRuntime.memcpy(saveBuf, (((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
			CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
			db.mDbFlags |= (uint)(0x0002);
			sqlite3RunParser(pParse, zSql);
			sqlite3DbFree(db, pParse.zErrMsg);
			pParse.zErrMsg = null;
			db.mDbFlags = (uint)(savedDbFlags);
			sqlite3DbFree(db, zSql);
			CRuntime.memcpy((((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), saveBuf, (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
			pParse.nested--;
		}
		public static void sqlite3NoopDestructor(void* p)
		{
			(void)(p);
		}
		public static sqlite3_mutex_methods sqlite3NoopMutex()
		{
			return sqlite3NoopMutex_sMutex;
		}
		public static int sqlite3NotPureFunc(sqlite3_context pCtx)
		{
			VdbeOp* pOp;
			pOp = pCtx.pVdbe.aOp + pCtx.iOp;
			if ((pOp->opcode) == (65))
			{
				sbyte* zContext;
				sbyte* zMsg;
				if ((pOp->p5 & 0x000004) != 0)
				{
					zContext = "a CHECK constraint";
				}
				else if ((pOp->p5 & 0x000008) != 0)
				{
					zContext = "a generated column";
				}
				else
				{
					zContext = "an index";
				}

				zMsg = sqlite3_mprintf("non-deterministic use of %s() in %s", pCtx.pFunc.zName, zContext);
				sqlite3_result_error(pCtx, zMsg, (int)(-1));
				sqlite3_free(zMsg);
				return (int)(0);
			}

			return (int)(1);
		}
		public static void sqlite3OomClear(sqlite3 db)
		{
			if (((db.mallocFailed) != 0) && ((db.nVdbeExec) == (0)))
			{
				db.mallocFailed = (byte)(0);
				(0);

				db.lookaside.bDisable--;
				db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
			}
		}
		public static void* sqlite3OomFault(sqlite3 db)
		{
			if (((db.mallocFailed) == (0)) && ((db.bBenignMalloc) == (0)))
			{
				db.mallocFailed = (byte)(1);
				if ((db.nVdbeExec) > (0))
				{
					(1);
				}

				db.lookaside.bDisable++;
				db.lookaside.sz = (ushort)(0);
				if ((db.pParse) != null)
				{
					sqlite3ErrorMsg(db.pParse, "out of memory");
					db.pParse.rc = (int)(7);
				}
			}

			return null;
		}
		public static sbyte* sqlite3OpcodeName(int i)
		{
			return sqlite3OpcodeName_azName[i];
		}
		public static void sqlite3OpenSchemaTable(Parse p, int iDb)
		{
			Vdbe v = sqlite3GetVdbe(p);
			sqlite3TableLock(p, (int)(iDb), (uint)(1), (byte)(1), "sqlite_master");
			sqlite3VdbeAddOp4Int(v, (int)(112), (int)(0), (int)(1), (int)(iDb), (int)(5));
			if ((p.nTab) == (0))
			{
				p.nTab = (int)(1);
			}
		}
		public static void sqlite3OpenTable(Parse pParse, int iCur, int iDb, Table pTab, int opcode)
		{
			Vdbe v;


			v = pParse.pVdbe;

			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(((opcode) == (112)) ? 1 : 0), pTab.zName);
			if ((((pTab).tabFlags & 0x00000080) == (0)))
			{
				sqlite3VdbeAddOp4Int(v, (int)(opcode), (int)(iCur), (int)(pTab.tnum), (int)(iDb), (int)(pTab.nNVCol));
			}
			else
			{
				Index pPk = sqlite3PrimaryKeyIndex(pTab);


				sqlite3VdbeAddOp3(v, (int)(opcode), (int)(iCur), (int)(pPk.tnum), (int)(iDb));
				sqlite3VdbeSetP4KeyInfo(pParse, pPk);
			}
		}
		public static int sqlite3OpenTableAndIndices(Parse pParse, Table pTab, int op, byte p5, int iBase, byte* aToOpen, int* piDataCur, int* piIdxCur)
		{
			int i = 0;
			int iDb = 0;
			int iDataCur = 0;
			Index pIdx;
			Vdbe v;


			if ((((pTab).eTabType) == (1)))
			{
				*piDataCur = (int)(*piIdxCur = (int)(-999));
				return (int)(0);
			}

			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
			v = pParse.pVdbe;

			if ((iBase) < (0))
				iBase = (int)(pParse.nTab);
			iDataCur = (int)(iBase++);
			if ((piDataCur) != null)
				*piDataCur = (int)(iDataCur);
			if ((((pTab).tabFlags & 0x00000080) == (0)) && (((aToOpen) == (null)) || ((aToOpen[0]) != 0)))
			{
				sqlite3OpenTable(pParse, (int)(iDataCur), (int)(iDb), pTab, (int)(op));
			}
			else
			{
				sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)((op) == (112)), pTab.zName);
			}

			if ((piIdxCur) != null)
				*piIdxCur = (int)(iBase);
			for (i = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, i++)
			{
				int iIdxCur = (int)(iBase++);

				if ((((pIdx).idxType) == (2)) && (!(((pTab).tabFlags & 0x00000080) == (0))))
				{
					if ((piDataCur) != null)
						*piDataCur = (int)(iIdxCur);
					p5 = (byte)(0);
				}

				if (((aToOpen) == (null)) || ((aToOpen[i + 1]) != 0))
				{
					sqlite3VdbeAddOp3(v, (int)(op), (int)(iIdxCur), (int)(pIdx.tnum), (int)(iDb));
					sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
					sqlite3VdbeChangeP5(v, (ushort)(p5));
				}
			}

			if ((iBase) > (pParse.nTab))
				pParse.nTab = (int)(iBase);
			return (int)(i);
		}
		public static int sqlite3OpenTempDatabase(Parse pParse)
		{
			sqlite3 db = pParse.db;
			if (((db.aDb[1].pBt) == (null)) && (pParse.explain == 0))
			{
				int rc = 0;
				Btree pBt;
				rc = (int)(sqlite3BtreeOpen(db.pVfs, null, db, pBt, (int)(0), (int)(sqlite3OpenTempDatabase_flags)));
				if (rc != 0)
				{
					sqlite3ErrorMsg(pParse, "unable to open a temporary database file for storing temporary tables");
					pParse.rc = (int)(rc);
					return (int)(1);
				}

				db.aDb[1].pBt = pBt;

				if ((7) == (sqlite3BtreeSetPageSize(pBt, (int)(db.nextPagesize), (int)(0), (int)(0))))
				{
					sqlite3OomFault(db);
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int sqlite3OsAccess(sqlite3_vfs pVfs, sbyte* zPath, int flags, int* pResOut)
		{
			return (int)(pVfs.xAccess(pVfs, zPath, (int)(flags), pResOut));
		}
		public static int sqlite3OsCheckReservedLock(sqlite3_file id, int* pResOut)
		{
			return (int)(id.pMethods.xCheckReservedLock(id, pResOut));
		}
		public static void sqlite3OsClose(sqlite3_file pId)
		{
			if ((pId.pMethods) != null)
			{
				pId.pMethods.xClose(pId);
				pId.pMethods = null;
			}
		}
		public static void sqlite3OsCloseFree(sqlite3_file pFile)
		{

			sqlite3OsClose(pFile);
			sqlite3_free(pFile);
		}
		public static int sqlite3OsCurrentTimeInt64(sqlite3_vfs pVfs, long* pTimeOut)
		{
			int rc = 0;
			if (((pVfs.iVersion) >= (2)) && ((pVfs.xCurrentTimeInt64) != null))
			{
				rc = (int)(pVfs.xCurrentTimeInt64(pVfs, pTimeOut));
			}
			else
			{
				double r = 0;
				rc = (int)(pVfs.xCurrentTime(pVfs, &r));
				*pTimeOut = ((long)(r * 86400000.0));
			}

			return (int)(rc);
		}
		public static int sqlite3OsDelete(sqlite3_vfs pVfs, sbyte* zPath, int dirSync)
		{

			return (int)(pVfs.xDelete != null ? pVfs.xDelete(pVfs, zPath, (int)(dirSync)) : 0);
		}
		public static int sqlite3OsDeviceCharacteristics(sqlite3_file id)
		{
			if (((id.pMethods) == (null)))
				return (int)(0);
			return (int)(id.pMethods.xDeviceCharacteristics(id));
		}
		public static void sqlite3OsDlClose(sqlite3_vfs pVfs, void* pHandle)
		{
			pVfs.xDlClose(pVfs, pHandle);
		}
		public static void sqlite3OsDlError(sqlite3_vfs pVfs, int nByte, sbyte* zBufOut)
		{
			pVfs.xDlError(pVfs, (int)(nByte), zBufOut);
		}
		public static void* sqlite3OsDlOpen(sqlite3_vfs pVfs, sbyte* zPath)
		{


			return pVfs.xDlOpen(pVfs, zPath);
		}
		public static Void()sqlite3OsDlSym(sqlite3_vfs pVfs, void* pHdle, sbyte* zSym)
		{
			return pVfs.xDlSym(pVfs, pHdle, zSym);
		}
		public static int sqlite3OsFetch(sqlite3_file id, long iOff, int iAmt, void** pp)
		{
			return (int)(id.pMethods.xFetch(id, (long)(iOff), (int)(iAmt), pp));
		}
		public static int sqlite3OsFileControl(sqlite3_file id, int op, void* pArg)
		{
			if ((id.pMethods) == (null))
				return (int)(12);
			return (int)(id.pMethods.xFileControl(id, (int)(op), pArg));
		}
		public static void sqlite3OsFileControlHint(sqlite3_file id, int op, void* pArg)
		{
			if ((id.pMethods) != null)
				(void)(id.pMethods.xFileControl(id, (int)(op), pArg));
		}
		public static int sqlite3OsFileSize(sqlite3_file id, long* pSize)
		{
			return (int)(id.pMethods.xFileSize(id, pSize));
		}
		public static int sqlite3OsFullPathname(sqlite3_vfs pVfs, sbyte* zPath, int nPathOut, sbyte* zPathOut)
		{
			zPathOut[0] = (sbyte)(0);
			return (int)(pVfs.xFullPathname(pVfs, zPath, (int)(nPathOut), zPathOut));
		}
		public static int sqlite3OsGetLastError(sqlite3_vfs pVfs)
		{
			return (int)(pVfs.xGetLastError ? pVfs.xGetLastError(pVfs, (int)(0), null) : 0);
		}
		public static int sqlite3OsInit()
		{
			void* p = sqlite3_malloc((int)(10));
			if ((p) == (null))
				return (int)(7);
			sqlite3_free(p);
			return (int)(sqlite3_os_init());
		}
		public static int sqlite3OsLock(sqlite3_file id, int lockType)
		{
			return (int)(id.pMethods.xLock(id, (int)(lockType)));
		}
		public static int sqlite3OsOpen(sqlite3_vfs pVfs, sbyte* zPath, sqlite3_file pFile, int flags, int* pFlagsOut)
		{
			int rc = 0;
			rc = (int)(pVfs.xOpen(pVfs, zPath, pFile, (int)(flags & 0x1087f7f), pFlagsOut));

			return (int)(rc);
		}
		public static int sqlite3OsOpenMalloc(sqlite3_vfs pVfs, sbyte* zFile, sqlite3_file ppFile, int flags, int* pOutFlags)
		{
			int rc = 0;
			sqlite3_file pFile;
			pFile = (sqlite3_file)(sqlite3MallocZero((ulong)(pVfs.szOsFile)));
			if ((pFile) != null)
			{
				rc = (int)(sqlite3OsOpen(pVfs, zFile, pFile, (int)(flags), pOutFlags));
				if (rc != 0)
				{
					sqlite3_free(pFile);
					ppFile = null;
				}
				else
				{
					ppFile = pFile;
				}
			}
			else
			{
				ppFile = null;
				rc = (int)(7);
			}


			return (int)(rc);
		}
		public static int sqlite3OsRandomness(sqlite3_vfs pVfs, int nByte, sbyte* zBufOut)
		{
			if ((sqlite3Config.iPrngSeed) != 0)
			{
				CRuntime.memset(zBufOut, (int)(0), (ulong)(nByte));
				if (((nByte) > ((int)(sizeof(unsigned)))))
					nByte = (int)(sizeof(unsignedint));
				CRuntime.memcpy(zBufOut, &sqlite3Config.iPrngSeed, (ulong)(nByte));
				return (int)(0);
			}
			else
			{
				return (int)(pVfs.xRandomness(pVfs, (int)(nByte), zBufOut));
			}
		}
		public static int sqlite3OsRead(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			return (int)(id.pMethods.xRead(id, pBuf, (int)(amt), (long)(offset)));
		}
		public static int sqlite3OsSectorSize(sqlite3_file id)
		{
			delegate0 xSectorSize = id.pMethods.xSectorSize;
			return (int)(xSectorSize ? xSectorSize(id) : 4096);
		}
		public static void sqlite3OsShmBarrier(sqlite3_file id)
		{
			id.pMethods.xShmBarrier(id);
		}
		public static int sqlite3OsShmLock(sqlite3_file id, int offset, int n, int flags)
		{
			return (int)(id.pMethods.xShmLock(id, (int)(offset), (int)(n), (int)(flags)));
		}
		public static int sqlite3OsShmMap(sqlite3_file id, int iPage, int pgsz, int bExtend, void** pp)
		{
			return (int)(id.pMethods.xShmMap(id, (int)(iPage), (int)(pgsz), (int)(bExtend), pp));
		}
		public static int sqlite3OsShmUnmap(sqlite3_file id, int deleteFlag)
		{
			return (int)(id.pMethods.xShmUnmap(id, (int)(deleteFlag)));
		}
		public static int sqlite3OsSleep(sqlite3_vfs pVfs, int nMicro)
		{
			return (int)(pVfs.xSleep(pVfs, (int)(nMicro)));
		}
		public static int sqlite3OsSync(sqlite3_file id, int flags)
		{
			return (int)((flags) != 0 ? id.pMethods.xSync(id, (int)(flags)) : 0);
		}
		public static int sqlite3OsTruncate(sqlite3_file id, long size)
		{
			return (int)(id.pMethods.xTruncate(id, (long)(size)));
		}
		public static int sqlite3OsUnfetch(sqlite3_file id, long iOff, void* p)
		{
			return (int)(id.pMethods.xUnfetch(id, (long)(iOff), p));
		}
		public static int sqlite3OsUnlock(sqlite3_file id, int lockType)
		{
			return (int)(id.pMethods.xUnlock(id, (int)(lockType)));
		}
		public static int sqlite3OsWrite(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			return (int)(id.pMethods.xWrite(id, pBuf, (int)(amt), (long)(offset)));
		}
		public static void sqlite3PageFree(void* p)
		{
			pcache1Free(p);
		}
		public static void* sqlite3PageMalloc(int sz)
		{

			return pcache1Alloc((int)(sz));
		}
		public static sqlite3_backup sqlite3PagerBackupPtr(Pager pPager)
		{
			return pPager.pBackup;
		}
		public static int sqlite3PagerBegin(Pager pPager, int exFlag, int subjInMemory)
		{
			int rc = (int)(0);
			if ((pPager.errCode) != 0)
				return (int)(pPager.errCode);

			pPager.subjInMemory = ((byte)(subjInMemory));
			if ((pPager.eState) == (1))
			{

				if (((pPager).pWal != null))
				{
					if (((pPager.exclusiveMode) != 0) && ((sqlite3WalExclusiveMode(pPager.pWal, (int)(-1))) != 0))
					{
						rc = (int)(pagerLockDb(pPager, (int)(4)));
						if (rc != 0)
						{
							return (int)(rc);
						}

						(void)(sqlite3WalExclusiveMode(pPager.pWal, (int)(1)));
					}

					rc = (int)(sqlite3WalBeginWriteTransaction(pPager.pWal));
				}
				else
				{
					rc = (int)(pagerLockDb(pPager, (int)(2)));
					if (((rc) == (0)) && ((exFlag) != 0))
					{
						rc = (int)(pager_wait_on_lock(pPager, (int)(4)));
					}
				}

				if ((rc) == (0))
				{
					pPager.eState = (byte)(2);
					pPager.dbHintSize = (uint)(pPager.dbSize);
					pPager.dbFileSize = (uint)(pPager.dbSize);
					pPager.dbOrigSize = (uint)(pPager.dbSize);
					pPager.journalOff = (long)(0);
				}




			}

			return (int)(rc);
		}
		public static void sqlite3PagerCacheStat(Pager pPager, int eStat, int reset, int* pnVal)
		{




			eStat -= (int)(7);
			*pnVal += (int)(pPager.aStat[eStat]);
			if ((reset) != 0)
			{
				pPager.aStat[eStat] = (int)(0);
			}
		}
		public static int sqlite3PagerCheckpoint(Pager pPager, sqlite3 db, int eMode, int* pnLog, int* pnCkpt)
		{
			int rc = (int)(0);
			if (((pPager.pWal) == (null)) && ((pPager.journalMode) == (5)))
			{
				sqlite3_exec(db, "PRAGMA table_list", null, null, null);
			}

			if ((pPager.pWal) != null)
			{
				rc = (int)(sqlite3WalCheckpoint(pPager.pWal, db, (int)(eMode), ((eMode) == (0) ? null : pPager.xBusyHandler), pPager.pBusyHandlerArg, (int)(pPager.walSyncFlags), (int)(pPager.pageSize), (byte*)(pPager.pTmpSpace), pnLog, pnCkpt));
			}

			return (int)(rc);
		}
		public static void sqlite3PagerClearCache(Pager pPager)
		{

			if ((pPager.tempFile) == (0))
				pager_reset(pPager);
		}
		public static int sqlite3PagerClose(Pager pPager, sqlite3 db)
		{
			byte* pTmp = (byte*)(pPager.pTmpSpace);


			sqlite3BeginBenignMalloc();
			pagerFreeMapHdrs(pPager);
			pPager.exclusiveMode = (byte)(0);
			{
				byte* a = null;

				if ((((db) != null) && ((0) == (db.flags & 0x00000800))) && ((0) == (databaseIsUnmoved(pPager))))
				{
					a = pTmp;
				}

				sqlite3WalClose(pPager.pWal, db, (int)(pPager.walSyncFlags), (int)(pPager.pageSize), a);
				pPager.pWal = null;
			}

			pager_reset(pPager);
			if ((pPager.memDb) != 0)
			{
				pager_unlock(pPager);
			}
			else
			{
				if (((pPager.jfd).pMethods != null))
				{
					pager_error(pPager, (int)(pagerSyncHotJournal(pPager)));
				}

				pagerUnlockAndRollback(pPager);
			}

			sqlite3EndBenignMalloc();
			sqlite3OsClose(pPager.jfd);
			sqlite3OsClose(pPager.fd);
			sqlite3PageFree(pTmp);
			sqlite3PcacheClose(pPager.pPCache);


			sqlite3_free(pPager);
			return (int)(0);
		}
		public static int sqlite3PagerCloseWal(Pager pPager, sqlite3 db)
		{
			int rc = (int)(0);

			if (pPager.pWal == null)
			{
				int logexists = (int)(0);
				rc = (int)(pagerLockDb(pPager, (int)(1)));
				if ((rc) == (0))
				{
					rc = (int)(sqlite3OsAccess(pPager.pVfs, pPager.zWal, (int)(0), &logexists));
				}

				if (((rc) == (0)) && ((logexists) != 0))
				{
					rc = (int)(pagerOpenWal(pPager));
				}
			}

			if (((rc) == (0)) && ((pPager.pWal) != null))
			{
				rc = (int)(pagerExclusiveLock(pPager));
				if ((rc) == (0))
				{
					rc = (int)(sqlite3WalClose(pPager.pWal, db, (int)(pPager.walSyncFlags), (int)(pPager.pageSize), (byte*)(pPager.pTmpSpace)));
					pPager.pWal = null;
					pagerFixMaplimit(pPager);
					if (((rc) != 0) && (pPager.exclusiveMode == 0))
						pagerUnlockDb(pPager, (int)(1));
				}
			}

			return (int)(rc);
		}
		public static int sqlite3PagerCommitPhaseOne(Pager pPager, sbyte* zSuper, int noSync)
		{
			int rc = (int)(0);


			if ((pPager.errCode) != 0)
				return (int)(pPager.errCode);
			if ((sqlite3FaultSim((int)(400))) != 0)
				return (int)(10);
			if ((pPager.eState) < (3))
				return (int)(0);


			if ((0) == (pagerFlushOnCommit(pPager, (int)(1))))
			{
				sqlite3BackupRestart(pPager.pBackup);
			}
			else
			{
				PgHdr pList;
				if (((pPager).pWal != null))
				{
					PgHdr pPageOne = null;
					pList = sqlite3PcacheDirtyList(pPager.pPCache);
					if ((pList) == (null))
					{
						rc = (int)(sqlite3PagerGet(pPager, (uint)(1), pPageOne, (int)(0)));
						pList = pPageOne;
						pList.pDirty = null;
					}


					if ((pList) != null)
					{
						rc = (int)(pagerWalFrames(pPager, pList, (uint)(pPager.dbSize), (int)(1)));
					}

					sqlite3PagerUnref(pPageOne);
					if ((rc) == (0))
					{
						sqlite3PcacheCleanAll(pPager.pPCache);
					}
				}
				else
				{
					rc = (int)(pager_incr_changecounter(pPager, (int)(0)));
					if (rc != 0)
						goto commit_phase_one_exit;
					rc = (int)(writeSuperJournal(pPager, zSuper));
					if (rc != 0)
						goto commit_phase_one_exit;
					rc = (int)(syncJournal(pPager, (int)(0)));
					if (rc != 0)
						goto commit_phase_one_exit;
					pList = sqlite3PcacheDirtyList(pPager.pPCache);
					if ((0) == (0))
					{
						rc = (int)(pager_write_pagelist(pPager, pList));
					}

					if (rc != 0)
					{

						goto commit_phase_one_exit;
					}

					sqlite3PcacheCleanAll(pPager.pPCache);
					if ((pPager.dbSize) > (pPager.dbFileSize))
					{
						uint nNew = (uint)(pPager.dbSize - ((pPager.dbSize) == ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1))));

						rc = (int)(pager_truncate(pPager, (uint)(nNew)));
						if (rc != 0)
							goto commit_phase_one_exit;
					}

					if (noSync == 0)
					{
						rc = (int)(sqlite3PagerSync(pPager, zSuper));
					}
				}
			}

		commit_phase_one_exit:
			; if (((rc) == (0)) && (!((pPager).pWal != null))) { pPager.eState = (byte)(5); }
			return (int)(rc);
		}
		public static int sqlite3PagerCommitPhaseTwo(Pager pPager)
		{
			int rc = (int)(0);
			if ((pPager.errCode) != 0)
				return (int)(pPager.errCode);
			pPager.iDataVersion++;


			if ((((pPager.eState) == (2)) && ((pPager.exclusiveMode) != 0)) && ((pPager.journalMode) == (1)))
			{

				pPager.eState = (byte)(1);
				return (int)(0);
			}

			rc = (int)(pager_end_transaction(pPager, (int)(pPager.setSuper), (int)(1)));
			return (int)(pager_error(pPager, (int)(rc)));
		}
		public static uint sqlite3PagerDataVersion(Pager pPager)
		{
			return (uint)(pPager.iDataVersion);
		}
		public static void sqlite3PagerDontWrite(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;
			if (((pPager.tempFile == 0) && ((pPg.flags & 0x002) != 0)) && ((pPager.nSavepoint) == (0)))
			{
				pPg.flags |= (ushort)(0x010);
				pPg.flags &= (ushort)(~0x004);
			}
		}
		public static int sqlite3PagerExclusiveLock(Pager pPager)
		{
			int rc = (int)(pPager.errCode);

			if ((rc) == (0))
			{


				if ((0) == ((pPager).pWal != null))
				{
					rc = (int)(pager_wait_on_lock(pPager, (int)(4)));
				}
			}

			return (int)(rc);
		}
		public static sqlite3_file sqlite3PagerFile(Pager pPager)
		{
			return pPager.fd;
		}
		public static sbyte* sqlite3PagerFilename(Pager pPager, int nullIfMemDb)
		{
			return (((nullIfMemDb) != 0) && ((pPager.memDb) != 0)) ? &sqlite3PagerFilename_zFake[4] : pPager.zFilename;
		}
		public static int sqlite3PagerFlush(Pager pPager)
		{
			int rc = (int)(pPager.errCode);
			if (pPager.memDb == 0)
			{
				PgHdr pList = sqlite3PcacheDirtyList(pPager.pPCache);

				while (((rc) == (0)) && ((pList) != null))
				{
					PgHdr pNext = pList.pDirty;
					if ((pList.nRef) == (0))
					{
						rc = (int)(pagerStress((void*)(pPager), pList));
					}

					pList = pNext;
				}
			}

			return (int)(rc);
		}
		public static int sqlite3PagerGet(Pager pPager, uint pgno, PgHdr ppPage, int flags)
		{
			return (int)(pPager.xGet(pPager, (uint)(pgno), ppPage, (int)(flags)));
		}
		public static void* sqlite3PagerGetData(PgHdr pPg)
		{

			return pPg.pData;
		}
		public static void* sqlite3PagerGetExtra(PgHdr pPg)
		{
			return pPg.pExtra;
		}
		public static int sqlite3PagerGetJournalMode(Pager pPager)
		{
			return (int)(pPager.journalMode);
		}
		public static int sqlite3PagerIsMemdb(Pager pPager)
		{
			return (((pPager.tempFile) != 0) || ((pPager.memVfs) != 0) ? 1 : 0);
		}
		public static byte sqlite3PagerIsreadonly(Pager pPager)
		{
			return (byte)(pPager.readOnly);
		}
		public static sbyte* sqlite3PagerJournalname(Pager pPager)
		{
			return pPager.zJournal;
		}
		public static long sqlite3PagerJournalSizeLimit(Pager pPager, long iLimit)
		{
			if ((iLimit) >= (-1))
			{
				pPager.journalSizeLimit = (long)(iLimit);
				sqlite3WalLimit(pPager.pWal, (long)(iLimit));
			}

			return (long)(pPager.journalSizeLimit);
		}
		public static sqlite3_file sqlite3PagerJrnlFile(Pager pPager)
		{
			return pPager.pWal ? sqlite3WalFile(pPager.pWal) : pPager.jfd;
		}
		public static int sqlite3PagerLockingMode(Pager pPager, int eMode)
		{




			if ((((eMode) >= (0)) && (pPager.tempFile == 0)) && (sqlite3WalHeapMemory(pPager.pWal) == 0))
			{
				pPager.exclusiveMode = ((byte)(eMode));
			}

			return (int)(pPager.exclusiveMode);
		}
		public static PgHdr sqlite3PagerLookup(Pager pPager, uint pgno)
		{
			sqlite3_pcache_page* pPage;



			pPage = sqlite3PcacheFetch(pPager.pPCache, (uint)(pgno), (int)(0));

			if ((pPage) == (null))
				return null;
			return sqlite3PcacheFetchFinish(pPager.pPCache, (uint)(pgno), pPage);
		}
		public static uint sqlite3PagerMaxPageCount(Pager pPager, uint mxPage)
		{
			if ((mxPage) > (0))
			{
				pPager.mxPgno = (uint)(mxPage);
			}


			return (uint)(pPager.mxPgno);
		}
		public static int sqlite3PagerMemUsed(Pager pPager)
		{
			int perPageSize = (int)(pPager.pageSize + pPager.nExtra + (int)(sizeof(PgHdr) + 5 * sizeof(void*)));
			return (int)(perPageSize * sqlite3PcachePagecount(pPager.pPCache) + sqlite3MallocSize(pPager) + pPager.pageSize);
		}
		public static int sqlite3PagerMovepage(Pager pPager, PgHdr pPg, uint pgno, int isCommit)
		{
			PgHdr pPgOld;
			uint needSyncPgno = (uint)(0);
			int rc = 0;
			uint origPgno = 0;




			if ((pPager.tempFile) != 0)
			{
				rc = (int)(sqlite3PagerWrite(pPg));
				if ((rc) != 0)
					return (int)(rc);
			}

			if (((pPg.flags & 0x002) != 0) && (0 != (rc = (int)(subjournalPageIfRequired(pPg)))))
			{
				return (int)(rc);
			}

			if (((pPg.flags & 0x008) != 0) && (isCommit == 0))
			{
				needSyncPgno = (uint)(pPg.pgno);


			}

			pPg.flags &= (ushort)(~0x008);
			pPgOld = sqlite3PagerLookup(pPager, (uint)(pgno));

			if ((pPgOld) != null)
			{
				if (((pPgOld.nRef) > (1)))
				{
					sqlite3PagerUnrefNotNull(pPgOld);
					return (int)(sqlite3CorruptError((int)(60360)));
				}

				pPg.flags |= (ushort)(pPgOld.flags & 0x008);
				if ((pPager.tempFile) != 0)
				{
					sqlite3PcacheMove(pPgOld, (uint)(pPager.dbSize + 1));
				}
				else
				{
					sqlite3PcacheDrop(pPgOld);
				}
			}

			origPgno = (uint)(pPg.pgno);
			sqlite3PcacheMove(pPg, (uint)(pgno));
			sqlite3PcacheMakeDirty(pPg);
			if (((pPager.tempFile) != 0) && ((pPgOld) != null))
			{
				sqlite3PcacheMove(pPgOld, (uint)(origPgno));
				sqlite3PagerUnrefNotNull(pPgOld);
			}

			if ((needSyncPgno) != 0)
			{
				PgHdr pPgHdr;
				rc = (int)(sqlite3PagerGet(pPager, (uint)(needSyncPgno), pPgHdr, (int)(0)));
				if (rc != 0)
				{
					if ((needSyncPgno) <= (pPager.dbOrigSize))
					{

						sqlite3BitvecClear(pPager.pInJournal, (uint)(needSyncPgno), pPager.pTmpSpace);
					}

					return (int)(rc);
				}

				pPgHdr.flags |= (ushort)(0x008);
				sqlite3PcacheMakeDirty(pPgHdr);
				sqlite3PagerUnrefNotNull(pPgHdr);
			}

			return (int)(0);
		}
		public static int sqlite3PagerOkToChangeJournalMode(Pager pPager)
		{

			if ((pPager.eState) >= (3))
				return (int)(0);
			if ((((pPager.jfd).pMethods != null) && ((pPager.journalOff) > (0))))
				return (int)(0);
			return (int)(1);
		}
		public static int sqlite3PagerOpen(sqlite3_vfs pVfs, Pager ppPager, sbyte* zFilename, int nExtra, int flags, int vfsFlags, delegate75 xReinit)
		{
			byte* pPtr;
			Pager pPager = null;
			int rc = (int)(0);
			int tempFile = (int)(0);
			int memDb = (int)(0);
			int memJM = (int)(0);
			int readOnly = (int)(0);
			int journalFileSize = 0;
			sbyte* zPathname = null;
			int nPathname = (int)(0);
			int useJournal = (int)((flags & 0x0001) == (0) ? 1 : 0);
			int pcacheSize = (int)(sqlite3PcacheSize());
			uint szPageDflt = (uint)(4096);
			sbyte* zUri = null;
			int nUriByte = (int)(1);
			int nUri = (int)(0);
			journalFileSize = (int)(((sqlite3JournalSize(pVfs)) + 7) & ~7);
			ppPager = null;
			if ((flags & 0x0002) != 0)
			{
				memDb = (int)(1);
				if (((zFilename) != null) && ((zFilename[0]) != 0))
				{
					zPathname = sqlite3DbStrDup(null, zFilename);
					if ((zPathname) == (null))
						return (int)(7);
					nPathname = (int)(sqlite3Strlen30(zPathname));
					zFilename = null;
				}
			}

			if (((zFilename) != null) && ((zFilename[0]) != 0))
			{
				sbyte* z;
				nPathname = (int)(pVfs.mxPathname + 1);
				zPathname = sqlite3DbMallocRaw(null, (ulong)(nPathname * 2));
				if ((zPathname) == (null))
				{
					return (int)(7);
				}

				zPathname[0] = (sbyte)(0);
				rc = (int)(sqlite3OsFullPathname(pVfs, zFilename, (int)(nPathname), zPathname));
				if (rc != 0)
				{
					if ((rc) == (0 | (2 << 8)))
					{
						if ((vfsFlags & 0x01000000) != 0)
						{
							rc = (int)(14 | (6 << 8));
						}
						else
						{
							rc = (int)(0);
						}
					}
				}

				nPathname = (int)(sqlite3Strlen30(zPathname));
				z = zUri = &zFilename[sqlite3Strlen30(zFilename) + 1];
				while ((*z) != 0)
				{
					z += CRuntime.strlen(z) + 1;
					z += CRuntime.strlen(z) + 1;
					nUri++;
				}

				nUriByte = ((int)(&z[1] - zUri));

				if (((rc) == (0)) && ((nPathname + 8) > (pVfs.mxPathname)))
				{
					rc = (int)(sqlite3CantopenError((int)(57967)));
				}

				if (rc != 0)
				{
					sqlite3DbFree(null, zPathname);
					return (int)(rc);
				}
			}

			pPtr = (byte*)(sqlite3MallocZero((ulong)((((sizeof(Pager)) + 7) & ~7) + (((pcacheSize) + 7) & ~7) + (((pVfs.szOsFile) + 7) & ~7) + journalFileSize * 2 + sizeof(Pager) + 4 + nPathname + 1 + nUriByte + nPathname + 8 + 1 + nPathname + 4 + 1 + 3)));

			if (pPtr == null)
			{
				sqlite3DbFree(null, zPathname);
				return (int)(7);
			}

			pPager = (Pager)(pPtr);
			pPtr += (((sizeof(Pager)) + 7) & ~7);
			pPager.pPCache = (PCache)(pPtr);
			pPtr += (((pcacheSize) + 7) & ~7);
			pPager.fd = (sqlite3_file)(pPtr);
			pPtr += (((pVfs.szOsFile) + 7) & ~7);
			pPager.sjfd = (sqlite3_file)(pPtr);
			pPtr += journalFileSize;
			pPager.jfd = (sqlite3_file)(pPtr);
			pPtr += journalFileSize;

			CRuntime.memcpy(pPtr, pPager, (ulong)(sizeof(Pager)));
			pPtr += sizeof(Pager);
			pPtr += 4;
			pPager.zFilename = (sbyte*)(pPtr);
			if ((nPathname) > (0))
			{
				CRuntime.memcpy(pPtr, zPathname, (ulong)(nPathname));
				pPtr += nPathname + 1;
				if ((zUri) != null)
				{
					CRuntime.memcpy(pPtr, zUri, (ulong)(nUriByte));
					pPtr += nUriByte;
				}
				else
				{
					pPtr++;
				}
			}

			if ((nPathname) > (0))
			{
				pPager.zJournal = (sbyte*)(pPtr);
				CRuntime.memcpy(pPtr, zPathname, (ulong)(nPathname));
				pPtr += nPathname;
				CRuntime.memcpy(pPtr, "-journal", (ulong)(8));
				pPtr += 8 + 1;
			}
			else
			{
				pPager.zJournal = null;
			}

			if ((nPathname) > (0))
			{
				pPager.zWal = (sbyte*)(pPtr);
				CRuntime.memcpy(pPtr, zPathname, (ulong)(nPathname));
				pPtr += nPathname;
				CRuntime.memcpy(pPtr, "-wal", (ulong)(4));
				pPtr += 4 + 1;
			}
			else
			{
				pPager.zWal = null;
			}

			(void)(pPtr);
			if ((nPathname) != 0)
				sqlite3DbFree(null, zPathname);
			pPager.pVfs = pVfs;
			pPager.vfsFlags = (uint)(vfsFlags);
			if (((zFilename) != null) && ((zFilename[0]) != 0))
			{
				int fout = (int)(0);
				rc = (int)(sqlite3OsOpen(pVfs, pPager.zFilename, pPager.fd, (int)(vfsFlags), &fout));

				pPager.memVfs = (byte)(memJM = (int)((fout & 0x00000080) != 0));
				readOnly = (int)((fout & 0x00000001) != 0);
				if ((rc) == (0))
				{
					int iDc = (int)(sqlite3OsDeviceCharacteristics(pPager.fd));
					if (readOnly == 0)
					{
						setSectorSize(pPager);

						if ((szPageDflt) < (pPager.sectorSize))
						{
							if ((pPager.sectorSize) > (8192))
							{
								szPageDflt = (uint)(8192);
							}
							else
							{
								szPageDflt = (uint)(pPager.sectorSize);
							}
						}
					}

					pPager.noLock = (byte)(sqlite3_uri_boolean(pPager.zFilename, "nolock", (int)(0)));
					if (((iDc & 0x00002000) != 0) || ((sqlite3_uri_boolean(pPager.zFilename, "immutable", (int)(0))) != 0))
					{
						vfsFlags |= (int)(0x00000001);
						goto act_like_temp_file;
					}
				}
			}
			else
			{
			act_like_temp_file:
				;
				tempFile = (int)(1);
				pPager.eState = (byte)(1);
				pPager.eLock = (byte)(4);
				pPager.noLock = (byte)(1);
				readOnly = (int)(vfsFlags & 0x00000001);
			}

			if ((rc) == (0))
			{

				rc = (int)(sqlite3PagerSetPagesize(pPager, &szPageDflt, (int)(-1)));
			}

			if ((rc) == (0))
			{
				nExtra = (int)(((nExtra) + 7) & ~7);

				rc = (int)(sqlite3PcacheOpen((int)(szPageDflt), (int)(nExtra), (int)(!memDb), (!memDb) != 0 ? pagerStress : null, (void*)(pPager), pPager.pPCache));
			}

			if (rc != 0)
			{
				sqlite3OsClose(pPager.fd);
				sqlite3PageFree(pPager.pTmpSpace);
				sqlite3_free(pPager);
				return (int)(rc);
			}

			pPager.useJournal = ((byte)(useJournal));
			pPager.mxPgno = (uint)(1073741823);
			pPager.tempFile = ((byte)(tempFile));


			pPager.exclusiveMode = ((byte)(tempFile));
			pPager.changeCountDone = (byte)(pPager.tempFile);
			pPager.memDb = ((byte)(memDb));
			pPager.readOnly = ((byte)(readOnly));

			pPager.noSync = (byte)(pPager.tempFile);
			if ((pPager.noSync) != 0)
			{




			}
			else
			{
				pPager.fullSync = (byte)(1);
				pPager.extraSync = (byte)(0);
				pPager.syncFlags = (byte)(0x00002);
				pPager.walSyncFlags = (byte)(0x00002 | (0x00002 << 2));
			}

			pPager.nExtra = ((ushort)(nExtra));
			pPager.journalSizeLimit = (long)(-1);

			setSectorSize(pPager);
			if (useJournal == 0)
			{
				pPager.journalMode = (byte)(2);
			}
			else if (((memDb) != 0) || ((memJM) != 0))
			{
				pPager.journalMode = (byte)(4);
			}

			pPager.xReiniter = xReinit;
			setGetterMethod(pPager);
			ppPager = pPager;
			return (int)(0);
		}
		public static int sqlite3PagerOpenSavepoint(Pager pPager, int nSavepoint)
		{


			if (((nSavepoint) > (pPager.nSavepoint)) && ((pPager.useJournal) != 0))
			{
				return (int)(pagerOpenSavepoint(pPager, (int)(nSavepoint)));
			}
			else
			{
				return (int)(0);
			}
		}
		public static int sqlite3PagerOpenWal(Pager pPager, int* pbOpen)
		{
			int rc = (int)(0);





			if ((pPager.tempFile == 0) && (pPager.pWal == null))
			{
				if (sqlite3PagerWalSupported(pPager) == 0)
					return (int)(14);
				sqlite3OsClose(pPager.jfd);
				rc = (int)(pagerOpenWal(pPager));
				if ((rc) == (0))
				{
					pPager.journalMode = (byte)(5);
					pPager.eState = (byte)(0);
				}
			}
			else
			{
				*pbOpen = (int)(1);
			}

			return (int)(rc);
		}
		public static void sqlite3PagerPagecount(Pager pPager, int* pnPage)
		{


			*pnPage = ((int)(pPager.dbSize));
		}
		public static int sqlite3PagerPageRefcount(PgHdr pPage)
		{
			return (int)(sqlite3PcachePageRefcount(pPage));
		}
		public static int sqlite3PagerReadFileheader(Pager pPager, int N, byte* pDest)
		{
			int rc = (int)(0);
			CRuntime.memset(pDest, (int)(0), (ulong)(N));


			if (((pPager.fd).pMethods != null))
			{
				rc = (int)(sqlite3OsRead(pPager.fd, pDest, (int)(N), (long)(0)));
				if ((rc) == (10 | (2 << 8)))
				{
					rc = (int)(0);
				}
			}

			return (int)(rc);
		}
		public static void sqlite3PagerRef(PgHdr pPg)
		{
			sqlite3PcacheRef(pPg);
		}
		public static void sqlite3PagerRekey(PgHdr pPg, uint iNew, ushort flags)
		{

			pPg.flags = (ushort)(flags);
			sqlite3PcacheMove(pPg, (uint)(iNew));
		}
		public static int sqlite3PagerRollback(Pager pPager)
		{
			int rc = (int)(0);

			if ((pPager.eState) == (6))
				return (int)(pPager.errCode);
			if ((pPager.eState) <= (1))
				return (int)(0);
			if (((pPager).pWal != null))
			{
				int rc2 = 0;
				rc = (int)(sqlite3PagerSavepoint(pPager, (int)(2), (int)(-1)));
				rc2 = (int)(pager_end_transaction(pPager, (int)(pPager.setSuper), (int)(0)));
				if ((rc) == (0))
					rc = (int)(rc2);
			}
			else if ((!((pPager.jfd).pMethods != null)) || ((pPager.eState) == (2)))
			{
				int eState = (int)(pPager.eState);
				rc = (int)(pager_end_transaction(pPager, (int)(0), (int)(0)));
				if ((pPager.memDb == 0) && ((eState) > (2)))
				{
					pPager.errCode = (int)(4);
					pPager.eState = (byte)(6);
					setGetterMethod(pPager);
					return (int)(rc);
				}
			}
			else
			{
				rc = (int)(pager_playback(pPager, (int)(0)));
			}



			return (int)(pager_error(pPager, (int)(rc)));
		}
		public static int sqlite3PagerSavepoint(Pager pPager, int op, int iSavepoint)
		{
			int rc = (int)(pPager.errCode);


			if (((rc) == (0)) && ((iSavepoint) < (pPager.nSavepoint)))
			{
				int ii = 0;
				int nNew = 0;
				nNew = (int)(iSavepoint + (((op) == (1)) ? 0 : 1));
				for (ii = (int)(nNew); (ii) < (pPager.nSavepoint); ii++)
				{
					sqlite3BitvecDestroy(pPager.aSavepoint[ii].pInSavepoint);
				}

				pPager.nSavepoint = (int)(nNew);
				if ((op) == (1))
				{
					PagerSavepoint* pRel = &pPager.aSavepoint[nNew];
					if (((pRel->bTruncateOnRelease) != 0) && ((pPager.sjfd).pMethods != null))
					{
						if ((sqlite3JournalIsInMemory(pPager.sjfd)) != 0)
						{
							long sz = (long)((pPager.pageSize + 4) * (long)(pRel->iSubRec));
							rc = (int)(sqlite3OsTruncate(pPager.sjfd, (long)(sz)));

						}

						pPager.nSubRec = (uint)(pRel->iSubRec);
					}
				}
				else if (((pPager).pWal != null) || ((pPager.jfd).pMethods != null))
				{
					PagerSavepoint* pSavepoint = ((nNew) == (0)) ? null : &pPager.aSavepoint[nNew - 1];
					rc = (int)(pagerPlaybackSavepoint(pPager, pSavepoint));

				}
			}

			return (int)(rc);
		}
		public static void sqlite3PagerSetBusyHandler(Pager pPager, delegate19 xBusyHandler, void* pBusyHandlerArg)
		{
			void** ap;
			pPager.xBusyHandler = xBusyHandler;
			pPager.pBusyHandlerArg = pBusyHandlerArg;
			ap = (void**)(&pPager.xBusyHandler);


			sqlite3OsFileControlHint(pPager.fd, (int)(15), (void*)(ap));
		}
		public static void sqlite3PagerSetCachesize(Pager pPager, int mxPage)
		{
			sqlite3PcacheSetCachesize(pPager.pPCache, (int)(mxPage));
		}
		public static void sqlite3PagerSetFlags(Pager pPager, uint pgFlags)
		{
			uint level = (uint)(pgFlags & 0x07);
			if ((pPager.tempFile) != 0)
			{
				pPager.noSync = (byte)(1);
				pPager.fullSync = (byte)(0);
				pPager.extraSync = (byte)(0);
			}
			else
			{
				pPager.noSync = (byte)((level) == (0x01) ? 1 : 0);
				pPager.fullSync = (byte)((level) >= (0x03) ? 1 : 0);
				pPager.extraSync = (byte)((level) == (0x04) ? 1 : 0);
			}

			if ((pPager.noSync) != 0)
			{
				pPager.syncFlags = (byte)(0);
			}
			else if ((pgFlags & 0x08) != 0)
			{
				pPager.syncFlags = (byte)(0x00003);
			}
			else
			{
				pPager.syncFlags = (byte)(0x00002);
			}

			pPager.walSyncFlags = (byte)(pPager.syncFlags << 2);
			if ((pPager.fullSync) != 0)
			{
				pPager.walSyncFlags |= (byte)(pPager.syncFlags);
			}

			if (((pgFlags & 0x10) != 0) && (pPager.noSync == 0))
			{
				pPager.walSyncFlags |= (byte)(0x00003 << 2);
			}

			if ((pgFlags & 0x20) != 0)
			{
				pPager.doNotSpill &= (byte)(~0x01);
			}
			else
			{
				pPager.doNotSpill |= (byte)(0x01);
			}
		}
		public static int sqlite3PagerSetJournalMode(Pager pPager, int eMode)
		{
			byte eOld = (byte)(pPager.journalMode);


			if ((pPager.memDb) != 0)
			{

				if ((eMode != 4) && (eMode != 2))
				{
					eMode = (int)(eOld);
				}
			}

			if (eMode != eOld)
			{

				pPager.journalMode = ((byte)(eMode));







				if (((pPager.exclusiveMode == 0) && ((eOld & 5) == (1))) && ((eMode & 1) == (0)))
				{
					sqlite3OsClose(pPager.jfd);
					if ((pPager.eLock) >= (2))
					{
						sqlite3OsDelete(pPager.pVfs, pPager.zJournal, (int)(0));
					}
					else
					{
						int rc = (int)(0);
						int state = (int)(pPager.eState);

						if ((state) == (0))
						{
							rc = (int)(sqlite3PagerSharedLock(pPager));
						}

						if ((pPager.eState) == (1))
						{

							rc = (int)(pagerLockDb(pPager, (int)(2)));
						}

						if ((rc) == (0))
						{
							sqlite3OsDelete(pPager.pVfs, pPager.zJournal, (int)(0));
						}

						if (((rc) == (0)) && ((state) == (1)))
						{
							pagerUnlockDb(pPager, (int)(1));
						}
						else if ((state) == (0))
						{
							pager_unlock(pPager);
						}


					}
				}
				else if ((eMode) == (2))
				{
					sqlite3OsClose(pPager.jfd);
				}
			}

			return (int)(pPager.journalMode);
		}
		public static void sqlite3PagerSetMmapLimit(Pager pPager, long szMmap)
		{
			pPager.szMmap = (long)(szMmap);
			pagerFixMaplimit(pPager);
		}
		public static int sqlite3PagerSetPagesize(Pager pPager, uint* pPageSize, int nReserve)
		{
			int rc = (int)(0);
			uint pageSize = (uint)(*pPageSize);

			if ((((((pPager.memDb) == (0)) || ((pPager.dbSize) == (0))) && ((sqlite3PcacheRefCount(pPager.pPCache)) == (0))) && ((pageSize) != 0)) && (pageSize != (uint)(pPager.pageSize)))
			{
				sbyte* pNew = null;
				long nByte = (long)(0);
				if (((pPager.eState) > (0)) && ((pPager.fd).pMethods != null))
				{
					rc = (int)(sqlite3OsFileSize(pPager.fd, &nByte));
				}

				if ((rc) == (0))
				{
					pNew = (sbyte*)(sqlite3PageMalloc((int)(pageSize + 8)));
					if (pNew == null)
					{
						rc = (int)(7);
					}
					else
					{
						CRuntime.memset(pNew + pageSize, (int)(0), (ulong)(8));
					}
				}

				if ((rc) == (0))
				{
					pager_reset(pPager);
					rc = (int)(sqlite3PcacheSetPageSize(pPager.pPCache, (int)(pageSize)));
				}

				if ((rc) == (0))
				{
					sqlite3PageFree(pPager.pTmpSpace);
					pPager.pTmpSpace = pNew;
					pPager.dbSize = ((uint)((nByte + pageSize - 1) / pageSize));
					pPager.pageSize = (long)(pageSize);
				}
				else
				{
					sqlite3PageFree(pNew);
				}
			}

			*pPageSize = (uint)(pPager.pageSize);
			if ((rc) == (0))
			{
				if ((nReserve) < (0))
					nReserve = (int)(pPager.nReserve);

				pPager.nReserve = ((short)(nReserve));
				pagerFixMaplimit(pPager);
			}

			return (int)(rc);
		}
		public static int sqlite3PagerSetSpillsize(Pager pPager, int mxPage)
		{
			return (int)(sqlite3PcacheSetSpillsize(pPager.pPCache, (int)(mxPage)));
		}
		public static int sqlite3PagerSharedLock(Pager pPager)
		{
			int rc = (int)(0);




			if ((!((pPager).pWal != null)) && ((pPager.eState) == (0)))
			{
				int bHotJournal = (int)(1);


				rc = (int)(pager_wait_on_lock(pPager, (int)(1)));
				if (rc != 0)
				{

					goto failed;
				}

				if ((pPager.eLock) <= (1))
				{
					rc = (int)(hasHotJournal(pPager, &bHotJournal));
				}

				if (rc != 0)
				{
					goto failed;
				}

				if ((bHotJournal) != 0)
				{
					if ((pPager.readOnly) != 0)
					{
						rc = (int)(8 | (3 << 8));
						goto failed;
					}

					rc = (int)(pagerLockDb(pPager, (int)(4)));
					if (rc != 0)
					{
						goto failed;
					}

					if ((!((pPager.jfd).pMethods != null)) && (pPager.journalMode != 2))
					{
						sqlite3_vfs pVfs = pPager.pVfs;
						int bExists = 0;
						rc = (int)(sqlite3OsAccess(pVfs, pPager.zJournal, (int)(0), &bExists));
						if (((rc) == (0)) && ((bExists) != 0))
						{
							int fout = (int)(0);
							int f = (int)(0x00000002 | 0x00000800);

							rc = (int)(sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, (int)(f), &fout));

							if (((rc) == (0)) && ((fout & 0x00000001) != 0))
							{
								rc = (int)(sqlite3CantopenError((int)(58497)));
								sqlite3OsClose(pPager.jfd);
							}
						}
					}

					if (((pPager.jfd).pMethods != null))
					{

						rc = (int)(pagerSyncHotJournal(pPager));
						if ((rc) == (0))
						{
							rc = (int)(pager_playback(pPager, (int)(!pPager.tempFile)));
							pPager.eState = (byte)(0);
						}
					}
					else if (pPager.exclusiveMode == 0)
					{
						pagerUnlockDb(pPager, (int)(1));
					}

					if (rc != 0)
					{
						pager_error(pPager, (int)(rc));
						goto failed;
					}



				}

				if ((pPager.tempFile == 0) && ((pPager.hasHeldSharedLock) != 0))
				{
					sbyte* dbFileVers = stackalloc sbyte[16];
					rc = (int)(sqlite3OsRead(pPager.fd, &dbFileVers, (int)(16 * sizeof(sbyte)), (long)(24)));
					if (rc != 0)
					{
						if (rc != (10 | (2 << 8)))
						{
							goto failed;
						}

						CRuntime.memset(dbFileVers, (int)(0), (ulong)(16 * sizeof(sbyte)));
					}

					if (memcmp(pPager.dbFileVers, dbFileVers, (ulong)(16 * sizeof(sbyte))) != 0)
					{
						pager_reset(pPager);
						if (((pPager).bUseFetch) != 0)
						{
							sqlite3OsUnfetch(pPager.fd, (long)(0), null);
						}
					}
				}

				rc = (int)(pagerOpenWalIfPresent(pPager));

			}

			if (((pPager).pWal != null))
			{

				rc = (int)(pagerBeginReadTransaction(pPager));
			}

			if ((((pPager.tempFile) == (0)) && ((pPager.eState) == (0))) && ((rc) == (0)))
			{
				rc = (int)(pagerPagecount(pPager, &pPager.dbSize));
			}

		failed:
			; if (rc != 0) { ((void)(0)); pager_unlock(pPager); ((void)(0)); } else { pPager.eState = (byte)(1); pPager.hasHeldSharedLock = (byte)(1); }
			return (int)(rc);
		}
		public static void sqlite3PagerShrink(Pager pPager)
		{
			sqlite3PcacheShrink(pPager.pPCache);
		}
		public static int sqlite3PagerSync(Pager pPager, sbyte* zSuper)
		{
			int rc = (int)(0);
			void* pArg = (void*)(zSuper);
			rc = (int)(sqlite3OsFileControl(pPager.fd, (int)(21), pArg));
			if ((rc) == (12))
				rc = (int)(0);
			if (((rc) == (0)) && (pPager.noSync == 0))
			{

				rc = (int)(sqlite3OsSync(pPager.fd, (int)(pPager.syncFlags)));
			}

			return (int)(rc);
		}
		public static void* sqlite3PagerTempSpace(Pager pPager)
		{
			return pPager.pTmpSpace;
		}
		public static void sqlite3PagerTruncateImage(Pager pPager, uint nPage)
		{


			pPager.dbSize = (uint)(nPage);
		}
		public static void sqlite3PagerUnref(PgHdr pPg)
		{
			if ((pPg) != null)
				sqlite3PagerUnrefNotNull(pPg);
		}
		public static void sqlite3PagerUnrefNotNull(PgHdr pPg)
		{

			if ((pPg.flags & 0x020) != 0)
			{

				pagerReleaseMapPage(pPg);
			}
			else
			{
				sqlite3PcacheRelease(pPg);
			}


		}
		public static void sqlite3PagerUnrefPageOne(PgHdr pPg)
		{
			Pager pPager;



			pPager = pPg.pPager;
			sqlite3PcacheRelease(pPg);
			pagerUnlockIfUnused(pPager);
		}
		public static sqlite3_vfs sqlite3PagerVfs(Pager pPager)
		{
			return pPager.pVfs;
		}
		public static int sqlite3PagerWalCallback(Pager pPager)
		{
			return (int)(sqlite3WalCallback(pPager.pWal));
		}
		public static int sqlite3PagerWalSupported(Pager pPager)
		{
			sqlite3_io_methods pMethods = pPager.fd.pMethods;
			if ((pPager.noLock) != 0)
				return (int)(0);
			return (((pPager.exclusiveMode) != 0) || (((pMethods.iVersion) >= (2)) && ((pMethods.xShmMap) != null)) ? 1 : 0);
		}
		public static int sqlite3PagerWrite(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;



			if (((pPg.flags & 0x004) != 0) && ((pPager.dbSize) >= (pPg.pgno)))
			{
				if ((pPager.nSavepoint) != 0)
					return (int)(subjournalPageIfRequired(pPg));
				return (int)(0);
			}
			else if ((pPager.errCode) != 0)
			{
				return (int)(pPager.errCode);
			}
			else if ((pPager.sectorSize) > ((uint)(pPager.pageSize)))
			{

				return (int)(pagerWriteLargeSector(pPg));
			}
			else
			{
				return (int)(pager_write(pPg));
			}
		}
		public static void sqlite3ParseObjectInit(Parse pParse, sqlite3 db)
		{
			CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&((0).zErrMsg)))), (int)(0), (ulong)(((ulong)(&((0).aTempReg))) - ((ulong)(&((0).zErrMsg)))));
			CRuntime.memset((((sbyte*)(pParse)) + ((ulong)(&((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));

			pParse.pOuterParse = db.pParse;
			db.pParse = pParse;
			pParse.db = db;
			if ((db.mallocFailed) != 0)
				sqlite3ErrorMsg(pParse, "out of memory");
		}
		public static void sqlite3ParseObjectReset(Parse pParse)
		{
			sqlite3 db = pParse.db;



			sqlite3DbFree(db, pParse.aTableLock);
			while ((pParse.pCleanup) != null)
			{
				ParseCleanup pCleanup = pParse.pCleanup;
				pParse.pCleanup = pCleanup.pNext;
				pCleanup.xCleanup(db, pCleanup.pPtr);
				sqlite3DbFreeNN(db, pCleanup);
			}

			sqlite3DbFree(db, pParse.aLabel);
			if ((pParse.pConstExpr) != null)
			{
				sqlite3ExprListDelete(db, pParse.pConstExpr);
			}


			db.lookaside.bDisable -= (uint)(pParse.disableLookaside);
			db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);

			db.pParse = pParse.pOuterParse;
			pParse.db = null;
			pParse.disableLookaside = (byte)(0);
		}
		public static void sqlite3Parser(void* yyp, int yymajor, Token yyminor)
		{
			YYMINORTYPE yyminorunion = new YYMINORTYPE();
			ushort yyact = 0;
			yyParser yypParser = (yyParser)(yyp);
			Parse pParse = yypParser.pParse;

			yyact = (ushort)(yypParser.yytos->stateno);
			while ((1) != 0)
			{


				yyact = (ushort)(yy_find_shift_action((ushort)(yymajor), (ushort)(yyact)));
				if ((yyact) >= (1236))
				{
					uint yyruleno = (uint)(yyact - 1236);
					if ((yyRuleInfoNRhs[yyruleno]) == (0))
					{
						if ((yypParser.yytos) >= (yypParser.yystackEnd))
						{
							yyStackOverflow(yypParser);
							break;
						}
					}

					yyact = (ushort)(yy_reduce(yypParser, (uint)(yyruleno), (int)(yymajor), (Token)(yyminor), pParse));
				}
				else if ((yyact) <= (1232))
				{
					yy_shift(yypParser, (ushort)(yyact), (ushort)(yymajor), (Token)(yyminor));
					break;
				}
				else if ((yyact) == (1234))
				{
					yypParser.yytos--;
					yy_accept(yypParser);
					return;
				}
				else
				{

					yyminorunion.yy0 = (Token)(yyminor);
					yy_syntax_error(yypParser, (int)(yymajor), (Token)(yyminor));
					yy_destructor(yypParser, (ushort)(yymajor), &yyminorunion);
					break;
				}
			}

			return;
		}
		public static void* sqlite3ParserAddCleanup(Parse pParse, delegate70 xCleanup, void* pPtr)
		{
			ParseCleanup pCleanup = sqlite3DbMallocRaw(pParse.db, (ulong)(sizeof(ParseCleanup)));
			if ((pCleanup) != null)
			{
				pCleanup.pNext = pParse.pCleanup;
				pParse.pCleanup = pCleanup;
				pCleanup.pPtr = pPtr;
				pCleanup.xCleanup = xCleanup;
			}
			else
			{
				xCleanup(pParse.db, pPtr);
				pPtr = null;
			}

			return pPtr;
		}
		public static int sqlite3ParserFallback(int iToken)
		{

			return (int)(yyFallback[iToken]);
		}
		public static void sqlite3ParserFinalize(void* p)
		{
			yyParser pParser = (yyParser)(p);
			while ((pParser.yytos) > (pParser.yystack))
			{
				yy_pop_parser_stack(pParser);
			}
		}
		public static void sqlite3ParserInit(void* yypRawParser, Parse pParse)
		{
			yyParser yypParser = (yyParser)(yypRawParser);
			yypParser.pParse = pParse;
			yypParser.yytos = yypParser.yystack;
			yypParser.yystack[0].stateno = (ushort)(0);
			yypParser.yystack[0].major = (ushort)(0);
			yypParser.yystackEnd = &yypParser.yystack[100 - 1];
		}
		public static int sqlite3ParseUri(sbyte* zDefaultVfs, sbyte* zUri, uint* pFlags, sqlite3_vfs ppVfs, sbyte** pzFile, sbyte** pzErrMsg)
		{
			int rc = (int)(0);
			uint flags = (uint)(*pFlags);
			sbyte* zVfs = zDefaultVfs;
			sbyte* zFile;
			sbyte c = 0;
			int nUri = (int)(sqlite3Strlen30(zUri));

			if (((((flags & 0x00000040) != 0) || ((sqlite3Config.bOpenUri) != 0)) && ((nUri) >= (5))) && ((memcmp(zUri, "file:", (ulong)(5))) == (0)))
			{
				sbyte* zOpt;
				int eState = 0;
				int iIn = 0;
				int iOut = (int)(0);
				ulong nByte = (ulong)(nUri + 8);
				flags |= (uint)(0x00000040);
				for (iIn = (int)(0); (iIn) < (nUri); iIn++)
				{
					nByte += (ulong)((zUri[iIn]) == (38));
				}

				zFile = sqlite3_malloc64((ulong)(nByte));
				if (zFile == null)
					return (int)(7);
				CRuntime.memset(zFile, (int)(0), (ulong)(4));
				zFile += 4;
				iIn = (int)(5);
				if (((zUri[5]) == (47)) && ((zUri[6]) == (47)))
				{
					iIn = (int)(7);
					while (((zUri[iIn]) != 0) && (zUri[iIn] != 47))
					{
						iIn++;
					}

					if ((iIn != 7) && ((iIn != 16) || ((memcmp("localhost", &zUri[7], (ulong)(9))) != 0)))
					{
						*pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s", (int)(iIn - 7), &zUri[7]);
						rc = (int)(1);
						goto parse_uri_out;
					}
				}

				eState = (int)(0);
				while (((c = (sbyte)(zUri[iIn])) != 0) && (c != 35))
				{
					iIn++;
					if ((((c) == (37)) && ((sqlite3CtypeMap[(byte)(zUri[iIn])] & 0x08) != 0)) && ((sqlite3CtypeMap[(byte)(zUri[iIn + 1])] & 0x08) != 0))
					{
						int octet = (int)(sqlite3HexToInt((int)(zUri[iIn++])) << 4);
						octet += (int)(sqlite3HexToInt((int)(zUri[iIn++])));

						if ((octet) == (0))
						{
							while ((((((c = (sbyte)(zUri[iIn])) != 0) && (c != 35)) && ((eState != 0) || (c != 63))) && ((eState != 1) || ((c != 61) && (c != 38)))) && ((eState != 2) || (c != 38)))
							{
								iIn++;
							}

							continue;
						}

						c = (sbyte)(octet);
					}
					else if (((eState) == (1)) && (((c) == (38)) || ((c) == (61))))
					{
						if ((zFile[iOut - 1]) == (0))
						{
							while ((((zUri[iIn]) != 0) && (zUri[iIn] != 35)) && (zUri[iIn - 1] != 38))
							{
								iIn++;
							}

							continue;
						}

						if ((c) == (38))
						{
							zFile[iOut++] = (sbyte)(0);
						}
						else
						{
							eState = (int)(2);
						}

						c = (sbyte)(0);
					}
					else if ((((eState) == (0)) && ((c) == (63))) || (((eState) == (2)) && ((c) == (38))))
					{
						c = (sbyte)(0);
						eState = (int)(1);
					}

					zFile[iOut++] = (sbyte)(c);
				}

				if ((eState) == (1))
					zFile[iOut++] = (sbyte)(0);
				CRuntime.memset(zFile + iOut, (int)(0), (ulong)(4));
				zOpt = &zFile[sqlite3Strlen30(zFile) + 1];
				while ((zOpt[0]) != 0)
				{
					int nOpt = (int)(sqlite3Strlen30(zOpt));
					sbyte* zVal = &zOpt[nOpt + 1];
					int nVal = (int)(sqlite3Strlen30(zVal));
					if (((nOpt) == (3)) && ((memcmp("vfs", zOpt, (ulong)(3))) == (0)))
					{
						zVfs = zVal;
					}
					else
					{
						OpenMode* aMode = null;
						sbyte* zModeType = null;
						int mask = (int)(0);
						int limit = (int)(0);
						if (((nOpt) == (5)) && ((memcmp("cache", zOpt, (ulong)(5))) == (0)))
						{
							mask = (int)(0x00020000 | 0x00040000);
							aMode = sqlite3ParseUri_aCacheMode;
							limit = (int)(mask);
							zModeType = "cache";
						}

						if (((nOpt) == (4)) && ((memcmp("mode", zOpt, (ulong)(4))) == (0)))
						{
							mask = (int)(0x00000001 | 0x00000002 | 0x00000004 | 0x00000080);
							aMode = sqlite3ParseUri_aOpenMode;
							limit = (int)(mask & flags);
							zModeType = "access";
						}

						if ((aMode) != null)
						{
							int i = 0;
							int mode = (int)(0);
							for (i = (int)(0); aMode[i].z; i++)
							{
								sbyte* z = aMode[i].z;
								if (((nVal) == (sqlite3Strlen30(z))) && ((0) == (memcmp(zVal, z, (ulong)(nVal)))))
								{
									mode = (int)(aMode[i].mode);
									break;
								}
							}

							if ((mode) == (0))
							{
								*pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
								rc = (int)(1);
								goto parse_uri_out;
							}

							if ((mode & ~0x00000080) > (limit))
							{
								*pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s", zModeType, zVal);
								rc = (int)(3);
								goto parse_uri_out;
							}

							flags = (uint)((flags & ~mask) | mode);
						}
					}

					zOpt = &zVal[nVal + 1];
				}
			}
			else
			{
				zFile = sqlite3_malloc64((ulong)(nUri + 8));
				if (zFile == null)
					return (int)(7);
				CRuntime.memset(zFile, (int)(0), (ulong)(4));
				zFile += 4;
				if ((nUri) != 0)
				{
					CRuntime.memcpy(zFile, zUri, (ulong)(nUri));
				}

				CRuntime.memset(zFile + nUri, (int)(0), (ulong)(4));
				flags &= (uint)(~0x00000040);
			}

			ppVfs = sqlite3_vfs_find(zVfs);
			if ((ppVfs) == (null))
			{
				*pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
				rc = (int)(1);
			}

		parse_uri_out:
			; if (rc != 0) { sqlite3_free_filename(zFile); zFile = null; }
			*pFlags = (uint)(flags);
			*pzFile = zFile;
			return (int)(rc);
		}
		public static sqlite3_mutex* sqlite3Pcache1Mutex()
		{
			return (pcache1_g).mutex;
		}
		public static void sqlite3PCacheBufferSetup(void* pBuf, int sz, int n)
		{
			if (((pcache1_g).isInit) != 0)
			{
				PgFreeslot* p;
				if ((pBuf) == (null))
					sz = (int)(n = (int)(0));
				if ((n) == (0))
					sz = (int)(0);
				sz = (int)((sz) & ~7);
				(pcache1_g).szSlot = (int)(sz);
				(pcache1_g).nSlot = (int)((pcache1_g).nFreeSlot = (int)(n));
				(pcache1_g).nReserve = (int)((n) > (90) ? 10 : (n / 10 + 1));
				(pcache1_g).pStart = pBuf;
				(pcache1_g).pFree = null;
				(pcache1_g).bUnderPressure = (int)(0);
				while ((n--) != 0)
				{
					p = (PgFreeslot*)(pBuf);
					p->pNext = (pcache1_g).pFree;
					(pcache1_g).pFree = p;
					pBuf = (void*)(&((sbyte*)(pBuf))[sz]);
				}

				(pcache1_g).pEnd = pBuf;
			}
		}
		public static void sqlite3PcacheCleanAll(PCache pCache)
		{
			PgHdr p;
			while ((p = pCache.pDirty) != null)
			{
				sqlite3PcacheMakeClean(p);
			}
		}
		public static void sqlite3PcacheClear(PCache pCache)
		{
			sqlite3PcacheTruncate(pCache, (uint)(0));
		}
		public static void sqlite3PcacheClearSyncFlags(PCache pCache)
		{
			PgHdr p;
			for (p = pCache.pDirty; p; p = p.pDirtyNext)
			{
				p.flags &= (ushort)(~0x008);
			}

			pCache.pSynced = pCache.pDirtyTail;
		}
		public static void sqlite3PcacheClearWritable(PCache pCache)
		{
			PgHdr p;
			for (p = pCache.pDirty; p; p = p.pDirtyNext)
			{
				p.flags &= (ushort)(~(0x008 | 0x004));
			}

			pCache.pSynced = pCache.pDirtyTail;
		}
		public static void sqlite3PcacheClose(PCache pCache)
		{

			sqlite3Config.pcache2.xDestroy(pCache.pCache);
		}
		public static PgHdr sqlite3PcacheDirtyList(PCache pCache)
		{
			PgHdr p;
			for (p = pCache.pDirty; p; p = p.pDirtyNext)
			{
				p.pDirty = p.pDirtyNext;
			}

			return pcacheSortDirtyList(pCache.pDirty);
		}
		public static void sqlite3PcacheDrop(PgHdr p)
		{


			if ((p.flags & 0x002) != 0)
			{
				pcacheManageDirtyList(p, (byte)(1));
			}

			p.pCache.nRefSum--;
			sqlite3Config.pcache2.xUnpin(p.pCache.pCache, p.pPage, (int)(1));
		}
		public static sqlite3_pcache_page* sqlite3PcacheFetch(PCache pCache, uint pgno, int createFlag)
		{
			int eCreate = 0;
			sqlite3_pcache_page* pRes;




			eCreate = (int)(createFlag & pCache.eCreate);



			pRes = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(pgno), (int)(eCreate));
			return pRes;
		}
		public static PgHdr sqlite3PcacheFetchFinish(PCache pCache, uint pgno, sqlite3_pcache_page* pPage)
		{
			PgHdr pPgHdr;

			pPgHdr = (PgHdr)(pPage->pExtra);
			if (pPgHdr.pPage == null)
			{
				return pcacheFetchFinishWithInit(pCache, (uint)(pgno), pPage);
			}

			pCache.nRefSum++;
			pPgHdr.nRef++;

			return pPgHdr;
		}
		public static int sqlite3PcacheFetchStress(PCache pCache, uint pgno, sqlite3_pcache_page** ppPage)
		{
			PgHdr pPg;
			if ((pCache.eCreate) == (2))
				return (int)(0);
			if ((sqlite3PcachePagecount(pCache)) > (pCache.szSpill))
			{
				for (pPg = pCache.pSynced; ((pPg) != null) && (((pPg.nRef) != 0) || ((pPg.flags & 0x008) != 0)); pPg = pPg.pDirtyPrev)
				{
				}

				pCache.pSynced = pPg;
				if (pPg == null)
				{
					for (pPg = pCache.pDirtyTail; ((pPg) != null) && ((pPg.nRef) != 0); pPg = pPg.pDirtyPrev)
					{
					}
				}

				if ((pPg) != null)
				{
					int rc = 0;
					rc = (int)(pCache.xStress(pCache.pStress, pPg));
					if ((rc != 0) && (rc != 5))
					{
						return (int)(rc);
					}
				}
			}

			*ppPage = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(pgno), (int)(2));
			return (int)((*ppPage) == (null) ? 7 : 0);
		}
		public static int sqlite3PcacheInitialize()
		{
			if ((sqlite3Config.pcache2.xInit) == (null))
			{
				sqlite3PCacheSetDefault();

			}

			return (int)(sqlite3Config.pcache2.xInit(sqlite3Config.pcache2.pArg));
		}
		public static void sqlite3PcacheMakeClean(PgHdr p)
		{



			pcacheManageDirtyList(p, (byte)(1));
			p.flags &= (ushort)(~(0x002 | 0x008 | 0x004));
			p.flags |= (ushort)(0x001);

			if ((p.nRef) == (0))
			{
				pcacheUnpin(p);
			}
		}
		public static void sqlite3PcacheMakeDirty(PgHdr p)
		{


			if ((p.flags & (0x001 | 0x010)) != 0)
			{
				p.flags &= (ushort)(~0x010);
				if ((p.flags & 0x001) != 0)
				{
					p.flags ^= (ushort)(0x002 | 0x001);

					pcacheManageDirtyList(p, (byte)(2));
				}


			}
		}
		public static void sqlite3PcacheMove(PgHdr p, uint newPgno)
		{
			PCache pCache = p.pCache;



			sqlite3Config.pcache2.xRekey(pCache.pCache, p.pPage, (uint)(p.pgno), (uint)(newPgno));
			p.pgno = (uint)(newPgno);
			if (((p.flags & 0x002) != 0) && ((p.flags & 0x008) != 0))
			{
				pcacheManageDirtyList(p, (byte)(3));
			}
		}
		public static int sqlite3PcacheOpen(int szPage, int szExtra, int bPurgeable, delegate59 xStress, void* pStress, PCache p)
		{
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(PCache)));
			p.szPage = (int)(1);
			p.szExtra = (int)(szExtra);

			p.bPurgeable = (byte)(bPurgeable);
			p.eCreate = (byte)(2);
			p.xStress = xStress;
			p.pStress = pStress;
			p.szCache = (int)(100);
			p.szSpill = (int)(1);
			return (int)(sqlite3PcacheSetPageSize(p, (int)(szPage)));
		}
		public static int sqlite3PcachePagecount(PCache pCache)
		{

			return (int)(sqlite3Config.pcache2.xPagecount(pCache.pCache));
		}
		public static int sqlite3PcachePageRefcount(PgHdr p)
		{
			return (int)(p.nRef);
		}
		public static int sqlite3PCachePercentDirty(PCache pCache)
		{
			PgHdr pDirty;
			int nDirty = (int)(0);
			int nCache = (int)(numberOfCachePages(pCache));
			for (pDirty = pCache.pDirty; pDirty; pDirty = pDirty.pDirtyNext)
			{
				nDirty++;
			}

			return (int)((nCache) != 0 ? (int)(((long)(nDirty) * 100) / nCache) : 0);
		}
		public static void sqlite3PcacheRef(PgHdr p)
		{


			p.nRef++;
			p.pCache.nRefSum++;
		}
		public static int sqlite3PcacheRefCount(PCache pCache)
		{
			return (int)(pCache.nRefSum);
		}
		public static void sqlite3PcacheRelease(PgHdr p)
		{

			p.pCache.nRefSum--;
			if ((--p.nRef) == (0))
			{
				if ((p.flags & 0x001) != 0)
				{
					pcacheUnpin(p);
				}
				else
				{
					pcacheManageDirtyList(p, (byte)(3));
				}
			}
		}
		public static void sqlite3PcacheSetCachesize(PCache pCache, int mxPage)
		{

			pCache.szCache = (int)(mxPage);
			sqlite3Config.pcache2.xCachesize(pCache.pCache, (int)(numberOfCachePages(pCache)));
		}
		public static void sqlite3PCacheSetDefault()
		{
			sqlite3_config((int)(18), sqlite3PCacheSetDefault_defaultMethods);
		}
		public static int sqlite3PcacheSetPageSize(PCache pCache, int szPage)
		{

			if ((pCache.szPage) != 0)
			{
				sqlite3_pcache* pNew;
				pNew = sqlite3Config.pcache2.xCreate((int)(szPage), (int)(pCache.szExtra + (((sizeof(PgHdr)) + 7) & ~7)), (int)(pCache.bPurgeable));
				if ((pNew) == (null))
					return (int)(7);
				sqlite3Config.pcache2.xCachesize(pNew, (int)(numberOfCachePages(pCache)));
				if ((pCache.pCache) != null)
				{
					sqlite3Config.pcache2.xDestroy(pCache.pCache);
				}

				pCache.pCache = pNew;
				pCache.szPage = (int)(szPage);
			}

			return (int)(0);
		}
		public static int sqlite3PcacheSetSpillsize(PCache p, int mxPage)
		{
			int res = 0;

			if ((mxPage) != 0)
			{
				if ((mxPage) < (0))
				{
					mxPage = ((int)((-1024 * (long)(mxPage)) / (p.szPage + p.szExtra)));
				}

				p.szSpill = (int)(mxPage);
			}

			res = (int)(numberOfCachePages(p));
			if ((res) < (p.szSpill))
				res = (int)(p.szSpill);
			return (int)(res);
		}
		public static void sqlite3PcacheShrink(PCache pCache)
		{

			sqlite3Config.pcache2.xShrink(pCache.pCache);
		}
		public static void sqlite3PcacheShutdown()
		{
			if ((sqlite3Config.pcache2.xShutdown) != null)
			{
				sqlite3Config.pcache2.xShutdown(sqlite3Config.pcache2.pArg);
			}
		}
		public static int sqlite3PcacheSize()
		{
			return (int)(sizeof(PCache));
		}
		public static void sqlite3PcacheTruncate(PCache pCache, uint pgno)
		{
			if ((pCache.pCache) != null)
			{
				PgHdr p;
				PgHdr pNext;
				for (p = pCache.pDirty; p; p = pNext)
				{
					pNext = p.pDirtyNext;

					if ((p.pgno) > (pgno))
					{

						sqlite3PcacheMakeClean(p);
					}
				}

				if (((pgno) == (0)) && ((pCache.nRefSum) != 0))
				{
					sqlite3_pcache_page* pPage1;
					pPage1 = sqlite3Config.pcache2.xFetch(pCache.pCache, (uint)(1), (int)(0));
					if ((pPage1) != null)
					{
						CRuntime.memset(pPage1->pBuf, (int)(0), (ulong)(pCache.szPage));
						pgno = (uint)(1);
					}
				}

				sqlite3Config.pcache2.xTruncate(pCache.pCache, (uint)(pgno + 1));
			}
		}
		public static Expr sqlite3PExpr(Parse pParse, int op, Expr pLeft, Expr pRight)
		{
			Expr p;
			p = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Expr)));
			if ((p) != null)
			{
				CRuntime.memset(p, (int)(0), (ulong)(sizeof(Expr)));
				p.op = (byte)(op & 0xff);
				p.iAgg = (short)(-1);
				sqlite3ExprAttachSubtrees(pParse.db, p, pLeft, pRight);
				sqlite3ExprCheckHeight(pParse, (int)(p.nHeight));
			}
			else
			{
				sqlite3ExprDelete(pParse.db, pLeft);
				sqlite3ExprDelete(pParse.db, pRight);
			}

			return p;
		}
		public static void sqlite3PExprAddSelect(Parse pParse, Expr pExpr, Select pSelect)
		{
			if ((pExpr) != null)
			{
				pExpr.x.pSelect = pSelect;
				(pExpr).flags |= (uint)(0x000800 | 0x200000);
				sqlite3ExprSetHeightAndFlags(pParse, pExpr);
			}
			else
			{

				sqlite3SelectDelete(pParse.db, pSelect);
			}
		}
		public static void sqlite3Pragma(Parse pParse, Token* pId1, Token* pId2, Token* pValue, int minusFlag)
		{
			sbyte* zLeft = null;
			sbyte* zRight = null;
			sbyte* zDb = null;
			Token* pId;
			sbyte** aFcntl = stackalloc sbyte[4];
			int iDb = 0;
			int rc = 0;
			sqlite3 db = pParse.db;
			Db pDb;
			Vdbe v = sqlite3GetVdbe(pParse);
			PragmaName* pPragma;
			if ((v) == (null))
				return;
			sqlite3VdbeRunOnlyOnce(v);
			pParse.nMem = (int)(2);
			iDb = (int)(sqlite3TwoPartName(pParse, pId1, pId2, &pId));
			if ((iDb) < (0))
				return;
			pDb = db.aDb[iDb];
			if (((iDb) == (1)) && ((sqlite3OpenTempDatabase(pParse)) != 0))
			{
				return;
			}

			zLeft = sqlite3NameFromToken(db, pId);
			if (zLeft == null)
				return;
			if ((minusFlag) != 0)
			{
				zRight = sqlite3MPrintf(db, "-%T", pValue);
			}
			else
			{
				zRight = sqlite3NameFromToken(db, pValue);
			}


			zDb = (pId2->n) > (0) ? pDb.zDbSName : null;
			if ((sqlite3AuthCheck(pParse, (int)(19), zLeft, zRight, zDb)) != 0)
			{
				goto pragma_out;
			}

			aFcntl[0] = null;
			aFcntl[1] = zLeft;
			aFcntl[2] = zRight;
			aFcntl[3] = null;
			db.busyHandler.nBusy = (int)(0);
			rc = (int)(sqlite3_file_control(db, zDb, (int)(14), (void*)(aFcntl)));
			if ((rc) == (0))
			{
				sqlite3VdbeSetNumCols(v, (int)(1));
				sqlite3VdbeSetColName(v, (int)(0), (int)(0), aFcntl[0], ((Void(Void * ))(-1)));
				returnSingleText(v, aFcntl[0]);
				sqlite3_free(aFcntl[0]);
				goto pragma_out;
			}

			if (rc != 12)
			{
				if ((aFcntl[0]) != null)
				{
					sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
					sqlite3_free(aFcntl[0]);
				}

				pParse.nErr++;
				pParse.rc = (int)(rc);
				goto pragma_out;
			}

			pPragma = pragmaLocate(zLeft);
			if ((pPragma) == (null))
			{
				goto pragma_out;
			}

			if ((pPragma->mPragFlg & 0x01) != 0)
			{
				if ((sqlite3ReadSchema(pParse)) != 0)
					goto pragma_out;
			}

			if (((pPragma->mPragFlg & 0x02) == (0)) && (((pPragma->mPragFlg & 0x04) == (0)) || ((zRight) == (null))))
			{
				setPragmaResultColumnNames(v, pPragma);
			}

			switch (pPragma->ePragTyp)
			{
				case 13:
					{
						VdbeOp* aOp;
						sqlite3VdbeUsesBtree(v, (int)(iDb));
						if (zRight == null)
						{
							pParse.nMem += (int)(2);
							aOp = sqlite3VdbeAddOpList(v, ((int)(9 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_getCacheSize, (int)(sqlite3Pragma_iLn));
							if ((0) != 0)
								break;
							aOp[0].p1 = (int)(iDb);
							aOp[1].p1 = (int)(iDb);
							aOp[6].p1 = (int)(-2000);
						}
						else
						{
							int size = (int)(sqlite3AbsInt32((int)(sqlite3Atoi(zRight))));
							sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
							sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(3), (int)(size));

							pDb.pSchema.cache_size = (int)(size);
							sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
						}

						break;
					}

				case 31:
					{
						Btree pBt = pDb.pBt;

						if (zRight == null)
						{
							int size = (int)((pBt) ? sqlite3BtreeGetPageSize(pBt) : 0);
							returnSingleInt(v, (long)(size));
						}
						else
						{
							db.nextPagesize = (int)(sqlite3Atoi(zRight));
							if ((7) == (sqlite3BtreeSetPageSize(pBt, (int)(db.nextPagesize), (int)(0), (int)(0))))
							{
								sqlite3OomFault(db);
							}
						}

						break;
					}

				case 33:
					{
						Btree pBt = pDb.pBt;
						int b = (int)(-1);

						if ((zRight) != null)
						{
							if ((sqlite3_stricmp(zRight, "fast")) == (0))
							{
								b = (int)(2);
							}
							else
							{
								b = (int)(sqlite3GetBoolean(zRight, (byte)(0)));
							}
						}

						if (((pId2->n) == (0)) && ((b) >= (0)))
						{
							int ii = 0;
							for (ii = (int)(0); (ii) < (db.nDb); ii++)
							{
								sqlite3BtreeSecureDelete(db.aDb[ii].pBt, (int)(b));
							}
						}

						b = (int)(sqlite3BtreeSecureDelete(pBt, (int)(b)));
						returnSingleInt(v, (long)(b));
						break;
					}

				case 27:
					{
						int iReg = 0;
						long x = (long)(0);
						sqlite3CodeVerifySchema(pParse, (int)(iDb));
						iReg = (int)(++pParse.nMem);
						if ((sqlite3UpperToLower[(byte)(zLeft[0])]) == (112))
						{
							sqlite3VdbeAddOp2(v, (int)(176), (int)(iDb), (int)(iReg));
						}
						else
						{
							if (((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &x)) == (0)))
							{
								if ((x) < (0))
									x = (long)(0);
								else if ((x) > (0xfffffffe))
									x = (long)(0xfffffffe);
							}
							else
							{
								x = (long)(0);
							}

							sqlite3VdbeAddOp3(v, (int)(177), (int)(iDb), (int)(iReg), (int)(x));
						}

						sqlite3VdbeAddOp2(v, (int)(83), (int)(iReg), (int)(1));
						break;
					}

				case 26:
					{
						sbyte* zRet = "normal";
						int eMode = (int)(getLockingMode(zRight));
						if (((pId2->n) == (0)) && ((eMode) == (-1)))
						{
							eMode = (int)(db.dfltLockMode);
						}
						else
						{
							Pager pPager;
							if ((pId2->n) == (0))
							{
								int ii = 0;

								for (ii = (int)(2); (ii) < (db.nDb); ii++)
								{
									pPager = sqlite3BtreePager(db.aDb[ii].pBt);
									sqlite3PagerLockingMode(pPager, (int)(eMode));
								}

								db.dfltLockMode = ((byte)(eMode));
							}

							pPager = sqlite3BtreePager(pDb.pBt);
							eMode = (int)(sqlite3PagerLockingMode(pPager, (int)(eMode)));
						}


						if ((eMode) == (1))
						{
							zRet = "exclusive";
						}

						returnSingleText(v, zRet);
						break;
					}

				case 23:
					{
						int eMode = 0;
						int ii = 0;
						if ((zRight) == (null))
						{
							eMode = (int)(-1);
						}
						else
						{
							sbyte* zMode;
							int n = (int)(sqlite3Strlen30(zRight));
							for (eMode = (int)(0); (zMode = sqlite3JournalModename((int)(eMode))) != null; eMode++)
							{
								if ((sqlite3_strnicmp(zRight, zMode, (int)(n))) == (0))
									break;
							}

							if (zMode == null)
							{
								eMode = (int)(-1);
							}

							if (((eMode) == (2)) && ((db.flags & 0x10000000) != 0))
							{
								eMode = (int)(-1);
							}
						}

						if (((eMode) == (-1)) && ((pId2->n) == (0)))
						{
							iDb = (int)(0);
							pId2->n = (uint)(1);
						}

						for (ii = (int)(db.nDb - 1); (ii) >= (0); ii--)
						{
							if (((db.aDb[ii].pBt) != null) && (((ii) == (iDb)) || ((pId2->n) == (0))))
							{
								sqlite3VdbeUsesBtree(v, (int)(ii));
								sqlite3VdbeAddOp3(v, (int)(7), (int)(ii), (int)(1), (int)(eMode));
							}
						}

						sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
						break;
					}

				case 24:
					{
						Pager pPager = sqlite3BtreePager(pDb.pBt);
						long iLimit = (long)(-2);
						if ((zRight) != null)
						{
							sqlite3DecOrHexToI64(zRight, &iLimit);
							if ((iLimit) < (-1))
								iLimit = (long)(-1);
						}

						iLimit = (long)(sqlite3PagerJournalSizeLimit(pPager, (long)(iLimit)));
						returnSingleInt(v, (long)(iLimit));
						break;
					}

				case 3:
					{
						Btree pBt = pDb.pBt;

						if (zRight == null)
						{
							returnSingleInt(v, (long)(sqlite3BtreeGetAutoVacuum(pBt)));
						}
						else
						{
							int eAuto = (int)(getAutoVacuum(zRight));

							db.nextAutovac = (sbyte)((byte)(eAuto));
							rc = (int)(sqlite3BtreeSetAutoVacuum(pBt, (int)(eAuto)));
							if (((rc) == (0)) && (((eAuto) == (1)) || ((eAuto) == (2))))
							{
								VdbeOp* aOp;
								int iAddr = (int)(sqlite3VdbeCurrentAddr(v));
								aOp = sqlite3VdbeAddOpList(v, ((int)(5 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_setMeta6, (int)(sqlite3Pragma_iLn));
								if ((0) != 0)
									break;
								aOp[0].p1 = (int)(iDb);
								aOp[1].p1 = (int)(iDb);
								aOp[2].p2 = (int)(iAddr + 4);
								aOp[4].p1 = (int)(iDb);
								aOp[4].p3 = (int)(eAuto - 1);
								sqlite3VdbeUsesBtree(v, (int)(iDb));
							}
						}

						break;
					}

				case 19:
					{
						int iLimit = 0;
						int addr = 0;
						if ((((zRight) == (null)) || (sqlite3GetInt32(zRight, &iLimit) == 0)) || ((iLimit) <= (0)))
						{
							iLimit = (int)(0x7fffffff);
						}

						sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(iLimit), (int)(1));
						addr = (int)(sqlite3VdbeAddOp1(v, (int)(61), (int)(iDb)));
						sqlite3VdbeAddOp1(v, (int)(83), (int)(1));
						sqlite3VdbeAddOp2(v, (int)(85), (int)(1), (int)(-1));
						sqlite3VdbeAddOp2(v, (int)(49), (int)(1), (int)(addr));
						sqlite3VdbeJumpHere(v, (int)(addr));
						break;
					}

				case 6:
					{

						if (zRight == null)
						{
							returnSingleInt(v, (long)(pDb.pSchema.cache_size));
						}
						else
						{
							int size = (int)(sqlite3Atoi(zRight));
							pDb.pSchema.cache_size = (int)(size);
							sqlite3BtreeSetCacheSize(pDb.pBt, (int)(pDb.pSchema.cache_size));
						}

						break;
					}

				case 7:
					{

						if (zRight == null)
						{
							returnSingleInt(v, (long)((db.flags & 0x00000020) == (0) ? 0 : sqlite3BtreeSetSpillSize(pDb.pBt, (int)(0))));
						}
						else
						{
							int size = (int)(1);
							if ((sqlite3GetInt32(zRight, &size)) != 0)
							{
								sqlite3BtreeSetSpillSize(pDb.pBt, (int)(size));
							}

							if ((sqlite3GetBoolean(zRight, (byte)(size != 0))) != 0)
							{
								db.flags |= (ulong)(0x00000020);
							}
							else
							{
								db.flags &= (ulong)(~(ulong)(0x00000020));
							}

							setAllPagerFlags(db);
						}

						break;
					}

				case 28:
					{
						long sz = 0;

						if ((zRight) != null)
						{
							int ii = 0;
							sqlite3DecOrHexToI64(zRight, &sz);
							if ((sz) < (0))
								sz = (long)(sqlite3Config.szMmap);
							if ((pId2->n) == (0))
								db.szMmap = (long)(sz);
							for (ii = (int)(db.nDb - 1); (ii) >= (0); ii--)
							{
								if (((db.aDb[ii].pBt) != null) && (((ii) == (iDb)) || ((pId2->n) == (0))))
								{
									sqlite3BtreeSetMmapLimit(db.aDb[ii].pBt, (long)(sz));
								}
							}
						}

						sz = (long)(-1);
						rc = (int)(sqlite3_file_control(db, zDb, (int)(18), &sz));
						if ((rc) == (0))
						{
							returnSingleInt(v, (long)(sz));
						}
						else if (rc != 12)
						{
							pParse.nErr++;
							pParse.rc = (int)(rc);
						}

						break;
					}

				case 39:
					{
						if (zRight == null)
						{
							returnSingleInt(v, (long)(db.temp_store));
						}
						else
						{
							changeTempStorage(pParse, zRight);
						}

						break;
					}

				case 40:
					{
						if (zRight == null)
						{
							returnSingleText(v, sqlite3_temp_directory);
						}
						else
						{
							if ((zRight[0]) != 0)
							{
								int res = 0;
								rc = (int)(sqlite3OsAccess(db.pVfs, zRight, (int)(1), &res));
								if ((rc != 0) || ((res) == (0)))
								{
									sqlite3ErrorMsg(pParse, "not a writable directory");
									goto pragma_out;
								}
							}

							if ((((1) == (0)) || (((1) == (1)) && ((db.temp_store) <= (1)))) || (((1) == (2)) && ((db.temp_store) == (1))))
							{
								invalidateTempStorage(pParse);
							}

							sqlite3_free(sqlite3_temp_directory);
							if ((zRight[0]) != 0)
							{
								sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
							}
							else
							{
								sqlite3_temp_directory = null;
							}
						}

						break;
					}

				case 11:
					{
						if (zRight == null)
						{
							returnSingleText(v, sqlite3_data_directory);
						}
						else
						{
							if ((zRight[0]) != 0)
							{
								int res = 0;
								rc = (int)(sqlite3OsAccess(db.pVfs, zRight, (int)(1), &res));
								if ((rc != 0) || ((res) == (0)))
								{
									sqlite3ErrorMsg(pParse, "not a writable directory");
									goto pragma_out;
								}
							}

							sqlite3_free(sqlite3_data_directory);
							if ((zRight[0]) != 0)
							{
								sqlite3_data_directory = sqlite3_mprintf("%s", zRight);
							}
							else
							{
								sqlite3_data_directory = null;
							}
						}

						break;
					}

				case 36:
					{
						if (zRight == null)
						{
							returnSingleInt(v, (long)(pDb.safety_level - 1));
						}
						else
						{
							if (db.autoCommit == 0)
							{
								sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction");
							}
							else if (iDb != 1)
							{
								int iLevel = (int)((getSafetyLevel(zRight, (int)(0), (byte)(1)) + 1) & 0x07);
								if ((iLevel) == (0))
									iLevel = (int)(1);
								pDb.safety_level = (byte)(iLevel);
								pDb.bSyncSet = (byte)(1);
								setAllPagerFlags(db);
							}
						}

						break;
					}

				case 4:
					{
						if ((zRight) == (null))
						{
							setPragmaResultColumnNames(v, pPragma);
							returnSingleInt(v, (long)((db.flags & pPragma->iArg) != 0));
						}
						else
						{
							ulong mask = (ulong)(pPragma->iArg);
							if ((db.autoCommit) == (0))
							{
								mask &= (ulong)(~(0x00004000));
							}

							if ((sqlite3GetBoolean(zRight, (byte)(0))) != 0)
							{
								db.flags |= (ulong)(mask);
							}
							else
							{
								db.flags &= (ulong)(~mask);
								if ((mask) == (0x00080000))
									db.nDeferredImmCons = (long)(0);
								if (((mask & 0x00000001) != 0) && ((sqlite3_stricmp(zRight, "reset")) == (0)))
								{
									sqlite3ResetAllSchemasOfConnection(db);
								}
							}

							sqlite3VdbeAddOp0(v, (int)(165));
							setAllPagerFlags(db);
						}

						break;
					}

				case 37:
					if ((zRight) != null)
					{
						Table pTab;
						sqlite3CodeVerifyNamedSchema(pParse, zDb);
						pTab = sqlite3LocateTable(pParse, (uint)(0x02), zRight, zDb);
						if ((pTab) != null)
						{
							int i = 0;
							int k = 0;
							int nHidden = (int)(0);
							Column* pCol;
							Index pPk = sqlite3PrimaryKeyIndex(pTab);
							pParse.nMem = (int)(7);
							sqlite3ViewGetColumnNames(pParse, pTab);
							for (i = (int)(0), pCol = pTab.aCol; (i) < (pTab.nCol); i++, pCol++)
							{
								int isHidden = (int)(0);
								Expr pColExpr;
								if ((pCol->colFlags & 0x0062) != 0)
								{
									if ((pPragma->iArg) == (0))
									{
										nHidden++;
										continue;
									}

									if ((pCol->colFlags & 0x0020) != 0)
									{
										isHidden = (int)(2);
									}
									else if ((pCol->colFlags & 0x0040) != 0)
									{
										isHidden = (int)(3);
									}
									else
									{

										isHidden = (int)(1);
									}
								}

								if ((pCol->colFlags & 0x0001) == (0))
								{
									k = (int)(0);
								}
								else if ((pPk) == (null))
								{
									k = (int)(1);
								}
								else
								{
									for (k = (int)(1); ((k) <= (pTab.nCol)) && (pPk.aiColumn[k - 1] != i); k++)
									{
									}
								}

								pColExpr = sqlite3ColumnExpr(pTab, pCol);


								sqlite3VdbeMultiLoad(v, (int)(1), (pPragma->iArg) != 0 ? "issisii" : "issisi", (int)(i - nHidden), pCol->zCnName, sqlite3ColumnType(pCol, ""), (int)((pCol->notNull) != 0 ? 1 : 0), (((isHidden) >= (2)) || ((pColExpr) == (null))) ? null : pColExpr.u.zToken, (int)(k), (int)(isHidden));
							}
						}
					}

					break;
				case 38:
					{
						int ii = 0;
						pParse.nMem = (int)(6);
						sqlite3CodeVerifyNamedSchema(pParse, zDb);
						for (ii = (int)(0); (ii) < (db.nDb); ii++)
						{
							HashElem* k;
							Hash* pHash;
							int initNCol = 0;
							if (((zDb) != null) && (sqlite3_stricmp(zDb, db.aDb[ii].zDbSName) != 0))
								continue;
							pHash = &db.aDb[ii].pSchema.tblHash;
							initNCol = (int)((pHash)->count);
							while ((initNCol--) != 0)
							{
								for (k = ((pHash)->first); 1; k = ((k)->next))
								{
									Table pTab;
									if ((k) == (null))
									{
										initNCol = (int)(0);
										break;
									}

									pTab = ((k)->data);
									if ((pTab.nCol) == (0))
									{
										sbyte* zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\"", pTab.zName);
										if ((zSql) != null)
										{
											sqlite3_stmt* pDummy = null;
											(void)(sqlite3_prepare(db, zSql, (int)(-1), &pDummy, null));
											(void)(sqlite3_finalize(pDummy));
											sqlite3DbFree(db, zSql);
										}

										if ((db.mallocFailed) != 0)
										{
											sqlite3ErrorMsg(db.pParse, "out of memory");
											db.pParse.rc = (int)(7);
										}

										pHash = &db.aDb[ii].pSchema.tblHash;
										break;
									}
								}
							}

							for (k = ((pHash)->first); k; k = ((k)->next))
							{
								Table pTab = ((k)->data);
								sbyte* zType;
								if (((zRight) != null) && (sqlite3_stricmp(zRight, pTab.zName) != 0))
									continue;
								if ((((pTab).eTabType) == (2)))
								{
									zType = "view";
								}
								else if ((((pTab).eTabType) == (1)))
								{
									zType = "virtual";
								}
								else if ((pTab.tabFlags & 0x00001000) != 0)
								{
									zType = "shadow";
								}
								else
								{
									zType = "table";
								}

								sqlite3VdbeMultiLoad(v, (int)(1), "sssiii", db.aDb[ii].zDbSName, sqlite3PreferredTableName(pTab.zName), zType, (int)(pTab.nCol), (int)((pTab.tabFlags & 0x00000080) != 0), (int)((pTab.tabFlags & 0x00010000) != 0));
							}
						}
					}

					break;
				case 20:
					if ((zRight) != null)
					{
						Index pIdx;
						Table pTab;
						pIdx = sqlite3FindIndex(db, zRight, zDb);
						if ((pIdx) == (null))
						{
							pTab = sqlite3LocateTable(pParse, (uint)(0x02), zRight, zDb);
							if (((pTab) != null) && (!(((pTab).tabFlags & 0x00000080) == (0))))
							{
								pIdx = sqlite3PrimaryKeyIndex(pTab);
							}
						}

						if ((pIdx) != null)
						{
							int iIdxDb = (int)(sqlite3SchemaToIndex(db, pIdx.pSchema));
							int i = 0;
							int mx = 0;
							if ((pPragma->iArg) != 0)
							{
								mx = (int)(pIdx.nColumn);
								pParse.nMem = (int)(6);
							}
							else
							{
								mx = (int)(pIdx.nKeyCol);
								pParse.nMem = (int)(3);
							}

							pTab = pIdx.pTable;
							sqlite3CodeVerifySchema(pParse, (int)(iIdxDb));

							for (i = (int)(0); (i) < (mx); i++)
							{
								short cnum = (short)(pIdx.aiColumn[i]);
								sqlite3VdbeMultiLoad(v, (int)(1), "iisX", (int)(i), (int)(cnum), (cnum) < (0) ? null : pTab.aCol[cnum].zCnName);
								if ((pPragma->iArg) != 0)
								{
									sqlite3VdbeMultiLoad(v, (int)(4), "isiX", (int)(pIdx.aSortOrder[i]), pIdx.azColl[i], ((i) < (pIdx.nKeyCol) ? 1 : 0));
								}

								sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(pParse.nMem));
							}
						}
					}

					break;
				case 21:
					if ((zRight) != null)
					{
						Index pIdx;
						Table pTab;
						int i = 0;
						pTab = sqlite3FindTable(db, zRight, zDb);
						if ((pTab) != null)
						{
							int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
							pParse.nMem = (int)(5);
							sqlite3CodeVerifySchema(pParse, (int)(iTabDb));
							for (pIdx = pTab.pIndex, i = (int)(0); pIdx; pIdx = pIdx.pNext, i++)
							{
								sbyte** azOrigin = stackalloc sbyte*[] { "c", "u", "pk" };
								sqlite3VdbeMultiLoad(v, (int)(1), "isisi", (int)(i), pIdx.zName, (int)((pIdx).onError != 0), azOrigin[pIdx.idxType], (int)(pIdx.pPartIdxWhere != null));
							}
						}
					}

					break;
				case 12:
					{
						int i = 0;
						pParse.nMem = (int)(3);
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							if ((db.aDb[i].pBt) == (null))
								continue;

							sqlite3VdbeMultiLoad(v, (int)(1), "iss", (int)(i), db.aDb[i].zDbSName, sqlite3BtreeGetFilename(db.aDb[i].pBt));
						}
					}

					break;
				case 9:
					{
						int i = (int)(0);
						HashElem* p;
						pParse.nMem = (int)(2);
						for (p = ((&db.aCollSeq)->first); p; p = ((p)->next))
						{
							CollSeq pColl = (CollSeq)((p)->data);
							sqlite3VdbeMultiLoad(v, (int)(1), "is", (int)(i++), pColl.zName);
						}
					}

					break;
				case 17:
					{
						int i = 0;
						HashElem* j;
						FuncDef p;
						int showInternFunc = (int)((db.mDbFlags & 0x0020) != 0);
						pParse.nMem = (int)(6);
						for (i = (int)(0); (i) < (23); i++)
						{
							for (p = sqlite3BuiltinFunctions.a[i]; p; p = p.u.pHash)
							{

								pragmaFunclistLine(v, p, (int)(1), (int)(showInternFunc));
							}
						}

						for (j = ((&db.aFunc)->first); j; j = ((j)->next))
						{
							p = (FuncDef)((j)->data);

							pragmaFunclistLine(v, p, (int)(0), (int)(showInternFunc));
						}
					}

					break;
				case 29:
					{
						HashElem* j;
						pParse.nMem = (int)(1);
						for (j = ((&db.aModule)->first); j; j = ((j)->next))
						{
							Module pMod = (Module)((j)->data);
							sqlite3VdbeMultiLoad(v, (int)(1), "s", pMod.zName);
						}
					}

					break;
				case 32:
					{
						int i = 0;
						for (i = (int)(0); (i) < ((int)(67 * sizeof(PragmaName) / sizeof(PragmaName))); i++)
						{
							sqlite3VdbeMultiLoad(v, (int)(1), "s", aPragmaName[i].zName);
						}
					}

					break;
				case 16:
					if ((zRight) != null)
					{
						FKey pFK;
						Table pTab;
						pTab = sqlite3FindTable(db, zRight, zDb);
						if (((pTab) != null) && (((pTab).eTabType) == (0)))
						{
							pFK = pTab.u.tab.pFKey;
							if ((pFK) != null)
							{
								int iTabDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
								int i = (int)(0);
								pParse.nMem = (int)(8);
								sqlite3CodeVerifySchema(pParse, (int)(iTabDb));
								while ((pFK) != null)
								{
									int j = 0;
									for (j = (int)(0); (j) < (pFK.nCol); j++)
									{
										sqlite3VdbeMultiLoad(v, (int)(1), "iissssss", (int)(i), (int)(j), pFK.zTo, pTab.aCol[pFK.aCol[j].iFrom].zCnName, pFK.aCol[j].zCol, actionName((byte)(pFK.aAction[1])), actionName((byte)(pFK.aAction[0])), "NONE");
									}

									++i;
									pFK = pFK.pNextFrom;
								}
							}
						}
					}

					break;
				case 15:
					{
						FKey pFK;
						Table pTab;
						Table pParent;
						Index pIdx;
						int i = 0;
						int j = 0;
						HashElem* k;
						int x = 0;
						int regResult = 0;
						int regKey = 0;
						int regRow = 0;
						int addrTop = 0;
						int addrOk = 0;
						int* aiCols;
						regResult = (int)(pParse.nMem + 1);
						pParse.nMem += (int)(4);
						regKey = (int)(++pParse.nMem);
						regRow = (int)(++pParse.nMem);
						k = ((&db.aDb[iDb].pSchema.tblHash)->first);
						while ((k) != null)
						{
							if ((zRight) != null)
							{
								pTab = sqlite3LocateTable(pParse, (uint)(0), zRight, zDb);
								k = null;
							}
							else
							{
								pTab = (Table)((k)->data);
								k = ((k)->next);
							}

							if ((((pTab) == (null)) || (!(((pTab).eTabType) == (0)))) || ((pTab.u.tab.pFKey) == (null)))
								continue;
							iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
							zDb = db.aDb[iDb].zDbSName;
							sqlite3CodeVerifySchema(pParse, (int)(iDb));
							sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
							if ((pTab.nCol + regRow) > (pParse.nMem))
								pParse.nMem = (int)(pTab.nCol + regRow);
							sqlite3OpenTable(pParse, (int)(0), (int)(iDb), pTab, (int)(101));
							sqlite3VdbeLoadString(v, (int)(regResult), pTab.zName);

							for (i = (int)(1), pFK = pTab.u.tab.pFKey; pFK; i++, pFK = pFK.pNextFrom)
							{
								pParent = sqlite3FindTable(db, pFK.zTo, zDb);
								if ((pParent) == (null))
									continue;
								pIdx = null;
								sqlite3TableLock(pParse, (int)(iDb), (uint)(pParent.tnum), (byte)(0), pParent.zName);
								x = (int)(sqlite3FkLocateIndex(pParse, pParent, pFK, pIdx, null));
								if ((x) == (0))
								{
									if ((pIdx) == (null))
									{
										sqlite3OpenTable(pParse, (int)(i), (int)(iDb), pParent, (int)(101));
									}
									else
									{
										sqlite3VdbeAddOp3(v, (int)(101), (int)(i), (int)(pIdx.tnum), (int)(iDb));
										sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
									}
								}
								else
								{
									k = null;
									break;
								}
							}


							if ((pFK) != null)
								break;
							if ((pParse.nTab) < (i))
								pParse.nTab = (int)(i);
							addrTop = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(0)));

							for (i = (int)(1), pFK = pTab.u.tab.pFKey; pFK; i++, pFK = pFK.pNextFrom)
							{
								pParent = sqlite3FindTable(db, pFK.zTo, zDb);
								pIdx = null;
								aiCols = null;
								if ((pParent) != null)
								{
									x = (int)(sqlite3FkLocateIndex(pParse, pParent, pFK, pIdx, &aiCols));

								}

								addrOk = (int)(sqlite3VdbeMakeLabel(pParse));
								if ((regRow + pFK.nCol) > (pParse.nMem))
									pParse.nMem = (int)(regRow + pFK.nCol);
								for (j = (int)(0); (j) < (pFK.nCol); j++)
								{
									int iCol = (int)((aiCols) != 0 ? aiCols[j] : pFK.aCol[j].iFrom);
									sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(0), (int)(iCol), (int)(regRow + j));
									sqlite3VdbeAddOp2(v, (int)(50), (int)(regRow + j), (int)(addrOk));
								}

								if ((pIdx) != null)
								{
									sqlite3VdbeAddOp4(v, (int)(96), (int)(regRow), (int)(pFK.nCol), (int)(regKey), sqlite3IndexAffinityStr(db, pIdx), (int)(pFK.nCol));
									sqlite3VdbeAddOp4Int(v, (int)(31), (int)(i), (int)(addrOk), (int)(regKey), (int)(0));
								}
								else if ((pParent) != null)
								{
									int jmp = (int)(sqlite3VdbeCurrentAddr(v) + 2);
									sqlite3VdbeAddOp3(v, (int)(32), (int)(i), (int)(jmp), (int)(regRow));
									sqlite3VdbeGoto(v, (int)(addrOk));

								}

								if ((((pTab).tabFlags & 0x00000080) == (0)))
								{
									sqlite3VdbeAddOp2(v, (int)(134), (int)(0), (int)(regResult + 1));
								}
								else
								{
									sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regResult + 1));
								}

								sqlite3VdbeMultiLoad(v, (int)(regResult + 2), "siX", pFK.zTo, (int)(i - 1));
								sqlite3VdbeAddOp2(v, (int)(83), (int)(regResult), (int)(4));
								sqlite3VdbeResolveLabel(v, (int)(addrOk));
								sqlite3DbFree(db, aiCols);
							}

							sqlite3VdbeAddOp2(v, (int)(5), (int)(0), (int)(addrTop + 1));
							sqlite3VdbeJumpHere(v, (int)(addrTop));
						}
					}

					break;
				case 8:
					{
						if ((zRight) != null)
						{
							sqlite3RegisterLikeFunctions(db, (int)(sqlite3GetBoolean(zRight, (byte)(0))));
						}
					}

					break;
				case 22:
					{
						int i = 0;
						int j = 0;
						int addr = 0;
						int mxErr = 0;
						Table pObjTab = null;
						int isQuick = (int)(((sqlite3UpperToLower[(byte)(zLeft[0])]) == (113)) ? 1 : 0);


						if ((pId2->z) == (null))
							iDb = (int)(-1);
						pParse.nMem = (int)(6);
						mxErr = (int)(100);
						if ((zRight) != null)
						{
							if ((sqlite3GetInt32(zRight, &mxErr)) != 0)
							{
								if ((mxErr) <= (0))
								{
									mxErr = (int)(100);
								}
							}
							else
							{
								pObjTab = sqlite3LocateTable(pParse, (uint)(0), zRight, (iDb) >= (0) ? db.aDb[iDb].zDbSName : null);
							}
						}

						sqlite3VdbeAddOp2(v, (int)(71), (int)(mxErr - 1), (int)(1));
						for (i = (int)(0); (i) < (db.nDb); i++)
						{
							HashElem* x;
							Hash* pTbls;
							int* aRoot;
							int cnt = (int)(0);
							int mxIdx = (int)(0);
							if (((0) != 0) && ((i) == (1)))
								continue;
							if (((iDb) >= (0)) && (i != iDb))
								continue;
							sqlite3CodeVerifySchema(pParse, (int)(i));

							pTbls = &db.aDb[i].pSchema.tblHash;
							for (cnt = (int)(0), x = ((pTbls)->first); x; x = ((x)->next))
							{
								Table pTab = ((x)->data);
								Index pIdx;
								int nIdx = 0;
								if (((pObjTab) != null) && (pObjTab != pTab))
									continue;
								if ((((pTab).tabFlags & 0x00000080) == (0)))
									cnt++;
								for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
								{
									cnt++;
								}

								if ((nIdx) > (mxIdx))
									mxIdx = (int)(nIdx);
							}

							if ((cnt) == (0))
								continue;
							if ((pObjTab) != null)
								cnt++;
							aRoot = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (cnt + 1)));
							if ((aRoot) == (null))
								break;
							cnt = (int)(0);
							if ((pObjTab) != null)
								aRoot[++cnt] = (int)(0);
							for (x = ((pTbls)->first); x; x = ((x)->next))
							{
								Table pTab = ((x)->data);
								Index pIdx;
								if (((pObjTab) != null) && (pObjTab != pTab))
									continue;
								if ((((pTab).tabFlags & 0x00000080) == (0)))
									aRoot[++cnt] = (int)(pTab.tnum);
								for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
								{
									aRoot[++cnt] = (int)(pIdx.tnum);
								}
							}

							aRoot[0] = (int)(cnt);
							pParse.nMem = (int)((pParse.nMem) > (8 + mxIdx) ? (pParse.nMem) : (8 + mxIdx));
							sqlite3ClearTempRegCache(pParse);
							sqlite3VdbeAddOp4(v, (int)(154), (int)(2), (int)(cnt), (int)(1), (sbyte*)(aRoot), (int)(-15));
							sqlite3VdbeChangeP5(v, (ushort)((byte)(i)));
							addr = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(2)));
							sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), sqlite3MPrintf(db, "*** in database %s ***\n", db.aDb[i].zDbSName), (int)(-7));
							sqlite3VdbeAddOp3(v, (int)(111), (int)(2), (int)(3), (int)(3));
							integrityCheckResultRow(v);
							sqlite3VdbeJumpHere(v, (int)(addr));
							for (x = ((pTbls)->first); x; x = ((x)->next))
							{
								Table pTab = ((x)->data);
								Index pIdx;
								Index pPk;
								Index pPrior = null;
								int loopTop = 0;
								int iDataCur = 0;
								int iIdxCur = 0;
								int r1 = (int)(-1);
								int bStrict = 0;
								if (!(((pTab).eTabType) == (0)))
									continue;
								if (((pObjTab) != null) && (pObjTab != pTab))
									continue;
								pPk = (((pTab).tabFlags & 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
								sqlite3OpenTableAndIndices(pParse, pTab, (int)(101), (byte)(0), (int)(1), null, &iDataCur, &iIdxCur);
								sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(7));
								for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
								{
									sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(8 + j));
								}



								sqlite3VdbeAddOp2(v, (int)(38), (int)(iDataCur), (int)(0));
								loopTop = (int)(sqlite3VdbeAddOp2(v, (int)(85), (int)(7), (int)(1)));
								if (isQuick == 0)
								{
									sqlite3VdbeAddOp3(v, (int)(93), (int)(iDataCur), (int)(pTab.nNVCol - 1), (int)(3));
									sqlite3VdbeChangeP5(v, (ushort)(0x80));
								}

								bStrict = (int)((pTab.tabFlags & 0x00010000) != 0);
								for (j = (int)(0); (j) < (pTab.nCol); j++)
								{
									sbyte* zErr;
									Column* pCol = pTab.aCol + j;
									int doError = 0;
									int jmp2 = 0;
									if ((j) == (pTab.iPKey))
										continue;
									if (((pCol->notNull) == (0)) && (bStrict == 0))
										continue;
									doError = (int)((bStrict) != 0 ? sqlite3VdbeMakeLabel(pParse) : 0);
									sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(j), (int)(3));
									if ((sqlite3VdbeGetOp(v, (int)(-1))->opcode) == (93))
									{
										sqlite3VdbeChangeP5(v, (ushort)(0x80));
									}

									if ((pCol->notNull) != 0)
									{
										jmp2 = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(3)));
										zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab.zName, pCol->zCnName);
										sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
										if (((bStrict) != 0) && (pCol->eCType != 1))
										{
											sqlite3VdbeGoto(v, (int)(doError));
										}
										else
										{
											integrityCheckResultRow(v);
										}

										sqlite3VdbeJumpHere(v, (int)(jmp2));
									}

									if (((pTab.tabFlags & 0x00010000) != 0) && (pCol->eCType != 1))
									{
										jmp2 = (int)(sqlite3VdbeAddOp3(v, (int)(21), (int)(3), (int)(0), (int)(sqlite3StdTypeMap[pCol->eCType - 1])));
										zErr = sqlite3MPrintf(db, "non-%s value in %s.%s", sqlite3StdType[pCol->eCType - 1], pTab.zName, pTab.aCol[j].zCnName);
										sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
										sqlite3VdbeResolveLabel(v, (int)(doError));
										integrityCheckResultRow(v);
										sqlite3VdbeJumpHere(v, (int)(jmp2));
									}
								}

								if (((pTab.pCheck) != null) && ((db.flags & 0x00000200) == (0)))
								{
									ExprList pCheck = sqlite3ExprListDup(db, pTab.pCheck, (int)(0));
									if ((db.mallocFailed) == (0))
									{
										int addrCkFault = (int)(sqlite3VdbeMakeLabel(pParse));
										int addrCkOk = (int)(sqlite3VdbeMakeLabel(pParse));
										sbyte* zErr;
										int k = 0;
										pParse.iSelfTab = (int)(iDataCur + 1);
										for (k = (int)(pCheck.nExpr - 1); (k) > (0); k--)
										{
											sqlite3ExprIfFalse(pParse, pCheck.a[k].pExpr, (int)(addrCkFault), (int)(0));
										}

										sqlite3ExprIfTrue(pParse, pCheck.a[0].pExpr, (int)(addrCkOk), (int)(0x10));
										sqlite3VdbeResolveLabel(v, (int)(addrCkFault));
										pParse.iSelfTab = (int)(0);
										zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s", pTab.zName);
										sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(3), (int)(0), zErr, (int)(-7));
										integrityCheckResultRow(v);
										sqlite3VdbeResolveLabel(v, (int)(addrCkOk));
									}

									sqlite3ExprListDelete(db, pCheck);
								}

								if (isQuick == 0)
								{
									for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
									{
										int jmp2 = 0;
										int jmp3 = 0;
										int jmp4 = 0;
										int jmp5 = 0;
										int ckUniq = (int)(sqlite3VdbeMakeLabel(pParse));
										if ((pPk) == (pIdx))
											continue;
										r1 = (int)(sqlite3GenerateIndexKey(pParse, pIdx, (int)(iDataCur), (int)(0), (int)(0), &jmp3, pPrior, (int)(r1)));
										pPrior = pIdx;
										sqlite3VdbeAddOp2(v, (int)(85), (int)(8 + j), (int)(1));
										jmp2 = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iIdxCur + j), (int)(ckUniq), (int)(r1), (int)(pIdx.nColumn)));
										sqlite3VdbeLoadString(v, (int)(3), "row ");
										sqlite3VdbeAddOp3(v, (int)(111), (int)(7), (int)(3), (int)(3));
										sqlite3VdbeLoadString(v, (int)(4), " missing from index ");
										sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(3), (int)(3));
										jmp5 = (int)(sqlite3VdbeLoadString(v, (int)(4), pIdx.zName));
										sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(3), (int)(3));
										jmp4 = (int)(integrityCheckResultRow(v));
										sqlite3VdbeJumpHere(v, (int)(jmp2));
										if (((pIdx).onError != 0))
										{
											int uniqOk = (int)(sqlite3VdbeMakeLabel(pParse));
											int jmp6 = 0;
											int kk = 0;
											for (kk = (int)(0); (kk) < (pIdx.nKeyCol); kk++)
											{
												int iCol = (int)(pIdx.aiColumn[kk]);

												if (((iCol) >= (0)) && ((pTab.aCol[iCol].notNull) != 0))
													continue;
												sqlite3VdbeAddOp2(v, (int)(50), (int)(r1 + kk), (int)(uniqOk));
											}

											jmp6 = (int)(sqlite3VdbeAddOp1(v, (int)(5), (int)(iIdxCur + j)));
											sqlite3VdbeGoto(v, (int)(uniqOk));
											sqlite3VdbeJumpHere(v, (int)(jmp6));
											sqlite3VdbeAddOp4Int(v, (int)(40), (int)(iIdxCur + j), (int)(uniqOk), (int)(r1), (int)(pIdx.nKeyCol));
											sqlite3VdbeLoadString(v, (int)(3), "non-unique entry in index ");
											sqlite3VdbeGoto(v, (int)(jmp5));
											sqlite3VdbeResolveLabel(v, (int)(uniqOk));
										}

										sqlite3VdbeJumpHere(v, (int)(jmp4));
										sqlite3ResolvePartIdxLabel(pParse, (int)(jmp3));
									}
								}

								sqlite3VdbeAddOp2(v, (int)(5), (int)(iDataCur), (int)(loopTop));
								sqlite3VdbeJumpHere(v, (int)(loopTop - 1));
								if (isQuick == 0)
								{
									sqlite3VdbeLoadString(v, (int)(2), "wrong # of entries in index ");
									for (j = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, j++)
									{
										if ((pPk) == (pIdx))
											continue;
										sqlite3VdbeAddOp2(v, (int)(97), (int)(iIdxCur + j), (int)(3));
										addr = (int)(sqlite3VdbeAddOp3(v, (int)(53), (int)(8 + j), (int)(0), (int)(3)));
										sqlite3VdbeChangeP5(v, (ushort)(0x90));
										sqlite3VdbeLoadString(v, (int)(4), pIdx.zName);
										sqlite3VdbeAddOp3(v, (int)(111), (int)(4), (int)(2), (int)(3));
										integrityCheckResultRow(v);
										sqlite3VdbeJumpHere(v, (int)(addr));
									}
								}
							}
						}

						{
							VdbeOp* aOp;
							aOp = sqlite3VdbeAddOpList(v, ((int)(7 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_endCode, (int)(sqlite3Pragma_iLn));
							if ((aOp) != null)
							{
								aOp[0].p2 = (int)(1 - mxErr);
								aOp[2].p4type = (sbyte)(-1);
								aOp[2].p4.z = "ok";
								aOp[5].p4type = (sbyte)(-1);
								aOp[5].p4.z = sqlite3ErrStr((int)(11));
							}

							sqlite3VdbeChangeP3(v, (int)(0), (int)(sqlite3VdbeCurrentAddr(v) - 2));
						}
					}

					break;
				case 14:
					{
						EncName* pEnc;
						if (zRight == null)
						{
							if ((sqlite3ReadSchema(pParse)) != 0)
								goto pragma_out;



							returnSingleText(v, sqlite3Pragma_encnames[((pParse.db).enc)].zName);
						}
						else
						{
							if ((db.mDbFlags & 0x0040) == (0))
							{
								for (pEnc = &sqlite3Pragma_encnames[0]; pEnc->zName; pEnc++)
								{
									if ((0) == (sqlite3StrICmp(zRight, pEnc->zName)))
									{
										byte enc = (byte)((pEnc->enc) != 0 ? pEnc->enc : 2);
										((db).aDb[0].pSchema.enc) = (byte)(enc);
										sqlite3SetTextEncoding(db, (byte)(enc));
										break;
									}
								}

								if (pEnc->zName == null)
								{
									sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
								}
							}
						}
					}

					break;
				case 2:
					{
						int iCookie = (int)(pPragma->iArg);
						sqlite3VdbeUsesBtree(v, (int)(iDb));
						if (((zRight) != null) && ((pPragma->mPragFlg & 0x08) == (0)))
						{
							VdbeOp* aOp;
							aOp = sqlite3VdbeAddOpList(v, ((int)(2 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_setCookie, (int)(0));
							if ((0) != 0)
								break;
							aOp[0].p1 = (int)(iDb);
							aOp[1].p1 = (int)(iDb);
							aOp[1].p2 = (int)(iCookie);
							aOp[1].p3 = (int)(sqlite3Atoi(zRight));
							aOp[1].p5 = (ushort)(1);
						}
						else
						{
							VdbeOp* aOp;
							aOp = sqlite3VdbeAddOpList(v, ((int)(3 * sizeof(VdbeOpList) / sizeof(VdbeOpList))), sqlite3Pragma_readCookie, (int)(0));
							if ((0) != 0)
								break;
							aOp[0].p1 = (int)(iDb);
							aOp[1].p1 = (int)(iDb);
							aOp[1].p3 = (int)(iCookie);
							sqlite3VdbeReusable(v);
						}
					}

					break;
				case 10:
					{
						int i = (int)(0);
						sbyte* zOpt;
						pParse.nMem = (int)(1);
						while ((zOpt = sqlite3_compileoption_get((int)(i++))) != null)
						{
							sqlite3VdbeLoadString(v, (int)(1), zOpt);
							sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(1));
						}

						sqlite3VdbeReusable(v);
					}

					break;
				case 43:
					{
						int iBt = (int)((pId2->z) != 0 ? iDb : (10 + 2));
						int eMode = (int)(0);
						if ((zRight) != null)
						{
							if ((sqlite3StrICmp(zRight, "full")) == (0))
							{
								eMode = (int)(1);
							}
							else if ((sqlite3StrICmp(zRight, "restart")) == (0))
							{
								eMode = (int)(2);
							}
							else if ((sqlite3StrICmp(zRight, "truncate")) == (0))
							{
								eMode = (int)(3);
							}
						}

						pParse.nMem = (int)(3);
						sqlite3VdbeAddOp3(v, (int)(6), (int)(iBt), (int)(eMode), (int)(1));
						sqlite3VdbeAddOp2(v, (int)(83), (int)(1), (int)(3));
					}

					break;
				case 42:
					{
						if ((zRight) != null)
						{
							sqlite3_wal_autocheckpoint(db, (int)(sqlite3Atoi(zRight)));
						}

						returnSingleInt(v, (long)((db.xWalCallback) == (sqlite3WalDefaultHook) ? ((int)((long)(db.pWalArg))) : 0));
					}

					break;
				case 34:
					{
						sqlite3_db_release_memory(db);
						break;
					}

				case 30:
					{
						int iDbLast = 0;
						int iTabCur = 0;
						HashElem* k;
						Schema pSchema;
						Table pTab;
						Index pIdx;
						short szThreshold = 0;
						sbyte* zSubSql;
						uint opMask = 0;
						if ((zRight) != null)
						{
							opMask = ((uint)(sqlite3Atoi(zRight)));
							if ((opMask & 0x02) == (0))
								break;
						}
						else
						{
							opMask = (uint)(0xfffe);
						}

						iTabCur = (int)(pParse.nTab++);
						for (iDbLast = (int)((zDb) != 0 ? iDb : db.nDb - 1); (iDb) <= (iDbLast); iDb++)
						{
							if ((iDb) == (1))
								continue;
							sqlite3CodeVerifySchema(pParse, (int)(iDb));
							pSchema = db.aDb[iDb].pSchema;
							for (k = ((&pSchema.tblHash)->first); k; k = ((k)->next))
							{
								pTab = (Table)((k)->data);
								if ((pTab.tabFlags & 0x00000100) == (0))
									continue;
								szThreshold = (short)(pTab.nRowLogEst + 46);

								for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
								{
									if (pIdx.hasStat1 == 0)
									{
										szThreshold = (short)(0);
										break;
									}
								}

								if ((szThreshold) != 0)
								{
									sqlite3OpenTable(pParse, (int)(iTabCur), (int)(iDb), pTab, (int)(101));
									sqlite3VdbeAddOp3(v, (int)(35), (int)(iTabCur), (int)(sqlite3VdbeCurrentAddr(v) + 2 + (opMask & 1)), (int)(szThreshold));
								}

								zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"", db.aDb[iDb].zDbSName, pTab.zName);
								if ((opMask & 0x01) != 0)
								{
									int r1 = (int)(sqlite3GetTempReg(pParse));
									sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(r1), (int)(0), zSubSql, (int)(-7));
									sqlite3VdbeAddOp2(v, (int)(83), (int)(r1), (int)(1));
								}
								else
								{
									sqlite3VdbeAddOp4(v, (int)(147), (int)(0), (int)(0), (int)(0), zSubSql, (int)(-7));
								}
							}
						}

						sqlite3VdbeAddOp0(v, (int)(165));
						break;
					}

				default:
					{

						if ((zRight) != null)
						{
							sqlite3_busy_timeout(db, (int)(sqlite3Atoi(zRight)));
						}

						returnSingleInt(v, (long)(db.busyTimeout));
						break;
					}

				case 35:
					{
						long N = 0;
						if (((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0)))
						{
							sqlite3_soft_heap_limit64((long)(N));
						}

						returnSingleInt(v, (long)(sqlite3_soft_heap_limit64((long)(-1))));
						break;
					}

				case 18:
					{
						long N = 0;
						if (((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0)))
						{
							long iPrior = (long)(sqlite3_hard_heap_limit64((long)(-1)));
							if (((N) > (0)) && (((iPrior) == (0)) || ((iPrior) > (N))))
								sqlite3_hard_heap_limit64((long)(N));
						}

						returnSingleInt(v, (long)(sqlite3_hard_heap_limit64((long)(-1))));
						break;
					}

				case 41:
					{
						long N = 0;
						if ((((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0))) && ((N) >= (0)))
						{
							sqlite3_limit(db, (int)(11), (int)(N & 0x7fffffff));
						}

						returnSingleInt(v, (long)(sqlite3_limit(db, (int)(11), (int)(-1))));
						break;
					}

				case 1:
					{
						long N = 0;
						if ((((zRight) != null) && ((sqlite3DecOrHexToI64(zRight, &N)) == (0))) && ((N) >= (0)))
						{
							db.nAnalysisLimit = ((int)(N & 0x7fffffff));
						}

						returnSingleInt(v, (long)(db.nAnalysisLimit));
						break;
					}
			}

			if (((pPragma->mPragFlg & 0x04) != 0) && ((zRight) != null))
			{
			}

		pragma_out:
			; sqlite3DbFree(db, zLeft);
			sqlite3DbFree(db, zRight);
		}
		public static Module sqlite3PragmaVtabRegister(sqlite3 db, sbyte* zName)
		{
			PragmaName* pName;

			pName = pragmaLocate(zName + 7);
			if ((pName) == (null))
				return null;
			if ((pName->mPragFlg & (0x10 | 0x20)) == (0))
				return null;

			return sqlite3VtabCreateModule(db, zName, pragmaVtabModule, (void*)(pName), null);
		}
		public static sbyte* sqlite3PreferredTableName(sbyte* zName)
		{
			if ((sqlite3_strnicmp(zName, "sqlite_", (int)(7))) == (0))
			{
				if ((sqlite3StrICmp(zName + 7, &"sqlite_master"[7])) == (0))
				{
					return "sqlite_schema";
				}

				if ((sqlite3StrICmp(zName + 7, &"sqlite_temp_master"[7])) == (0))
				{
					return "sqlite_temp_schema";
				}
			}

			return zName;
		}
		public static int sqlite3Prepare(sqlite3 db, sbyte* zSql, int nBytes, uint prepFlags, Vdbe pReprepare, sqlite3_stmt** ppStmt, sbyte** pzTail)
		{
			int rc = (int)(0);
			int i = 0;
			Parse sParse = new Parse();
			CRuntime.memset((((sbyte*)(sParse)) + ((ulong)(&((0).zErrMsg)))), (int)(0), (ulong)(((ulong)(&((0).aTempReg))) - ((ulong)(&((0).zErrMsg)))));
			CRuntime.memset((((sbyte*)(sParse)) + ((ulong)(&((0).sLastToken)))), (int)(0), (ulong)(sizeof(Parse) - ((ulong)(&((0).sLastToken)))));
			sParse.pOuterParse = db.pParse;
			db.pParse = sParse;
			sParse.db = db;
			sParse.pReprepare = pReprepare;

			if ((db.mallocFailed) != 0)
				sqlite3ErrorMsg(sParse, "out of memory");

			if ((prepFlags & 0x01) != 0)
			{
				sParse.disableLookaside++;
				db.lookaside.bDisable++;
				db.lookaside.sz = (ushort)(0);
			}

			sParse.disableVtab = (byte)((prepFlags & 0x04) != 0);
			if (db.noSharedCache == 0)
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{

						rc = (int)(sqlite3BtreeSchemaLocked(pBt));
						if ((rc) != 0)
						{
							sbyte* zDb = db.aDb[i].zDbSName;
							sqlite3ErrorWithMsg(db, (int)(rc), "database schema is locked: %s", zDb);
							goto end_prepare;
						}
					}
				}
			}

			sqlite3VtabUnlockList(db);
			if (((nBytes) >= (0)) && (((nBytes) == (0)) || (zSql[nBytes - 1] != 0)))
			{
				sbyte* zSqlCopy;
				int mxLen = (int)(db.aLimit[1]);
				if ((nBytes) > (mxLen))
				{
					sqlite3ErrorWithMsg(db, (int)(18), "statement too long");
					rc = (int)(sqlite3ApiExit(db, (int)(18)));
					goto end_prepare;
				}

				zSqlCopy = sqlite3DbStrNDup(db, zSql, (ulong)(nBytes));
				if ((zSqlCopy) != null)
				{
					sqlite3RunParser(sParse, zSqlCopy);
					sParse.zTail = &zSql[sParse.zTail - zSqlCopy];
					sqlite3DbFree(db, zSqlCopy);
				}
				else
				{
					sParse.zTail = &zSql[nBytes];
				}
			}
			else
			{
				sqlite3RunParser(sParse, zSql);
			}


			if ((pzTail) != null)
			{
				*pzTail = sParse.zTail;
			}

			if ((db.init.busy) == (0))
			{
				sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail - zSql), (byte)(prepFlags));
			}

			if ((db.mallocFailed) != 0)
			{
				sParse.rc = (int)(7);
				sParse.checkSchema = (byte)(0);
			}

			if ((sParse.rc != 0) && (sParse.rc != 101))
			{
				if (((sParse.checkSchema) != 0) && ((db.init.busy) == (0)))
				{
					schemaIsValid(sParse);
				}

				if ((sParse.pVdbe) != null)
				{
					sqlite3VdbeFinalize(sParse.pVdbe);
				}


				rc = (int)(sParse.rc);
				if ((sParse.zErrMsg) != null)
				{
					sqlite3ErrorWithMsg(db, (int)(rc), "%s", sParse.zErrMsg);
					sqlite3DbFree(db, sParse.zErrMsg);
				}
				else
				{
					sqlite3Error(db, (int)(rc));
				}
			}
			else
			{

				*ppStmt = (sqlite3_stmt*)(sParse.pVdbe);
				rc = (int)(0);
				sqlite3ErrorClear(db);
			}

			while ((sParse.pTriggerPrg) != null)
			{
				TriggerPrg pT = sParse.pTriggerPrg;
				sParse.pTriggerPrg = pT.pNext;
				sqlite3DbFree(db, pT);
			}

		end_prepare:
			; sqlite3ParseObjectReset(sParse);
			return (int)(rc);
		}
		public static int sqlite3Prepare16(sqlite3 db, void* zSql, int nBytes, uint prepFlags, sqlite3_stmt** ppStmt, void** pzTail)
		{
			sbyte* zSql8;
			sbyte* zTail8 = null;
			int rc = (int)(0);
			*ppStmt = null;
			if ((sqlite3SafetyCheckOk(db) == 0) || ((zSql) == (null)))
			{
				return (int)(sqlite3MisuseError((int)(134140)));
			}

			if ((nBytes) >= (0))
			{
				int sz = 0;
				sbyte* z = (sbyte*)(zSql);
				for (sz = (int)(0); ((sz) < (nBytes)) && ((z[sz] != 0) || (z[sz + 1] != 0)); sz += (int)(2))
				{
				}

				nBytes = (int)(sz);
			}

			sqlite3_mutex_enter(db.mutex);
			zSql8 = sqlite3Utf16to8(db, zSql, (int)(nBytes), (byte)(2));
			if ((zSql8) != null)
			{
				rc = (int)(sqlite3LockAndPrepare(db, zSql8, (int)(-1), (uint)(prepFlags), null, ppStmt, &zTail8));
			}

			if (((zTail8) != null) && ((pzTail) != null))
			{
				int chars_parsed = (int)(sqlite3Utf8CharLen(zSql8, (int)(zTail8 - zSql8)));
				*pzTail = (byte*)(zSql) + sqlite3Utf16ByteLen(zSql, (int)(chars_parsed));
			}

			sqlite3DbFree(db, zSql8);
			rc = (int)(sqlite3ApiExit(db, (int)(rc)));
			sqlite3_mutex_leave(db.mutex);
			return (int)(rc);
		}
		public static Index sqlite3PrimaryKeyIndex(Table pTab)
		{
			Index p;
			for (p = pTab.pIndex; ((p) != null) && (!(((p).idxType) == (2))); p = p.pNext)
			{
			}

			return p;
		}
		public static void sqlite3PrngRestoreState()
		{
			CRuntime.memcpy(&sqlite3Prng, &sqlite3SavedPrng, (ulong)(sizeof(sqlite3PrngType)));
		}
		public static void sqlite3PrngSaveState()
		{
			CRuntime.memcpy(&sqlite3SavedPrng, &sqlite3Prng, (ulong)(sizeof(sqlite3PrngType)));
		}
		public static void sqlite3Put4byte(byte* p, uint v)
		{
			uint x = (uint)(_byteswap_ulong((uint)(v)));
			CRuntime.memcpy(p, &x, (ulong)(4));
		}
		public static int sqlite3PutVarint(byte* p, ulong v)
		{
			if ((v) <= (0x7f))
			{
				p[0] = (byte)(v & 0x7f);
				return (int)(1);
			}

			if ((v) <= (0x3fff))
			{
				p[0] = (byte)(((v >> 7) & 0x7f) | 0x80);
				p[1] = (byte)(v & 0x7f);
				return (int)(2);
			}

			return (int)(putVarint64(p, (ulong)(v)));
		}
		public static void sqlite3QuoteValue(sqlite3_str pStr, sqlite3_value pValue)
		{

			switch (sqlite3_value_type(pValue))
			{
				case 2:
					{
						double r1 = 0;
						double r2 = 0;
						sbyte* zVal;
						r1 = (double)(sqlite3_value_double(pValue));
						sqlite3_str_appendf(pStr, "%!.15g", (double)(r1));
						zVal = sqlite3_str_value(pStr);
						if ((zVal) != null)
						{
							sqlite3AtoF(zVal, &r2, (int)(pStr.nChar), (byte)(1));
							if (r1 != r2)
							{
								sqlite3_str_reset(pStr);
								sqlite3_str_appendf(pStr, "%!.20e", (double)(r1));
							}
						}

						break;
					}

				case 1:
					{
						sqlite3_str_appendf(pStr, "%lld", (long)(sqlite3_value_int64(pValue)));
						break;
					}

				case 4:
					{
						sbyte* zBlob = sqlite3_value_blob(pValue);
						int nBlob = (int)(sqlite3_value_bytes(pValue));

						sqlite3StrAccumEnlarge(pStr, (int)(nBlob * 2 + 4));
						if ((pStr.accError) == (0))
						{
							sbyte* zText = pStr.zText;
							int i = 0;
							for (i = (int)(0); (i) < (nBlob); i++)
							{
								zText[(i * 2) + 2] = (sbyte)(hexdigits[(zBlob[i] >> 4) & 0x0F]);
								zText[(i * 2) + 3] = (sbyte)(hexdigits[(zBlob[i]) & 0x0F]);
							}

							zText[(nBlob * 2) + 2] = (sbyte)(39);
							zText[(nBlob * 2) + 3] = (sbyte)(0);
							zText[0] = (sbyte)(88);
							zText[1] = (sbyte)(39);
							pStr.nChar = (uint)(nBlob * 2 + 3);
						}

						break;
					}

				case 3:
					{
						byte* zArg = sqlite3_value_text(pValue);
						sqlite3_str_appendf(pStr, "%Q", zArg);
						break;
					}

				default:
					{

						sqlite3_str_append(pStr, "NULL", (int)(4));
						break;
					}
			}
		}
		public static int sqlite3ReadOnlyShadowTables(sqlite3 db)
		{
			if (((((db.flags & 0x10000000) != 0) && ((db.pVtabCtx) == (null))) && ((db.nVdbeExec) == (0))) && (!((((db).nVTrans) > (0)) && (((db).aVTrans) == (null)))))
			{
				return (int)(1);
			}

			return (int)(0);
		}
		public static int sqlite3ReadSchema(Parse pParse)
		{
			int rc = (int)(0);
			sqlite3 db = pParse.db;

			if (db.init.busy == 0)
			{
				rc = (int)(sqlite3Init(db, &pParse.zErrMsg));
				if (rc != 0)
				{
					pParse.rc = (int)(rc);
					pParse.nErr++;
				}
				else if ((db.noSharedCache) != 0)
				{
					db.mDbFlags |= (uint)(0x0010);
				}
			}

			return (int)(rc);
		}
		public static void* sqlite3Realloc(void* pOld, ulong nBytes)
		{
			int nOld = 0; int nNew = 0; int nDiff = 0;
			void* pNew;


			if ((pOld) == (null))
			{
				return sqlite3Malloc((ulong)(nBytes));
			}

			if ((nBytes) == (0))
			{
				sqlite3_free(pOld);
				return null;
			}

			if ((nBytes) >= (0x7fffff00))
			{
				return null;
			}

			nOld = (int)(sqlite3MallocSize(pOld));
			nNew = (int)(sqlite3Config.m.xRoundup((int)(nBytes)));
			if ((nOld) == (nNew))
			{
				pNew = pOld;
			}
			else if ((sqlite3Config.bMemstat) != 0)
			{
				long nUsed = 0;
				sqlite3_mutex_enter(mem0.mutex);
				sqlite3StatusHighwater((int)(5), (int)(nBytes));
				nDiff = (int)(nNew - nOld);
				if (((nDiff) > (0)) && ((nUsed = (long)(sqlite3StatusValue((int)(0)))) >= (mem0.alarmThreshold - nDiff)))
				{
					sqlite3MallocAlarm((int)(nDiff));
					if (((mem0.hardLimit) > (0)) && ((nUsed) >= (mem0.hardLimit - nDiff)))
					{
						sqlite3_mutex_leave(mem0.mutex);
						return null;
					}
				}

				pNew = sqlite3Config.m.xRealloc(pOld, (int)(nNew));
				if ((pNew) != null)
				{
					nNew = (int)(sqlite3MallocSize(pNew));
					sqlite3StatusUp((int)(0), (int)(nNew - nOld));
				}

				sqlite3_mutex_leave(mem0.mutex);
			}
			else
			{
				pNew = sqlite3Config.m.xRealloc(pOld, (int)(nNew));
			}


			return pNew;
		}
		public static int sqlite3RealSameAsInt(double r1, long i)
		{
			double r2 = (double)(i);
			return (((r1) == (0.0)) || ((((memcmp(&r1, &r2, (ulong)(sizeof(double)))) == (0)) && ((i) >= (-2251799813685248L  L ) ) ) && ((i) < (2251799813685248L  L ) ) ) ? 1 :  0 ) ;
		}
		public static void sqlite3RecordErrorByteOffset(sqlite3 db, sbyte* z)
		{
			Parse pParse;
			sbyte* zText;
			sbyte* zEnd;

			if (((db) == (null)))
				return;
			if (db.errByteOffset != (-2))
				return;
			pParse = db.pParse;
			if (((pParse) == (null)))
				return;
			zText = pParse.zTail;
			if (((zText) == (null)))
				return;
			zEnd = &zText[CRuntime.strlen(zText)];
			if (((((ulong)(z)) >= ((ulong)(zText))) && (((ulong)(z)) < ((ulong)(zEnd)))))
			{
				db.errByteOffset = ((int)(z - zText));
			}
		}
		public static void sqlite3RecordErrorOffsetOfExpr(sqlite3 db, Expr pExpr)
		{
			while (((pExpr) != null) && ((((pExpr).flags & (0x000001)) != 0) || ((pExpr.w.iOfst) <= (0))))
			{
				pExpr = pExpr.pLeft;
			}

			if ((pExpr) == (null))
				return;
			db.errByteOffset = (int)(pExpr.w.iOfst);
		}
		public static int sqlite3ReferencesSrcList(Parse pParse, Expr pExpr, SrcList pSrcList)
		{
			Walker w = new Walker();
			RefSrcList x = new RefSrcList();
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			CRuntime.memset(x, (int)(0), (ulong)(sizeof(RefSrcList)));
			w.xExprCallback = exprRefToSrcList;
			w.xSelectCallback = selectRefEnter;
			w.xSelectCallback2 = selectRefLeave;
			w.u.pRefSrcList = x;
			x.db = pParse.db;
			x.pRef = pSrcList;


			sqlite3WalkExprList(w, pExpr.x.pList);
			if ((((pExpr).flags & (0x1000000)) != 0))
			{
				sqlite3WalkExpr(w, pExpr.y.pWin.pFilter);
			}

			sqlite3DbFree(pParse.db, x.aiExclude);
			if ((w.eCode & 0x01) != 0)
			{
				return (int)(1);
			}
			else if ((w.eCode) != 0)
			{
				return (int)(0);
			}
			else
			{
				return (int)(-1);
			}
		}
		public static void sqlite3RefillIndex(Parse pParse, Index pIndex, int memRootPage)
		{
			Table pTab = pIndex.pTable;
			int iTab = (int)(pParse.nTab++);
			int iIdx = (int)(pParse.nTab++);
			int iSorter = 0;
			int addr1 = 0;
			int addr2 = 0;
			uint tnum = 0;
			int iPartIdxLabel = 0;
			Vdbe v;
			KeyInfo pKey;
			int regRecord = 0;
			sqlite3 db = pParse.db;
			int iDb = (int)(sqlite3SchemaToIndex(db, pIndex.pSchema));
			if ((sqlite3AuthCheck(pParse, (int)(27), pIndex.zName, null, db.aDb[iDb].zDbSName)) != 0)
			{
				return;
			}

			sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(1), pTab.zName);
			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
				return;
			if ((memRootPage) >= (0))
			{
				tnum = ((uint)(memRootPage));
			}
			else
			{
				tnum = (uint)(pIndex.tnum);
			}

			pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);

			iSorter = (int)(pParse.nTab++);
			sqlite3VdbeAddOp4(v, (int)(118), (int)(iSorter), (int)(0), (int)(pIndex.nKeyCol), (sbyte*)(sqlite3KeyInfoRef(pKey)), (int)(-9));
			sqlite3OpenTable(pParse, (int)(iTab), (int)(iDb), pTab, (int)(101));
			addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iTab), (int)(0)));
			regRecord = (int)(sqlite3GetTempReg(pParse));
			sqlite3MultiWrite(pParse);
			sqlite3GenerateIndexKey(pParse, pIndex, (int)(iTab), (int)(regRecord), (int)(0), &iPartIdxLabel, null, (int)(0));
			sqlite3VdbeAddOp2(v, (int)(138), (int)(iSorter), (int)(regRecord));
			sqlite3ResolvePartIdxLabel(pParse, (int)(iPartIdxLabel));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(iTab), (int)(addr1 + 1));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			if ((memRootPage) < (0))
				sqlite3VdbeAddOp2(v, (int)(144), (int)(tnum), (int)(iDb));
			sqlite3VdbeAddOp4(v, (int)(112), (int)(iIdx), (int)(tnum), (int)(iDb), (sbyte*)(pKey), (int)(-9));
			sqlite3VdbeChangeP5(v, (ushort)(0x01 | (((memRootPage) >= (0)) ? 0x10 : 0)));
			addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(36), (int)(iSorter), (int)(0)));
			if (((pIndex).onError != 0))
			{
				int j2 = (int)(sqlite3VdbeGoto(v, (int)(1)));
				addr2 = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3VdbeAddOp4Int(v, (int)(131), (int)(iSorter), (int)(j2), (int)(regRecord), (int)(pIndex.nKeyCol));
				sqlite3UniqueConstraint(pParse, (int)(2), pIndex);
				sqlite3VdbeJumpHere(v, (int)(j2));
			}
			else
			{
				sqlite3MayAbort(pParse);
				addr2 = (int)(sqlite3VdbeCurrentAddr(v));
			}

			sqlite3VdbeAddOp3(v, (int)(132), (int)(iSorter), (int)(regRecord), (int)(iIdx));
			if (pIndex.bAscKeyBug == 0)
			{
				sqlite3VdbeAddOp1(v, (int)(136), (int)(iIdx));
			}

			sqlite3VdbeAddOp2(v, (int)(137), (int)(iIdx), (int)(regRecord));
			sqlite3VdbeChangeP5(v, (ushort)(0x10));
			sqlite3ReleaseTempReg(pParse, (int)(regRecord));
			sqlite3VdbeAddOp2(v, (int)(3), (int)(iSorter), (int)(addr2));
			sqlite3VdbeJumpHere(v, (int)(addr1));
			sqlite3VdbeAddOp1(v, (int)(121), (int)(iTab));
			sqlite3VdbeAddOp1(v, (int)(121), (int)(iIdx));
			sqlite3VdbeAddOp1(v, (int)(121), (int)(iSorter));
		}
		public static void sqlite3RegisterBuiltinFunctions()
		{
			sqlite3AlterFunctions();
			sqlite3WindowFunctions();
			sqlite3RegisterDateTimeFunctions();
			sqlite3RegisterJsonFunctions();
			sqlite3InsertBuiltinFuncs(sqlite3RegisterBuiltinFunctions_aBuiltinFunc, ((int)(69 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3RegisterDateTimeFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3RegisterDateTimeFunctions_aDateTimeFuncs, ((int)(9 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3RegisterJsonFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3RegisterJsonFunctions_aJsonFunc, ((int)(19 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3RegisterLikeFunctions(sqlite3 db, int caseSensitive)
		{
			compareInfo* pInfo;
			int flags = 0;
			if ((caseSensitive) != 0)
			{
				pInfo = &likeInfoAlt;
				flags = (int)(0x0004 | 0x0008);
			}
			else
			{
				pInfo = &likeInfoNorm;
				flags = (int)(0x0004);
			}

			sqlite3CreateFunc(db, "like", (int)(2), (int)(1), pInfo, likeFunc, null, null, null, null, null);
			sqlite3CreateFunc(db, "like", (int)(3), (int)(1), pInfo, likeFunc, null, null, null, null, null);
			sqlite3FindFunction(db, "like", (int)(2), (byte)(1), (byte)(0)).funcFlags |= (uint)(flags);
			sqlite3FindFunction(db, "like", (int)(3), (byte)(1), (byte)(0)).funcFlags |= (uint)(flags);
		}
		public static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 db)
		{
			int rc = (int)(sqlite3_overload_function(db, "MATCH", (int)(2)));

			if ((rc) == (7))
			{
				sqlite3OomFault(db);
			}
		}
		public static void sqlite3Reindex(Parse pParse, Token* pName1, Token* pName2)
		{
			CollSeq pColl;
			sbyte* z;
			sbyte* zDb;
			Table pTab;
			Index pIndex;
			int iDb = 0;
			sqlite3 db = pParse.db;
			Token* pObjName;
			if (0 != sqlite3ReadSchema(pParse))
			{
				return;
			}

			if ((pName1) == (null))
			{
				reindexDatabases(pParse, null);
				return;
			}
			else if (((pName2) == (null)) || ((pName2->z) == (null)))
			{
				sbyte* zColl;

				zColl = sqlite3NameFromToken(pParse.db, pName1);
				if (zColl == null)
					return;
				pColl = sqlite3FindCollSeq(db, (byte)((db).enc), zColl, (int)(0));
				if ((pColl) != null)
				{
					reindexDatabases(pParse, zColl);
					sqlite3DbFree(db, zColl);
					return;
				}

				sqlite3DbFree(db, zColl);
			}

			iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pObjName));
			if ((iDb) < (0))
				return;
			z = sqlite3NameFromToken(db, pObjName);
			if ((z) == (null))
				return;
			zDb = db.aDb[iDb].zDbSName;
			pTab = sqlite3FindTable(db, z, zDb);
			if ((pTab) != null)
			{
				reindexTable(pParse, pTab, null);
				sqlite3DbFree(db, z);
				return;
			}

			pIndex = sqlite3FindIndex(db, z, zDb);
			sqlite3DbFree(db, z);
			if ((pIndex) != null)
			{
				sqlite3BeginWriteOperation(pParse, (int)(0), (int)(iDb));
				sqlite3RefillIndex(pParse, pIndex, (int)(-1));
				return;
			}

			sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
		}
		public static void sqlite3ReleaseTempRange(Parse pParse, int iReg, int nReg)
		{
			if ((nReg) == (1))
			{
				sqlite3ReleaseTempReg(pParse, (int)(iReg));
				return;
			}

			if ((nReg) > (pParse.nRangeReg))
			{
				pParse.nRangeReg = (int)(nReg);
				pParse.iRangeReg = (int)(iReg);
			}
		}
		public static void sqlite3ReleaseTempReg(Parse pParse, int iReg)
		{
			if ((iReg) != 0)
			{
				if ((pParse.nTempReg) < ((int)(8 * sizeof(int) / sizeof(int))))
				{
					pParse.aTempReg[pParse.nTempReg++] = (int)(iReg);
				}
			}
		}
		public static void sqlite3RenameExprlistUnmap(Parse pParse, ExprList pEList)
		{
			if ((pEList) != null)
			{
				int i = 0;
				Walker sWalker = new Walker();
				CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
				sWalker.pParse = pParse;
				sWalker.xExprCallback = renameUnmapExprCb;
				sqlite3WalkExprList(sWalker, pEList);
				for (i = (int)(0); (i) < (pEList.nExpr); i++)
				{
					if (((pEList.a[i].eEName) == (0)))
					{
						sqlite3RenameTokenRemap(pParse, null, (void*)(pEList.a[i].zEName));
					}
				}
			}
		}
		public static void sqlite3RenameExprUnmap(Parse pParse, Expr pExpr)
		{
			byte eMode = (byte)(pParse.eParseMode);
			Walker sWalker = new Walker();
			CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
			sWalker.pParse = pParse;
			sWalker.xExprCallback = renameUnmapExprCb;
			sWalker.xSelectCallback = renameUnmapSelectCb;
			pParse.eParseMode = (byte)(3);
			sqlite3WalkExpr(sWalker, pExpr);
			pParse.eParseMode = (byte)(eMode);
		}
		public static void* sqlite3RenameTokenMap(Parse pParse, void* pPtr, Token* pToken)
		{
			RenameToken* pNew;

			if ((pParse.eParseMode != 3))
			{
				pNew = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(RenameToken)));
				if ((pNew) != null)
				{
					pNew->p = pPtr;
					pNew->t = (Token)(*pToken);
					pNew->pNext = pParse.pRename;
					pParse.pRename = pNew;
				}
			}

			return pPtr;
		}
		public static void sqlite3RenameTokenRemap(Parse pParse, void* pTo, void* pFrom)
		{
			RenameToken* p;
			for (p = pParse.pRename; p; p = p->pNext)
			{
				if ((p->p) == (pFrom))
				{
					p->p = pTo;
					break;
				}
			}
		}
		public static int sqlite3ReportError(int iErr, int lineno, sbyte* zType)
		{
			sqlite3_log((int)(iErr), "%s at line %d of [%.10s]", zType, (int)(lineno), 20 + sqlite3_sourceid());
			return (int)(iErr);
		}
		public static int sqlite3Reprepare(Vdbe p)
		{
			int rc = 0;
			sqlite3_stmt* pNew;
			sbyte* zSql;
			sqlite3 db;
			byte prepFlags = 0;

			zSql = sqlite3_sql((sqlite3_stmt*)(p));

			db = sqlite3VdbeDb(p);

			prepFlags = (byte)(sqlite3VdbePrepareFlags(p));
			rc = (int)(sqlite3LockAndPrepare(db, zSql, (int)(-1), (uint)(prepFlags), p, &pNew, null));
			if ((rc) != 0)
			{
				if ((rc) == (7))
				{
					sqlite3OomFault(db);
				}


				return (int)(rc);
			}
			else
			{

			}

			sqlite3VdbeSwap((Vdbe)(pNew), p);
			sqlite3TransferBindings(pNew, (sqlite3_stmt*)(p));
			sqlite3VdbeResetStepResult((Vdbe)(pNew));
			sqlite3VdbeFinalize((Vdbe)(pNew));
			return (int)(0);
		}
		public static void sqlite3ResetAllSchemasOfConnection(sqlite3 db)
		{
			int i = 0;
			sqlite3BtreeEnterAll(db);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Db pDb = db.aDb[i];
				if ((pDb.pSchema) != null)
				{
					if ((db.nSchemaLock) == (0))
					{
						sqlite3SchemaClear(pDb.pSchema);
					}
					else
					{
						(db).aDb[i].pSchema.schemaFlags |= (ushort)(0x0008);
					}
				}
			}

			db.mDbFlags &= (uint)(~(0x0001 | 0x0010));
			sqlite3VtabUnlockList(db);
			sqlite3BtreeLeaveAll(db);
			if ((db.nSchemaLock) == (0))
			{
				sqlite3CollapseDatabaseArray(db);
			}
		}
		public static void sqlite3ResetOneSchema(sqlite3 db, int iDb)
		{
			int i = 0;

			if ((iDb) >= (0))
			{

				(db).aDb[iDb].pSchema.schemaFlags |= (ushort)(0x0008);
				(db).aDb[1].pSchema.schemaFlags |= (ushort)(0x0008);
				db.mDbFlags &= (uint)(~0x0010);
			}

			if ((db.nSchemaLock) == (0))
			{
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					if ((((db).aDb[i].pSchema.schemaFlags & (0x0008)) == (0x0008)))
					{
						sqlite3SchemaClear(db.aDb[i].pSchema);
					}
				}
			}
		}
		public static int sqlite3ResolveExprListNames(NameContext pNC, ExprList pList)
		{
			int i = 0;
			int savedHasAgg = (int)(0);
			Walker w = new Walker();
			if ((pList) == (null))
				return (int)(0);
			w.pParse = pNC.pParse;
			w.xExprCallback = resolveExprStep;
			w.xSelectCallback = resolveSelectStep;
			w.xSelectCallback2 = null;
			w.u.pNC = pNC;
			savedHasAgg = (int)(pNC.ncFlags & (0x000010 | 0x001000 | 0x008000 | 0x8000000));
			pNC.ncFlags &= (int)(~(0x000010 | 0x001000 | 0x008000 | 0x8000000));
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				Expr pExpr = pList.a[i].pExpr;
				if ((pExpr) == (null))
					continue;
				w.pParse.nHeight += (int)(pExpr.nHeight);
				if ((sqlite3ExprCheckHeight(w.pParse, (int)(w.pParse.nHeight))) != 0)
				{
					return (int)(2);
				}

				sqlite3WalkExpr(w, pExpr);
				w.pParse.nHeight -= (int)(pExpr.nHeight);


				if ((pNC.ncFlags & (0x000010 | 0x001000 | 0x008000 | 0x8000000)) != 0)
				{
					(pExpr).flags |= (uint)(pNC.ncFlags & (0x000010 | 0x008000));
					savedHasAgg |= (int)(pNC.ncFlags & (0x000010 | 0x001000 | 0x008000 | 0x8000000));
					pNC.ncFlags &= (int)(~(0x000010 | 0x001000 | 0x008000 | 0x8000000));
				}

				if ((w.pParse.nErr) > (0))
					return (int)(2);
			}

			pNC.ncFlags |= (int)(savedHasAgg);
			return (int)(0);
		}
		public static int sqlite3ResolveExprNames(NameContext pNC, Expr pExpr)
		{
			int savedHasAgg = 0;
			Walker w = new Walker();
			if ((pExpr) == (null))
				return (int)(0);
			savedHasAgg = (int)(pNC.ncFlags & (0x000010 | 0x001000 | 0x008000 | 0x8000000));
			pNC.ncFlags &= (int)(~(0x000010 | 0x001000 | 0x008000 | 0x8000000));
			w.pParse = pNC.pParse;
			w.xExprCallback = resolveExprStep;
			w.xSelectCallback = (pNC.ncFlags & 0x080000) ? null : resolveSelectStep;
			w.xSelectCallback2 = null;
			w.u.pNC = pNC;
			w.pParse.nHeight += (int)(pExpr.nHeight);
			if ((sqlite3ExprCheckHeight(w.pParse, (int)(w.pParse.nHeight))) != 0)
			{
				return (int)(1);
			}

			sqlite3WalkExpr(w, pExpr);
			w.pParse.nHeight -= (int)(pExpr.nHeight);


			(pExpr).flags |= (uint)(pNC.ncFlags & (0x000010 | 0x008000));
			pNC.ncFlags |= (int)(savedHasAgg);
			return (((pNC.nNcErr) > (0)) || ((w.pParse.nErr) > (0)) ? 1 : 0);
		}
		public static int sqlite3ResolveOrderGroupBy(Parse pParse, Select pSelect, ExprList pOrderBy, sbyte* zType)
		{
			int i = 0;
			sqlite3 db = pParse.db;
			ExprList pEList;
			ExprList_item* pItem;
			if ((((pOrderBy) == (null)) || ((pParse.db.mallocFailed) != 0)) || ((pParse.eParseMode) >= (2)))
				return (int)(0);
			if ((pOrderBy.nExpr) > (db.aLimit[2]))
			{
				sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
				return (int)(1);
			}

			pEList = pSelect.pEList;

			for (i = (int)(0), pItem = pOrderBy.a; (i) < (pOrderBy.nExpr); i++, pItem++)
			{
				if ((pItem->u.x.iOrderByCol) != 0)
				{
					if ((pItem->u.x.iOrderByCol) > (pEList.nExpr))
					{
						resolveOutOfRangeError(pParse, zType, (int)(i + 1), (int)(pEList.nExpr), null);
						return (int)(1);
					}

					resolveAlias(pParse, pEList, (int)(pItem->u.x.iOrderByCol - 1), pItem->pExpr, (int)(0));
				}
			}

			return (int)(0);
		}
		public static void sqlite3ResolvePartIdxLabel(Parse pParse, int iLabel)
		{
			if ((iLabel) != 0)
			{
				sqlite3VdbeResolveLabel(pParse.pVdbe, (int)(iLabel));
			}
		}
		public static void sqlite3ResolveSelectNames(Parse pParse, Select p, NameContext pOuterNC)
		{
			Walker w = new Walker();

			w.xExprCallback = resolveExprStep;
			w.xSelectCallback = resolveSelectStep;
			w.xSelectCallback2 = null;
			w.pParse = pParse;
			w.u.pNC = pOuterNC;
			sqlite3WalkSelect(w, p);
		}
		public static int sqlite3ResolveSelfReference(Parse pParse, Table pTab, int type, Expr pExpr, ExprList pList)
		{
			SrcList sSrc = new SrcList();
			NameContext sNC = new NameContext();
			int rc = 0;


			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			CRuntime.memset(sSrc, (int)(0), (ulong)(sizeof(SrcList)));
			if ((pTab) != null)
			{
				sSrc.nSrc = (int)(1);
				sSrc.a[0].zName = pTab.zName;
				sSrc.a[0].pTab = pTab;
				sSrc.a[0].iCursor = (int)(-1);
				if (pTab.pSchema != pParse.db.aDb[1].pSchema)
				{
					type |= (int)(0x040000);
				}
			}

			sNC.pParse = pParse;
			sNC.pSrcList = sSrc;
			sNC.ncFlags = (int)(type | 0x010000);
			if ((rc = (int)(sqlite3ResolveExprNames(sNC, pExpr))) != 0)
				return (int)(rc);
			if ((pList) != null)
				rc = (int)(sqlite3ResolveExprListNames(sNC, pList));
			return (int)(rc);
		}
		public static void sqlite3ResultIntReal(sqlite3_context pCtx)
		{

			if ((pCtx.pOut.flags & 0x0004) != 0)
			{
				pCtx.pOut.flags &= (ushort)(~0x0004);
				pCtx.pOut.flags |= (ushort)(0x0020);
			}
		}
		public static Table sqlite3ResultSetOfSelect(Parse pParse, Select pSelect, sbyte aff)
		{
			Table pTab;
			sqlite3 db = pParse.db;
			ulong savedFlags = 0;
			savedFlags = (ulong)(db.flags);
			db.flags &= (ulong)(~(ulong)(0x00000004));
			db.flags |= (ulong)(0x00000040);
			sqlite3SelectPrep(pParse, pSelect, null);
			db.flags = (ulong)(savedFlags);
			if ((pParse.nErr) != 0)
				return null;
			while ((pSelect.pPrior) != null)
			{
				pSelect = pSelect.pPrior;
			}

			pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
			if ((pTab) == (null))
			{
				return null;
			}

			pTab.nTabRef = (uint)(1);
			pTab.zName = null;
			pTab.nRowLogEst = (short)(200);

			sqlite3ColumnsFromExprList(pParse, pSelect.pEList, &pTab.nCol, &pTab.aCol);
			sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, (sbyte)(aff));
			pTab.iPKey = (short)(-1);
			if ((db.mallocFailed) != 0)
			{
				sqlite3DeleteTable(db, pTab);
				return null;
			}

			return pTab;
		}
		public static void sqlite3ResultStrAccum(sqlite3_context pCtx, sqlite3_str p)
		{
			if ((p.accError) != 0)
			{
				sqlite3_result_error_code(pCtx, (int)(p.accError));
				sqlite3_str_reset(p);
			}
			else if ((((p).printfFlags & 0x04) != 0))
			{
				sqlite3_result_text(pCtx, p.zText, (int)(p.nChar), ((Void(Void * ))(sqlite3OomFault)));
			}
			else
			{
				sqlite3_result_text(pCtx, "", (int)(0), null);
				sqlite3_str_reset(p);
			}
		}
		public static void sqlite3RollbackAll(sqlite3 db, int tripCode)
		{
			int i = 0;
			int inTrans = (int)(0);
			int schemaChange = 0;

			sqlite3BeginBenignMalloc();
			sqlite3BtreeEnterAll(db);
			schemaChange = (int)(((db.mDbFlags & 0x0001) != 0) && ((db.init.busy) == (0)) ? 1 : 0);
			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				Btree p = db.aDb[i].pBt;
				if ((p) != null)
				{
					if ((sqlite3BtreeTxnState(p)) == (2))
					{
						inTrans = (int)(1);
					}

					sqlite3BtreeRollback(p, (int)(tripCode), (int)(!schemaChange));
				}
			}

			sqlite3VtabRollback(db);
			sqlite3EndBenignMalloc();
			if ((schemaChange) != 0)
			{
				sqlite3ExpirePreparedStatements(db, (int)(0));
				sqlite3ResetAllSchemasOfConnection(db);
			}

			sqlite3BtreeLeaveAll(db);
			db.nDeferredCons = (long)(0);
			db.nDeferredImmCons = (long)(0);
			db.flags &= (ulong)(~(0x00080000 | ((ulong)(0x00002) << 32)));
			if (((db.xRollbackCallback) != null) && (((inTrans) != 0) || (db.autoCommit == 0)))
			{
				db.xRollbackCallback(db.pRollbackArg);
			}
		}
		public static void sqlite3RootPageMoved(sqlite3 db, int iDb, uint iFrom, uint iTo)
		{
			HashElem* pElem;
			Hash* pHash;
			Db pDb;

			pDb = db.aDb[iDb];
			pHash = &pDb.pSchema.tblHash;
			for (pElem = ((pHash)->first); pElem; pElem = ((pElem)->next))
			{
				Table pTab = ((pElem)->data);
				if ((pTab.tnum) == (iFrom))
				{
					pTab.tnum = (uint)(iTo);
				}
			}

			pHash = &pDb.pSchema.idxHash;
			for (pElem = ((pHash)->first); pElem; pElem = ((pElem)->next))
			{
				Index pIdx = ((pElem)->data);
				if ((pIdx.tnum) == (iFrom))
				{
					pIdx.tnum = (uint)(iTo);
				}
			}
		}
		public static void sqlite3RowidConstraint(Parse pParse, int onError, Table pTab)
		{
			sbyte* zMsg;
			int rc = 0;
			if ((pTab.iPKey) >= (0))
			{
				zMsg = sqlite3MPrintf(pParse.db, "%s.%s", pTab.zName, pTab.aCol[pTab.iPKey].zCnName);
				rc = (int)(19 | (6 << 8));
			}
			else
			{
				zMsg = sqlite3MPrintf(pParse.db, "%s.rowid", pTab.zName);
				rc = (int)(19 | (10 << 8));
			}

			sqlite3HaltConstraint(pParse, (int)(rc), (int)(onError), zMsg, (sbyte)(-7), (byte)(2));
		}
		public static void sqlite3RowSetClear(void* pArg)
		{
			RowSet p = (RowSet)(pArg);
			RowSetChunk pChunk; RowSetChunk pNextChunk;
			for (pChunk = p.pChunk; pChunk; pChunk = pNextChunk)
			{
				pNextChunk = pChunk.pNextChunk;
				sqlite3DbFree(p.db, pChunk);
			}

			p.pChunk = null;
			p.nFresh = (ushort)(0);
			p.pEntry = null;
			p.pLast = null;
			p.pForest = null;
			p.rsFlags = (ushort)(0x01);
		}
		public static void sqlite3RowSetDelete(void* pArg)
		{
			sqlite3RowSetClear(pArg);
			sqlite3DbFree(((RowSet)(pArg)).db, pArg);
		}
		public static RowSet sqlite3RowSetInit(sqlite3 db)
		{
			RowSet p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(RowSet)));
			if ((p) != null)
			{
				int N = (int)(sqlite3DbMallocSize(db, p));
				p.pChunk = null;
				p.db = db;
				p.pEntry = null;
				p.pLast = null;
				p.pForest = null;
				p.pFresh = (RowSetEntry*)((((sizeof(RowSet)) + 7) & ~7) + (sbyte*)(p));
				p.nFresh = ((ushort)((N - (((sizeof(RowSet)) + 7) & ~7)) / sizeof(RowSetEntry)));
				p.rsFlags = (ushort)(0x01);
				p.iBatch = (int)(0);
			}

			return p;
		}
		public static void sqlite3RowSetInsert(RowSet p, long rowid)
		{
			RowSetEntry* pEntry;
			RowSetEntry* pLast;

			pEntry = rowSetEntryAlloc(p);
			if ((pEntry) == (null))
				return;
			pEntry->v = (long)(rowid);
			pEntry->pRight = null;
			pLast = p.pLast;
			if ((pLast) != null)
			{
				if ((rowid) <= (pLast->v))
				{
					p.rsFlags &= (ushort)(~0x01);
				}

				pLast->pRight = pEntry;
			}
			else
			{
				p.pEntry = pEntry;
			}

			p.pLast = pEntry;
		}
		public static int sqlite3RowSetNext(RowSet p, long* pRowid)
		{


			if ((p.rsFlags & 0x02) == (0))
			{
				if ((p.rsFlags & 0x01) == (0))
				{
					p.pEntry = rowSetEntrySort(p.pEntry);
				}

				p.rsFlags |= (ushort)(0x01 | 0x02);
			}

			if ((p.pEntry) != null)
			{
				*pRowid = (long)(p.pEntry->v);
				p.pEntry = p.pEntry->pRight;
				if ((p.pEntry) == (null))
				{
					sqlite3RowSetClear(p);
				}

				return (int)(1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static int sqlite3RowSetTest(RowSet pRowSet, int iBatch, long iRowid)
		{
			RowSetEntry* p; RowSetEntry* pTree;

			if (iBatch != pRowSet.iBatch)
			{
				p = pRowSet.pEntry;
				if ((p) != null)
				{
					RowSetEntry** ppPrevTree = &pRowSet.pForest;
					if ((pRowSet.rsFlags & 0x01) == (0))
					{
						p = rowSetEntrySort(p);
					}

					for (pTree = pRowSet.pForest; pTree; pTree = pTree->pRight)
					{
						ppPrevTree = &pTree->pRight;
						if ((pTree->pLeft) == (null))
						{
							pTree->pLeft = rowSetListToTree(p);
							break;
						}
						else
						{
							RowSetEntry* pAux;
							RowSetEntry* pTail;
							rowSetTreeToList(pTree->pLeft, &pAux, &pTail);
							pTree->pLeft = null;
							p = rowSetEntryMerge(pAux, p);
						}
					}

					if ((pTree) == (null))
					{
						*ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);
						if ((pTree) != null)
						{
							pTree->v = (long)(0);
							pTree->pRight = null;
							pTree->pLeft = rowSetListToTree(p);
						}
					}

					pRowSet.pEntry = null;
					pRowSet.pLast = null;
					pRowSet.rsFlags |= (ushort)(0x01);
				}

				pRowSet.iBatch = (int)(iBatch);
			}

			for (pTree = pRowSet.pForest; pTree; pTree = pTree->pRight)
			{
				p = pTree->pLeft;
				while ((p) != null)
				{
					if ((p->v) < (iRowid))
					{
						p = p->pRight;
					}
					else if ((p->v) > (iRowid))
					{
						p = p->pLeft;
					}
					else
					{
						return (int)(1);
					}
				}
			}

			return (int)(0);
		}
		public static int sqlite3RunParser(Parse pParse, sbyte* zSql)
		{
			int nErr = (int)(0);
			void* pEngine;
			int n = (int)(0);
			int tokenType = 0;
			int lastTokenParsed = (int)(-1);
			sqlite3 db = pParse.db;
			int mxSqlLen = 0;
			Parse pParentParse = null;
			yyParser sEngine = new yyParser();

			mxSqlLen = (int)(db.aLimit[1]);
			if ((db.nVdbeActive) == (0))
			{
				(0);
			}

			pParse.rc = (int)(0);
			pParse.zTail = zSql;
			pEngine = sEngine;
			sqlite3ParserInit(pEngine, pParse);




			pParentParse = db.pParse;
			db.pParse = pParse;
			while ((1) != 0)
			{
				n = (int)(sqlite3GetToken((byte*)(zSql), &tokenType));
				mxSqlLen -= (int)(n);
				if ((mxSqlLen) < (0))
				{
					pParse.rc = (int)(18);
					break;
				}

				if ((tokenType) >= (164))
				{

					if ((0) != 0)
					{
						pParse.rc = (int)(9);
						pParse.nErr++;
						break;
					}

					if ((tokenType) == (183))
					{
						zSql += n;
						continue;
					}

					if ((zSql[0]) == (0))
					{
						if ((lastTokenParsed) == (1))
						{
							tokenType = (int)(0);
						}
						else if ((lastTokenParsed) == (0))
						{
							break;
						}
						else
						{
							tokenType = (int)(1);
						}

						n = (int)(0);
					}
					else if ((tokenType) == (164))
					{

						tokenType = (int)(analyzeWindowKeyword((byte*)(&zSql[6])));
					}
					else if ((tokenType) == (165))
					{

						tokenType = (int)(analyzeOverKeyword((byte*)(&zSql[4]), (int)(lastTokenParsed)));
					}
					else if ((tokenType) == (166))
					{

						tokenType = (int)(analyzeFilterKeyword((byte*)(&zSql[6]), (int)(lastTokenParsed)));
					}
					else
					{
						Token x = new Token();
						x.z = zSql;
						x.n = (uint)(n);
						sqlite3ErrorMsg(pParse, "unrecognized token: \"%T\"", &x);
						break;
					}
				}

				pParse.sLastToken.z = zSql;
				pParse.sLastToken.n = (uint)(n);
				sqlite3Parser(pEngine, (int)(tokenType), (Token)(pParse.sLastToken));
				lastTokenParsed = (int)(tokenType);
				zSql += n;

				if (pParse.rc != 0)
					break;
			}


			sqlite3ParserFinalize(pEngine);
			if ((db.mallocFailed) != 0)
			{
				pParse.rc = (int)(7);
			}

			if (((pParse.zErrMsg) != null) || ((pParse.rc != 0) && (pParse.rc != 101)))
			{
				if ((pParse.zErrMsg) == (null))
				{
					pParse.zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr((int)(pParse.rc)));
				}

				sqlite3_log((int)(pParse.rc), "%s in \"%s\"", pParse.zErrMsg, pParse.zTail);
				nErr++;
			}

			pParse.zTail = zSql;
			sqlite3_free(pParse.apVtabLock);
			if (((pParse.pNewTable) != null) && (!(pParse.eParseMode != 0)))
			{
				sqlite3DeleteTable(db, pParse.pNewTable);
			}

			if (((pParse.pNewTrigger) != null) && (!((pParse.eParseMode) >= (2))))
			{
				sqlite3DeleteTrigger(db, pParse.pNewTrigger);
			}

			sqlite3DbFree(db, pParse.pVList);
			db.pParse = pParentParse;

			return (int)(nErr);
		}
		public static int sqlite3RunVacuum(sbyte** pzErrMsg, sqlite3 db, int iDb, sqlite3_value pOut)
		{
			int rc = (int)(0);
			Btree pMain;
			Btree pTemp;
			uint saved_mDbFlags = 0;
			ulong saved_flags = 0;
			long saved_nChange = 0;
			long saved_nTotalChange = 0;
			uint saved_openFlags = 0;
			byte saved_mTrace = 0;
			Db pDb = null;
			int isMemDb = 0;
			int nRes = 0;
			int nDb = 0;
			sbyte* zDbMain;
			sbyte* zOut;
			if (db.autoCommit == 0)
			{
				sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
				return (int)(1);
			}

			if ((db.nVdbeActive) > (1))
			{
				sqlite3SetString(pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
				return (int)(1);
			}

			saved_openFlags = (uint)(db.openFlags);
			if ((pOut) != null)
			{
				if (sqlite3_value_type(pOut) != 3)
				{
					sqlite3SetString(pzErrMsg, db, "non-text filename");
					return (int)(1);
				}

				zOut = (sbyte*)(sqlite3_value_text(pOut));
				db.openFlags &= (uint)(~0x00000001);
				db.openFlags |= (uint)(0x00000004 | 0x00000002);
			}
			else
			{
				zOut = "";
			}

			saved_flags = (ulong)(db.flags);
			saved_mDbFlags = (uint)(db.mDbFlags);
			saved_nChange = (long)(db.nChange);
			saved_nTotalChange = (long)(db.nTotalChange);
			saved_mTrace = (byte)(db.mTrace);
			db.flags |= (ulong)(0x00000001 | 0x00000200);
			db.mDbFlags |= (uint)(0x0002 | 0x0004);
			db.flags &= (ulong)(~(0x00004000 | 0x00001000 | 0x10000000 | ((ulong)(0x00001) << 32)));
			db.mTrace = (byte)(0);
			zDbMain = db.aDb[iDb].zDbSName;
			pMain = db.aDb[iDb].pBt;
			isMemDb = (int)(sqlite3PagerIsMemdb(sqlite3BtreePager(pMain)));
			nDb = (int)(db.nDb);
			rc = (int)(execSqlF(db, pzErrMsg, "ATTACH %Q AS vacuum_db", zOut));
			db.openFlags = (uint)(saved_openFlags);
			if (rc != 0)
				goto end_of_vacuum;

			pDb = db.aDb[nDb];

			pTemp = pDb.pBt;
			if ((pOut) != null)
			{
				sqlite3_file id = sqlite3PagerFile(sqlite3BtreePager(pTemp));
				long sz = (long)(0);
				if ((id.pMethods != null) && ((sqlite3OsFileSize(id, &sz) != 0) || ((sz) > (0))))
				{
					rc = (int)(1);
					sqlite3SetString(pzErrMsg, db, "output file already exists");
					goto end_of_vacuum;
				}

				db.mDbFlags |= (uint)(0x0008);
			}

			nRes = (int)(sqlite3BtreeGetRequestedReserve(pMain));
			sqlite3BtreeSetCacheSize(pTemp, (int)(db.aDb[iDb].pSchema.cache_size));
			sqlite3BtreeSetSpillSize(pTemp, (int)(sqlite3BtreeSetSpillSize(pMain, (int)(0))));
			sqlite3BtreeSetPagerFlags(pTemp, (uint)(0x01 | 0x20));
			rc = (int)(execSql(db, pzErrMsg, "BEGIN"));
			if (rc != 0)
				goto end_of_vacuum;
			rc = (int)(sqlite3BtreeBeginTrans(pMain, (int)((pOut) == (null) ? 2 : 0), null));
			if (rc != 0)
				goto end_of_vacuum;
			if (((sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))) == (5)) && ((pOut) == (null)))
			{
				db.nextPagesize = (int)(0);
			}

			if ((((sqlite3BtreeSetPageSize(pTemp, (int)(sqlite3BtreeGetPageSize(pMain)), (int)(nRes), (int)(0))) != 0) || ((isMemDb == 0) && ((sqlite3BtreeSetPageSize(pTemp, (int)(db.nextPagesize), (int)(nRes), (int)(0))) != 0))) || ((db.mallocFailed) != 0))
			{
				rc = (int)(7);
				goto end_of_vacuum;
			}

			sqlite3BtreeSetAutoVacuum(pTemp, (int)((db.nextAutovac) >= (0) ? db.nextAutovac : sqlite3BtreeGetAutoVacuum(pMain)));
			db.init.iDb = (byte)(nDb);
			rc = (int)(execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_schema WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0", zDbMain));
			if (rc != 0)
				goto end_of_vacuum;
			rc = (int)(execSqlF(db, pzErrMsg, "SELECT sql FROM \"%w\".sqlite_schema WHERE type='index'", zDbMain));
			if (rc != 0)
				goto end_of_vacuum;
			db.init.iDb = (byte)(0);
			rc = (int)(execSqlF(db, pzErrMsg, "SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM\"%w\".'||quote(name)FROM vacuum_db.sqlite_schema WHERE type='table'AND coalesce(rootpage,1)>0", zDbMain));

			db.mDbFlags &= (uint)(~0x0004);
			if (rc != 0)
				goto end_of_vacuum;
			rc = (int)(execSqlF(db, pzErrMsg, "INSERT INTO vacuum_db.sqlite_schema SELECT*FROM \"%w\".sqlite_schema WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)", zDbMain));
			if ((rc) != 0)
				goto end_of_vacuum;
			{
				uint meta = 0;
				int i = 0;


				for (i = (int)(0); (i) < ((int)(10 * sizeof(byte) / sizeof(byte))); i += (int)(2))
				{
					sqlite3BtreeGetMeta(pMain, (int)(sqlite3RunVacuum_aCopy[i]), &meta);
					rc = (int)(sqlite3BtreeUpdateMeta(pTemp, (int)(sqlite3RunVacuum_aCopy[i]), (uint)(meta + sqlite3RunVacuum_aCopy[i + 1])));
					if ((rc != 0))
						goto end_of_vacuum;
				}

				if ((pOut) == (null))
				{
					rc = (int)(sqlite3BtreeCopyFile(pMain, pTemp));
				}

				if (rc != 0)
					goto end_of_vacuum;
				rc = (int)(sqlite3BtreeCommit(pTemp));
				if (rc != 0)
					goto end_of_vacuum;
				if ((pOut) == (null))
				{
					sqlite3BtreeSetAutoVacuum(pMain, (int)(sqlite3BtreeGetAutoVacuum(pTemp)));
				}
			}


			if ((pOut) == (null))
			{
				rc = (int)(sqlite3BtreeSetPageSize(pMain, (int)(sqlite3BtreeGetPageSize(pTemp)), (int)(nRes), (int)(1)));
			}

		end_of_vacuum:
			; db.init.iDb = (byte)(0);
			db.mDbFlags = (uint)(saved_mDbFlags);
			db.flags = (ulong)(saved_flags);
			db.nChange = (long)(saved_nChange);
			db.nTotalChange = (long)(saved_nTotalChange);
			db.mTrace = (byte)(saved_mTrace);
			sqlite3BtreeSetPageSize(pMain, (int)(-1), (int)(0), (int)(1));
			db.autoCommit = (byte)(1);
			if ((pDb) != null)
			{
				sqlite3BtreeClose(pDb.pBt);
				pDb.pBt = null;
				pDb.pSchema = null;
			}

			sqlite3ResetAllSchemasOfConnection(db);
			return (int)(rc);
		}
		public static int sqlite3SafetyCheckOk(sqlite3 db)
		{
			byte eOpenState = 0;
			if ((db) == (null))
			{
				logBadConnection("NULL");
				return (int)(0);
			}

			eOpenState = (byte)(db.eOpenState);
			if (eOpenState != 0x76)
			{
				if ((sqlite3SafetyCheckSickOrOk(db)) != 0)
				{
					logBadConnection("unopened");
				}

				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static int sqlite3SafetyCheckSickOrOk(sqlite3 db)
		{
			byte eOpenState = 0;
			eOpenState = (byte)(db.eOpenState);
			if (((eOpenState != 0xba) && (eOpenState != 0x76)) && (eOpenState != 0x6d))
			{
				logBadConnection("invalid");
				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static void sqlite3Savepoint(Parse pParse, int op, Token* pName)
		{
			sbyte* zName = sqlite3NameFromToken(pParse.db, pName);
			if ((zName) != null)
			{
				Vdbe v = sqlite3GetVdbe(pParse);

				if ((v == null) || ((sqlite3AuthCheck(pParse, (int)(32), sqlite3Savepoint_az[op], zName, null)) != 0))
				{
					sqlite3DbFree(pParse.db, zName);
					return;
				}

				sqlite3VdbeAddOp4(v, (int)(0), (int)(op), (int)(0), (int)(0), zName, (int)(-7));
			}
		}
		public static void sqlite3SchemaClear(void* p)
		{
			Hash temp1 = new Hash();
			Hash temp2 = new Hash();
			HashElem* pElem;
			Schema pSchema = (Schema)(p);
			temp1 = (Hash)(pSchema.tblHash);
			temp2 = (Hash)(pSchema.trigHash);
			sqlite3HashInit(&pSchema.trigHash);
			sqlite3HashClear(&pSchema.idxHash);
			for (pElem = ((&temp2)->first); pElem; pElem = ((pElem)->next))
			{
				sqlite3DeleteTrigger(null, (Trigger)((pElem)->data));
			}

			sqlite3HashClear(&temp2);
			sqlite3HashInit(&pSchema.tblHash);
			for (pElem = ((&temp1)->first); pElem; pElem = ((pElem)->next))
			{
				Table pTab = ((pElem)->data);
				sqlite3DeleteTable(null, pTab);
			}

			sqlite3HashClear(&temp1);
			sqlite3HashClear(&pSchema.fkeyHash);
			pSchema.pSeqTab = null;
			if ((pSchema.schemaFlags & 0x0001) != 0)
			{
				pSchema.iGeneration++;
			}

			pSchema.schemaFlags &= (ushort)(~(0x0001 | 0x0008));
		}
		public static Schema sqlite3SchemaGet(sqlite3 db, Btree pBt)
		{
			Schema p;
			if ((pBt) != null)
			{
				p = (Schema)(sqlite3BtreeSchema(pBt, (int)(sizeof(Schema)), sqlite3SchemaClear));
			}
			else
			{
				p = (Schema)(sqlite3DbMallocZero(null, (ulong)(sizeof(Schema))));
			}

			if (p == null)
			{
				sqlite3OomFault(db);
			}
			else if ((0) == (p.file_format))
			{
				sqlite3HashInit(&p.tblHash);
				sqlite3HashInit(&p.idxHash);
				sqlite3HashInit(&p.trigHash);
				sqlite3HashInit(&p.fkeyHash);
				p.enc = (byte)(1);
			}

			return p;
		}
		public static int sqlite3SchemaToIndex(sqlite3 db, Schema pSchema)
		{
			int i = (int)(-32768);

			if ((pSchema) != null)
			{
				for (i = (int)(0); 1; i++)
				{

					if ((db.aDb[i].pSchema) == (pSchema))
					{
						break;
					}
				}


			}

			return (int)(i);
		}
		public static int sqlite3SectorSize(sqlite3_file pFile)
		{
			int iRet = (int)(sqlite3OsSectorSize(pFile));
			if ((iRet) < (32))
			{
				iRet = (int)(512);
			}
			else if ((iRet) > (0x10000))
			{

				iRet = (int)(0x10000);
			}

			return (int)(iRet);
		}
		public static int sqlite3Select(Parse pParse, Select p, SelectDest pDest)
		{
			int i = 0; int j = 0;
			WhereInfo pWInfo;
			Vdbe v;
			int isAgg = 0;
			ExprList pEList = null;
			SrcList pTabList;
			Expr pWhere;
			ExprList pGroupBy;
			Expr pHaving;
			AggInfo pAggInfo = null;
			int rc = (int)(1);
			DistinctCtx sDistinct = new DistinctCtx();
			SortCtx sSort = new SortCtx();
			int iEnd = 0;
			sqlite3 db;
			ExprList pMinMaxOrderBy = null;
			byte minMaxFlag = 0;
			db = pParse.db;

			v = sqlite3GetVdbe(pParse);
			if (((p) == (null)) || ((pParse.nErr) != 0))
			{
				return (int)(1);
			}


			if ((sqlite3AuthCheck(pParse, (int)(21), null, null, null)) != 0)
				return (int)(1);




			if (((pDest.eDest) <= (6)))
			{

				if ((p.pOrderBy) != null)
				{
					sqlite3ParserAddCleanup(pParse, sqlite3ExprListDelete, p.pOrderBy);
					p.pOrderBy = null;
				}

				p.selFlags &= (uint)(~0x0000001);
				p.selFlags |= (uint)(0x0400000);
			}

			sqlite3SelectPrep(pParse, p, null);
			if ((pParse.nErr) != 0)
			{
				goto select_end;
			}



			if ((p.selFlags & 0x0800000) != 0)
			{
				SrcItem p0 = p.pSrc.a[0];
				for (i = (int)(1); (i) < (p.pSrc.nSrc); i++)
				{
					SrcItem p1 = p.pSrc.a[i];
					if (((p0.pTab) == (p1.pTab)) && ((0) == (sqlite3_stricmp(p0.zAlias, p1.zAlias))))
					{
						sqlite3ErrorMsg(pParse, "target object/alias may not appear in FROM clause: %s", (p0.zAlias) != 0 ? p0.zAlias : p0.pTab.zName);
						goto select_end;
					}
				}

				p.selFlags &= (uint)(~0x0800000);
			}

			if ((pDest.eDest) == (9))
			{
				sqlite3GenerateColumnNames(pParse, p);
			}

			if ((sqlite3WindowRewrite(pParse, p)) != 0)
			{

				goto select_end;
			}

			pTabList = p.pSrc;
			isAgg = (int)((p.selFlags & 0x0000008) != 0);
			CRuntime.memset(sSort, (int)(0), (ulong)(sizeof(SortCtx)));
			sSort.pOrderBy = p.pOrderBy;
			for (i = (int)(0); (p.pPrior == null) && ((i) < (pTabList.nSrc)); i++)
			{
				SrcItem pItem = pTabList.a[i];
				Select pSub = pItem.pSelect;
				Table pTab = pItem.pTab;

				if ((((pItem.fg.jointype & 0x0008) != 0) && ((sqlite3ExprImpliesNonNullRow(p.pWhere, (int)(pItem.iCursor))) != 0)) && (((db).dbOptFlags & (0x00002000)) == (0)))
				{
					pItem.fg.jointype &= (byte)(~(0x0008 | 0x0020));
					unsetJoinExpr(p.pWhere, (int)(pItem.iCursor));
				}

				if ((pSub) == (null))
					continue;
				if (pTab.nCol != pSub.pEList.nExpr)
				{
					sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d", (int)(pTab.nCol), pTab.zName, (int)(pSub.pEList.nExpr));
					goto select_end;
				}

				if ((pSub.selFlags & 0x0000008) != 0)
					continue;

				if ((((((pSub.pOrderBy != null) && ((p.pOrderBy != null) || ((pTabList.nSrc) > (1)))) && ((pSub.pLimit) == (null))) && ((pSub.selFlags & 0x8000000) == (0))) && ((p.selFlags & 0x8000000) == (0))) && (((db).dbOptFlags & (0x00040000)) == (0)))
				{
					sqlite3ExprListDelete(db, pSub.pOrderBy);
					pSub.pOrderBy = null;
				}

				if ((((pSub.pOrderBy != null) && ((i) == (0))) && ((p.selFlags & 0x0040000) != 0)) && (((pTabList.nSrc) == (1)) || ((pTabList.a[1].fg.jointype & (0x0008 | 0x0002)) != 0)))
				{
					continue;
				}

				if ((flattenSubquery(pParse, p, (int)(i), (int)(isAgg))) != 0)
				{
					if ((pParse.nErr) != 0)
						goto select_end;
					i = (int)(-1);
				}

				pTabList = p.pSrc;
				if ((db.mallocFailed) != 0)
					goto select_end;
				if (!((pDest.eDest) <= (8)))
				{
					sSort.pOrderBy = p.pOrderBy;
				}
			}

			if ((p.pPrior) != null)
			{
				rc = (int)(multiSelect(pParse, p, pDest));
				if ((p.pNext) == (null))
					sqlite3VdbeExplainPop(pParse);
				return (int)(rc);
			}

			if ((((p.pWhere != null) && ((p.pWhere.op) == (44))) && (((db).dbOptFlags & (0x00008000)) == (0))) && ((propagateConstants(pParse, p)) != 0))
			{
			}
			else
			{
			}

			for (i = (int)(0); (i) < (pTabList.nSrc); i++)
			{
				SrcItem pItem = pTabList.a[i];
				SrcItem pPrior;
				SelectDest dest = new SelectDest();
				Select pSub;
				sbyte* zSavedAuthContext;
				if (((pItem.colUsed) == (0)) && (pItem.zName != null))
				{
					sqlite3AuthCheck(pParse, (int)(20), pItem.zName, "", pItem.zDatabase);
				}

				pSub = pItem.pSelect;
				if ((pSub) == (null))
					continue;

				pParse.nHeight += (int)(sqlite3SelectExprHeight(p));
				if (((((db).dbOptFlags & (0x00001000)) == (0)) && (((pItem.fg.isCte) == (0)) || ((pItem.u2.pCteUse->eM10d != 0) && ((pItem.u2.pCteUse->nUse) < (2))))) && ((pushDownWhereTerms(pParse, pSub, p.pWhere, (int)(pItem.iCursor), (int)((pItem.fg.jointype & 0x0020) != 0))) != 0))
				{

				}
				else
				{
				}

				zSavedAuthContext = pParse.zAuthContext;
				pParse.zAuthContext = pItem.zName;
				if ((((i) == (0)) && (((pTabList.nSrc) == (1)) || ((pTabList.a[1].fg.jointype & (0x0008 | 0x0002)) != 0))) && (((pItem.fg.isCte) == (0)) || (pItem.u2.pCteUse->eM10d != 0)))
				{
					int addrTop = (int)(sqlite3VdbeCurrentAddr(v) + 1);
					pItem.regReturn = (int)(++pParse.nMem);
					sqlite3VdbeAddOp3(v, (int)(13), (int)(pItem.regReturn), (int)(0), (int)(addrTop));
					pItem.addrFillSub = (int)(addrTop);
					sqlite3SelectDestInit(dest, (int)(13), (int)(pItem.regReturn));
					sqlite3VdbeExplain(pParse, (byte)(1), "CO-ROUTINE %!S", pItem);
					sqlite3Select(pParse, pSub, dest);
					pItem.pTab.nRowLogEst = (short)(pSub.nSelectRow);
					pItem.fg.viaCoroutine = (uint)(1);
					pItem.regResult = (int)(dest.iSdst);
					sqlite3VdbeEndCoroutine(v, (int)(pItem.regReturn));
					sqlite3VdbeJumpHere(v, (int)(addrTop - 1));
					sqlite3ClearTempRegCache(pParse);
				}
				else if (((pItem.fg.isCte) != 0) && ((pItem.u2.pCteUse->addrM9e) > (0)))
				{
					CteUse* pCteUse = pItem.u2.pCteUse;
					sqlite3VdbeAddOp2(v, (int)(12), (int)(pCteUse->regRtn), (int)(pCteUse->addrM9e));
					if (pItem.iCursor != pCteUse->iCur)
					{
						sqlite3VdbeAddOp2(v, (int)(113), (int)(pItem.iCursor), (int)(pCteUse->iCur));
					}

					pSub.nSelectRow = (short)(pCteUse->nRowEst);
				}
				else if ((pPrior = isSelfJoinView(pTabList, pItem)) != null)
				{
					if ((pPrior.addrFillSub) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(12), (int)(pPrior.regReturn), (int)(pPrior.addrFillSub));
					}

					sqlite3VdbeAddOp2(v, (int)(113), (int)(pItem.iCursor), (int)(pPrior.iCursor));
					pSub.nSelectRow = (short)(pPrior.pSelect.nSelectRow);
				}
				else
				{
					int topAddr = 0;
					int onceAddr = (int)(0);
					int retAddr = 0;
					pItem.regReturn = (int)(++pParse.nMem);
					topAddr = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pItem.regReturn)));
					pItem.addrFillSub = (int)(topAddr + 1);
					if ((pItem.fg.isCorrelated) == (0))
					{
						onceAddr = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
					}
					else
					{
					}

					sqlite3SelectDestInit(dest, (int)(12), (int)(pItem.iCursor));
					sqlite3VdbeExplain(pParse, (byte)(1), "MATERIALIZE %!S", pItem);
					sqlite3Select(pParse, pSub, dest);
					pItem.pTab.nRowLogEst = (short)(pSub.nSelectRow);
					if ((onceAddr) != 0)
						sqlite3VdbeJumpHere(v, (int)(onceAddr));
					retAddr = (int)(sqlite3VdbeAddOp1(v, (int)(67), (int)(pItem.regReturn)));
					sqlite3VdbeChangeP1(v, (int)(topAddr), (int)(retAddr));
					sqlite3ClearTempRegCache(pParse);
					if (((pItem.fg.isCte) != 0) && ((pItem.fg.isCorrelated) == (0)))
					{
						CteUse* pCteUse = pItem.u2.pCteUse;
						pCteUse->addrM9e = (int)(pItem.addrFillSub);
						pCteUse->regRtn = (int)(pItem.regReturn);
						pCteUse->iCur = (int)(pItem.iCursor);
						pCteUse->nRowEst = (short)(pSub.nSelectRow);
					}
				}

				if ((db.mallocFailed) != 0)
					goto select_end;
				pParse.nHeight -= (int)(sqlite3SelectExprHeight(p));
				pParse.zAuthContext = zSavedAuthContext;
			}

			pEList = p.pEList;
			pWhere = p.pWhere;
			pGroupBy = p.pGroupBy;
			pHaving = p.pHaving;
			sDistinct.isTnct = (byte)((p.selFlags & 0x0000001) != 0);
			if ((((p.selFlags & (0x0000001 | 0x0000008)) == (0x0000001)) && ((sqlite3ExprListCompare(sSort.pOrderBy, pEList, (int)(-1))) == (0))) && ((p.pWin) == (null)))
			{
				p.selFlags &= (uint)(~0x0000001);
				pGroupBy = p.pGroupBy = sqlite3ExprListDup(db, pEList, (int)(0));
				p.selFlags |= (uint)(0x0000008);

			}

			if ((sSort.pOrderBy) != null)
			{
				KeyInfo pKeyInfo;
				pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, (int)(0), (int)(pEList.nExpr));
				sSort.iECursor = (int)(pParse.nTab++);
				sSort.addrSortIndex = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(sSort.iECursor), (int)(sSort.pOrderBy.nExpr + 1 + pEList.nExpr), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
			}
			else
			{
				sSort.addrSortIndex = (int)(-1);
			}

			if ((pDest.eDest) == (12))
			{
				sqlite3VdbeAddOp2(v, (int)(116), (int)(pDest.iSDParm), (int)(pEList.nExpr));
			}

			iEnd = (int)(sqlite3VdbeMakeLabel(pParse));
			if ((p.selFlags & 0x0004000) == (0))
			{
				p.nSelectRow = (short)(320);
			}

			computeLimitRegisters(pParse, p, (int)(iEnd));
			if (((p.iLimit) == (0)) && ((sSort.addrSortIndex) >= (0)))
			{
				sqlite3VdbeChangeOpcode(v, (int)(sSort.addrSortIndex), (byte)(118));
				sSort.sortFlags |= (byte)(0x01);
			}

			if ((p.selFlags & 0x0000001) != 0)
			{
				sDistinct.tabTnct = (int)(pParse.nTab++);
				sDistinct.addrTnct = (int)(sqlite3VdbeAddOp4(v, (int)(116), (int)(sDistinct.tabTnct), (int)(0), (int)(0), (sbyte*)(sqlite3KeyInfoFromExprList(pParse, p.pEList, (int)(0), (int)(0))), (int)(-9)));
				sqlite3VdbeChangeP5(v, (ushort)(8));
				sDistinct.eTnctType = (byte)(3);
			}
			else
			{
				sDistinct.eTnctType = (byte)(0);
			}

			if ((isAgg == 0) && ((pGroupBy) == (null)))
			{
				ushort wctrlFlags = (ushort)(((sDistinct.isTnct) != 0 ? 0x0100 : 0) | (p.selFlags & 0x0004000));
				Window pWin = p.pWin;
				if ((pWin) != null)
				{
					sqlite3WindowCodeInit(pParse, p);
				}


				pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p.pEList, p, (ushort)(wctrlFlags), (int)(p.nSelectRow));
				if ((pWInfo) == (null))
					goto select_end;
				if ((sqlite3WhereOutputRowCount(pWInfo)) < (p.nSelectRow))
				{
					p.nSelectRow = (short)(sqlite3WhereOutputRowCount(pWInfo));
				}

				if (((sDistinct.isTnct) != 0) && ((sqlite3WhereIsDistinct(pWInfo)) != 0))
				{
					sDistinct.eTnctType = (byte)(sqlite3WhereIsDistinct(pWInfo));
				}

				if ((sSort.pOrderBy) != null)
				{
					sSort.nOBSat = (int)(sqlite3WhereIsOrdered(pWInfo));
					sSort.labelOBLopt = (int)(sqlite3WhereOrderByLimitOptLabel(pWInfo));
					if ((sSort.nOBSat) == (sSort.pOrderBy.nExpr))
					{
						sSort.pOrderBy = null;
					}
				}

				if (((sSort.addrSortIndex) >= (0)) && ((sSort.pOrderBy) == (null)))
				{
					sqlite3VdbeChangeToNoop(v, (int)(sSort.addrSortIndex));
				}


				if ((pWin) != null)
				{
					int addrGosub = (int)(sqlite3VdbeMakeLabel(pParse));
					int iCont = (int)(sqlite3VdbeMakeLabel(pParse));
					int iBreak = (int)(sqlite3VdbeMakeLabel(pParse));
					int regGosub = (int)(++pParse.nMem);
					sqlite3WindowCodeStep(pParse, p, pWInfo, (int)(regGosub), (int)(addrGosub));
					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(iBreak));
					sqlite3VdbeResolveLabel(v, (int)(addrGosub));
					sSort.labelOBLopt = (int)(0);
					selectInnerLoop(pParse, p, (int)(-1), sSort, &sDistinct, pDest, (int)(iCont), (int)(iBreak));
					sqlite3VdbeResolveLabel(v, (int)(iCont));
					sqlite3VdbeAddOp1(v, (int)(67), (int)(regGosub));
					sqlite3VdbeResolveLabel(v, (int)(iBreak));
				}
				else
				{
					selectInnerLoop(pParse, p, (int)(-1), sSort, &sDistinct, pDest, (int)(sqlite3WhereContinueLabel(pWInfo)), (int)(sqlite3WhereBreakLabel(pWInfo)));
					sqlite3WhereEnd(pWInfo);
				}
			}
			else
			{
				NameContext sNC = new NameContext();
				int iAMem = 0;
				int iBMem = 0;
				int iUseFlag = 0;
				int iAbortFlag = 0;
				int groupBySort = 0;
				int addrEnd = 0;
				int sortPTab = (int)(0);
				int sortOut = (int)(0);
				int orderByGrp = (int)(0);
				if ((pGroupBy) != null)
				{
					int k = 0;
					ExprList_item* pItem;
					for (k = (int)(p.pEList.nExpr), pItem = p.pEList.a; (k) > (0); k--, pItem++)
					{
						pItem->u.x.iAlias = (ushort)(0);
					}

					for (k = (int)(pGroupBy.nExpr), pItem = pGroupBy.a; (k) > (0); k--, pItem++)
					{
						pItem->u.x.iAlias = (ushort)(0);
					}


					if ((p.nSelectRow) > (66))
						p.nSelectRow = (short)(66);
					if (((sSort.pOrderBy) != null) && ((pGroupBy.nExpr) == (sSort.pOrderBy.nExpr)))
					{
						int ii = 0;
						for (ii = (int)(0); (ii) < (pGroupBy.nExpr); ii++)
						{
							byte sortFlags = (byte)(sSort.pOrderBy.a[ii].sortFlags & 0x01);
							pGroupBy.a[ii].sortFlags = (byte)(sortFlags);
						}

						if ((sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, (int)(-1))) == (0))
						{
							orderByGrp = (int)(1);
						}
					}
				}
				else
				{

					p.nSelectRow = (short)(0);
				}

				addrEnd = (int)(sqlite3VdbeMakeLabel(pParse));
				pAggInfo = sqlite3DbMallocZero(db, (ulong)(sizeof(AggInfo)));
				if ((pAggInfo) != null)
				{
					sqlite3ParserAddCleanup(pParse, agginfoFree, pAggInfo);
				}

				if ((db.mallocFailed) != 0)
				{
					goto select_end;
				}

				pAggInfo.selId = (uint)(p.selId);
				CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
				sNC.pParse = pParse;
				sNC.pSrcList = pTabList;
				sNC.uNC.pAggInfo = pAggInfo;
				pAggInfo.mnReg = (int)(pParse.nMem + 1);
				pAggInfo.nSortingColumn = (int)(pGroupBy ? pGroupBy.nExpr : 0);
				pAggInfo.pGroupBy = pGroupBy;
				sqlite3ExprAnalyzeAggList(sNC, pEList);
				sqlite3ExprAnalyzeAggList(sNC, sSort.pOrderBy);
				if ((pHaving) != null)
				{
					if ((pGroupBy) != null)
					{



						havingToWhere(pParse, p);
						pWhere = p.pWhere;
					}

					sqlite3ExprAnalyzeAggregates(sNC, pHaving);
				}

				pAggInfo.nAccumulator = (int)(pAggInfo.nColumn);
				if ((((p.pGroupBy) == (null)) && ((p.pHaving) == (null))) && ((pAggInfo.nFunc) == (1)))
				{
					minMaxFlag = (byte)(minMaxQuery(db, pAggInfo.aFunc[0].pFExpr, pMinMaxOrderBy));
				}
				else
				{
					minMaxFlag = (byte)(0x0000);
				}

				for (i = (int)(0); (i) < (pAggInfo.nFunc); i++)
				{
					Expr pExpr = pAggInfo.aFunc[i].pFExpr;

					sNC.ncFlags |= (int)(0x020000);
					sqlite3ExprAnalyzeAggList(sNC, pExpr.x.pList);

					if ((((pExpr).flags & (0x1000000)) != 0))
					{
						sqlite3ExprAnalyzeAggregates(sNC, pExpr.y.pWin.pFilter);
					}

					sNC.ncFlags &= (int)(~0x020000);
				}

				pAggInfo.mxReg = (int)(pParse.nMem);
				if ((db.mallocFailed) != 0)
					goto select_end;
				if ((pGroupBy) != null)
				{
					KeyInfo pKeyInfo;
					int addr1 = 0;
					int addrOutputRow = 0;
					int regOutputRow = 0;
					int addrSetAbort = 0;
					int addrTopOfLoop = 0;
					int addrSortingIdx = 0;
					int addrReset = 0;
					int regReset = 0;
					ExprList pDistinct = null;
					ushort distFlag = (ushort)(0);
					int eDist = (int)(0);
					if ((((((pAggInfo.nFunc) == (1)) && ((pAggInfo.aFunc[0].iDistinct) >= (0))) && (pAggInfo.aFunc[0].pFExpr != null)) && ((((pAggInfo.aFunc[0].pFExpr).flags & 0x000800) == (0)) != 0)) && (pAggInfo.aFunc[0].pFExpr.x.pList != null))
					{
						Expr pExpr = pAggInfo.aFunc[0].pFExpr.x.pList.a[0].pExpr;
						pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
						pDistinct = sqlite3ExprListDup(db, pGroupBy, (int)(0));
						pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);
						distFlag = (ushort)(pDistinct ? (0x0100 | 0x0400) : 0);
					}

					pAggInfo.sortingIdx = (int)(pParse.nTab++);
					pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, (int)(0), (int)(pAggInfo.nColumn));
					addrSortingIdx = (int)(sqlite3VdbeAddOp4(v, (int)(118), (int)(pAggInfo.sortingIdx), (int)(pAggInfo.nSortingColumn), (int)(0), (sbyte*)(pKeyInfo), (int)(-9)));
					iUseFlag = (int)(++pParse.nMem);
					iAbortFlag = (int)(++pParse.nMem);
					regOutputRow = (int)(++pParse.nMem);
					addrOutputRow = (int)(sqlite3VdbeMakeLabel(pParse));
					regReset = (int)(++pParse.nMem);
					addrReset = (int)(sqlite3VdbeMakeLabel(pParse));
					iAMem = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(pGroupBy.nExpr);
					iBMem = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(pGroupBy.nExpr);
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(iAbortFlag));
					sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(iAMem), (int)(iAMem + pGroupBy.nExpr - 1));
					sqlite3VdbeAddOp2(v, (int)(12), (int)(regReset), (int)(addrReset));
					pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, null, (ushort)(0x0040 | ((orderByGrp) != 0 ? 0x0200 : 0) | distFlag), (int)(0));
					if ((pWInfo) == (null))
					{
						sqlite3ExprListDelete(db, pDistinct);
						goto select_end;
					}

					eDist = (int)(sqlite3WhereIsDistinct(pWInfo));
					if ((sqlite3WhereIsOrdered(pWInfo)) == (pGroupBy.nExpr))
					{
						groupBySort = (int)(0);
					}
					else
					{
						int regBase = 0;
						int regRecord = 0;
						int nCol = 0;
						int nGroupBy = 0;
						explainTempTable(pParse, (((sDistinct.isTnct) != 0) && ((p.selFlags & 0x0000001) == (0))) ? "DISTINCT" : "GROUP BY");
						groupBySort = (int)(1);
						nGroupBy = (int)(pGroupBy.nExpr);
						nCol = (int)(nGroupBy);
						j = (int)(nGroupBy);
						for (i = (int)(0); (i) < (pAggInfo.nColumn); i++)
						{
							if ((pAggInfo.aCol[i].iSorterColumn) >= (j))
							{
								nCol++;
								j++;
							}
						}

						regBase = (int)(sqlite3GetTempRange(pParse, (int)(nCol)));
						sqlite3ExprCodeExprList(pParse, pGroupBy, (int)(regBase), (int)(0), (byte)(0));
						j = (int)(nGroupBy);
						for (i = (int)(0); (i) < (pAggInfo.nColumn); i++)
						{
							AggInfo_col* pCol = &pAggInfo.aCol[i];
							if ((pCol->iSorterColumn) >= (j))
							{
								int r1 = (int)(j + regBase);
								sqlite3ExprCodeGetColumnOfTable(v, pCol->pTab, (int)(pCol->iTable), (int)(pCol->iColumn), (int)(r1));
								j++;
							}
						}

						regRecord = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(regBase), (int)(nCol), (int)(regRecord));
						sqlite3VdbeAddOp2(v, (int)(138), (int)(pAggInfo.sortingIdx), (int)(regRecord));
						sqlite3ReleaseTempReg(pParse, (int)(regRecord));
						sqlite3ReleaseTempRange(pParse, (int)(regBase), (int)(nCol));
						sqlite3WhereEnd(pWInfo);
						pAggInfo.sortingIdxPTab = (int)(sortPTab = (int)(pParse.nTab++));
						sortOut = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp3(v, (int)(120), (int)(sortPTab), (int)(sortOut), (int)(nCol));
						sqlite3VdbeAddOp2(v, (int)(36), (int)(pAggInfo.sortingIdx), (int)(addrEnd));
						pAggInfo.useSortingIdx = (byte)(1);
					}

					if ((((orderByGrp) != 0) && (((db).dbOptFlags & (0x00000004)) == (0))) && (((groupBySort) != 0) || ((sqlite3WhereIsSorted(pWInfo)) != 0)))
					{
						sSort.pOrderBy = null;
						sqlite3VdbeChangeToNoop(v, (int)(sSort.addrSortIndex));
					}

					addrTopOfLoop = (int)(sqlite3VdbeCurrentAddr(v));
					if ((groupBySort) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(132), (int)(pAggInfo.sortingIdx), (int)(sortOut), (int)(sortPTab));
					}

					for (j = (int)(0); (j) < (pGroupBy.nExpr); j++)
					{
						if ((groupBySort) != 0)
						{
							sqlite3VdbeAddOp3(v, (int)(93), (int)(sortPTab), (int)(j), (int)(iBMem + j));
						}
						else
						{
							pAggInfo.directMode = (byte)(1);
							sqlite3ExprCode(pParse, pGroupBy.a[j].pExpr, (int)(iBMem + j));
						}
					}

					sqlite3VdbeAddOp4(v, (int)(89), (int)(iAMem), (int)(iBMem), (int)(pGroupBy.nExpr), (sbyte*)(sqlite3KeyInfoRef(pKeyInfo)), (int)(-9));
					addr1 = (int)(sqlite3VdbeCurrentAddr(v));
					sqlite3VdbeAddOp3(v, (int)(16), (int)(addr1 + 1), (int)(0), (int)(addr1 + 1));
					sqlite3ExprCodeMove(pParse, (int)(iBMem), (int)(iAMem), (int)(pGroupBy.nExpr));
					sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutputRow), (int)(addrOutputRow));
					sqlite3VdbeAddOp2(v, (int)(49), (int)(iAbortFlag), (int)(addrEnd));
					sqlite3VdbeAddOp2(v, (int)(12), (int)(regReset), (int)(addrReset));
					sqlite3VdbeJumpHere(v, (int)(addr1));
					updateAccumulator(pParse, (int)(iUseFlag), pAggInfo, (int)(eDist));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iUseFlag));
					if ((groupBySort) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(3), (int)(pAggInfo.sortingIdx), (int)(addrTopOfLoop));
					}
					else
					{
						sqlite3WhereEnd(pWInfo);
						sqlite3VdbeChangeToNoop(v, (int)(addrSortingIdx));
					}

					sqlite3ExprListDelete(db, pDistinct);
					sqlite3VdbeAddOp2(v, (int)(12), (int)(regOutputRow), (int)(addrOutputRow));
					sqlite3VdbeGoto(v, (int)(addrEnd));
					addrSetAbort = (int)(sqlite3VdbeCurrentAddr(v));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(iAbortFlag));
					sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
					sqlite3VdbeResolveLabel(v, (int)(addrOutputRow));
					addrOutputRow = (int)(sqlite3VdbeCurrentAddr(v));
					sqlite3VdbeAddOp2(v, (int)(49), (int)(iUseFlag), (int)(addrOutputRow + 2));
					sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
					finalizeAggFunctions(pParse, pAggInfo);
					sqlite3ExprIfFalse(pParse, pHaving, (int)(addrOutputRow + 1), (int)(0x10));
					selectInnerLoop(pParse, p, (int)(-1), sSort, &sDistinct, pDest, (int)(addrOutputRow + 1), (int)(addrSetAbort));
					sqlite3VdbeAddOp1(v, (int)(67), (int)(regOutputRow));
					sqlite3VdbeResolveLabel(v, (int)(addrReset));
					resetAccumulator(pParse, pAggInfo);
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(iUseFlag));
					sqlite3VdbeAddOp1(v, (int)(67), (int)(regReset));
					if (eDist != 0)
					{
						AggInfo_func* pF = &pAggInfo.aFunc[0];
						fixDistinctOpenEph(pParse, (int)(eDist), (int)(pF->iDistinct), (int)(pF->iDistAddr));
					}
				}
				else
				{
					Table pTab;
					if ((pTab = isSimpleCount(p, pAggInfo)) != null)
					{
						int iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
						int iCsr = (int)(pParse.nTab++);
						Index pIdx;
						KeyInfo pKeyInfo = null;
						Index pBest = null;
						uint iRoot = (uint)(pTab.tnum);
						sqlite3CodeVerifySchema(pParse, (int)(iDb));
						sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
						if (!(((pTab).tabFlags & 0x00000080) == (0)))
							pBest = sqlite3PrimaryKeyIndex(pTab);
						if (p.pSrc.a[0].fg.notIndexed == 0)
						{
							for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
							{
								if (((((pIdx.bUnordered) == (0)) && ((pIdx.szIdxRow) < (pTab.szTabRow))) && ((pIdx.pPartIdxWhere) == (null))) && ((pBest == null) || ((pIdx.szIdxRow) < (pBest.szIdxRow))))
								{
									pBest = pIdx;
								}
							}
						}

						if ((pBest) != null)
						{
							iRoot = (uint)(pBest.tnum);
							pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
						}

						sqlite3VdbeAddOp4Int(v, (int)(101), (int)(iCsr), (int)(iRoot), (int)(iDb), (int)(1));
						if ((pKeyInfo) != null)
						{
							sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pKeyInfo), (int)(-9));
						}

						sqlite3VdbeAddOp2(v, (int)(97), (int)(iCsr), (int)(pAggInfo.aFunc[0].iMem));
						sqlite3VdbeAddOp1(v, (int)(121), (int)(iCsr));
						explainSimpleCount(pParse, pTab, pBest);
					}
					else
					{
						int regAcc = (int)(0);
						ExprList pDistinct = null;
						ushort distFlag = (ushort)(0);
						int eDist = 0;
						if ((pAggInfo.nAccumulator) != 0)
						{
							for (i = (int)(0); (i) < (pAggInfo.nFunc); i++)
							{
								if ((((pAggInfo.aFunc[i].pFExpr).flags & (0x1000000)) != 0))
								{
									continue;
								}

								if ((pAggInfo.aFunc[i].pFunc.funcFlags & 0x0020) != 0)
								{
									break;
								}
							}

							if ((i) == (pAggInfo.nFunc))
							{
								regAcc = (int)(++pParse.nMem);
								sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regAcc));
							}
						}
						else if (((pAggInfo.nFunc) == (1)) && ((pAggInfo.aFunc[0].iDistinct) >= (0)))
						{

							pDistinct = pAggInfo.aFunc[0].pFExpr.x.pList;
							distFlag = (ushort)(pDistinct ? (0x0100 | 0x0400) : 0);
						}


						resetAccumulator(pParse, pAggInfo);


						pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, null, (ushort)(minMaxFlag | distFlag), (int)(0));
						if ((pWInfo) == (null))
						{
							goto select_end;
						}

						eDist = (int)(sqlite3WhereIsDistinct(pWInfo));
						updateAccumulator(pParse, (int)(regAcc), pAggInfo, (int)(eDist));
						if (eDist != 0)
						{
							AggInfo_func* pF = &pAggInfo.aFunc[0];
							fixDistinctOpenEph(pParse, (int)(eDist), (int)(pF->iDistinct), (int)(pF->iDistAddr));
						}

						if ((regAcc) != 0)
							sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regAcc));
						if ((minMaxFlag) != 0)
						{
							sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);
						}

						sqlite3WhereEnd(pWInfo);
						finalizeAggFunctions(pParse, pAggInfo);
					}

					sSort.pOrderBy = null;
					sqlite3ExprIfFalse(pParse, pHaving, (int)(addrEnd), (int)(0x10));
					selectInnerLoop(pParse, p, (int)(-1), null, null, pDest, (int)(addrEnd), (int)(addrEnd));
				}

				sqlite3VdbeResolveLabel(v, (int)(addrEnd));
			}

			if ((sDistinct.eTnctType) == (3))
			{
				explainTempTable(pParse, "DISTINCT");
			}

			if ((sSort.pOrderBy) != null)
			{
				explainTempTable(pParse, (sSort.nOBSat) > (0) ? "RIGHT PART OF ORDER BY" : "ORDER BY");

				generateSortTail(pParse, p, sSort, (int)(pEList.nExpr), pDest);
			}

			sqlite3VdbeResolveLabel(v, (int)(iEnd));
			rc = (int)((pParse.nErr) > (0) ? 1 : 0);
		select_end:
			; ((void)(0));

			sqlite3ExprListDelete(db, pMinMaxOrderBy);
			sqlite3VdbeExplainPop(pParse);
			return (int)(rc);
		}
		public static void sqlite3SelectAddColumnTypeAndCollation(Parse pParse, Table pTab, Select pSelect, sbyte aff)
		{
			sqlite3 db = pParse.db;
			NameContext sNC = new NameContext();
			Column* pCol;
			CollSeq pColl;
			int i = 0;
			Expr p;
			ExprList_item* a;



			if ((db.mallocFailed) != 0)
				return;
			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pSrcList = pSelect.pSrc;
			a = pSelect.pEList.a;
			for (i = (int)(0), pCol = pTab.aCol; (i) < (pTab.nCol); i++, pCol++)
			{
				sbyte* zType;
				long n = 0;
				long m = 0;
				pTab.tabFlags |= (uint)(pCol->colFlags & 0x0062);
				p = a[i].pExpr;
				zType = columnTypeImpl(sNC, p);
				pCol->affinity = (sbyte)(sqlite3ExprAffinity(p));
				if ((zType) != null)
				{
					m = (long)(sqlite3Strlen30(zType));
					n = (long)(sqlite3Strlen30(pCol->zCnName));
					pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, (ulong)(n + m + 2));
					if ((pCol->zCnName) != null)
					{
						CRuntime.memcpy(&pCol->zCnName[n + 1], zType, (ulong)(m + 1));
						pCol->colFlags |= (ushort)(0x0004);
					}
					else
					{
						pCol->colFlags &= (ushort)(~(0x0004 | 0x0200));
					}
				}

				if ((pCol->affinity) <= (0x40))
					pCol->affinity = (sbyte)(aff);
				pColl = sqlite3ExprCollSeq(pParse, p);
				if ((pColl) != null)
				{

					sqlite3ColumnSetColl(db, pCol, pColl.zName);
				}
			}

			pTab.szTabRow = (short)(1);
		}
		public static void sqlite3SelectAddTypeInfo(Parse pParse, Select pSelect)
		{
			Walker w = new Walker();
			w.xSelectCallback = sqlite3SelectWalkNoop;
			w.xSelectCallback2 = selectAddSubqueryTypeInfo;
			w.xExprCallback = sqlite3ExprWalkNoop;
			w.pParse = pParse;
			sqlite3WalkSelect(w, pSelect);
		}
		public static void sqlite3SelectDelete(sqlite3 db, Select p)
		{
			if ((p) != null)
				clearSelect(db, p, (int)(1));
		}
		public static void sqlite3SelectDestInit(SelectDest pDest, int eDest, int iParm)
		{
			pDest.eDest = ((byte)(eDest));
			pDest.iSDParm = (int)(iParm);
			pDest.iSDParm2 = (int)(0);
			pDest.zAffSdst = null;
			pDest.iSdst = (int)(0);
			pDest.nSdst = (int)(0);
		}
		public static Select sqlite3SelectDup(sqlite3 db, Select pDup, int flags)
		{
			Select pRet = null;
			Select pNext = null;
			Select pp = pRet;
			Select p;

			for (p = pDup; p; p = p.pPrior)
			{
				Select pNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Select)));
				if ((pNew) == (null))
					break;
				pNew.pEList = sqlite3ExprListDup(db, p.pEList, (int)(flags));
				pNew.pSrc = sqlite3SrcListDup(db, p.pSrc, (int)(flags));
				pNew.pWhere = sqlite3ExprDup(db, p.pWhere, (int)(flags));
				pNew.pGroupBy = sqlite3ExprListDup(db, p.pGroupBy, (int)(flags));
				pNew.pHaving = sqlite3ExprDup(db, p.pHaving, (int)(flags));
				pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, (int)(flags));
				pNew.op = (byte)(p.op);
				pNew.pNext = pNext;
				pNew.pPrior = null;
				pNew.pLimit = sqlite3ExprDup(db, p.pLimit, (int)(flags));
				pNew.iLimit = (int)(0);
				pNew.iOffset = (int)(0);
				pNew.selFlags = (uint)(p.selFlags & ~0x0000020);
				pNew.addrOpenEphm[0] = (int)(-1);
				pNew.addrOpenEphm[1] = (int)(-1);
				pNew.nSelectRow = (short)(p.nSelectRow);
				pNew.pWith = sqlite3WithDup(db, p.pWith);
				pNew.pWin = null;
				pNew.pWinDefn = sqlite3WindowListDup(db, p.pWinDefn);
				if (((p.pWin) != null) && ((db.mallocFailed) == (0)))
					gatherSelectWindows(pNew);
				pNew.selId = (uint)(p.selId);
				if ((db.mallocFailed) != 0)
				{
					pNew.pNext = null;
					sqlite3SelectDelete(db, pNew);
					break;
				}

				pp = pNew;
				pp = pNew.pPrior;
				pNext = pNew;
			}

			return pRet;
		}
		public static void sqlite3SelectExpand(Parse pParse, Select pSelect)
		{
			Walker w = new Walker();
			w.xExprCallback = sqlite3ExprWalkNoop;
			w.pParse = pParse;
			if ((pParse.hasCompound) != 0)
			{
				w.xSelectCallback = convertCompoundSelectToSubquery;
				w.xSelectCallback2 = null;
				sqlite3WalkSelect(w, pSelect);
			}

			w.xSelectCallback = selectExpander;
			w.xSelectCallback2 = sqlite3SelectPopWith;
			w.eCode = (ushort)(0);
			sqlite3WalkSelect(w, pSelect);
		}
		public static int sqlite3SelectExprHeight(Select p)
		{
			int nHeight = (int)(0);
			heightOfSelect(p, &nHeight);
			return (int)(nHeight);
		}
		public static Select sqlite3SelectNew(Parse pParse, ExprList pEList, SrcList pSrc, Expr pWhere, ExprList pGroupBy, Expr pHaving, ExprList pOrderBy, uint selFlags, Expr pLimit)
		{
			Select pNew; Select pAllocated;
			Select standin = new Select();
			pAllocated = pNew = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Select)));
			if ((pNew) == (null))
			{

				pNew = standin;
			}

			if ((pEList) == (null))
			{
				pEList = sqlite3ExprListAppend(pParse, null, sqlite3Expr(pParse.db, (int)(180), null));
			}

			pNew.pEList = pEList;
			pNew.op = (byte)(138);
			pNew.selFlags = (uint)(selFlags);
			pNew.iLimit = (int)(0);
			pNew.iOffset = (int)(0);
			pNew.selId = (uint)(++pParse.nSelect);
			pNew.addrOpenEphm[0] = (int)(-1);
			pNew.addrOpenEphm[1] = (int)(-1);
			pNew.nSelectRow = (short)(0);
			if ((pSrc) == (null))
				pSrc = sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(SrcList)));
			pNew.pSrc = pSrc;
			pNew.pWhere = pWhere;
			pNew.pGroupBy = pGroupBy;
			pNew.pHaving = pHaving;
			pNew.pOrderBy = pOrderBy;
			pNew.pPrior = null;
			pNew.pNext = null;
			pNew.pLimit = pLimit;
			pNew.pWith = null;
			pNew.pWin = null;
			pNew.pWinDefn = null;
			if ((pParse.db.mallocFailed) != 0)
			{
				clearSelect(pParse.db, pNew, (int)(pNew != standin));
				pAllocated = null;
			}
			else
			{

			}

			return pAllocated;
		}
		public static sbyte* sqlite3SelectOpName(int id)
		{
			sbyte* z;
			switch (id)
			{
				case 135:
					z = "UNION ALL";
					break;
				case 137:
					z = "INTERSECT";
					break;
				case 136:
					z = "EXCEPT";
					break;
				default:
					z = "UNION";
					break;
			}

			return z;
		}
		public static void sqlite3SelectPopWith(Walker pWalker, Select p)
		{
			Parse pParse = pWalker.pParse;
			if (((pParse.pWith) != null) && ((p.pPrior) == (null)))
			{
				With pWith = findRightmost(p).pWith;
				if (pWith != null)
				{

					pParse.pWith = pWith.pOuter;
				}
			}
		}
		public static void sqlite3SelectPrep(Parse pParse, Select p, NameContext pOuterNC)
		{


			if ((pParse.db.mallocFailed) != 0)
				return;
			if ((p.selFlags & 0x0000080) != 0)
				return;
			sqlite3SelectExpand(pParse, p);
			if ((pParse.nErr) != 0)
				return;
			sqlite3ResolveSelectNames(pParse, p, pOuterNC);
			if ((pParse.nErr) != 0)
				return;
			sqlite3SelectAddTypeInfo(pParse, p);
		}
		public static int sqlite3SelectWalkFail(Walker pWalker, Select NotUsed)
		{
			(void)(NotUsed);
			pWalker.eCode = (ushort)(0);
			return (int)(2);
		}
		public static int sqlite3SelectWalkNoop(Walker NotUsed, Select NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			return (int)(0);
		}
		public static void sqlite3SelectWrongNumTermsError(Parse pParse, Select p)
		{
			if ((p.selFlags & 0x0000200) != 0)
			{
				sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
			}
			else
			{
				sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s do not have the same number of result columns", sqlite3SelectOpName((int)(p.op)));
			}
		}
		public static void sqlite3SetHasNullFlag(Vdbe v, int iCur, int regHasNull)
		{
			int addr1 = 0;
			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regHasNull));
			addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(iCur)));
			sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(0), (int)(regHasNull));
			sqlite3VdbeChangeP5(v, (ushort)(0x80));
			sqlite3VdbeJumpHere(v, (int)(addr1));
		}
		public static void sqlite3SetJoinExpr(Expr p, int iTable)
		{
			while ((p) != null)
			{
				(p).flags |= (uint)(0x000001);

				p.w.iRightJoinTable = (int)(iTable);
				if ((p.op) == (172))
				{

					if ((p.x.pList) != null)
					{
						int i = 0;
						for (i = (int)(0); (i) < (p.x.pList.nExpr); i++)
						{
							sqlite3SetJoinExpr(p.x.pList.a[i].pExpr, (int)(iTable));
						}
					}
				}

				sqlite3SetJoinExpr(p.pLeft, (int)(iTable));
				p = p.pRight;
			}
		}
		public static void sqlite3SetString(sbyte** pz, sqlite3 db, sbyte* zNew)
		{
			sqlite3DbFree(db, *pz);
			*pz = sqlite3DbStrDup(db, zNew);
		}
		public static void sqlite3SetTextEncoding(sqlite3 db, byte enc)
		{

			db.enc = (byte)(enc);
			db.pDfltColl = sqlite3FindCollSeq(db, (byte)(enc), sqlite3StrBINARY, (int)(0));
		}
		public static int sqlite3ShadowTableName(sqlite3 db, sbyte* zName)
		{
			sbyte* zTail;
			Table pTab;
			zTail = strrchr(zName, (int)(95));
			if ((zTail) == (null))
				return (int)(0);
			*zTail = (sbyte)(0);
			pTab = sqlite3FindTable(db, zName, null);
			*zTail = (sbyte)(95);
			if ((pTab) == (null))
				return (int)(0);
			if (!(((pTab).eTabType) == (1)))
				return (int)(0);
			return (int)(sqlite3IsShadowTableOf(db, pTab, zName));
		}
		public static void sqlite3SkipAccumulatorLoad(sqlite3_context context)
		{

			context.isError = (int)(-1);
			context.skipFlag = (byte)(1);
		}
		public static SrcList sqlite3SrcListAppend(Parse pParse, SrcList pList, Token* pTable, Token* pDatabase)
		{
			SrcItem pItem;
			sqlite3 db;



			db = pParse.db;
			if ((pList) == (null))
			{
				pList = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(SrcList)));
				if ((pList) == (null))
					return null;
				pList.nAlloc = (uint)(1);
				pList.nSrc = (int)(1);
				CRuntime.memset(pList.a[0], (int)(0), (ulong)(sizeof(SrcItem)));
				pList.a[0].iCursor = (int)(-1);
			}
			else
			{
				SrcList pNew = sqlite3SrcListEnlarge(pParse, pList, (int)(1), (int)(pList.nSrc));
				if ((pNew) == (null))
				{
					sqlite3SrcListDelete(db, pList);
					return null;
				}
				else
				{
					pList = pNew;
				}
			}

			pItem = pList.a[pList.nSrc - 1];
			if (((pDatabase) != null) && ((pDatabase->z) == (null)))
			{
				pDatabase = null;
			}

			if ((pDatabase) != null)
			{
				pItem.zName = sqlite3NameFromToken(db, pDatabase);
				pItem.zDatabase = sqlite3NameFromToken(db, pTable);
			}
			else
			{
				pItem.zName = sqlite3NameFromToken(db, pTable);
				pItem.zDatabase = null;
			}

			return pList;
		}
		public static SrcList sqlite3SrcListAppendFromTerm(Parse pParse, SrcList p, Token* pTable, Token* pDatabase, Token* pAlias, Select pSubquery, Expr pOn, IdList* pUsing)
		{
			SrcItem pItem;
			sqlite3 db = pParse.db;
			if ((p == null) && (((pOn) != null) || ((pUsing) != null)))
			{
				sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s", (pOn ? "ON" : "USING"));
				goto append_from_error;
			}

			p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);
			if ((p) == (null))
			{
				goto append_from_error;
			}


			pItem = p.a[p.nSrc - 1];


			if (((pParse.eParseMode) >= (2)) && ((pItem.zName) != null))
			{
				Token* pToken = (((pDatabase) != null) && ((pDatabase->z) != null)) ? pDatabase : pTable;
				sqlite3RenameTokenMap(pParse, pItem.zName, pToken);
			}


			if ((pAlias->n) != 0)
			{
				pItem.zAlias = sqlite3NameFromToken(db, pAlias);
			}

			pItem.pSelect = pSubquery;
			pItem.pOn = pOn;
			pItem.pUsing = pUsing;
			return p;
		append_from_error:
			; ((void)(0));
			sqlite3ExprDelete(db, pOn);
			sqlite3IdListDelete(db, pUsing);
			sqlite3SelectDelete(db, pSubquery);
			return null;
		}
		public static SrcList sqlite3SrcListAppendList(Parse pParse, SrcList p1, SrcList p2)
		{

			if ((p2) != null)
			{
				SrcList pNew = sqlite3SrcListEnlarge(pParse, p1, (int)(p2.nSrc), (int)(1));
				if ((pNew) == (null))
				{
					sqlite3SrcListDelete(pParse.db, p2);
				}
				else
				{
					p1 = pNew;
					CRuntime.memcpy(p1.a[1], p2.a, (ulong)(p2.nSrc * sizeof(SrcItem)));
					sqlite3DbFree(pParse.db, p2);
				}
			}

			return p1;
		}
		public static void sqlite3SrcListAssignCursors(Parse pParse, SrcList pList)
		{
			int i = 0;
			SrcItem pItem;

			if ((pList) != null)
			{
				for (i = (int)(0), pItem = pList.a; (i) < (pList.nSrc); i++, pItem++)
				{
					if ((pItem.iCursor) >= (0))
						continue;
					pItem.iCursor = (int)(pParse.nTab++);
					if ((pItem.pSelect) != null)
					{
						sqlite3SrcListAssignCursors(pParse, pItem.pSelect.pSrc);
					}
				}
			}
		}
		public static void sqlite3SrcListDelete(sqlite3 db, SrcList pList)
		{
			int i = 0;
			SrcItem pItem;
			if ((pList) == (null))
				return;
			for (pItem = pList.a, i = (int)(0); (i) < (pList.nSrc); i++, pItem++)
			{
				if ((pItem.zDatabase) != null)
					sqlite3DbFreeNN(db, pItem.zDatabase);
				sqlite3DbFree(db, pItem.zName);
				if ((pItem.zAlias) != null)
					sqlite3DbFreeNN(db, pItem.zAlias);
				if ((pItem.fg.isIndexedBy) != 0)
					sqlite3DbFree(db, pItem.u1.zIndexedBy);
				if ((pItem.fg.isTabFunc) != 0)
					sqlite3ExprListDelete(db, pItem.u1.pFuncArg);
				sqlite3DeleteTable(db, pItem.pTab);
				if ((pItem.pSelect) != null)
					sqlite3SelectDelete(db, pItem.pSelect);
				if ((pItem.pOn) != null)
					sqlite3ExprDelete(db, pItem.pOn);
				if ((pItem.pUsing) != null)
					sqlite3IdListDelete(db, pItem.pUsing);
			}

			sqlite3DbFreeNN(db, pList);
		}
		public static SrcList sqlite3SrcListDup(sqlite3 db, SrcList p, int flags)
		{
			return null;
		}
		public static SrcList sqlite3SrcListEnlarge(Parse pParse, SrcList pSrc, int nExtra, int iStart)
		{
			int i = 0;




			if (((uint)(pSrc.nSrc) + nExtra) > (pSrc.nAlloc))
			{
				SrcList pNew;
				long nAlloc = (long)(2 * (long)(pSrc.nSrc) + nExtra);
				sqlite3 db = pParse.db;
				if ((pSrc.nSrc + nExtra) >= (200))
				{
					sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d", (int)(200));
					return null;
				}

				if ((nAlloc) > (200))
					nAlloc = (long)(200);
				pNew = sqlite3DbRealloc(db, pSrc, (ulong)(sizeof(SrcList) + (nAlloc - 1) * sizeof(SrcItem)));
				if ((pNew) == (null))
				{

					return null;
				}

				pSrc = pNew;
				pSrc.nAlloc = (uint)(nAlloc);
			}

			for (i = (int)(pSrc.nSrc - 1); (i) >= (iStart); i--)
			{
				pSrc.a[i + nExtra] = (SrcItem)(pSrc.a[i]);
			}

			pSrc.nSrc += (int)(nExtra);
			CRuntime.memset(pSrc.a[iStart], (int)(0), (ulong)(sizeof(SrcItem) * nExtra));
			for (i = (int)(iStart); (i) < (iStart + nExtra); i++)
			{
				pSrc.a[i].iCursor = (int)(-1);
			}

			return pSrc;
		}
		public static void sqlite3SrcListFuncArgs(Parse pParse, SrcList p, ExprList pList)
		{
			if ((p) != null)
			{
				SrcItem pItem = p.a[p.nSrc - 1];



				pItem.u1.pFuncArg = pList;
				pItem.fg.isTabFunc = (uint)(1);
			}
			else
			{
				sqlite3ExprListDelete(pParse.db, pList);
			}
		}
		public static void sqlite3SrcListIndexedBy(Parse pParse, SrcList p, Token* pIndexedBy)
		{

			if (((p) != null) && ((pIndexedBy->n) > (0)))
			{
				SrcItem pItem;

				pItem = p.a[p.nSrc - 1];



				if (((pIndexedBy->n) == (1)) && (pIndexedBy->z == null))
				{
					pItem.fg.notIndexed = (uint)(1);
				}
				else
				{
					pItem.u1.zIndexedBy = sqlite3NameFromToken(pParse.db, pIndexedBy);
					pItem.fg.isIndexedBy = (uint)(1);

				}
			}
		}
		public static Table sqlite3SrcListLookup(Parse pParse, SrcList pSrc)
		{
			SrcItem pItem = pSrc.a;
			Table pTab;

			pTab = sqlite3LocateTableItem(pParse, (uint)(0), pItem);
			sqlite3DeleteTable(pParse.db, pItem.pTab);
			pItem.pTab = pTab;
			if ((pTab) != null)
			{
				pTab.nTabRef++;
				if (((pItem.fg.isIndexedBy) != 0) && ((sqlite3IndexedByLookup(pParse, pItem)) != 0))
				{
					pTab = null;
				}
			}

			return pTab;
		}
		public static void sqlite3SrcListShiftJoinType(SrcList p)
		{
			if ((p) != null)
			{
				int i = 0;
				for (i = (int)(p.nSrc - 1); (i) > (0); i--)
				{
					p.a[i].fg.jointype = (byte)(p.a[i - 1].fg.jointype);
				}

				p.a[0].fg.jointype = (byte)(0);
			}
		}
		public static void sqlite3StartTable(Parse pParse, Token* pName1, Token* pName2, int isTemp, int isView, int isVirtual, int noErr)
		{
			Table pTable;
			sbyte* zName = null;
			sqlite3 db = pParse.db;
			Vdbe v;
			int iDb = 0;
			Token* pName;
			if (((db.init.busy) != 0) && ((db.init.newTnum) == (1)))
			{
				iDb = (int)(db.init.iDb);
				zName = sqlite3DbStrDup(db, (((!0) != 0) && ((iDb) == (1)) ? "sqlite_temp_master" : "sqlite_master"));
				pName = pName1;
			}
			else
			{
				iDb = (int)(sqlite3TwoPartName(pParse, pName1, pName2, &pName));
				if ((iDb) < (0))
					return;
				if ((((0 == 0) && ((isTemp) != 0)) && ((pName2->n) > (0))) && (iDb != 1))
				{
					sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
					return;
				}

				if ((0 == 0) && ((isTemp) != 0))
					iDb = (int)(1);
				zName = sqlite3NameFromToken(db, pName);
				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenMap(pParse, (void*)(zName), pName);
				}
			}

			pParse.sNameToken = (Token)(*pName);
			if ((zName) == (null))
				return;
			if ((sqlite3CheckObjectName(pParse, zName, (isView) != 0 ? "view" : "table", zName)) != 0)
			{
				goto begin_table_error;
			}

			if ((db.init.iDb) == (1))
				isTemp = (int)(1);


			{
				sbyte* zDb = db.aDb[iDb].zDbSName;
				if ((sqlite3AuthCheck(pParse, (int)(18), (((!0) != 0) && ((isTemp) == (1)) ? "sqlite_temp_master" : "sqlite_master"), null, zDb)) != 0)
				{
					goto begin_table_error;
				}

				if ((isVirtual == 0) && ((sqlite3AuthCheck(pParse, (int)(sqlite3StartTable_aCode[isTemp + 2 * isView]), zName, null, zDb)) != 0))
				{
					goto begin_table_error;
				}
			}

			if (!(pParse.eParseMode != 0))
			{
				sbyte* zDb = db.aDb[iDb].zDbSName;
				if (0 != sqlite3ReadSchema(pParse))
				{
					goto begin_table_error;
				}

				pTable = sqlite3FindTable(db, zName, zDb);
				if ((pTable) != null)
				{
					if (noErr == 0)
					{
						sqlite3ErrorMsg(pParse, "%s %T already exists", ((((pTable).eTabType) == (2)) ? "view" : "table"), pName);
					}
					else
					{

						sqlite3CodeVerifySchema(pParse, (int)(iDb));
						sqlite3ForceNotReadOnly(pParse);
					}

					goto begin_table_error;
				}

				if (sqlite3FindIndex(db, zName, zDb) != null)
				{
					sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
					goto begin_table_error;
				}
			}

			pTable = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
			if ((pTable) == (null))
			{

				pParse.rc = (int)(7);
				pParse.nErr++;
				goto begin_table_error;
			}

			pTable.zName = zName;
			pTable.iPKey = (short)(-1);
			pTable.pSchema = db.aDb[iDb].pSchema;
			pTable.nTabRef = (uint)(1);
			pTable.nRowLogEst = (short)(200);


			pParse.pNewTable = pTable;
			if ((db.init.busy == 0) && ((v = sqlite3GetVdbe(pParse)) != null))
			{
				int addr1 = 0;
				int fileFormat = 0;
				int reg1 = 0;
				int reg2 = 0;
				int reg3 = 0;
				sqlite3BeginWriteOperation(pParse, (int)(1), (int)(iDb));
				if ((isVirtual) != 0)
				{
					sqlite3VdbeAddOp0(v, (int)(169));
				}

				reg1 = (int)(pParse.regRowid = (int)(++pParse.nMem));
				reg2 = (int)(pParse.regRoot = (int)(++pParse.nMem));
				reg3 = (int)(++pParse.nMem);
				sqlite3VdbeAddOp3(v, (int)(98), (int)(iDb), (int)(reg3), (int)(2));
				sqlite3VdbeUsesBtree(v, (int)(iDb));
				addr1 = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(reg3)));
				fileFormat = (int)((db.flags & 0x00000002) != 0 ? 1 : 4);
				sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(2), (int)(fileFormat));
				sqlite3VdbeAddOp3(v, (int)(99), (int)(iDb), (int)(5), (int)((db).enc));
				sqlite3VdbeJumpHere(v, (int)(addr1));
				if (((isView) != 0) || ((isVirtual) != 0))
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(reg2));
				}
				else
				{

					pParse.u1.addrCrTab = (int)(sqlite3VdbeAddOp3(v, (int)(146), (int)(iDb), (int)(reg2), (int)(1)));
				}

				sqlite3OpenSchemaTable(pParse, (int)(iDb));
				sqlite3VdbeAddOp2(v, (int)(126), (int)(0), (int)(reg1));
				sqlite3VdbeAddOp4(v, (int)(76), (int)(6), (int)(reg3), (int)(0), sqlite3StartTable_nullRow, (int)(-1));
				sqlite3VdbeAddOp3(v, (int)(127), (int)(0), (int)(reg3), (int)(reg1));
				sqlite3VdbeChangeP5(v, (ushort)(0x08));
				sqlite3VdbeAddOp0(v, (int)(121));
			}

			return;
		begin_table_error:
			; pParse.checkSchema = (byte)(1);
			sqlite3DbFree(db, zName);
			return;
		}
		public static void sqlite3StatusDown(int op, int N)
		{




			sqlite3Stat.nowValue[op] -= (long)(N);
		}
		public static void sqlite3StatusHighwater(int op, int X)
		{
			long newValue = 0;

			newValue = ((long)(X));




			if ((newValue) > (sqlite3Stat.mxValue[op]))
			{
				sqlite3Stat.mxValue[op] = (long)(newValue);
			}
		}
		public static void sqlite3StatusUp(int op, int N)
		{



			sqlite3Stat.nowValue[op] += (long)(N);
			if ((sqlite3Stat.nowValue[op]) > (sqlite3Stat.mxValue[op]))
			{
				sqlite3Stat.mxValue[op] = (long)(sqlite3Stat.nowValue[op]);
			}
		}
		public static long sqlite3StatusValue(int op)
		{



			return (long)(sqlite3Stat.nowValue[op]);
		}
		public static int sqlite3Step(Vdbe p)
		{
			sqlite3 db;
			int rc = 0;

			if (p.iVdbeMagic != 0x2df20da3)
			{
				sqlite3_reset((sqlite3_stmt*)(p));
			}

			db = p.db;
			if ((db.mallocFailed) != 0)
			{
				p.rc = (int)(7);
				return (int)(7);
			}

			if (((p.pc) < (0)) && ((p.expired) != 0))
			{
				p.rc = (int)(17);
				rc = (int)(1);
				if ((p.prepFlags & 0x80) != 0)
				{
					rc = (int)(sqlite3VdbeTransferError(p));
				}

				goto end_of_step;
			}

			if ((p.pc) < (0))
			{
				if ((db.nVdbeActive) == (0))
				{
					(0);
				}


				if ((((db.mTrace & (0x02 | 0x80)) != 0) && (db.init.busy == 0)) && ((p.zSql) != null))
				{
					sqlite3OsCurrentTimeInt64(db.pVfs, &p.startTime);
				}
				else
				{

				}

				db.nVdbeActive++;
				if ((p.readOnly) == (0))
					db.nVdbeWrite++;
				if ((p.bIsReader) != 0)
					db.nVdbeRead++;
				p.pc = (int)(0);
			}

			if ((p.explain) != 0)
			{
				rc = (int)(sqlite3VdbeList(p));
			}
			else
			{
				db.nVdbeExec++;
				rc = (int)(sqlite3VdbeExec(p));
				db.nVdbeExec--;
			}

			if (rc != 100)
			{
				if (((p).startTime) > (0))
				{
					invokeProfileCallback(db, p);
				}

				if (((rc) == (101)) && ((db.autoCommit) != 0))
				{

					p.rc = (int)(doWalCallbacks(db));
					if (p.rc != 0)
					{
						rc = (int)(1);
					}
				}
				else if ((rc != 101) && ((p.prepFlags & 0x80) != 0))
				{
					rc = (int)(sqlite3VdbeTransferError(p));
				}
			}

			db.errCode = (int)(rc);
			if ((7) == (sqlite3ApiExit(p.db, (int)(p.rc))))
			{
				p.rc = (int)(7);
				if ((p.prepFlags & 0x80) != 0)
					rc = (int)(p.rc);
			}

		end_of_step:
			; ((void)(0));
			return (int)(rc & db.errMask);
		}
		public static long sqlite3StmtCurrentTime(sqlite3_context p)
		{
			int rc = 0;
			long* piTime = &p.pVdbe.iCurrentTime;

			if ((*piTime) == (0))
			{
				rc = (int)(sqlite3OsCurrentTimeInt64(p.pOut.db.pVfs, piTime));
				if ((rc) != 0)
					*piTime = (long)(0);
			}

			return (long)(*piTime);
		}
		public static short sqlite3StorageColumnToTable(Table pTab, short iCol)
		{
			if ((pTab.tabFlags & 0x00000020) != 0)
			{
				int i = 0;
				for (i = (int)(0); (i) <= (iCol); i++)
				{
					if ((pTab.aCol[i].colFlags & 0x0020) != 0)
						iCol++;
				}
			}

			return (short)(iCol);
		}
		public static int sqlite3StrAccumEnlarge(sqlite3_str p, int N)
		{
			sbyte* zNew;

			if ((p.accError) != 0)
			{
				return (int)(0);
			}

			if ((p.mxAlloc) == (0))
			{
				sqlite3StrAccumSetError(p, (byte)(18));
				return (int)(p.nAlloc - p.nChar - 1);
			}
			else
			{
				sbyte* zOld = (((p).printfFlags & 0x04) != 0) ? p.zText : null;
				long szNew = (long)(p.nChar);
				szNew += (long)((long)(N) + 1);
				if ((szNew + p.nChar) <= (p.mxAlloc))
				{
					szNew += (long)(p.nChar);
				}

				if ((szNew) > (p.mxAlloc))
				{
					sqlite3_str_reset(p);
					sqlite3StrAccumSetError(p, (byte)(18));
					return (int)(0);
				}
				else
				{
					p.nAlloc = (uint)((int)(szNew));
				}

				if ((p.db) != null)
				{
					zNew = sqlite3DbRealloc(p.db, zOld, (ulong)(p.nAlloc));
				}
				else
				{
					zNew = sqlite3Realloc(zOld, (ulong)(p.nAlloc));
				}

				if ((zNew) != null)
				{

					if ((!(((p).printfFlags & 0x04) != 0)) && ((p.nChar) > (0)))
						CRuntime.memcpy(zNew, p.zText, (ulong)(p.nChar));
					p.zText = zNew;
					p.nAlloc = (uint)(sqlite3DbMallocSize(p.db, zNew));
					p.printfFlags |= (byte)(0x04);
				}
				else
				{
					sqlite3_str_reset(p);
					sqlite3StrAccumSetError(p, (byte)(7));
					return (int)(0);
				}
			}

			return (int)(N);
		}
		public static sbyte* sqlite3StrAccumFinish(sqlite3_str p)
		{
			if ((p.zText) != null)
			{
				p.zText[p.nChar] = (sbyte)(0);
				if (((p.mxAlloc) > (0)) && (!(((p).printfFlags & 0x04) != 0)))
				{
					return strAccumFinishRealloc(p);
				}
			}

			return p.zText;
		}
		public static void sqlite3StrAccumInit(sqlite3_str p, sqlite3 db, sbyte* zBase, int n, int mx)
		{
			p.zText = zBase;
			p.db = db;
			p.nAlloc = (uint)(n);
			p.mxAlloc = (uint)(mx);
			p.nChar = (uint)(0);
			p.accError = (byte)(0);
			p.printfFlags = (byte)(0);
		}
		public static void sqlite3StrAccumSetError(sqlite3_str p, byte eError)
		{

			p.accError = (byte)(eError);
			if ((p.mxAlloc) != 0)
				sqlite3_str_reset(p);
			if ((eError) == (18))
				sqlite3ErrorToParser(p.db, (int)(eError));
		}
		public static int sqlite3StrICmp(sbyte* zLeft, sbyte* zRight)
		{
			byte* a; byte* b;
			int c = 0; int x = 0;
			a = (byte*)(zLeft);
			b = (byte*)(zRight);
			for (; ; )
			{
				c = (int)(*a);
				x = (int)(*b);
				if ((c) == (x))
				{
					if ((c) == (0))
						break;
				}
				else
				{
					c = (int)((int)(sqlite3UpperToLower[c]) - (int)(sqlite3UpperToLower[x]));
					if ((c) != 0)
						break;
				}

				a++;
				b++;
			}

			return (int)(c);
		}
		public static byte sqlite3StrIHash(sbyte* z)
		{
			byte h = (byte)(0);
			if ((z) == (null))
				return (byte)(0);
			while ((z[0]) != 0)
			{
				h += (byte)(sqlite3UpperToLower[(byte)(z[0])]);
				z++;
			}

			return (byte)(h);
		}
		public static void sqlite3StringToId(Expr p)
		{
			if ((p.op) == (117))
			{
				p.op = (byte)(59);
			}
			else if (((p.op) == (113)) && ((p.pLeft.op) == (117)))
			{
				p.pLeft.op = (byte)(59);
			}
		}
		public static int sqlite3Strlen30(sbyte* z)
		{
			if ((z) == (null))
				return (int)(0);
			return (int)(0x3fffffff & (int)(CRuntime.strlen(z)));
		}
		public static int sqlite3SubInt64(long* pA, long iB)
		{
			if ((iB) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
			{
				if ((*pA) >= (0))
					return (int)(1);
				*pA -= (long)(iB);
				return (int)(0);
			}
			else
			{
				return (int)(sqlite3AddInt64(pA, (long)(-iB)));
			}
		}
		public static void sqlite3SubselectError(Parse pParse, int nActual, int nExpect)
		{
			if ((pParse.nErr) == (0))
			{
				sbyte* zFmt = "sub-select returns %d columns - expected %d";
				sqlite3ErrorMsg(pParse, zFmt, (int)(nActual), (int)(nExpect));
			}
		}
		public static void sqlite3SystemError(sqlite3 db, int rc)
		{
			if ((rc) == (10 | (12 << 8)))
				return;
			rc &= (int)(0xff);
			if (((rc) == (14)) || ((rc) == (10)))
			{
				db.iSysErrno = (int)(sqlite3OsGetLastError(db.pVfs));
			}
		}
		public static void sqlite3TableAffinity(Vdbe v, Table pTab, int iReg)
		{
			int i = 0; int j = 0;
			sbyte* zColAff;
			if ((pTab.tabFlags & 0x00010000) != 0)
			{
				if ((iReg) == (0))
				{
					VdbeOp* pPrev;
					sqlite3VdbeAppendP4(v, pTab, (int)(-6));
					pPrev = sqlite3VdbeGetOp(v, (int)(-1));


					pPrev->opcode = (byte)(94);
					sqlite3VdbeAddOp3(v, (int)(96), (int)(pPrev->p1), (int)(pPrev->p2), (int)(pPrev->p3));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(94), (int)(iReg), (int)(pTab.nNVCol));
					sqlite3VdbeAppendP4(v, pTab, (int)(-6));
				}

				return;
			}

			zColAff = pTab.zColAff;
			if ((zColAff) == (null))
			{
				sqlite3 db = sqlite3VdbeDb(v);
				zColAff = (sbyte*)(sqlite3DbMallocRaw(null, (ulong)(pTab.nCol + 1)));
				if (zColAff == null)
				{
					sqlite3OomFault(db);
					return;
				}

				for (i = (int)(j = (int)(0)); (i) < (pTab.nCol); i++)
				{

					if ((pTab.aCol[i].colFlags & 0x0020) == (0))
					{
						zColAff[j++] = (sbyte)(pTab.aCol[i].affinity);
					}
				}

				do
				{
					zColAff[j--] = (sbyte)(0);
				}
				while (((j) >= (0)) && ((zColAff[j]) <= (0x41)));
				pTab.zColAff = zColAff;
			}


			i = (int)(CRuntime.strlen(zColAff) & 0x3fffffff);
			if ((i) != 0)
			{
				if ((iReg) != 0)
				{
					sqlite3VdbeAddOp4(v, (int)(95), (int)(iReg), (int)(i), (int)(0), zColAff, (int)(i));
				}
				else
				{

					sqlite3VdbeChangeP4(v, (int)(-1), zColAff, (int)(i));
				}
			}
		}
		public static sbyte sqlite3TableColumnAffinity(Table pTab, int iCol)
		{
			if (((iCol) < (0)) || ((iCol) >= (pTab.nCol)))
				return (sbyte)(0x44);
			return (sbyte)(pTab.aCol[iCol].affinity);
		}
		public static short sqlite3TableColumnToIndex(Index pIdx, short iCol)
		{
			int i = 0;
			for (i = (int)(0); (i) < (pIdx.nColumn); i++)
			{
				if ((iCol) == (pIdx.aiColumn[i]))
					return (short)(i);
			}

			return (short)(-1);
		}
		public static short sqlite3TableColumnToStorage(Table pTab, short iCol)
		{
			int i = 0;
			short n = 0;

			if (((pTab.tabFlags & 0x00000020) == (0)) || ((iCol) < (0)))
				return (short)(iCol);
			for (i = (int)(0), n = (short)(0); (i) < (iCol); i++)
			{
				if ((pTab.aCol[i].colFlags & 0x0020) == (0))
					n++;
			}

			if ((pTab.aCol[i].colFlags & 0x0020) != 0)
			{
				return (short)(pTab.nNVCol + i - n);
			}
			else
			{
				return (short)(n);
			}
		}
		public static void sqlite3TableLock(Parse pParse, int iDb, uint iTab, byte isWriteLock, sbyte* zName)
		{
			if ((iDb) == (1))
				return;
			if (sqlite3BtreeSharable(pParse.db.aDb[iDb].pBt) == 0)
				return;
			lockTable(pParse, (int)(iDb), (uint)(iTab), (byte)(isWriteLock), zName);
		}
		public static int sqlite3TempInMemory(sqlite3 db)
		{
			return (((db.temp_store) == (2)) ? 1 : 0);
		}
		public static int sqlite3TestExtInit(sqlite3 db)
		{
			(void)(db);
			return (int)(sqlite3FaultSim((int)(500)));
		}
		public static int sqlite3ThreadCreate(SQLiteThread ppThread, delegate74 xTask, void* pIn)
		{
			SQLiteThread p;


			ppThread = null;
			p = sqlite3Malloc((ulong)(sizeof(SQLiteThread)));
			if ((p) == (null))
				return (int)(7);
			if (((sqlite3Config.bCoreMutex) == (0)) || ((sqlite3FaultSim((int)(200))) != 0))
			{
				CRuntime.memset(p, (int)(0), (ulong)(sizeof(SQLiteThread)));
			}
			else
			{
				p.xTask = xTask;
				p.pIn = pIn;
				p.tid = (void*)(_beginthreadex(null, (uint)(0), sqlite3ThreadProc, p, (uint)(0), &p.id));
				if ((p.tid) == (null))
				{
					CRuntime.memset(p, (int)(0), (ulong)(sizeof(SQLiteThread)));
				}
			}

			if ((p.xTask) == (null))
			{
				p.id = (uint)(GetCurrentThreadId());
				p.pResult = xTask(pIn);
			}

			ppThread = p;
			return (int)(0);
		}
		public static int sqlite3ThreadJoin(SQLiteThread p, void** ppOut)
		{
			uint rc = 0;
			int bRc = 0;

			if (((p) == (null)))
				return (int)(7);
			if ((p.xTask) == (null))
			{
				rc = (uint)(((uint)(0x00000000L)) + 0);

			}
			else
			{

				rc = (uint)(sqlite3Win32Wait(p.tid));

				bRc = (int)(CloseHandle(p.tid));

			}

			if ((rc) == (((uint)(0x00000000L)) + 0))
				*ppOut = p.pResult;
			sqlite3_free(p);
			return (int)(((rc) == (((uint)(0x00000000L)) + 0)) ? 0 : 1);
		}
		public static uint sqlite3ThreadProc(void* pArg)
		{
			SQLiteThread p = (SQLiteThread)(pArg);


			p.pResult = p.xTask(p.pIn);
			_endthreadex((uint)(0));
			return (uint)(0);
		}
		public static void sqlite3TokenInit(Token* p, sbyte* z)
		{
			p->z = z;
			p->n = (uint)(sqlite3Strlen30(z));
		}
		public static int sqlite3TransferBindings(sqlite3_stmt* pFromStmt, sqlite3_stmt* pToStmt)
		{
			Vdbe pFrom = (Vdbe)(pFromStmt);
			Vdbe pTo = (Vdbe)(pToStmt);
			int i = 0;


			sqlite3_mutex_enter(pTo.db.mutex);
			for (i = (int)(0); (i) < (pFrom.nVar); i++)
			{
				sqlite3VdbeMemMove(pTo.aVar[i], pFrom.aVar[i]);
			}

			sqlite3_mutex_leave(pTo.db.mutex);
			return (int)(0);
		}
		public static uint sqlite3TriggerColmask(Parse pParse, Trigger pTrigger, ExprList pChanges, int isNew, int tr_tm, Table pTab, int orconf)
		{
			int op = (int)(pChanges ? 129 : 128);
			uint mask = (uint)(0);
			Trigger p;

			for (p = pTrigger; p; p = p.pNext)
			{
				if ((((p.op) == (op)) && ((tr_tm & p.tr_tm) != 0)) && ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
				{
					if ((p.bReturning) != 0)
					{
						mask = (uint)(0xffffffff);
					}
					else
					{
						TriggerPrg pPrg;
						pPrg = getRowTrigger(pParse, p, pTab, (int)(orconf));
						if ((pPrg) != null)
						{
							mask |= (uint)(pPrg.aColmask[isNew]);
						}
					}
				}
			}

			return (uint)(mask);
		}
		public static TriggerStep sqlite3TriggerDeleteStep(Parse pParse, Token* pTableName, Expr pWhere, sbyte* zStart, sbyte* zEnd)
		{
			sqlite3 db = pParse.db;
			TriggerStep pTriggerStep;
			pTriggerStep = triggerStepAllocate(pParse, (byte)(128), pTableName, zStart, zEnd);
			if ((pTriggerStep) != null)
			{
				if (((pParse.eParseMode) >= (2)))
				{
					pTriggerStep.pWhere = pWhere;
					pWhere = null;
				}
				else
				{
					pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001));
				}

				pTriggerStep.orconf = (byte)(11);
			}

			sqlite3ExprDelete(db, pWhere);
			return pTriggerStep;
		}
		public static TriggerStep sqlite3TriggerInsertStep(Parse pParse, Token* pTableName, IdList* pColumn, Select pSelect, byte orconf, Upsert pUpsert, sbyte* zStart, sbyte* zEnd)
		{
			sqlite3 db = pParse.db;
			TriggerStep pTriggerStep;

			pTriggerStep = triggerStepAllocate(pParse, (byte)(127), pTableName, zStart, zEnd);
			if ((pTriggerStep) != null)
			{
				if (((pParse.eParseMode) >= (2)))
				{
					pTriggerStep.pSelect = pSelect;
					pSelect = null;
				}
				else
				{
					pTriggerStep.pSelect = sqlite3SelectDup(db, pSelect, (int)(0x0001));
				}

				pTriggerStep.pIdList = pColumn;
				pTriggerStep.pUpsert = pUpsert;
				pTriggerStep.orconf = (byte)(orconf);
				if ((pUpsert) != null)
				{
					sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget);
				}
			}
			else
			{
				sqlite3IdListDelete(db, pColumn);
				sqlite3UpsertDelete(db, pUpsert);
			}

			sqlite3SelectDelete(db, pSelect);
			return pTriggerStep;
		}
		public static Trigger sqlite3TriggerList(Parse pParse, Table pTab)
		{
			Schema pTmpSchema;
			Trigger pList;
			HashElem* p;
			if ((pParse.disableTriggers) != 0)
			{
				return null;
			}

			pTmpSchema = pParse.db.aDb[1].pSchema;
			p = ((&pTmpSchema.trigHash)->first);
			pList = pTab.pTrigger;
			while ((p) != null)
			{
				Trigger pTrig = (Trigger)((p)->data);
				if (((((pTrig.pTabSchema) == (pTab.pSchema)) && ((pTrig.table) != null)) && ((0) == (sqlite3StrICmp(pTrig.table, pTab.zName)))) && (pTrig.pTabSchema != pTmpSchema))
				{
					pTrig.pNext = pList;
					pList = pTrig;
				}
				else if (((pTrig.op) == (150)) && ((pParse.db.pVtabCtx) == (null)))
				{


					pTrig.table = pTab.zName;
					pTrig.pTabSchema = pTab.pSchema;
					pTrig.pNext = pList;
					pList = pTrig;
				}

				p = ((p)->next);
			}

			return pList;
		}
		public static TriggerStep sqlite3TriggerSelectStep(sqlite3 db, Select pSelect, sbyte* zStart, sbyte* zEnd)
		{
			TriggerStep pTriggerStep = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerStep)));
			if ((pTriggerStep) == (null))
			{
				sqlite3SelectDelete(db, pSelect);
				return null;
			}

			pTriggerStep.op = (byte)(138);
			pTriggerStep.pSelect = pSelect;
			pTriggerStep.orconf = (byte)(11);
			pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd);
			return pTriggerStep;
		}
		public static Trigger sqlite3TriggersExist(Parse pParse, Table pTab, int op, ExprList pChanges, int* pMask)
		{
			int mask = (int)(0);
			Trigger pList = null;
			Trigger p;
			pList = sqlite3TriggerList(pParse, pTab);

			if (pList != null)
			{
				p = pList;
				if (((pParse.db.flags & 0x00040000) == (0)) && (pTab.pTrigger != null))
				{
					if ((pList) == (pTab.pTrigger))
					{
						pList = null;
						goto exit_triggers_exist;
					}

					while (((p.pNext) != null) && (p.pNext != pTab.pTrigger))
					{
						p = p.pNext;
					}

					p.pNext = null;
					p = pList;
				}

				do
				{
					if (((p.op) == (op)) && ((checkColumnOverlap(p.pColumns, pChanges)) != 0))
					{
						mask |= (int)(p.tr_tm);
					}
					else if ((p.op) == (150))
					{

						p.op = (byte)(op);
						if ((((pTab).eTabType) == (1)))
						{
							if (op != 127)
							{
								sqlite3ErrorMsg(pParse, "%s RETURNING is not available on virtual tables", (op) == (128) ? "DELETE" : "UPDATE");
							}

							p.tr_tm = (byte)(1);
						}
						else
						{
							p.tr_tm = (byte)(2);
						}

						mask |= (int)(p.tr_tm);
					}
					else if (((((p.bReturning) != 0) && ((p.op) == (127))) && ((op) == (129))) && (((pParse).pToplevel) == (null)))
					{
						mask |= (int)(p.tr_tm);
					}

					p = p.pNext;
				}
				while ((p) != null);
			}

		exit_triggers_exist:
			; if ((pMask) != null) { *pMask = (int)(mask); }
			return ((mask) != 0 ? pList : null);
		}
		public static SrcList sqlite3TriggerStepSrc(Parse pParse, TriggerStep pStep)
		{
			sqlite3 db = pParse.db;
			SrcList pSrc;
			sbyte* zName = sqlite3DbStrDup(db, pStep.zTarget);
			pSrc = sqlite3SrcListAppend(pParse, null, null, null);


			if ((pSrc) != null)
			{
				Schema pSchema = pStep.pTrig.pSchema;
				pSrc.a[0].zName = zName;
				if (pSchema != db.aDb[1].pSchema)
				{
					pSrc.a[0].pSchema = pSchema;
				}

				if ((pStep.pFrom) != null)
				{
					SrcList pDup = sqlite3SrcListDup(db, pStep.pFrom, (int)(0));
					pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);
				}
			}
			else
			{
				sqlite3DbFree(db, zName);
			}

			return pSrc;
		}
		public static TriggerStep sqlite3TriggerUpdateStep(Parse pParse, Token* pTableName, SrcList pFrom, ExprList pEList, Expr pWhere, byte orconf, sbyte* zStart, sbyte* zEnd)
		{
			sqlite3 db = pParse.db;
			TriggerStep pTriggerStep;
			pTriggerStep = triggerStepAllocate(pParse, (byte)(129), pTableName, zStart, zEnd);
			if ((pTriggerStep) != null)
			{
				if (((pParse.eParseMode) >= (2)))
				{
					pTriggerStep.pExprList = pEList;
					pTriggerStep.pWhere = pWhere;
					pTriggerStep.pFrom = pFrom;
					pEList = null;
					pWhere = null;
					pFrom = null;
				}
				else
				{
					pTriggerStep.pExprList = sqlite3ExprListDup(db, pEList, (int)(0x0001));
					pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, (int)(0x0001));
					pTriggerStep.pFrom = sqlite3SrcListDup(db, pFrom, (int)(0x0001));
				}

				pTriggerStep.orconf = (byte)(orconf);
			}

			sqlite3ExprListDelete(db, pEList);
			sqlite3ExprDelete(db, pWhere);
			sqlite3SrcListDelete(db, pFrom);
			return pTriggerStep;
		}
		public static int sqlite3TwoPartName(Parse pParse, Token* pName1, Token* pName2, Token** pUnqual)
		{
			int iDb = 0;
			sqlite3 db = pParse.db;

			if ((pName2->n) > (0))
			{
				if ((db.init.busy) != 0)
				{
					sqlite3ErrorMsg(pParse, "corrupt database");
					return (int)(-1);
				}

				*pUnqual = pName2;
				iDb = (int)(sqlite3FindDb(db, pName1));
				if ((iDb) < (0))
				{
					sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
					return (int)(-1);
				}
			}
			else
			{

				iDb = (int)(db.init.iDb);
				*pUnqual = pName1;
			}

			return (int)(iDb);
		}
		public static void sqlite3UniqueConstraint(Parse pParse, int onError, Index pIdx)
		{
			sbyte* zErr;
			int j = 0;
			sqlite3_str errMsg = new sqlite3_str();
			Table pTab = pIdx.pTable;
			sqlite3StrAccumInit(errMsg, pParse.db, null, (int)(0), (int)(pParse.db.aLimit[0]));
			if ((pIdx.aColExpr) != null)
			{
				sqlite3_str_appendf(errMsg, "index '%q'", pIdx.zName);
			}
			else
			{
				for (j = (int)(0); (j) < (pIdx.nKeyCol); j++)
				{
					sbyte* zCol;

					zCol = pTab.aCol[pIdx.aiColumn[j]].zCnName;
					if ((j) != 0)
						sqlite3_str_append(errMsg, ", ", (int)(2));
					sqlite3_str_appendall(errMsg, pTab.zName);
					sqlite3_str_append(errMsg, ".", (int)(1));
					sqlite3_str_appendall(errMsg, zCol);
				}
			}

			zErr = sqlite3StrAccumFinish(errMsg);
			sqlite3HaltConstraint(pParse, (int)((((pIdx).idxType) == (2)) ? (19 | (6 << 8)) : (19 | (8 << 8))), (int)(onError), zErr, (sbyte)(-7), (byte)(2));
		}
		public static void sqlite3UnlinkAndDeleteIndex(sqlite3 db, int iDb, sbyte* zIdxName)
		{
			Index pIndex;
			Hash* pHash;

			pHash = &db.aDb[iDb].pSchema.idxHash;
			pIndex = sqlite3HashInsert(pHash, zIdxName, null);
			if ((pIndex) != null)
			{
				if ((pIndex.pTable.pIndex) == (pIndex))
				{
					pIndex.pTable.pIndex = pIndex.pNext;
				}
				else
				{
					Index p;
					p = pIndex.pTable.pIndex;
					while (((p) != null) && (p.pNext != pIndex))
					{
						p = p.pNext;
					}

					if ((((p) != null) && ((p.pNext) == (pIndex))))
					{
						p.pNext = pIndex.pNext;
					}
				}

				sqlite3FreeIndex(db, pIndex);
			}

			db.mDbFlags |= (uint)(0x0001);
		}
		public static void sqlite3UnlinkAndDeleteTable(sqlite3 db, int iDb, sbyte* zTabName)
		{
			Table p;
			Db pDb;




			pDb = db.aDb[iDb];
			p = sqlite3HashInsert(&pDb.pSchema.tblHash, zTabName, null);
			sqlite3DeleteTable(db, p);
			db.mDbFlags |= (uint)(0x0001);
		}
		public static void sqlite3UnlinkAndDeleteTrigger(sqlite3 db, int iDb, sbyte* zName)
		{
			Trigger pTrigger;
			Hash* pHash;

			pHash = &(db.aDb[iDb].pSchema.trigHash);
			pTrigger = sqlite3HashInsert(pHash, zName, null);
			if ((pTrigger) != null)
			{
				if ((pTrigger.pSchema) == (pTrigger.pTabSchema))
				{
					Table pTab = tableOfTrigger(pTrigger);
					if ((pTab) != null)
					{
						Trigger pp;
						for (pp = pTab.pTrigger; pp; pp = ((pp).pNext))
						{
							if ((pp) == (pTrigger))
							{
								pp = (pp).pNext;
								break;
							}
						}
					}
				}

				sqlite3DeleteTrigger(db, pTrigger);
				db.mDbFlags |= (uint)(0x0001);
			}
		}
		public static void sqlite3Update(Parse pParse, SrcList pTabList, ExprList pChanges, Expr pWhere, int onError, ExprList pOrderBy, Expr pLimit, Upsert pUpsert)
		{
			int i = 0; int j = 0; int k = 0;
			Table pTab;
			int addrTop = (int)(0);
			WhereInfo pWInfo = null;
			Vdbe v;
			Index pIdx;
			Index pPk;
			int nIdx = 0;
			int nAllIdx = 0;
			int iBaseCur = 0;
			int iDataCur = 0;
			int iIdxCur = 0;
			sqlite3 db;
			int* aRegIdx = null;
			int* aXRef = null;
			byte* aToOpen;
			byte chngPk = 0;
			byte chngRowid = 0;
			byte chngKey = 0;
			Expr pRowidExpr = null;
			int iRowidExpr = (int)(-1);
			AuthContext sContext = new AuthContext();
			NameContext sNC = new NameContext();
			int iDb = 0;
			int eOnePass = 0;
			int hasFK = 0;
			int labelBreak = 0;
			int labelContinue = 0;
			int flags = 0;
			int isView = 0;
			Trigger pTrigger;
			int tmask = 0;
			int newmask = 0;
			int iEph = (int)(0);
			int nKey = (int)(0);
			int* aiCurOnePass = stackalloc int[2];
			int addrOpen = (int)(0);
			int iPk = (int)(0);
			short nPk = (short)(0);
			int bReplace = (int)(0);
			int bFinishSeek = (int)(1);
			int nChangeFrom = (int)(0);
			int regRowCount = (int)(0);
			int regOldRowid = (int)(0);
			int regNewRowid = (int)(0);
			int regNew = (int)(0);
			int regOld = (int)(0);
			int regRowSet = (int)(0);
			int regKey = (int)(0);
			CRuntime.memset(sContext, (int)(0), (ulong)(sizeof(AuthContext)));
			db = pParse.db;

			if ((pParse.nErr) != 0)
			{
				goto update_cleanup;
			}


			pTab = sqlite3SrcListLookup(pParse, pTabList);
			if ((pTab) == (null))
				goto update_cleanup;
			iDb = (int)(sqlite3SchemaToIndex(pParse.db, pTab.pSchema));
			pTrigger = sqlite3TriggersExist(pParse, pTab, (int)(129), pChanges, &tmask);
			isView = (int)(((pTab).eTabType) == (2) ? 1 : 0);

			nChangeFrom = (int)(((pTabList.nSrc) > (1)) ? pChanges.nExpr : 0);

			if ((sqlite3ViewGetColumnNames(pParse, pTab)) != 0)
			{
				goto update_cleanup;
			}

			if ((sqlite3IsReadOnly(pParse, pTab, (int)(tmask))) != 0)
			{
				goto update_cleanup;
			}

			iBaseCur = (int)(iDataCur = (int)(pParse.nTab++));
			iIdxCur = (int)(iDataCur + 1);
			pPk = (((pTab).tabFlags & 0x00000080) == (0)) ? null : sqlite3PrimaryKeyIndex(pTab);
			for (nIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nIdx++)
			{
				if ((pPk) == (pIdx))
				{
					iDataCur = (int)(pParse.nTab);
				}

				pParse.nTab++;
			}

			if ((pUpsert) != null)
			{
				iDataCur = (int)(pUpsert.iDataCur);
				iIdxCur = (int)(pUpsert.iIdxCur);
				pParse.nTab = (int)(iBaseCur);
			}

			pTabList.a[0].iCursor = (int)(iDataCur);
			aXRef = sqlite3DbMallocRawNN(db, (ulong)(sizeof(int) * (pTab.nCol + nIdx + 1) + nIdx + 2));
			if ((aXRef) == (null))
				goto update_cleanup;
			aRegIdx = aXRef + pTab.nCol;
			aToOpen = (byte*)(aRegIdx + nIdx + 1);
			CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
			aToOpen[nIdx + 1] = (byte)(0);
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				aXRef[i] = (int)(-1);
			}

			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = pParse;
			sNC.pSrcList = pTabList;
			sNC.uNC.pUpsert = pUpsert;
			sNC.ncFlags = (int)(0x000200);
			v = sqlite3GetVdbe(pParse);
			if ((v) == (null))
				goto update_cleanup;
			chngRowid = (byte)(chngPk = (byte)(0));
			for (i = (int)(0); (i) < (pChanges.nExpr); i++)
			{
				byte hCol = (byte)(sqlite3StrIHash(pChanges.a[i].zEName));
				if (((nChangeFrom) == (0)) && ((sqlite3ResolveExprNames(sNC, pChanges.a[i].pExpr)) != 0))
				{
					goto update_cleanup;
				}

				for (j = (int)(0); (j) < (pTab.nCol); j++)
				{
					if (((pTab.aCol[j].hName) == (hCol)) && ((sqlite3StrICmp(pTab.aCol[j].zCnName, pChanges.a[i].zEName)) == (0)))
					{
						if ((j) == (pTab.iPKey))
						{
							chngRowid = (byte)(1);
							pRowidExpr = pChanges.a[i].pExpr;
							iRowidExpr = (int)(i);
						}
						else if (((pPk) != null) && ((pTab.aCol[j].colFlags & 0x0001) != 0))
						{
							chngPk = (byte)(1);
						}
						else if ((pTab.aCol[j].colFlags & 0x0060) != 0)
						{
							sqlite3ErrorMsg(pParse, "cannot UPDATE generated column \"%s\"", pTab.aCol[j].zCnName);
							goto update_cleanup;
						}

						aXRef[j] = (int)(i);
						break;
					}
				}

				if ((j) >= (pTab.nCol))
				{
					if (((pPk) == (null)) && ((sqlite3IsRowid(pChanges.a[i].zEName)) != 0))
					{
						j = (int)(-1);
						chngRowid = (byte)(1);
						pRowidExpr = pChanges.a[i].pExpr;
						iRowidExpr = (int)(i);
					}
					else
					{
						sqlite3ErrorMsg(pParse, "no such column: %s", pChanges.a[i].zEName);
						pParse.checkSchema = (byte)(1);
						goto update_cleanup;
					}
				}

				{
					int rc = 0;
					rc = (int)(sqlite3AuthCheck(pParse, (int)(23), pTab.zName, (j) < (0) ? "ROWID" : pTab.aCol[j].zCnName, db.aDb[iDb].zDbSName));
					if ((rc) == (1))
					{
						goto update_cleanup;
					}
					else if ((rc) == (2))
					{
						aXRef[j] = (int)(-1);
					}
				}
			}




			chngKey = (byte)(chngRowid + chngPk);
			if ((pTab.tabFlags & 0x00000060) != 0)
			{
				int bProgress = 0;
				do
				{
					bProgress = (int)(0);
					for (i = (int)(0); (i) < (pTab.nCol); i++)
					{
						if ((aXRef[i]) >= (0))
							continue;
						if ((pTab.aCol[i].colFlags & 0x0060) == (0))
							continue;
						if ((sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &pTab.aCol[i]), aXRef, (int)(chngRowid))) != 0)
						{
							aXRef[i] = (int)(99999);
							bProgress = (int)(1);
						}
					}
				}
				while ((bProgress) != 0);
			}

			pTabList.a[0].colUsed = (ulong)((((pTab).eTabType) == (1)) ? ((ulong)(-1)) : 0);
			hasFK = (int)(sqlite3FkRequired(pParse, pTab, aXRef, (int)(chngKey)));
			if ((onError) == (5))
				bReplace = (int)(1);
			for (nAllIdx = (int)(0), pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext, nAllIdx++)
			{
				int reg = 0;
				if (((((chngKey) != 0) || ((hasFK) > (1))) || ((pIdx) == (pPk))) || ((indexWhereClauseMightChange(pIdx, aXRef, (int)(chngRowid))) != 0))
				{
					reg = (int)(++pParse.nMem);
					pParse.nMem += (int)(pIdx.nColumn);
				}
				else
				{
					reg = (int)(0);
					for (i = (int)(0); (i) < (pIdx.nKeyCol); i++)
					{
						if ((indexColumnIsBeingUpdated(pIdx, (int)(i), aXRef, (int)(chngRowid))) != 0)
						{
							reg = (int)(++pParse.nMem);
							pParse.nMem += (int)(pIdx.nColumn);
							if (((onError) == (11)) && ((pIdx.onError) == (5)))
							{
								bReplace = (int)(1);
							}

							break;
						}
					}
				}

				if ((reg) == (0))
					aToOpen[nAllIdx + 1] = (byte)(0);
				aRegIdx[nAllIdx] = (int)(reg);
			}

			aRegIdx[nAllIdx] = (int)(++pParse.nMem);
			if ((bReplace) != 0)
			{
				CRuntime.memset(aToOpen, (int)(1), (ulong)(nIdx + 1));
			}

			if ((pParse.nested) == (0))
				sqlite3VdbeCountChanges(v);
			sqlite3BeginWriteOperation(pParse, (((pTrigger) != null) || ((hasFK) != 0) ? 1 : 0), (int)(iDb));
			if (!(((pTab).eTabType) == (1)))
			{

				regRowSet = (int)(aRegIdx[nAllIdx]);
				regOldRowid = (int)(regNewRowid = (int)(++pParse.nMem));
				if ((((chngPk) != 0) || ((pTrigger) != null)) || ((hasFK) != 0))
				{
					regOld = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(pTab.nCol);
				}

				if ((((chngKey) != 0) || ((pTrigger) != null)) || ((hasFK) != 0))
				{
					regNewRowid = (int)(++pParse.nMem);
				}

				regNew = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(pTab.nCol);
			}

			if ((isView) != 0)
			{
				sqlite3AuthContextPush(pParse, sContext, pTab.zName);
			}

			if (((nChangeFrom) == (0)) && ((isView) != 0))
			{
				sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, (int)(iDataCur));
				pOrderBy = null;
				pLimit = null;
			}

			if (((nChangeFrom) == (0)) && ((sqlite3ResolveExprNames(sNC, pWhere)) != 0))
			{
				goto update_cleanup;
			}

			if ((((pTab).eTabType) == (1)))
			{
				updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, (int)(onError));
				goto update_cleanup;
			}

			labelContinue = (int)(labelBreak = (int)(sqlite3VdbeMakeLabel(pParse)));
			if ((((((db.flags & ((ulong)(0x00001) << 32)) != 0) && (pParse.pTriggerTab == null)) && (pParse.nested == 0)) && (pParse.bReturning == 0)) && ((pUpsert) == (null)))
			{
				regRowCount = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regRowCount));
			}

			if (((nChangeFrom) == (0)) && (((pTab).tabFlags & 0x00000080) == (0)))
			{
				sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(regRowSet), (int)(regOldRowid));
				iEph = (int)(pParse.nTab++);
				addrOpen = (int)(sqlite3VdbeAddOp3(v, (int)(116), (int)(iEph), (int)(0), (int)(regRowSet)));
			}
			else
			{

				nPk = (short)(pPk ? pPk.nKeyCol : 0);
				iPk = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPk);
				pParse.nMem += (int)(nChangeFrom);
				regKey = (int)(++pParse.nMem);
				if ((pUpsert) == (null))
				{
					int nEphCol = (int)(nPk + nChangeFrom + ((isView) != 0 ? pTab.nCol : 0));
					iEph = (int)(pParse.nTab++);
					if ((pPk) != null)
						sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(iPk), (int)(iPk + nPk - 1));
					addrOpen = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(iEph), (int)(nEphCol)));
					if ((pPk) != null)
					{
						KeyInfo pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);
						if ((pKeyInfo) != null)
						{
							pKeyInfo.nAllField = (ushort)(nEphCol);
							sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
						}
					}

					if ((nChangeFrom) != 0)
					{
						updateFromSelect(pParse, (int)(iEph), pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit);
						if ((isView) != 0)
							iDataCur = (int)(iEph);
					}
				}
			}

			if ((nChangeFrom) != 0)
			{
				sqlite3MultiWrite(pParse);
				eOnePass = (int)(0);
				nKey = (int)(nPk);
				regKey = (int)(iPk);
			}
			else
			{
				if ((pUpsert) != null)
				{
					pWInfo = null;
					eOnePass = (int)(1);
					sqlite3ExprIfFalse(pParse, pWhere, (int)(labelBreak), (int)(0x10));
					bFinishSeek = (int)(0);
				}
				else
				{
					flags = (int)(0x0004);
					if (((((pParse.nested == 0) && (pTrigger == null)) && (hasFK == 0)) && (chngKey == 0)) && (bReplace == 0))
					{
						flags |= (int)(0x0008);
					}

					pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, null, null, null, (ushort)(flags), (int)(iIdxCur));
					if ((pWInfo) == (null))
						goto update_cleanup;
					eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aiCurOnePass));
					bFinishSeek = (int)(sqlite3WhereUsesDeferredSeek(pWInfo));
					if (eOnePass != 1)
					{
						sqlite3MultiWrite(pParse);
						if ((eOnePass) == (2))
						{
							int iCur = (int)(aiCurOnePass[1]);
							if ((((iCur) >= (0)) && (iCur != iDataCur)) && ((aToOpen[iCur - iBaseCur]) != 0))
							{
								eOnePass = (int)(0);
							}


						}
					}
				}

				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					sqlite3VdbeAddOp2(v, (int)(134), (int)(iDataCur), (int)(regOldRowid));
					if ((eOnePass) == (0))
					{
						aRegIdx[nAllIdx] = (int)(++pParse.nMem);
						sqlite3VdbeAddOp3(v, (int)(127), (int)(iEph), (int)(regRowSet), (int)(regOldRowid));
					}
					else
					{
						if ((addrOpen) != 0)
							sqlite3VdbeChangeToNoop(v, (int)(addrOpen));
					}
				}
				else
				{
					for (i = (int)(0); (i) < (nPk); i++)
					{

						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(pPk.aiColumn[i]), (int)(iPk + i));
					}

					if ((eOnePass) != 0)
					{
						if ((addrOpen) != 0)
							sqlite3VdbeChangeToNoop(v, (int)(addrOpen));
						nKey = (int)(nPk);
						regKey = (int)(iPk);
					}
					else
					{
						sqlite3VdbeAddOp4(v, (int)(96), (int)(iPk), (int)(nPk), (int)(regKey), sqlite3IndexAffinityStr(db, pPk), (int)(nPk));
						sqlite3VdbeAddOp4Int(v, (int)(137), (int)(iEph), (int)(regKey), (int)(iPk), (int)(nPk));
					}
				}
			}

			if ((pUpsert) == (null))
			{
				if (((nChangeFrom) == (0)) && (eOnePass != 2))
				{
					sqlite3WhereEnd(pWInfo);
				}

				if (isView == 0)
				{
					int addrOnce = (int)(0);
					if (eOnePass != 0)
					{
						if ((aiCurOnePass[0]) >= (0))
							aToOpen[aiCurOnePass[0] - iBaseCur] = (byte)(0);
						if ((aiCurOnePass[1]) >= (0))
							aToOpen[aiCurOnePass[1] - iBaseCur] = (byte)(0);
					}

					if (((eOnePass) == (2)) && ((nIdx - ((aiCurOnePass[1]) >= (0))) > (0)))
					{
						addrOnce = (int)(sqlite3VdbeAddOp0(v, (int)(17)));
					}

					sqlite3OpenTableAndIndices(pParse, pTab, (int)(112), (byte)(0), (int)(iBaseCur), aToOpen, null, null);
					if ((addrOnce) != 0)
					{
						sqlite3VdbeJumpHereOrPopInst(v, (int)(addrOnce));
					}
				}

				if (eOnePass != 0)
				{
					if ((aiCurOnePass[0] != iDataCur) && (aiCurOnePass[1] != iDataCur))
					{

						sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelBreak), (int)(regKey), (int)(nKey));
					}

					if (eOnePass != 1)
					{
						labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
					}

					sqlite3VdbeAddOp2(v, (int)(50), (int)(pPk ? regKey : regOldRowid), (int)(labelBreak));
				}
				else if (((pPk) != null) || ((nChangeFrom) != 0))
				{
					labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
					sqlite3VdbeAddOp2(v, (int)(38), (int)(iEph), (int)(labelBreak));
					addrTop = (int)(sqlite3VdbeCurrentAddr(v));
					if ((nChangeFrom) != 0)
					{
						if (isView == 0)
						{
							if ((pPk) != null)
							{
								for (i = (int)(0); (i) < (nPk); i++)
								{
									sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(i), (int)(iPk + i));
								}

								sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(iPk), (int)(nPk));
							}
							else
							{
								sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(regOldRowid));
								sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
							}
						}
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(133), (int)(iEph), (int)(regKey));
						sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(0));
					}
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(38), (int)(iEph), (int)(labelBreak));
					labelContinue = (int)(sqlite3VdbeMakeLabel(pParse));
					addrTop = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(regOldRowid)));
					sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
				}
			}


			if ((chngRowid) != 0)
			{

				if ((nChangeFrom) == (0))
				{
					sqlite3ExprCode(pParse, pRowidExpr, (int)(regNewRowid));
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(iRowidExpr), (int)(regNewRowid));
				}

				sqlite3VdbeAddOp1(v, (int)(15), (int)(regNewRowid));
			}

			if ((((chngPk) != 0) || ((hasFK) != 0)) || ((pTrigger) != null))
			{
				uint oldmask = (uint)((hasFK) != 0 ? sqlite3FkOldmask(pParse, pTab) : 0);
				oldmask |= (uint)(sqlite3TriggerColmask(pParse, pTrigger, pChanges, (int)(0), (int)(1 | 2), pTab, (int)(onError)));
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					uint colFlags = (uint)(pTab.aCol[i].colFlags);
					k = (int)(sqlite3TableColumnToStorage(pTab, (short)(i)) + regOld);
					if ((((oldmask) == (0xffffffff)) || (((i) < (32)) && ((oldmask & (((uint)(1)) << (i))) != 0))) || ((colFlags & 0x0001) != 0))
					{
						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
					}
				}

				if (((chngRowid) == (0)) && ((pPk) == (null)))
				{
					sqlite3VdbeAddOp2(v, (int)(79), (int)(regOldRowid), (int)(regNewRowid));
				}
			}

			newmask = (int)(sqlite3TriggerColmask(pParse, pTrigger, pChanges, (int)(1), (int)(1), pTab, (int)(onError)));
			for (i = (int)(0), k = (int)(regNew); (i) < (pTab.nCol); i++, k++)
			{
				if ((i) == (pTab.iPKey))
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
				}
				else if ((pTab.aCol[i].colFlags & 0x0060) != 0)
				{
					if ((pTab.aCol[i].colFlags & 0x0020) != 0)
						k--;
				}
				else
				{
					j = (int)(aXRef[i]);
					if ((j) >= (0))
					{
						if ((nChangeFrom) != 0)
						{
							int nOff = (int)((isView) != 0 ? pTab.nCol : nPk);

							sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(nOff + j), (int)(k));
						}
						else
						{
							sqlite3ExprCode(pParse, pChanges.a[j].pExpr, (int)(k));
						}
					}
					else if ((((0) == (tmask & 1)) || ((i) > (31))) || ((newmask & (((uint)(1)) << (i))) != 0))
					{
						sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
						bFinishSeek = (int)(0);
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(k));
					}
				}
			}

			if ((pTab.tabFlags & 0x00000060) != 0)
			{
				sqlite3ComputeGeneratedColumns(pParse, (int)(regNew), pTab);
			}

			if ((tmask & 1) != 0)
			{
				sqlite3TableAffinity(v, pTab, (int)(regNew));
				sqlite3CodeRowTrigger(pParse, pTrigger, (int)(129), pChanges, (int)(1), pTab, (int)(regOldRowid), (int)(onError), (int)(labelContinue));
				if (isView == 0)
				{
					if ((pPk) != null)
					{
						sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(nKey));
					}
					else
					{
						sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
					}

					for (i = (int)(0), k = (int)(regNew); (i) < (pTab.nCol); i++, k++)
					{
						if ((pTab.aCol[i].colFlags & 0x0060) != 0)
						{
							if ((pTab.aCol[i].colFlags & 0x0020) != 0)
								k--;
						}
						else if (((aXRef[i]) < (0)) && (i != pTab.iPKey))
						{
							sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iDataCur), (int)(i), (int)(k));
						}
					}

					if ((pTab.tabFlags & 0x00000060) != 0)
					{
						sqlite3ComputeGeneratedColumns(pParse, (int)(regNew), pTab);
					}
				}
			}

			if (isView == 0)
			{

				sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, (int)(iDataCur), (int)(iIdxCur), (int)(regNewRowid), (int)(regOldRowid), (byte)(chngKey), (byte)(onError), (int)(labelContinue), &bReplace, aXRef, null);
				if (((bReplace) != 0) || ((chngKey) != 0))
				{
					if ((pPk) != null)
					{
						sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iDataCur), (int)(labelContinue), (int)(regKey), (int)(nKey));
					}
					else
					{
						sqlite3VdbeAddOp3(v, (int)(33), (int)(iDataCur), (int)(labelContinue), (int)(regOldRowid));
					}
				}

				if ((hasFK) != 0)
				{
					sqlite3FkCheck(pParse, pTab, (int)(regOldRowid), (int)(0), aXRef, (int)(chngKey));
				}

				sqlite3GenerateRowIndexDelete(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), aRegIdx, (int)(-1));
				if ((bFinishSeek) != 0)
				{
					sqlite3VdbeAddOp1(v, (int)(142), (int)(iDataCur));
				}


				if (((hasFK) > (1)) || ((chngKey) != 0))
				{
					sqlite3VdbeAddOp2(v, (int)(129), (int)(iDataCur), (int)(0));
				}

				if ((hasFK) != 0)
				{
					sqlite3FkCheck(pParse, pTab, (int)(0), (int)(regNewRowid), aXRef, (int)(chngKey));
				}

				sqlite3CompleteInsertion(pParse, pTab, (int)(iDataCur), (int)(iIdxCur), (int)(regNewRowid), aRegIdx, (int)(0x04 | ((eOnePass) == (2) ? 0x02 : 0)), (int)(0), (int)(0));
				if ((hasFK) != 0)
				{
					sqlite3FkActions(pParse, pTab, pChanges, (int)(regOldRowid), aXRef, (int)(chngKey));
				}
			}

			if ((regRowCount) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(85), (int)(regRowCount), (int)(1));
			}

			sqlite3CodeRowTrigger(pParse, pTrigger, (int)(129), pChanges, (int)(2), pTab, (int)(regOldRowid), (int)(onError), (int)(labelContinue));
			if ((eOnePass) == (1))
			{
			}
			else if ((eOnePass) == (2))
			{
				sqlite3VdbeResolveLabel(v, (int)(labelContinue));
				sqlite3WhereEnd(pWInfo);
			}
			else
			{
				sqlite3VdbeResolveLabel(v, (int)(labelContinue));
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iEph), (int)(addrTop));
			}

			sqlite3VdbeResolveLabel(v, (int)(labelBreak));
			if ((((pParse.nested) == (0)) && ((pParse.pTriggerTab) == (null))) && ((pUpsert) == (null)))
			{
				sqlite3AutoincrementEnd(pParse);
			}

			if ((regRowCount) != 0)
			{
				sqlite3CodeChangeCount(v, (int)(regRowCount), "rows updated");
			}

		update_cleanup:
			; sqlite3AuthContextPop(sContext);
			sqlite3DbFree(db, aXRef);
			sqlite3SrcListDelete(db, pTabList);
			sqlite3ExprListDelete(db, pChanges);
			sqlite3ExprDelete(db, pWhere);
			return;
		}
		public static int sqlite3UpsertAnalyzeTarget(Parse pParse, SrcList pTabList, Upsert pUpsert)
		{
			Table pTab;
			int rc = 0;
			int iCursor = 0;
			Index pIdx;
			ExprList pTarget;
			Expr pTerm;
			NameContext sNC = new NameContext();
			var sCol = new Expr[2]; sCol[0] = new Expr(); sCol[1] = new Expr();
			int nClause = (int)(0);




			CRuntime.memset(sNC, (int)(0), (ulong)(sizeof(NameContext)));
			sNC.pParse = pParse;
			sNC.pSrcList = pTabList;
			for (; ((pUpsert) != null) && ((pUpsert.pUpsertTarget) != null); pUpsert = pUpsert.pNextUpsert, nClause++)
			{
				rc = (int)(sqlite3ResolveExprListNames(sNC, pUpsert.pUpsertTarget));
				if ((rc) != 0)
					return (int)(rc);
				rc = (int)(sqlite3ResolveExprNames(sNC, pUpsert.pUpsertTargetWhere));
				if ((rc) != 0)
					return (int)(rc);
				pTab = pTabList.a[0].pTab;
				pTarget = pUpsert.pUpsertTarget;
				iCursor = (int)(pTabList.a[0].iCursor);
				if ((((((pTab).tabFlags & 0x00000080) == (0)) && ((pTarget.nExpr) == (1))) && (((pTerm = pTarget.a[0].pExpr).op) == (167))) && ((pTerm.iColumn) == (-1)))
				{

					continue;
				}

				CRuntime.memset(sCol, (int)(0), (ulong)(2 * sizeof(Expr)));
				sCol[0].op = (byte)(113);
				sCol[0].pLeft = sCol[1];
				sCol[1].op = (byte)(167);
				sCol[1].iTable = (int)(pTabList.a[0].iCursor);
				for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
				{
					int ii = 0;
					int jj = 0;
					int nn = 0;
					if (!((pIdx).onError != 0))
						continue;
					if (pTarget.nExpr != pIdx.nKeyCol)
						continue;
					if ((pIdx.pPartIdxWhere) != null)
					{
						if ((pUpsert.pUpsertTargetWhere) == (null))
							continue;
						if (sqlite3ExprCompare(pParse, pUpsert.pUpsertTargetWhere, pIdx.pPartIdxWhere, (int)(iCursor)) != 0)
						{
							continue;
						}
					}

					nn = (int)(pIdx.nKeyCol);
					for (ii = (int)(0); (ii) < (nn); ii++)
					{
						Expr pExpr;
						sCol[0].u.zToken = pIdx.azColl[ii];
						if ((pIdx.aiColumn[ii]) == (-2))
						{


							pExpr = pIdx.aColExpr.a[ii].pExpr;
							if (pExpr.op != 113)
							{
								sCol[0].pLeft = pExpr;
								pExpr = sCol[0];
							}
						}
						else
						{
							sCol[0].pLeft = sCol[1];
							sCol[1].iColumn = (short)(pIdx.aiColumn[ii]);
							pExpr = sCol[0];
						}

						for (jj = (int)(0); (jj) < (nn); jj++)
						{
							if ((sqlite3ExprCompare(pParse, pTarget.a[jj].pExpr, pExpr, (int)(iCursor))) < (2))
							{
								break;
							}
						}

						if ((jj) >= (nn))
						{
							break;
						}
					}

					if ((ii) < (nn))
					{
						continue;
					}

					pUpsert.pUpsertIdx = pIdx;
					break;
				}

				if ((pUpsert.pUpsertIdx) == (null))
				{
					sbyte* zWhich = stackalloc sbyte[16];
					if (((nClause) == (0)) && ((pUpsert.pNextUpsert) == (null)))
					{
						zWhich[0] = (sbyte)(0);
					}
					else
					{
						sqlite3_snprintf((int)(16 * sizeof(sbyte)), zWhich, "%r ", (int)(nClause + 1));
					}

					sqlite3ErrorMsg(pParse, "%sON CONFLICT clause does not match any PRIMARY KEY or UNIQUE constraint", zWhich);
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static void sqlite3UpsertDelete(sqlite3 db, Upsert p)
		{
			if ((p) != null)
				upsertDelete(db, p);
		}
		public static void sqlite3UpsertDoUpdate(Parse pParse, Upsert pUpsert, Table pTab, Index pIdx, int iCur)
		{
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			SrcList pSrc;
			int iDataCur = 0;
			int i = 0;
			Upsert pTop = pUpsert;


			iDataCur = (int)(pUpsert.iDataCur);
			pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);
			if (((pIdx) != null) && (iCur != iDataCur))
			{
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					int regRowid = (int)(sqlite3GetTempReg(pParse));
					sqlite3VdbeAddOp2(v, (int)(141), (int)(iCur), (int)(regRowid));
					sqlite3VdbeAddOp3(v, (int)(32), (int)(iDataCur), (int)(0), (int)(regRowid));
					sqlite3ReleaseTempReg(pParse, (int)(regRowid));
				}
				else
				{
					Index pPk = sqlite3PrimaryKeyIndex(pTab);
					int nPk = (int)(pPk.nKeyCol);
					int iPk = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(nPk);
					for (i = (int)(0); (i) < (nPk); i++)
					{
						int k = 0;

						k = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[i])));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iCur), (int)(k), (int)(iPk + i));
					}

					i = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(iDataCur), (int)(0), (int)(iPk), (int)(nPk)));
					sqlite3VdbeAddOp4(v, (int)(70), (int)(11), (int)(2), (int)(0), "corrupt database", (int)(-1));
					sqlite3MayAbort(pParse);
					sqlite3VdbeJumpHere(v, (int)(i));
				}
			}

			pSrc = sqlite3SrcListDup(db, pTop.pUpsertSrc, (int)(0));
			for (i = (int)(0); (i) < (pTab.nCol); i++)
			{
				if ((pTab.aCol[i].affinity) == (0x45))
				{
					sqlite3VdbeAddOp1(v, (int)(86), (int)(pTop.regData + i));
				}
			}

			sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db, pUpsert.pUpsertSet, (int)(0)), sqlite3ExprDup(db, pUpsert.pUpsertWhere, (int)(0)), (int)(2), null, null, pUpsert);
		}
		public static Upsert sqlite3UpsertDup(sqlite3 db, Upsert p)
		{
			if ((p) == (null))
				return null;
			return sqlite3UpsertNew(db, sqlite3ExprListDup(db, p.pUpsertTarget, (int)(0)), sqlite3ExprDup(db, p.pUpsertTargetWhere, (int)(0)), sqlite3ExprListDup(db, p.pUpsertSet, (int)(0)), sqlite3ExprDup(db, p.pUpsertWhere, (int)(0)), sqlite3UpsertDup(db, p.pNextUpsert));
		}
		public static Upsert sqlite3UpsertNew(sqlite3 db, ExprList pTarget, Expr pTargetWhere, ExprList pSet, Expr pWhere, Upsert pNext)
		{
			Upsert pNew;
			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Upsert)));
			if ((pNew) == (null))
			{
				sqlite3ExprListDelete(db, pTarget);
				sqlite3ExprDelete(db, pTargetWhere);
				sqlite3ExprListDelete(db, pSet);
				sqlite3ExprDelete(db, pWhere);
				sqlite3UpsertDelete(db, pNext);
				return null;
			}
			else
			{
				pNew.pUpsertTarget = pTarget;
				pNew.pUpsertTargetWhere = pTargetWhere;
				pNew.pUpsertSet = pSet;
				pNew.pUpsertWhere = pWhere;
				pNew.isDoUpdate = (byte)(pSet != null);
				pNew.pNextUpsert = pNext;
			}

			return pNew;
		}
		public static int sqlite3UpsertNextIsIPK(Upsert pUpsert)
		{
			Upsert pNext;
			if (((pUpsert) == (null)))
				return (int)(0);
			pNext = pUpsert.pNextUpsert;
			if ((pNext) == (null))
				return (int)(1);
			if ((pNext.pUpsertTarget) == (null))
				return (int)(1);
			if ((pNext.pUpsertIdx) == (null))
				return (int)(1);
			return (int)(0);
		}
		public static Upsert sqlite3UpsertOfIndex(Upsert pUpsert, Index pIdx)
		{
			while ((((pUpsert) != null) && (pUpsert.pUpsertTarget != null)) && (pUpsert.pUpsertIdx != pIdx))
			{
				pUpsert = pUpsert.pNextUpsert;
			}

			return pUpsert;
		}
		public static int sqlite3Utf16ByteLen(void* zIn, int nChar)
		{
			int c = 0;
			byte* z = zIn;
			int n = (int)(0);
			if ((2) == (2))
				z++;
			while ((n) < (nChar))
			{
				c = (int)(z[0]);
				z += 2;
				if (((((c) >= (0xd8)) && ((c) < (0xdc))) && ((z[0]) >= (0xdc))) && ((z[0]) < (0xe0)))
					z += 2;
				n++;
			}

			return (int)((int)(z - (byte*)(zIn)) - ((2) == (2)));
		}
		public static sbyte* sqlite3Utf16to8(sqlite3 db, void* z, int nByte, byte enc)
		{
			sqlite3_value m = new sqlite3_value();
			CRuntime.memset(m, (int)(0), (ulong)(sizeof(sqlite3_value)));
			m.db = db;
			sqlite3VdbeMemSetStr(m, z, (long)(nByte), (byte)(enc), null);
			sqlite3VdbeChangeEncoding(m, (int)(1));
			if ((db.mallocFailed) != 0)
			{
				sqlite3VdbeMemRelease(m);
				m.z = null;
			}




			return m.z;
		}
		public static int sqlite3Utf8CharLen(sbyte* zIn, int nByte)
		{
			int r = (int)(0);
			byte* z = (byte*)(zIn);
			byte* zTerm;
			if ((nByte) >= (0))
			{
				zTerm = &z[nByte];
			}
			else
			{
				zTerm = (byte*)(-1);
			}


			while ((*z != 0) && ((z) < (zTerm)))
			{
				{
					if ((*(z++)) >= (0xc0))
					{
						while ((*z & 0xc0) == (0x80))
						{
							z++;
						}
					}
				}

				r++;
			}

			return (int)(r);
		}
		public static uint sqlite3Utf8Read(byte** pz)
		{
			uint c = 0;
			c = (uint)(*((*pz)++));
			if ((c) >= (0xc0))
			{
				c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
				while ((*(*pz) & 0xc0) == (0x80))
				{
					c = (uint)((c << 6) + (0x3f & *((*pz)++)));
				}

				if ((((c) < (0x80)) || ((c & 0xFFFFF800) == (0xD800))) || ((c & 0xFFFFFFFE) == (0xFFFE)))
				{
					c = (uint)(0xFFFD);
				}
			}

			return (uint)(c);
		}
		public static void sqlite3Vacuum(Parse pParse, Token* pNm, Expr pInto)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			int iDb = (int)(0);
			if ((v) == (null))
				goto build_vacuum_end;
			if ((pParse.nErr) != 0)
				goto build_vacuum_end;
			if ((pNm) != null)
			{
				iDb = (int)(sqlite3TwoPartName(pParse, pNm, pNm, &pNm));
				if ((iDb) < (0))
					goto build_vacuum_end;
			}

			if (iDb != 1)
			{
				int iIntoReg = (int)(0);
				if (((pInto) != null) && ((sqlite3ResolveSelfReference(pParse, null, (int)(0), pInto, null)) == (0)))
				{
					iIntoReg = (int)(++pParse.nMem);
					sqlite3ExprCode(pParse, pInto, (int)(iIntoReg));
				}

				sqlite3VdbeAddOp2(v, (int)(8), (int)(iDb), (int)(iIntoReg));
				sqlite3VdbeUsesBtree(v, (int)(iDb));
			}

		build_vacuum_end:
			; sqlite3ExprDelete(pParse.db, pInto);
			return;
		}
		public static void sqlite3ValueApplyAffinity(sqlite3_value pVal, byte affinity, byte enc)
		{
			applyAffinity(pVal, (sbyte)(affinity), (byte)(enc));
		}
		public static int sqlite3ValueBytes(sqlite3_value pVal, byte enc)
		{
			sqlite3_value p = pVal;

			if (((p.flags & 0x0002) != 0) && ((pVal.enc) == (enc)))
			{
				return (int)(p.n);
			}

			if ((p.flags & 0x0010) != 0)
			{
				if ((p.flags & 0x4000) != 0)
				{
					return (int)(p.n + p.u.nZero);
				}
				else
				{
					return (int)(p.n);
				}
			}

			if ((p.flags & 0x0001) != 0)
				return (int)(0);
			return (int)(valueBytes(pVal, (byte)(enc)));
		}
		public static void sqlite3ValueFree(sqlite3_value v)
		{
			if (v == null)
				return;
			sqlite3VdbeMemRelease(v);
			sqlite3DbFreeNN((v).db, v);
		}
		public static int sqlite3ValueFromExpr(sqlite3 db, Expr pExpr, byte enc, byte affinity, sqlite3_value ppVal)
		{
			return (int)(pExpr ? valueFromExpr(db, pExpr, (byte)(enc), (byte)(affinity), ppVal, null) : 0);
		}
		public static sqlite3_value sqlite3ValueNew(sqlite3 db)
		{
			sqlite3_value p = sqlite3DbMallocZero(db, (ulong)(sizeof(sqlite3_value)));
			if ((p) != null)
			{
				p.flags = (ushort)(0x0001);
				p.db = db;
			}

			return p;
		}
		public static void sqlite3ValueSetNull(sqlite3_value p)
		{
			sqlite3VdbeMemSetNull(p);
		}
		public static void sqlite3ValueSetStr(sqlite3_value v, int n, void* z, byte enc, delegate17 xDel)
		{
			if ((v) != null)
				sqlite3VdbeMemSetStr(v, z, (long)(n), (byte)(enc), xDel);
		}
		public static void* sqlite3ValueText(sqlite3_value pVal, byte enc)
		{
			if (pVal == null)
				return null;



			if (((pVal.flags & (0x0002 | 0x0200)) == (0x0002 | 0x0200)) && ((pVal.enc) == (enc)))
			{

				return pVal.z;
			}

			if ((pVal.flags & 0x0001) != 0)
			{
				return null;
			}

			return valueToText(pVal, (byte)(enc));
		}
		public static int sqlite3VarintLen(ulong v)
		{
			int i = 0;
			for (i = (int)(1); (v >>= 7) != 0; i++)
			{

			}

			return (int)(i);
		}
		public static int sqlite3VdbeAddFunctionCall(Parse pParse, int p1, int p2, int p3, int nArg, FuncDef pFunc, int eCallCtx)
		{
			Vdbe v = pParse.pVdbe;
			int nByte = 0;
			int addr = 0;
			sqlite3_context pCtx;

			nByte = (int)(sizeof(sqlite3_context) + (nArg - 1) * sizeof(sqlite3_value));
			pCtx = sqlite3DbMallocRawNN(pParse.db, (ulong)(nByte));
			if ((pCtx) == (null))
			{

				freeEphemeralFunction(pParse.db, pFunc);
				return (int)(0);
			}

			pCtx.pOut = null;
			pCtx.pFunc = pFunc;
			pCtx.pVdbe = null;
			pCtx.isError = (int)(0);
			pCtx.argc = (byte)(nArg);
			pCtx.iOp = (int)(sqlite3VdbeCurrentAddr(v));
			addr = (int)(sqlite3VdbeAddOp4(v, (int)((eCallCtx) != 0 ? 65 : 66), (int)(p1), (int)(p2), (int)(p3), (sbyte*)(pCtx), (int)(-16)));
			sqlite3VdbeChangeP5(v, (ushort)(eCallCtx & 0x00002e));
			return (int)(addr);
		}
		public static int sqlite3VdbeAddOp0(Vdbe p, int op)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(0), (int)(0), (int)(0)));
		}
		public static int sqlite3VdbeAddOp1(Vdbe p, int op, int p1)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(0), (int)(0)));
		}
		public static int sqlite3VdbeAddOp2(Vdbe p, int op, int p1, int p2)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(0)));
		}
		public static int sqlite3VdbeAddOp3(Vdbe p, int op, int p1, int p2, int p3)
		{
			int i = 0;
			VdbeOp* pOp;
			i = (int)(p.nOp);


			if ((p.nOpAlloc) <= (i))
			{
				return (int)(growOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
			}


			p.nOp++;
			pOp = &p.aOp[i];

			pOp->opcode = ((byte)(op));
			pOp->p5 = (ushort)(0);
			pOp->p1 = (int)(p1);
			pOp->p2 = (int)(p2);
			pOp->p3 = (int)(p3);
			pOp->p4.p = null;
			pOp->p4type = (sbyte)(0);
			return (int)(i);
		}
		public static int sqlite3VdbeAddOp4(Vdbe p, int op, int p1, int p2, int p3, sbyte* zP4, int p4type)
		{
			int addr = (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
			sqlite3VdbeChangeP4(p, (int)(addr), zP4, (int)(p4type));
			return (int)(addr);
		}
		public static int sqlite3VdbeAddOp4Dup8(Vdbe p, int op, int p1, int p2, int p3, byte* zP4, int p4type)
		{
			sbyte* p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), (ulong)(8));
			if ((p4copy) != null)
				CRuntime.memcpy(p4copy, zP4, (ulong)(8));
			return (int)(sqlite3VdbeAddOp4(p, (int)(op), (int)(p1), (int)(p2), (int)(p3), p4copy, (int)(p4type)));
		}
		public static int sqlite3VdbeAddOp4Int(Vdbe p, int op, int p1, int p2, int p3, int p4)
		{
			int addr = (int)(sqlite3VdbeAddOp3(p, (int)(op), (int)(p1), (int)(p2), (int)(p3)));
			if ((p.db.mallocFailed) == (0))
			{
				VdbeOp* pOp = &p.aOp[addr];
				pOp->p4type = (sbyte)(-3);
				pOp->p4.i = (int)(p4);
			}

			return (int)(addr);
		}
		public static VdbeOp* sqlite3VdbeAddOpList(Vdbe p, int nOp, VdbeOpList* aOp, int iLineno)
		{
			int i = 0;
			VdbeOp* pOut; VdbeOp* pFirst;


			if (((p.nOp + nOp) > (p.nOpAlloc)) && ((growOpArray(p, (int)(nOp))) != 0))
			{
				return null;
			}

			pFirst = pOut = &p.aOp[p.nOp];
			for (i = (int)(0); (i) < (nOp); i++, aOp++, pOut++)
			{
				pOut->opcode = (byte)(aOp->opcode);
				pOut->p1 = (int)(aOp->p1);
				pOut->p2 = (int)(aOp->p2);

				if (((sqlite3OpcodeProperty[aOp->opcode] & 0x01) != 0) && ((aOp->p2) > (0)))
				{
					pOut->p2 += (int)(p.nOp);
				}

				pOut->p3 = (int)(aOp->p3);
				pOut->p4type = (sbyte)(0);
				pOut->p4.p = null;
				pOut->p5 = (ushort)(0);
				(void)(iLineno);
			}

			p.nOp += (int)(nOp);
			return pFirst;
		}
		public static void sqlite3VdbeAddParseSchemaOp(Vdbe p, int iDb, sbyte* zWhere, ushort p5)
		{
			int j = 0;
			sqlite3VdbeAddOp4(p, (int)(148), (int)(iDb), (int)(0), (int)(0), zWhere, (int)(-7));
			sqlite3VdbeChangeP5(p, (ushort)(p5));
			for (j = (int)(0); (j) < (p.db.nDb); j++)
			{
				sqlite3VdbeUsesBtree(p, (int)(j));
			}

			sqlite3MayAbort(p.pParse);
		}
		public static UnpackedRecord sqlite3VdbeAllocUnpackedRecord(KeyInfo pKeyInfo)
		{
			UnpackedRecord p;
			int nByte = 0;
			nByte = (int)((((sizeof(UnpackedRecord)) + 7) & ~7) + sizeof(sqlite3_value) * (pKeyInfo.nKeyField + 1));
			p = (UnpackedRecord)(sqlite3DbMallocRaw(pKeyInfo.db, (ulong)(nByte)));
			if (p == null)
				return null;
			p.aMem = (sqlite3_value)(&((sbyte*)(p))[(((sizeof(UnpackedRecord)) + 7) & ~7)]);

			p.pKeyInfo = pKeyInfo;
			p.nField = (ushort)(pKeyInfo.nKeyField + 1);
			return p;
		}
		public static void sqlite3VdbeAppendP4(Vdbe p, void* pP4, int n)
		{
			VdbeOp* pOp;


			if ((p.db.mallocFailed) != 0)
			{
				freeP4(p.db, (int)(n), pP4);
			}
			else
			{


				pOp = &p.aOp[p.nOp - 1];

				pOp->p4type = (sbyte)(n);
				pOp->p4.p = pP4;
			}
		}
		public static int sqlite3VdbeBooleanValue(sqlite3_value pMem, int ifNull)
		{
			if ((pMem.flags & (0x0004 | 0x0020)) != 0)
				return (int)(pMem.u.i != 0);
			if ((pMem.flags & 0x0001) != 0)
				return (int)(ifNull);
			return (int)(sqlite3VdbeRealValue(pMem) != 0.0);
		}
		public static int sqlite3VdbeChangeEncoding(sqlite3_value pMem, int desiredEnc)
		{
			int rc = 0;



			if (((pMem.flags & 0x0002) == 0) || ((pMem.enc) == (desiredEnc)))
			{
				return (int)(0);
			}


			rc = (int)(sqlite3VdbeMemTranslate(pMem, (byte)(desiredEnc)));



			return (int)(rc);
		}
		public static void sqlite3VdbeChangeOpcode(Vdbe p, int addr, byte iNewOpcode)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->opcode = (byte)(iNewOpcode);
		}
		public static void sqlite3VdbeChangeP1(Vdbe p, int addr, int val)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->p1 = (int)(val);
		}
		public static void sqlite3VdbeChangeP2(Vdbe p, int addr, int val)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->p2 = (int)(val);
		}
		public static void sqlite3VdbeChangeP3(Vdbe p, int addr, int val)
		{
			sqlite3VdbeGetOp(p, (int)(addr))->p3 = (int)(val);
		}
		public static void sqlite3VdbeChangeP4(Vdbe p, int addr, sbyte* zP4, int n)
		{
			VdbeOp* pOp;
			sqlite3 db;

			db = p.db;


			if ((db.mallocFailed) != 0)
			{
				if (n != (-12))
					freeP4(db, (int)(n), (void*)(*&zP4));
				return;
			}



			if ((addr) < (0))
			{
				addr = (int)(p.nOp - 1);
			}

			pOp = &p.aOp[addr];
			if (((n) >= (0)) || ((pOp->p4type) != 0))
			{
				vdbeChangeP4Full(p, pOp, zP4, (int)(n));
				return;
			}

			if ((n) == (-3))
			{
				pOp->p4.i = ((int)((long)(zP4)));
				pOp->p4type = (sbyte)(-3);
			}
			else if (zP4 != null)
			{

				pOp->p4.p = (void*)(zP4);
				pOp->p4type = ((sbyte)(n));
				if ((n) == (-12))
					sqlite3VtabLock((VTable)(zP4));
			}
		}
		public static void sqlite3VdbeChangeP5(Vdbe p, ushort p5)
		{

			if ((p.nOp) > (0))
				p.aOp[p.nOp - 1].p5 = (ushort)(p5);
		}
		public static int sqlite3VdbeChangeToNoop(Vdbe p, int addr)
		{
			VdbeOp* pOp;
			if ((p.db.mallocFailed) != 0)
				return (int)(0);

			pOp = &p.aOp[addr];
			freeP4(p.db, (int)(pOp->p4type), pOp->p4.p);
			pOp->p4type = (sbyte)(0);
			pOp->p4.z = null;
			pOp->opcode = (byte)(182);
			return (int)(1);
		}
		public static int sqlite3VdbeCheckFk(Vdbe p, int deferred)
		{
			sqlite3 db = p.db;
			if ((((deferred) != 0) && ((db.nDeferredCons + db.nDeferredImmCons) > (0))) || ((deferred == 0) && ((p.nFkConstraint) > (0))))
			{
				p.rc = (int)(19 | (3 << 8));
				p.errorAction = (byte)(2);
				sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
				return (int)(1);
			}

			return (int)(0);
		}
		public static void sqlite3VdbeClearObject(sqlite3 db, Vdbe p)
		{
			SubProgram* pSub; SubProgram* pNext;

			releaseMemArray(p.aColName, (int)(p.nResColumn * 2));
			for (pSub = p.pProgram; pSub; pSub = pNext)
			{
				pNext = pSub->pNext;
				vdbeFreeOpArray(db, pSub->aOp, (int)(pSub->nOp));
				sqlite3DbFree(db, pSub);
			}

			if (p.iVdbeMagic != 0x16bceaa5)
			{
				releaseMemArray(p.aVar, (int)(p.nVar));
				sqlite3DbFree(db, p.pVList);
				sqlite3DbFree(db, p.pFree);
			}

			vdbeFreeOpArray(db, p.aOp, (int)(p.nOp));
			sqlite3DbFree(db, p.aColName);
			sqlite3DbFree(db, p.zSql);
		}
		public static int sqlite3VdbeCloseStatement(Vdbe p, int eOp)
		{
			if (((p.db.nStatement) != 0) && ((p.iStatement) != 0))
			{
				return (int)(vdbeCloseStatement(p, (int)(eOp)));
			}

			return (int)(0);
		}
		public static void sqlite3VdbeCountChanges(Vdbe v)
		{
			v.changeCntOn = (uint)(1);
		}
		public static Vdbe sqlite3VdbeCreate(Parse pParse)
		{
			sqlite3 db = pParse.db;
			Vdbe p;
			p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(Vdbe)));
			if ((p) == (null))
				return null;
			CRuntime.memset(&p.aOp, (int)(0), (ulong)(sizeof(Vdbe) - ((ulong)(&((0).aOp)))));
			p.db = db;
			if ((db.pVdbe) != null)
			{
				db.pVdbe.pPrev = p;
			}

			p.pNext = db.pVdbe;
			p.pPrev = null;
			db.pVdbe = p;
			p.iVdbeMagic = (uint)(0x16bceaa5);
			p.pParse = pParse;
			pParse.pVdbe = p;




			sqlite3VdbeAddOp2(p, (int)(64), (int)(0), (int)(1));
			return p;
		}
		public static int sqlite3VdbeCurrentAddr(Vdbe p)
		{

			return (int)(p.nOp);
		}
		public static int sqlite3VdbeCursorMoveto(VdbeCursor pp, uint* piCol)
		{
			VdbeCursor p = pp;

			if ((p.deferredMoveto) != 0)
			{
				uint iMap = 0;

				if ((((p.ub.aAltMap) != null) && ((iMap = (uint)(p.ub.aAltMap[1 + *piCol])) > (0))) && (p.nullRow == 0))
				{
					pp = p.pAltCursor;
					*piCol = (uint)(iMap - 1);
					return (int)(0);
				}

				return (int)(sqlite3VdbeFinishMoveto(p));
			}

			if ((sqlite3BtreeCursorHasMoved(p.uc.pCursor)) != 0)
			{
				return (int)(handleMovedCursor(p));
			}

			return (int)(0);
		}
		public static int sqlite3VdbeCursorRestore(VdbeCursor p)
		{

			if ((sqlite3BtreeCursorHasMoved(p.uc.pCursor)) != 0)
			{
				return (int)(handleMovedCursor(p));
			}

			return (int)(0);
		}
		public static sqlite3 sqlite3VdbeDb(Vdbe v)
		{
			return v.db;
		}
		public static void sqlite3VdbeDelete(Vdbe p)
		{
			sqlite3 db;

			db = p.db;

			sqlite3VdbeClearObject(db, p);
			if ((p.pPrev) != null)
			{
				p.pPrev.pNext = p.pNext;
			}
			else
			{

				db.pVdbe = p.pNext;
			}

			if ((p.pNext) != null)
			{
				p.pNext.pPrev = p.pPrev;
			}

			p.iVdbeMagic = (uint)(0x5606c3c8);
			p.db = null;
			sqlite3DbFreeNN(db, p);
		}
		public static void sqlite3VdbeDeleteAuxData(sqlite3 db, AuxData pp, int iOp, int mask)
		{
			while ((pp) != null)
			{
				AuxData pAux = pp;
				if (((iOp) < (0)) || ((((pAux.iAuxOp) == (iOp)) && ((pAux.iAuxArg) >= (0))) && (((pAux.iAuxArg) > (31)) || ((mask & (((uint)(1)) << (pAux.iAuxArg))) == 0))))
				{
					if ((pAux.xDeleteAux) != null)
					{
						pAux.xDeleteAux(pAux.pAux);
					}

					pp = pAux.pNextAux;
					sqlite3DbFree(db, pAux);
				}
				else
				{
					pp = pAux.pNextAux;
				}
			}
		}
		public static int sqlite3VdbeDeletePriorOpcode(Vdbe p, byte op)
		{
			if (((p.nOp) > (0)) && ((p.aOp[p.nOp - 1].opcode) == (op)))
			{
				return (int)(sqlite3VdbeChangeToNoop(p, (int)(p.nOp - 1)));
			}
			else
			{
				return (int)(0);
			}
		}
		public static sbyte* sqlite3VdbeDisplayP4(sqlite3 db, VdbeOp* pOp)
		{
			sbyte* zP4 = null;
			sqlite3_str x = new sqlite3_str();
			sqlite3StrAccumInit(x, null, null, (int)(0), (int)(1000000000));
			switch (pOp->p4type)
			{
				case (-9):
					{
						int j = 0;
						KeyInfo pKeyInfo = pOp->p4.pKeyInfo;

						sqlite3_str_appendf(x, "k(%d", (int)(pKeyInfo.nKeyField));
						for (j = (int)(0); (j) < (pKeyInfo.nKeyField); j++)
						{
							CollSeq pColl = pKeyInfo.aColl[j];
							sbyte* zColl = pColl ? pColl.zName : "";
							if ((CRuntime.strcmp(zColl, "BINARY")) == (0))
								zColl = "B";
							sqlite3_str_appendf(x, ",%s%s%s", (pKeyInfo.aSortFlags[j] & 0x01) ? "-" : "", (pKeyInfo.aSortFlags[j] & 0x02) ? "N." : "", zColl);
						}

						sqlite3_str_append(x, ")", (int)(1));
						break;
					}

				case (-2):
					{
						CollSeq pColl = pOp->p4.pColl;

						sqlite3_str_appendf(x, "%.18s-%s", pColl.zName, sqlite3VdbeDisplayP4_encnames[pColl.enc]);
						break;
					}

				case (-8):
					{
						FuncDef pDef = pOp->p4.pFunc;
						sqlite3_str_appendf(x, "%s(%d)", pDef.zName, (int)(pDef.nArg));
						break;
					}

				case (-16):
					{
						FuncDef pDef = pOp->p4.pCtx.pFunc;
						sqlite3_str_appendf(x, "%s(%d)", pDef.zName, (int)(pDef.nArg));
						break;
					}

				case (-14):
					{
						sqlite3_str_appendf(x, "%lld", (long)(*pOp->p4.pI64));
						break;
					}

				case (-3):
					{
						sqlite3_str_appendf(x, "%d", (int)(pOp->p4.i));
						break;
					}

				case (-13):
					{
						sqlite3_str_appendf(x, "%.16g", (double)(*pOp->p4.pReal));
						break;
					}

				case (-11):
					{
						sqlite3_value pMem = pOp->p4.pMem;
						if ((pMem.flags & 0x0002) != 0)
						{
							zP4 = pMem.z;
						}
						else if ((pMem.flags & (0x0004 | 0x0020)) != 0)
						{
							sqlite3_str_appendf(x, "%lld", (long)(pMem.u.i));
						}
						else if ((pMem.flags & 0x0008) != 0)
						{
							sqlite3_str_appendf(x, "%.16g", (double)(pMem.u.r));
						}
						else if ((pMem.flags & 0x0001) != 0)
						{
							zP4 = "NULL";
						}
						else
						{

							zP4 = "(blob)";
						}

						break;
					}

				case (-12):
					{
						sqlite3_vtab pVtab = pOp->p4.pVtab.pVtab;
						sqlite3_str_appendf(x, "vtab:%p", pVtab);
						break;
					}

				case (-15):
					{
						uint i = 0;
						uint* ai = pOp->p4.ai;
						uint n = (uint)(ai[0]);
						for (i = (uint)(1); (i) <= (n); i++)
						{
							sqlite3_str_appendf(x, "%c%u", (int)((i) == (1) ? 91 : 44), (uint)(ai[i]));
						}

						sqlite3_str_append(x, "]", (int)(1));
						break;
					}

				case (-4):
					{
						zP4 = "program";
						break;
					}

				case (-17):
				case (-5):
					{
						break;
					}

				case (-6):
					{
						zP4 = pOp->p4.pTab.zName;
						break;
					}

				default:
					{
						zP4 = pOp->p4.z;
					}
			}

			if ((zP4) != null)
				sqlite3_str_appendall(x, zP4);
			if ((x.accError & 7) != 0)
			{
				sqlite3OomFault(db);
			}

			return sqlite3StrAccumFinish(x);
		}
		public static void sqlite3VdbeEndCoroutine(Vdbe v, int regYield)
		{
			sqlite3VdbeAddOp1(v, (int)(68), (int)(regYield));
			v.pParse.nTempReg = (byte)(0);
			v.pParse.nRangeReg = (int)(0);
		}
		public static void sqlite3VdbeEnter(Vdbe p)
		{
			int i = 0;
			sqlite3 db;
			Db aDb;
			int nDb = 0;
			if ((p.lockMask) == (0))
				return;
			db = p.db;
			aDb = db.aDb;
			nDb = (int)(db.nDb);
			for (i = (int)(0); (i) < (nDb); i++)
			{
				if (((i != 1) && (((p.lockMask) & (((uint)(1)) << (i))) != 0)) && (aDb[i].pBt != null))
				{
					sqlite3BtreeEnter(aDb[i].pBt);
				}
			}
		}
		public static void sqlite3VdbeError(Vdbe p, sbyte* zFormat)
		{
			sbyte* ap;
			sqlite3DbFree(p.db, p.zErrMsg);
			(__va_start(&ap, zFormat));
			p.zErrMsg = sqlite3VMPrintf(p.db, zFormat, ap);
			((void)(ap = null));
		}
		public static int sqlite3VdbeExec(Vdbe p)
		{
			return 1;
		}
		public static sbyte* sqlite3VdbeExpandSql(Vdbe p, sbyte* zRawSql)
		{
			sqlite3 db;
			int idx = (int)(0);
			int nextIndex = (int)(1);
			int n = 0;
			int nToken = 0;
			int i = 0;
			sqlite3_value pVar;
			sqlite3_str _out_ = new sqlite3_str();
			sqlite3_value utf8 = new sqlite3_value();
			db = p.db;
			sqlite3StrAccumInit(_out_, null, null, (int)(0), (int)(db.aLimit[0]));
			if ((db.nVdbeExec) > (1))
			{
				while ((*zRawSql) != 0)
				{
					sbyte* zStart = zRawSql;
					while ((*(zRawSql++) != 10) && ((*zRawSql) != 0))
					{
					}

					sqlite3_str_append(_out_, "-- ", (int)(3));

					sqlite3_str_append(_out_, zStart, (int)(zRawSql - zStart));
				}
			}
			else if ((p.nVar) == (0))
			{
				sqlite3_str_append(_out_, zRawSql, (int)(sqlite3Strlen30(zRawSql)));
			}
			else
			{
				while ((zRawSql[0]) != 0)
				{
					n = (int)(findNextHostParameter(zRawSql, &nToken));

					sqlite3_str_append(_out_, zRawSql, (int)(n));
					zRawSql += n;

					if ((nToken) == (0))
						break;
					if ((zRawSql[0]) == (63))
					{
						if ((nToken) > (1))
						{

							sqlite3GetInt32(&zRawSql[1], &idx);
						}
						else
						{
							idx = (int)(nextIndex);
						}
					}
					else
					{

						idx = (int)(sqlite3VdbeParameterIndex(p, zRawSql, (int)(nToken)));

					}

					zRawSql += nToken;
					nextIndex = (int)((idx + 1) > (nextIndex) ? (idx + 1) : (nextIndex));

					pVar = p.aVar[idx - 1];
					if ((pVar.flags & 0x0001) != 0)
					{
						sqlite3_str_append(_out_, "NULL", (int)(4));
					}
					else if ((pVar.flags & (0x0004 | 0x0020)) != 0)
					{
						sqlite3_str_appendf(_out_, "%lld", (long)(pVar.u.i));
					}
					else if ((pVar.flags & 0x0008) != 0)
					{
						sqlite3_str_appendf(_out_, "%!.15g", (double)(pVar.u.r));
					}
					else if ((pVar.flags & 0x0002) != 0)
					{
						int nOut = 0;
						byte enc = (byte)((db).enc);
						if (enc != 1)
						{
							CRuntime.memset(utf8, (int)(0), (ulong)(sizeof(sqlite3_value)));
							utf8.db = db;
							sqlite3VdbeMemSetStr(utf8, pVar.z, (long)(pVar.n), (byte)(enc), null);
							if ((7) == (sqlite3VdbeChangeEncoding(utf8, (int)(1))))
							{
								_out_.accError = (byte)(7);
								_out_.nAlloc = (uint)(0);
							}

							pVar = utf8;
						}

						nOut = (int)(pVar.n);
						sqlite3_str_appendf(_out_, "'%.*q'", (int)(nOut), pVar.z);
						if (enc != 1)
							sqlite3VdbeMemRelease(utf8);
					}
					else if ((pVar.flags & 0x4000) != 0)
					{
						sqlite3_str_appendf(_out_, "zeroblob(%d)", (int)(pVar.u.nZero));
					}
					else
					{
						int nOut = 0;

						sqlite3_str_append(_out_, "x'", (int)(2));
						nOut = (int)(pVar.n);
						for (i = (int)(0); (i) < (nOut); i++)
						{
							sqlite3_str_appendf(_out_, "%02x", (int)(pVar.z[i] & 0xff));
						}

						sqlite3_str_append(_out_, "'", (int)(1));
					}
				}
			}

			if ((_out_.accError) != 0)
				sqlite3_str_reset(_out_);
			return sqlite3StrAccumFinish(_out_);
		}
		public static void sqlite3VdbeExplain(Parse pParse, byte bPush, sbyte* zFmt)
		{
			if ((pParse.explain) == (2))
			{
				sbyte* zMsg;
				Vdbe v;
				sbyte* ap;
				int iThis = 0;
				(__va_start(&ap, zFmt));
				zMsg = sqlite3VMPrintf(pParse.db, zFmt, ap);
				((void)(ap = null));
				v = pParse.pVdbe;
				iThis = (int)(v.nOp);
				sqlite3VdbeAddOp4(v, (int)(183), (int)(iThis), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7));
				if ((bPush) != 0)
				{
					pParse.addrExplain = (int)(iThis);
				}
			}
		}
		public static int sqlite3VdbeExplainParent(Parse pParse)
		{
			VdbeOp* pOp;
			if ((pParse.addrExplain) == (0))
				return (int)(0);
			pOp = sqlite3VdbeGetOp(pParse.pVdbe, (int)(pParse.addrExplain));
			return (int)(pOp->p2);
		}
		public static void sqlite3VdbeExplainPop(Parse pParse)
		{
			pParse.addrExplain = (int)(sqlite3VdbeExplainParent(pParse));
		}
		public static int sqlite3VdbeFinalize(Vdbe p)
		{
			int rc = (int)(0);
			if (((p.iVdbeMagic) == (0x2df20da3)) || ((p.iVdbeMagic) == (0x319c2973)))
			{
				rc = (int)(sqlite3VdbeReset(p));

			}

			sqlite3VdbeDelete(p);
			return (int)(rc);
		}
		public static Int(Int , Int , Int )sqlite3VdbeFindCompare(UnpackedRecord p)
		{
			if ((p.pKeyInfo.nAllField) <= (13))
			{
				int flags = (int)(p.aMem[0].flags);
				if ((p.pKeyInfo.aSortFlags[0]) != 0)
				{
					if ((p.pKeyInfo.aSortFlags[0] & 0x02) != 0)
					{
						return sqlite3VdbeRecordCompare;
					}

					p.r1 = (sbyte)(1);
					p.r2 = (sbyte)(-1);
				}
				else
				{
					p.r1 = (sbyte)(-1);
					p.r2 = (sbyte)(1);
				}

				if ((flags & 0x0004) != 0)
				{
					return vdbeRecordCompareInt;
				}

				if (((flags & (0x0008 | 0x0020 | 0x0001 | 0x0010)) == (0)) && ((p.pKeyInfo.aColl[0]) == (null)))
				{

					return vdbeRecordCompareString;
				}
			}

			return sqlite3VdbeRecordCompare;
		}
		public static int sqlite3VdbeFinishMoveto(VdbeCursor p)
		{
			int res = 0; int rc = 0;



			rc = (int)(sqlite3BtreeTableMoveto(p.uc.pCursor, (long)(p.movetoTarget), (int)(0), &res));
			if ((rc) != 0)
				return (int)(rc);
			if (res != 0)
				return (int)(sqlite3CorruptError((int)(83310)));
			p.deferredMoveto = (byte)(0);
			p.cacheStatus = (uint)(0);
			return (int)(0);
		}
		public static void sqlite3VdbeFrameDelete(VdbeFrame p)
		{
			int i = 0;
			sqlite3_value aMem = ((sqlite3_value)(&((byte*)(p))[(((sizeof(VdbeFrame)) + 7) & ~7)]));
			VdbeCursor apCsr = (VdbeCursor)(aMem[p.nChildMem]);

			for (i = (int)(0); (i) < (p.nChildCsr); i++)
			{
				sqlite3VdbeFreeCursor(p.v, apCsr[i]);
			}

			releaseMemArray(aMem, (int)(p.nChildMem));
			sqlite3VdbeDeleteAuxData(p.v.db, p.pAuxData, (int)(-1), (int)(0));
			sqlite3DbFree(p.v.db, p);
		}
		public static void sqlite3VdbeFrameMemDel(void* pArg)
		{
			VdbeFrame pFrame = (VdbeFrame)(pArg);

			pFrame.pParent = pFrame.v.pDelFrame;
			pFrame.v.pDelFrame = pFrame;
		}
		public static int sqlite3VdbeFrameRestore(VdbeFrame pFrame)
		{
			Vdbe v = pFrame.v;
			closeCursorsInFrame(v);
			v.aOp = pFrame.aOp;
			v.nOp = (int)(pFrame.nOp);
			v.aMem = pFrame.aMem;
			v.nMem = (int)(pFrame.nMem);
			v.apCsr = pFrame.apCsr;
			v.nCursor = (int)(pFrame.nCursor);
			v.db.lastRowid = (long)(pFrame.lastRowid);
			v.nChange = (long)(pFrame.nChange);
			v.db.nChange = (long)(pFrame.nDbChange);
			sqlite3VdbeDeleteAuxData(v.db, v.pAuxData, (int)(-1), (int)(0));
			v.pAuxData = pFrame.pAuxData;
			pFrame.pAuxData = null;
			return (int)(pFrame.pc);
		}
		public static void sqlite3VdbeFreeCursor(Vdbe p, VdbeCursor pCx)
		{
			if ((pCx) == (null))
			{
				return;
			}

			switch (pCx.eCurType)
			{
				case 1:
					{
						sqlite3VdbeSorterClose(p.db, pCx);
						break;
					}

				case 0:
					{

						sqlite3BtreeCloseCursor(pCx.uc.pCursor);
						break;
					}

				case 2:
					{
						sqlite3_vtab_cursor pVCur = pCx.uc.pVCur;
						sqlite3_module pModule = pVCur.pVtab.pModule;

						pVCur.pVtab.nRef--;
						pModule.xClose(pVCur);
						break;
					}
			}
		}
		public static sqlite3_value sqlite3VdbeGetBoundValue(Vdbe v, int iVar, byte aff)
		{

			if ((v) != null)
			{
				sqlite3_value pMem = v.aVar[iVar - 1];

				if ((0) == (pMem.flags & 0x0001))
				{
					sqlite3_value pRet = sqlite3ValueNew(v.db);
					if ((pRet) != null)
					{
						sqlite3VdbeMemCopy(pRet, pMem);
						sqlite3ValueApplyAffinity(pRet, (byte)(aff), (byte)(1));
					}

					return pRet;
				}
			}

			return null;
		}
		public static VdbeOp* sqlite3VdbeGetOp(Vdbe p, int addr)
		{

			if ((addr) < (0))
			{
				addr = (int)(p.nOp - 1);
			}


			if ((p.db.mallocFailed) != 0)
			{
				return &sqlite3VdbeGetOp_dummy;
			}
			else
			{
				return &p.aOp[addr];
			}
		}
		public static int sqlite3VdbeGoto(Vdbe p, int iDest)
		{
			return (int)(sqlite3VdbeAddOp3(p, (int)(11), (int)(0), (int)(iDest), (int)(0)));
		}
		public static int sqlite3VdbeHalt(Vdbe p)
		{
			int rc = 0;
			sqlite3 db = p.db;
			if (p.iVdbeMagic != 0x2df20da3)
			{
				return (int)(0);
			}

			if ((db.mallocFailed) != 0)
			{
				p.rc = (int)(7);
			}

			closeAllCursors(p);
			if (((p.pc) >= (0)) && ((p.bIsReader) != 0))
			{
				int mrc = 0;
				int eStatementOp = (int)(0);
				int isSpecialError = 0;
				sqlite3VdbeEnter(p);
				if ((p.rc) != 0)
				{
					mrc = (int)(p.rc & 0xff);
					isSpecialError = (int)(((((mrc) == (7)) || ((mrc) == (10))) || ((mrc) == (9))) || ((mrc) == (13)) ? 1 : 0);
				}
				else
				{
					mrc = (int)(isSpecialError = (int)(0));
				}

				if ((isSpecialError) != 0)
				{
					if ((p.readOnly == 0) || (mrc != 9))
					{
						if ((((mrc) == (7)) || ((mrc) == (13))) && ((p.usesStmtJournal) != 0))
						{
							eStatementOp = (int)(2);
						}
						else
						{
							sqlite3RollbackAll(db, (int)(4 | (2 << 8)));
							sqlite3CloseSavepoints(db);
							db.autoCommit = (byte)(1);
							p.nChange = (long)(0);
						}
					}
				}

				if (((p.rc) == (0)) || (((p.errorAction) == (3)) && (isSpecialError == 0)))
				{
					sqlite3VdbeCheckFk(p, (int)(0));
				}

				if (((!((((db).nVTrans) > (0)) && (((db).aVTrans) == (null)))) && ((db.autoCommit) != 0)) && ((db.nVdbeWrite) == ((p.readOnly) == (0))))
				{
					if (((p.rc) == (0)) || (((p.errorAction) == (3)) && (isSpecialError == 0)))
					{
						rc = (int)(sqlite3VdbeCheckFk(p, (int)(1)));
						if (rc != 0)
						{
							if ((p.readOnly) != 0)
							{
								sqlite3VdbeLeave(p);
								return (int)(1);
							}

							rc = (int)(19 | (3 << 8));
						}
						else if ((db.flags & ((ulong)(0x00002) << 32)) != 0)
						{
							rc = (int)(11);
							db.flags &= (ulong)(~((ulong)(0x00002) << 32));
						}
						else
						{
							rc = (int)(vdbeCommit(db, p));
						}

						if (((rc) == (5)) && ((p.readOnly) != 0))
						{
							sqlite3VdbeLeave(p);
							return (int)(5);
						}
						else if (rc != 0)
						{
							p.rc = (int)(rc);
							sqlite3RollbackAll(db, (int)(0));
							p.nChange = (long)(0);
						}
						else
						{
							db.nDeferredCons = (long)(0);
							db.nDeferredImmCons = (long)(0);
							db.flags &= (ulong)(~(ulong)(0x00080000));
							sqlite3CommitInternalChanges(db);
						}
					}
					else
					{
						sqlite3RollbackAll(db, (int)(0));
						p.nChange = (long)(0);
					}

					db.nStatement = (int)(0);
				}
				else if ((eStatementOp) == (0))
				{
					if (((p.rc) == (0)) || ((p.errorAction) == (3)))
					{
						eStatementOp = (int)(1);
					}
					else if ((p.errorAction) == (2))
					{
						eStatementOp = (int)(2);
					}
					else
					{
						sqlite3RollbackAll(db, (int)(4 | (2 << 8)));
						sqlite3CloseSavepoints(db);
						db.autoCommit = (byte)(1);
						p.nChange = (long)(0);
					}
				}

				if ((eStatementOp) != 0)
				{
					rc = (int)(sqlite3VdbeCloseStatement(p, (int)(eStatementOp)));
					if ((rc) != 0)
					{
						if (((p.rc) == (0)) || ((p.rc & 0xff) == (19)))
						{
							p.rc = (int)(rc);
							sqlite3DbFree(db, p.zErrMsg);
							p.zErrMsg = null;
						}

						sqlite3RollbackAll(db, (int)(4 | (2 << 8)));
						sqlite3CloseSavepoints(db);
						db.autoCommit = (byte)(1);
						p.nChange = (long)(0);
					}
				}

				if ((p.changeCntOn) != 0)
				{
					if (eStatementOp != 2)
					{
						sqlite3VdbeSetChanges(db, (long)(p.nChange));
					}
					else
					{
						sqlite3VdbeSetChanges(db, (long)(0));
					}

					p.nChange = (long)(0);
				}

				sqlite3VdbeLeave(p);
			}

			if ((p.pc) >= (0))
			{
				db.nVdbeActive--;
				if (p.readOnly == 0)
					db.nVdbeWrite--;
				if ((p.bIsReader) != 0)
					db.nVdbeRead--;



			}

			p.iVdbeMagic = (uint)(0x319c2973);
			if ((db.mallocFailed) != 0)
			{
				p.rc = (int)(7);
			}

			if ((db.autoCommit) != 0)
			{
			}


			return (int)((p.rc) == (5) ? 5 : 0);
		}
		public static int sqlite3VdbeHasSubProgram(Vdbe pVdbe)
		{
			return (int)(pVdbe.pProgram != null);
		}
		public static int sqlite3VdbeIdxKeyCompare(sqlite3 db, VdbeCursor pC, UnpackedRecord pUnpacked, int* res)
		{
			long nCellKey = (long)(0);
			int rc = 0;
			BtCursor pCur;
			sqlite3_value m = new sqlite3_value();

			pCur = pC.uc.pCursor;

			nCellKey = (long)(sqlite3BtreePayloadSize(pCur));
			if (((nCellKey) <= (0)) || ((nCellKey) > (0x7fffffff)))
			{
				*res = (int)(0);
				return (int)(sqlite3CorruptError((int)(84802)));
			}

			sqlite3VdbeMemInit(m, db, (ushort)(0));
			rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			*res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(m.n), m.z, pUnpacked, (int)(0)));
			sqlite3VdbeMemRelease(m);
			return (int)(0);
		}
		public static int sqlite3VdbeIdxRowid(sqlite3 db, BtCursor pCur, long* rowid)
		{
			long nCellKey = (long)(0);
			int rc = 0;
			uint szHdr = 0;
			uint typeRowid = 0;
			uint lenRowid = 0;
			sqlite3_value m = new sqlite3_value(); sqlite3_value v = new sqlite3_value();

			nCellKey = (long)(sqlite3BtreePayloadSize(pCur));

			sqlite3VdbeMemInit(m, db, (ushort)(0));
			rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pCur, (uint)(nCellKey), m));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			szHdr = ((uint)(*((byte*)(m.z))));
			if ((szHdr) >= (0x80))
				sqlite3GetVarint32(((byte*)(m.z)), &(szHdr));

			if ((((szHdr) < (3)) || ((szHdr) > ((uint)(m.n)))))
			{
				goto idx_rowid_corruption;
			}

			typeRowid = ((uint)(*((byte*)(&m.z[szHdr - 1]))));
			if ((typeRowid) >= (0x80))
				sqlite3GetVarint32(((byte*)(&m.z[szHdr - 1])), &(typeRowid));
			if (((((typeRowid) < (1)) || ((typeRowid) > (9))) || ((typeRowid) == (7))))
			{
				goto idx_rowid_corruption;
			}

			lenRowid = (uint)(sqlite3SmallTypeSizes[typeRowid]);
			if ((((uint)(m.n)) < (szHdr + lenRowid)))
			{
				goto idx_rowid_corruption;
			}

			sqlite3VdbeSerialGet((byte*)(&m.z[m.n - lenRowid]), (uint)(typeRowid), v);
			*rowid = (long)(v.u.i);
			sqlite3VdbeMemRelease(m);
			return (int)(0);
		idx_rowid_corruption:
			;
			sqlite3VdbeMemRelease(m);
			return (int)(sqlite3CorruptError((int)(84769)));
		}
		public static void sqlite3VdbeIntegerAffinity(sqlite3_value pMem)
		{
			long ix = 0;





			ix = (long)(doubleToInt64((double)(pMem.u.r)));
			if ((((pMem.u.r) == (ix)) && ((ix) > (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))) && ((ix) < (0xffffffff | (((long)(0x7fffffff)) << 32))))
			{
				pMem.u.i = (long)(ix);
				((pMem).flags = (ushort)(((pMem).flags & ~(0xc1bf | 0x4000)) | 0x0004));
			}
		}
		public static long sqlite3VdbeIntValue(sqlite3_value pMem)
		{
			int flags = 0;



			flags = (int)(pMem.flags);
			if ((flags & (0x0004 | 0x0020)) != 0)
			{
				return (long)(pMem.u.i);
			}
			else if ((flags & 0x0008) != 0)
			{
				return (long)(doubleToInt64((double)(pMem.u.r)));
			}
			else if (((flags & (0x0002 | 0x0010)) != 0) && (pMem.z != null))
			{
				return (long)(memIntValue(pMem));
			}
			else
			{
				return (long)(0);
			}
		}
		public static void sqlite3VdbeJumpHere(Vdbe p, int addr)
		{
			sqlite3VdbeChangeP2(p, (int)(addr), (int)(p.nOp));
		}
		public static void sqlite3VdbeJumpHereOrPopInst(Vdbe p, int addr)
		{
			if ((addr) == (p.nOp - 1))
			{


				p.nOp--;
			}
			else
			{
				sqlite3VdbeChangeP2(p, (int)(addr), (int)(p.nOp));
			}
		}
		public static void sqlite3VdbeLeave(Vdbe p)
		{
			if ((p.lockMask) == (0))
				return;
			vdbeLeave(p);
		}
		public static void sqlite3VdbeLinkSubProgram(Vdbe pVdbe, SubProgram* p)
		{
			p->pNext = pVdbe.pProgram;
			pVdbe.pProgram = p;
		}
		public static int sqlite3VdbeList(Vdbe p)
		{
			sqlite3_value pSub = null;
			sqlite3 db = p.db;
			int i = 0;
			int rc = (int)(0);
			sqlite3_value pMem = p.aMem[1];
			int bListSubprogs = (int)((((p.explain) == (1)) || ((db.flags & 0x01000000) != 0)) ? 1 : 0);
			VdbeOp* aOp;
			VdbeOp* pOp;



			releaseMemArray(pMem, (int)(8));
			p.pResultSet = null;
			if ((p.rc) == (7))
			{
				sqlite3OomFault(db);
				return (int)(1);
			}

			if ((bListSubprogs) != 0)
			{

				pSub = p.aMem[9];
			}
			else
			{
				pSub = null;
			}

			rc = (int)(sqlite3VdbeNextOpcode(p, pSub, ((p.explain) == (2) ? 1 : 0), &p.pc, &i, &aOp));
			if ((rc) == (0))
			{
				pOp = aOp + i;
				if ((0) != 0)
				{
					p.rc = (int)(9);
					rc = (int)(1);
					sqlite3VdbeError(p, sqlite3ErrStr((int)(p.rc)));
				}
				else
				{
					sbyte* zP4 = sqlite3VdbeDisplayP4(db, pOp);
					if ((p.explain) == (2))
					{
						sqlite3VdbeMemSetInt64(pMem, (long)(pOp->p1));
						sqlite3VdbeMemSetInt64(pMem[1], (long)(pOp->p2));
						sqlite3VdbeMemSetInt64(pMem[2], (long)(pOp->p3));
						sqlite3VdbeMemSetStr(pMem[3], zP4, (long)(-1), (byte)(1), sqlite3_free);
						p.nResColumn = (ushort)(4);
					}
					else
					{
						sqlite3VdbeMemSetInt64(pMem[0], (long)(i));
						sqlite3VdbeMemSetStr(pMem[1], sqlite3OpcodeName((int)(pOp->opcode)), (long)(-1), (byte)(1), null);
						sqlite3VdbeMemSetInt64(pMem[2], (long)(pOp->p1));
						sqlite3VdbeMemSetInt64(pMem[3], (long)(pOp->p2));
						sqlite3VdbeMemSetInt64(pMem[4], (long)(pOp->p3));
						sqlite3VdbeMemSetInt64(pMem[6], (long)(pOp->p5));
						sqlite3VdbeMemSetNull(pMem[7]);
						sqlite3VdbeMemSetStr(pMem[5], zP4, (long)(-1), (byte)(1), sqlite3_free);
						p.nResColumn = (ushort)(8);
					}

					p.pResultSet = pMem;
					if ((db.mallocFailed) != 0)
					{
						p.rc = (int)(7);
						rc = (int)(1);
					}
					else
					{
						p.rc = (int)(0);
						rc = (int)(100);
					}
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeLoadString(Vdbe p, int iDest, sbyte* zStr)
		{
			return (int)(sqlite3VdbeAddOp4(p, (int)(117), (int)(0), (int)(iDest), (int)(0), zStr, (int)(0)));
		}
		public static int sqlite3VdbeMakeLabel(Parse pParse)
		{
			return (int)(--pParse.nLabel);
		}
		public static void sqlite3VdbeMakeReady(Vdbe p, Parse pParse)
		{
			sqlite3 db;
			int nVar = 0;
			int nMem = 0;
			int nCursor = 0;
			int nArg = 0;
			int n = 0;
			ReusableSpace x = new ReusableSpace();





			p.pVList = pParse.pVList;
			pParse.pVList = null;
			db = p.db;

			nVar = (int)(pParse.nVar);
			nMem = (int)(pParse.nMem);
			nCursor = (int)(pParse.nTab);
			nArg = (int)(pParse.nMaxArg);
			nMem += (int)(nCursor);
			if (((nCursor) == (0)) && ((nMem) > (0)))
				nMem++;
			n = (int)(((sizeof(VdbeOp) * p.nOp) + 7) & ~7);
			x.pSpace = &((byte*)(p.aOp))[n];

			x.nFree = (long)((pParse.szOpAlloc - n) & ~7);


			resolveP2Values(p, &nArg);
			p.usesStmtJournal = (uint)((byte)(((pParse.isMultiWrite) != 0) && ((pParse.mayAbort) != 0)));
			if ((pParse.explain) != 0)
			{
				int iFirst = 0;
				int mx = 0;
				int i = 0;
				if ((nMem) < (10))
					nMem = (int)(10);
				p.explain = (uint)(pParse.explain);
				if ((pParse.explain) == (2))
				{
					sqlite3VdbeSetNumCols(p, (int)(4));
					iFirst = (int)(8);
					mx = (int)(12);
				}
				else
				{
					sqlite3VdbeSetNumCols(p, (int)(8));
					iFirst = (int)(0);
					mx = (int)(8);
				}

				for (i = (int)(iFirst); (i) < (mx); i++)
				{
					sqlite3VdbeSetColName(p, (int)(i - iFirst), (int)(0), sqlite3VdbeMakeReady_azColName[i], null);
				}
			}

			p.expired = (uint)(0);
			x.nNeeded = (long)(0);
			p.aMem = allocSpace(&x, null, (long)(nMem * sizeof(sqlite3_value)));
			p.aVar = allocSpace(&x, null, (long)(nVar * sizeof(sqlite3_value)));
			p.apArg = allocSpace(&x, null, (long)(nArg * sizeof(sqlite3_value)));
			p.apCsr = allocSpace(&x, null, (long)(nCursor * sizeof(VdbeCursor)));
			if ((x.nNeeded) != 0)
			{
				x.pSpace = p.pFree = sqlite3DbMallocRawNN(db, (ulong)(x.nNeeded));
				x.nFree = (long)(x.nNeeded);
				if (db.mallocFailed == 0)
				{
					p.aMem = allocSpace(&x, p.aMem, (long)(nMem * sizeof(sqlite3_value)));
					p.aVar = allocSpace(&x, p.aVar, (long)(nVar * sizeof(sqlite3_value)));
					p.apArg = allocSpace(&x, p.apArg, (long)(nArg * sizeof(sqlite3_value)));
					p.apCsr = allocSpace(&x, p.apCsr, (long)(nCursor * sizeof(VdbeCursor)));
				}
			}

			if ((db.mallocFailed) != 0)
			{
				p.nVar = (short)(0);
				p.nCursor = (int)(0);
				p.nMem = (int)(0);
			}
			else
			{
				p.nCursor = (int)(nCursor);
				p.nVar = ((short)(nVar));
				initMemArray(p.aVar, (int)(nVar), db, (ushort)(0x0001));
				p.nMem = (int)(nMem);
				initMemArray(p.aMem, (int)(nMem), db, (ushort)(0x0080));
				CRuntime.memset(p.apCsr, (int)(0), (ulong)(nCursor * sizeof(VdbeCursor)));
			}

			sqlite3VdbeRewind(p);
		}
		public static int sqlite3VdbeMemAggValue(sqlite3_value pAccum, sqlite3_value pOut, FuncDef pFunc)
		{
			sqlite3_context ctx = new sqlite3_context();




			CRuntime.memset(ctx, (int)(0), (ulong)(sizeof(sqlite3_context)));
			sqlite3VdbeMemSetNull(pOut);
			ctx.pOut = pOut;
			ctx.pMem = pAccum;
			ctx.pFunc = pFunc;
			pFunc.xValue(ctx);
			return (int)(ctx.isError);
		}
		public static int sqlite3VdbeMemCast(sqlite3_value pMem, byte aff, byte encoding)
		{
			if ((pMem.flags & 0x0001) != 0)
				return (int)(0);
			switch (aff)
			{
				case 0x41:
					{
						if ((pMem.flags & 0x0010) == (0))
						{
							sqlite3ValueApplyAffinity(pMem, (byte)(0x42), (byte)(encoding));

							if ((pMem.flags & 0x0002) != 0)
								((pMem).flags = (ushort)(((pMem).flags & ~(0xc1bf | 0x4000)) | 0x0010));
						}
						else
						{
							pMem.flags &= (ushort)(~(0xc1bf & ~0x0010));
						}

						break;
					}

				case 0x43:
					{
						sqlite3VdbeMemNumerify(pMem);
						break;
					}

				case 0x44:
					{
						sqlite3VdbeMemIntegerify(pMem);
						break;
					}

				case 0x45:
					{
						sqlite3VdbeMemRealify(pMem);
						break;
					}

				default:
					{


						pMem.flags |= (ushort)((pMem.flags & 0x0010) >> 3);
						sqlite3ValueApplyAffinity(pMem, (byte)(0x42), (byte)(encoding));

						pMem.flags &= (ushort)(~(0x0004 | 0x0008 | 0x0020 | 0x0010 | 0x4000));
						return (int)(sqlite3VdbeChangeEncoding(pMem, (int)(encoding)));
					}
			}

			return (int)(0);
		}
		public static int sqlite3VdbeMemClearAndResize(sqlite3_value pMem, int szNew)
		{


			if ((pMem.szMalloc) < (szNew))
			{
				return (int)(sqlite3VdbeMemGrow(pMem, (int)(szNew), (int)(0)));
			}


			pMem.z = pMem.zMalloc;
			pMem.flags &= (ushort)(0x0001 | 0x0004 | 0x0008 | 0x0020);
			return (int)(0);
		}
		public static int sqlite3VdbeMemCopy(sqlite3_value pTo, sqlite3_value pFrom)
		{
			int rc = (int)(0);

			if ((((pTo).flags & (0x2000 | 0x0400)) != 0))
				vdbeMemClearExternAndSetNull(pTo);
			CRuntime.memcpy(pTo, pFrom, ((ulong)(&((0).zMalloc))));
			pTo.flags &= (ushort)(~0x0400);
			if ((pTo.flags & (0x0002 | 0x0010)) != 0)
			{
				if ((0) == (pFrom.flags & 0x0800))
				{
					pTo.flags |= (ushort)(0x1000);
					rc = (int)(sqlite3VdbeMemMakeWriteable(pTo));
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeMemExpandBlob(sqlite3_value pMem)
		{
			int nByte = 0;





			nByte = (int)(pMem.n + pMem.u.nZero);
			if ((nByte) <= (0))
			{
				if ((pMem.flags & 0x0010) == (0))
					return (int)(0);
				nByte = (int)(1);
			}

			if ((sqlite3VdbeMemGrow(pMem, (int)(nByte), (int)(1))) != 0)
			{
				return (int)(7);
			}



			CRuntime.memset(&pMem.z[pMem.n], (int)(0), (ulong)(pMem.u.nZero));
			pMem.n += (int)(pMem.u.nZero);
			pMem.flags &= (ushort)(~(0x4000 | 0x0200));
			return (int)(0);
		}
		public static int sqlite3VdbeMemFinalize(sqlite3_value pMem, FuncDef pFunc)
		{
			sqlite3_context ctx = new sqlite3_context();
			sqlite3_value t = new sqlite3_value();





			CRuntime.memset(ctx, (int)(0), (ulong)(sizeof(sqlite3_context)));
			CRuntime.memset(t, (int)(0), (ulong)(sizeof(sqlite3_value)));
			t.flags = (ushort)(0x0001);
			t.db = pMem.db;
			ctx.pOut = t;
			ctx.pMem = pMem;
			ctx.pFunc = pFunc;
			pFunc.xFinalize(ctx);

			if ((pMem.szMalloc) > (0))
				sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
			CRuntime.memcpy(pMem, t, (ulong)(sizeof(sqlite3_value)));
			return (int)(ctx.isError);
		}
		public static int sqlite3VdbeMemFromBtree(BtCursor pCur, uint offset, uint amt, sqlite3_value pMem)
		{
			int rc = 0;
			pMem.flags = (ushort)(0x0001);
			if ((sqlite3BtreeMaxRecordSize(pCur)) < (offset + amt))
			{
				return (int)(sqlite3CorruptError((int)(79069)));
			}

			if ((0) == (rc = (int)(sqlite3VdbeMemClearAndResize(pMem, (int)(amt + 1)))))
			{
				rc = (int)(sqlite3BtreePayload(pCur, (uint)(offset), (uint)(amt), pMem.z));
				if ((rc) == (0))
				{
					pMem.z[amt] = (sbyte)(0);
					pMem.flags = (ushort)(0x0010);
					pMem.n = ((int)(amt));
				}
				else
				{
					sqlite3VdbeMemRelease(pMem);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeMemFromBtreeZeroOffset(BtCursor pCur, uint amt, sqlite3_value pMem)
		{
			uint available = (uint)(0);
			int rc = (int)(0);



			pMem.z = (sbyte*)(sqlite3BtreePayloadFetch(pCur, &available));

			if ((amt) <= (available))
			{
				pMem.flags = (ushort)(0x0010 | 0x1000);
				pMem.n = ((int)(amt));
			}
			else
			{
				rc = (int)(sqlite3VdbeMemFromBtree(pCur, (uint)(0), (uint)(amt), pMem));
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeMemGrow(sqlite3_value pMem, int n, int bPreserve)
		{




			if ((((pMem.szMalloc) > (0)) && ((bPreserve) != 0)) && ((pMem.z) == (pMem.zMalloc)))
			{
				if ((pMem.db) != null)
				{
					pMem.z = pMem.zMalloc = sqlite3DbReallocOrFree(pMem.db, pMem.z, (ulong)(n));
				}
				else
				{
					pMem.zMalloc = sqlite3Realloc(pMem.z, (ulong)(n));
					if ((pMem.zMalloc) == (null))
						sqlite3_free(pMem.z);
					pMem.z = pMem.zMalloc;
				}

				bPreserve = (int)(0);
			}
			else
			{
				if ((pMem.szMalloc) > (0))
					sqlite3DbFreeNN(pMem.db, pMem.zMalloc);
				pMem.zMalloc = sqlite3DbMallocRaw(pMem.db, (ulong)(n));
			}

			if ((pMem.zMalloc) == (null))
			{
				sqlite3VdbeMemSetNull(pMem);
				pMem.z = null;
				pMem.szMalloc = (int)(0);
				return (int)(7);
			}
			else
			{
				pMem.szMalloc = (int)(sqlite3DbMallocSize(pMem.db, pMem.zMalloc));
			}

			if (((bPreserve) != 0) && ((pMem.z) != null))
			{

				CRuntime.memcpy(pMem.zMalloc, pMem.z, (ulong)(pMem.n));
			}

			if ((pMem.flags & 0x0400) != 0)
			{

				pMem.xDel((void*)(pMem.z));
			}

			pMem.z = pMem.zMalloc;
			pMem.flags &= (ushort)(~(0x0400 | 0x1000 | 0x0800));
			return (int)(0);
		}
		public static int sqlite3VdbeMemHandleBom(sqlite3_value pMem)
		{
			int rc = (int)(0);
			byte bom = (byte)(0);

			if ((pMem.n) > (1))
			{
				byte b1 = (byte)(*(byte*)(pMem.z));
				byte b2 = (byte)(*(((byte*)(pMem.z)) + 1));
				if (((b1) == (0xFE)) && ((b2) == (0xFF)))
				{
					bom = (byte)(3);
				}

				if (((b1) == (0xFF)) && ((b2) == (0xFE)))
				{
					bom = (byte)(2);
				}
			}

			if ((bom) != 0)
			{
				rc = (int)(sqlite3VdbeMemMakeWriteable(pMem));
				if ((rc) == (0))
				{
					pMem.n -= (int)(2);
					CRuntime.memmove(pMem.z, &pMem.z[2], (ulong)(pMem.n));
					pMem.z[pMem.n] = (sbyte)(0);
					pMem.z[pMem.n + 1] = (sbyte)(0);
					pMem.flags |= (ushort)(0x0200);
					pMem.enc = (byte)(bom);
				}
			}

			return (int)(rc);
		}
		public static void sqlite3VdbeMemInit(sqlite3_value pMem, sqlite3 db, ushort flags)
		{

			pMem.flags = (ushort)(flags);
			pMem.db = db;
			pMem.szMalloc = (int)(0);
		}
		public static int sqlite3VdbeMemIntegerify(sqlite3_value pMem)
		{




			pMem.u.i = (long)(sqlite3VdbeIntValue(pMem));
			((pMem).flags = (ushort)(((pMem).flags & ~(0xc1bf | 0x4000)) | 0x0004));
			return (int)(0);
		}
		public static int sqlite3VdbeMemMakeWriteable(sqlite3_value pMem)
		{



			if ((pMem.flags & (0x0002 | 0x0010)) != 0)
			{
				if ((((pMem).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pMem) : 0) != 0)
					return (int)(7);
				if (((pMem.szMalloc) == (0)) || (pMem.z != pMem.zMalloc))
				{
					int rc = (int)(vdbeMemAddTerminator(pMem));
					if ((rc) != 0)
						return (int)(rc);
				}
			}

			pMem.flags &= (ushort)(~0x1000);
			return (int)(0);
		}
		public static void sqlite3VdbeMemMove(sqlite3_value pTo, sqlite3_value pFrom)
		{



			sqlite3VdbeMemRelease(pTo);
			CRuntime.memcpy(pTo, pFrom, (ulong)(sizeof(sqlite3_value)));
			pFrom.flags = (ushort)(0x0001);
			pFrom.szMalloc = (int)(0);
		}
		public static int sqlite3VdbeMemNulTerminate(sqlite3_value pMem)
		{


			if ((pMem.flags & (0x0200 | 0x0002)) != 0x0002)
			{
				return (int)(0);
			}
			else
			{
				return (int)(vdbeMemAddTerminator(pMem));
			}
		}
		public static int sqlite3VdbeMemNumerify(sqlite3_value pMem)
		{

			if ((pMem.flags & (0x0004 | 0x0008 | 0x0020 | 0x0001)) == (0))
			{
				int rc = 0;
				long ix = 0;


				rc = (int)(sqlite3AtoF(pMem.z, &pMem.u.r, (int)(pMem.n), (byte)(pMem.enc)));
				if (((((rc) == (0)) || ((rc) == (1))) && ((sqlite3Atoi64(pMem.z, &ix, (int)(pMem.n), (byte)(pMem.enc))) <= (1))) || ((sqlite3RealSameAsInt((double)(pMem.u.r), (long)(ix = ((long)(pMem.u.r))))) != 0))
				{
					pMem.u.i = (long)(ix);
					((pMem).flags = (ushort)(((pMem).flags & ~(0xc1bf | 0x4000)) | 0x0004));
				}
				else
				{
					((pMem).flags = (ushort)(((pMem).flags & ~(0xc1bf | 0x4000)) | 0x0008));
				}
			}


			pMem.flags &= (ushort)(~(0x0002 | 0x0010 | 0x4000));
			return (int)(0);
		}
		public static int sqlite3VdbeMemRealify(sqlite3_value pMem)
		{



			pMem.u.r = (double)(sqlite3VdbeRealValue(pMem));
			((pMem).flags = (ushort)(((pMem).flags & ~(0xc1bf | 0x4000)) | 0x0008));
			return (int)(0);
		}
		public static void sqlite3VdbeMemRelease(sqlite3_value p)
		{

			if ((((p).flags & (0x2000 | 0x0400)) != 0) || ((p.szMalloc) != 0))
			{
				vdbeMemClear(p);
			}
		}
		public static void sqlite3VdbeMemSetDouble(sqlite3_value pMem, double val)
		{
			sqlite3VdbeMemSetNull(pMem);
			if (sqlite3IsNaN((double)(val)) == 0)
			{
				pMem.u.r = (double)(val);
				pMem.flags = (ushort)(0x0008);
			}
		}
		public static void sqlite3VdbeMemSetInt64(sqlite3_value pMem, long val)
		{
			if ((((pMem).flags & (0x2000 | 0x0400)) != 0))
			{
				vdbeReleaseAndSetInt64(pMem, (long)(val));
			}
			else
			{
				pMem.u.i = (long)(val);
				pMem.flags = (ushort)(0x0004);
			}
		}
		public static void sqlite3VdbeMemSetNull(sqlite3_value pMem)
		{
			if ((((pMem).flags & (0x2000 | 0x0400)) != 0))
			{
				vdbeMemClearExternAndSetNull(pMem);
			}
			else
			{
				pMem.flags = (ushort)(0x0001);
			}
		}
		public static void sqlite3VdbeMemSetPointer(sqlite3_value pMem, void* pPtr, sbyte* zPType, delegate17 xDestructor)
		{

			vdbeMemClear(pMem);
			pMem.u.zPType = (zPType) != 0 ? zPType : "";
			pMem.z = pPtr;
			pMem.flags = (ushort)(0x0001 | 0x0400 | 0x8000 | 0x0200);
			pMem.eSubtype = (byte)(112);
			pMem.xDel = xDestructor ? xDestructor : sqlite3NoopDestructor;
		}
		public static int sqlite3VdbeMemSetRowSet(sqlite3_value pMem)
		{
			sqlite3 db = pMem.db;
			RowSet p;


			sqlite3VdbeMemRelease(pMem);
			p = sqlite3RowSetInit(db);
			if ((p) == (null))
				return (int)(7);
			pMem.z = (sbyte*)(p);
			pMem.flags = (ushort)(0x0010 | 0x0400);
			pMem.xDel = sqlite3RowSetDelete;
			return (int)(0);
		}
		public static int sqlite3VdbeMemSetStr(sqlite3_value pMem, sbyte* z, long n, byte enc, delegate17 xDel)
		{
			long nByte = (long)(n);
			int iLimit = 0;
			ushort flags = (ushort)(0);



			if (z == null)
			{
				sqlite3VdbeMemSetNull(pMem);
				return (int)(0);
			}

			if ((pMem.db) != null)
			{
				iLimit = (int)(pMem.db.aLimit[0]);
			}
			else
			{
				iLimit = (int)(1000000000);
			}

			flags = (ushort)((enc) == (0) ? 0x0010 : 0x0002);
			if ((nByte) < (0))
			{

				if ((enc) == (1))
				{
					nByte = (long)(CRuntime.strlen(z));
				}
				else
				{
					for (nByte = (long)(0); ((nByte) <= (iLimit)) && ((z[nByte] | z[nByte + 1]) != 0); nByte += (long)(2))
					{
					}
				}

				flags |= (ushort)(0x0200);
			}

			if ((xDel) == ((Void(Void * ))(-1)))
			{
				long nAlloc = (long)(nByte);
				if ((flags & 0x0200) != 0)
				{
					nAlloc += (long)((enc) == (1) ? 1 : 2);
				}

				if ((nByte) > (iLimit))
				{
					return (int)(sqlite3ErrorToParser(pMem.db, (int)(18)));
				}

				if ((sqlite3VdbeMemClearAndResize(pMem, (int)((nAlloc) > (32) ? (nAlloc) : (32)))) != 0)
				{
					return (int)(7);
				}

				CRuntime.memcpy(pMem.z, z, (ulong)(nAlloc));
			}
			else
			{
				sqlite3VdbeMemRelease(pMem);
				pMem.z = z;
				if ((xDel) == ((Void(Void * ))(sqlite3OomFault)))
				{
					pMem.zMalloc = pMem.z;
					pMem.szMalloc = (int)(sqlite3DbMallocSize(pMem.db, pMem.zMalloc));
				}
				else
				{
					pMem.xDel = xDel;
					flags |= (ushort)(((xDel) == null) ? 0x0800 : 0x0400);
				}
			}

			pMem.n = ((int)(nByte & 0x7fffffff));
			pMem.flags = (ushort)(flags);
			if ((enc) != 0)
			{
				pMem.enc = (byte)(enc);
			}
			else
			{

				pMem.enc = (byte)((pMem.db).enc);
			}

			if (((enc) > (1)) && ((sqlite3VdbeMemHandleBom(pMem)) != 0))
			{
				return (int)(7);
			}

			if ((nByte) > (iLimit))
			{
				return (int)(sqlite3ErrorToParser(pMem.db, (int)(18)));
			}

			return (int)(0);
		}
		public static void sqlite3VdbeMemSetZeroBlob(sqlite3_value pMem, int n)
		{
			sqlite3VdbeMemRelease(pMem);
			pMem.flags = (ushort)(0x0010 | 0x4000);
			pMem.n = (int)(0);
			if ((n) < (0))
				n = (int)(0);
			pMem.u.nZero = (int)(n);
			pMem.enc = (byte)(1);
			pMem.z = null;
		}
		public static void sqlite3VdbeMemShallowCopy(sqlite3_value pTo, sqlite3_value pFrom, int srcType)
		{


			if ((((pTo).flags & (0x2000 | 0x0400)) != 0))
			{
				vdbeClrCopy(pTo, pFrom, (int)(srcType));
				return;
			}

			CRuntime.memcpy(pTo, pFrom, ((ulong)(&((0).zMalloc))));
			if ((pFrom.flags & 0x0800) == (0))
			{
				pTo.flags &= (ushort)(~(0x0400 | 0x0800 | 0x1000));

				pTo.flags |= (ushort)(srcType);
			}
		}
		public static int sqlite3VdbeMemStringify(sqlite3_value pMem, byte enc, byte bForce)
		{
			int nByte = (int)(32);







			if ((sqlite3VdbeMemClearAndResize(pMem, (int)(nByte))) != 0)
			{
				pMem.enc = (byte)(0);
				return (int)(7);
			}

			vdbeMemRenderNum((int)(nByte), pMem.z, pMem);

			pMem.n = (int)(CRuntime.strlen(pMem.z) & 0x3fffffff);
			pMem.enc = (byte)(1);
			pMem.flags |= (ushort)(0x0002 | 0x0200);
			if ((bForce) != 0)
				pMem.flags &= (ushort)(~(0x0004 | 0x0008 | 0x0020));
			sqlite3VdbeChangeEncoding(pMem, (int)(enc));
			return (int)(0);
		}
		public static int sqlite3VdbeMemTooBig(sqlite3_value p)
		{

			if ((p.flags & (0x0002 | 0x0010)) != 0)
			{
				int n = (int)(p.n);
				if ((p.flags & 0x4000) != 0)
				{
					n += (int)(p.u.nZero);
				}

				return ((n) > (p.db.aLimit[0]) ? 1 : 0);
			}

			return (int)(0);
		}
		public static int sqlite3VdbeMemTranslate(sqlite3_value pMem, byte desiredEnc)
		{
			long len = 0;
			byte* zOut;
			byte* zIn;
			byte* zTerm;
			byte* z;
			uint c = 0;





			if ((pMem.enc != 1) && (desiredEnc != 1))
			{
				byte temp = 0;
				int rc = 0;
				rc = (int)(sqlite3VdbeMemMakeWriteable(pMem));
				if (rc != 0)
				{

					return (int)(7);
				}

				zIn = (byte*)(pMem.z);
				zTerm = &zIn[pMem.n & ~1];
				while ((zIn) < (zTerm))
				{
					temp = (byte)(*zIn);
					*zIn = (byte)(*(zIn + 1));
					zIn++;
					*zIn++ = (byte)(temp);
				}

				pMem.enc = (byte)(desiredEnc);
				goto translate_out;
			}

			if ((desiredEnc) == (1))
			{
				pMem.n &= (int)(~1);
				len = (long)(2 * (long)(pMem.n) + 1);
			}
			else
			{
				len = (long)(2 * (long)(pMem.n) + 2);
			}

			zIn = (byte*)(pMem.z);
			zTerm = &zIn[pMem.n];
			zOut = sqlite3DbMallocRaw(pMem.db, (ulong)(len));
			if (zOut == null)
			{
				return (int)(7);
			}

			z = zOut;
			if ((pMem.enc) == (1))
			{
				if ((desiredEnc) == (2))
				{
					while ((zIn) < (zTerm))
					{
						c = (uint)(*(zIn++));
						if ((c) >= (0xc0))
						{
							c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
							while ((zIn != zTerm) && ((*zIn & 0xc0) == (0x80)))
							{
								c = (uint)((c << 6) + (0x3f & *(zIn++)));
							}

							if ((((c) < (0x80)) || ((c & 0xFFFFF800) == (0xD800))) || ((c & 0xFFFFFFFE) == (0xFFFE)))
							{
								c = (uint)(0xFFFD);
							}
						}

						{
							if ((c) <= (0xFFFF))
							{
								*z++ = ((byte)(c & 0x00FF));
								*z++ = ((byte)((c >> 8) & 0x00FF));
							}
							else
							{
								*z++ = ((byte)(((c >> 10) & 0x003F) + (((c - 0x10000) >> 10) & 0x00C0)));
								*z++ = ((byte)(0x00D8 + (((c - 0x10000) >> 18) & 0x03)));
								*z++ = ((byte)(c & 0x00FF));
								*z++ = ((byte)(0x00DC + ((c >> 8) & 0x03)));
							}
						}
					}
				}
				else
				{

					while ((zIn) < (zTerm))
					{
						c = (uint)(*(zIn++));
						if ((c) >= (0xc0))
						{
							c = (uint)(sqlite3Utf8Trans1[c - 0xc0]);
							while ((zIn != zTerm) && ((*zIn & 0xc0) == (0x80)))
							{
								c = (uint)((c << 6) + (0x3f & *(zIn++)));
							}

							if ((((c) < (0x80)) || ((c & 0xFFFFF800) == (0xD800))) || ((c & 0xFFFFFFFE) == (0xFFFE)))
							{
								c = (uint)(0xFFFD);
							}
						}

						{
							if ((c) <= (0xFFFF))
							{
								*z++ = ((byte)((c >> 8) & 0x00FF));
								*z++ = ((byte)(c & 0x00FF));
							}
							else
							{
								*z++ = ((byte)(0x00D8 + (((c - 0x10000) >> 18) & 0x03)));
								*z++ = ((byte)(((c >> 10) & 0x003F) + (((c - 0x10000) >> 10) & 0x00C0)));
								*z++ = ((byte)(0x00DC + ((c >> 8) & 0x03)));
								*z++ = ((byte)(c & 0x00FF));
							}
						}
					}
				}

				pMem.n = ((int)(z - zOut));
				*z++ = (byte)(0);
			}
			else
			{

				if ((pMem.enc) == (2))
				{
					while ((zIn) < (zTerm))
					{
						c = (uint)(*(zIn++));
						c += (uint)((*(zIn++)) << 8);
						if (((c) >= (0xd800)) && ((c) < (0xe000)))
						{
							if ((zIn) < (zTerm))
							{
								int c2 = (int)(*zIn++);
								c2 += (int)((*zIn++) << 8);
								c = (uint)((c2 & 0x03FF) + ((c & 0x003F) << 10) + (((c & 0x03C0) + 0x0040) << 10));
							}
						}

						{
							if ((c) < (0x00080))
							{
								*z++ = ((byte)(c & 0xFF));
							}
							else if ((c) < (0x00800))
							{
								*z++ = (byte)(0xC0 + (byte)((c >> 6) & 0x1F));
								*z++ = (byte)(0x80 + (byte)(c & 0x3F));
							}
							else if ((c) < (0x10000))
							{
								*z++ = (byte)(0xE0 + (byte)((c >> 12) & 0x0F));
								*z++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
								*z++ = (byte)(0x80 + (byte)(c & 0x3F));
							}
							else
							{
								*z++ = (byte)(0xF0 + (byte)((c >> 18) & 0x07));
								*z++ = (byte)(0x80 + (byte)((c >> 12) & 0x3F));
								*z++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
								*z++ = (byte)(0x80 + (byte)(c & 0x3F));
							}
						}
					}
				}
				else
				{
					while ((zIn) < (zTerm))
					{
						c = (uint)((*(zIn++)) << 8);
						c += (uint)(*(zIn++));
						if (((c) >= (0xd800)) && ((c) < (0xe000)))
						{
							if ((zIn) < (zTerm))
							{
								int c2 = (int)((*zIn++) << 8);
								c2 += (int)(*zIn++);
								c = (uint)((c2 & 0x03FF) + ((c & 0x003F) << 10) + (((c & 0x03C0) + 0x0040) << 10));
							}
						}

						{
							if ((c) < (0x00080))
							{
								*z++ = ((byte)(c & 0xFF));
							}
							else if ((c) < (0x00800))
							{
								*z++ = (byte)(0xC0 + (byte)((c >> 6) & 0x1F));
								*z++ = (byte)(0x80 + (byte)(c & 0x3F));
							}
							else if ((c) < (0x10000))
							{
								*z++ = (byte)(0xE0 + (byte)((c >> 12) & 0x0F));
								*z++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
								*z++ = (byte)(0x80 + (byte)(c & 0x3F));
							}
							else
							{
								*z++ = (byte)(0xF0 + (byte)((c >> 18) & 0x07));
								*z++ = (byte)(0x80 + (byte)((c >> 12) & 0x3F));
								*z++ = (byte)(0x80 + (byte)((c >> 6) & 0x3F));
								*z++ = (byte)(0x80 + (byte)(c & 0x3F));
							}
						}
					}
				}

				pMem.n = ((int)(z - zOut));
			}

			*z = (byte)(0);

			c = (uint)(0x0002 | 0x0200 | (pMem.flags & (0x003f | 0x8000)));
			sqlite3VdbeMemRelease(pMem);
			pMem.flags = (ushort)(c);
			pMem.enc = (byte)(desiredEnc);
			pMem.z = (sbyte*)(zOut);
			pMem.zMalloc = pMem.z;
			pMem.szMalloc = (int)(sqlite3DbMallocSize(pMem.db, pMem.z));
		translate_out:
			; return (int)(0);
		}
		public static void sqlite3VdbeMultiLoad(Vdbe p, int iDest, sbyte* zTypes)
		{
			sbyte* ap;
			int i = 0;
			sbyte c = 0;
			(__va_start(&ap, zTypes));
			for (i = (int)(0); (c = (sbyte)(zTypes[i])) != 0; i++)
			{
				if ((c) == (115))
				{
					sbyte* z = (((() > ()) || ((&(-1)) != 0)) ? **(sbyte***)((ap += ) - ) : *(sbyte**)((ap += ) - ));
					sqlite3VdbeAddOp4(p, (int)((z) == (null) ? 74 : 117), (int)(0), (int)(iDest + i), (int)(0), z, (int)(0));
				}
				else if ((c) == (105))
				{
					sqlite3VdbeAddOp2(p, (int)(71), (int)(((() > ()) || ((&(-1)) != 0)) ? **(int**)((ap += ) - ) : *(int*)((ap += ) - )), (int)(iDest + i));
				}
				else
				{
					goto skip_op_resultrow;
				}
			}

			sqlite3VdbeAddOp2(p, (int)(83), (int)(iDest), (int)(i));
		skip_op_resultrow:
			; ((void)(ap = null));
		}
		public static int sqlite3VdbeNextOpcode(Vdbe p, sqlite3_value pSub, int eMode, int* piPc, int* piAddr, VdbeOp** paOp)
		{
			int nRow = 0;
			int nSub = (int)(0);
			SubProgram** apSub = null;
			int i = 0;
			int rc = (int)(0);
			VdbeOp* aOp = null;
			int iPc = 0;
			nRow = (int)(p.nOp);
			if (pSub != null)
			{
				if ((pSub.flags & 0x0010) != 0)
				{
					nSub = (int)(pSub.n / sizeof(Vdbe));
					apSub = (SubProgram**)(pSub.z);
				}

				for (i = (int)(0); (i) < (nSub); i++)
				{
					nRow += (int)(apSub[i]->nOp);
				}
			}

			iPc = (int)(*piPc);
			while ((1) != 0)
			{
				i = (int)(iPc++);
				if ((i) >= (nRow))
				{
					p.rc = (int)(0);
					rc = (int)(101);
					break;
				}

				if ((i) < (p.nOp))
				{
					aOp = p.aOp;
				}
				else
				{
					int j = 0;
					i -= (int)(p.nOp);


					for (j = (int)(0); (i) >= (apSub[j]->nOp); j++)
					{
						i -= (int)(apSub[j]->nOp);

					}

					aOp = apSub[j]->aOp;
				}

				if ((pSub != null) && ((aOp[i].p4type) == (-4)))
				{
					int nByte = (int)((nSub + 1) * sizeof(SubProgram));
					int j = 0;
					for (j = (int)(0); (j) < (nSub); j++)
					{
						if ((apSub[j]) == (aOp[i].p4.pProgram))
							break;
					}

					if ((j) == (nSub))
					{
						p.rc = (int)(sqlite3VdbeMemGrow(pSub, (int)(nByte), (int)(nSub != 0)));
						if (p.rc != 0)
						{
							rc = (int)(1);
							break;
						}

						apSub = (SubProgram**)(pSub.z);
						apSub[nSub++] = aOp[i].p4.pProgram;
						((pSub).flags = (ushort)(((pSub).flags & ~(0xc1bf | 0x4000)) | 0x0010));
						pSub.n = (int)(nSub * sizeof(SubProgram));
						nRow += (int)(aOp[i].p4.pProgram->nOp);
					}
				}

				if ((eMode) == (0))
					break;
				{

					if ((aOp[i].opcode) == (183))
						break;
					if (((aOp[i].opcode) == (64)) && ((iPc) > (1)))
						break;
				}
			}

			*piPc = (int)(iPc);
			*piAddr = (int)(i);
			*paOp = aOp;
			return (int)(rc);
		}
		public static byte sqlite3VdbeOneByteSerialTypeLen(byte serial_type)
		{

			return (byte)(sqlite3SmallTypeSizes[serial_type]);
		}
		public static int sqlite3VdbeParameterIndex(Vdbe p, sbyte* zName, int nName)
		{
			if (((p) == (null)) || ((zName) == (null)))
				return (int)(0);
			return (int)(sqlite3VListNameToNum(p.pVList, zName, (int)(nName)));
		}
		public static Parse sqlite3VdbeParser(Vdbe p)
		{
			return p.pParse;
		}
		public static byte sqlite3VdbePrepareFlags(Vdbe v)
		{
			return (byte)(v.prepFlags);
		}
		public static double sqlite3VdbeRealValue(sqlite3_value pMem)
		{



			if ((pMem.flags & 0x0008) != 0)
			{
				return (double)(pMem.u.r);
			}
			else if ((pMem.flags & (0x0004 | 0x0020)) != 0)
			{
				return (double)(pMem.u.i);
			}
			else if ((pMem.flags & (0x0002 | 0x0010)) != 0)
			{
				return (double)(memRealValue(pMem));
			}
			else
			{
				return (double)(0);
			}
		}
		public static int sqlite3VdbeRecordCompare(int nKey1, void* pKey1, UnpackedRecord pPKey2)
		{
			return (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(0)));
		}
		public static int sqlite3VdbeRecordCompareWithSkip(int nKey1, void* pKey1, UnpackedRecord pPKey2, int bSkip)
		{
			uint d1 = 0;
			int i = 0;
			uint szHdr1 = 0;
			uint idx1 = 0;
			int rc = (int)(0);
			sqlite3_value pRhs = pPKey2.aMem;
			KeyInfo pKeyInfo;
			byte* aKey1 = (byte*)(pKey1);
			sqlite3_value mem1 = new sqlite3_value();
			if ((bSkip) != 0)
			{
				uint s1 = 0;
				idx1 = (uint)(1 + (byte)(((*(&aKey1[1])) < ((byte)(0x80))) ? ((s1) = ((uint)(*(&aKey1[1])))), 1 : 
        sqlite3GetVarint32((&aKey1[1]), &(s1)) ) )
        ;
				szHdr1 = (uint)(aKey1[0]);
				d1 = (uint)(szHdr1 + sqlite3VdbeSerialTypeLen((uint)(s1)));
				i = (int)(1);
				pRhs++;
			}

			else
			{
				idx1 = (uint)((byte)(((*(aKey1)) < ((byte)(0x80))) ? ((szHdr1) = ((uint)(*(aKey1)))), 1 : 
        sqlite3GetVarint32((aKey1), &(szHdr1)) ) )
        ;
				d1 = (uint)(szHdr1);
				i = (int)(0);
			}

			if ((d1) > ((uint)(nKey1)))
			{
				pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84312))));
				return (int)(0);
			}





			do
			{
				uint serial_type = 0;
				if ((pRhs.flags & (0x0004 | 0x0020)) != 0)
				{
					serial_type = (uint)(aKey1[idx1]);
					if ((serial_type) >= (10))
					{
						rc = (int)(+1);
					}
					else if ((serial_type) == (0))
					{
						rc = (int)(-1);
					}
					else if ((serial_type) == (7))
					{
						sqlite3VdbeSerialGet(&aKey1[d1], (uint)(serial_type), mem1);
						rc = (int)(-sqlite3IntFloatCompare((long)(pRhs.u.i), (double)(mem1.u.r)));
					}
					else
					{
						long lhs = (long)(vdbeRecordDecodeInt((uint)(serial_type), &aKey1[d1]));
						long rhs = (long)(pRhs.u.i);
						if ((lhs) < (rhs))
						{
							rc = (int)(-1);
						}
						else if ((lhs) > (rhs))
						{
							rc = (int)(+1);
						}
					}
				}
				else if ((pRhs.flags & 0x0008) != 0)
				{
					serial_type = (uint)(aKey1[idx1]);
					if ((serial_type) >= (10))
					{
						rc = (int)(+1);
					}
					else if ((serial_type) == (0))
					{
						rc = (int)(-1);
					}
					else
					{
						sqlite3VdbeSerialGet(&aKey1[d1], (uint)(serial_type), mem1);
						if ((serial_type) == (7))
						{
							if ((mem1.u.r) < (pRhs.u.r))
							{
								rc = (int)(-1);
							}
							else if ((mem1.u.r) > (pRhs.u.r))
							{
								rc = (int)(+1);
							}
						}
						else
						{
							rc = (int)(sqlite3IntFloatCompare((long)(mem1.u.i), (double)(pRhs.u.r)));
						}
					}
				}
				else if ((pRhs.flags & 0x0002) != 0)
				{
					serial_type = ((uint)(*(&aKey1[idx1])));
					if ((serial_type) >= (0x80))
						sqlite3GetVarint32((&aKey1[idx1]), &(serial_type));
					if ((serial_type) < (12))
					{
						rc = (int)(-1);
					}
					else if ((serial_type & 0x01) == 0)
					{
						rc = (int)(+1);
					}
					else
					{
						mem1.n = (int)((serial_type - 12) / 2);
						if (((d1 + mem1.n) > ((uint)(nKey1))) || (((pKeyInfo = pPKey2.pKeyInfo).nAllField) <= (i)))
						{
							pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84389))));
							return (int)(0);
						}
						else if ((pKeyInfo.aColl[i]) != null)
						{
							mem1.enc = (byte)(pKeyInfo.enc);
							mem1.db = pKeyInfo.db;
							mem1.flags = (ushort)(0x0002);
							mem1.z = (sbyte*)(&aKey1[d1]);
							rc = (int)(vdbeCompareMemString(mem1, pRhs, pKeyInfo.aColl[i], &pPKey2.errCode));
						}
						else
						{
							int nCmp = (int)((mem1.n) < (pRhs.n) ? (mem1.n) : (pRhs.n));
							rc = (int)(memcmp(&aKey1[d1], pRhs.z, (ulong)(nCmp)));
							if ((rc) == (0))
								rc = (int)(mem1.n - pRhs.n);
						}
					}
				}
				else if ((pRhs.flags & 0x0010) != 0)
				{

					serial_type = ((uint)(*(&aKey1[idx1])));
					if ((serial_type) >= (0x80))
						sqlite3GetVarint32((&aKey1[idx1]), &(serial_type));
					if (((serial_type) < (12)) || ((serial_type & 0x01) != 0))
					{
						rc = (int)(-1);
					}
					else
					{
						int nStr = (int)((serial_type - 12) / 2);
						if ((d1 + nStr) > ((uint)(nKey1)))
						{
							pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84419))));
							return (int)(0);
						}
						else if ((pRhs.flags & 0x4000) != 0)
						{
							if (isAllZero((sbyte*)(&aKey1[d1]), (int)(nStr)) == 0)
							{
								rc = (int)(1);
							}
							else
							{
								rc = (int)(nStr - pRhs.u.nZero);
							}
						}
						else
						{
							int nCmp = (int)((nStr) < (pRhs.n) ? (nStr) : (pRhs.n));
							rc = (int)(memcmp(&aKey1[d1], pRhs.z, (ulong)(nCmp)));
							if ((rc) == (0))
								rc = (int)(nStr - pRhs.n);
						}
					}
				}
				else
				{
					serial_type = (uint)(aKey1[idx1]);
					rc = (int)(serial_type != 0);
				}

				if (rc != 0)
				{
					int sortFlags = (int)(pPKey2.pKeyInfo.aSortFlags[i]);
					if ((sortFlags) != 0)
					{
						if (((sortFlags & 0x02) == (0)) || ((sortFlags & 0x01) != (((serial_type) == (0)) || ((pRhs.flags & 0x0001) != 0))))
						{
							rc = (int)(-rc);
						}
					}



					return (int)(rc);
				}

				i++;
				if ((i) == (pPKey2.nField))
					break;
				pRhs++;
				d1 += (uint)(sqlite3VdbeSerialTypeLen((uint)(serial_type)));
				idx1 += (uint)(sqlite3VarintLen((ulong)(serial_type)));
			}
			while (((idx1) < (szHdr1)) && ((d1) <= ((uint)(nKey1))));


			pPKey2.eqSeen = (byte)(1);
			return (int)(pPKey2.default_rc);
		}
		public static void sqlite3VdbeRecordUnpack(KeyInfo pKeyInfo, int nKey, void* pKey, UnpackedRecord p)
		{
			byte* aKey = (byte*)(pKey);
			uint d = 0;
			uint idx = 0;
			ushort u = 0;
			uint szHdr = 0;
			sqlite3_value pMem = p.aMem;
			p.default_rc = (sbyte)(0);

			idx = (uint)((byte)(((*(aKey)) < ((byte)(0x80))) ? ((szHdr) = ((uint)(*(aKey)))), 1 :  sqlite3GetVarint32((aKey), &(szHdr)) ) ) ;
			d = (uint)(szHdr);
			u = (ushort)(0);
			while (((idx) < (szHdr)) && ((d) <= ((uint)(nKey))))
			{
				uint serial_type = 0;
				idx += (uint)((byte)(((*(&aKey[idx])) < ((byte)(0x80))) ? ((serial_type) = ((uint)(*(&aKey[idx])))), 1 : 
        sqlite3GetVarint32((&aKey[idx]), &(serial_type)) ) )
        ;
				pMem.enc = (byte)(pKeyInfo.enc);
				pMem.db = pKeyInfo.db;
				pMem.szMalloc = (int)(0);
				pMem.z = null;
				sqlite3VdbeSerialGet(&aKey[d], (uint)(serial_type), pMem);
				d += (uint)(sqlite3VdbeSerialTypeLen((uint)(serial_type)));
				pMem++;
				if ((++u) >= (p.nField))
					break;
			}

			if (((d) > ((uint)(nKey))) && ((u) != 0))
			{

				sqlite3VdbeMemSetNull(pMem - 1);
			}


			p.nField = (ushort)(u);
		}
		public static int sqlite3VdbeReset(Vdbe p)
		{
			sqlite3 db;
			db = p.db;
			sqlite3VdbeHalt(p);
			if ((p.pc) >= (0))
			{
				if (((db.pErr) != null) || ((p.zErrMsg) != null))
				{
					sqlite3VdbeTransferError(p);
				}
				else
				{
					db.errCode = (int)(p.rc);
				}

				if ((p.runOnlyOnce) != 0)
					p.expired = (uint)(1);
			}
			else if (((p.rc) != 0) && ((p.expired) != 0))
			{
				sqlite3ErrorWithMsg(db, (int)(p.rc), (p.zErrMsg) != 0 ? "%s" : null, p.zErrMsg);
			}

			if ((p.zErrMsg) != null)
			{
				sqlite3DbFree(db, p.zErrMsg);
				p.zErrMsg = null;
			}

			p.pResultSet = null;
			p.iVdbeMagic = (uint)(0x48fa9f76);
			return (int)(p.rc & db.errMask);
		}
		public static void sqlite3VdbeResetStepResult(Vdbe p)
		{
			p.rc = (int)(0);
		}
		public static void sqlite3VdbeResolveLabel(Vdbe v, int x)
		{
			Parse p = v.pParse;
			int j = (int)(~(x));



			if ((p.nLabelAlloc + p.nLabel) < (0))
			{
				resizeResolveLabel(p, v, (int)(j));
			}
			else
			{

				p.aLabel[j] = (int)(v.nOp);
			}
		}
		public static void sqlite3VdbeReusable(Vdbe p)
		{
			p.runOnlyOnce = (uint)(0);
		}
		public static void sqlite3VdbeRewind(Vdbe p)
		{



			p.iVdbeMagic = (uint)(0x2df20da3);
			p.pc = (int)(-1);
			p.rc = (int)(0);
			p.errorAction = (byte)(2);
			p.nChange = (long)(0);
			p.cacheCtr = (uint)(1);
			p.minWriteFileFormat = (byte)(255);
			p.iStatement = (int)(0);
			p.nFkConstraint = (long)(0);
		}
		public static void sqlite3VdbeRunOnlyOnce(Vdbe p)
		{
			p.runOnlyOnce = (uint)(1);
		}
		public static void sqlite3VdbeSerialGet(byte* buf, uint serial_type, sqlite3_value pMem)
		{
			switch (serial_type)
			{
				case 10:
					{
						pMem.flags = (ushort)(0x0001 | 0x4000);
						pMem.n = (int)(0);
						pMem.u.nZero = (int)(0);
						return;
					}

				case 11:
				case 0:
					{
						pMem.flags = (ushort)(0x0001);
						return;
					}

				case 1:
					{
						pMem.u.i = (long)((sbyte)((buf)[0]));
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 2:
					{
						pMem.u.i = (long)(256 * (sbyte)((buf)[0]) | (buf)[1]);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 3:
					{
						pMem.u.i = (long)(65536 * (sbyte)((buf)[0]) | ((buf)[1] << 8) | (buf)[2]);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 4:
					{
						pMem.u.i = (long)(16777216 * (sbyte)((buf)[0]) | ((buf)[1] << 16) | ((buf)[2] << 8) | (buf)[3]);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 5:
					{
						pMem.u.i = (long)((((uint)((buf + 2)[0]) << 24) | ((buf + 2)[1] << 16) | ((buf + 2)[2] << 8) | (buf + 2)[3]) + (((long)(1)) << 32) * (256 * (sbyte)((buf)[0]) | (buf)[1]));
						pMem.flags = (ushort)(0x0004);
						return;
					}

				case 6:
				case 7:
					{
						serialGet(buf, (uint)(serial_type), pMem);
						return;
					}

				case 8:
				case 9:
					{
						pMem.u.i = (long)(serial_type - 8);
						pMem.flags = (ushort)(0x0004);
						return;
					}

				default:
					{
						pMem.z = (sbyte*)(buf);
						pMem.n = (int)((serial_type - 12) / 2);
						pMem.flags = (ushort)(sqlite3VdbeSerialGet_aFlag[serial_type & 1]);
						return;
					}
			}

			return;
		}
		public static uint sqlite3VdbeSerialPut(byte* buf, sqlite3_value pMem, uint serial_type)
		{
			uint len = 0;
			if (((serial_type) <= (7)) && ((serial_type) > (0)))
			{
				ulong v = 0;
				uint i = 0;
				if ((serial_type) == (7))
				{

					CRuntime.memcpy(&v, &pMem.u.r, (ulong)(sizeof(ulong)));
				}
				else
				{
					v = (ulong)(pMem.u.i);
				}

				len = (uint)(i = (uint)(sqlite3SmallTypeSizes[serial_type]));

				do
				{
					buf[--i] = ((byte)(v & 0xFF));
					v >>= 8;
				}
				while ((i) != 0);
				return (uint)(len);
			}

			if ((serial_type) >= (12))
			{

				len = (uint)(pMem.n);
				if ((len) > (0))
					CRuntime.memcpy(buf, pMem.z, (ulong)(len));
				return (uint)(len);
			}

			return (uint)(0);
		}
		public static uint sqlite3VdbeSerialTypeLen(uint serial_type)
		{
			if ((serial_type) >= (128))
			{
				return (uint)((serial_type - 12) / 2);
			}
			else
			{

				return (uint)(sqlite3SmallTypeSizes[serial_type]);
			}
		}
		public static void sqlite3VdbeSetChanges(sqlite3 db, long nChange)
		{

			db.nChange = (long)(nChange);
			db.nTotalChange += (long)(nChange);
		}
		public static int sqlite3VdbeSetColName(Vdbe p, int idx, int var, sbyte* zName, delegate17 xDel)
		{
			int rc = 0;
			sqlite3_value pColName;


			if ((p.db.mallocFailed) != 0)
			{

				return (int)(7);
			}


			pColName = (p.aColName[idx + var * p.nResColumn]);
			rc = (int)(sqlite3VdbeMemSetStr(pColName, zName, (long)(-1), (byte)(1), xDel));

			return (int)(rc);
		}
		public static void sqlite3VdbeSetNumCols(Vdbe p, int nResColumn)
		{
			int n = 0;
			sqlite3 db = p.db;
			if ((p.nResColumn) != 0)
			{
				releaseMemArray(p.aColName, (int)(p.nResColumn * 2));
				sqlite3DbFree(db, p.aColName);
			}

			n = (int)(nResColumn * 2);
			p.nResColumn = ((ushort)(nResColumn));
			p.aColName = (sqlite3_value)(sqlite3DbMallocRawNN(db, (ulong)(sizeof(sqlite3_value) * n)));
			if ((p.aColName) == (null))
				return;
			initMemArray(p.aColName, (int)(n), db, (ushort)(0x0001));
		}
		public static void sqlite3VdbeSetP4KeyInfo(Parse pParse, Index pIdx)
		{
			Vdbe v = pParse.pVdbe;
			KeyInfo pKeyInfo;


			pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
			if ((pKeyInfo) != null)
				sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
		}
		public static void sqlite3VdbeSetSql(Vdbe p, sbyte* z, int n, byte prepFlags)
		{
			if ((p) == (null))
				return;
			p.prepFlags = (byte)(prepFlags);
			if ((prepFlags & 0x80) == (0))
			{
				p.expmask = (uint)(0);
			}


			p.zSql = sqlite3DbStrNDup(p.db, z, (ulong)(n));
		}
		public static void sqlite3VdbeSetVarmask(Vdbe v, int iVar)
		{


			if ((iVar) >= (32))
			{
				v.expmask |= (uint)(0x80000000);
			}
			else
			{
				v.expmask |= (uint)((uint)(1) << (iVar - 1));
			}
		}
		public static void sqlite3VdbeSorterClose(sqlite3 db, VdbeCursor pCsr)
		{
			VdbeSorter pSorter;

			pSorter = pCsr.uc.pSorter;
			if ((pSorter) != null)
			{
				sqlite3VdbeSorterReset(db, pSorter);
				sqlite3_free(pSorter.list.aMemory);
				sqlite3DbFree(db, pSorter);
				pCsr.uc.pSorter = null;
			}
		}
		public static int sqlite3VdbeSorterCompare(VdbeCursor pCsr, sqlite3_value pVal, int nKeyCol, int* pRes)
		{
			VdbeSorter pSorter;
			UnpackedRecord r2;
			KeyInfo pKeyInfo;
			int i = 0;
			void* pKey;
			int nKey = 0;

			pSorter = pCsr.uc.pSorter;
			r2 = pSorter.pUnpacked;
			pKeyInfo = pCsr.pKeyInfo;
			if ((r2) == (null))
			{
				r2 = pSorter.pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
				if ((r2) == (null))
					return (int)(7);
				r2.nField = (ushort)(nKeyCol);
			}


			pKey = vdbeSorterRowkey(pSorter, &nKey);
			sqlite3VdbeRecordUnpack(pKeyInfo, (int)(nKey), pKey, r2);
			for (i = (int)(0); (i) < (nKeyCol); i++)
			{
				if ((r2.aMem[i].flags & 0x0001) != 0)
				{
					*pRes = (int)(-1);
					return (int)(0);
				}
			}

			*pRes = (int)(sqlite3VdbeRecordCompare((int)(pVal.n), pVal.z, r2));
			return (int)(0);
		}
		public static int sqlite3VdbeSorterInit(sqlite3 db, int nField, VdbeCursor pCsr)
		{
			int pgsz = 0;
			int i = 0;
			VdbeSorter pSorter;
			KeyInfo pKeyInfo;
			int szKeyInfo = 0;
			int sz = 0;
			int rc = (int)(0);
			int nWorker = 0;
			if (((sqlite3TempInMemory(db)) != 0) || ((sqlite3Config.bCoreMutex) == (0)))
			{
				nWorker = (int)(0);
			}
			else
			{
				nWorker = (int)(db.aLimit[11]);
			}




			szKeyInfo = (int)(sizeof(KeyInfo) + (pCsr.pKeyInfo.nKeyField - 1) * sizeof(CollSeq));
			sz = (int)(sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask));
			pSorter = (VdbeSorter)(sqlite3DbMallocZero(db, (ulong)(sz + szKeyInfo)));
			pCsr.uc.pSorter = pSorter;
			if ((pSorter) == (null))
			{
				rc = (int)(7);
			}
			else
			{
				Btree pBt = db.aDb[0].pBt;
				pSorter.pKeyInfo = pKeyInfo = (KeyInfo)((byte*)(pSorter) + sz);
				CRuntime.memcpy(pKeyInfo, pCsr.pKeyInfo, (ulong)(szKeyInfo));
				pKeyInfo.db = null;
				if (((nField) != 0) && ((nWorker) == (0)))
				{
					pKeyInfo.nKeyField = (ushort)(nField);
				}

				sqlite3BtreeEnter(pBt);
				pSorter.pgsz = (int)(pgsz = (int)(sqlite3BtreeGetPageSize(pBt)));
				sqlite3BtreeLeave(pBt);
				pSorter.nTask = (byte)(nWorker + 1);
				pSorter.iPrev = ((byte)(nWorker - 1));
				pSorter.bUseThreads = (byte)((pSorter.nTask) > (1));
				pSorter.db = db;
				for (i = (int)(0); (i) < (pSorter.nTask); i++)
				{
					SortSubtask pTask = pSorter.aTask[i];
					pTask.pSorter = pSorter;
				}

				if (sqlite3TempInMemory(db) == 0)
				{
					long mxCache = 0;
					uint szPma = (uint)(sqlite3Config.szPma);
					pSorter.mnPmaSize = (int)(szPma * pgsz);
					mxCache = (long)(db.aDb[0].pSchema.cache_size);
					if ((mxCache) < (0))
					{
						mxCache = (long)(mxCache * -1024);
					}
					else
					{
						mxCache = (long)(mxCache * pgsz);
					}

					mxCache = (long)((mxCache) < (1 << 29) ? (mxCache) : (1 << 29));
					pSorter.mxPmaSize = (int)((pSorter.mnPmaSize) > ((int)(mxCache)) ? (pSorter.mnPmaSize) : ((int)(mxCache)));
					if ((sqlite3Config.bSmallMalloc) == (0))
					{

						pSorter.nMemory = (int)(pgsz);
						pSorter.list.aMemory = (byte*)(sqlite3Malloc((ulong)(pgsz)));
						if (pSorter.list.aMemory == null)
							rc = (int)(7);
					}
				}

				if ((((pKeyInfo.nAllField) < (13)) && (((pKeyInfo.aColl[0]) == (null)) || ((pKeyInfo.aColl[0]) == (db.pDfltColl)))) && ((pKeyInfo.aSortFlags[0] & 0x02) == (0)))
				{
					pSorter.typeMask = (byte)(0x01 | 0x02);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeSorterNext(sqlite3 db, VdbeCursor pCsr)
		{
			VdbeSorter pSorter;
			int rc = 0;

			pSorter = pCsr.uc.pSorter;

			if ((pSorter.bUsePMA) != 0)
			{



				if ((pSorter.bUseThreads) != 0)
				{
					rc = (int)(vdbePmaReaderNext(pSorter.pReader));
					if (((rc) == (0)) && ((pSorter.pReader.pFd) == (null)))
						rc = (int)(101);
				}
				else
				{
					int res = (int)(0);


					rc = (int)(vdbeMergeEngineStep(pSorter.pMerger, &res));
					if (((rc) == (0)) && ((res) != 0))
						rc = (int)(101);
				}
			}
			else
			{
				SorterRecord* pFree = pSorter.list.pList;
				pSorter.list.pList = pFree->u.pNext;
				pFree->u.pNext = null;
				if ((pSorter.list.aMemory) == (null))
					vdbeSorterRecordFree(db, pFree);
				rc = (int)(pSorter.list.pList ? 0 : 101);
			}

			return (int)(rc);
		}
		public static void sqlite3VdbeSorterReset(sqlite3 db, VdbeSorter pSorter)
		{
			int i = 0;
			(void)(vdbeSorterJoinAll(pSorter, (int)(0)));

			if ((pSorter.pReader) != null)
			{
				vdbePmaReaderClear(pSorter.pReader);
				sqlite3DbFree(db, pSorter.pReader);
				pSorter.pReader = null;
			}

			vdbeMergeEngineFree(pSorter.pMerger);
			pSorter.pMerger = null;
			for (i = (int)(0); (i) < (pSorter.nTask); i++)
			{
				SortSubtask pTask = pSorter.aTask[i];
				vdbeSortSubtaskCleanup(db, pTask);
				pTask.pSorter = pSorter;
			}

			if ((pSorter.list.aMemory) == (null))
			{
				vdbeSorterRecordFree(null, pSorter.list.pList);
			}

			pSorter.list.pList = null;
			pSorter.list.szPMA = (int)(0);
			pSorter.bUsePMA = (byte)(0);
			pSorter.iMemory = (int)(0);
			pSorter.mxKeysize = (int)(0);
			sqlite3DbFree(db, pSorter.pUnpacked);
			pSorter.pUnpacked = null;
		}
		public static int sqlite3VdbeSorterRewind(VdbeCursor pCsr, int* pbEof)
		{
			VdbeSorter pSorter;
			int rc = (int)(0);

			pSorter = pCsr.uc.pSorter;

			if ((pSorter.bUsePMA) == (0))
			{
				if ((pSorter.list.pList) != null)
				{
					*pbEof = (int)(0);
					rc = (int)(vdbeSorterSort(pSorter.aTask[0], &pSorter.list));
				}
				else
				{
					*pbEof = (int)(1);
				}

				return (int)(rc);
			}


			rc = (int)(vdbeSorterFlushPMA(pSorter));
			rc = (int)(vdbeSorterJoinAll(pSorter, (int)(rc)));

			if ((rc) == (0))
			{
				rc = (int)(vdbeSorterSetupMerge(pSorter));
				*pbEof = (int)(0);
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeSorterRowkey(VdbeCursor pCsr, sqlite3_value pOut)
		{
			VdbeSorter pSorter;
			void* pKey;
			int nKey = 0;

			pSorter = pCsr.uc.pSorter;
			pKey = vdbeSorterRowkey(pSorter, &nKey);
			if ((sqlite3VdbeMemClearAndResize(pOut, (int)(nKey))) != 0)
			{
				return (int)(7);
			}

			pOut.n = (int)(nKey);
			((pOut).flags = (ushort)(((pOut).flags & ~(0xc1bf | 0x4000)) | 0x0010));
			CRuntime.memcpy(pOut.z, pKey, (ulong)(nKey));
			return (int)(0);
		}
		public static int sqlite3VdbeSorterWrite(VdbeCursor pCsr, sqlite3_value pVal)
		{
			VdbeSorter pSorter;
			int rc = (int)(0);
			SorterRecord* pNew;
			int bFlush = 0;
			int nReq = 0;
			int nPMA = 0;
			int t = 0;

			pSorter = pCsr.uc.pSorter;
			t = (int)((uint)(*((byte*)(&pVal.z[1]))));
			if ((t) >= (0x80))
				sqlite3GetVarint32(((byte*)(&pVal.z[1])), (uint*)(&(t)));
			if ((((t) > (0)) && ((t) < (10))) && (t != 7))
			{
				pSorter.typeMask &= (byte)(0x01);
			}
			else if (((t) > (10)) && ((t & 0x01) != 0))
			{
				pSorter.typeMask &= (byte)(0x02);
			}
			else
			{
				pSorter.typeMask = (byte)(0);
			}


			nReq = (int)(pVal.n + sizeof(SorterRecord));
			nPMA = (int)(pVal.n + sqlite3VarintLen((ulong)(pVal.n)));
			if ((pSorter.mxPmaSize) != 0)
			{
				if ((pSorter.list.aMemory) != null)
				{
					bFlush = (int)(((pSorter.iMemory) != 0) && ((pSorter.iMemory + nReq) > (pSorter.mxPmaSize)) ? 1 : 0);
				}
				else
				{
					bFlush = (int)(((pSorter.list.szPMA) > (pSorter.mxPmaSize)) || (((pSorter.list.szPMA) > (pSorter.mnPmaSize)) && ((sqlite3HeapNearlyFull()) != 0)) ? 1 : 0);
				}

				if ((bFlush) != 0)
				{
					rc = (int)(vdbeSorterFlushPMA(pSorter));
					pSorter.list.szPMA = (int)(0);
					pSorter.iMemory = (int)(0);

				}
			}

			pSorter.list.szPMA += (int)(nPMA);
			if ((nPMA) > (pSorter.mxKeysize))
			{
				pSorter.mxKeysize = (int)(nPMA);
			}

			if ((pSorter.list.aMemory) != null)
			{
				int nMin = (int)(pSorter.iMemory + nReq);
				if ((nMin) > (pSorter.nMemory))
				{
					byte* aNew;
					long nNew = (long)(2 * (long)(pSorter.nMemory));
					int iListOff = (int)(-1);
					if ((pSorter.list.pList) != null)
					{
						iListOff = (int)((byte*)(pSorter.list.pList) - pSorter.list.aMemory);
					}

					while ((nNew) < (nMin))
					{
						nNew = (long)(nNew * 2);
					}

					if ((nNew) > (pSorter.mxPmaSize))
						nNew = (long)(pSorter.mxPmaSize);
					if ((nNew) < (nMin))
						nNew = (long)(nMin);
					aNew = sqlite3Realloc(pSorter.list.aMemory, (ulong)(nNew));
					if (aNew == null)
						return (int)(7);
					if ((iListOff) >= (0))
					{
						pSorter.list.pList = (SorterRecord*)(&aNew[iListOff]);
					}

					pSorter.list.aMemory = aNew;
					pSorter.nMemory = (int)(nNew);
				}

				pNew = (SorterRecord*)(&pSorter.list.aMemory[pSorter.iMemory]);
				pSorter.iMemory += (int)(((nReq) + 7) & ~7);
				if ((pSorter.list.pList) != null)
				{
					pNew->u.iNext = ((int)((byte*)(pSorter.list.pList) - pSorter.list.aMemory));
				}
			}
			else
			{
				pNew = (SorterRecord*)(sqlite3Malloc((ulong)(nReq)));
				if ((pNew) == (null))
				{
					return (int)(7);
				}

				pNew->u.pNext = pSorter.list.pList;
			}

			CRuntime.memcpy(((void*)((pNew) + 1)), pVal.z, (ulong)(pVal.n));
			pNew->nVal = (int)(pVal.n);
			pSorter.list.pList = pNew;
			return (int)(rc);
		}
		public static void sqlite3VdbeSwap(Vdbe pA, Vdbe pB)
		{
			Vdbe tmp = new Vdbe(); Vdbe pTmp;
			sbyte* zTmp;

			tmp = (Vdbe)(pA);
			pA = (Vdbe)(pB);
			pB = (Vdbe)(tmp);
			pTmp = pA.pNext;
			pA.pNext = pB.pNext;
			pB.pNext = pTmp;
			pTmp = pA.pPrev;
			pA.pPrev = pB.pPrev;
			pB.pPrev = pTmp;
			zTmp = pA.zSql;
			pA.zSql = pB.zSql;
			pB.zSql = zTmp;
			pB.expmask = (uint)(pA.expmask);
			pB.prepFlags = (byte)(pA.prepFlags);
			CRuntime.memcpy(pB.aCounter, pA.aCounter, (ulong)(9 * sizeof(uint)));
			pB.aCounter[5]++;
		}
		public static VdbeOp* sqlite3VdbeTakeOpArray(Vdbe p, int* pnOp, int* pnMaxArg)
		{
			VdbeOp* aOp = p.aOp;


			resolveP2Values(p, pnMaxArg);
			*pnOp = (int)(p.nOp);
			p.aOp = null;
			return aOp;
		}
		public static int sqlite3VdbeTransferError(Vdbe p)
		{
			sqlite3 db = p.db;
			int rc = (int)(p.rc);
			if ((p.zErrMsg) != null)
			{
				db.bBenignMalloc++;
				sqlite3BeginBenignMalloc();
				if ((db.pErr) == (null))
					db.pErr = sqlite3ValueNew(db);
				sqlite3ValueSetStr(db.pErr, (int)(-1), p.zErrMsg, (byte)(1), ((Void(Void * ))(-1)));
				sqlite3EndBenignMalloc();
				db.bBenignMalloc--;
			}
			else if ((db.pErr) != null)
			{
				sqlite3ValueSetNull(db.pErr);
			}

			db.errCode = (int)(rc);
			db.errByteOffset = (int)(-1);
			return (int)(rc);
		}
		public static void sqlite3VdbeUsesBtree(Vdbe p, int i)
		{


			(p.btreeMask) |= (uint)(((uint)(1)) << (i));
			if ((i != 1) && ((sqlite3BtreeSharable(p.db.aDb[i].pBt)) != 0))
			{
				(p.lockMask) |= (uint)(((uint)(1)) << (i));
			}
		}
		public static void sqlite3VectorErrorMsg(Parse pParse, Expr pExpr)
		{
			if ((((pExpr).flags & 0x000800) != 0))
			{
				sqlite3SubselectError(pParse, (int)(pExpr.x.pSelect.pEList.nExpr), (int)(1));
			}
			else
			{
				sqlite3ErrorMsg(pParse, "row value misused");
			}
		}
		public static Expr sqlite3VectorFieldSubexpr(Expr pVector, int i)
		{

			if ((sqlite3ExprIsVector(pVector)) != 0)
			{

				if (((pVector.op) == (138)) || ((pVector.op2) == (138)))
				{

					return pVector.x.pSelect.pEList.a[i].pExpr;
				}
				else
				{

					return pVector.x.pList.a[i].pExpr;
				}
			}

			return pVector;
		}
		public static int sqlite3ViewGetColumnNames(Parse pParse, Table pTable)
		{
			Table pSelTab;
			Select pSel;
			int nErr = (int)(0);
			int n = 0;
			sqlite3 db = pParse.db;
			int rc = 0;
			delegate66 xAuth;

			if ((((pTable).eTabType) == (1)))
			{
				db.nSchemaLock++;
				rc = (int)(sqlite3VtabCallConnect(pParse, pTable));
				db.nSchemaLock--;
				return (int)(rc);
			}

			if ((pTable.nCol) > (0))
				return (int)(0);
			if ((pTable.nCol) < (0))
			{
				sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable.zName);
				return (int)(1);
			}



			pSel = sqlite3SelectDup(db, pTable.u.view.pSelect, (int)(0));
			if ((pSel) != null)
			{
				byte eParseMode = (byte)(pParse.eParseMode);
				pParse.eParseMode = (byte)(0);
				n = (int)(pParse.nTab);
				sqlite3SrcListAssignCursors(pParse, pSel.pSrc);
				pTable.nCol = (short)(-1);
				db.lookaside.bDisable++;
				db.lookaside.sz = (ushort)(0);
				xAuth = db.xAuth;
				db.xAuth = null;
				pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, (sbyte)(0x40));
				db.xAuth = xAuth;
				pParse.nTab = (int)(n);
				if ((pSelTab) == (null))
				{
					pTable.nCol = (short)(0);
					nErr++;
				}
				else if ((pTable.pCheck) != null)
				{
					sqlite3ColumnsFromExprList(pParse, pTable.pCheck, &pTable.nCol, &pTable.aCol);
					if (((pParse.nErr) == (0)) && ((pTable.nCol) == (pSel.pEList.nExpr)))
					{

						sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel, (sbyte)(0x40));
					}
				}
				else
				{

					pTable.nCol = (short)(pSelTab.nCol);
					pTable.aCol = pSelTab.aCol;
					pTable.tabFlags |= (uint)(pSelTab.tabFlags & 0x0062);
					pSelTab.nCol = (short)(0);
					pSelTab.aCol = null;

				}

				pTable.nNVCol = (short)(pTable.nCol);
				sqlite3DeleteTable(db, pSelTab);
				sqlite3SelectDelete(db, pSel);
				db.lookaside.bDisable--;
				db.lookaside.sz = (ushort)((db.lookaside.bDisable) != 0 ? 0 : db.lookaside.szTrue);
				pParse.eParseMode = (byte)(eParseMode);
			}
			else
			{
				nErr++;
			}

			pTable.pSchema.schemaFlags |= (ushort)(0x0002);
			if ((db.mallocFailed) != 0)
			{
				sqlite3DeleteColumnNames(db, pTable);
			}

			return (int)(nErr);
		}
		public static int* sqlite3VListAdd(sqlite3 db, int* pIn, sbyte* zName, int nName, int iVal)
		{
			int nInt = 0;
			sbyte* z;
			int i = 0;
			nInt = (int)(nName / 4 + 3);

			if (((pIn) == (null)) || ((pIn[1] + nInt) > (pIn[0])))
			{
				long nAlloc = (long)(((pIn) != 0 ? 2 * (long)(pIn[0]) : 10) + nInt);
				int* pOut = sqlite3DbRealloc(db, pIn, (ulong)(nAlloc * sizeof(int)));
				if ((pOut) == (null))
					return pIn;
				if ((pIn) == (null))
					pOut[1] = (int)(2);
				pIn = pOut;
				pIn[0] = (int)(nAlloc);
			}

			i = (int)(pIn[1]);
			pIn[i] = (int)(iVal);
			pIn[i + 1] = (int)(nInt);
			z = (sbyte*)(&pIn[i + 2]);
			pIn[1] = (int)(i + nInt);

			CRuntime.memcpy(z, zName, (ulong)(nName));
			z[nName] = (sbyte)(0);
			return pIn;
		}
		public static int sqlite3VListNameToNum(int* pIn, sbyte* zName, int nName)
		{
			int i = 0; int mx = 0;
			if ((pIn) == (null))
				return (int)(0);
			mx = (int)(pIn[1]);
			i = (int)(2);
			do
			{
				sbyte* z = (sbyte*)(&pIn[i + 2]);
				if (((CRuntime.strncmp(z, zName, (ulong)(nName))) == (0)) && ((z[nName]) == (0)))
					return (int)(pIn[i]);
				i += (int)(pIn[i + 1]);
			}
			while ((i) < (mx));
			return (int)(0);
		}
		public static sbyte* sqlite3VListNumToName(int* pIn, int iVal)
		{
			int i = 0; int mx = 0;
			if ((pIn) == (null))
				return null;
			mx = (int)(pIn[1]);
			i = (int)(2);
			do
			{
				if ((pIn[i]) == (iVal))
					return (sbyte*)(&pIn[i + 2]);
				i += (int)(pIn[i + 1]);
			}
			while ((i) < (mx));
			return null;
		}
		public static sbyte* sqlite3VMPrintf(sqlite3 db, sbyte* zFormat, sbyte* ap)
		{
			sbyte* z;
			sbyte* zBase = stackalloc sbyte[70];
			sqlite3_str acc = new sqlite3_str();

			sqlite3StrAccumInit(acc, db, zBase, (int)(70 * sizeof(sbyte)), (int)(db.aLimit[0]));
			acc.printfFlags = (byte)(0x01);
			sqlite3_str_vappendf(acc, zFormat, ap);
			z = sqlite3StrAccumFinish(acc);
			if ((acc.accError) == (7))
			{
				sqlite3OomFault(db);
			}

			return z;
		}
		public static void sqlite3VtabArgExtend(Parse pParse, Token* p)
		{
			Token* pArg = &pParse.sArg;
			if ((pArg->z) == (null))
			{
				pArg->z = p->z;
				pArg->n = (uint)(p->n);
			}
			else
			{

				pArg->n = (uint)((int)(&p->z[p->n] - pArg->z));
			}
		}
		public static void sqlite3VtabArgInit(Parse pParse)
		{
			addArgumentToVtab(pParse);
			pParse.sArg.z = null;
			pParse.sArg.n = (uint)(0);
		}
		public static int sqlite3VtabBegin(sqlite3 db, VTable pVTab)
		{
			int rc = (int)(0);
			sqlite3_module pModule;
			if (((((db).nVTrans) > (0)) && (((db).aVTrans) == (null))))
			{
				return (int)(6);
			}

			if (pVTab == null)
			{
				return (int)(0);
			}

			pModule = pVTab.pVtab.pModule;
			if ((pModule.xBegin) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (db.nVTrans); i++)
				{
					if ((db.aVTrans[i]) == (pVTab))
					{
						return (int)(0);
					}
				}

				rc = (int)(growVTrans(db));
				if ((rc) == (0))
				{
					rc = (int)(pModule.xBegin(pVTab.pVtab));
					if ((rc) == (0))
					{
						int iSvpt = (int)(db.nStatement + db.nSavepoint);
						addToVTrans(db, pVTab);
						if (((iSvpt) != 0) && ((pModule.xSavepoint) != null))
						{
							pVTab.iSavepoint = (int)(iSvpt);
							rc = (int)(pModule.xSavepoint(pVTab.pVtab, (int)(iSvpt - 1)));
						}
					}
				}
			}

			return (int)(rc);
		}
		public static void sqlite3VtabBeginParse(Parse pParse, Token* pName1, Token* pName2, Token* pModuleName, int ifNotExists)
		{
			Table pTable;
			sqlite3 db;
			sqlite3StartTable(pParse, pName1, pName2, (int)(0), (int)(0), (int)(1), (int)(ifNotExists));
			pTable = pParse.pNewTable;
			if ((pTable) == (null))
				return;

			pTable.eTabType = (byte)(1);
			db = pParse.db;

			addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
			addModuleArgument(pParse, pTable, null);
			addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable.zName));

			pParse.sNameToken.n = (uint)((int)(&pModuleName->z[pModuleName->n] - pParse.sNameToken.z));
			if ((pTable.u.vtab.azArg) != null)
			{
				int iDb = (int)(sqlite3SchemaToIndex(db, pTable.pSchema));

				sqlite3AuthCheck(pParse, (int)(29), pTable.zName, pTable.u.vtab.azArg[0], pParse.db.aDb[iDb].zDbSName);
			}
		}
		public static int sqlite3VtabCallConnect(Parse pParse, Table pTab)
		{
			sqlite3 db = pParse.db;
			sbyte* zMod;
			Module pMod;
			int rc = 0;


			if ((sqlite3GetVTable(db, pTab)) != null)
			{
				return (int)(0);
			}

			zMod = pTab.u.vtab.azArg[0];
			pMod = (Module)(sqlite3HashFind(&db.aModule, zMod));
			if (pMod == null)
			{
				sbyte* zModule = pTab.u.vtab.azArg[0];
				sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
				rc = (int)(1);
			}
			else
			{
				sbyte* zErr = null;
				rc = (int)(vtabCallConstructor(db, pTab, pMod, pMod.pModule.xConnect, &zErr));
				if (rc != 0)
				{
					sqlite3ErrorMsg(pParse, "%s", zErr);
					pParse.rc = (int)(rc);
				}

				sqlite3DbFree(db, zErr);
			}

			return (int)(rc);
		}
		public static int sqlite3VtabCallCreate(sqlite3 db, int iDb, sbyte* zTab, sbyte** pzErr)
		{
			int rc = (int)(0);
			Table pTab;
			Module pMod;
			sbyte* zMod;
			pTab = sqlite3FindTable(db, zTab, db.aDb[iDb].zDbSName);

			zMod = pTab.u.vtab.azArg[0];
			pMod = (Module)(sqlite3HashFind(&db.aModule, zMod));
			if ((((pMod) == (null)) || ((pMod.pModule.xCreate) == (null))) || ((pMod.pModule.xDestroy) == (null)))
			{
				*pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
				rc = (int)(1);
			}
			else
			{
				rc = (int)(vtabCallConstructor(db, pTab, pMod, pMod.pModule.xCreate, pzErr));
			}

			if (((rc) == (0)) && ((sqlite3GetVTable(db, pTab)) != null))
			{
				rc = (int)(growVTrans(db));
				if ((rc) == (0))
				{
					addToVTrans(db, sqlite3GetVTable(db, pTab));
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VtabCallDestroy(sqlite3 db, int iDb, sbyte* zTab)
		{
			int rc = (int)(0);
			Table pTab;
			pTab = sqlite3FindTable(db, zTab, db.aDb[iDb].zDbSName);
			if (((pTab != null) && ((((pTab).eTabType) == (1)) != 0)) && (pTab.u.vtab.p != null))
			{
				VTable p;
				delegate23 xDestroy;
				for (p = pTab.u.vtab.p; p; p = p.pNext)
				{

					if ((p.pVtab.nRef) > (0))
					{
						return (int)(6);
					}
				}

				p = vtabDisconnectAll(db, pTab);
				xDestroy = p.pMod.pModule.xDestroy;
				if ((xDestroy) == (null))
					xDestroy = p.pMod.pModule.xDisconnect;

				pTab.nTabRef++;
				rc = (int)(xDestroy(p.pVtab));
				if ((rc) == (0))
				{

					p.pVtab = null;
					pTab.u.vtab.p = null;
					sqlite3VtabUnlock(p);
				}

				sqlite3DeleteTable(db, pTab);
			}

			return (int)(rc);
		}
		public static void sqlite3VtabClear(sqlite3 db, Table p)
		{

			if ((db == null) || ((db.pnBytesFreed) == (null)))
				vtabDisconnectAll(null, p);
			if ((p.u.vtab.azArg) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (p.u.vtab.nArg); i++)
				{
					if (i != 1)
						sqlite3DbFree(db, p.u.vtab.azArg[i]);
				}

				sqlite3DbFree(db, p.u.vtab.azArg);
			}
		}
		public static int sqlite3VtabCommit(sqlite3 db)
		{
			callFinaliser(db, (int)((ulong)(&((0).xCommit))));
			return (int)(0);
		}
		public static Module sqlite3VtabCreateModule(sqlite3 db, sbyte* zName, sqlite3_module pModule, void* pAux, delegate17 xDestroy)
		{
			Module pMod;
			Module pDel;
			sbyte* zCopy;
			if ((pModule) == (null))
			{
				zCopy = zName;
				pMod = null;
			}
			else
			{
				int nName = (int)(sqlite3Strlen30(zName));
				pMod = (Module)(sqlite3Malloc((ulong)(sizeof(Module) + nName + 1)));
				if ((pMod) == (null))
				{
					sqlite3OomFault(db);
					return null;
				}

				zCopy = (sbyte*)(pMod[1]);
				CRuntime.memcpy(zCopy, zName, (ulong)(nName + 1));
				pMod.zName = zCopy;
				pMod.pModule = pModule;
				pMod.pAux = pAux;
				pMod.xDestroy = xDestroy;
				pMod.pEpoTab = null;
				pMod.nRefModule = (int)(1);
			}

			pDel = (Module)(sqlite3HashInsert(&db.aModule, zCopy, (void*)(pMod)));
			if ((pDel) != null)
			{
				if ((pDel) == (pMod))
				{
					sqlite3OomFault(db);
					sqlite3DbFree(db, pDel);
					pMod = null;
				}
				else
				{
					sqlite3VtabEponymousTableClear(db, pDel);
					sqlite3VtabModuleUnref(db, pDel);
				}
			}

			return pMod;
		}
		public static void sqlite3VtabDisconnect(sqlite3 db, Table p)
		{
			VTable ppVTab;



			for (ppVTab = p.u.vtab.p; ppVTab; ppVTab = (ppVTab).pNext)
			{
				if (((ppVTab).db) == (db))
				{
					VTable pVTab = ppVTab;
					ppVTab = pVTab.pNext;
					sqlite3VtabUnlock(pVTab);
					break;
				}
			}
		}
		public static void sqlite3VtabEponymousTableClear(sqlite3 db, Module pMod)
		{
			Table pTab = pMod.pEpoTab;
			if (pTab != null)
			{
				pTab.tabFlags |= (uint)(0x00004000);
				sqlite3DeleteTable(db, pTab);
				pMod.pEpoTab = null;
			}
		}
		public static int sqlite3VtabEponymousTableInit(Parse pParse, Module pMod)
		{
			sqlite3_module pModule = pMod.pModule;
			Table pTab;
			sbyte* zErr = null;
			int rc = 0;
			sqlite3 db = pParse.db;
			if ((pMod.pEpoTab) != null)
				return (int)(1);
			if ((pModule.xCreate != null) && (pModule.xCreate != pModule.xConnect))
				return (int)(0);
			pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
			if ((pTab) == (null))
				return (int)(0);
			pTab.zName = sqlite3DbStrDup(db, pMod.zName);
			if ((pTab.zName) == (null))
			{
				sqlite3DbFree(db, pTab);
				return (int)(0);
			}

			pMod.pEpoTab = pTab;
			pTab.nTabRef = (uint)(1);
			pTab.eTabType = (byte)(1);
			pTab.pSchema = db.aDb[0].pSchema;

			pTab.iPKey = (short)(-1);
			pTab.tabFlags |= (uint)(0x00008000);
			addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName));
			addModuleArgument(pParse, pTab, null);
			addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName));
			rc = (int)(vtabCallConstructor(db, pTab, pMod, pModule.xConnect, &zErr));
			if ((rc) != 0)
			{
				sqlite3ErrorMsg(pParse, "%s", zErr);
				sqlite3DbFree(db, zErr);
				sqlite3VtabEponymousTableClear(db, pMod);
			}

			return (int)(1);
		}
		public static void sqlite3VtabFinishParse(Parse pParse, Token* pEnd)
		{
			Table pTab = pParse.pNewTable;
			sqlite3 db = pParse.db;
			if ((pTab) == (null))
				return;

			addArgumentToVtab(pParse);
			pParse.sArg.z = null;
			if ((pTab.u.vtab.nArg) < (1))
				return;
			if (db.init.busy == 0)
			{
				sbyte* zStmt;
				sbyte* zWhere;
				int iDb = 0;
				int iReg = 0;
				Vdbe v;
				sqlite3MayAbort(pParse);
				if ((pEnd) != null)
				{
					pParse.sNameToken.n = (uint)((int)(pEnd->z - pParse.sNameToken.z) + pEnd->n);
				}

				zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse.sNameToken);
				iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
				sqlite3NestedParse(pParse, "UPDATE %Q.sqlite_master SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q WHERE rowid=#%d", db.aDb[iDb].zDbSName, pTab.zName, pTab.zName, zStmt, (int)(pParse.regRowid));
				v = sqlite3GetVdbe(pParse);
				sqlite3ChangeCookie(pParse, (int)(iDb));
				sqlite3VdbeAddOp0(v, (int)(165));
				zWhere = sqlite3MPrintf(db, "name=%Q AND sql=%Q", pTab.zName, zStmt);
				sqlite3VdbeAddParseSchemaOp(v, (int)(iDb), zWhere, (ushort)(0));
				sqlite3DbFree(db, zStmt);
				iReg = (int)(++pParse.nMem);
				sqlite3VdbeLoadString(v, (int)(iReg), pTab.zName);
				sqlite3VdbeAddOp2(v, (int)(170), (int)(iDb), (int)(iReg));
			}
			else
			{
				Table pOld;
				Schema pSchema = pTab.pSchema;
				sbyte* zName = pTab.zName;

				sqlite3MarkAllShadowTablesOf(db, pTab);
				pOld = sqlite3HashInsert(&pSchema.tblHash, zName, pTab);
				if ((pOld) != null)
				{
					sqlite3OomFault(db);

					return;
				}

				pParse.pNewTable = null;
			}
		}
		public static void sqlite3VtabImportErrmsg(Vdbe p, sqlite3_vtab pVtab)
		{
			if ((pVtab.zErrMsg) != null)
			{
				sqlite3 db = p.db;
				sqlite3DbFree(db, p.zErrMsg);
				p.zErrMsg = sqlite3DbStrDup(db, pVtab.zErrMsg);
				sqlite3_free(pVtab.zErrMsg);
				pVtab.zErrMsg = null;
			}
		}
		public static void sqlite3VtabLock(VTable pVTab)
		{
			pVTab.nRef++;
		}
		public static void sqlite3VtabMakeWritable(Parse pParse, Table pTab)
		{
			Parse pToplevel = ((pParse).pToplevel ? (pParse).pToplevel : (pParse));
			int i = 0; int n = 0;
			Table apVtabLock;

			for (i = (int)(0); (i) < (pToplevel.nVtabLock); i++)
			{
				if ((pTab) == (pToplevel.apVtabLock[i]))
					return;
			}

			n = (int)((pToplevel.nVtabLock + 1) * sizeof(Table));
			apVtabLock = sqlite3Realloc(pToplevel.apVtabLock, (ulong)(n));
			if ((apVtabLock) != null)
			{
				pToplevel.apVtabLock = apVtabLock;
				pToplevel.apVtabLock[pToplevel.nVtabLock++] = pTab;
			}
			else
			{
				sqlite3OomFault(pToplevel.db);
			}
		}
		public static void sqlite3VtabModuleUnref(sqlite3 db, Module pMod)
		{

			pMod.nRefModule--;
			if ((pMod.nRefModule) == (0))
			{
				if ((pMod.xDestroy) != null)
				{
					pMod.xDestroy(pMod.pAux);
				}


				sqlite3DbFree(db, pMod);
			}
		}
		public static FuncDef sqlite3VtabOverloadFunction(sqlite3 db, FuncDef pDef, int nArg, Expr pExpr)
		{
			Table pTab;
			sqlite3_vtab pVtab;
			sqlite3_module pMod;
			delegate67 xSFunc = null;
			void* pArg = null;
			FuncDef pNew;
			int rc = (int)(0);
			if (((pExpr) == (null)))
				return pDef;
			if (pExpr.op != 167)
				return pDef;

			pTab = pExpr.y.pTab;
			if ((pTab) == (null))
				return pDef;
			if (!(((pTab).eTabType) == (1)))
				return pDef;
			pVtab = sqlite3GetVTable(db, pTab).pVtab;


			pMod = pVtab.pModule;
			if ((pMod.xFindFunction) == (null))
				return pDef;
			rc = (int)(pMod.xFindFunction(pVtab, (int)(nArg), pDef.zName, &xSFunc, &pArg));
			if ((rc) == (0))
			{
				return pDef;
			}

			pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(FuncDef) + sqlite3Strlen30(pDef.zName) + 1));
			if ((pNew) == (null))
			{
				return pDef;
			}

			pNew = (FuncDef)(pDef);
			pNew.zName = (sbyte*)(pNew[1]);
			CRuntime.memcpy((sbyte*)(pNew[1]), pDef.zName, (ulong)(sqlite3Strlen30(pDef.zName) + 1));
			pNew.xSFunc = xSFunc;
			pNew.pUserData = pArg;
			pNew.funcFlags |= (uint)(0x0010);
			return pNew;
		}
		public static int sqlite3VtabRollback(sqlite3 db)
		{
			callFinaliser(db, (int)((ulong)(&((0).xRollback))));
			return (int)(0);
		}
		public static int sqlite3VtabSavepoint(sqlite3 db, int op, int iSavepoint)
		{
			int rc = (int)(0);


			if ((db.aVTrans) != null)
			{
				int i = 0;
				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nVTrans)); i++)
				{
					VTable pVTab = db.aVTrans[i];
					sqlite3_module pMod = pVTab.pMod.pModule;
					if (((pVTab.pVtab) != null) && ((pMod.iVersion) >= (2)))
					{
						delegate22 xMethod;
						sqlite3VtabLock(pVTab);
						switch (op)
						{
							case 0:
								xMethod = pMod.xSavepoint;
								pVTab.iSavepoint = (int)(iSavepoint + 1);
								break;
							case 2:
								xMethod = pMod.xRollbackTo;
								break;
							default:
								xMethod = pMod.xRelease;
								break;
						}

						if (((xMethod) != null) && ((pVTab.iSavepoint) > (iSavepoint)))
						{
							rc = (int)(xMethod(pVTab.pVtab, (int)(iSavepoint)));
						}

						sqlite3VtabUnlock(pVTab);
					}
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VtabSync(sqlite3 db, Vdbe p)
		{
			int i = 0;
			int rc = (int)(0);
			VTable aVTrans = db.aVTrans;
			db.aVTrans = null;
			for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nVTrans)); i++)
			{
				delegate23 x;
				sqlite3_vtab pVtab = aVTrans[i].pVtab;
				if (((pVtab) != null) && ((x = pVtab.pModule.xSync) != null))
				{
					rc = (int)(x(pVtab));
					sqlite3VtabImportErrmsg(p, pVtab);
				}
			}

			db.aVTrans = aVTrans;
			return (int)(rc);
		}
		public static void sqlite3VtabUnlock(VTable pVTab)
		{
			sqlite3 db = pVTab.db;



			pVTab.nRef--;
			if ((pVTab.nRef) == (0))
			{
				sqlite3_vtab p = pVTab.pVtab;
				sqlite3VtabModuleUnref(pVTab.db, pVTab.pMod);
				if ((p) != null)
				{
					p.pModule.xDisconnect(p);
				}

				sqlite3DbFree(db, pVTab);
			}
		}
		public static void sqlite3VtabUnlockList(sqlite3 db)
		{
			VTable p = db.pDisconnect;


			if ((p) != null)
			{
				db.pDisconnect = null;
				sqlite3ExpirePreparedStatements(db, (int)(0));
				do
				{
					VTable pNext = p.pNext;
					sqlite3VtabUnlock(p);
					p = pNext;
				}
				while ((p) != null);
			}
		}
		public static int sqlite3WalBeginReadTransaction(Wal pWal, int* pChanged)
		{
			int rc = 0;
			int cnt = (int)(0);

			do
			{
				rc = (int)(walTryBeginRead(pWal, pChanged, (int)(0), (int)(++cnt)));
			}
			while ((rc) == (-1));
			return (int)(rc);
		}
		public static int sqlite3WalBeginWriteTransaction(Wal pWal)
		{
			int rc = 0;


			if ((pWal.readOnly) != 0)
			{
				return (int)(8);
			}

			rc = (int)(walLockExclusive(pWal, (int)(0), (int)(1)));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			pWal.writeLock = (byte)(1);
			if (memcmp(&pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr))) != 0)
			{
				walUnlockExclusive(pWal, (int)(0), (int)(1));
				pWal.writeLock = (byte)(0);
				rc = (int)(5 | (2 << 8));
			}

			return (int)(rc);
		}
		public static int sqlite3WalCallback(Wal pWal)
		{
			uint ret = (uint)(0);
			if ((pWal) != null)
			{
				ret = (uint)(pWal.iCallback);
				pWal.iCallback = (uint)(0);
			}

			return (int)(ret);
		}
		public static int sqlite3WalCheckpoint(Wal pWal, sqlite3 db, int eMode, delegate19 xBusy, void* pBusyArg, int sync_flags, int nBuf, byte* zBuf, int* pnLog, int* pnCkpt)
		{
			int rc = 0;
			int isChanged = (int)(0);
			int eMode2 = (int)(eMode);
			delegate19 xBusy2 = xBusy;



			if ((pWal.readOnly) != 0)
				return (int)(8);
			(void)(0);
			rc = (int)(walLockExclusive(pWal, (int)(1), (int)(1)));
			if ((rc) == (0))
			{
				pWal.ckptLock = (byte)(1);
				if (eMode != 0)
				{
					rc = (int)(walBusyLock(pWal, xBusy2, pBusyArg, (int)(0), (int)(1)));
					if ((rc) == (0))
					{
						pWal.writeLock = (byte)(1);
					}
					else if ((rc) == (5))
					{
						eMode2 = (int)(0);
						xBusy2 = null;
						rc = (int)(0);
					}
				}
			}

			if ((rc) == (0))
			{
				rc = (int)(walIndexReadHdr(pWal, &isChanged));
				(void)(0);
				if (((isChanged) != 0) && ((pWal.pDbFd.pMethods.iVersion) >= (3)))
				{
					sqlite3OsUnfetch(pWal.pDbFd, (long)(0), null);
				}
			}

			if ((rc) == (0))
			{
				if (((pWal.hdr.mxFrame) != 0) && (walPagesize(pWal) != nBuf))
				{
					rc = (int)(sqlite3CorruptError((int)(64875)));
				}
				else
				{
					rc = (int)(walCheckpoint(pWal, db, (int)(eMode2), xBusy2, pBusyArg, (int)(sync_flags), zBuf));
				}

				if (((rc) == (0)) || ((rc) == (5)))
				{
					if ((pnLog) != null)
						*pnLog = ((int)(pWal.hdr.mxFrame));
					if ((pnCkpt) != null)
						*pnCkpt = ((int)(walCkptInfo(pWal)->nBackfill));
				}
			}

			if ((isChanged) != 0)
			{
				CRuntime.memset(&pWal.hdr, (int)(0), (ulong)(sizeof(WalIndexHdr)));
			}

			sqlite3WalEndWriteTransaction(pWal);
			if ((pWal.ckptLock) != 0)
			{
				walUnlockExclusive(pWal, (int)(1), (int)(1));
				pWal.ckptLock = (byte)(0);
			}

			return (int)(((rc) == (0)) && (eMode != eMode2) ? 5 : rc);
		}
		public static int sqlite3WalClose(Wal pWal, sqlite3 db, int sync_flags, int nBuf, byte* zBuf)
		{
			int rc = (int)(0);
			if ((pWal) != null)
			{
				int isDelete = (int)(0);
				if ((zBuf != null) && ((0) == (rc = (int)(sqlite3OsLock(pWal.pDbFd, (int)(4))))))
				{
					if ((pWal.exclusiveMode) == (0))
					{
						pWal.exclusiveMode = (byte)(1);
					}

					rc = (int)(sqlite3WalCheckpoint(pWal, db, (int)(0), null, null, (int)(sync_flags), (int)(nBuf), zBuf, null, null));
					if ((rc) == (0))
					{
						int bPersist = (int)(-1);
						sqlite3OsFileControlHint(pWal.pDbFd, (int)(10), &bPersist);
						if (bPersist != 1)
						{
							isDelete = (int)(1);
						}
						else if ((pWal.mxWalSize) >= (0))
						{
							walLimitSize(pWal, (long)(0));
						}
					}
				}

				walIndexClose(pWal, (int)(isDelete));
				sqlite3OsClose(pWal.pWalFd);
				if ((isDelete) != 0)
				{
					sqlite3BeginBenignMalloc();
					sqlite3OsDelete(pWal.pVfs, pWal.zWalName, (int)(0));
					sqlite3EndBenignMalloc();
				}

				sqlite3_free((void*)(pWal.apWiData));
				sqlite3_free(pWal);
			}

			return (int)(rc);
		}
		public static uint sqlite3WalDbsize(Wal pWal)
		{
			if (((pWal) != null) && ((pWal.readLock) >= (0)))
			{
				return (uint)(pWal.hdr.nPage);
			}

			return (uint)(0);
		}
		public static int sqlite3WalDefaultHook(void* pClientData, sqlite3 db, sbyte* zDb, int nFrame)
		{
			if ((nFrame) >= ((int)((long)(pClientData))))
			{
				sqlite3BeginBenignMalloc();
				sqlite3_wal_checkpoint(db, zDb);
				sqlite3EndBenignMalloc();
			}

			return (int)(0);
		}
		public static void sqlite3WalEndReadTransaction(Wal pWal)
		{
			sqlite3WalEndWriteTransaction(pWal);
			if ((pWal.readLock) >= (0))
			{
				walUnlockShared(pWal, (int)(3 + (pWal.readLock)));
				pWal.readLock = (short)(-1);
			}
		}
		public static int sqlite3WalEndWriteTransaction(Wal pWal)
		{
			if ((pWal.writeLock) != 0)
			{
				walUnlockExclusive(pWal, (int)(0), (int)(1));
				pWal.writeLock = (byte)(0);
				pWal.iReCksum = (uint)(0);
				pWal.truncateOnCommit = (byte)(0);
			}

			return (int)(0);
		}
		public static int sqlite3WalExclusiveMode(Wal pWal, int op)
		{
			int rc = 0;




			if ((op) == (0))
			{
				if (pWal.exclusiveMode != 0)
				{
					pWal.exclusiveMode = (byte)(0);
					if (walLockShared(pWal, (int)(3 + (pWal.readLock))) != 0)
					{
						pWal.exclusiveMode = (byte)(1);
					}

					rc = (int)((pWal.exclusiveMode) == (0) ? 1 : 0);
				}
				else
				{
					rc = (int)(0);
				}
			}
			else if ((op) > (0))
			{


				walUnlockShared(pWal, (int)(3 + (pWal.readLock)));
				pWal.exclusiveMode = (byte)(1);
				rc = (int)(1);
			}
			else
			{
				rc = (int)((pWal.exclusiveMode) == (0) ? 1 : 0);
			}

			return (int)(rc);
		}
		public static sqlite3_file sqlite3WalFile(Wal pWal)
		{
			return pWal.pWalFd;
		}
		public static int sqlite3WalFindFrame(Wal pWal, uint pgno, uint* piRead)
		{
			uint iRead = (uint)(0);
			uint iLast = (uint)(pWal.hdr.mxFrame);
			int iHash = 0;
			int iMinHash = 0;

			if (((iLast) == (0)) || (((pWal.readLock) == (0)) && ((pWal.bShmUnreliable) == (0))))
			{
				*piRead = (uint)(0);
				return (int)(0);
			}

			iMinHash = (int)(walFramePage((uint)(pWal.minFrame)));
			for (iHash = (int)(walFramePage((uint)(iLast))); (iHash) >= (iMinHash); iHash--)
			{
				WalHashLoc sLoc = new WalHashLoc();
				int iKey = 0;
				int nCollide = 0;
				int rc = 0;
				uint iH = 0;
				rc = (int)(walHashGet(pWal, (int)(iHash), &sLoc));
				if (rc != 0)
				{
					return (int)(rc);
				}

				nCollide = (int)(4096 * 2);
				iKey = (int)(walHash((uint)(pgno)));
				while ((iH = (uint)(0)) != 0)
				{
					uint iFrame = (uint)(iH + sLoc.iZero);
					if ((((iFrame) <= (iLast)) && ((iFrame) >= (pWal.minFrame))) && ((sLoc.aPgno[iH - 1]) == (pgno)))
					{

						iRead = (uint)(iFrame);
					}

					if ((nCollide--) == (0))
					{
						return (int)(sqlite3CorruptError((int)(64156)));
					}

					iKey = (int)(walNextHash((int)(iKey)));
				}

				if ((iRead) != 0)
					break;
			}

			*piRead = (uint)(iRead);
			return (int)(0);
		}
		public static int sqlite3WalFrames(Wal pWal, int szPage, PgHdr pList, uint nTruncate, int isCommit, int sync_flags)
		{
			int rc = 0;
			uint iFrame = 0;
			PgHdr p;
			PgHdr pLast = null;
			int nExtra = (int)(0);
			int szFrame = 0;
			long iOffset = 0;
			WalWriter w = new WalWriter();
			uint iFirst = (uint)(0);
			WalIndexHdr* pLive;



			pLive = (WalIndexHdr*)(walIndexHdr(pWal));
			if (memcmp(&pWal.hdr, (void*)(pLive), (ulong)(sizeof(WalIndexHdr))) != 0)
			{
				iFirst = (uint)(pLive->mxFrame + 1);
			}

			if (0 != (rc = (int)(walRestartLog(pWal))))
			{
				return (int)(rc);
			}

			iFrame = (uint)(pWal.hdr.mxFrame);
			if ((iFrame) == (0))
			{
				byte* aWalHdr = stackalloc byte[32];
				uint* aCksum = stackalloc uint[2];
				sqlite3Put4byte(&aWalHdr[0], (uint)(0x377f0682 | 0));
				sqlite3Put4byte(&aWalHdr[4], (uint)(3007000));
				sqlite3Put4byte(&aWalHdr[8], (uint)(szPage));
				sqlite3Put4byte(&aWalHdr[12], (uint)(pWal.nCkpt));
				if ((pWal.nCkpt) == (0))
					sqlite3_randomness((int)(8), pWal.hdr.aSalt);
				CRuntime.memcpy(&aWalHdr[16], pWal.hdr.aSalt, (ulong)(8));
				walChecksumBytes((int)(1), aWalHdr, (int)(32 - 2 * 4), null, aCksum);
				sqlite3Put4byte(&aWalHdr[24], (uint)(aCksum[0]));
				sqlite3Put4byte(&aWalHdr[28], (uint)(aCksum[1]));
				pWal.szPage = (uint)(szPage);
				pWal.hdr.bigEndCksum = (byte)(0);
				pWal.hdr.aFrameCksum[0] = (uint)(aCksum[0]);
				pWal.hdr.aFrameCksum[1] = (uint)(aCksum[1]);
				pWal.truncateOnCommit = (byte)(1);
				rc = (int)(sqlite3OsWrite(pWal.pWalFd, aWalHdr, (int)(32 * sizeof(byte)), (long)(0)));
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((pWal.syncHeader) != 0)
				{
					rc = (int)(sqlite3OsSync(pWal.pWalFd, (int)(((sync_flags) >> 2) & 0x03)));
					if ((rc) != 0)
						return (int)(rc);
				}
			}


			w.pWal = pWal;
			w.pFd = pWal.pWalFd;
			w.iSyncPoint = (long)(0);
			w.syncFlags = (int)(sync_flags);
			w.szPage = (int)(szPage);
			iOffset = (long)(32 + ((iFrame + 1) - 1) * (long)((szPage) + 24));
			szFrame = (int)(szPage + 24);
			for (p = pList; p; p = p.pDirty)
			{
				int nDbSize = 0;
				if (((iFirst) != 0) && (((p.pDirty) != null) || ((isCommit) == (0))))
				{
					uint iWrite = (uint)(0);
					sqlite3WalFindFrame(pWal, (uint)(p.pgno), &iWrite);

					if ((iWrite) >= (iFirst))
					{
						long iOff = (long)((32 + ((iWrite) - 1) * (long)((szPage) + 24)) + 24);
						void* pData;
						if (((pWal.iReCksum) == (0)) || ((iWrite) < (pWal.iReCksum)))
						{
							pWal.iReCksum = (uint)(iWrite);
						}

						pData = p.pData;
						rc = (int)(sqlite3OsWrite(pWal.pWalFd, pData, (int)(szPage), (long)(iOff)));
						if ((rc) != 0)
							return (int)(rc);
						p.flags &= (ushort)(~0x040);
						continue;
					}
				}

				iFrame++;

				nDbSize = (int)((((isCommit) != 0) && ((p.pDirty) == (null))) ? nTruncate : 0);
				rc = (int)(walWriteOneFrame(w, p, (int)(nDbSize), (long)(iOffset)));
				if ((rc) != 0)
					return (int)(rc);
				pLast = p;
				iOffset += (long)(szFrame);
				p.flags |= (ushort)(0x040);
			}

			if (((isCommit) != 0) && ((pWal.iReCksum) != 0))
			{
				rc = (int)(walRewriteChecksums(pWal, (uint)(iFrame)));
				if ((rc) != 0)
					return (int)(rc);
			}

			if (((isCommit) != 0) && (((sync_flags) & 0x03) != 0))
			{
				int bSync = (int)(1);
				if ((pWal.padToSectorBoundary) != 0)
				{
					int sectorSize = (int)(sqlite3SectorSize(pWal.pWalFd));
					w.iSyncPoint = (long)(((iOffset + sectorSize - 1) / sectorSize) * sectorSize);
					bSync = (int)((w.iSyncPoint) == (iOffset) ? 1 : 0);
					while ((iOffset) < (w.iSyncPoint))
					{
						rc = (int)(walWriteOneFrame(w, pLast, (int)(nTruncate), (long)(iOffset)));
						if ((rc) != 0)
							return (int)(rc);
						iOffset += (long)(szFrame);
						nExtra++;

					}
				}

				if ((bSync) != 0)
				{

					rc = (int)(sqlite3OsSync(w.pFd, (int)((sync_flags) & 0x03)));
				}
			}

			if ((((isCommit) != 0) && ((pWal.truncateOnCommit) != 0)) && ((pWal.mxWalSize) >= (0)))
			{
				long sz = (long)(pWal.mxWalSize);
				if ((32 + ((iFrame + nExtra + 1) - 1) * (long)((szPage) + 24)) > (pWal.mxWalSize))
				{
					sz = (long)(32 + ((iFrame + nExtra + 1) - 1) * (long)((szPage) + 24));
				}

				walLimitSize(pWal, (long)(sz));
				pWal.truncateOnCommit = (byte)(0);
			}

			iFrame = (uint)(pWal.hdr.mxFrame);
			for (p = pList; ((p) != null) && ((rc) == (0)); p = p.pDirty)
			{
				if ((p.flags & 0x040) == (0))
					continue;
				iFrame++;
				rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(p.pgno)));
			}


			while (((rc) == (0)) && ((nExtra) > (0)))
			{
				iFrame++;
				nExtra--;
				rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(pLast.pgno)));
			}

			if ((rc) == (0))
			{
				pWal.hdr.szPage = ((ushort)((szPage & 0xff00) | (szPage >> 16)));
				pWal.hdr.mxFrame = (uint)(iFrame);
				if ((isCommit) != 0)
				{
					pWal.hdr.iChange++;
					pWal.hdr.nPage = (uint)(nTruncate);
				}

				if ((isCommit) != 0)
				{
					walIndexWriteHdr(pWal);
					pWal.iCallback = (uint)(iFrame);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3WalHeapMemory(Wal pWal)
		{
			return ((((pWal) != null) && ((pWal.exclusiveMode) == (2))) ? 1 : 0);
		}
		public static void sqlite3WalkerDepthDecrease(Walker pWalker, Select pSelect)
		{
			(void)(pSelect);
			pWalker.walkerDepth--;
		}
		public static int sqlite3WalkerDepthIncrease(Walker pWalker, Select pSelect)
		{
			(void)(pSelect);
			pWalker.walkerDepth++;
			return (int)(0);
		}
		public static int sqlite3WalkExpr(Walker pWalker, Expr pExpr)
		{
			return (int)(pExpr ? walkExpr(pWalker, pExpr) : 0);
		}
		public static int sqlite3WalkExprList(Walker pWalker, ExprList p)
		{
			int i = 0;
			ExprList_item* pItem;
			if ((p) != null)
			{
				for (i = (int)(p.nExpr), pItem = p.a; (i) > (0); i--, pItem++)
				{
					if ((sqlite3WalkExpr(pWalker, pItem->pExpr)) != 0)
						return (int)(2);
				}
			}

			return (int)(0);
		}
		public static int sqlite3WalkSelect(Walker pWalker, Select p)
		{
			int rc = 0;
			if ((p) == (null))
				return (int)(0);
			if ((pWalker.xSelectCallback) == (null))
				return (int)(0);
			do
			{
				rc = (int)(pWalker.xSelectCallback(pWalker, p));
				if ((rc) != 0)
					return (int)(rc & 2);
				if (((sqlite3WalkSelectExpr(pWalker, p)) != 0) || ((sqlite3WalkSelectFrom(pWalker, p)) != 0))
				{
					return (int)(2);
				}

				if ((pWalker.xSelectCallback2) != null)
				{
					pWalker.xSelectCallback2(pWalker, p);
				}

				p = p.pPrior;
			}
			while (p != null);
			return (int)(0);
		}
		public static int sqlite3WalkSelectExpr(Walker pWalker, Select p)
		{
			if ((sqlite3WalkExprList(pWalker, p.pEList)) != 0)
				return (int)(2);
			if ((sqlite3WalkExpr(pWalker, p.pWhere)) != 0)
				return (int)(2);
			if ((sqlite3WalkExprList(pWalker, p.pGroupBy)) != 0)
				return (int)(2);
			if ((sqlite3WalkExpr(pWalker, p.pHaving)) != 0)
				return (int)(2);
			if ((sqlite3WalkExprList(pWalker, p.pOrderBy)) != 0)
				return (int)(2);
			if ((sqlite3WalkExpr(pWalker, p.pLimit)) != 0)
				return (int)(2);
			if ((p.pWinDefn) != null)
			{
				Parse pParse;
				if ((((pWalker.xSelectCallback2) == (sqlite3WalkWinDefnDummyCallback)) || (((pParse = pWalker.pParse) != null) && ((pParse.eParseMode) >= (2)))) || ((pWalker.xSelectCallback2) == (sqlite3SelectPopWith)))
				{
					int rc = (int)(walkWindowList(pWalker, p.pWinDefn, (int)(0)));
					return (int)(rc);
				}
			}

			return (int)(0);
		}
		public static int sqlite3WalkSelectFrom(Walker pWalker, Select p)
		{
			SrcList pSrc;
			int i = 0;
			SrcItem pItem;
			pSrc = p.pSrc;
			if ((pSrc) != null)
			{
				for (i = (int)(pSrc.nSrc), pItem = pSrc.a; (i) > (0); i--, pItem++)
				{
					if (((pItem.pSelect) != null) && ((sqlite3WalkSelect(pWalker, pItem.pSelect)) != 0))
					{
						return (int)(2);
					}

					if (((pItem.fg.isTabFunc) != 0) && ((sqlite3WalkExprList(pWalker, pItem.u1.pFuncArg)) != 0))
					{
						return (int)(2);
					}
				}
			}

			return (int)(0);
		}
		public static void sqlite3WalkWinDefnDummyCallback(Walker pWalker, Select p)
		{
			(void)(pWalker);
			(void)(p);
		}
		public static void sqlite3WalLimit(Wal pWal, long iLimit)
		{
			if ((pWal) != null)
				pWal.mxWalSize = (long)(iLimit);
		}
		public static int sqlite3WalOpen(sqlite3_vfs pVfs, sqlite3_file pDbFd, sbyte* zWalName, int bNoShm, long mxWalSize, Wal ppWal)
		{
			int rc = 0;
			Wal pRet;
			int flags = 0;
























			ppWal = null;
			pRet = (Wal)(sqlite3MallocZero((ulong)(sizeof(Wal) + pVfs.szOsFile)));
			if (pRet == null)
			{
				return (int)(7);
			}

			pRet.pVfs = pVfs;
			pRet.pWalFd = (sqlite3_file)(pRet[1]);
			pRet.pDbFd = pDbFd;
			pRet.readLock = (short)(-1);
			pRet.mxWalSize = (long)(mxWalSize);
			pRet.zWalName = zWalName;
			pRet.syncHeader = (byte)(1);
			pRet.padToSectorBoundary = (byte)(1);
			pRet.exclusiveMode = (byte)((bNoShm) != 0 ? 2 : 0);
			flags = (int)(0x00000002 | 0x00000004 | 0x00080000);
			rc = (int)(sqlite3OsOpen(pVfs, zWalName, pRet.pWalFd, (int)(flags), &flags));
			if (((rc) == (0)) && ((flags & 0x00000001) != 0))
			{
				pRet.readOnly = (byte)(1);
			}

			if (rc != 0)
			{
				walIndexClose(pRet, (int)(0));
				sqlite3OsClose(pRet.pWalFd);
				sqlite3_free(pRet);
			}
			else
			{
				int iDC = (int)(sqlite3OsDeviceCharacteristics(pDbFd));
				if ((iDC & 0x00000400) != 0)
				{
					pRet.syncHeader = (byte)(0);
				}

				if ((iDC & 0x00001000) != 0)
				{
					pRet.padToSectorBoundary = (byte)(0);
				}

				ppWal = pRet;
			}

			return (int)(rc);
		}
		public static int sqlite3WalReadFrame(Wal pWal, uint iRead, int nOut, byte* pOut)
		{
			int sz = 0;
			long iOffset = 0;
			sz = (int)(pWal.hdr.szPage);
			sz = (int)((sz & 0xfe00) + ((sz & 0x0001) << 16));
			iOffset = (long)((32 + ((iRead) - 1) * (long)((sz) + 24)) + 24);
			return (int)(sqlite3OsRead(pWal.pWalFd, pOut, (int)((nOut) > (sz) ? sz : nOut), (long)(iOffset)));
		}
		public static void sqlite3WalSavepoint(Wal pWal, uint* aWalData)
		{

			aWalData[0] = (uint)(pWal.hdr.mxFrame);
			aWalData[1] = (uint)(pWal.hdr.aFrameCksum[0]);
			aWalData[2] = (uint)(pWal.hdr.aFrameCksum[1]);
			aWalData[3] = (uint)(pWal.nCkpt);
		}
		public static int sqlite3WalSavepointUndo(Wal pWal, uint* aWalData)
		{
			int rc = (int)(0);


			if (aWalData[3] != pWal.nCkpt)
			{
				aWalData[0] = (uint)(0);
				aWalData[3] = (uint)(pWal.nCkpt);
			}

			if ((aWalData[0]) < (pWal.hdr.mxFrame))
			{
				pWal.hdr.mxFrame = (uint)(aWalData[0]);
				pWal.hdr.aFrameCksum[0] = (uint)(aWalData[1]);
				pWal.hdr.aFrameCksum[1] = (uint)(aWalData[2]);
				walCleanupHash(pWal);
			}

			return (int)(rc);
		}
		public static int sqlite3WalUndo(Wal pWal, delegate59 xUndo, void* pUndoCtx)
		{
			int rc = (int)(0);
			if ((pWal.writeLock) != 0)
			{
				uint iMax = (uint)(pWal.hdr.mxFrame);
				uint iFrame = 0;
				CRuntime.memcpy(&pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr)));
				for (iFrame = (uint)(pWal.hdr.mxFrame + 1); ((rc) == (0)) && ((iFrame) <= (iMax)); iFrame++)
				{

					rc = (int)(xUndo(pUndoCtx, (uint)(walFramePgno(pWal, (uint)(iFrame)))));
				}

				if (iMax != pWal.hdr.mxFrame)
					walCleanupHash(pWal);
			}

			return (int)(rc);
		}
		public static void sqlite3WhereAddLimit(WhereClause pWC, Select p)
		{

			if (((((p) != null) && ((p.pLimit) != null)) && ((p.selFlags & (0x0000001 | 0x0000008)) == (0))) && (((p.pSrc.nSrc) == (1)) && (((p.pSrc.a[0].pTab).eTabType) == (1))))
			{
				ExprList pOrderBy = p.pOrderBy;
				int iCsr = (int)(p.pSrc.a[0].iCursor);
				int ii = 0;
				for (ii = (int)(0); (ii) < (pWC.nTerm); ii++)
				{
					if ((pWC.a[ii].wtFlags & 0x0004) != 0)
					{


						continue;
					}

					if (pWC.a[ii].leftCursor != iCsr)
						return;
				}

				if ((pOrderBy) != null)
				{
					for (ii = (int)(0); (ii) < (pOrderBy.nExpr); ii++)
					{
						Expr pExpr = pOrderBy.a[ii].pExpr;
						if (pExpr.op != 167)
							return;
						if (pExpr.iTable != iCsr)
							return;
						if ((pOrderBy.a[ii].sortFlags & 0x02) != 0)
							return;
					}
				}


				whereAddLimitExpr(pWC, (int)(p.iLimit), p.pLimit.pLeft, (int)(iCsr), (int)(73));
				if ((p.iOffset) > (0))
				{
					whereAddLimitExpr(pWC, (int)(p.iOffset), p.pLimit.pRight, (int)(iCsr), (int)(74));
				}
			}
		}
		public static WhereInfo sqlite3WhereBegin(Parse pParse, SrcList pTabList, Expr pWhere, ExprList pOrderBy, ExprList pResultSet, Select pLimit, ushort wctrlFlags, int iAuxArg)
		{
			int nByteWInfo = 0;
			int nTabList = 0;
			WhereInfo pWInfo;
			Vdbe v = pParse.pVdbe;
			ulong notReady = 0;
			WhereLoopBuilder sWLB = new WhereLoopBuilder();
			WhereMaskSet* pMaskSet;
			WhereLevel pLevel;
			WhereLoop pLoop;
			int ii = 0;
			sqlite3 db;
			int rc = 0;
			byte bFordelete = (byte)(0);


			db = pParse.db;
			CRuntime.memset(sWLB, (int)(0), (ulong)(sizeof(WhereLoopBuilder)));
			if (((pOrderBy) != null) && ((pOrderBy.nExpr) >= ((int)(sizeof(ulong) * 8))))
				pOrderBy = null;
			if ((pTabList.nSrc) > ((int)(sizeof(ulong) * 8)))
			{
				sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int)(sizeof(ulong) * 8)));
				return null;
			}

			nTabList = (int)((wctrlFlags & 0x0020) ? 1 : pTabList.nSrc);
			nByteWInfo = (int)(((sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel)) + 7) & ~7);
			pWInfo = sqlite3DbMallocRawNN(db, (ulong)(nByteWInfo + sizeof(WhereLoop)));
			if ((db.mallocFailed) != 0)
			{
				sqlite3DbFree(db, pWInfo);
				pWInfo = null;
				goto whereBeginError;
			}

			pWInfo.pParse = pParse;
			pWInfo.pTabList = pTabList;
			pWInfo.pOrderBy = pOrderBy;
			pWInfo.pWhere = pWhere;
			pWInfo.pResultSet = pResultSet;
			pWInfo.aiCurOnePass[0] = (int)(pWInfo.aiCurOnePass[1] = (int)(-1));
			pWInfo.nLevel = (byte)(nTabList);
			pWInfo.iBreak = (int)(pWInfo.iContinue = (int)(sqlite3VdbeMakeLabel(pParse)));
			pWInfo.wctrlFlags = (ushort)(wctrlFlags);
			pWInfo.iLimit = (short)(iAuxArg);
			pWInfo.savedNQueryLoop = (int)(pParse.nQueryLoop);
			pWInfo.pLimit = pLimit;
			CRuntime.memset(&pWInfo.nOBSat, (int)(0), (ulong)(((ulong)((0).sWC)) - ((ulong)(&((0).nOBSat)))));
			CRuntime.memset(pWInfo.a[0], (int)(0), (ulong)(sizeof(WhereLoop) + nTabList * sizeof(WhereLevel)));

			pMaskSet = &pWInfo.sMaskSet;
			pMaskSet->n = (int)(0);
			pMaskSet->ix[0] = (int)(-99);
			sWLB.pWInfo = pWInfo;
			sWLB.pWC = pWInfo.sWC;
			sWLB.pNew = (WhereLoop)(((sbyte*)(pWInfo)) + nByteWInfo);

			whereLoopInit(sWLB.pNew);
			sqlite3WhereClauseInit(pWInfo.sWC, pWInfo);
			sqlite3WhereSplit(pWInfo.sWC, pWhere, (byte)(44));
			if ((nTabList) == (0))
			{
				if ((pOrderBy) != null)
					pWInfo.nOBSat = (sbyte)(pOrderBy.nExpr);
				if (((wctrlFlags & 0x0100) != 0) && (((db).dbOptFlags & (0x00000010)) == (0)))
				{
					pWInfo.eDistinct = (byte)(1);
				}

				sqlite3VdbeExplain(pParse, (byte)(0), "SCAN CONSTANT ROW");
			}
			else
			{
				ii = (int)(0);
				do
				{
					createMask(pMaskSet, (int)(pTabList.a[ii].iCursor));
					sqlite3WhereTabFuncArgs(pParse, pTabList.a[ii], pWInfo.sWC);
				}
				while ((++ii) < (pTabList.nSrc));
			}

			sqlite3WhereExprAnalyze(pTabList, pWInfo.sWC);
			sqlite3WhereAddLimit(pWInfo.sWC, pLimit);
			if ((db.mallocFailed) != 0)
				goto whereBeginError;
			for (ii = (int)(0); (ii) < (sWLB.pWC.nBase); ii++)
			{
				WhereTerm pT = sWLB.pWC.a[ii];
				if ((pT.wtFlags & 0x0002) != 0)
					continue;
				if (((pT.prereqAll) == (0)) && (((nTabList) == (0)) || ((exprIsDeterministic(pT.pExpr)) != 0)))
				{
					sqlite3ExprIfFalse(pParse, pT.pExpr, (int)(pWInfo.iBreak), (int)(0x10));
					pT.wtFlags |= (ushort)(0x0004);
				}
			}

			if ((wctrlFlags & 0x0100) != 0)
			{
				if ((((db).dbOptFlags & (0x00000010)) != 0))
				{
					wctrlFlags &= (ushort)(~0x0100);
					pWInfo.wctrlFlags &= (ushort)(~0x0100);
				}
				else if ((isDistinctRedundant(pParse, pTabList, pWInfo.sWC, pResultSet)) != 0)
				{
					pWInfo.eDistinct = (byte)(1);
				}
				else if ((pOrderBy) == (null))
				{
					pWInfo.wctrlFlags |= (ushort)(0x0080);
					pWInfo.pOrderBy = pResultSet;
				}
			}

			if ((nTabList != 1) || ((whereShortCut(sWLB)) == (0)))
			{
				rc = (int)(whereLoopAddAll(sWLB));
				if ((rc) != 0)
					goto whereBeginError;
				wherePathSolver(pWInfo, (short)(0));
				if ((db.mallocFailed) != 0)
					goto whereBeginError;
				if ((pWInfo.pOrderBy) != null)
				{
					wherePathSolver(pWInfo, (short)(pWInfo.nRowOut + 1));
					if ((db.mallocFailed) != 0)
						goto whereBeginError;
				}
			}

			if (((pWInfo.pOrderBy) == (null)) && ((db.flags & 0x00001000) != 0))
			{
				pWInfo.revMask = ((ulong)(-1));
			}

			if ((pParse.nErr) != 0)
			{
				goto whereBeginError;
			}


			notReady = (ulong)(~(ulong)(0));
			if (((((pWInfo.nLevel) >= (2)) && (pResultSet != null)) && ((0) == (wctrlFlags & 0x0400))) && (((db).dbOptFlags & (0x00000100)) == (0)))
			{
				notReady = (ulong)(whereOmitNoopJoin(pWInfo, (ulong)(notReady)));
				nTabList = (int)(pWInfo.nLevel);

			}

			if (((pWInfo.nLevel) >= (2)) && (((db).dbOptFlags & (0x00080000)) == (0)))
			{
				whereCheckIfBloomFilterIsUseful(pWInfo);
			}

			pWInfo.pParse.nQueryLoop += (uint)(pWInfo.nRowOut);

			if ((wctrlFlags & 0x0004) != 0)
			{
				int wsFlags = (int)(pWInfo.a[0].pWLoop.wsFlags);
				int bOnerow = (int)((wsFlags & 0x00001000) != 0);

				if (((bOnerow) != 0) || (((0 != (wctrlFlags & 0x0008)) && (!(((pTabList.a[0].pTab).eTabType) == (1)))) && (((0) == (wsFlags & 0x00002000)) || ((wctrlFlags & 0x0010) != 0))))
				{
					pWInfo.eOnePass = (byte)((bOnerow) != 0 ? 1 : 2);
					if ((((pTabList.a[0].pTab).tabFlags & 0x00000080) == (0)) && ((wsFlags & 0x00000040) != 0))
					{
						if ((wctrlFlags & 0x0008) != 0)
						{
							bFordelete = (byte)(0x08);
						}

						pWInfo.a[0].pWLoop.wsFlags = (uint)(wsFlags & ~0x00000040);
					}
				}
			}

			for (ii = (int)(0), pLevel = pWInfo.a; (ii) < (nTabList); ii++, pLevel++)
			{
				Table pTab;
				int iDb = 0;
				SrcItem pTabItem;
				pTabItem = pTabList.a[pLevel.iFrom];
				pTab = pTabItem.pTab;
				iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
				pLoop = pLevel.pWLoop;
				if (((pTab.tabFlags & 0x00004000) != 0) || (((pTab).eTabType) == (2)))
				{
				}
				else if ((pLoop.wsFlags & 0x00000400) != 0)
				{
					sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
					int iCur = (int)(pTabItem.iCursor);
					sqlite3VdbeAddOp4(v, (int)(172), (int)(iCur), (int)(0), (int)(0), pVTab, (int)(-12));
				}
				else if ((((pTab).eTabType) == (1)))
				{
				}
				else if (((pLoop.wsFlags & 0x00000040) == (0)) && ((wctrlFlags & 0x0020) == (0)))
				{
					int op = (int)(101);
					if (pWInfo.eOnePass != 0)
					{
						op = (int)(112);
						pWInfo.aiCurOnePass[0] = (int)(pTabItem.iCursor);
					}

					sqlite3OpenTable(pParse, (int)(pTabItem.iCursor), (int)(iDb), pTab, (int)(op));

					if (((((pWInfo.eOnePass) == (0)) && ((pTab.nCol) < ((int)(sizeof(ulong) * 8)))) && ((pTab.tabFlags & (0x00000060 | 0x00000080)) == (0))) && ((pLoop.wsFlags & (0x00004000 | 0x00400000)) == (0)))
					{
						ulong b = (ulong)(pTabItem.colUsed);
						int n = (int)(0);
						for (b; ; b = (ulong)(b >> 1), n++)
						{
						}

						sqlite3VdbeChangeP4(v, (int)(-1), ((void*)((long)(n))), (int)(-3));

					}

					{
						sqlite3VdbeChangeP5(v, (ushort)(bFordelete));
					}
				}
				else
				{
					sqlite3TableLock(pParse, (int)(iDb), (uint)(pTab.tnum), (byte)(0), pTab.zName);
				}

				if ((pLoop.wsFlags & 0x00000200) != 0)
				{
					Index pIx = pLoop.u.btree.pIndex;
					int iIndexCur = 0;
					int op = (int)(101);

					if (((!(((pTab).tabFlags & 0x00000080) == (0))) && (((pIx).idxType) == (2))) && ((wctrlFlags & 0x0020) != 0))
					{
						iIndexCur = (int)(pLevel.iTabCur);
						op = (int)(0);
					}
					else if (pWInfo.eOnePass != 0)
					{
						Index pJ = pTabItem.pTab.pIndex;
						iIndexCur = (int)(iAuxArg);

						while (((pJ) != null) && (pJ != pIx))
						{
							iIndexCur++;
							pJ = pJ.pNext;
						}

						op = (int)(112);
						pWInfo.aiCurOnePass[1] = (int)(iIndexCur);
					}
					else if (((iAuxArg) != 0) && ((wctrlFlags & 0x0020) != 0))
					{
						iIndexCur = (int)(iAuxArg);
						op = (int)(100);
					}
					else
					{
						iIndexCur = (int)(pParse.nTab++);
					}

					pLevel.iIdxCur = (int)(iIndexCur);


					if ((op) != 0)
					{
						sqlite3VdbeAddOp3(v, (int)(op), (int)(iIndexCur), (int)(pIx.tnum), (int)(iDb));
						sqlite3VdbeSetP4KeyInfo(pParse, pIx);
						if (((((((pLoop.wsFlags & 0x0000000f) != 0) && ((pLoop.wsFlags & (0x00000002 | 0x00008000)) == (0))) && ((pLoop.wsFlags & 0x00080000) == (0))) && ((pLoop.wsFlags & 0x00100000) == (0))) && ((pWInfo.wctrlFlags & 0x0001) == (0))) && (pWInfo.eDistinct != 2))
						{
							sqlite3VdbeChangeP5(v, (ushort)(0x02));
						}
					}
				}

				if ((iDb) >= (0))
					sqlite3CodeVerifySchema(pParse, (int)(iDb));
			}

			pWInfo.iTop = (int)(sqlite3VdbeCurrentAddr(v));
			if ((db.mallocFailed) != 0)
				goto whereBeginError;
			for (ii = (int)(0); (ii) < (nTabList); ii++)
			{
				int addrExplain = 0;
				int wsFlags = 0;
				if ((pParse.nErr) != 0)
					goto whereBeginError;
				pLevel = pWInfo.a[ii];
				wsFlags = (int)(pLevel.pWLoop.wsFlags);
				if ((wsFlags & (0x00004000 | 0x00400000)) != 0)
				{
					if ((wsFlags & 0x00004000) != 0)
					{
						constructAutomaticIndex(pParse, pWInfo.sWC, pTabList.a[pLevel.iFrom], (ulong)(notReady), pLevel);
					}
					else
					{
						sqlite3ConstructBloomFilter(pWInfo, (int)(ii), pLevel, (ulong)(notReady));
					}

					if ((db.mallocFailed) != 0)
						goto whereBeginError;
				}

				addrExplain = (int)(sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, (ushort)(wctrlFlags)));
				pLevel.addrBody = (int)(sqlite3VdbeCurrentAddr(v));
				notReady = (ulong)(sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, (int)(ii), pLevel, (ulong)(notReady)));
				pWInfo.iContinue = (int)(pLevel.addrCont);
				if (((wsFlags & 0x00002000) == (0)) && ((wctrlFlags & 0x0020) == (0)))
				{
					((void)(addrExplain));
				}
			}

			pWInfo.iEndWhere = (int)(sqlite3VdbeCurrentAddr(v));
			return pWInfo;
		whereBeginError:
			; if ((pWInfo) != null) { whereUndoExprMods(pWInfo); pParse.nQueryLoop = (uint)(pWInfo.savedNQueryLoop); whereInfoFree(db, pWInfo); }
			return null;
		}
		public static int sqlite3WhereBreakLabel(WhereInfo pWInfo)
		{
			return (int)(pWInfo.iBreak);
		}
		public static void sqlite3WhereClauseClear(WhereClause pWC)
		{
			sqlite3 db = pWC.pWInfo.pParse.db;

			if ((pWC.nTerm) > (0))
			{
				WhereTerm a = pWC.a;
				WhereTerm aLast = pWC.a[pWC.nTerm - 1];
				while ((1) != 0)
				{

					if ((a.wtFlags & 0x0001) != 0)
					{
						sqlite3ExprDelete(db, a.pExpr);
					}

					if ((a.wtFlags & (0x0010 | 0x0020)) != 0)
					{
						if ((a.wtFlags & 0x0010) != 0)
						{

							whereOrInfoDelete(db, a.u.pOrInfo);
						}
						else
						{

							whereAndInfoDelete(db, a.u.pAndInfo);
						}
					}

					if ((a) == (aLast))
						break;
					a++;
				}
			}

			if (pWC.a != pWC.aStatic)
			{
				sqlite3DbFree(db, pWC.a);
			}
		}
		public static void sqlite3WhereClauseInit(WhereClause pWC, WhereInfo pWInfo)
		{
			pWC.pWInfo = pWInfo;
			pWC.hasOr = (byte)(0);
			pWC.pOuter = null;
			pWC.nTerm = (int)(0);
			pWC.nBase = (int)(0);
			pWC.nSlot = ((int)(8 * sizeof(WhereTerm) / sizeof(WhereTerm)));
			pWC.a = pWC.aStatic;
		}
		public static ulong sqlite3WhereCodeOneLoopStart(Parse pParse, Vdbe v, WhereInfo pWInfo, int iLevel, WhereLevel pLevel, ulong notReady)
		{
			int j = 0; int k = 0;
			int iCur = 0;
			int addrNxt = 0;
			int bRev = 0;
			WhereLoop pLoop;
			WhereClause pWC;
			WhereTerm pTerm;
			sqlite3 db;
			SrcItem pTabItem;
			int addrBrk = 0;
			int addrHalt = 0;
			int addrCont = 0;
			int iRowidReg = (int)(0);
			int iReleaseReg = (int)(0);
			Index pIdx = null;
			int iLoop = 0;
			pWC = pWInfo.sWC;
			db = pParse.db;
			pLoop = pLevel.pWLoop;
			pTabItem = pWInfo.pTabList.a[pLevel.iFrom];
			iCur = (int)(pTabItem.iCursor);
			pLevel.notReady = (ulong)(notReady & ~sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(iCur)));
			bRev = (int)((pWInfo.revMask >> iLevel) & 1);
			addrBrk = (int)(pLevel.addrBrk = (int)(pLevel.addrNxt = (int)(sqlite3VdbeMakeLabel(pParse))));
			addrCont = (int)(pLevel.addrCont = (int)(sqlite3VdbeMakeLabel(pParse)));

			if (((pLevel.iFrom) > (0)) && ((pTabItem[0].fg.jointype & 0x0008) != 0))
			{
				pLevel.iLeftJoin = (int)(++pParse.nMem);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pLevel.iLeftJoin));
			}

			for (j = (int)(iLevel); ((j) > (0)) && ((pWInfo.a[j].iLeftJoin) == (0)); j--)
			{
			}

			addrHalt = (int)(pWInfo.a[j].addrBrk);
			if ((pTabItem.fg.viaCoroutine) != 0)
			{
				int regYield = (int)(pTabItem.regReturn);
				sqlite3VdbeAddOp3(v, (int)(13), (int)(regYield), (int)(0), (int)(pTabItem.addrFillSub));
				pLevel.p2 = (int)(sqlite3VdbeAddOp2(v, (int)(14), (int)(regYield), (int)(addrBrk)));
				pLevel.op = (byte)(11);
			}
			else if ((pLoop.wsFlags & 0x00000400) != 0)
			{
				int iReg = 0;
				int addrNotFound = 0;
				int nConstraint = (int)(pLoop.nLTerm);
				iReg = (int)(sqlite3GetTempRange(pParse, (int)(nConstraint + 2)));
				addrNotFound = (int)(pLevel.addrBrk);
				for (j = (int)(0); (j) < (nConstraint); j++)
				{
					int iTarget = (int)(iReg + j + 2);
					pTerm = pLoop.aLTerm[j];
					if (((pTerm) == (null)))
						continue;
					if ((pTerm.eOperator & 0x0001) != 0)
					{
						if ((((j) <= (31) ? ((uint)(1)) << (j) : 0) & pLoop.u.vtab.mHandleIn) != 0)
						{
							int iTab = (int)(pParse.nTab++);
							int iCache = (int)(++pParse.nMem);
							sqlite3CodeRhsOfIN(pParse, pTerm.pExpr, (int)(iTab));
							sqlite3VdbeAddOp3(v, (int)(173), (int)(iTab), (int)(iTarget), (int)(iCache));
						}
						else
						{
							codeEqualityTerm(pParse, pTerm, pLevel, (int)(j), (int)(bRev), (int)(iTarget));
							addrNotFound = (int)(pLevel.addrNxt);
						}
					}
					else
					{
						Expr pRight = pTerm.pExpr.pRight;
						codeExprOrVector(pParse, pRight, (int)(iTarget), (int)(1));
						if (((pTerm.eMatchOp) == (74)) && ((pLoop.u.vtab.bOmitOffset) != 0))
						{



							sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWInfo.pLimit.iOffset));
						}
					}
				}

				sqlite3VdbeAddOp2(v, (int)(71), (int)(pLoop.u.vtab.idxNum), (int)(iReg));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(nConstraint), (int)(iReg + 1));
				sqlite3VdbeAddOp4(v, (int)(9), (int)(iCur), (int)(addrNotFound), (int)(iReg), pLoop.u.vtab.idxStr, (int)((pLoop.u.vtab.needFree) != 0 ? (-7) : (-1)));
				pLoop.u.vtab.needFree = (uint)(0);
				if ((db.mallocFailed) != 0)
					pLoop.u.vtab.idxStr = null;
				pLevel.p1 = (int)(iCur);
				pLevel.op = (byte)((pWInfo.eOnePass) != 0 ? 182 : 62);
				pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));

				for (j = (int)(0); (j) < (nConstraint); j++)
				{
					pTerm = pLoop.aLTerm[j];
					if (((j) < (16)) && (((pLoop.u.vtab.omitMask >> j) & 1) != 0))
					{
						disableTerm(pLevel, pTerm);
						continue;
					}

					if ((((pTerm.eOperator & 0x0001) != 0) && ((((j) <= (31) ? ((uint)(1)) << (j) : 0) & pLoop.u.vtab.mHandleIn) == (0))) && (db.mallocFailed == 0))
					{
						Expr pCompare;
						Expr pRight;
						VdbeOp* pOp;
						int iIn = 0;
						for (iIn = (int)(0); ((iIn) < (pLevel.u._in_.nIn)); iIn++)
						{
							pOp = sqlite3VdbeGetOp(v, (int)(pLevel.u._in_.aInLoop[iIn].addrInTop));
							if ((((pOp->opcode) == (93)) && ((pOp->p3) == (iReg + j + 2))) || (((pOp->opcode) == (134)) && ((pOp->p2) == (iReg + j + 2))))
							{
								sqlite3VdbeAddOp3(v, (int)(pOp->opcode), (int)(pOp->p1), (int)(pOp->p2), (int)(pOp->p3));
								break;
							}
						}

						pCompare = sqlite3PExpr(pParse, (int)(53), null, null);
						if (db.mallocFailed == 0)
						{
							int iFld = (int)(pTerm.u.x.iField);
							Expr pLeft = pTerm.pExpr.pLeft;

							if ((iFld) > (0))
							{



								pCompare.pLeft = pLeft.x.pList.a[iFld - 1].pExpr;
							}
							else
							{
								pCompare.pLeft = pLeft;
							}

							pCompare.pRight = pRight = sqlite3Expr(db, (int)(176), null);
							if ((pRight) != null)
							{
								pRight.iTable = (int)(iReg + j + 2);
								sqlite3ExprIfFalse(pParse, pCompare, (int)(pLevel.addrCont), (int)(0x10));
							}

							pCompare.pLeft = null;
						}

						sqlite3ExprDelete(db, pCompare);
					}
				}
			}
			else if (((pLoop.wsFlags & 0x00000100) != 0) && ((pLoop.wsFlags & (0x00000004 | 0x00000001)) != 0))
			{

				pTerm = pLoop.aLTerm[0];


				iReleaseReg = (int)(++pParse.nMem);
				iRowidReg = (int)(codeEqualityTerm(pParse, pTerm, pLevel, (int)(0), (int)(bRev), (int)(iReleaseReg)));
				if (iRowidReg != iReleaseReg)
					sqlite3ReleaseTempReg(pParse, (int)(iReleaseReg));
				addrNxt = (int)(pLevel.addrNxt);
				if ((pLevel.regFilter) != 0)
				{
					sqlite3VdbeAddOp4Int(v, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(iRowidReg), (int)(1));
					filterPullDown(pParse, pWInfo, (int)(iLevel), (int)(addrNxt), (ulong)(notReady));
				}

				sqlite3VdbeAddOp3(v, (int)(32), (int)(iCur), (int)(addrNxt), (int)(iRowidReg));
				pLevel.op = (byte)(182);
			}
			else if (((pLoop.wsFlags & 0x00000100) != 0) && ((pLoop.wsFlags & 0x00000002) != 0))
			{
				int testOp = (int)(182);
				int start = 0;
				int memEndValue = (int)(0);
				WhereTerm pStart;
				WhereTerm pEnd;
				j = (int)(0);
				pStart = pEnd = null;
				if ((pLoop.wsFlags & 0x00000020) != 0)
					pStart = pLoop.aLTerm[j++];
				if ((pLoop.wsFlags & 0x00000010) != 0)
					pEnd = pLoop.aLTerm[j++];

				if ((bRev) != 0)
				{
					pTerm = pStart;
					pStart = pEnd;
					pEnd = pTerm;
				}

				if ((pStart) != null)
				{
					Expr pX;
					int r1 = 0;
					int rTemp = 0;
					int op = 0;
					byte* aMoveOp = stackalloc byte[] { 26, 24, 23, 25 };




					pX = pStart.pExpr;

					if ((sqlite3ExprIsVector(pX.pRight)) != 0)
					{
						r1 = (int)(rTemp = (int)(sqlite3GetTempReg(pParse)));
						codeExprOrVector(pParse, pX.pRight, (int)(r1), (int)(1));
						op = (int)(aMoveOp[((pX.op - 54 - 1) & 0x3) | 0x1]);




					}
					else
					{
						r1 = (int)(sqlite3ExprCodeTemp(pParse, pX.pRight, &rTemp));
						disableTerm(pLevel, pStart);
						op = (int)(aMoveOp[(pX.op - 54)]);
					}

					sqlite3VdbeAddOp3(v, (int)(op), (int)(iCur), (int)(addrBrk), (int)(r1));
					sqlite3ReleaseTempReg(pParse, (int)(rTemp));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)((bRev) != 0 ? 34 : 38), (int)(iCur), (int)(addrHalt));
				}

				if ((pEnd) != null)
				{
					Expr pX;
					pX = pEnd.pExpr;


					memEndValue = (int)(++pParse.nMem);
					codeExprOrVector(pParse, pX.pRight, (int)(memEndValue), (int)(1));
					if (((0) == (sqlite3ExprIsVector(pX.pRight))) && (((pX.op) == (56)) || ((pX.op) == (54))))
					{
						testOp = (int)((bRev) != 0 ? 55 : 57);
					}
					else
					{
						testOp = (int)((bRev) != 0 ? 56 : 54);
					}

					if ((0) == (sqlite3ExprIsVector(pX.pRight)))
					{
						disableTerm(pLevel, pEnd);
					}
				}

				start = (int)(sqlite3VdbeCurrentAddr(v));
				pLevel.op = (byte)((bRev) != 0 ? 4 : 5);
				pLevel.p1 = (int)(iCur);
				pLevel.p2 = (int)(start);

				if (testOp != 182)
				{
					iRowidReg = (int)(++pParse.nMem);
					sqlite3VdbeAddOp2(v, (int)(134), (int)(iCur), (int)(iRowidReg));
					sqlite3VdbeAddOp3(v, (int)(testOp), (int)(memEndValue), (int)(addrBrk), (int)(iRowidReg));
					sqlite3VdbeChangeP5(v, (ushort)(0x43 | 0x10));
				}
			}
			else if ((pLoop.wsFlags & 0x00000200) != 0)
			{
				ushort nEq = (ushort)(pLoop.u.btree.nEq);
				ushort nBtm = (ushort)(pLoop.u.btree.nBtm);
				ushort nTop = (ushort)(pLoop.u.btree.nTop);
				int regBase = 0;
				WhereTerm pRangeStart = null;
				WhereTerm pRangeEnd = null;
				int startEq = 0;
				int endEq = 0;
				int start_constraints = 0;
				int nConstraint = 0;
				int iIdxCur = 0;
				int nExtraReg = (int)(0);
				int op = 0;
				sbyte* zStartAff;
				sbyte* zEndAff = null;
				byte bSeekPastNull = (byte)(0);
				byte bStopAtNull = (byte)(0);
				int omitTable = 0;
				int regBignull = (int)(0);
				int addrSeekScan = (int)(0);
				pIdx = pLoop.u.btree.pIndex;
				iIdxCur = (int)(pLevel.iIdxCur);

				j = (int)(nEq);
				if ((pLoop.wsFlags & 0x00000020) != 0)
				{
					pRangeStart = pLoop.aLTerm[j++];
					nExtraReg = (int)((nExtraReg) > (pLoop.u.btree.nBtm) ? (nExtraReg) : (pLoop.u.btree.nBtm));

				}

				if ((pLoop.wsFlags & 0x00000010) != 0)
				{
					pRangeEnd = pLoop.aLTerm[j++];
					nExtraReg = (int)((nExtraReg) > (pLoop.u.btree.nTop) ? (nExtraReg) : (pLoop.u.btree.nTop));
					if ((pRangeEnd.wtFlags & 0x0100) != 0)
					{


						pLevel.iLikeRepCntr = ((uint)(++pParse.nMem));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pLevel.iLikeRepCntr));
						pLevel.addrLikeRep = (int)(sqlite3VdbeCurrentAddr(v));

						pLevel.iLikeRepCntr <<= 1;
						pLevel.iLikeRepCntr |= (uint)(bRev ^ ((pIdx.aSortOrder[nEq]) == (1)));
					}

					if ((pRangeStart) == (null))
					{
						j = (int)(pIdx.aiColumn[nEq]);
						if ((((j) >= (0)) && ((pIdx.pTable.aCol[j].notNull) == (0))) || ((j) == (-2)))
						{
							bSeekPastNull = (byte)(1);
						}
					}
				}


				if (((pLoop.wsFlags & (0x00000010 | 0x00000020)) == (0)) && ((pLoop.wsFlags & 0x00080000) != 0))
				{


					nExtraReg = (int)(1);
					bSeekPastNull = (byte)(1);
					pLevel.regBignull = (int)(regBignull = (int)(++pParse.nMem));
					if ((pLevel.iLeftJoin) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regBignull));
					}

					pLevel.addrBignull = (int)(sqlite3VdbeMakeLabel(pParse));
				}

				if ((((nEq) < (pIdx.nColumn)) && ((bRev) == ((pIdx.aSortOrder[nEq]) == (0)))))
				{
					{
						WhereTerm t = pRangeEnd;
						pRangeEnd = pRangeStart;
						pRangeStart = t;
					}

					{
						byte t = (byte)(bSeekPastNull);
						bSeekPastNull = (byte)(bStopAtNull);
						bStopAtNull = (byte)(t);
					}

					{
						byte t = (byte)(nBtm);
						nBtm = (ushort)(nTop);
						nTop = (ushort)(t);
					}
				}

				if (((iLevel) > (0)) && ((pLoop.wsFlags & 0x00100000) != 0))
				{
					sqlite3VdbeAddOp1(v, (int)(135), (int)(iIdxCur));
				}

				regBase = (int)(codeAllEqualityTerms(pParse, pLevel, (int)(bRev), (int)(nExtraReg), &zStartAff));

				if (((zStartAff) != null) && ((nTop) != 0))
				{
					zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
				}

				addrNxt = (int)((regBignull) != 0 ? pLevel.addrBignull : pLevel.addrNxt);
				startEq = (int)((pRangeStart == null) || ((pRangeStart.eOperator & ((0x0002 << (55 - 53)) | (0x0002 << (57 - 53)))) != 0) ? 1 : 0);
				endEq = (int)((pRangeEnd == null) || ((pRangeEnd.eOperator & ((0x0002 << (55 - 53)) | (0x0002 << (57 - 53)))) != 0) ? 1 : 0);
				start_constraints = (int)(((pRangeStart) != null) || ((nEq) > (0)) ? 1 : 0);
				nConstraint = (int)(nEq);
				if ((pRangeStart) != null)
				{
					Expr pRight = pRangeStart.pExpr.pRight;
					codeExprOrVector(pParse, pRight, (int)(regBase + nEq), (int)(nBtm));
					whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
					if (((pRangeStart.wtFlags & 0x0080) == (0)) && ((sqlite3ExprCanBeNull(pRight)) != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + nEq), (int)(addrNxt));
					}

					if ((zStartAff) != null)
					{
						updateRangeAffinityStr(pRight, (int)(nBtm), &zStartAff[nEq]);
					}

					nConstraint += (int)(nBtm);
					if ((sqlite3ExprIsVector(pRight)) == (0))
					{
						disableTerm(pLevel, pRangeStart);
					}
					else
					{
						startEq = (int)(1);
					}

					bSeekPastNull = (byte)(0);
				}
				else if ((bSeekPastNull) != 0)
				{
					startEq = (int)(0);
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
					start_constraints = (int)(1);
					nConstraint++;
				}
				else if ((regBignull) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
					start_constraints = (int)(1);
					nConstraint++;
				}

				codeApplyAffinity(pParse, (int)(regBase), (int)(nConstraint - bSeekPastNull), zStartAff);
				if (((pLoop.nSkip) > (0)) && ((nConstraint) == (pLoop.nSkip)))
				{
				}
				else
				{
					if ((regBignull) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(regBignull));
					}

					if ((pLevel.regFilter) != 0)
					{
						sqlite3VdbeAddOp4Int(v, (int)(63), (int)(pLevel.regFilter), (int)(addrNxt), (int)(regBase), (int)(nEq));
						filterPullDown(pParse, pWInfo, (int)(iLevel), (int)(addrNxt), (ulong)(notReady));
					}

					op = (int)(sqlite3WhereCodeOneLoopStart_aStartOp[(start_constraints << 2) + (startEq << 1) + bRev]);

					if (((pLoop.wsFlags & 0x00100000) != 0) && ((op) == (25)))
					{

						addrSeekScan = (int)(sqlite3VdbeAddOp1(v, (int)(123), (int)((pIdx.aiRowLogEst[0] + 9) / 10)));
					}

					sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint));

					if ((regBignull) != 0)
					{



						sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(sqlite3VdbeCurrentAddr(v) + 2));
						op = (int)(sqlite3WhereCodeOneLoopStart_aStartOp[((nConstraint) > (1)) * 4 + 2 + bRev]);
						sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint - startEq));

					}
				}

				nConstraint = (int)(nEq);

				if ((pRangeEnd) != null)
				{
					Expr pRight = pRangeEnd.pExpr.pRight;
					if ((addrSeekScan) != 0)
					{
						pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
					}

					codeExprOrVector(pParse, pRight, (int)(regBase + nEq), (int)(nTop));
					whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
					if (((pRangeEnd.wtFlags & 0x0080) == (0)) && ((sqlite3ExprCanBeNull(pRight)) != 0))
					{
						sqlite3VdbeAddOp2(v, (int)(50), (int)(regBase + nEq), (int)(addrNxt));
					}

					if ((zEndAff) != null)
					{
						updateRangeAffinityStr(pRight, (int)(nTop), zEndAff);
						codeApplyAffinity(pParse, (int)(regBase + nEq), (int)(nTop), zEndAff);
					}
					else
					{

					}

					nConstraint += (int)(nTop);
					if ((sqlite3ExprIsVector(pRight)) == (0))
					{
						disableTerm(pLevel, pRangeEnd);
					}
					else
					{
						endEq = (int)(1);
					}
				}
				else if ((bStopAtNull) != 0)
				{
					if ((regBignull) == (0))
					{
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regBase + nEq));
						endEq = (int)(0);
					}

					nConstraint++;
				}

				sqlite3DbFree(db, zStartAff);
				sqlite3DbFree(db, zEndAff);
				if ((pLevel.p2) == (0))
					pLevel.p2 = (int)(sqlite3VdbeCurrentAddr(v));
				if ((nConstraint) != 0)
				{
					if ((regBignull) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(20), (int)(regBignull), (int)(sqlite3VdbeCurrentAddr(v) + 3));
					}

					op = (int)(sqlite3WhereCodeOneLoopStart_aEndOp[bRev * 2 + endEq]);
					sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint));
					if ((addrSeekScan) != 0)
						sqlite3VdbeJumpHere(v, (int)(addrSeekScan));
				}

				if ((regBignull) != 0)
				{



					sqlite3VdbeAddOp2(v, (int)(18), (int)(regBignull), (int)(sqlite3VdbeCurrentAddr(v) + 2));
					op = (int)(sqlite3WhereCodeOneLoopStart_aEndOp[bRev * 2 + bSeekPastNull]);
					sqlite3VdbeAddOp4Int(v, (int)(op), (int)(iIdxCur), (int)(addrNxt), (int)(regBase), (int)(nConstraint + bSeekPastNull));
				}

				if ((pLoop.wsFlags & 0x00040000) != 0)
				{
					sqlite3VdbeAddOp3(v, (int)(124), (int)(iIdxCur), (int)(nEq), (int)(nEq));
				}

				omitTable = (int)(((pLoop.wsFlags & 0x00000040) != 0) && ((pWInfo.wctrlFlags & 0x0020) == (0)) ? 1 : 0);
				if ((omitTable) != 0)
				{
				}
				else if ((((pIdx.pTable).tabFlags & 0x00000080) == (0)))
				{
					codeDeferredSeek(pWInfo, pIdx, (int)(iCur), (int)(iIdxCur));
				}
				else if (iCur != iIdxCur)
				{
					Index pPk = sqlite3PrimaryKeyIndex(pIdx.pTable);
					iRowidReg = (int)(sqlite3GetTempRange(pParse, (int)(pPk.nKeyCol)));
					for (j = (int)(0); (j) < (pPk.nKeyCol); j++)
					{
						k = (int)(sqlite3TableColumnToIndex(pIdx, (short)(pPk.aiColumn[j])));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(iIdxCur), (int)(k), (int)(iRowidReg + j));
					}

					sqlite3VdbeAddOp4Int(v, (int)(30), (int)(iCur), (int)(addrCont), (int)(iRowidReg), (int)(pPk.nKeyCol));
				}

				if ((pLevel.iLeftJoin) == (0))
				{
					if ((pWInfo.wctrlFlags & 0x0020) == (0))
					{
						whereIndexExprTrans(pIdx, (int)(iCur), (int)(iIdxCur), pWInfo);
					}

					if ((pIdx.pPartIdxWhere) != null)
					{
						whereApplyPartialIndexConstraints(pIdx.pPartIdxWhere, (int)(iCur), pWC);
					}
				}
				else
				{

				}

				if ((pLoop.wsFlags & 0x00001000) != 0)
				{
					pLevel.op = (byte)(182);
				}
				else if ((bRev) != 0)
				{
					pLevel.op = (byte)(4);
				}
				else
				{
					pLevel.op = (byte)(5);
				}

				pLevel.p1 = (int)(iIdxCur);
				pLevel.p3 = (byte)((pLoop.wsFlags & 0x00010000) != 0 ? 1 : 0);
				if ((pLoop.wsFlags & 0x0000000f) == (0))
				{
					pLevel.p5 = (byte)(1);
				}
				else
				{

				}

				if ((omitTable) != 0)
					pIdx = null;
			}
			else if ((pLoop.wsFlags & 0x00002000) != 0)
			{
				WhereClause pOrWc;
				SrcList pOrTab;
				Index pCov = null;
				int iCovCur = (int)(pParse.nTab++);
				int regReturn = (int)(++pParse.nMem);
				int regRowset = (int)(0);
				int regRowid = (int)(0);
				int iLoopBody = (int)(sqlite3VdbeMakeLabel(pParse));
				int iRetInit = 0;
				int untestedTerms = (int)(0);
				int ii = 0;
				Expr pAndExpr = null;
				Table pTab = pTabItem.pTab;
				pTerm = pLoop.aLTerm[0];



				pOrWc = pTerm.u.pOrInfo.wc;
				pLevel.op = (byte)(67);
				pLevel.p1 = (int)(regReturn);
				if ((pWInfo.nLevel) > (1))
				{
					int nNotReady = 0;
					SrcItem origSrc;
					nNotReady = (int)(pWInfo.nLevel - iLevel - 1);
					pOrTab = sqlite3DbMallocRaw(db, (ulong)(sizeof(SrcList) + nNotReady * sizeof(SrcItem)));
					if ((pOrTab) == (null))
						return (ulong)(notReady);
					pOrTab.nAlloc = (uint)((byte)(nNotReady + 1));
					pOrTab.nSrc = (int)(pOrTab.nAlloc);
					CRuntime.memcpy(pOrTab.a, pTabItem, (ulong)(sizeof(SrcItem)));
					origSrc = pWInfo.pTabList.a;
					for (k = (int)(1); (k) <= (nNotReady); k++)
					{
						CRuntime.memcpy(pOrTab.a[k], origSrc[pLevel[k].iFrom], (ulong)(sizeof(SrcItem)));
					}
				}
				else
				{
					pOrTab = pWInfo.pTabList;
				}

				if ((pWInfo.wctrlFlags & 0x0010) == (0))
				{
					if ((((pTab).tabFlags & 0x00000080) == (0)))
					{
						regRowset = (int)(++pParse.nMem);
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regRowset));
					}
					else
					{
						Index pPk = sqlite3PrimaryKeyIndex(pTab);
						regRowset = (int)(pParse.nTab++);
						sqlite3VdbeAddOp2(v, (int)(116), (int)(regRowset), (int)(pPk.nKeyCol));
						sqlite3VdbeSetP4KeyInfo(pParse, pPk);
					}

					regRowid = (int)(++pParse.nMem);
				}

				iRetInit = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regReturn)));
				if ((pWC.nTerm) > (1))
				{
					int iTerm = 0;
					for (iTerm = (int)(0); (iTerm) < (pWC.nTerm); iTerm++)
					{
						Expr pExpr = pWC.a[iTerm].pExpr;
						if ((pWC.a[iTerm]) == (pTerm))
							continue;
						if ((pWC.a[iTerm].wtFlags & (0x0002 | 0x0004 | 0x8000)) != 0)
						{
							continue;
						}

						if ((pWC.a[iTerm].eOperator & 0x1fff) == (0))
							continue;
						if ((((pExpr).flags & (0x200000)) != 0))
							continue;
						pExpr = sqlite3ExprDup(db, pExpr, (int)(0));
						pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
					}

					if ((pAndExpr) != null)
					{
						pAndExpr = sqlite3PExpr(pParse, (int)(44 | 0x10000), null, pAndExpr);
					}
				}

				sqlite3VdbeExplain(pParse, (byte)(1), "MULTI-INDEX OR");
				for (ii = (int)(0); (ii) < (pOrWc.nTerm); ii++)
				{
					WhereTerm pOrTerm = pOrWc.a[ii];
					if (((pOrTerm.leftCursor) == (iCur)) || ((pOrTerm.eOperator & 0x0400) != 0))
					{
						WhereInfo pSubWInfo;
						Expr pOrExpr = pOrTerm.pExpr;
						Expr pDelete;
						int jmp1 = (int)(0);
						pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, (int)(0));
						if ((db.mallocFailed) != 0)
						{
							sqlite3ExprDelete(db, pDelete);
							continue;
						}

						if ((pAndExpr) != null)
						{
							pAndExpr.pLeft = pOrExpr;
							pOrExpr = pAndExpr;
						}

						sqlite3VdbeExplain(pParse, (byte)(1), "INDEX %d", (int)(ii + 1));
						pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, null, null, null, (ushort)(0x0020), (int)(iCovCur));

						if ((pSubWInfo) != null)
						{
							WhereLoop pSubLoop;
							int addrExplain = (int)(sqlite3WhereExplainOneScan(pParse, pOrTab, pSubWInfo.a[0], (ushort)(0)));
							((void)(addrExplain));
							if ((pWInfo.wctrlFlags & 0x0010) == (0))
							{
								int iSet = (int)(((ii) == (pOrWc.nTerm - 1)) ? -1 : ii);
								if ((((pTab).tabFlags & 0x00000080) == (0)))
								{
									sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(-1), (int)(regRowid));
									jmp1 = (int)(sqlite3VdbeAddOp4Int(v, (int)(46), (int)(regRowset), (int)(0), (int)(regRowid), (int)(iSet)));
								}
								else
								{
									Index pPk = sqlite3PrimaryKeyIndex(pTab);
									int nPk = (int)(pPk.nKeyCol);
									int iPk = 0;
									int r = 0;
									r = (int)(sqlite3GetTempRange(pParse, (int)(nPk)));
									for (iPk = (int)(0); (iPk) < (nPk); iPk++)
									{
										int iCol = (int)(pPk.aiColumn[iPk]);
										sqlite3ExprCodeGetColumnOfTable(v, pTab, (int)(iCur), (int)(iCol), (int)(r + iPk));
									}

									if ((iSet) != 0)
									{
										jmp1 = (int)(sqlite3VdbeAddOp4Int(v, (int)(31), (int)(regRowset), (int)(0), (int)(r), (int)(nPk)));
									}

									if ((iSet) >= (0))
									{
										sqlite3VdbeAddOp3(v, (int)(96), (int)(r), (int)(nPk), (int)(regRowid));
										sqlite3VdbeAddOp4Int(v, (int)(137), (int)(regRowset), (int)(regRowid), (int)(r), (int)(nPk));
										if ((iSet) != 0)
											sqlite3VdbeChangeP5(v, (ushort)(0x10));
									}

									sqlite3ReleaseTempRange(pParse, (int)(r), (int)(nPk));
								}
							}

							sqlite3VdbeAddOp2(v, (int)(12), (int)(regReturn), (int)(iLoopBody));
							if ((jmp1) != 0)
								sqlite3VdbeJumpHere(v, (int)(jmp1));
							if ((pSubWInfo.untestedTerms) != 0)
								untestedTerms = (int)(1);
							pSubLoop = pSubWInfo.a[0].pWLoop;

							if ((((pSubLoop.wsFlags & 0x00000200) != 0) && (((ii) == (0)) || ((pSubLoop.u.btree.pIndex) == (pCov)))) && ((((pTab).tabFlags & 0x00000080) == (0)) || (!(((pSubLoop.u.btree.pIndex).idxType) == (2)))))
							{

								pCov = pSubLoop.u.btree.pIndex;
							}
							else
							{
								pCov = null;
							}

							if ((sqlite3WhereUsesDeferredSeek(pSubWInfo)) != 0)
							{
								pWInfo.bDeferredSeek = (uint)(1);
							}

							sqlite3WhereEnd(pSubWInfo);
							sqlite3VdbeExplainPop(pParse);
						}

						sqlite3ExprDelete(db, pDelete);
					}
				}

				sqlite3VdbeExplainPop(pParse);



				pLevel.u.pCoveringIdx = pCov;
				if ((pCov) != null)
					pLevel.iIdxCur = (int)(iCovCur);
				if ((pAndExpr) != null)
				{
					pAndExpr.pLeft = null;
					sqlite3ExprDelete(db, pAndExpr);
				}

				sqlite3VdbeChangeP1(v, (int)(iRetInit), (int)(sqlite3VdbeCurrentAddr(v)));
				sqlite3VdbeGoto(v, (int)(pLevel.addrBrk));
				sqlite3VdbeResolveLabel(v, (int)(iLoopBody));
				if ((pWInfo.nLevel) > (1))
				{
					sqlite3DbFree(db, pOrTab);
				}

				if (untestedTerms == 0)
					disableTerm(pLevel, pTerm);
			}
			else
			{

				if ((pTabItem.fg.isRecursive) != 0)
				{
					pLevel.op = (byte)(182);
				}
				else
				{
					pLevel.op = (byte)(sqlite3WhereCodeOneLoopStart_aStep[bRev]);
					pLevel.p1 = (int)(iCur);
					pLevel.p2 = (int)(1 + sqlite3VdbeAddOp2(v, (int)(sqlite3WhereCodeOneLoopStart_aStart[bRev]), (int)(iCur), (int)(addrHalt)));
					pLevel.p5 = (byte)(1);
				}
			}

			iLoop = (int)(pIdx ? 1 : 2);
			do
			{
				int iNext = (int)(0);
				for (pTerm = pWC.a, j = (int)(pWC.nTerm); (j) > (0); j--, pTerm++)
				{
					Expr pE;
					int skipLikeAddr = (int)(0);
					if ((pTerm.wtFlags & (0x0002 | 0x0004)) != 0)
						continue;
					if ((pTerm.prereqAll & pLevel.notReady) != 0)
					{
						pWInfo.untestedTerms = (uint)(1);
						continue;
					}

					pE = pTerm.pExpr;

					if (((pTabItem.fg.jointype & 0x0008) != 0) && (!(((pE).flags & (0x000001)) != 0)))
					{
						continue;
					}

					if (((iLoop) == (1)) && (sqlite3ExprCoveredByIndex(pE, (int)(pLevel.iTabCur), pIdx) == 0))
					{
						iNext = (int)(2);
						continue;
					}

					if (((iLoop) < (3)) && ((pTerm.wtFlags & 0x1000) != 0))
					{
						if ((iNext) == (0))
							iNext = (int)(3);
						continue;
					}

					if ((pTerm.wtFlags & 0x0200) != 0)
					{
						uint x = (uint)(pLevel.iLikeRepCntr);
						if ((x) > (0))
						{
							skipLikeAddr = (int)(sqlite3VdbeAddOp1(v, (int)((x & 1) ? 20 : 18), (int)(x >> 1)));
						}
					}

					sqlite3ExprIfFalse(pParse, pE, (int)(addrCont), (int)(0x10));
					if ((skipLikeAddr) != 0)
						sqlite3VdbeJumpHere(v, (int)(skipLikeAddr));
					pTerm.wtFlags |= (ushort)(0x0004);
				}

				iLoop = (int)(iNext);
			}
			while ((iLoop) > (0));
			for (pTerm = pWC.a, j = (int)(pWC.nBase); (j) > (0); j--, pTerm++)
			{
				Expr pE;
				Expr sEAlt = new Expr();
				WhereTerm pAlt;
				if ((pTerm.wtFlags & (0x0002 | 0x0004)) != 0)
					continue;
				if ((pTerm.eOperator & (0x0002 | 0x0080)) == (0))
					continue;
				if ((pTerm.eOperator & 0x0800) == (0))
					continue;
				if (pTerm.leftCursor != iCur)
					continue;
				if ((pTabItem.fg.jointype & 0x0008) != 0)
					continue;
				pE = pTerm.pExpr;



				pAlt = sqlite3WhereFindTerm(pWC, (int)(iCur), (int)(pTerm.u.x.leftColumn), (ulong)(notReady), (uint)(0x0002 | 0x0001 | 0x0080), null);
				if ((pAlt) == (null))
					continue;
				if ((pAlt.wtFlags & (0x0004)) != 0)
					continue;
				if ((((pAlt.eOperator & 0x0001) != 0) && (((pAlt.pExpr).flags & 0x000800) != 0)) && ((pAlt.pExpr.x.pSelect.pEList.nExpr) > (1)))
				{
					continue;
				}

				sEAlt = (Expr)(pAlt.pExpr);
				sEAlt.pLeft = pE.pLeft;
				sqlite3ExprIfFalse(pParse, sEAlt, (int)(addrCont), (int)(0x10));
				pAlt.wtFlags |= (ushort)(0x0004);
			}

			if ((pLevel.iLeftJoin) != 0)
			{
				pLevel.addrFirst = (int)(sqlite3VdbeCurrentAddr(v));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pLevel.iLeftJoin));
				for (pTerm = pWC.a, j = (int)(0); (j) < (pWC.nBase); j++, pTerm++)
				{
					if ((pTerm.wtFlags & (0x0002 | 0x0004)) != 0)
						continue;
					if ((pTerm.prereqAll & pLevel.notReady) != 0)
					{

						continue;
					}


					sqlite3ExprIfFalse(pParse, pTerm.pExpr, (int)(addrCont), (int)(0x10));
					pTerm.wtFlags |= (ushort)(0x0004);
				}
			}

			return (ulong)(pLevel.notReady);
		}
		public static int sqlite3WhereContinueLabel(WhereInfo pWInfo)
		{

			return (int)(pWInfo.iContinue);
		}
		public static void sqlite3WhereEnd(WhereInfo pWInfo)
		{
			Parse pParse = pWInfo.pParse;
			Vdbe v = pParse.pVdbe;
			int i = 0;
			WhereLevel pLevel;
			WhereLoop pLoop;
			SrcList pTabList = pWInfo.pTabList;
			sqlite3 db = pParse.db;
			int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
			for (i = (int)(pWInfo.nLevel - 1); (i) >= (0); i--)
			{
				int addr = 0;
				pLevel = pWInfo.a[i];
				pLoop = pLevel.pWLoop;
				if (pLevel.op != 182)
				{
					int addrSeek = (int)(0);
					Index pIdx;
					int n = 0;
					if (((((((pWInfo.eDistinct) == (2)) && ((i) == (pWInfo.nLevel - 1))) && ((pLoop.wsFlags & 0x00000200) != 0)) && (((pIdx = pLoop.u.btree.pIndex).hasStat1) != 0)) && ((n = (int)(pLoop.u.btree.nDistinctCol)) > (0))) && ((pIdx.aiRowLogEst[n]) >= (36)))
					{
						int r1 = (int)(pParse.nMem + 1);
						int j = 0;
						int op = 0;
						for (j = (int)(0); (j) < (n); j++)
						{
							sqlite3VdbeAddOp3(v, (int)(93), (int)(pLevel.iIdxCur), (int)(j), (int)(r1 + j));
						}

						pParse.nMem += (int)(n + 1);
						op = (int)((pLevel.op) == (4) ? 23 : 26);
						addrSeek = (int)(sqlite3VdbeAddOp4Int(v, (int)(op), (int)(pLevel.iIdxCur), (int)(0), (int)(r1), (int)(n)));
						sqlite3VdbeAddOp2(v, (int)(11), (int)(1), (int)(pLevel.p2));
					}

					sqlite3VdbeResolveLabel(v, (int)(pLevel.addrCont));
					sqlite3VdbeAddOp3(v, (int)(pLevel.op), (int)(pLevel.p1), (int)(pLevel.p2), (int)(pLevel.p3));
					sqlite3VdbeChangeP5(v, (ushort)(pLevel.p5));
					if ((pLevel.regBignull) != 0)
					{
						sqlite3VdbeResolveLabel(v, (int)(pLevel.addrBignull));
						sqlite3VdbeAddOp2(v, (int)(60), (int)(pLevel.regBignull), (int)(pLevel.p2 - 1));
					}

					if ((addrSeek) != 0)
						sqlite3VdbeJumpHere(v, (int)(addrSeek));
				}
				else
				{
					sqlite3VdbeResolveLabel(v, (int)(pLevel.addrCont));
				}

				if (((pLoop.wsFlags & 0x00000800) != 0) && ((pLevel.u._in_.nIn) > (0)))
				{
					InLoop* pIn;
					int j = 0;
					sqlite3VdbeResolveLabel(v, (int)(pLevel.addrNxt));
					for (j = (int)(pLevel.u._in_.nIn), pIn = &pLevel.u._in_.aInLoop[j - 1]; (j) > (0); j--, pIn--)
					{

						sqlite3VdbeJumpHere(v, (int)(pIn->addrInTop + 1));
						if (pIn->eEndLoopOp != 182)
						{
							if ((pIn->nPrefix) != 0)
							{
								int bEarlyOut = (int)(((pLoop.wsFlags & 0x00000400) == (0)) && ((pLoop.wsFlags & 0x00040000) != 0) ? 1 : 0);
								if ((pLevel.iLeftJoin) != 0)
								{
									sqlite3VdbeAddOp2(v, (int)(27), (int)(pIn->iCur), (int)(sqlite3VdbeCurrentAddr(v) + 2 + bEarlyOut));
								}

								if ((bEarlyOut) != 0)
								{
									sqlite3VdbeAddOp4Int(v, (int)(28), (int)(pLevel.iIdxCur), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(pIn->iBase), (int)(pIn->nPrefix));
									sqlite3VdbeJumpHere(v, (int)(pIn->addrInTop + 1));
								}
							}

							sqlite3VdbeAddOp2(v, (int)(pIn->eEndLoopOp), (int)(pIn->iCur), (int)(pIn->addrInTop));
						}

						sqlite3VdbeJumpHere(v, (int)(pIn->addrInTop - 1));
					}
				}

				sqlite3VdbeResolveLabel(v, (int)(pLevel.addrBrk));
				if ((pLevel.addrSkip) != 0)
				{
					sqlite3VdbeGoto(v, (int)(pLevel.addrSkip));
					sqlite3VdbeJumpHere(v, (int)(pLevel.addrSkip));
					sqlite3VdbeJumpHere(v, (int)(pLevel.addrSkip - 2));
				}

				if ((pLevel.addrLikeRep) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(60), (int)(pLevel.iLikeRepCntr >> 1), (int)(pLevel.addrLikeRep));
				}

				if ((pLevel.iLeftJoin) != 0)
				{
					int ws = (int)(pLoop.wsFlags);
					addr = (int)(sqlite3VdbeAddOp1(v, (int)(49), (int)(pLevel.iLeftJoin)));

					if ((ws & 0x00000040) == (0))
					{

						sqlite3VdbeAddOp1(v, (int)(135), (int)(pLevel.iTabCur));
					}

					if (((ws & 0x00000200) != 0) || (((ws & 0x00002000) != 0) && ((pLevel.u.pCoveringIdx) != null)))
					{
						if ((ws & 0x00002000) != 0)
						{
							Index pIx = pLevel.u.pCoveringIdx;
							int iDb = (int)(sqlite3SchemaToIndex(db, pIx.pSchema));
							sqlite3VdbeAddOp3(v, (int)(100), (int)(pLevel.iIdxCur), (int)(pIx.tnum), (int)(iDb));
							sqlite3VdbeSetP4KeyInfo(pParse, pIx);
						}

						sqlite3VdbeAddOp1(v, (int)(135), (int)(pLevel.iIdxCur));
					}

					if ((pLevel.op) == (67))
					{
						sqlite3VdbeAddOp2(v, (int)(12), (int)(pLevel.p1), (int)(pLevel.addrFirst));
					}
					else
					{
						sqlite3VdbeGoto(v, (int)(pLevel.addrFirst));
					}

					sqlite3VdbeJumpHere(v, (int)(addr));
				}
			}

			sqlite3VdbeResolveLabel(v, (int)(pWInfo.iBreak));

			for (i = (int)(0), pLevel = pWInfo.a; (i) < (pWInfo.nLevel); i++, pLevel++)
			{
				int k = 0;
				int last = 0;
				VdbeOp* pOp;
				VdbeOp* pLastOp;
				Index pIdx = null;
				SrcItem pTabItem = pTabList.a[pLevel.iFrom];
				Table pTab = pTabItem.pTab;

				pLoop = pLevel.pWLoop;
				if ((pTabItem.fg.viaCoroutine) != 0)
				{
					translateColumnToCopy(pParse, (int)(pLevel.addrBody), (int)(pLevel.iTabCur), (int)(pTabItem.regResult), (int)(0));
					continue;
				}

				if ((pLoop.wsFlags & (0x00000200 | 0x00000040)) != 0)
				{
					pIdx = pLoop.u.btree.pIndex;
				}
				else if ((pLoop.wsFlags & 0x00002000) != 0)
				{
					pIdx = pLevel.u.pCoveringIdx;
				}

				if (((pIdx) != null) && (db.mallocFailed == 0))
				{
					if (((pWInfo.eOnePass) == (0)) || (!(((pIdx.pTable).tabFlags & 0x00000080) == (0))))
					{
						last = (int)(iEnd);
					}
					else
					{
						last = (int)(pWInfo.iEndWhere);
					}

					k = (int)(pLevel.addrBody + 1);
					pOp = sqlite3VdbeGetOp(v, (int)(k));
					pLastOp = pOp + (last - k);

					do
					{
						if (pOp->p1 != pLevel.iTabCur)
						{
						}
						else if ((pOp->opcode) == (93))
						{
							int x = (int)(pOp->p2);

							if (!(((pTab).tabFlags & 0x00000080) == (0)))
							{
								Index pPk = sqlite3PrimaryKeyIndex(pTab);
								x = (int)(pPk.aiColumn[x]);

							}
							else
							{
								x = (int)(sqlite3StorageColumnToTable(pTab, (short)(x)));
							}

							x = (int)(sqlite3TableColumnToIndex(pIdx, (short)(x)));
							if ((x) >= (0))
							{
								pOp->p2 = (int)(x);
								pOp->p1 = (int)(pLevel.iIdxCur);
							}
							else
							{

							}
						}
						else if ((pOp->opcode) == (134))
						{
							pOp->p1 = (int)(pLevel.iIdxCur);
							pOp->opcode = (byte)(141);
						}
						else if ((pOp->opcode) == (22))
						{
							pOp->p1 = (int)(pLevel.iIdxCur);
						}
					}
					while ((++pOp) < (pLastOp));
				}
			}

			if ((pWInfo.pExprMods) != null)
				whereUndoExprMods(pWInfo);
			pParse.nQueryLoop = (uint)(pWInfo.savedNQueryLoop);
			whereInfoFree(db, pWInfo);
			return;
		}
		public static int sqlite3WhereExplainBloomFilter(Parse pParse, WhereInfo pWInfo, WhereLevel pLevel)
		{
			int ret = (int)(0);
			SrcItem pItem = pWInfo.pTabList.a[pLevel.iFrom];
			Vdbe v = pParse.pVdbe;
			sqlite3 db = pParse.db;
			sbyte* zMsg;
			int i = 0;
			WhereLoop pLoop;
			sqlite3_str str = new sqlite3_str();
			sbyte* zBuf = stackalloc sbyte[100];
			sqlite3StrAccumInit(str, db, zBuf, (int)(100 * sizeof(sbyte)), (int)(1000000000));
			str.printfFlags = (byte)(0x01);
			sqlite3_str_appendf(str, "BLOOM FILTER ON %S (", pItem);
			pLoop = pLevel.pWLoop;
			if ((pLoop.wsFlags & 0x00000100) != 0)
			{
				Table pTab = pItem.pTab;
				if ((pTab.iPKey) >= (0))
				{
					sqlite3_str_appendf(str, "%s=?", pTab.aCol[pTab.iPKey].zCnName);
				}
				else
				{
					sqlite3_str_appendf(str, "rowid=?");
				}
			}
			else
			{
				for (i = (int)(pLoop.nSkip); (i) < (pLoop.u.btree.nEq); i++)
				{
					sbyte* z = explainIndexColumnName(pLoop.u.btree.pIndex, (int)(i));
					if ((i) > (pLoop.nSkip))
						sqlite3_str_append(str, " AND ", (int)(5));
					sqlite3_str_appendf(str, "%s=?", z);
				}
			}

			sqlite3_str_append(str, ")", (int)(1));
			zMsg = sqlite3StrAccumFinish(str);
			ret = (int)(sqlite3VdbeAddOp4(v, (int)(183), (int)(sqlite3VdbeCurrentAddr(v)), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7)));
			return (int)(ret);
		}
		public static int sqlite3WhereExplainOneScan(Parse pParse, SrcList pTabList, WhereLevel pLevel, ushort wctrlFlags)
		{
			int ret = (int)(0);
			if ((((pParse).pToplevel ? (pParse).pToplevel : (pParse)).explain) == (2))
			{
				SrcItem pItem = pTabList.a[pLevel.iFrom];
				Vdbe v = pParse.pVdbe;
				sqlite3 db = pParse.db;
				int isSearch = 0;
				WhereLoop pLoop;
				uint flags = 0;
				sbyte* zMsg;
				sqlite3_str str = new sqlite3_str();
				sbyte* zBuf = stackalloc sbyte[100];
				pLoop = pLevel.pWLoop;
				flags = (uint)(pLoop.wsFlags);
				if (((flags & 0x00002000) != 0) || ((wctrlFlags & 0x0020) != 0))
					return (int)(0);
				isSearch = (int)((((flags & (0x00000020 | 0x00000010)) != 0) || (((flags & 0x00000400) == (0)) && ((pLoop.u.btree.nEq) > (0)))) || ((wctrlFlags & (0x0001 | 0x0002)) != 0) ? 1 : 0);
				sqlite3StrAccumInit(str, db, zBuf, (int)(100 * sizeof(sbyte)), (int)(1000000000));
				str.printfFlags = (byte)(0x01);
				sqlite3_str_appendf(str, "%s %S", (isSearch) != 0 ? "SEARCH" : "SCAN", pItem);
				if ((flags & (0x00000100 | 0x00000400)) == (0))
				{
					sbyte* zFmt = null;
					Index pIdx;

					pIdx = pLoop.u.btree.pIndex;

					if ((!(((pItem.pTab).tabFlags & 0x00000080) == (0))) && (((pIdx).idxType) == (2)))
					{
						if ((isSearch) != 0)
						{
							zFmt = "PRIMARY KEY";
						}
					}
					else if ((flags & 0x00020000) != 0)
					{
						zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
					}
					else if ((flags & 0x00004000) != 0)
					{
						zFmt = "AUTOMATIC COVERING INDEX";
					}
					else if ((flags & 0x00000040) != 0)
					{
						zFmt = "COVERING INDEX %s";
					}
					else
					{
						zFmt = "INDEX %s";
					}

					if ((zFmt) != null)
					{
						sqlite3_str_append(str, " USING ", (int)(7));
						sqlite3_str_appendf(str, zFmt, pIdx.zName);
						explainIndexRange(str, pLoop);
					}
				}
				else if (((flags & 0x00000100) != 0) && ((flags & 0x0000000f) != 0))
				{
					sbyte cRangeOp = 0;
					sbyte* zRowid = "rowid";
					sqlite3_str_appendf(str, " USING INTEGER PRIMARY KEY (%s", zRowid);
					if ((flags & (0x00000001 | 0x00000004)) != 0)
					{
						cRangeOp = (sbyte)(61);
					}
					else if ((flags & 0x00000030) == (0x00000030))
					{
						sqlite3_str_appendf(str, ">? AND %s", zRowid);
						cRangeOp = (sbyte)(60);
					}
					else if ((flags & 0x00000020) != 0)
					{
						cRangeOp = (sbyte)(62);
					}
					else
					{

						cRangeOp = (sbyte)(60);
					}

					sqlite3_str_appendf(str, "%c?)", (int)(cRangeOp));
				}
				else if ((flags & 0x00000400) != 0)
				{
					sqlite3_str_appendf(str, " VIRTUAL TABLE INDEX %d:%s", (int)(pLoop.u.vtab.idxNum), pLoop.u.vtab.idxStr);
				}

				zMsg = sqlite3StrAccumFinish(str);
				ret = (int)(sqlite3VdbeAddOp4(v, (int)(183), (int)(sqlite3VdbeCurrentAddr(v)), (int)(pParse.addrExplain), (int)(0), zMsg, (int)(-7)));
			}

			return (int)(ret);
		}
		public static void sqlite3WhereExprAnalyze(SrcList pTabList, WhereClause pWC)
		{
			int i = 0;
			for (i = (int)(pWC.nTerm - 1); (i) >= (0); i--)
			{
				exprAnalyze(pTabList, pWC, (int)(i));
			}
		}
		public static ulong sqlite3WhereExprListUsage(WhereMaskSet* pMaskSet, ExprList pList)
		{
			int i = 0;
			ulong mask = (ulong)(0);
			if ((pList) != null)
			{
				for (i = (int)(0); (i) < (pList.nExpr); i++)
				{
					mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, pList.a[i].pExpr));
				}
			}

			return (ulong)(mask);
		}
		public static ulong sqlite3WhereExprUsage(WhereMaskSet* pMaskSet, Expr p)
		{
			return (ulong)(p ? sqlite3WhereExprUsageNN(pMaskSet, p) : 0);
		}
		public static ulong sqlite3WhereExprUsageFull(WhereMaskSet* pMaskSet, Expr p)
		{
			ulong mask = 0;
			mask = (ulong)(((p.op) == (179)) ? sqlite3WhereGetMask(pMaskSet, (int)(p.iTable)) : 0);
			if ((p.pLeft) != null)
				mask |= (ulong)(sqlite3WhereExprUsageNN(pMaskSet, p.pLeft));
			if ((p.pRight) != null)
			{
				mask |= (ulong)(sqlite3WhereExprUsageNN(pMaskSet, p.pRight));

			}
			else if ((((p).flags & 0x000800) != 0))
			{
				if ((((p).flags & (0x000020)) != 0))
					pMaskSet->bVarSelect = (int)(1);
				mask |= (ulong)(exprSelectUsage(pMaskSet, p.x.pSelect));
			}
			else if ((p.x.pList) != null)
			{
				mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, p.x.pList));
			}

			if ((((p.op) == (172)) || ((p.op) == (168))) && (((p).flags & 0x1000000) != 0))
			{

				mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, p.y.pWin.pPartition));
				mask |= (ulong)(sqlite3WhereExprListUsage(pMaskSet, p.y.pWin.pOrderBy));
				mask |= (ulong)(sqlite3WhereExprUsage(pMaskSet, p.y.pWin.pFilter));
			}

			return (ulong)(mask);
		}
		public static ulong sqlite3WhereExprUsageNN(WhereMaskSet* pMaskSet, Expr p)
		{
			if (((p.op) == (167)) && (!(((p).flags & (0x000008)) != 0)))
			{
				return (ulong)(sqlite3WhereGetMask(pMaskSet, (int)(p.iTable)));
			}
			else if ((((p).flags & (0x004000 | 0x800000)) != 0))
			{

				return (ulong)(0);
			}

			return (ulong)(sqlite3WhereExprUsageFull(pMaskSet, p));
		}
		public static WhereTerm sqlite3WhereFindTerm(WhereClause pWC, int iCur, int iColumn, ulong notReady, uint op, Index pIdx)
		{
			WhereTerm pResult = null;
			WhereTerm p;
			WhereScan scan = new WhereScan();
			p = whereScanInit(scan, pWC, (int)(iCur), (int)(iColumn), (uint)(op), pIdx);
			op &= (uint)(0x0002 | 0x0080);
			while ((p) != null)
			{
				if ((p.prereqRight & notReady) == (0))
				{
					if (((p.prereqRight) == (0)) && ((p.eOperator & op) != 0))
					{
						return p;
					}

					if ((pResult) == (null))
						pResult = p;
				}

				p = whereScanNext(scan);
			}

			return pResult;
		}
		public static ulong sqlite3WhereGetMask(WhereMaskSet* pMaskSet, int iCursor)
		{
			int i = 0;



			if ((pMaskSet->ix[0]) == (iCursor))
			{
				return (ulong)(1);
			}

			for (i = (int)(1); (i) < (pMaskSet->n); i++)
			{
				if ((pMaskSet->ix[i]) == (iCursor))
				{
					return (ulong)(((ulong)(1)) << (i));
				}
			}

			return (ulong)(0);
		}
		public static int sqlite3WhereIsDistinct(WhereInfo pWInfo)
		{
			return (int)(pWInfo.eDistinct);
		}
		public static int sqlite3WhereIsOrdered(WhereInfo pWInfo)
		{
			return (int)(pWInfo.nOBSat);
		}
		public static int sqlite3WhereIsSorted(WhereInfo pWInfo)
		{


			return (int)(pWInfo.sorted);
		}
		public static void sqlite3WhereMinMaxOptEarlyOut(Vdbe v, WhereInfo pWInfo)
		{
			WhereLevel pInner;
			int i = 0;
			if (pWInfo.bOrderedInnerLoop == 0)
				return;
			if ((pWInfo.nOBSat) == (0))
				return;
			for (i = (int)(pWInfo.nLevel - 1); (i) >= (0); i--)
			{
				pInner = pWInfo.a[i];
				if ((pInner.pWLoop.wsFlags & 0x00000004) != 0)
				{
					sqlite3VdbeGoto(v, (int)(pInner.addrNxt));
					return;
				}
			}

			sqlite3VdbeGoto(v, (int)(pWInfo.iBreak));
		}
		public static int sqlite3WhereOkOnePass(WhereInfo pWInfo, int* aiCur)
		{
			CRuntime.memcpy(aiCur, pWInfo.aiCurOnePass, (ulong)(sizeof(int) * 2));
			return (int)(pWInfo.eOnePass);
		}
		public static int sqlite3WhereOrderByLimitOptLabel(WhereInfo pWInfo)
		{
			WhereLevel pInner;
			if (pWInfo.bOrderedInnerLoop == 0)
			{
				return (int)(pWInfo.iContinue);
			}

			pInner = pWInfo.a[pWInfo.nLevel - 1];

			return (int)(pInner.addrNxt);
		}
		public static short sqlite3WhereOutputRowCount(WhereInfo pWInfo)
		{
			return (short)(pWInfo.nRowOut);
		}
		public static void sqlite3WhereSplit(WhereClause pWC, Expr pExpr, byte op)
		{
			Expr pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);
			pWC.op = (byte)(op);

			if ((pE2) == (null))
				return;
			if (pE2.op != op)
			{
				whereClauseInsert(pWC, pExpr, (ushort)(0));
			}
			else
			{
				sqlite3WhereSplit(pWC, pE2.pLeft, (byte)(op));
				sqlite3WhereSplit(pWC, pE2.pRight, (byte)(op));
			}
		}
		public static void sqlite3WhereTabFuncArgs(Parse pParse, SrcItem pItem, WhereClause pWC)
		{
			Table pTab;
			int j = 0; int k = 0;
			ExprList pArgs;
			Expr pColRef;
			Expr pTerm;
			if ((pItem.fg.isTabFunc) == (0))
				return;
			pTab = pItem.pTab;

			pArgs = pItem.u1.pFuncArg;
			if ((pArgs) == (null))
				return;
			for (j = (int)(k = (int)(0)); (j) < (pArgs.nExpr); j++)
			{
				Expr pRhs;
				while (((k) < (pTab.nCol)) && ((pTab.aCol[k].colFlags & 0x0002) == (0)))
				{
					k++;
				}

				if ((k) >= (pTab.nCol))
				{
					sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d", pTab.zName, (int)(j));
					return;
				}

				pColRef = sqlite3ExprAlloc(pParse.db, (int)(167), null, (int)(0));
				if ((pColRef) == (null))
					return;
				pColRef.iTable = (int)(pItem.iCursor);
				pColRef.iColumn = (short)(k++);

				pColRef.y.pTab = pTab;
				pItem.colUsed |= (ulong)(sqlite3ExprColUsed(pColRef));
				pRhs = sqlite3PExpr(pParse, (int)(174), sqlite3ExprDup(pParse.db, pArgs.a[j].pExpr, (int)(0)), null);
				pTerm = sqlite3PExpr(pParse, (int)(53), pColRef, pRhs);
				if ((pItem.fg.jointype & 0x0008) != 0)
				{
					sqlite3SetJoinExpr(pTerm, (int)(pItem.iCursor));
				}

				whereClauseInsert(pWC, pTerm, (ushort)(0x0001));
			}
		}
		public static int sqlite3WhereUsesDeferredSeek(WhereInfo pWInfo)
		{
			return (int)(pWInfo.bDeferredSeek);
		}
		public static uint sqlite3Win32Wait(void* hObject)
		{
			uint rc = 0;
			while ((rc = (uint)((Uint(Void * , Void * , Void * ))(aSyscall[64].pCurrent)(hObject, (uint)(0xFFFFFFFF), (int)(1)))) == ((uint)(0x000000C0L)))
			{
			}

			return (uint)(rc);
		}
		public static Window sqlite3WindowAlloc(Parse pParse, int eType, int eStart, Expr pStart, int eEnd, Expr pEnd, byte eExclude)
		{
			Window pWin = null;
			int bImplicitFrame = (int)(0);





			if ((eType) == (0))
			{
				bImplicitFrame = (int)(1);
				eType = (int)(89);
			}

			if ((((eStart) == (85)) && ((eEnd) == (88))) || (((eStart) == (86)) && (((eEnd) == (88)) || ((eEnd) == (85)))))
			{
				sqlite3ErrorMsg(pParse, "unsupported frame specification");
				goto windowAllocErr;
			}

			pWin = (Window)(sqlite3DbMallocZero(pParse.db, (ulong)(sizeof(Window))));
			if ((pWin) == (null))
				goto windowAllocErr;
			pWin.eFrmType = (byte)(eType);
			pWin.eStart = (byte)(eStart);
			pWin.eEnd = (byte)(eEnd);
			if (((eExclude) == (0)) && (((pParse.db).dbOptFlags & (0x00000002)) != 0))
			{
				eExclude = (byte)(66);
			}

			pWin.eExclude = (byte)(eExclude);
			pWin.bImplicitFrame = (byte)(bImplicitFrame);
			pWin.pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
			pWin.pStart = sqlite3WindowOffsetExpr(pParse, pStart);
			return pWin;
		windowAllocErr:
			; sqlite3ExprDelete(pParse.db, pEnd);
			sqlite3ExprDelete(pParse.db, pStart);
			return null;
		}
		public static Window sqlite3WindowAssemble(Parse pParse, Window pWin, ExprList pPartition, ExprList pOrderBy, Token* pBase)
		{
			if ((pWin) != null)
			{
				pWin.pPartition = pPartition;
				pWin.pOrderBy = pOrderBy;
				if ((pBase) != null)
				{
					pWin.zBase = sqlite3DbStrNDup(pParse.db, pBase->z, (ulong)(pBase->n));
				}
			}
			else
			{
				sqlite3ExprListDelete(pParse.db, pPartition);
				sqlite3ExprListDelete(pParse.db, pOrderBy);
			}

			return pWin;
		}
		public static void sqlite3WindowAttach(Parse pParse, Expr p, Window pWin)
		{
			if ((p) != null)
			{


				p.y.pWin = pWin;
				(p).flags |= (uint)(0x1000000);
				pWin.pOwner = p;
				if (((p.flags & 0x000002) != 0) && (pWin.eFrmType != 166))
				{
					sqlite3ErrorMsg(pParse, "DISTINCT is not supported for window functions");
				}
			}
			else
			{
				sqlite3WindowDelete(pParse.db, pWin);
			}
		}
		public static void sqlite3WindowChain(Parse pParse, Window pWin, Window pList)
		{
			if ((pWin.zBase) != null)
			{
				sqlite3 db = pParse.db;
				Window pExist = windowFind(pParse, pList, pWin.zBase);
				if ((pExist) != null)
				{
					sbyte* zErr = null;
					if ((pWin.pPartition) != null)
					{
						zErr = "PARTITION clause";
					}
					else if (((pExist.pOrderBy) != null) && ((pWin.pOrderBy) != null))
					{
						zErr = "ORDER BY clause";
					}
					else if ((pExist.bImplicitFrame) == (0))
					{
						zErr = "frame specification";
					}

					if ((zErr) != null)
					{
						sqlite3ErrorMsg(pParse, "cannot override %s of window: %s", zErr, pWin.zBase);
					}
					else
					{
						pWin.pPartition = sqlite3ExprListDup(db, pExist.pPartition, (int)(0));
						if ((pExist.pOrderBy) != null)
						{

							pWin.pOrderBy = sqlite3ExprListDup(db, pExist.pOrderBy, (int)(0));
						}

						sqlite3DbFree(db, pWin.zBase);
						pWin.zBase = null;
					}
				}
			}
		}
		public static void sqlite3WindowCodeInit(Parse pParse, Select pSelect)
		{
			int nEphExpr = (int)(pSelect.pSrc.a[0].pSelect.pEList.nExpr);
			Window pMWin = pSelect.pWin;
			Window pWin;
			Vdbe v = sqlite3GetVdbe(pParse);
			sqlite3VdbeAddOp2(v, (int)(116), (int)(pMWin.iEphCsr), (int)(nEphExpr));
			sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 1), (int)(pMWin.iEphCsr));
			sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 2), (int)(pMWin.iEphCsr));
			sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.iEphCsr + 3), (int)(pMWin.iEphCsr));
			if ((pMWin.pPartition) != null)
			{
				int nExpr = (int)(pMWin.pPartition.nExpr);
				pMWin.regPart = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nExpr);
				sqlite3VdbeAddOp3(v, (int)(74), (int)(0), (int)(pMWin.regPart), (int)(pMWin.regPart + nExpr - 1));
			}

			pMWin.regOne = (int)(++pParse.nMem);
			sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regOne));
			if ((pMWin.eExclude) != 0)
			{
				pMWin.regStartRowid = (int)(++pParse.nMem);
				pMWin.regEndRowid = (int)(++pParse.nMem);
				pMWin.csrApp = (int)(pParse.nTab++);
				sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regStartRowid));
				sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pMWin.regEndRowid));
				sqlite3VdbeAddOp2(v, (int)(113), (int)(pMWin.csrApp), (int)(pMWin.iEphCsr));
				return;
			}

			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				FuncDef p = pWin.pFunc;
				if (((p.funcFlags & 0x1000) != 0) && (pWin.eStart != 90))
				{
					ExprList pList;
					KeyInfo pKeyInfo;

					pList = pWin.pOwner.x.pList;
					pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, (int)(0), (int)(0));
					pWin.csrApp = (int)(pParse.nTab++);
					pWin.regApp = (int)(pParse.nMem + 1);
					pParse.nMem += (int)(3);
					if (((pKeyInfo) != null) && ((pWin.pFunc.zName[1]) == (105)))
					{

						pKeyInfo.aSortFlags[0] = (byte)(0x01);
					}

					sqlite3VdbeAddOp2(v, (int)(116), (int)(pWin.csrApp), (int)(2));
					sqlite3VdbeAppendP4(v, pKeyInfo, (int)(-9));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
				}
				else if (((p.zName) == (nth_valueName)) || ((p.zName) == (first_valueName)))
				{
					pWin.regApp = (int)(pParse.nMem + 1);
					pWin.csrApp = (int)(pParse.nTab++);
					pParse.nMem += (int)(2);
					sqlite3VdbeAddOp2(v, (int)(113), (int)(pWin.csrApp), (int)(pMWin.iEphCsr));
				}
				else if (((p.zName) == (leadName)) || ((p.zName) == (lagName)))
				{
					pWin.csrApp = (int)(pParse.nTab++);
					sqlite3VdbeAddOp2(v, (int)(113), (int)(pWin.csrApp), (int)(pMWin.iEphCsr));
				}
			}
		}
		public static void sqlite3WindowCodeStep(Parse pParse, Select p, WhereInfo pWInfo, int regGosub, int addrGosub)
		{
			Window pMWin = p.pWin;
			ExprList pOrderBy = pMWin.pOrderBy;
			Vdbe v = sqlite3GetVdbe(pParse);
			int csrWrite = 0;
			int csrInput = (int)(p.pSrc.a[0].iCursor);
			int nInput = (int)(p.pSrc.a[0].pTab.nCol);
			int iInput = 0;
			int addrNe = 0;
			int addrGosubFlush = (int)(0);
			int addrInteger = (int)(0);
			int addrEmpty = 0;
			int regNew = 0;
			int regRecord = 0;
			int regNewPeer = (int)(0);
			int regPeer = (int)(0);
			int regFlushPart = (int)(0);
			WindowCodeArg s = new WindowCodeArg();
			int lblWhereEnd = 0;
			int regStart = (int)(0);
			int regEnd = (int)(0);



			lblWhereEnd = (int)(sqlite3VdbeMakeLabel(pParse));
			CRuntime.memset(s, (int)(0), (ulong)(sizeof(WindowCodeArg)));
			s.pParse = pParse;
			s.pMWin = pMWin;
			s.pVdbe = v;
			s.regGosub = (int)(regGosub);
			s.addrGosub = (int)(addrGosub);
			s.current.csr = (int)(pMWin.iEphCsr);
			csrWrite = (int)(s.current.csr + 1);
			s.start.csr = (int)(s.current.csr + 2);
			s.end.csr = (int)(s.current.csr + 3);
			switch (pMWin.eStart)
			{
				case 86:
					if ((pMWin.eFrmType != 89) && ((windowExprGtZero(pParse, pMWin.pStart)) != 0))
					{
						s.eDelete = (int)(1);
					}

					break;
				case 90:
					if ((windowCacheFrame(pMWin)) == (0))
					{
						if ((pMWin.eEnd) == (88))
						{
							if ((pMWin.eFrmType != 89) && ((windowExprGtZero(pParse, pMWin.pEnd)) != 0))
							{
								s.eDelete = (int)(3);
							}
						}
						else
						{
							s.eDelete = (int)(1);
						}
					}

					break;
				default:
					s.eDelete = (int)(2);
					break;
			}

			regNew = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nInput);
			regRecord = (int)(++pParse.nMem);
			s.regRowid = (int)(++pParse.nMem);
			if (((pMWin.eStart) == (88)) || ((pMWin.eStart) == (86)))
			{
				regStart = (int)(++pParse.nMem);
			}

			if (((pMWin.eEnd) == (88)) || ((pMWin.eEnd) == (86)))
			{
				regEnd = (int)(++pParse.nMem);
			}

			if (pMWin.eFrmType != 76)
			{
				int nPeer = (int)(pOrderBy ? pOrderBy.nExpr : 0);
				regNewPeer = (int)(regNew + pMWin.nBufferCol);
				if ((pMWin.pPartition) != null)
					regNewPeer += (int)(pMWin.pPartition.nExpr);
				regPeer = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPeer);
				s.start.reg = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPeer);
				s.current.reg = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPeer);
				s.end.reg = (int)(pParse.nMem + 1);
				pParse.nMem += (int)(nPeer);
			}

			for (iInput = (int)(0); (iInput) < (nInput); iInput++)
			{
				sqlite3VdbeAddOp3(v, (int)(93), (int)(csrInput), (int)(iInput), (int)(regNew + iInput));
			}

			sqlite3VdbeAddOp3(v, (int)(96), (int)(regNew), (int)(nInput), (int)(regRecord));
			if ((pMWin.pPartition) != null)
			{
				int addr = 0;
				ExprList pPart = pMWin.pPartition;
				int nPart = (int)(pPart.nExpr);
				int regNewPart = (int)(regNew + pMWin.nBufferCol);
				KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, (int)(0), (int)(0));
				regFlushPart = (int)(++pParse.nMem);
				addr = (int)(sqlite3VdbeAddOp3(v, (int)(89), (int)(regNewPart), (int)(pMWin.regPart), (int)(nPart)));
				sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
				sqlite3VdbeAddOp3(v, (int)(16), (int)(addr + 2), (int)(addr + 4), (int)(addr + 2));
				addrGosubFlush = (int)(sqlite3VdbeAddOp1(v, (int)(12), (int)(regFlushPart)));
				sqlite3VdbeAddOp3(v, (int)(79), (int)(regNewPart), (int)(pMWin.regPart), (int)(nPart - 1));
			}

			sqlite3VdbeAddOp2(v, (int)(126), (int)(csrWrite), (int)(s.regRowid));
			sqlite3VdbeAddOp3(v, (int)(127), (int)(csrWrite), (int)(regRecord), (int)(s.regRowid));
			addrNe = (int)(sqlite3VdbeAddOp3(v, (int)(52), (int)(pMWin.regOne), (int)(0), (int)(s.regRowid)));
			s.regArg = (int)(windowInitAccum(pParse, pMWin));
			if ((regStart) != 0)
			{
				sqlite3ExprCode(pParse, pMWin.pStart, (int)(regStart));
				windowCheckValue(pParse, (int)(regStart), (int)(0 + ((pMWin.eFrmType) == (89) ? 3 : 0)));
			}

			if ((regEnd) != 0)
			{
				sqlite3ExprCode(pParse, pMWin.pEnd, (int)(regEnd));
				windowCheckValue(pParse, (int)(regEnd), (int)(1 + ((pMWin.eFrmType) == (89) ? 3 : 0)));
			}

			if (((pMWin.eFrmType != 89) && ((pMWin.eStart) == (pMWin.eEnd))) && ((regStart) != 0))
			{
				int op = (int)(((pMWin.eStart) == (86)) ? 57 : 55);
				int addrGe = (int)(sqlite3VdbeAddOp3(v, (int)(op), (int)(regStart), (int)(0), (int)(regEnd)));
				windowAggFinal(s, (int)(0));
				sqlite3VdbeAddOp2(v, (int)(38), (int)(s.current.csr), (int)(1));
				windowReturnOneRow(s);
				sqlite3VdbeAddOp1(v, (int)(145), (int)(s.current.csr));
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblWhereEnd));
				sqlite3VdbeJumpHere(v, (int)(addrGe));
			}

			if ((((pMWin.eStart) == (86)) && (pMWin.eFrmType != 89)) && ((regEnd) != 0))
			{

				sqlite3VdbeAddOp3(v, (int)(107), (int)(regStart), (int)(regEnd), (int)(regStart));
			}

			if (pMWin.eStart != 90)
			{
				sqlite3VdbeAddOp2(v, (int)(38), (int)(s.start.csr), (int)(1));
			}

			sqlite3VdbeAddOp2(v, (int)(38), (int)(s.current.csr), (int)(1));
			sqlite3VdbeAddOp2(v, (int)(38), (int)(s.end.csr), (int)(1));
			if (((regPeer) != 0) && ((pOrderBy) != null))
			{
				sqlite3VdbeAddOp3(v, (int)(79), (int)(regNewPeer), (int)(regPeer), (int)(pOrderBy.nExpr - 1));
				sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.start.reg), (int)(pOrderBy.nExpr - 1));
				sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.current.reg), (int)(pOrderBy.nExpr - 1));
				sqlite3VdbeAddOp3(v, (int)(79), (int)(regPeer), (int)(s.end.reg), (int)(pOrderBy.nExpr - 1));
			}

			sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblWhereEnd));
			sqlite3VdbeJumpHere(v, (int)(addrNe));
			if ((regPeer) != 0)
			{
				windowIfNewPeer(pParse, pOrderBy, (int)(regNewPeer), (int)(regPeer), (int)(lblWhereEnd));
			}

			if ((pMWin.eStart) == (86))
			{
				windowCodeOp(s, (int)(3), (int)(0), (int)(0));
				if (pMWin.eEnd != 90)
				{
					if ((pMWin.eFrmType) == (89))
					{
						int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
						int addrNext = (int)(sqlite3VdbeCurrentAddr(v));
						windowCodeRangeTest(s, (int)(57), (int)(s.current.csr), (int)(regEnd), (int)(s.end.csr), (int)(lbl));
						windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
						windowCodeOp(s, (int)(1), (int)(0), (int)(0));
						sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrNext));
						sqlite3VdbeResolveLabel(v, (int)(lbl));
					}
					else
					{
						windowCodeOp(s, (int)(1), (int)(regEnd), (int)(0));
						windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
					}
				}
			}
			else if ((pMWin.eEnd) == (88))
			{
				int bRPS = (int)((((pMWin.eStart) == (88)) && ((pMWin.eFrmType) == (89))) ? 1 : 0);
				windowCodeOp(s, (int)(3), (int)(regEnd), (int)(0));
				if ((bRPS) != 0)
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
				windowCodeOp(s, (int)(1), (int)(0), (int)(0));
				if (bRPS == 0)
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
			}
			else
			{
				int addr = (int)(0);
				windowCodeOp(s, (int)(3), (int)(0), (int)(0));
				if (pMWin.eEnd != 90)
				{
					if ((pMWin.eFrmType) == (89))
					{
						int lbl = (int)(0);
						addr = (int)(sqlite3VdbeCurrentAddr(v));
						if ((regEnd) != 0)
						{
							lbl = (int)(sqlite3VdbeMakeLabel(pParse));
							windowCodeRangeTest(s, (int)(57), (int)(s.current.csr), (int)(regEnd), (int)(s.end.csr), (int)(lbl));
						}

						windowCodeOp(s, (int)(1), (int)(0), (int)(0));
						windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
						if ((regEnd) != 0)
						{
							sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addr));
							sqlite3VdbeResolveLabel(v, (int)(lbl));
						}
					}
					else
					{
						if ((regEnd) != 0)
						{
							addr = (int)(sqlite3VdbeAddOp3(v, (int)(49), (int)(regEnd), (int)(0), (int)(1)));
						}

						windowCodeOp(s, (int)(1), (int)(0), (int)(0));
						windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
						if ((regEnd) != 0)
							sqlite3VdbeJumpHere(v, (int)(addr));
					}
				}
			}

			sqlite3VdbeResolveLabel(v, (int)(lblWhereEnd));
			sqlite3WhereEnd(pWInfo);
			if ((pMWin.pPartition) != null)
			{
				addrInteger = (int)(sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regFlushPart)));
				sqlite3VdbeJumpHere(v, (int)(addrGosubFlush));
			}

			s.regRowid = (int)(0);
			addrEmpty = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(csrWrite)));
			if ((pMWin.eEnd) == (88))
			{
				int bRPS = (int)((((pMWin.eStart) == (88)) && ((pMWin.eFrmType) == (89))) ? 1 : 0);
				windowCodeOp(s, (int)(3), (int)(regEnd), (int)(0));
				if ((bRPS) != 0)
					windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
				windowCodeOp(s, (int)(1), (int)(0), (int)(0));
			}
			else if ((pMWin.eStart) == (86))
			{
				int addrStart = 0;
				int addrBreak1 = 0;
				int addrBreak2 = 0;
				int addrBreak3 = 0;
				windowCodeOp(s, (int)(3), (int)(0), (int)(0));
				if ((pMWin.eFrmType) == (89))
				{
					addrStart = (int)(sqlite3VdbeCurrentAddr(v));
					addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(regStart), (int)(1)));
					addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
				}
				else if ((pMWin.eEnd) == (90))
				{
					addrStart = (int)(sqlite3VdbeCurrentAddr(v));
					addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(regStart), (int)(1)));
					addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(0), (int)(1)));
				}
				else
				{

					addrStart = (int)(sqlite3VdbeCurrentAddr(v));
					addrBreak1 = (int)(windowCodeOp(s, (int)(1), (int)(regEnd), (int)(1)));
					addrBreak2 = (int)(windowCodeOp(s, (int)(2), (int)(regStart), (int)(1)));
				}

				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
				sqlite3VdbeJumpHere(v, (int)(addrBreak2));
				addrStart = (int)(sqlite3VdbeCurrentAddr(v));
				addrBreak3 = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
				sqlite3VdbeJumpHere(v, (int)(addrBreak1));
				sqlite3VdbeJumpHere(v, (int)(addrBreak3));
			}
			else
			{
				int addrBreak = 0;
				int addrStart = 0;
				windowCodeOp(s, (int)(3), (int)(0), (int)(0));
				addrStart = (int)(sqlite3VdbeCurrentAddr(v));
				addrBreak = (int)(windowCodeOp(s, (int)(1), (int)(0), (int)(1)));
				windowCodeOp(s, (int)(2), (int)(regStart), (int)(0));
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrStart));
				sqlite3VdbeJumpHere(v, (int)(addrBreak));
			}

			sqlite3VdbeJumpHere(v, (int)(addrEmpty));
			sqlite3VdbeAddOp1(v, (int)(145), (int)(s.current.csr));
			if ((pMWin.pPartition) != null)
			{
				if ((pMWin.regStartRowid) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(pMWin.regStartRowid));
					sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pMWin.regEndRowid));
				}

				sqlite3VdbeChangeP1(v, (int)(addrInteger), (int)(sqlite3VdbeCurrentAddr(v)));
				sqlite3VdbeAddOp1(v, (int)(67), (int)(regFlushPart));
			}
		}
		public static int sqlite3WindowCompare(Parse pParse, Window p1, Window p2, int bFilter)
		{
			int res = 0;
			if (((p1) == (null)) || ((p2) == (null)))
				return (int)(1);
			if (p1.eFrmType != p2.eFrmType)
				return (int)(1);
			if (p1.eStart != p2.eStart)
				return (int)(1);
			if (p1.eEnd != p2.eEnd)
				return (int)(1);
			if (p1.eExclude != p2.eExclude)
				return (int)(1);
			if ((sqlite3ExprCompare(pParse, p1.pStart, p2.pStart, (int)(-1))) != 0)
				return (int)(1);
			if ((sqlite3ExprCompare(pParse, p1.pEnd, p2.pEnd, (int)(-1))) != 0)
				return (int)(1);
			if ((res = (int)(sqlite3ExprListCompare(p1.pPartition, p2.pPartition, (int)(-1)))))
			{
				return (int)(res);
			}

			if ((res = (int)(sqlite3ExprListCompare(p1.pOrderBy, p2.pOrderBy, (int)(-1)))))
			{
				return (int)(res);
			}

			if ((bFilter) != 0)
			{
				if ((res = (int)(sqlite3ExprCompare(pParse, p1.pFilter, p2.pFilter, (int)(-1)))))
				{
					return (int)(res);
				}
			}

			return (int)(0);
		}
		public static void sqlite3WindowDelete(sqlite3 db, Window p)
		{
			if ((p) != null)
			{
				sqlite3WindowUnlinkFromSelect(p);
				sqlite3ExprDelete(db, p.pFilter);
				sqlite3ExprListDelete(db, p.pPartition);
				sqlite3ExprListDelete(db, p.pOrderBy);
				sqlite3ExprDelete(db, p.pEnd);
				sqlite3ExprDelete(db, p.pStart);
				sqlite3DbFree(db, p.zName);
				sqlite3DbFree(db, p.zBase);
				sqlite3DbFree(db, p);
			}
		}
		public static Window sqlite3WindowDup(sqlite3 db, Expr pOwner, Window p)
		{
			Window pNew = null;
			if ((p) != null)
			{
				pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(Window)));
				if ((pNew) != null)
				{
					pNew.zName = sqlite3DbStrDup(db, p.zName);
					pNew.zBase = sqlite3DbStrDup(db, p.zBase);
					pNew.pFilter = sqlite3ExprDup(db, p.pFilter, (int)(0));
					pNew.pFunc = p.pFunc;
					pNew.pPartition = sqlite3ExprListDup(db, p.pPartition, (int)(0));
					pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, (int)(0));
					pNew.eFrmType = (byte)(p.eFrmType);
					pNew.eEnd = (byte)(p.eEnd);
					pNew.eStart = (byte)(p.eStart);
					pNew.eExclude = (byte)(p.eExclude);
					pNew.regResult = (int)(p.regResult);
					pNew.regAccum = (int)(p.regAccum);
					pNew.iArgCol = (int)(p.iArgCol);
					pNew.iEphCsr = (int)(p.iEphCsr);
					pNew.bExprArgs = (byte)(p.bExprArgs);
					pNew.pStart = sqlite3ExprDup(db, p.pStart, (int)(0));
					pNew.pEnd = sqlite3ExprDup(db, p.pEnd, (int)(0));
					pNew.pOwner = pOwner;
					pNew.bImplicitFrame = (byte)(p.bImplicitFrame);
				}
			}

			return pNew;
		}
		public static int sqlite3WindowExtraAggFuncDepth(Walker pWalker, Expr pExpr)
		{
			if (((pExpr.op) == (168)) && ((pExpr.op2) >= (pWalker.walkerDepth)))
			{
				pExpr.op2++;
			}

			return (int)(0);
		}
		public static void sqlite3WindowFunctions()
		{
			sqlite3InsertBuiltinFuncs(sqlite3WindowFunctions_aWindowFuncs, ((int)(15 * sizeof(FuncDef) / sizeof(FuncDef))));
		}
		public static void sqlite3WindowLink(Select pSel, Window pWin)
		{
			if ((pSel) != null)
			{
				if (((null) == (pSel.pWin)) || ((0) == (sqlite3WindowCompare(null, pSel.pWin, pWin, (int)(0)))))
				{
					pWin.pNextWin = pSel.pWin;
					if ((pSel.pWin) != null)
					{
						pSel.pWin.ppThis = pWin.pNextWin;
					}

					pSel.pWin = pWin;
					pWin.ppThis = pSel.pWin;
				}
				else
				{
					if ((sqlite3ExprListCompare(pWin.pPartition, pSel.pWin.pPartition, (int)(-1))) != 0)
					{
						pSel.selFlags |= (uint)(0x2000000);
					}
				}
			}
		}
		public static void sqlite3WindowListDelete(sqlite3 db, Window p)
		{
			while ((p) != null)
			{
				Window pNext = p.pNextWin;
				sqlite3WindowDelete(db, p);
				p = pNext;
			}
		}
		public static Window sqlite3WindowListDup(sqlite3 db, Window p)
		{
			Window pWin;
			Window pRet = null;
			Window pp = pRet;
			for (pWin = p; pWin; pWin = pWin.pNextWin)
			{
				pp = sqlite3WindowDup(db, null, pWin);
				if ((pp) == (null))
					break;
				pp = ((pp).pNextWin);
			}

			return pRet;
		}
		public static Expr sqlite3WindowOffsetExpr(Parse pParse, Expr pExpr)
		{
			if ((0) == (sqlite3ExprIsConstant(pExpr)))
			{
				if (((pParse.eParseMode) >= (2)))
					sqlite3RenameExprUnmap(pParse, pExpr);
				sqlite3ExprDelete(pParse.db, pExpr);
				pExpr = sqlite3ExprAlloc(pParse.db, (int)(121), null, (int)(0));
			}

			return pExpr;
		}
		public static int sqlite3WindowRewrite(Parse pParse, Select p)
		{
			int rc = (int)(0);
			if (((((p.pWin) != null) && ((p.pPrior) == (null))) && ((p.selFlags & 0x0100000) == (0))) && ((!((pParse.eParseMode) >= (2))) != 0))
			{
				Vdbe v = sqlite3GetVdbe(pParse);
				sqlite3 db = pParse.db;
				Select pSub = null;
				SrcList pSrc = p.pSrc;
				Expr pWhere = p.pWhere;
				ExprList pGroupBy = p.pGroupBy;
				Expr pHaving = p.pHaving;
				ExprList pSort = null;
				ExprList pSublist = null;
				Window pMWin = p.pWin;
				Window pWin;
				Table pTab;
				Walker w = new Walker();
				uint selFlags = (uint)(p.selFlags);
				pTab = sqlite3DbMallocZero(db, (ulong)(sizeof(Table)));
				if ((pTab) == (null))
				{
					return (int)(sqlite3ErrorToParser(db, (int)(7)));
				}

				sqlite3AggInfoPersistWalkerInit(w, pParse);
				sqlite3WalkSelect(w, p);
				if ((p.selFlags & 0x0000008) == (0))
				{
					w.xExprCallback = disallowAggregatesInOrderByCb;
					w.xSelectCallback = null;
					sqlite3WalkExprList(w, p.pOrderBy);
				}

				p.pSrc = null;
				p.pWhere = null;
				p.pGroupBy = null;
				p.pHaving = null;
				p.selFlags &= (uint)(~0x0000008);
				p.selFlags |= (uint)(0x0100000);
				pSort = exprListAppendList(pParse, null, pMWin.pPartition, (int)(1));
				pSort = exprListAppendList(pParse, pSort, pMWin.pOrderBy, (int)(1));
				if ((((pSort) != null) && ((p.pOrderBy) != null)) && ((p.pOrderBy.nExpr) <= (pSort.nExpr)))
				{
					int nSave = (int)(pSort.nExpr);
					pSort.nExpr = (int)(p.pOrderBy.nExpr);
					if ((sqlite3ExprListCompare(pSort, p.pOrderBy, (int)(-1))) == (0))
					{
						sqlite3ExprListDelete(db, p.pOrderBy);
						p.pOrderBy = null;
					}

					pSort.nExpr = (int)(nSave);
				}

				pMWin.iEphCsr = (int)(pParse.nTab++);
				pParse.nTab += (int)(3);
				selectWindowRewriteEList(pParse, pMWin, pSrc, p.pEList, pTab, pSublist);
				selectWindowRewriteEList(pParse, pMWin, pSrc, p.pOrderBy, pTab, pSublist);
				pMWin.nBufferCol = (int)(pSublist ? pSublist.nExpr : 0);
				pSublist = exprListAppendList(pParse, pSublist, pMWin.pPartition, (int)(0));
				pSublist = exprListAppendList(pParse, pSublist, pMWin.pOrderBy, (int)(0));
				for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
				{
					ExprList pArgs;


					pArgs = pWin.pOwner.x.pList;
					if ((pWin.pFunc.funcFlags & 0x00100000) != 0)
					{
						selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, pSublist);
						pWin.iArgCol = (int)(pSublist ? pSublist.nExpr : 0);
						pWin.bExprArgs = (byte)(1);
					}
					else
					{
						pWin.iArgCol = (int)(pSublist ? pSublist.nExpr : 0);
						pSublist = exprListAppendList(pParse, pSublist, pArgs, (int)(0));
					}

					if ((pWin.pFilter) != null)
					{
						Expr pFilter = sqlite3ExprDup(db, pWin.pFilter, (int)(0));
						pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
					}

					pWin.regAccum = (int)(++pParse.nMem);
					pWin.regResult = (int)(++pParse.nMem);
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
				}

				if ((pSublist) == (null))
				{
					pSublist = sqlite3ExprListAppend(pParse, null, sqlite3Expr(db, (int)(155), "0"));
				}

				pSub = sqlite3SelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, (uint)(0), null);
				p.pSrc = sqlite3SrcListAppend(pParse, null, null, null);

				if ((p.pSrc) != null)
				{
					Table pTab2;
					p.pSrc.a[0].pSelect = pSub;
					sqlite3SrcListAssignCursors(pParse, p.pSrc);
					pSub.selFlags |= (uint)(0x0000040 | 0x8000000);
					pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, (sbyte)(0x40));
					pSub.selFlags |= (uint)(selFlags & 0x0000008);
					if ((pTab2) == (null))
					{
						rc = (int)(7);
					}
					else
					{
						CRuntime.memcpy(pTab, pTab2, (ulong)(sizeof(Table)));
						pTab.tabFlags |= (uint)(0x00004000);
						p.pSrc.a[0].pTab = pTab;
						pTab = pTab2;
						CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
						w.xExprCallback = sqlite3WindowExtraAggFuncDepth;
						w.xSelectCallback = sqlite3WalkerDepthIncrease;
						w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
						sqlite3WalkSelect(w, pSub);
					}
				}
				else
				{
					sqlite3SelectDelete(db, pSub);
				}

				if ((db.mallocFailed) != 0)
					rc = (int)(7);
				sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pTab);
			}


			return (int)(rc);
		}
		public static void sqlite3WindowUnlinkFromSelect(Window p)
		{
			if ((p.ppThis) != null)
			{
				p.ppThis = p.pNextWin;
				if ((p.pNextWin) != null)
					p.pNextWin.ppThis = p.ppThis;
				p.ppThis = null;
			}
		}
		public static void sqlite3WindowUpdate(Parse pParse, Window pList, Window pWin, FuncDef pFunc)
		{
			if (((pWin.zName) != null) && ((pWin.eFrmType) == (0)))
			{
				Window p = windowFind(pParse, pList, pWin.zName);
				if ((p) == (null))
					return;
				pWin.pPartition = sqlite3ExprListDup(pParse.db, p.pPartition, (int)(0));
				pWin.pOrderBy = sqlite3ExprListDup(pParse.db, p.pOrderBy, (int)(0));
				pWin.pStart = sqlite3ExprDup(pParse.db, p.pStart, (int)(0));
				pWin.pEnd = sqlite3ExprDup(pParse.db, p.pEnd, (int)(0));
				pWin.eStart = (byte)(p.eStart);
				pWin.eEnd = (byte)(p.eEnd);
				pWin.eFrmType = (byte)(p.eFrmType);
				pWin.eExclude = (byte)(p.eExclude);
			}
			else
			{
				sqlite3WindowChain(pParse, pWin, pList);
			}

			if ((((pWin.eFrmType) == (89)) && (((pWin.pStart) != null) || ((pWin.pEnd) != null))) && (((pWin.pOrderBy) == (null)) || (pWin.pOrderBy.nExpr != 1)))
			{
				sqlite3ErrorMsg(pParse, "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression");
			}
			else if ((pFunc.funcFlags & 0x00010000) != 0)
			{
				sqlite3 db = pParse.db;
				if ((pWin.pFilter) != null)
				{
					sqlite3ErrorMsg(pParse, "FILTER clause may only be used with aggregate window functions");
				}
				else
				{
					WindowUpdate* aUp = stackalloc WindowUpdate[] { { row_numberName, 76, 90, 85 }, { dense_rankName, 89, 90, 85 }, { rankName, 89, 90, 85 }, { percent_rankName, 92, 85, 90 }, { cume_distName, 92, 86, 90 }, { ntileName, 76, 85, 90 }, { leadName, 76, 90, 90 }, { lagName, 76, 90, 85 } };
					int i = 0;
					for (i = (int)(0); (i) < ((int)(8 * sizeof(WindowUpdate) / sizeof(WindowUpdate))); i++)
					{
						if ((pFunc.zName) == (aUp[i].zFunc))
						{
							sqlite3ExprDelete(db, pWin.pStart);
							sqlite3ExprDelete(db, pWin.pEnd);
							pWin.pEnd = pWin.pStart = null;
							pWin.eFrmType = (byte)(aUp[i].eFrmType);
							pWin.eStart = (byte)(aUp[i].eStart);
							pWin.eEnd = (byte)(aUp[i].eEnd);
							pWin.eExclude = (byte)(0);
							if ((pWin.eStart) == (86))
							{
								pWin.pStart = sqlite3Expr(db, (int)(155), "1");
							}

							break;
						}
					}
				}
			}

			pWin.pFunc = pFunc;
		}
		public static With sqlite3WithAdd(Parse pParse, With pWith, Cte pCte)
		{
			sqlite3 db = pParse.db;
			With pNew;
			sbyte* zName;
			if ((pCte) == (null))
			{
				return pWith;
			}

			zName = pCte.zName;
			if (((zName) != null) && ((pWith) != null))
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWith.nCte); i++)
				{
					if ((sqlite3StrICmp(zName, pWith.a[i].zName)) == (0))
					{
						sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
					}
				}
			}

			if ((pWith) != null)
			{
				long nByte = (long)(sizeof(With) + (sizeof(Cte) * pWith.nCte));
				pNew = sqlite3DbRealloc(db, pWith, (ulong)(nByte));
			}
			else
			{
				pNew = sqlite3DbMallocZero(db, (ulong)(sizeof(With)));
			}


			if ((db.mallocFailed) != 0)
			{
				sqlite3CteDelete(db, pCte);
				pNew = pWith;
			}
			else
			{
				pNew.a[pNew.nCte++] = (Cte)(pCte);
				sqlite3DbFree(db, pCte);
			}

			return pNew;
		}
		public static void sqlite3WithDelete(sqlite3 db, With pWith)
		{
			if ((pWith) != null)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWith.nCte); i++)
				{
					cteClear(db, pWith.a[i]);
				}

				sqlite3DbFree(db, pWith);
			}
		}
		public static With sqlite3WithDup(sqlite3 db, With p)
		{
			With pRet = null;
			if ((p) != null)
			{
				long nByte = (long)(sizeof(With) + sizeof(Cte) * (p.nCte - 1));
				pRet = sqlite3DbMallocZero(db, (ulong)(nByte));
				if ((pRet) != null)
				{
					int i = 0;
					pRet.nCte = (int)(p.nCte);
					for (i = (int)(0); (i) < (p.nCte); i++)
					{
						pRet.a[i].pSelect = sqlite3SelectDup(db, p.a[i].pSelect, (int)(0));
						pRet.a[i].pCols = sqlite3ExprListDup(db, p.a[i].pCols, (int)(0));
						pRet.a[i].zName = sqlite3DbStrDup(db, p.a[i].zName);
					}
				}
			}

			return pRet;
		}
		public static With sqlite3WithPush(Parse pParse, With pWith, byte bFree)
		{
			if ((pWith) != null)
			{
				if ((bFree) != 0)
				{
					pWith = (With)(sqlite3ParserAddCleanup(pParse, sqlite3WithDelete, pWith));
					if ((pWith) == (null))
						return null;
				}

				if ((pParse.nErr) == (0))
				{

					pWith.pOuter = pParse.pWith;
					pParse.pWith = pWith;
				}
			}

			return pWith;
		}
		public static int sqlite3WritableSchema(sqlite3 db)
		{
			return ((db.flags & (0x00000001 | 0x10000000)) == (0x00000001) ? 1 : 0);
		}
		public static void sqliteAuthBadReturnCode(Parse pParse)
		{
			sqlite3ErrorMsg(pParse, "authorizer malfunction");
			pParse.rc = (int)(1);
		}
		public static int sqliteDefaultBusyCallback(void* ptr, int count)
		{
			sqlite3 db = (sqlite3)(ptr);
			int tmout = (int)(db.busyTimeout);
			int delay = 0; int prior = 0;

			if ((count) < ((int)(12 * sizeof(byte) / sizeof(byte))))
			{
				delay = (int)(sqliteDefaultBusyCallback_delays[count]);
				prior = (int)(sqliteDefaultBusyCallback_totals[count]);
			}
			else
			{
				delay = (int)(sqliteDefaultBusyCallback_delays[((int)(12 * sizeof(byte) / sizeof(byte))) - 1]);
				prior = (int)(sqliteDefaultBusyCallback_totals[((int)(12 * sizeof(byte) / sizeof(byte))) - 1] + delay * (count - (((int)(12 * sizeof(byte) / sizeof(byte))) - 1)));
			}

			if ((prior + delay) > (tmout))
			{
				delay = (int)(tmout - prior);
				if ((delay) <= (0))
					return (int)(0);
			}

			sqlite3OsSleep(db.pVfs, (int)(delay * 1000));
			return (int)(1);
		}
		public static int sqliteProcessJoin(Parse pParse, Select p)
		{
			SrcList pSrc;
			int i = 0; int j = 0;
			SrcItem pLeft;
			SrcItem pRight;
			pSrc = p.pSrc;
			pLeft = pSrc.a[0];
			pRight = pLeft[1];
			for (i = (int)(0); (i) < (pSrc.nSrc - 1); i++, pRight++, pLeft++)
			{
				Table pRightTab = pRight.pTab;
				int isOuter = 0;
				if ((((pLeft.pTab) == (null)) || ((pRightTab) == (null))))
					continue;
				isOuter = (int)((pRight.fg.jointype & 0x0020) != 0);
				if ((pRight.fg.jointype & 0x0004) != 0)
				{
					if (((pRight.pOn) != null) || ((pRight.pUsing) != null))
					{
						sqlite3ErrorMsg(pParse, "a NATURAL join may not have an ON or USING clause", (int)(0));
						return (int)(1);
					}

					for (j = (int)(0); (j) < (pRightTab.nCol); j++)
					{
						sbyte* zName;
						int iLeft = 0;
						int iLeftCol = 0;
						if ((((&pRightTab.aCol[j])->colFlags & 0x0002) != 0))
							continue;
						zName = pRightTab.aCol[j].zCnName;
						if ((tableAndColumnIndex(pSrc, (int)(i + 1), zName, &iLeft, &iLeftCol, (int)(1))) != 0)
						{
							addWhereTerm(pParse, pSrc, (int)(iLeft), (int)(iLeftCol), (int)(i + 1), (int)(j), (int)(isOuter), p.pWhere);
						}
					}
				}

				if (((pRight.pOn) != null) && ((pRight.pUsing) != null))
				{
					sqlite3ErrorMsg(pParse, "cannot have both ON and USING clauses in the same join");
					return (int)(1);
				}

				if ((pRight.pOn) != null)
				{
					if ((isOuter) != 0)
						sqlite3SetJoinExpr(pRight.pOn, (int)(pRight.iCursor));
					p.pWhere = sqlite3ExprAnd(pParse, p.pWhere, pRight.pOn);
					pRight.pOn = null;
				}

				if ((pRight.pUsing) != null)
				{
					IdList* pList = pRight.pUsing;
					for (j = (int)(0); (j) < (pList->nId); j++)
					{
						sbyte* zName;
						int iLeft = 0;
						int iLeftCol = 0;
						int iRightCol = 0;
						zName = pList->a[j].zName;
						iRightCol = (int)(sqlite3ColumnIndex(pRightTab, zName));
						if (((iRightCol) < (0)) || (tableAndColumnIndex(pSrc, (int)(i + 1), zName, &iLeft, &iLeftCol, (int)(0)) == 0))
						{
							sqlite3ErrorMsg(pParse, "cannot join using column %s - column not present in both tables", zName);
							return (int)(1);
						}

						addWhereTerm(pParse, pSrc, (int)(iLeft), (int)(iLeftCol), (int)(i + 1), (int)(iRightCol), (int)(isOuter), p.pWhere);
					}
				}
			}

			return (int)(0);
		}
		public static void sqliteViewResetAll(sqlite3 db, int idx)
		{
			HashElem* i;

			if (!(((db).aDb[idx].pSchema.schemaFlags & (0x0002)) == (0x0002)))
				return;
			for (i = ((&db.aDb[idx].pSchema.tblHash)->first); i; i = ((i)->next))
			{
				Table pTab = ((i)->data);
				if ((((pTab).eTabType) == (2)))
				{
					sqlite3DeleteColumnNames(db, pTab);
				}
			}

			(db).aDb[idx].pSchema.schemaFlags &= (ushort)(~(0x0002));
		}
		public static void srclistRenumberCursors(Parse pParse, int* aCsrMap, SrcList pSrc, int iExcept)
		{
			int i = 0;
			SrcItem pItem;
			for (i = (int)(0), pItem = pSrc.a; (i) < (pSrc.nSrc); i++, pItem++)
			{
				if (i != iExcept)
				{
					Select p;

					if ((pItem.fg.isRecursive == 0) || ((aCsrMap[pItem.iCursor + 1]) == (0)))
					{
						aCsrMap[pItem.iCursor + 1] = (int)(pParse.nTab++);
					}

					pItem.iCursor = (int)(aCsrMap[pItem.iCursor + 1]);
					for (p = pItem.pSelect; p; p = p.pPrior)
					{
						srclistRenumberCursors(pParse, aCsrMap, p.pSrc, (int)(-1));
					}
				}
			}
		}
		public static void statAccumDestructor(void* pOld)
		{
			StatAccum p = (StatAccum)(pOld);
			sqlite3DbFree(p.db, p);
		}
		public static void statGet(sqlite3_context context, int argc, sqlite3_value argv)
		{
			StatAccum p = (StatAccum)(sqlite3_value_blob(argv[0]));

			{
				sqlite3_str sStat = new sqlite3_str();
				int i = 0;
				sqlite3StrAccumInit(sStat, null, null, (int)(0), (int)((p.nKeyCol + 1) * 100));
				sqlite3_str_appendf(sStat, "%llu", (ulong)((p.nSkipAhead) != 0 ? (ulong)(p.nEst) : (ulong)(p.nRow)));
				for (i = (int)(0); (i) < (p.nKeyCol); i++)
				{
					ulong nDistinct = (ulong)(p.current.anDLt[i] + 1);
					ulong iVal = (ulong)((p.nRow + nDistinct - 1) / nDistinct);
					sqlite3_str_appendf(sStat, " %llu", (ulong)(iVal));

				}

				sqlite3ResultStrAccum(context, sStat);
			}


		}
		public static void statInit(sqlite3_context context, int argc, sqlite3_value argv)
		{
			StatAccum p;
			int nCol = 0;
			int nKeyCol = 0;
			int nColUp = 0;
			int n = 0;
			sqlite3 db = sqlite3_context_db_handle(context);

			nCol = (int)(sqlite3_value_int(argv[0]));

			nColUp = (int)((sizeof(uint)) < (8) ? (nCol + 1) & ~1 : nCol);
			nKeyCol = (int)(sqlite3_value_int(argv[1]));


			n = (int)(sizeof(StatAccum) + sizeof(uint) * nColUp + sizeof(uint) * nColUp);
			p = sqlite3DbMallocZero(db, (ulong)(n));
			if ((p) == (null))
			{
				sqlite3_result_error_nomem(context);
				return;
			}

			p.db = db;
			p.nEst = (uint)(sqlite3_value_int64(argv[2]));
			p.nRow = (uint)(0);
			p.nLimit = (int)(sqlite3_value_int64(argv[3]));
			p.nCol = (int)(nCol);
			p.nKeyCol = (int)(nKeyCol);
			p.nSkipAhead = (byte)(0);
			p.current.anDLt = (uint*)(p[1]);
			p.current.anEq = &p.current.anDLt[nColUp];
			sqlite3_result_blob(context, p, (int)(sizeof(StatAccum)), statAccumDestructor);
		}
		public static void statPush(sqlite3_context context, int argc, sqlite3_value argv)
		{
			int i = 0;
			StatAccum p = (StatAccum)(sqlite3_value_blob(argv[0]));
			int iChng = (int)(sqlite3_value_int(argv[1]));

			(void)(context);


			if ((p.nRow) == (0))
			{
				for (i = (int)(0); (i) < (p.nCol); i++)
				{
					p.current.anEq[i] = (uint)(1);
				}
			}
			else
			{
				for (i = (int)(0); (i) < (iChng); i++)
				{
					p.current.anEq[i]++;
				}

				for (i = (int)(iChng); (i) < (p.nCol); i++)
				{
					p.current.anDLt[i]++;
					p.current.anEq[i] = (uint)(1);
				}
			}

			p.nRow++;
			if (((p.nLimit) != 0) && ((p.nRow) > ((uint)(p.nLimit) * (p.nSkipAhead + 1))))
			{
				p.nSkipAhead++;
				sqlite3_result_int(context, ((p.current.anDLt[0]) > (0) ? 1 : 0));
			}
		}
		public static sbyte* strAccumFinishRealloc(sqlite3_str p)
		{
			sbyte* zText;

			zText = sqlite3DbMallocRaw(p.db, (ulong)(p.nChar + 1));
			if ((zText) != null)
			{
				CRuntime.memcpy(zText, p.zText, (ulong)(p.nChar + 1));
				p.printfFlags |= (byte)(0x04);
			}
			else
			{
				sqlite3StrAccumSetError(p, (byte)(7));
			}

			p.zText = zText;
			return zText;
		}
		public static void strftimeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			ulong i = 0; ulong j = 0;
			sqlite3 db;
			sbyte* zFmt;
			sqlite3_str sRes = new sqlite3_str();
			if ((argc) == (0))
				return;
			zFmt = (sbyte*)(sqlite3_value_text(argv[0]));
			if (((zFmt) == (null)) || ((isDate(context, (int)(argc - 1), argv[1], &x)) != 0))
				return;
			db = sqlite3_context_db_handle(context);
			sqlite3StrAccumInit(sRes, null, null, (int)(0), (int)(db.aLimit[0]));
			computeJD(&x);
			computeYMD_HMS(&x);
			for (i = (ulong)(j = (ulong)(0)); zFmt[i]; i++)
			{
				if (zFmt[i] != 37)
					continue;
				if ((j) < (i))
					sqlite3_str_append(sRes, zFmt + j, (int)(i - j));
				i++;
				j = (ulong)(i + 1);
				switch (zFmt[i])
				{
					case 100:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.D));
							break;
						}

					case 102:
						{
							double s = (double)(x.s);
							if ((s) > (59.999))
								s = (double)(59.999);
							sqlite3_str_appendf(sRes, "%06.3f", (double)(s));
							break;
						}

					case 72:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.h));
							break;
						}

					case 87:
					case 106:
						{
							int nDay = 0;
							DateTime y = (DateTime)(x);
							y.validJD = (sbyte)(0);
							y.M = (int)(1);
							y.D = (int)(1);
							computeJD(&y);
							nDay = ((int)((x.iJD - y.iJD + 43200000) / 86400000));
							if ((zFmt[i]) == (87))
							{
								int wd = 0;
								wd = ((int)(((x.iJD + 43200000) / 86400000) % 7));
								sqlite3_str_appendf(sRes, "%02d", (int)((nDay + 7 - wd) / 7));
							}
							else
							{
								sqlite3_str_appendf(sRes, "%03d", (int)(nDay + 1));
							}

							break;
						}

					case 74:
						{
							sqlite3_str_appendf(sRes, "%.16g", (double)(x.iJD / 86400000.0));
							break;
						}

					case 109:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.M));
							break;
						}

					case 77:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.m));
							break;
						}

					case 115:
						{
							long iS = (long)(x.iJD / 1000 - 21086676 * (long)(10000));
							sqlite3_str_appendf(sRes, "%lld", (long)(iS));
							break;
						}

					case 83:
						{
							sqlite3_str_appendf(sRes, "%02d", (int)(x.s));
							break;
						}

					case 119:
						{
							sqlite3_str_appendchar(sRes, (int)(1), (sbyte)((sbyte)(((x.iJD + 129600000) / 86400000) % 7) + 48));
							break;
						}

					case 89:
						{
							sqlite3_str_appendf(sRes, "%04d", (int)(x.Y));
							break;
						}

					case 37:
						{
							sqlite3_str_appendchar(sRes, (int)(1), (sbyte)(37));
							break;
						}

					default:
						{
							sqlite3_str_reset(sRes);
							return;
						}
				}
			}

			if ((j) < (i))
				sqlite3_str_append(sRes, zFmt + j, (int)(i - j));
			sqlite3ResultStrAccum(context, sRes);
		}
		public static uint strHash(sbyte* z)
		{
			uint h = (uint)(0);
			byte c = 0;
			while ((c = ((byte)(*z++))) != 0)
			{
				h += (uint)(sqlite3UpperToLower[c]);
				h *= (uint)(0x9e3779b1);
			}

			return (uint)(h);
		}
		public static int subjournalPage(PgHdr pPg)
		{
			int rc = (int)(0);
			Pager pPager = pPg.pPager;
			if (pPager.journalMode != 2)
			{




				rc = (int)(openSubJournal(pPager));
				if ((rc) == (0))
				{
					void* pData = pPg.pData;
					long offset = (long)((long)(pPager.nSubRec) * (4 + pPager.pageSize));
					sbyte* pData2;
					pData2 = pData;
					rc = (int)(write32bits(pPager.sjfd, (long)(offset), (uint)(pPg.pgno)));
					if ((rc) == (0))
					{
						rc = (int)(sqlite3OsWrite(pPager.sjfd, pData2, (int)(pPager.pageSize), (long)(offset + 4)));
					}
				}
			}

			if ((rc) == (0))
			{
				pPager.nSubRec++;

				rc = (int)(addToSavepointBitvecs(pPager, (uint)(pPg.pgno)));
			}

			return (int)(rc);
		}
		public static int subjournalPageIfRequired(PgHdr pPg)
		{
			if ((subjRequiresPage(pPg)) != 0)
			{
				return (int)(subjournalPage(pPg));
			}
			else
			{
				return (int)(0);
			}
		}
		public static int subjRequiresPage(PgHdr pPg)
		{
			Pager pPager = pPg.pPager;
			PagerSavepoint* p;
			uint pgno = (uint)(pPg.pgno);
			int i = 0;
			for (i = (int)(0); (i) < (pPager.nSavepoint); i++)
			{
				p = &pPager.aSavepoint[i];
				if (((p->nOrig) >= (pgno)) && ((0) == (sqlite3BitvecTestNotNull(p->pInSavepoint, (uint)(pgno)))))
				{
					for (i = (int)(i + 1); (i) < (pPager.nSavepoint); i++)
					{
						pPager.aSavepoint[i].bTruncateOnRelease = (int)(0);
					}

					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static Expr substExpr(SubstContext pSubst, Expr pExpr)
		{
			if ((pExpr) == (null))
				return null;
			if ((((pExpr).flags & (0x000001)) != 0) && ((pExpr.w.iRightJoinTable) == (pSubst.iTable)))
			{
				pExpr.w.iRightJoinTable = (int)(pSubst.iNewTable);
			}

			if ((((pExpr.op) == (167)) && ((pExpr.iTable) == (pSubst.iTable))) && (!(((pExpr).flags & (0x000008)) != 0)))
			{
				{
					Expr pNew;
					Expr pCopy = pSubst.pEList.a[pExpr.iColumn].pExpr;
					Expr ifNullRow = new Expr();


					if ((sqlite3ExprIsVector(pCopy)) != 0)
					{
						sqlite3VectorErrorMsg(pSubst.pParse, pCopy);
					}
					else
					{
						sqlite3 db = pSubst.pParse.db;
						if (((pSubst.isLeftJoin) != 0) && (pCopy.op != 167))
						{
							CRuntime.memset(ifNullRow, (int)(0), (ulong)(sizeof(Expr)));
							ifNullRow.op = (byte)(179);
							ifNullRow.pLeft = pCopy;
							ifNullRow.iTable = (int)(pSubst.iNewTable);
							ifNullRow.flags = (uint)(0x020000);
							pCopy = ifNullRow;
						}

						pNew = sqlite3ExprDup(db, pCopy, (int)(0));
						if ((db.mallocFailed) != 0)
						{
							sqlite3ExprDelete(db, pNew);
							return pExpr;
						}

						if ((pSubst.isLeftJoin) != 0)
						{
							(pNew).flags |= (uint)(0x100000);
						}

						if ((((pExpr).flags & (0x000001)) != 0))
						{
							sqlite3SetJoinExpr(pNew, (int)(pExpr.w.iRightJoinTable));
						}

						sqlite3ExprDelete(db, pExpr);
						pExpr = pNew;
						if ((pExpr.op != 167) && (pExpr.op != 113))
						{
							CollSeq pColl = sqlite3ExprCollSeq(pSubst.pParse, pExpr);
							pExpr = sqlite3ExprAddCollateString(pSubst.pParse, pExpr, (pColl ? pColl.zName : "BINARY"));
						}

						(pExpr).flags &= (uint)(~(0x000100));
					}
				}
			}
			else
			{
				if (((pExpr.op) == (179)) && ((pExpr.iTable) == (pSubst.iTable)))
				{
					pExpr.iTable = (int)(pSubst.iNewTable);
				}

				pExpr.pLeft = substExpr(pSubst, pExpr.pLeft);
				pExpr.pRight = substExpr(pSubst, pExpr.pRight);
				if ((((pExpr).flags & 0x000800) != 0))
				{
					substSelect(pSubst, pExpr.x.pSelect, (int)(1));
				}
				else
				{
					substExprList(pSubst, pExpr.x.pList);
				}

				if ((((pExpr).flags & (0x1000000)) != 0))
				{
					Window pWin = pExpr.y.pWin;
					pWin.pFilter = substExpr(pSubst, pWin.pFilter);
					substExprList(pSubst, pWin.pPartition);
					substExprList(pSubst, pWin.pOrderBy);
				}
			}

			return pExpr;
		}
		public static void substExprList(SubstContext pSubst, ExprList pList)
		{
			int i = 0;
			if ((pList) == (null))
				return;
			for (i = (int)(0); (i) < (pList.nExpr); i++)
			{
				pList.a[i].pExpr = substExpr(pSubst, pList.a[i].pExpr);
			}
		}
		public static void substrFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* z;
			byte* z2;
			int len = 0;
			int p0type = 0;
			long p1 = 0; long p2 = 0;
			int negP2 = (int)(0);

			if (((sqlite3_value_type(argv[1])) == (5)) || (((argc) == (3)) && ((sqlite3_value_type(argv[2])) == (5))))
			{
				return;
			}

			p0type = (int)(sqlite3_value_type(argv[0]));
			p1 = (long)(sqlite3_value_int(argv[1]));
			if ((p0type) == (4))
			{
				len = (int)(sqlite3_value_bytes(argv[0]));
				z = sqlite3_value_blob(argv[0]);
				if ((z) == (null))
					return;

			}
			else
			{
				z = sqlite3_value_text(argv[0]);
				if ((z) == (null))
					return;
				len = (int)(0);
				if ((p1) < (0))
				{
					for (z2 = z; *z2; len++)
					{
						{
							if ((*(z2++)) >= (0xc0))
							{
								while ((*z2 & 0xc0) == (0x80))
								{
									z2++;
								}
							}
						}
					}
				}
			}

			if ((argc) == (3))
			{
				p2 = (long)(sqlite3_value_int(argv[2]));
				if ((p2) < (0))
				{
					p2 = (long)(-p2);
					negP2 = (int)(1);
				}
			}
			else
			{
				p2 = (long)(sqlite3_context_db_handle(context).aLimit[0]);
			}

			if ((p1) < (0))
			{
				p1 += (long)(len);
				if ((p1) < (0))
				{
					p2 += (long)(p1);
					if ((p2) < (0))
						p2 = (long)(0);
					p1 = (long)(0);
				}
			}
			else if ((p1) > (0))
			{
				p1--;
			}
			else if ((p2) > (0))
			{
				p2--;
			}

			if ((negP2) != 0)
			{
				p1 -= (long)(p2);
				if ((p1) < (0))
				{
					p2 += (long)(p1);
					p1 = (long)(0);
				}
			}


			if (p0type != 4)
			{
				while (((*z) != 0) && ((p1) != 0))
				{
					{
						if ((*(z++)) >= (0xc0))
						{
							while ((*z & 0xc0) == (0x80))
							{
								z++;
							}
						}
					}

					p1--;
				}

				for (z2 = z; ((*z2) != 0) && ((p2) != 0); p2--)
				{
					{
						if ((*(z2++)) >= (0xc0))
						{
							while ((*z2 & 0xc0) == (0x80))
							{
								z2++;
							}
						}
					}
				}

				sqlite3_result_text64(context, (sbyte*)(z), (ulong)(z2 - z), ((Void(Void * ))(-1)), (byte)(1));
			}
			else
			{
				if ((p1 + p2) > (len))
				{
					p2 = (long)(len - p1);
					if ((p2) < (0))
						p2 = (long)(0);
				}

				sqlite3_result_blob64(context, (sbyte*)(&z[p1]), (ulong)(p2), ((Void(Void * ))(-1)));
			}
		}
		public static void substSelect(SubstContext pSubst, Select p, int doPrior)
		{
			SrcList pSrc;
			SrcItem pItem;
			int i = 0;
			if (p == null)
				return;
			do
			{
				substExprList(pSubst, p.pEList);
				substExprList(pSubst, p.pGroupBy);
				substExprList(pSubst, p.pOrderBy);
				p.pHaving = substExpr(pSubst, p.pHaving);
				p.pWhere = substExpr(pSubst, p.pWhere);
				pSrc = p.pSrc;

				for (i = (int)(pSrc.nSrc), pItem = pSrc.a; (i) > (0); i--, pItem++)
				{
					substSelect(pSubst, pItem.pSelect, (int)(1));
					if ((pItem.fg.isTabFunc) != 0)
					{
						substExprList(pSubst, pItem.u1.pFuncArg);
					}
				}
			}
			while (((doPrior) != 0) && ((p = p.pPrior) != null));
		}
		public static void subtypeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{

			sqlite3_result_int(context, (int)(sqlite3_value_subtype(argv[0])));
		}
		public static void sumFinalize(sqlite3_context context)
		{
			SumCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			if (((p) != null) && ((p->cnt) > (0)))
			{
				if ((p->overflow) != 0)
				{
					sqlite3_result_error(context, "integer overflow", (int)(-1));
				}
				else if ((p->approx) != 0)
				{
					sqlite3_result_double(context, (double)(p->rSum));
				}
				else
				{
					sqlite3_result_int64(context, (long)(p->iSum));
				}
			}
		}
		public static void sumInverse(sqlite3_context context, int argc, sqlite3_value argv)
		{
			SumCtx* p;
			int type = 0;


			p = sqlite3_aggregate_context(context, (int)(sizeof(SumCtx)));
			type = (int)(sqlite3_value_numeric_type(argv[0]));
			if (((p) != null) && (type != 5))
			{

				p->cnt--;

				if (((type) == (1)) && ((p->approx) == (0)))
				{
					long v = (long)(sqlite3_value_int64(argv[0]));
					p->rSum -= (double)(v);
					p->iSum -= (long)(v);
				}
				else
				{
					p->rSum -= (double)(sqlite3_value_double(argv[0]));
				}
			}
		}
		public static void sumStep(sqlite3_context context, int argc, sqlite3_value argv)
		{
			SumCtx* p;
			int type = 0;


			p = sqlite3_aggregate_context(context, (int)(sizeof(SumCtx)));
			type = (int)(sqlite3_value_numeric_type(argv[0]));
			if (((p) != null) && (type != 5))
			{
				p->cnt++;
				if ((type) == (1))
				{
					long v = (long)(sqlite3_value_int64(argv[0]));
					p->rSum += (double)(v);
					if (((p->approx | p->overflow) == (0)) && ((sqlite3AddInt64(&p->iSum, (long)(v))) != 0))
					{
						p->approx = (byte)(p->overflow = (byte)(1));
					}
				}
				else
				{
					p->rSum += (double)(sqlite3_value_double(argv[0]));
					p->approx = (byte)(1);
				}
			}
		}
		public static int syncJournal(Pager pPager, int newHdr)
		{
			int rc = 0;



			rc = (int)(sqlite3PagerExclusiveLock(pPager));
			if (rc != 0)
				return (int)(rc);
			if (pPager.noSync == 0)
			{

				if (((pPager.jfd).pMethods != null) && (pPager.journalMode != 4))
				{
					int iDc = (int)(sqlite3OsDeviceCharacteristics(pPager.fd));

					if ((0) == (iDc & 0x00000200))
					{
						long iNextHdrOffset = 0;
						byte* aMagic = stackalloc byte[8];
						byte* zHeader = stackalloc byte[12];
						CRuntime.memcpy(zHeader, aJournalMagic, (ulong)(8 * sizeof(byte)));
						sqlite3Put4byte(&zHeader[8 * sizeof(byte)], (uint)(pPager.nRec));
						iNextHdrOffset = (long)(journalHdrOffset(pPager));
						rc = (int)(sqlite3OsRead(pPager.jfd, aMagic, (int)(8), (long)(iNextHdrOffset)));
						if (((rc) == (0)) && ((0) == (memcmp(aMagic, aJournalMagic, (ulong)(8)))))
						{
							rc = (int)(sqlite3OsWrite(pPager.jfd, &syncJournal_zerobyte, (int)(1), (long)(iNextHdrOffset)));
						}

						if ((rc != 0) && (rc != (10 | (2 << 8))))
						{
							return (int)(rc);
						}

						if (((pPager.fullSync) != 0) && ((0) == (iDc & 0x00000400)))
						{
							rc = (int)(sqlite3OsSync(pPager.jfd, (int)(pPager.syncFlags)));
							if (rc != 0)
								return (int)(rc);
						}

						rc = (int)(sqlite3OsWrite(pPager.jfd, zHeader, (int)(12 * sizeof(byte)), (long)(pPager.journalHdr)));
						if (rc != 0)
							return (int)(rc);
					}

					if ((0) == (iDc & 0x00000400))
					{
						rc = (int)(sqlite3OsSync(pPager.jfd, (int)(pPager.syncFlags | ((pPager.syncFlags) == (0x00003) ? 0x00010 : 0))));
						if (rc != 0)
							return (int)(rc);
					}

					pPager.journalHdr = (long)(pPager.journalOff);
					if (((newHdr) != 0) && ((0) == (iDc & 0x00000200)))
					{
						pPager.nRec = (int)(0);
						rc = (int)(writeJournalHdr(pPager));
						if (rc != 0)
							return (int)(rc);
					}
				}
				else
				{
					pPager.journalHdr = (long)(pPager.journalOff);
				}
			}

			sqlite3PcacheClearSyncFlags(pPager.pPCache);
			pPager.eState = (byte)(4);

			return (int)(0);
		}
		public static int synthCollSeq(sqlite3 db, CollSeq pColl)
		{
			CollSeq pColl2;
			sbyte* z = pColl.zName;
			int i = 0;
			for (i = (int)(0); (i) < (3); i++)
			{
				pColl2 = sqlite3FindCollSeq(db, (byte)(synthCollSeq_aEnc[i]), z, (int)(0));
				if (pColl2.xCmp != null)
				{
					CRuntime.memcpy(pColl, pColl2, (ulong)(sizeof(CollSeq)));
					pColl.xDel = null;
					return (int)(0);
				}
			}

			return (int)(1);
		}
		public static int tabIsReadOnly(Parse pParse, Table pTab)
		{
			sqlite3 db;
			if ((((pTab).eTabType) == (1)))
			{
				return ((sqlite3GetVTable(pParse.db, pTab).pMod.pModule.xUpdate) == (null) ? 1 : 0);
			}

			if ((pTab.tabFlags & (0x00000001 | 0x00001000)) == (0))
				return (int)(0);
			db = pParse.db;
			if ((pTab.tabFlags & 0x00000001) != 0)
			{
				return (((sqlite3WritableSchema(db)) == (0)) && ((pParse.nested) == (0)) ? 1 : 0);
			}


			return (int)(sqlite3ReadOnlyShadowTables(db));
		}
		public static int tableAndColumnIndex(SrcList pSrc, int N, sbyte* zCol, int* piTab, int* piCol, int bIgnoreHidden)
		{
			int i = 0;
			int iCol = 0;

			for (i = (int)(0); (i) < (N); i++)
			{
				iCol = (int)(sqlite3ColumnIndex(pSrc.a[i].pTab, zCol));
				if (((iCol) >= (0)) && (((bIgnoreHidden) == (0)) || ((((&pSrc.a[i].pTab.aCol[iCol])->colFlags & 0x0002) != 0) == (0))))
				{
					if ((piTab) != null)
					{
						*piTab = (int)(i);
						*piCol = (int)(iCol);
					}

					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int tableMayNotBeDropped(sqlite3 db, Table pTab)
		{
			if ((sqlite3_strnicmp(pTab.zName, "sqlite_", (int)(7))) == (0))
			{
				if ((sqlite3_strnicmp(pTab.zName + 7, "stat", (int)(4))) == (0))
					return (int)(0);
				if ((sqlite3_strnicmp(pTab.zName + 7, "parameters", (int)(10))) == (0))
					return (int)(0);
				return (int)(1);
			}

			if (((pTab.tabFlags & 0x00001000) != 0) && ((sqlite3ReadOnlyShadowTables(db)) != 0))
			{
				return (int)(1);
			}

			if ((pTab.tabFlags & 0x00008000) != 0)
			{
				return (int)(1);
			}

			return (int)(0);
		}
		public static Table tableOfTrigger(Trigger pTrigger)
		{
			return sqlite3HashFind(&pTrigger.pTabSchema.tblHash, pTrigger.table);
		}
		public static int termCanDriveIndex(WhereTerm pTerm, SrcItem pSrc, ulong notReady)
		{
			sbyte aff = 0;
			if (pTerm.leftCursor != pSrc.iCursor)
				return (int)(0);
			if ((pTerm.eOperator & (0x0002 | 0x0080)) == (0))
				return (int)(0);
			if ((((pSrc.fg.jointype & 0x0008) != 0) && (!(((pTerm.pExpr).flags & (0x000001)) != 0))) && ((pTerm.eOperator & 0x0080) != 0))
			{
				return (int)(0);
			}

			if ((pTerm.prereqRight & notReady) != 0)
				return (int)(0);

			if ((pTerm.u.x.leftColumn) < (0))
				return (int)(0);
			aff = (sbyte)(pSrc.pTab.aCol[pTerm.u.x.leftColumn].affinity);
			if (sqlite3IndexAffinityOk(pTerm.pExpr, (sbyte)(aff)) == 0)
				return (int)(0);
			return (int)(1);
		}
		public static int termIsEquivalence(Parse pParse, Expr pExpr)
		{
			sbyte aff1 = 0; sbyte aff2 = 0;
			CollSeq pColl;
			if (!(((pParse.db).dbOptFlags & (0x00000080)) == (0)))
				return (int)(0);
			if ((pExpr.op != 53) && (pExpr.op != 45))
				return (int)(0);
			if ((((pExpr).flags & (0x000001)) != 0))
				return (int)(0);
			aff1 = (sbyte)(sqlite3ExprAffinity(pExpr.pLeft));
			aff2 = (sbyte)(sqlite3ExprAffinity(pExpr.pRight));
			if ((aff1 != aff2) && ((!((aff1) >= (0x43))) || (!((aff2) >= (0x43)))))
			{
				return (int)(0);
			}

			pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);
			if ((sqlite3IsBinary(pColl)) != 0)
				return (int)(1);
			return (int)(sqlite3ExprCollSeqMatch(pParse, pExpr.pLeft, pExpr.pRight));
		}
		public static void timeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				int s = 0;
				sbyte* zBuf = stackalloc sbyte[16];
				computeHMS(&x);
				zBuf[0] = (sbyte)(48 + (x.h / 10) % 10);
				zBuf[1] = (sbyte)(48 + (x.h) % 10);
				zBuf[2] = (sbyte)(58);
				zBuf[3] = (sbyte)(48 + (x.m / 10) % 10);
				zBuf[4] = (sbyte)(48 + (x.m) % 10);
				zBuf[5] = (sbyte)(58);
				s = ((int)(x.s));
				zBuf[6] = (sbyte)(48 + (s / 10) % 10);
				zBuf[7] = (sbyte)(48 + (s) % 10);
				zBuf[8] = (sbyte)(0);
				sqlite3_result_text(context, zBuf, (int)(8), ((Void(Void * ))(-1)));
			}
		}
		public static Expr tokenExpr(Parse pParse, int op, Token t)
		{
			Expr p = sqlite3DbMallocRawNN(pParse.db, (ulong)(sizeof(Expr) + t.n + 1));
			if ((p) != null)
			{
				p.op = ((byte)(op));
				p.affExpr = (sbyte)(0);
				p.flags = (uint)(0x800000);
				p.iAgg = (short)(-1);
				p.pLeft = p.pRight = null;
				p.pAggInfo = null;
				CRuntime.memset(&p.x, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18070 : 3)) ) )
        ;
				CRuntime.memset(&p.y, (int)(0), (ulong)(sizeof(union Expr::(unnamed at sqlite3.c : 18099 : 3)) ) )
        ;
				p.op2 = (byte)(0);
				p.iTable = (int)(0);
				p.iColumn = (short)(0);
				p.u.zToken = (sbyte*)(p[1]);
				CRuntime.memcpy(p.u.zToken, t.z, (ulong)(t.n));
				p.u.zToken[t.n] = (sbyte)(0);
				p.w.iOfst = ((int)(t.z - pParse.zTail));
				if ((sqlite3CtypeMap[(byte)(p.u.zToken[0])] & 0x80) != 0)
				{
					sqlite3DequoteExpr(p);
				}

				p.nHeight = (int)(1);
				if (((pParse.eParseMode) >= (2)))
				{
					return (Expr)(sqlite3RenameTokenMap(pParse, (void*)(p), &t));
				}
			}

			return p;
		}
		public static int toLocaltime(DateTime* p, sqlite3_context pCtx)
		{
			long t = 0;
			tm sLocal = new tm();
			int iYearDiff = 0;
			CRuntime.memset(&sLocal, (int)(0), (ulong)(sizeof(tm)));
			computeJD(p);
			if (((p->iJD) < (2108667600 * (long)(100000))) || ((p->iJD) > (2130141456 * (long)(100000))))
			{
				DateTime x = (DateTime)(*p);
				computeYMD_HMS(&x);
				iYearDiff = (int)((2000 + x.Y % 4) - x.Y);
				x.Y += (int)(iYearDiff);
				x.validJD = (sbyte)(0);
				computeJD(&x);
				t = (long)(x.iJD / 1000 - 21086676 * (long)(10000));
			}
			else
			{
				iYearDiff = (int)(0);
				t = (long)(p->iJD / 1000 - 21086676 * (long)(10000));
			}

			if ((osLocaltime(&t, &sLocal)) != 0)
			{
				sqlite3_result_error(pCtx, "local time unavailable", (int)(-1));
				return (int)(1);
			}

			p->Y = (int)(sLocal.tm_year + 1900 - iYearDiff);
			p->M = (int)(sLocal.tm_mon + 1);
			p->D = (int)(sLocal.tm_mday);
			p->h = (int)(sLocal.tm_hour);
			p->m = (int)(sLocal.tm_min);
			p->s = (double)(sLocal.tm_sec + (p->iJD % 1000) * 0.001);
			p->validYMD = (sbyte)(1);
			p->validHMS = (sbyte)(1);
			p->validJD = (sbyte)(0);
			p->rawS = (sbyte)(0);
			p->validTZ = (sbyte)(0);
			p->isError = (sbyte)(0);
			return (int)(0);
		}
		public static void total_changes(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			sqlite3 db = sqlite3_context_db_handle(context);
			(void)(NotUsed) ,  (void)(NotUsed2);
			sqlite3_result_int64(context, (long)(sqlite3_total_changes64(db)));
		}
		public static void totalFinalize(sqlite3_context context)
		{
			SumCtx* p;
			p = sqlite3_aggregate_context(context, (int)(0));
			sqlite3_result_double(context, (double)(p ? p->rSum : (double)(0)));
		}
		public static void transferJoinMarkings(Expr pDerived, Expr pBase)
		{
			if ((pDerived) != null)
			{
				pDerived.flags |= (uint)(pBase.flags & 0x000001);
				pDerived.w.iRightJoinTable = (int)(pBase.w.iRightJoinTable);
			}
		}
		public static void transferParseError(Parse pTo, Parse pFrom)
		{


			if ((pTo.nErr) == (0))
			{
				pTo.zErrMsg = pFrom.zErrMsg;
				pTo.nErr = (int)(pFrom.nErr);
				pTo.rc = (int)(pFrom.rc);
			}
			else
			{
				sqlite3DbFree(pFrom.db, pFrom.zErrMsg);
			}
		}
		public static void translateColumnToCopy(Parse pParse, int iStart, int iTabCur, int iRegister, int iAutoidxCur)
		{
			Vdbe v = pParse.pVdbe;
			VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iStart));
			int iEnd = (int)(sqlite3VdbeCurrentAddr(v));
			if ((pParse.db.mallocFailed) != 0)
				return;
			for (; (iStart) < (iEnd); iStart++, pOp++)
			{
				if (pOp->p1 != iTabCur)
					continue;
				if ((pOp->opcode) == (93))
				{
					pOp->opcode = (byte)(79);
					pOp->p1 = (int)(pOp->p2 + iRegister);
					pOp->p2 = (int)(pOp->p3);
					pOp->p3 = (int)(0);
				}
				else if ((pOp->opcode) == (134))
				{
					pOp->opcode = (byte)(125);
					pOp->p1 = (int)(iAutoidxCur);
				}
			}
		}
		public static sbyte* triggerSpanDup(sqlite3 db, sbyte* zStart, sbyte* zEnd)
		{
			sbyte* z = sqlite3DbSpanDup(db, zStart, zEnd);
			int i = 0;
			if ((z) != null)
				for (i = (int)(0); z[i]; i++)
				{
					if ((sqlite3CtypeMap[(byte)(z[i])] & 0x01) != 0)
						z[i] = (sbyte)(32);
				}

			return z;
		}
		public static TriggerStep triggerStepAllocate(Parse pParse, byte op, Token* pName, sbyte* zStart, sbyte* zEnd)
		{
			sqlite3 db = pParse.db;
			TriggerStep pTriggerStep;
			if ((pParse.nErr) != 0)
				return null;
			pTriggerStep = sqlite3DbMallocZero(db, (ulong)(sizeof(TriggerStep) + pName->n + 1));
			if ((pTriggerStep) != null)
			{
				sbyte* z = (sbyte*)(pTriggerStep[1]);
				CRuntime.memcpy(z, pName->z, (ulong)(pName->n));
				sqlite3Dequote(z);
				pTriggerStep.zTarget = z;
				pTriggerStep.op = (byte)(op);
				pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd);
				if (((pParse.eParseMode) >= (2)))
				{
					sqlite3RenameTokenMap(pParse, pTriggerStep.zTarget, pName);
				}
			}

			return pTriggerStep;
		}
		public static void trimFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* zIn;
			byte* zCharSet;
			uint nIn = 0;
			int flags = 0;
			int i = 0;
			uint* aLen = null;
			byte** azChar = null;
			int nChar = 0;
			if ((sqlite3_value_type(argv[0])) == (5))
			{
				return;
			}

			zIn = sqlite3_value_text(argv[0]);
			if ((zIn) == (null))
				return;
			nIn = ((uint)(sqlite3_value_bytes(argv[0])));

			if ((argc) == (1))
			{
				nChar = (int)(1);
				aLen = trimFunc_lenOne;
				azChar = trimFunc_azOne;
				zCharSet = null;
			}
			else if ((zCharSet = sqlite3_value_text(argv[1])) == (null))
			{
				return;
			}
			else
			{
				byte* z;
				for (z = zCharSet, nChar = (int)(0); *z; nChar++)
				{
					{
						if ((*(z++)) >= (0xc0))
						{
							while ((*z & 0xc0) == (0x80))
							{
								z++;
							}
						}
					}
				}

				if ((nChar) > (0))
				{
					azChar = contextMalloc(context, (long)(((long)(nChar)) * (sizeof(char*) + sizeof(unsigned))));
					if ((azChar) == (null))
					{
						return;
					}

					aLen = (uint*)(&azChar[nChar]);
					for (z = zCharSet, nChar = (int)(0); *z; nChar++)
					{
						azChar[nChar] = z;
						{
							if ((*(z++)) >= (0xc0))
							{
								while ((*z & 0xc0) == (0x80))
								{
									z++;
								}
							}
						}

						aLen[nChar] = ((uint)(z - azChar[nChar]));
					}
				}
			}

			if ((nChar) > (0))
			{
				flags = ((int)((long)(sqlite3_user_data(context))));
				if ((flags & 1) != 0)
				{
					while ((nIn) > (0))
					{
						uint len = (uint)(0);
						for (i = (int)(0); (i) < (nChar); i++)
						{
							len = (uint)(aLen[i]);
							if (((len) <= (nIn)) && ((memcmp(zIn, azChar[i], (ulong)(len))) == (0)))
								break;
						}

						if ((i) >= (nChar))
							break;
						zIn += len;
						nIn -= (uint)(len);
					}
				}

				if ((flags & 2) != 0)
				{
					while ((nIn) > (0))
					{
						uint len = (uint)(0);
						for (i = (int)(0); (i) < (nChar); i++)
						{
							len = (uint)(aLen[i]);
							if (((len) <= (nIn)) && ((memcmp(&zIn[nIn - len], azChar[i], (ulong)(len))) == (0)))
								break;
						}

						if ((i) >= (nChar))
							break;
						nIn -= (uint)(len);
					}
				}

				if ((zCharSet) != null)
				{
					sqlite3_free(azChar);
				}
			}

			sqlite3_result_text(context, (sbyte*)(zIn), (int)(nIn), ((Void(Void * ))(-1)));
		}
		public static void typeofFunc(sqlite3_context context, int NotUsed, sqlite3_value argv)
		{
			int i = (int)(sqlite3_value_type(argv[0]) - 1);
			(void)(NotUsed);






			sqlite3_result_text(context, typeofFunc_azType[i], (int)(-1), null);
		}
		public static void unicodeFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			byte* z = sqlite3_value_text(argv[0]);

			if (((z) != null) && ((z[0]) != 0))
				sqlite3_result_int(context, (int)(sqlite3Utf8Read(&z)));
		}
		public static void unixepochFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			DateTime x = new DateTime();
			if ((isDate(context, (int)(argc), argv, &x)) == (0))
			{
				computeJD(&x);
				sqlite3_result_int64(context, (long)(x.iJD / 1000 - 21086676 * (long)(10000)));
			}
		}
		public static void unlockBtreeIfUnused(BtShared pBt)
		{


			if (((pBt.inTransaction) == (0)) && (pBt.pPage1 != null))
			{
				MemPage pPage1 = pBt.pPage1;


				pBt.pPage1 = null;
				releasePageOne(pPage1);
			}
		}
		public static void unlockBtreeMutex(Btree p)
		{
			BtShared pBt = p.pBt;




			sqlite3_mutex_leave(pBt.mutex);
			p.locked = (byte)(0);
		}
		public static void unmapColumnIdlistNames(Parse pParse, IdList* pIdList)
		{
			if ((pIdList) != null)
			{
				int ii = 0;
				for (ii = (int)(0); (ii) < (pIdList->nId); ii++)
				{
					sqlite3RenameTokenRemap(pParse, null, (void*)(pIdList->a[ii].zName));
				}
			}
		}
		public static void unsetJoinExpr(Expr p, int iTable)
		{
			while ((p) != null)
			{
				if ((((p).flags & (0x000001)) != 0) && (((iTable) < (0)) || ((p.w.iRightJoinTable) == (iTable))))
				{
					(p).flags &= (uint)(~(0x000001));
				}

				if (((p.op) == (167)) && ((p.iTable) == (iTable)))
				{
					(p).flags &= (uint)(~(0x100000));
				}

				if ((p.op) == (172))
				{

					if ((p.x.pList) != null)
					{
						int i = 0;
						for (i = (int)(0); (i) < (p.x.pList.nExpr); i++)
						{
							unsetJoinExpr(p.x.pList.a[i].pExpr, (int)(iTable));
						}
					}
				}

				unsetJoinExpr(p.pLeft, (int)(iTable));
				p = p.pRight;
			}
		}
		public static void updateAccumulator(Parse pParse, int regAcc, AggInfo pAggInfo, int eDistinctType)
		{
			Vdbe v = pParse.pVdbe;
			int i = 0;
			int regHit = (int)(0);
			int addrHitTest = (int)(0);
			AggInfo_func* pF;
			AggInfo_col* pC;
			pAggInfo.directMode = (byte)(1);
			for (i = (int)(0), pF = pAggInfo.aFunc; (i) < (pAggInfo.nFunc); i++, pF++)
			{
				int nArg = 0;
				int addrNext = (int)(0);
				int regAgg = 0;
				ExprList pList;


				pList = pF->pFExpr.x.pList;
				if ((((pF->pFExpr).flags & (0x1000000)) != 0))
				{
					Expr pFilter = pF->pFExpr.y.pWin.pFilter;
					if ((((pAggInfo.nAccumulator) != 0) && ((pF->pFunc.funcFlags & 0x0020) != 0)) && ((regAcc) != 0))
					{
						if ((regHit) == (0))
							regHit = (int)(++pParse.nMem);
						sqlite3VdbeAddOp2(v, (int)(79), (int)(regAcc), (int)(regHit));
					}

					addrNext = (int)(sqlite3VdbeMakeLabel(pParse));
					sqlite3ExprIfFalse(pParse, pFilter, (int)(addrNext), (int)(0x10));
				}

				if ((pList) != null)
				{
					nArg = (int)(pList.nExpr);
					regAgg = (int)(sqlite3GetTempRange(pParse, (int)(nArg)));
					sqlite3ExprCodeExprList(pParse, pList, (int)(regAgg), (int)(0), (byte)(0x01));
				}
				else
				{
					nArg = (int)(0);
					regAgg = (int)(0);
				}

				if (((pF->iDistinct) >= (0)) && ((pList) != null))
				{
					if ((addrNext) == (0))
					{
						addrNext = (int)(sqlite3VdbeMakeLabel(pParse));
					}

					pF->iDistinct = (int)(codeDistinct(pParse, (int)(eDistinctType), (int)(pF->iDistinct), (int)(addrNext), pList, (int)(regAgg)));
				}

				if ((pF->pFunc.funcFlags & 0x0020) != 0)
				{
					CollSeq pColl = null;
					ExprList_item* pItem;
					int j = 0;

					for (j = (int)(0), pItem = pList.a; (pColl == null) && ((j) < (nArg)); j++, pItem++)
					{
						pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
					}

					if (pColl == null)
					{
						pColl = pParse.db.pDfltColl;
					}

					if (((regHit) == (0)) && ((pAggInfo.nAccumulator) != 0))
						regHit = (int)(++pParse.nMem);
					sqlite3VdbeAddOp4(v, (int)(84), (int)(regHit), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
				}

				sqlite3VdbeAddOp3(v, (int)(161), (int)(0), (int)(regAgg), (int)(pF->iMem));
				sqlite3VdbeAppendP4(v, pF->pFunc, (int)(-8));
				sqlite3VdbeChangeP5(v, (ushort)((byte)(nArg)));
				sqlite3ReleaseTempRange(pParse, (int)(regAgg), (int)(nArg));
				if ((addrNext) != 0)
				{
					sqlite3VdbeResolveLabel(v, (int)(addrNext));
				}
			}

			if (((regHit) == (0)) && ((pAggInfo.nAccumulator) != 0))
			{
				regHit = (int)(regAcc);
			}

			if ((regHit) != 0)
			{
				addrHitTest = (int)(sqlite3VdbeAddOp1(v, (int)(18), (int)(regHit)));
			}

			for (i = (int)(0), pC = pAggInfo.aCol; (i) < (pAggInfo.nAccumulator); i++, pC++)
			{
				sqlite3ExprCode(pParse, pC->pCExpr, (int)(pC->iMem));
			}

			pAggInfo.directMode = (byte)(0);
			if ((addrHitTest) != 0)
			{
				sqlite3VdbeJumpHereOrPopInst(v, (int)(addrHitTest));
			}
		}
		public static void updateFromSelect(Parse pParse, int iEph, Index pPk, ExprList pChanges, SrcList pTabList, Expr pWhere, ExprList pOrderBy, Expr pLimit)
		{
			int i = 0;
			SelectDest dest = new SelectDest();
			Select pSelect = null;
			ExprList pList = null;
			ExprList pGrp = null;
			Expr pLimit2 = null;
			ExprList pOrderBy2 = null;
			sqlite3 db = pParse.db;
			Table pTab = pTabList.a[0].pTab;
			SrcList pSrc;
			Expr pWhere2;
			int eDest = 0;
			(void)(pOrderBy);
			(void)(pLimit);
			pSrc = sqlite3SrcListDup(db, pTabList, (int)(0));
			pWhere2 = sqlite3ExprDup(db, pWhere, (int)(0));

			if ((pSrc) != null)
			{
				pSrc.a[0].fg.notCte = (uint)(1);
				pSrc.a[0].iCursor = (int)(-1);
				pSrc.a[0].pTab.nTabRef--;
				pSrc.a[0].pTab = null;
			}

			if ((pPk) != null)
			{
				for (i = (int)(0); (i) < (pPk.nKeyCol); i++)
				{
					Expr pNew = exprRowColumn(pParse, (int)(pPk.aiColumn[i]));
					pList = sqlite3ExprListAppend(pParse, pList, pNew);
				}

				eDest = (int)((((pTab).eTabType) == (1)) ? 14 : 15);
			}
			else if ((((pTab).eTabType) == (2)))
			{
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, (int)(i)));
				}

				eDest = (int)(14);
			}
			else
			{
				eDest = (int)((((pTab).eTabType) == (1)) ? 14 : 15);
				pList = sqlite3ExprListAppend(pParse, null, sqlite3PExpr(pParse, (int)(75), null, null));
			}


			if ((pChanges) != null)
			{
				for (i = (int)(0); (i) < (pChanges.nExpr); i++)
				{
					pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, pChanges.a[i].pExpr, (int)(0)));
				}
			}

			pSelect = sqlite3SelectNew(pParse, pList, pSrc, pWhere2, pGrp, null, pOrderBy2, (uint)(0x0800000 | 0x0020000), pLimit2);
			if ((pSelect) != null)
				pSelect.selFlags |= (uint)(0x8000000);
			sqlite3SelectDestInit(dest, (int)(eDest), (int)(iEph));
			dest.iSDParm2 = (int)(pPk ? pPk.nKeyCol : -1);
			sqlite3Select(pParse, pSelect, dest);
			sqlite3SelectDelete(db, pSelect);
		}
		public static void updateRangeAffinityStr(Expr pRight, int n, sbyte* zAff)
		{
			int i = 0;
			for (i = (int)(0); (i) < (n); i++)
			{
				Expr p = sqlite3VectorFieldSubexpr(pRight, (int)(i));
				if (((sqlite3CompareAffinity(p, (sbyte)(zAff[i]))) == (0x41)) || ((sqlite3ExprNeedsNoAffinityChange(p, (sbyte)(zAff[i]))) != 0))
				{
					zAff[i] = (sbyte)(0x41);
				}
			}
		}
		public static void updateVirtualTable(Parse pParse, SrcList pSrc, Table pTab, ExprList pChanges, Expr pRowid, int* aXRef, Expr pWhere, int onError)
		{
			Vdbe v = pParse.pVdbe;
			int ephemTab = 0;
			int i = 0;
			sqlite3 db = pParse.db;
			sbyte* pVTab = (sbyte*)(sqlite3GetVTable(db, pTab));
			WhereInfo pWInfo = null;
			int nArg = (int)(2 + pTab.nCol);
			int regArg = 0;
			int regRec = 0;
			int regRowid = 0;
			int iCsr = (int)(pSrc.a[0].iCursor);
			int* aDummy = stackalloc int[2];
			int eOnePass = 0;
			int addr = 0;

			ephemTab = (int)(pParse.nTab++);
			addr = (int)(sqlite3VdbeAddOp2(v, (int)(116), (int)(ephemTab), (int)(nArg)));
			regArg = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nArg);
			if ((pSrc.nSrc) > (1))
			{
				Index pPk = null;
				Expr pRow;
				ExprList pList;
				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					if ((pRowid) != null)
					{
						pRow = sqlite3ExprDup(db, pRowid, (int)(0));
					}
					else
					{
						pRow = sqlite3PExpr(pParse, (int)(75), null, null);
					}
				}
				else
				{
					short iPk = 0;
					pPk = sqlite3PrimaryKeyIndex(pTab);


					iPk = (short)(pPk.aiColumn[0]);
					if ((aXRef[iPk]) >= (0))
					{
						pRow = sqlite3ExprDup(db, pChanges.a[aXRef[iPk]].pExpr, (int)(0));
					}
					else
					{
						pRow = exprRowColumn(pParse, (int)(iPk));
					}
				}

				pList = sqlite3ExprListAppend(pParse, null, pRow);
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{
					if ((aXRef[i]) >= (0))
					{
						pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, pChanges.a[aXRef[i]].pExpr, (int)(0)));
					}
					else
					{
						pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, (int)(i)));
					}
				}

				updateFromSelect(pParse, (int)(ephemTab), pPk, pList, pSrc, pWhere, null, null);
				sqlite3ExprListDelete(db, pList);
				eOnePass = (int)(0);
			}
			else
			{
				regRec = (int)(++pParse.nMem);
				regRowid = (int)(++pParse.nMem);
				pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, null, null, null, (ushort)(0x0004), (int)(0));
				if ((pWInfo) == (null))
					return;
				for (i = (int)(0); (i) < (pTab.nCol); i++)
				{

					if ((aXRef[i]) >= (0))
					{
						sqlite3ExprCode(pParse, pChanges.a[aXRef[i]].pExpr, (int)(regArg + 2 + i));
					}
					else
					{
						sqlite3VdbeAddOp3(v, (int)(174), (int)(iCsr), (int)(i), (int)(regArg + 2 + i));
						sqlite3VdbeChangeP5(v, (ushort)(0x01));
					}
				}

				if ((((pTab).tabFlags & 0x00000080) == (0)))
				{
					sqlite3VdbeAddOp2(v, (int)(134), (int)(iCsr), (int)(regArg));
					if ((pRowid) != null)
					{
						sqlite3ExprCode(pParse, pRowid, (int)(regArg + 1));
					}
					else
					{
						sqlite3VdbeAddOp2(v, (int)(134), (int)(iCsr), (int)(regArg + 1));
					}
				}
				else
				{
					Index pPk;
					short iPk = 0;
					pPk = sqlite3PrimaryKeyIndex(pTab);


					iPk = (short)(pPk.aiColumn[0]);
					sqlite3VdbeAddOp3(v, (int)(174), (int)(iCsr), (int)(iPk), (int)(regArg));
					sqlite3VdbeAddOp2(v, (int)(80), (int)(regArg + 2 + iPk), (int)(regArg + 1));
				}

				eOnePass = (int)(sqlite3WhereOkOnePass(pWInfo, aDummy));

				if ((eOnePass) != 0)
				{
					sqlite3VdbeChangeToNoop(v, (int)(addr));
					sqlite3VdbeAddOp1(v, (int)(121), (int)(iCsr));
				}
				else
				{
					sqlite3MultiWrite(pParse);
					sqlite3VdbeAddOp3(v, (int)(96), (int)(regArg), (int)(nArg), (int)(regRec));
					sqlite3VdbeAddOp2(v, (int)(126), (int)(ephemTab), (int)(regRowid));
					sqlite3VdbeAddOp3(v, (int)(127), (int)(ephemTab), (int)(regRec), (int)(regRowid));
				}
			}

			if ((eOnePass) == (0))
			{
				if ((pSrc.nSrc) == (1))
				{
					sqlite3WhereEnd(pWInfo);
				}

				addr = (int)(sqlite3VdbeAddOp1(v, (int)(38), (int)(ephemTab)));
				for (i = (int)(0); (i) < (nArg); i++)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(ephemTab), (int)(i), (int)(regArg + i));
				}
			}

			sqlite3VtabMakeWritable(pParse, pTab);
			sqlite3VdbeAddOp4(v, (int)(10), (int)(0), (int)(nArg), (int)(regArg), pVTab, (int)(-12));
			sqlite3VdbeChangeP5(v, (ushort)((onError) == (11) ? 2 : onError));
			sqlite3MayAbort(pParse);
			if ((eOnePass) == (0))
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(ephemTab), (int)(addr + 1));
				sqlite3VdbeJumpHere(v, (int)(addr));
				sqlite3VdbeAddOp2(v, (int)(121), (int)(ephemTab), (int)(0));
			}
			else
			{
				sqlite3WhereEnd(pWInfo);
			}
		}
		public static void upperFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			sbyte* z1;
			sbyte* z2;
			int i = 0; int n = 0;

			z2 = (sbyte*)(sqlite3_value_text(argv[0]));
			n = (int)(sqlite3_value_bytes(argv[0]));

			if ((z2) != null)
			{
				z1 = contextMalloc(context, (long)(((long)(n)) + 1));
				if ((z1) != null)
				{
					for (i = (int)(0); (i) < (n); i++)
					{
						z1[i] = ((sbyte)((z2[i]) & ~(sqlite3CtypeMap[(byte)(z2[i])] & 0x20)));
					}

					sqlite3_result_text(context, z1, (int)(n), sqlite3_free);
				}
			}
		}
		public static void upsertDelete(sqlite3 db, Upsert p)
		{
			do
			{
				Upsert pNext = p.pNextUpsert;
				sqlite3ExprListDelete(db, p.pUpsertTarget);
				sqlite3ExprDelete(db, p.pUpsertTargetWhere);
				sqlite3ExprListDelete(db, p.pUpsertSet);
				sqlite3ExprDelete(db, p.pUpsertWhere);
				sqlite3DbFree(db, p.pToFree);
				sqlite3DbFree(db, p);
				p = pNext;
			}
			while ((p) != null);
		}
		public static sbyte* uriParameter(sbyte* zFilename, sbyte* zParam)
		{
			zFilename += sqlite3Strlen30(zFilename) + 1;
			while ((zFilename != null) && ((zFilename[0]) != 0))
			{
				int x = (int)(CRuntime.strcmp(zFilename, zParam));
				zFilename += sqlite3Strlen30(zFilename) + 1;
				if ((x) == (0))
					return zFilename;
				zFilename += sqlite3Strlen30(zFilename) + 1;
			}

			return null;
		}
		public static int validJulianDay(long iJD)
		{
			return (((iJD) >= (0)) && ((iJD) <= ((((long)(0x1a640)) << 32) | 0x1072fdff)) ? 1 : 0);
		}
		public static int valueBytes(sqlite3_value pVal, byte enc)
		{
			return (int)(valueToText(pVal, (byte)(enc)) != null ? pVal.n : 0);
		}
		public static int valueFromExpr(sqlite3 db, Expr pExpr, byte enc, byte affinity, sqlite3_value ppVal, ValueNewStat4Ctx pCtx)
		{
			int op = 0;
			sbyte* zVal = null;
			sqlite3_value pVal = null;
			int negInt = (int)(1);
			sbyte* zNeg = "";
			int rc = (int)(0);

			while (((op = (int)(pExpr.op)) == (174)) || ((op) == (181)))
			{
				pExpr = pExpr.pLeft;
			}

			if ((op) == (176))
				op = (int)(pExpr.op2);

			if ((op) == (36))
			{
				byte aff = 0;

				aff = (byte)(sqlite3AffinityType(pExpr.u.zToken, null));
				rc = (int)(valueFromExpr(db, pExpr.pLeft, (byte)(enc), (byte)(aff), ppVal, pCtx));
				if ((ppVal) != null)
				{
					sqlite3VdbeMemCast(ppVal, (byte)(aff), (byte)(1));
					sqlite3ValueApplyAffinity(ppVal, (byte)(affinity), (byte)(1));
				}

				return (int)(rc);
			}

			if (((op) == (173)) && (((pExpr.pLeft.op) == (155)) || ((pExpr.pLeft.op) == (153))))
			{
				pExpr = pExpr.pLeft;
				op = (int)(pExpr.op);
				negInt = (int)(-1);
				zNeg = "-";
			}

			if ((((op) == (117)) || ((op) == (153))) || ((op) == (155)))
			{
				pVal = valueNew(db, pCtx);
				if ((pVal) == (null))
					goto no_mem;
				if ((((pExpr).flags & (0x000400)) != 0))
				{
					sqlite3VdbeMemSetInt64(pVal, (long)((long)(pExpr.u.iValue) * negInt));
				}
				else
				{
					zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr.u.zToken);
					if ((zVal) == (null))
						goto no_mem;
					sqlite3ValueSetStr(pVal, (int)(-1), zVal, (byte)(1), ((Void(Void * ))(sqlite3OomFault)));
				}

				if ((((op) == (155)) || ((op) == (153))) && ((affinity) == (0x41)))
				{
					sqlite3ValueApplyAffinity(pVal, (byte)(0x43), (byte)(1));
				}
				else
				{
					sqlite3ValueApplyAffinity(pVal, (byte)(affinity), (byte)(1));
				}


				if ((pVal.flags & (0x0004 | 0x0020 | 0x0008)) != 0)
				{
					pVal.flags &= (ushort)(~0x0002);
				}

				if (enc != 1)
				{
					rc = (int)(sqlite3VdbeChangeEncoding(pVal, (int)(enc)));
				}
			}
			else if ((op) == (173))
			{
				if (((0) == (valueFromExpr(db, pExpr.pLeft, (byte)(enc), (byte)(affinity), pVal, pCtx))) && (pVal != null))
				{
					sqlite3VdbeMemNumerify(pVal);
					if ((pVal.flags & 0x0008) != 0)
					{
						pVal.u.r = (double)(-pVal.u.r);
					}
					else if ((pVal.u.i) == (((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))))
					{
						pVal.u.r = (double)(-(double)(((long)(-1)) - (0xffffffff | (((long)(0x7fffffff)) << 32))));
						((pVal).flags = (ushort)(((pVal).flags & ~(0xc1bf | 0x4000)) | 0x0008));
					}
					else
					{
						pVal.u.i = (long)(-pVal.u.i);
					}

					sqlite3ValueApplyAffinity(pVal, (byte)(affinity), (byte)(enc));
				}
			}
			else if ((op) == (121))
			{
				pVal = valueNew(db, pCtx);
				if ((pVal) == (null))
					goto no_mem;
				sqlite3VdbeMemSetNull(pVal);
			}
			else if ((op) == (154))
			{
				int nVal = 0;



				pVal = valueNew(db, pCtx);
				if (pVal == null)
					goto no_mem;
				zVal = &pExpr.u.zToken[2];
				nVal = (int)(sqlite3Strlen30(zVal) - 1);

				sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, (int)(nVal)), (long)(nVal / 2), (byte)(0), ((Void(Void * ))(sqlite3OomFault)));
			}
			else if ((op) == (170))
			{

				pVal = valueNew(db, pCtx);
				if ((pVal) != null)
				{
					pVal.flags = (ushort)(0x0004);
					pVal.u.i = (long)((pExpr.u.zToken[4]) == (0));
				}
			}

			ppVal = pVal;
			return (int)(rc);
		no_mem:
			; sqlite3OomFault(db);
			sqlite3DbFree(db, zVal);


			sqlite3ValueFree(pVal);
			return (int)(7);
		}
		public static int valueFromValueList(sqlite3_value pVal, sqlite3_value ppOut, int bNext)
		{
			int rc = 0;
			ValueList pRhs;
			ppOut = null;
			if ((pVal) == (null))
				return (int)(21);
			pRhs = (ValueList)(sqlite3_value_pointer(pVal, "ValueList"));
			if ((pRhs) == (null))
				return (int)(21);
			if ((bNext) != 0)
			{
				rc = (int)(sqlite3BtreeNext(pRhs.pCsr, (int)(0)));
			}
			else
			{
				int dummy = (int)(0);
				rc = (int)(sqlite3BtreeFirst(pRhs.pCsr, &dummy));

				if ((sqlite3BtreeEof(pRhs.pCsr)) != 0)
					rc = (int)(101);
			}

			if ((rc) == (0))
			{
				uint sz = 0;
				sqlite3_value sMem = new sqlite3_value();
				CRuntime.memset(sMem, (int)(0), (ulong)(sizeof(sqlite3_value)));
				sz = (uint)(sqlite3BtreePayloadSize(pRhs.pCsr));
				rc = (int)(sqlite3VdbeMemFromBtreeZeroOffset(pRhs.pCsr, (uint)((int)(sz)), sMem));
				if ((rc) == (0))
				{
					byte* zBuf = (byte*)(sMem.z);
					uint iSerial = 0;
					sqlite3_value pOut = pRhs.pOut;
					int iOff = (int)(1 + (byte)(((*(&zBuf[1])) < ((byte)(0x80))) ? ((iSerial) = ((uint)(*(&zBuf[1])))), 1 : 
            sqlite3GetVarint32((&zBuf[1]), &(iSerial)) ) )
            ;
					sqlite3VdbeSerialGet(&zBuf[iOff], (uint)(iSerial), pOut);
					pOut.enc = (byte)((pOut.db).enc);
					if (((pOut.flags & 0x1000) != 0) && ((sqlite3VdbeMemMakeWriteable(pOut)) != 0))
					{
						rc = (int)(7);
					}
					else
					{
						ppOut = pOut;
					}
				}

				sqlite3VdbeMemRelease(sMem);
			}

			return (int)(rc);
		}
		public static sqlite3_value valueNew(sqlite3 db, ValueNewStat4Ctx p)
		{
			(void)(p);
			return sqlite3ValueNew(db);
		}
		public static void* valueToText(sqlite3_value pVal, byte enc)
		{





			if ((pVal.flags & (0x0010 | 0x0002)) != 0)
			{
				if ((((pVal).flags & 0x4000) ? sqlite3VdbeMemExpandBlob(pVal) : 0) != 0)
					return null;
				pVal.flags |= (ushort)(0x0002);
				if (pVal.enc != (enc & ~8))
				{
					sqlite3VdbeChangeEncoding(pVal, (int)(enc & ~8));
				}

				if (((enc & 8) != 0) && ((1) == (1 & ((int)((long)(pVal.z))))))
				{

					if (sqlite3VdbeMemMakeWriteable(pVal) != 0)
					{
						return null;
					}
				}

				sqlite3VdbeMemNulTerminate(pVal);
			}
			else
			{
				sqlite3VdbeMemStringify(pVal, (byte)(enc), (byte)(0));

			}


			if ((pVal.enc) == (enc & ~8))
			{

				return pVal.z;
			}
			else
			{
				return null;
			}
		}
		public static void vdbeChangeP4Full(Vdbe p, VdbeOp* pOp, sbyte* zP4, int n)
		{
			if ((pOp->p4type) != 0)
			{
				freeP4(p.db, (int)(pOp->p4type), pOp->p4.p);
				pOp->p4type = (sbyte)(0);
				pOp->p4.p = null;
			}

			if ((n) < (0))
			{
				sqlite3VdbeChangeP4(p, (int)(pOp - p.aOp), zP4, (int)(n));
			}
			else
			{
				if ((n) == (0))
					n = (int)(sqlite3Strlen30(zP4));
				pOp->p4.z = sqlite3DbStrNDup(p.db, zP4, (ulong)(n));
				pOp->p4type = (sbyte)(-7);
			}
		}
		public static int vdbeCloseStatement(Vdbe p, int eOp)
		{
			sqlite3 db = p.db;
			int rc = (int)(0);
			int i = 0;
			int iSavepoint = (int)(p.iStatement - 1);



			for (i = (int)(0); (i) < (db.nDb); i++)
			{
				int rc2 = (int)(0);
				Btree pBt = db.aDb[i].pBt;
				if ((pBt) != null)
				{
					if ((eOp) == (2))
					{
						rc2 = (int)(sqlite3BtreeSavepoint(pBt, (int)(2), (int)(iSavepoint)));
					}

					if ((rc2) == (0))
					{
						rc2 = (int)(sqlite3BtreeSavepoint(pBt, (int)(1), (int)(iSavepoint)));
					}

					if ((rc) == (0))
					{
						rc = (int)(rc2);
					}
				}
			}

			db.nStatement--;
			p.iStatement = (int)(0);
			if ((rc) == (0))
			{
				if ((eOp) == (2))
				{
					rc = (int)(sqlite3VtabSavepoint(db, (int)(2), (int)(iSavepoint)));
				}

				if ((rc) == (0))
				{
					rc = (int)(sqlite3VtabSavepoint(db, (int)(1), (int)(iSavepoint)));
				}
			}

			if ((eOp) == (2))
			{
				db.nDeferredCons = (long)(p.nStmtDefCons);
				db.nDeferredImmCons = (long)(p.nStmtDefImmCons);
			}

			return (int)(rc);
		}
		public static void vdbeClrCopy(sqlite3_value pTo, sqlite3_value pFrom, int eType)
		{
			vdbeMemClearExternAndSetNull(pTo);

			sqlite3VdbeMemShallowCopy(pTo, pFrom, (int)(eType));
		}
		public static int vdbeCommit(sqlite3 db, Vdbe p)
		{
			int i = 0;
			int nTrans = (int)(0);
			int rc = (int)(0);
			int needXcommit = (int)(0);
			rc = (int)(sqlite3VtabSync(db, p));
			for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
			{
				Btree pBt = db.aDb[i].pBt;
				if ((sqlite3BtreeTxnState(pBt)) == (2))
				{
					Pager pPager;
					needXcommit = (int)(1);
					sqlite3BtreeEnter(pBt);
					pPager = sqlite3BtreePager(pBt);
					if (((db.aDb[i].safety_level != 0x01) && ((vdbeCommit_aMJNeeded[sqlite3PagerGetJournalMode(pPager)]) != 0)) && ((sqlite3PagerIsMemdb(pPager)) == (0)))
					{

						nTrans++;
					}

					rc = (int)(sqlite3PagerExclusiveLock(pPager));
					sqlite3BtreeLeave(pBt);
				}
			}

			if (rc != 0)
			{
				return (int)(rc);
			}

			if (((needXcommit) != 0) && ((db.xCommitCallback) != null))
			{
				rc = (int)(db.xCommitCallback(db.pCommitArg));
				if ((rc) != 0)
				{
					return (int)(19 | (2 << 8));
				}
			}

			if (((0) == (sqlite3Strlen30(sqlite3BtreeGetFilename(db.aDb[0].pBt)))) || ((nTrans) <= (1)))
			{
				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeCommitPhaseOne(pBt, null));
					}
				}

				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeCommitPhaseTwo(pBt, (int)(0)));
					}
				}

				if ((rc) == (0))
				{
					sqlite3VtabCommit(db);
				}
			}
			else
			{
				sqlite3_vfs pVfs = db.pVfs;
				sbyte* zSuper = null;
				sbyte* zMainFile = sqlite3BtreeGetFilename(db.aDb[0].pBt);
				sqlite3_file pSuperJrnl = null;
				long offset = (long)(0);
				int res = 0;
				int retryCount = (int)(0);
				int nMainFile = 0;
				nMainFile = (int)(sqlite3Strlen30(zMainFile));
				zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", (int)(0), zMainFile, (int)(0));
				if ((zSuper) == (null))
					return (int)(7);
				zSuper += 4;
				do
				{
					uint iRandom = 0;
					if ((retryCount) != 0)
					{
						if ((retryCount) > (100))
						{
							sqlite3_log((int)(13), "MJ delete: %s", zSuper);
							sqlite3OsDelete(pVfs, zSuper, (int)(0));
							break;
						}
						else if ((retryCount) == (1))
						{
							sqlite3_log((int)(13), "MJ collide: %s", zSuper);
						}
					}

					retryCount++;
					sqlite3_randomness((int)(sizeof(uint)), &iRandom);
					sqlite3_snprintf((int)(13), &zSuper[nMainFile], "-mj%06X9%02X", (uint)((iRandom >> 8) & 0xffffff), (uint)(iRandom & 0xff));

					rc = (int)(sqlite3OsAccess(pVfs, zSuper, (int)(0), &res));
				}
				while (((rc) == (0)) && ((res) != 0));
				if ((rc) == (0))
				{
					rc = (int)(sqlite3OsOpenMalloc(pVfs, zSuper, pSuperJrnl, (int)(0x00000002 | 0x00000004 | 0x00000010 | 0x00004000), null));
				}

				if (rc != 0)
				{
					sqlite3DbFree(db, zSuper - 4);
					return (int)(rc);
				}

				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((sqlite3BtreeTxnState(pBt)) == (2))
					{
						sbyte* zFile = sqlite3BtreeGetJournalname(pBt);
						if ((zFile) == (null))
						{
							continue;
						}


						rc = (int)(sqlite3OsWrite(pSuperJrnl, zFile, (int)(sqlite3Strlen30(zFile) + 1), (long)(offset)));
						offset += (long)(sqlite3Strlen30(zFile) + 1);
						if (rc != 0)
						{
							sqlite3OsCloseFree(pSuperJrnl);
							sqlite3OsDelete(pVfs, zSuper, (int)(0));
							sqlite3DbFree(db, zSuper - 4);
							return (int)(rc);
						}
					}
				}

				if (((0) == (sqlite3OsDeviceCharacteristics(pSuperJrnl) & 0x00000400)) && (0 != (rc = (int)(sqlite3OsSync(pSuperJrnl, (int)(0x00002))))))
				{
					sqlite3OsCloseFree(pSuperJrnl);
					sqlite3OsDelete(pVfs, zSuper, (int)(0));
					sqlite3DbFree(db, zSuper - 4);
					return (int)(rc);
				}

				for (i = (int)(0); ((rc) == (0)) && ((i) < (db.nDb)); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						rc = (int)(sqlite3BtreeCommitPhaseOne(pBt, zSuper));
					}
				}

				sqlite3OsCloseFree(pSuperJrnl);

				if (rc != 0)
				{
					sqlite3DbFree(db, zSuper - 4);
					return (int)(rc);
				}

				rc = (int)(sqlite3OsDelete(pVfs, zSuper, (int)(1)));
				sqlite3DbFree(db, zSuper - 4);
				zSuper = null;
				if ((rc) != 0)
				{
					return (int)(rc);
				}

				sqlite3BeginBenignMalloc();
				for (i = (int)(0); (i) < (db.nDb); i++)
				{
					Btree pBt = db.aDb[i].pBt;
					if ((pBt) != null)
					{
						sqlite3BtreeCommitPhaseTwo(pBt, (int)(1));
					}
				}

				sqlite3EndBenignMalloc();
				sqlite3VtabCommit(db);
			}

			return (int)(rc);
		}
		public static int vdbeCompareMemString(sqlite3_value pMem1, sqlite3_value pMem2, CollSeq pColl, byte* prcErr)
		{
			if ((pMem1.enc) == (pColl.enc))
			{
				return (int)(pColl.xCmp(pColl.pUser, (int)(pMem1.n), pMem1.z, (int)(pMem2.n), pMem2.z));
			}
			else
			{
				int rc = 0;
				void* v1;
				void* v2;
				sqlite3_value c1 = new sqlite3_value();
				sqlite3_value c2 = new sqlite3_value();
				sqlite3VdbeMemInit(c1, pMem1.db, (ushort)(0x0001));
				sqlite3VdbeMemInit(c2, pMem1.db, (ushort)(0x0001));
				sqlite3VdbeMemShallowCopy(c1, pMem1, (int)(0x1000));
				sqlite3VdbeMemShallowCopy(c2, pMem2, (int)(0x1000));
				v1 = sqlite3ValueText(c1, (byte)(pColl.enc));
				v2 = sqlite3ValueText(c2, (byte)(pColl.enc));
				if ((((v1) == (null)) || ((v2) == (null))))
				{
					if ((prcErr) != null)
						*prcErr = (byte)(7);
					rc = (int)(0);
				}
				else
				{
					rc = (int)(pColl.xCmp(pColl.pUser, (int)(c1.n), v1, (int)(c2.n), v2));
				}

				sqlite3VdbeMemRelease(c1);
				sqlite3VdbeMemRelease(c2);
				return (int)(rc);
			}
		}
		public static void vdbeFreeOpArray(sqlite3 db, VdbeOp* aOp, int nOp)
		{
			if ((aOp) != null)
			{
				VdbeOp* pOp;
				for (pOp = &aOp[nOp - 1]; (pOp) >= (aOp); pOp--)
				{
					if ((pOp->p4type) <= (-7))
						freeP4(db, (int)(pOp->p4type), pOp->p4.p);
				}

				sqlite3DbFreeNN(db, aOp);
			}
		}
		public static int vdbeIncrBgPopulate(IncrMerger pIncr)
		{
			void* p = (void*)(pIncr);

			return (int)(vdbeSorterCreateThread(pIncr.pTask, vdbeIncrPopulateThread, p));
		}
		public static void vdbeIncrFree(IncrMerger pIncr)
		{
			if ((pIncr) != null)
			{
				if ((pIncr.bUseThread) != 0)
				{
					vdbeSorterJoinThread(pIncr.pTask);
					if ((pIncr.aFile[0].pFd) != null)
						sqlite3OsCloseFree(pIncr.aFile[0].pFd);
					if ((pIncr.aFile[1].pFd) != null)
						sqlite3OsCloseFree(pIncr.aFile[1].pFd);
				}

				vdbeMergeEngineFree(pIncr.pMerger);
				sqlite3_free(pIncr);
			}
		}
		public static int vdbeIncrMergerNew(SortSubtask pTask, MergeEngine pMerger, IncrMerger ppOut)
		{
			int rc = (int)(0);
			IncrMerger pIncr = ppOut = (IncrMerger)((sqlite3FaultSim((int)(100))) != 0 ? null : sqlite3MallocZero((ulong)(sizeof(IncrMerger))));
			if ((pIncr) != null)
			{
				pIncr.pMerger = pMerger;
				pIncr.pTask = pTask;
				pIncr.mxSz = (int)((pTask.pSorter.mxKeysize + 9) > (pTask.pSorter.mxPmaSize / 2) ? (pTask.pSorter.mxKeysize + 9) : (pTask.pSorter.mxPmaSize / 2));
				pTask.file2.iEof += (long)(pIncr.mxSz);
			}
			else
			{
				vdbeMergeEngineFree(pMerger);
				rc = (int)(7);
			}


			return (int)(rc);
		}
		public static void vdbeIncrMergerSetThreads(IncrMerger pIncr)
		{
			pIncr.bUseThread = (int)(1);
			pIncr.pTask.file2.iEof -= (long)(pIncr.mxSz);
		}
		public static int vdbeIncrPopulate(IncrMerger pIncr)
		{
			int rc = (int)(0);
			int rc2 = 0;
			long iStart = (long)(pIncr.iStartOff);
			SorterFile pOut = pIncr.aFile[1];
			SortSubtask pTask = pIncr.pTask;
			MergeEngine pMerger = pIncr.pMerger;
			PmaWriter writer = new PmaWriter();

			vdbePmaWriterInit(pOut.pFd, writer, (int)(pTask.pSorter.pgsz), (long)(iStart));
			while ((rc) == (0))
			{
				int dummy = 0;
				PmaReader pReader = pMerger.aReadr[pMerger.aTree[1]];
				int nKey = (int)(pReader.nKey);
				long iEof = (long)(writer.iWriteOff + writer.iBufEnd);
				if ((pReader.pFd) == (null))
					break;
				if ((iEof + nKey + sqlite3VarintLen((ulong)(nKey))) > (iStart + pIncr.mxSz))
					break;
				vdbePmaWriteVarint(writer, (ulong)(nKey));
				vdbePmaWriteBlob(writer, pReader.aKey, (int)(nKey));

				rc = (int)(vdbeMergeEngineStep(pIncr.pMerger, &dummy));
			}

			rc2 = (int)(vdbePmaWriterFinish(writer, &pOut.iEof));
			if ((rc) == (0))
				rc = (int)(rc2);
			return (int)(rc);
		}
		public static void* vdbeIncrPopulateThread(void* pCtx)
		{
			IncrMerger pIncr = (IncrMerger)(pCtx);
			void* pRet = ((void*)((long)(vdbeIncrPopulate(pIncr))));
			pIncr.pTask.bDone = (int)(1);
			return pRet;
		}
		public static int vdbeIncrSwap(IncrMerger pIncr)
		{
			int rc = (int)(0);
			if ((pIncr.bUseThread) != 0)
			{
				rc = (int)(vdbeSorterJoinThread(pIncr.pTask));
				if ((rc) == (0))
				{
					SorterFile f0 = (SorterFile)(pIncr.aFile[0]);
					pIncr.aFile[0] = (SorterFile)(pIncr.aFile[1]);
					pIncr.aFile[1] = (SorterFile)(f0);
				}

				if ((rc) == (0))
				{
					if ((pIncr.aFile[0].iEof) == (pIncr.iStartOff))
					{
						pIncr.bEof = (int)(1);
					}
					else
					{
						rc = (int)(vdbeIncrBgPopulate(pIncr));
					}
				}
			}
			else
			{
				rc = (int)(vdbeIncrPopulate(pIncr));
				pIncr.aFile[0] = (SorterFile)(pIncr.aFile[1]);
				if ((pIncr.aFile[0].iEof) == (pIncr.iStartOff))
				{
					pIncr.bEof = (int)(1);
				}
			}

			return (int)(rc);
		}
		public static void vdbeLeave(Vdbe p)
		{
			int i = 0;
			sqlite3 db;
			Db aDb;
			int nDb = 0;
			db = p.db;
			aDb = db.aDb;
			nDb = (int)(db.nDb);
			for (i = (int)(0); (i) < (nDb); i++)
			{
				if (((i != 1) && (((p.lockMask) & (((uint)(1)) << (i))) != 0)) && (aDb[i].pBt != null))
				{
					sqlite3BtreeLeave(aDb[i].pBt);
				}
			}
		}
		public static int vdbeMemAddTerminator(sqlite3_value pMem)
		{
			if ((sqlite3VdbeMemGrow(pMem, (int)(pMem.n + 3), (int)(1))) != 0)
			{
				return (int)(7);
			}

			pMem.z[pMem.n] = (sbyte)(0);
			pMem.z[pMem.n + 1] = (sbyte)(0);
			pMem.z[pMem.n + 2] = (sbyte)(0);
			pMem.flags |= (ushort)(0x0200);
			return (int)(0);
		}
		public static void vdbeMemClear(sqlite3_value p)
		{
			if ((((p).flags & (0x2000 | 0x0400)) != 0))
			{
				vdbeMemClearExternAndSetNull(p);
			}

			if ((p.szMalloc) != 0)
			{
				sqlite3DbFreeNN(p.db, p.zMalloc);
				p.szMalloc = (int)(0);
			}

			p.z = null;
		}
		public static void vdbeMemClearExternAndSetNull(sqlite3_value p)
		{


			if ((p.flags & 0x2000) != 0)
			{
				sqlite3VdbeMemFinalize(p, p.u.pDef);

			}

			if ((p.flags & 0x0400) != 0)
			{

				p.xDel((void*)(p.z));
			}

			p.flags = (ushort)(0x0001);
		}
		public static void vdbeMemRenderNum(int sz, sbyte* zBuf, sqlite3_value p)
		{
			sqlite3_str acc = new sqlite3_str();


			if ((p.flags & 0x0004) != 0)
			{
				sqlite3Int64ToText((long)(p.u.i), zBuf);
			}
			else
			{
				sqlite3StrAccumInit(acc, null, zBuf, (int)(sz), (int)(0));
				sqlite3_str_appendf(acc, "%!.15g", (double)((p.flags & 0x0020) != 0 ? (double)(p.u.i) : p.u.r));

				zBuf[acc.nChar] = (sbyte)(0);
			}
		}
		public static sbyte* vdbeMemTypeName(sqlite3_value pMem)
		{
			return vdbeMemTypeName_azTypes[sqlite3_value_type(pMem) - 1];
		}
		public static void vdbeMergeEngineCompare(MergeEngine pMerger, int iOut)
		{
			int i1 = 0;
			int i2 = 0;
			int iRes = 0;
			PmaReader p1;
			PmaReader p2;

			if ((iOut) >= (pMerger.nTree / 2))
			{
				i1 = (int)((iOut - pMerger.nTree / 2) * 2);
				i2 = (int)(i1 + 1);
			}
			else
			{
				i1 = (int)(pMerger.aTree[iOut * 2]);
				i2 = (int)(pMerger.aTree[iOut * 2 + 1]);
			}

			p1 = pMerger.aReadr[i1];
			p2 = pMerger.aReadr[i2];
			if ((p1.pFd) == (null))
			{
				iRes = (int)(i2);
			}
			else if ((p2.pFd) == (null))
			{
				iRes = (int)(i1);
			}
			else
			{
				SortSubtask pTask = pMerger.pTask;
				int bCached = (int)(0);
				int res = 0;

				res = (int)(pTask.xCompare(pTask, &bCached, p1.aKey, (int)(p1.nKey), p2.aKey, (int)(p2.nKey)));
				if ((res) <= (0))
				{
					iRes = (int)(i1);
				}
				else
				{
					iRes = (int)(i2);
				}
			}

			pMerger.aTree[iOut] = (int)(iRes);
		}
		public static void vdbeMergeEngineFree(MergeEngine pMerger)
		{
			int i = 0;
			if ((pMerger) != null)
			{
				for (i = (int)(0); (i) < (pMerger.nTree); i++)
				{
					vdbePmaReaderClear(pMerger.aReadr[i]);
				}
			}

			sqlite3_free(pMerger);
		}
		public static int vdbeMergeEngineInit(SortSubtask pTask, MergeEngine pMerger, int eMode)
		{
			int rc = (int)(0);
			int i = 0;
			int nTree = 0;



			pMerger.pTask = pTask;
			nTree = (int)(pMerger.nTree);
			for (i = (int)(0); (i) < (nTree); i++)
			{
				if (((8) > (0)) && ((eMode) == (2)))
				{
					rc = (int)(vdbePmaReaderNext(pMerger.aReadr[nTree - i - 1]));
				}
				else
				{
					rc = (int)(vdbePmaReaderIncrInit(pMerger.aReadr[i], (int)(0)));
				}

				if (rc != 0)
					return (int)(rc);
			}

			for (i = (int)(pMerger.nTree - 1); (i) > (0); i--)
			{
				vdbeMergeEngineCompare(pMerger, (int)(i));
			}

			return (int)(pTask.pUnpacked.errCode);
		}
		public static int vdbeMergeEngineLevel0(SortSubtask pTask, int nPMA, long* piOffset, MergeEngine ppOut)
		{
			MergeEngine pNew;
			long iOff = (long)(*piOffset);
			int i = 0;
			int rc = (int)(0);
			ppOut = pNew = vdbeMergeEngineNew((int)(nPMA));
			if ((pNew) == (null))
				rc = (int)(7);
			for (i = (int)(0); ((i) < (nPMA)) && ((rc) == (0)); i++)
			{
				long nDummy = (long)(0);
				PmaReader pReadr = pNew.aReadr[i];
				rc = (int)(vdbePmaReaderInit(pTask, pTask.file, (long)(iOff), pReadr, &nDummy));
				iOff = (long)(pReadr.iEof);
			}

			if (rc != 0)
			{
				vdbeMergeEngineFree(pNew);
				ppOut = null;
			}

			*piOffset = (long)(iOff);
			return (int)(rc);
		}
		public static MergeEngine vdbeMergeEngineNew(int nReader)
		{
			int N = (int)(2);
			int nByte = 0;
			MergeEngine pNew;

			while ((N) < (nReader))
			{
				N += (int)(N);
			}

			nByte = (int)(sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader)));
			pNew = (sqlite3FaultSim((int)(100))) != 0 ? null : (MergeEngine)(sqlite3MallocZero((ulong)(nByte)));
			if ((pNew) != null)
			{
				pNew.nTree = (int)(N);
				pNew.pTask = null;
				pNew.aReadr = (PmaReader)(pNew[1]);
				pNew.aTree = (int*)(pNew.aReadr[N]);
			}

			return pNew;
		}
		public static int vdbeMergeEngineStep(MergeEngine pMerger, int* pbEof)
		{
			int rc = 0;
			int iPrev = (int)(pMerger.aTree[1]);
			SortSubtask pTask = pMerger.pTask;
			rc = (int)(vdbePmaReaderNext(pMerger.aReadr[iPrev]));
			if ((rc) == (0))
			{
				int i = 0;
				PmaReader pReadr1;
				PmaReader pReadr2;
				int bCached = (int)(0);
				pReadr1 = pMerger.aReadr[(iPrev & 0xFFFE)];
				pReadr2 = pMerger.aReadr[(iPrev | 0x0001)];
				for (i = (int)((pMerger.nTree + iPrev) / 2); (i) > (0); i = (int)(i / 2))
				{
					int iRes = 0;
					if ((pReadr1.pFd) == (null))
					{
						iRes = (int)(+1);
					}
					else if ((pReadr2.pFd) == (null))
					{
						iRes = (int)(-1);
					}
					else
					{
						iRes = (int)(pTask.xCompare(pTask, &bCached, pReadr1.aKey, (int)(pReadr1.nKey), pReadr2.aKey, (int)(pReadr2.nKey)));
					}

					if (((iRes) < (0)) || (((iRes) == (0)) && ((pReadr1) < (pReadr2))))
					{
						pMerger.aTree[i] = ((int)(pReadr1 - pMerger.aReadr));
						pReadr2 = pMerger.aReadr[pMerger.aTree[i ^ 0x0001]];
						bCached = (int)(0);
					}
					else
					{
						if ((pReadr1.pFd) != null)
							bCached = (int)(0);
						pMerger.aTree[i] = ((int)(pReadr2 - pMerger.aReadr));
						pReadr1 = pMerger.aReadr[pMerger.aTree[i ^ 0x0001]];
					}
				}

				*pbEof = (int)((pMerger.aReadr[pMerger.aTree[1]].pFd) == (null) ? 1 : 0);
			}

			return (int)((rc) == (0) ? pTask.pUnpacked.errCode : rc);
		}
		public static int vdbePmaReadBlob(PmaReader p, int nByte, byte** ppOut)
		{
			int iBuf = 0;
			int nAvail = 0;
			if ((p.aMap) != null)
			{
				*ppOut = &p.aMap[p.iReadOff];
				p.iReadOff += (long)(nByte);
				return (int)(0);
			}


			iBuf = (int)(p.iReadOff % p.nBuffer);
			if ((iBuf) == (0))
			{
				int nRead = 0;
				int rc = 0;
				if ((p.iEof - p.iReadOff) > ((long)(p.nBuffer)))
				{
					nRead = (int)(p.nBuffer);
				}
				else
				{
					nRead = ((int)(p.iEof - p.iReadOff));
				}


				rc = (int)(sqlite3OsRead(p.pFd, p.aBuffer, (int)(nRead), (long)(p.iReadOff)));

				if (rc != 0)
					return (int)(rc);
			}

			nAvail = (int)(p.nBuffer - iBuf);
			if ((nByte) <= (nAvail))
			{
				*ppOut = &p.aBuffer[iBuf];
				p.iReadOff += (long)(nByte);
			}
			else
			{
				int nRem = 0;
				if ((p.nAlloc) < (nByte))
				{
					byte* aNew;
					long nNew = (long)((128) > (2 * (long)(p.nAlloc)) ? (128) : (2 * (long)(p.nAlloc)));
					while ((nByte) > (nNew))
					{
						nNew = (long)(nNew * 2);
					}

					aNew = sqlite3Realloc(p.aAlloc, (ulong)(nNew));
					if (aNew == null)
						return (int)(7);
					p.nAlloc = (int)(nNew);
					p.aAlloc = aNew;
				}

				CRuntime.memcpy(p.aAlloc, &p.aBuffer[iBuf], (ulong)(nAvail));
				p.iReadOff += (long)(nAvail);
				nRem = (int)(nByte - nAvail);
				while ((nRem) > (0))
				{
					int rc = 0;
					int nCopy = 0;
					byte* aNext;
					nCopy = (int)(nRem);
					if ((nRem) > (p.nBuffer))
						nCopy = (int)(p.nBuffer);
					rc = (int)(vdbePmaReadBlob(p, (int)(nCopy), &aNext));
					if (rc != 0)
						return (int)(rc);

					CRuntime.memcpy(&p.aAlloc[nByte - nRem], aNext, (ulong)(nCopy));
					nRem -= (int)(nCopy);
				}

				*ppOut = p.aAlloc;
			}

			return (int)(0);
		}
		public static void* vdbePmaReaderBgIncrInit(void* pCtx)
		{
			PmaReader pReader = (PmaReader)(pCtx);
			void* pRet = ((void*)((long)(vdbePmaReaderIncrMergeInit(pReader, (int)(1)))));
			pReader.pIncr.pTask.bDone = (int)(1);
			return pRet;
		}
		public static void vdbePmaReaderClear(PmaReader pReadr)
		{
			sqlite3_free(pReadr.aAlloc);
			sqlite3_free(pReadr.aBuffer);
			if ((pReadr.aMap) != null)
				sqlite3OsUnfetch(pReadr.pFd, (long)(0), pReadr.aMap);
			vdbeIncrFree(pReadr.pIncr);
			CRuntime.memset(pReadr, (int)(0), (ulong)(sizeof(PmaReader)));
		}
		public static int vdbePmaReaderIncrInit(PmaReader pReadr, int eMode)
		{
			IncrMerger pIncr = pReadr.pIncr;
			int rc = (int)(0);
			if ((pIncr) != null)
			{

				if ((pIncr.bUseThread) != 0)
				{
					void* pCtx = (void*)(pReadr);
					rc = (int)(vdbeSorterCreateThread(pIncr.pTask, vdbePmaReaderBgIncrInit, pCtx));
				}
				else
				{
					rc = (int)(vdbePmaReaderIncrMergeInit(pReadr, (int)(eMode)));
				}
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderIncrMergeInit(PmaReader pReadr, int eMode)
		{
			int rc = (int)(0);
			IncrMerger pIncr = pReadr.pIncr;
			SortSubtask pTask = pIncr.pTask;
			sqlite3 db = pTask.pSorter.db;

			rc = (int)(vdbeMergeEngineInit(pTask, pIncr.pMerger, (int)(eMode)));
			if ((rc) == (0))
			{
				int mxSz = (int)(pIncr.mxSz);
				if ((pIncr.bUseThread) != 0)
				{
					rc = (int)(vdbeSorterOpenTempFile(db, (long)(mxSz), pIncr.aFile[0].pFd));
					if ((rc) == (0))
					{
						rc = (int)(vdbeSorterOpenTempFile(db, (long)(mxSz), pIncr.aFile[1].pFd));
					}
				}
				else
				{
					if ((pTask.file2.pFd) == (null))
					{

						rc = (int)(vdbeSorterOpenTempFile(db, (long)(pTask.file2.iEof), pTask.file2.pFd));
						pTask.file2.iEof = (long)(0);
					}

					if ((rc) == (0))
					{
						pIncr.aFile[1].pFd = pTask.file2.pFd;
						pIncr.iStartOff = (long)(pTask.file2.iEof);
						pTask.file2.iEof += (long)(mxSz);
					}
				}
			}

			if (((rc) == (0)) && ((pIncr.bUseThread) != 0))
			{

				rc = (int)(vdbeIncrPopulate(pIncr));
			}

			if (((rc) == (0)) && (((8) == (0)) || (eMode != 1)))
			{
				rc = (int)(vdbePmaReaderNext(pReadr));
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderInit(SortSubtask pTask, SorterFile pFile, long iStart, PmaReader pReadr, long* pnByte)
		{
			int rc = 0;




			rc = (int)(vdbePmaReaderSeek(pTask, pReadr, pFile, (long)(iStart)));
			if ((rc) == (0))
			{
				ulong nByte = (ulong)(0);
				rc = (int)(vdbePmaReadVarint(pReadr, &nByte));
				pReadr.iEof = (long)(pReadr.iReadOff + nByte);
				*pnByte += (long)(nByte);
			}

			if ((rc) == (0))
			{
				rc = (int)(vdbePmaReaderNext(pReadr));
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderNext(PmaReader pReadr)
		{
			int rc = (int)(0);
			ulong nRec = (ulong)(0);
			if ((pReadr.iReadOff) >= (pReadr.iEof))
			{
				IncrMerger pIncr = pReadr.pIncr;
				int bEof = (int)(1);
				if ((pIncr) != null)
				{
					rc = (int)(vdbeIncrSwap(pIncr));
					if (((rc) == (0)) && ((pIncr.bEof) == (0)))
					{
						rc = (int)(vdbePmaReaderSeek(pIncr.pTask, pReadr, pIncr.aFile[0], (long)(pIncr.iStartOff)));
						bEof = (int)(0);
					}
				}

				if ((bEof) != 0)
				{
					vdbePmaReaderClear(pReadr);
					return (int)(rc);
				}
			}

			if ((rc) == (0))
			{
				rc = (int)(vdbePmaReadVarint(pReadr, &nRec));
			}

			if ((rc) == (0))
			{
				pReadr.nKey = ((int)(nRec));
				rc = (int)(vdbePmaReadBlob(pReadr, (int)(nRec), &pReadr.aKey));
			}

			return (int)(rc);
		}
		public static int vdbePmaReaderSeek(SortSubtask pTask, PmaReader pReadr, SorterFile pFile, long iOff)
		{
			int rc = (int)(0);

			if ((sqlite3FaultSim((int)(201))) != 0)
				return (int)(10 | (1 << 8));
			if ((pReadr.aMap) != null)
			{
				sqlite3OsUnfetch(pReadr.pFd, (long)(0), pReadr.aMap);
				pReadr.aMap = null;
			}

			pReadr.iReadOff = (long)(iOff);
			pReadr.iEof = (long)(pFile.iEof);
			pReadr.pFd = pFile.pFd;
			rc = (int)(vdbeSorterMapFile(pTask, pFile, &pReadr.aMap));
			if (((rc) == (0)) && ((pReadr.aMap) == (null)))
			{
				int pgsz = (int)(pTask.pSorter.pgsz);
				int iBuf = (int)(pReadr.iReadOff % pgsz);
				if ((pReadr.aBuffer) == (null))
				{
					pReadr.aBuffer = (byte*)(sqlite3Malloc((ulong)(pgsz)));
					if ((pReadr.aBuffer) == (null))
						rc = (int)(7);
					pReadr.nBuffer = (int)(pgsz);
				}

				if (((rc) == (0)) && ((iBuf) != 0))
				{
					int nRead = (int)(pgsz - iBuf);
					if ((pReadr.iReadOff + nRead) > (pReadr.iEof))
					{
						nRead = ((int)(pReadr.iEof - pReadr.iReadOff));
					}

					rc = (int)(sqlite3OsRead(pReadr.pFd, &pReadr.aBuffer[iBuf], (int)(nRead), (long)(pReadr.iReadOff)));
				}
			}

			return (int)(rc);
		}
		public static int vdbePmaReadVarint(PmaReader p, ulong* pnOut)
		{
			int iBuf = 0;
			if ((p.aMap) != null)
			{
				p.iReadOff += (long)(sqlite3GetVarint(&p.aMap[p.iReadOff], pnOut));
			}
			else
			{
				iBuf = (int)(p.iReadOff % p.nBuffer);
				if (((iBuf) != 0) && ((p.nBuffer - iBuf) >= (9)))
				{
					p.iReadOff += (long)(sqlite3GetVarint(&p.aBuffer[iBuf], pnOut));
				}
				else
				{
					byte* aVarint = stackalloc byte[16];
					byte* a;
					int i = (int)(0);
					int rc = 0;
					do
					{
						rc = (int)(vdbePmaReadBlob(p, (int)(1), &a));
						if ((rc) != 0)
							return (int)(rc);
						aVarint[(i++) & 0xf] = (byte)(a[0]);
					}
					while ((a[0] & 0x80) != 0);
					sqlite3GetVarint(aVarint, pnOut);
				}
			}

			return (int)(0);
		}
		public static void vdbePmaWriteBlob(PmaWriter p, byte* pData, int nData)
		{
			int nRem = (int)(nData);
			while (((nRem) > (0)) && ((p.eFWErr) == (0)))
			{
				int nCopy = (int)(nRem);
				if ((nCopy) > (p.nBuffer - p.iBufEnd))
				{
					nCopy = (int)(p.nBuffer - p.iBufEnd);
				}

				CRuntime.memcpy(&p.aBuffer[p.iBufEnd], &pData[nData - nRem], (ulong)(nCopy));
				p.iBufEnd += (int)(nCopy);
				if ((p.iBufEnd) == (p.nBuffer))
				{
					p.eFWErr = (int)(sqlite3OsWrite(p.pFd, &p.aBuffer[p.iBufStart], (int)(p.iBufEnd - p.iBufStart), (long)(p.iWriteOff + p.iBufStart)));
					p.iBufStart = (int)(p.iBufEnd = (int)(0));
					p.iWriteOff += (long)(p.nBuffer);
				}


				nRem -= (int)(nCopy);
			}
		}
		public static int vdbePmaWriterFinish(PmaWriter p, long* piEof)
		{
			int rc = 0;
			if ((((p.eFWErr) == (0)) && ((p.aBuffer) != null)) && ((p.iBufEnd) > (p.iBufStart)))
			{
				p.eFWErr = (int)(sqlite3OsWrite(p.pFd, &p.aBuffer[p.iBufStart], (int)(p.iBufEnd - p.iBufStart), (long)(p.iWriteOff + p.iBufStart)));
			}

			*piEof = (long)(p.iWriteOff + p.iBufEnd);
			sqlite3_free(p.aBuffer);
			rc = (int)(p.eFWErr);
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(PmaWriter)));
			return (int)(rc);
		}
		public static void vdbePmaWriterInit(sqlite3_file pFd, PmaWriter p, int nBuf, long iStart)
		{
			CRuntime.memset(p, (int)(0), (ulong)(sizeof(PmaWriter)));
			p.aBuffer = (byte*)(sqlite3Malloc((ulong)(nBuf)));
			if (p.aBuffer == null)
			{
				p.eFWErr = (int)(7);
			}
			else
			{
				p.iBufEnd = (int)(p.iBufStart = (int)(iStart % nBuf));
				p.iWriteOff = (long)(iStart - p.iBufStart);
				p.nBuffer = (int)(nBuf);
				p.pFd = pFd;
			}
		}
		public static void vdbePmaWriteVarint(PmaWriter p, ulong iVal)
		{
			int nByte = 0;
			byte* aByte = stackalloc byte[10];
			nByte = (int)(sqlite3PutVarint(aByte, (ulong)(iVal)));
			vdbePmaWriteBlob(p, aByte, (int)(nByte));
		}
		public static int vdbeRecordCompareInt(int nKey1, void* pKey1, UnpackedRecord pPKey2)
		{
			byte* aKey = &((byte*)(pKey1))[*(byte*)(pKey1) & 0x3F];
			int serial_type = (int)(((byte*)(pKey1))[1]);
			int res = 0;
			uint y = 0;
			ulong x = 0;
			long v = 0;
			long lhs = 0;

			switch (serial_type)
			{
				case 1:
					{
						lhs = (long)((sbyte)((aKey)[0]));
						break;
					}

				case 2:
					{
						lhs = (long)(256 * (sbyte)((aKey)[0]) | (aKey)[1]);
						break;
					}

				case 3:
					{
						lhs = (long)(65536 * (sbyte)((aKey)[0]) | ((aKey)[1] << 8) | (aKey)[2]);
						break;
					}

				case 4:
					{
						y = (uint)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						lhs = ((long)(*(int*)(&y)));
						break;
					}

				case 5:
					{
						lhs = (long)((((uint)((aKey + 2)[0]) << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((long)(1)) << 32) * (256 * (sbyte)((aKey)[0]) | (aKey)[1]));
						break;
					}

				case 6:
					{
						x = (ulong)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						x = (ulong)((x << 32) | (((uint)((aKey + 4)[0]) << 24) | ((aKey + 4)[1] << 16) | ((aKey + 4)[2] << 8) | (aKey + 4)[3]));
						lhs = (long)(*(long*)(&x));
						break;
					}

				case 8:
					lhs = (long)(0);
					break;
				case 9:
					lhs = (long)(1);
					break;
				case 0:
				case 7:
					return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, pPKey2));
				default:
					return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, pPKey2));
			}

			v = (long)(pPKey2.aMem[0].u.i);
			if ((v) > (lhs))
			{
				res = (int)(pPKey2.r1);
			}
			else if ((v) < (lhs))
			{
				res = (int)(pPKey2.r2);
			}
			else if ((pPKey2.nField) > (1))
			{
				res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(1)));
			}
			else
			{
				res = (int)(pPKey2.default_rc);
				pPKey2.eqSeen = (byte)(1);
			}


			return (int)(res);
		}
		public static int vdbeRecordCompareString(int nKey1, void* pKey1, UnpackedRecord pPKey2)
		{
			byte* aKey1 = (byte*)(pKey1);
			int serial_type = 0;
			int res = 0;

			serial_type = (int)(aKey1[1]);
			if ((serial_type) >= (0x80))
			{
				sqlite3GetVarint32(&aKey1[1], (uint*)(&serial_type));
			}

			if ((serial_type) < (12))
			{
				res = (int)(pPKey2.r1);
			}
			else if ((serial_type & 0x01) == 0)
			{
				res = (int)(pPKey2.r2);
			}
			else
			{
				int nCmp = 0;
				int nStr = 0;
				int szHdr = (int)(aKey1[0]);
				nStr = (int)((serial_type - 12) / 2);
				if ((szHdr + nStr) > (nKey1))
				{
					pPKey2.errCode = ((byte)(sqlite3CorruptError((int)(84614))));
					return (int)(0);
				}

				nCmp = (int)((pPKey2.aMem[0].n) < (nStr) ? (pPKey2.aMem[0].n) : (nStr));
				res = (int)(memcmp(&aKey1[szHdr], pPKey2.aMem[0].z, (ulong)(nCmp)));
				if ((res) > (0))
				{
					res = (int)(pPKey2.r2);
				}
				else if ((res) < (0))
				{
					res = (int)(pPKey2.r1);
				}
				else
				{
					res = (int)(nStr - pPKey2.aMem[0].n);
					if ((res) == (0))
					{
						if ((pPKey2.nField) > (1))
						{
							res = (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, pPKey2, (int)(1)));
						}
						else
						{
							res = (int)(pPKey2.default_rc);
							pPKey2.eqSeen = (byte)(1);
						}
					}
					else if ((res) > (0))
					{
						res = (int)(pPKey2.r2);
					}
					else
					{
						res = (int)(pPKey2.r1);
					}
				}
			}


			return (int)(res);
		}
		public static long vdbeRecordDecodeInt(uint serial_type, byte* aKey)
		{
			uint y = 0;

			switch (serial_type)
			{
				case 0:
				case 1:
					;
					return (long)((sbyte)((aKey)[0]));
				case 2:
					;
					return (long)(256 * (sbyte)((aKey)[0]) | (aKey)[1]);
				case 3:
					;
					return (long)(65536 * (sbyte)((aKey)[0]) | ((aKey)[1] << 8) | (aKey)[2]);
				case 4:
					{
						y = (uint)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						return (long)(*(int*)(&y));
					}

				case 5:
					{
						return (long)((((uint)((aKey + 2)[0]) << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((long)(1)) << 32) * (256 * (sbyte)((aKey)[0]) | (aKey)[1]));
					}

				case 6:
					{
						ulong x = (ulong)(((uint)((aKey)[0]) << 24) | ((aKey)[1] << 16) | ((aKey)[2] << 8) | (aKey)[3]);
						x = (ulong)((x << 32) | (((uint)((aKey + 4)[0]) << 24) | ((aKey + 4)[1] << 16) | ((aKey + 4)[2] << 8) | (aKey + 4)[3]));
						return (long)(*(long*)(&x));
					}
			}

			return (long)(serial_type - 8);
		}
		public static void vdbeReleaseAndSetInt64(sqlite3_value pMem, long val)
		{
			sqlite3VdbeMemSetNull(pMem);
			pMem.u.i = (long)(val);
			pMem.flags = (ushort)(0x0004);
		}
		public static int vdbeSafety(Vdbe p)
		{
			if ((p.db) == (null))
			{
				sqlite3_log((int)(21), "API called with finalized prepared statement");
				return (int)(1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static int vdbeSafetyNotNull(Vdbe p)
		{
			if ((p) == (null))
			{
				sqlite3_log((int)(21), "API called with NULL prepared statement");
				return (int)(1);
			}
			else
			{
				return (int)(vdbeSafety(p));
			}
		}
		public static int vdbeSortAllocUnpacked(SortSubtask pTask)
		{
			if ((pTask.pUnpacked) == (null))
			{
				pTask.pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask.pSorter.pKeyInfo);
				if ((pTask.pUnpacked) == (null))
					return (int)(7);
				pTask.pUnpacked.nField = (ushort)(pTask.pSorter.pKeyInfo.nKeyField);
				pTask.pUnpacked.errCode = (byte)(0);
			}

			return (int)(0);
		}
		public static int vdbeSorterAddToTree(SortSubtask pTask, int nDepth, int iSeq, MergeEngine pRoot, MergeEngine pLeaf)
		{
			int rc = (int)(0);
			int nDiv = (int)(1);
			int i = 0;
			MergeEngine p = pRoot;
			IncrMerger pIncr;
			rc = (int)(vdbeIncrMergerNew(pTask, pLeaf, pIncr));
			for (i = (int)(1); (i) < (nDepth); i++)
			{
				nDiv = (int)(nDiv * 16);
			}

			for (i = (int)(1); ((i) < (nDepth)) && ((rc) == (0)); i++)
			{
				int iIter = (int)((iSeq / nDiv) % 16);
				PmaReader pReadr = p.aReadr[iIter];
				if ((pReadr.pIncr) == (null))
				{
					MergeEngine pNew = vdbeMergeEngineNew((int)(16));
					if ((pNew) == (null))
					{
						rc = (int)(7);
					}
					else
					{
						rc = (int)(vdbeIncrMergerNew(pTask, pNew, pReadr.pIncr));
					}
				}

				if ((rc) == (0))
				{
					p = pReadr.pIncr.pMerger;
					nDiv = (int)(nDiv / 16);
				}
			}

			if ((rc) == (0))
			{
				p.aReadr[iSeq % 16].pIncr = pIncr;
			}
			else
			{
				vdbeIncrFree(pIncr);
			}

			return (int)(rc);
		}
		public static int vdbeSorterCompare(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			UnpackedRecord r2 = pTask.pUnpacked;
			if (*pbKey2Cached == 0)
			{
				sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, (int)(nKey2), pKey2, r2);
				*pbKey2Cached = (int)(1);
			}

			return (int)(sqlite3VdbeRecordCompare((int)(nKey1), pKey1, r2));
		}
		public static int vdbeSorterCompareInt(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			byte* p1 = (byte*)(pKey1);
			byte* p2 = (byte*)(pKey2);
			int s1 = (int)(p1[1]);
			int s2 = (int)(p2[1]);
			byte* v1 = &p1[p1[0]];
			byte* v2 = &p2[p2[0]];
			int res = 0;


			if ((s1) == (s2))
			{
				byte n = (byte)(vdbeSorterCompareInt_aLen[s1]);
				int i = 0;
				res = (int)(0);
				for (i = (int)(0); (i) < (n); i++)
				{
					if ((res = (int)(v1[i] - v2[i])) != 0)
					{
						if (((v1[0] ^ v2[0]) & 0x80) != 0)
						{
							res = (int)((v1[0] & 0x80) != 0 ? -1 : +1);
						}

						break;
					}
				}
			}
			else if (((s1) > (7)) && ((s2) > (7)))
			{
				res = (int)(s1 - s2);
			}
			else
			{
				if ((s2) > (7))
				{
					res = (int)(+1);
				}
				else if ((s1) > (7))
				{
					res = (int)(-1);
				}
				else
				{
					res = (int)(s1 - s2);
				}


				if ((res) > (0))
				{
					if ((*v1 & 0x80) != 0)
						res = (int)(-1);
				}
				else
				{
					if ((*v2 & 0x80) != 0)
						res = (int)(+1);
				}
			}

			if ((res) == (0))
			{
				if ((pTask.pSorter.pKeyInfo.nKeyField) > (1))
				{
					res = (int)(vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, (int)(nKey1), pKey2, (int)(nKey2)));
				}
			}
			else if ((pTask.pSorter.pKeyInfo.aSortFlags[0]) != 0)
			{

				res = (int)(res * -1);
			}

			return (int)(res);
		}
		public static int vdbeSorterCompareTail(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			UnpackedRecord r2 = pTask.pUnpacked;
			if ((*pbKey2Cached) == (0))
			{
				sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, (int)(nKey2), pKey2, r2);
				*pbKey2Cached = (int)(1);
			}

			return (int)(sqlite3VdbeRecordCompareWithSkip((int)(nKey1), pKey1, r2, (int)(1)));
		}
		public static int vdbeSorterCompareText(SortSubtask pTask, int* pbKey2Cached, void* pKey1, int nKey1, void* pKey2, int nKey2)
		{
			byte* p1 = (byte*)(pKey1);
			byte* p2 = (byte*)(pKey2);
			byte* v1 = &p1[p1[0]];
			byte* v2 = &p2[p2[0]];
			int n1 = 0;
			int n2 = 0;
			int res = 0;
			n1 = (int)((uint)(*(&p1[1])));
			if ((n1) >= (0x80))
				sqlite3GetVarint32((&p1[1]), (uint*)(&(n1)));
			n2 = (int)((uint)(*(&p2[1])));
			if ((n2) >= (0x80))
				sqlite3GetVarint32((&p2[1]), (uint*)(&(n2)));
			res = (int)(memcmp(v1, v2, (ulong)((((n1) < (n2) ? (n1) : (n2)) - 13) / 2)));
			if ((res) == (0))
			{
				res = (int)(n1 - n2);
			}

			if ((res) == (0))
			{
				if ((pTask.pSorter.pKeyInfo.nKeyField) > (1))
				{
					res = (int)(vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, (int)(nKey1), pKey2, (int)(nKey2)));
				}
			}
			else
			{

				if ((pTask.pSorter.pKeyInfo.aSortFlags[0]) != 0)
				{
					res = (int)(res * -1);
				}
			}

			return (int)(res);
		}
		public static int vdbeSorterCreateThread(SortSubtask pTask, delegate74 xTask, void* pIn)
		{

			return (int)(sqlite3ThreadCreate(pTask.pThread, xTask, pIn));
		}
		public static void vdbeSorterExtendFile(sqlite3 db, sqlite3_file pFd, long nByte)
		{
			if (((nByte) <= ((long)(db.nMaxSorterMmap))) && ((pFd.pMethods.iVersion) >= (3)))
			{
				void* p = null;
				int chunksize = (int)(4 * 1024);
				sqlite3OsFileControlHint(pFd, (int)(6), &chunksize);
				sqlite3OsFileControlHint(pFd, (int)(5), &nByte);
				sqlite3OsFetch(pFd, (long)(0), (int)(nByte), &p);
				if ((p) != null)
					sqlite3OsUnfetch(pFd, (long)(0), p);
			}
		}
		public static int vdbeSorterFlushPMA(VdbeSorter pSorter)
		{
			int rc = (int)(0);
			int i = 0;
			SortSubtask pTask = null;
			int nWorker = (int)(pSorter.nTask - 1);
			pSorter.bUsePMA = (byte)(1);
			for (i = (int)(0); (i) < (nWorker); i++)
			{
				int iTest = (int)((pSorter.iPrev + i + 1) % nWorker);
				pTask = pSorter.aTask[iTest];
				if ((pTask.bDone) != 0)
				{
					rc = (int)(vdbeSorterJoinThread(pTask));
				}

				if ((rc != 0) || ((pTask.pThread) == (null)))
					break;
			}

			if ((rc) == (0))
			{
				if ((i) == (nWorker))
				{
					rc = (int)(vdbeSorterListToPMA(pSorter.aTask[nWorker], &pSorter.list));
				}
				else
				{
					byte* aMem;
					void* pCtx;




					aMem = pTask.list.aMemory;
					pCtx = (void*)(pTask);
					pSorter.iPrev = ((byte)(pTask - pSorter.aTask));
					pTask.list = (SorterList)(pSorter.list);
					pSorter.list.pList = null;
					pSorter.list.szPMA = (int)(0);
					if ((aMem) != null)
					{
						pSorter.list.aMemory = aMem;
						pSorter.nMemory = (int)(sqlite3MallocSize(aMem));
					}
					else if ((pSorter.list.aMemory) != null)
					{
						pSorter.list.aMemory = sqlite3Malloc((ulong)(pSorter.nMemory));
						if (pSorter.list.aMemory == null)
							return (int)(7);
					}

					rc = (int)(vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx));
				}
			}

			return (int)(rc);
		}
		public static void* vdbeSorterFlushThread(void* pCtx)
		{
			SortSubtask pTask = (SortSubtask)(pCtx);
			int rc = 0;

			rc = (int)(vdbeSorterListToPMA(pTask, &pTask.list));
			pTask.bDone = (int)(1);
			return ((void*)((long)(rc)));
		}
		public static Int(SortSubtask* , SortSubtask* , SortSubtask* , SortSubtask* , SortSubtask* , SortSubtask* )vdbeSorterGetCompare(VdbeSorter p)
		{
			if ((p.typeMask) == (0x01))
			{
				return vdbeSorterCompareInt;
			}
			else if ((p.typeMask) == (0x02))
			{
				return vdbeSorterCompareText;
			}

			return vdbeSorterCompare;
		}
		public static int vdbeSorterJoinAll(VdbeSorter pSorter, int rcin)
		{
			int rc = (int)(rcin);
			int i = 0;
			for (i = (int)(pSorter.nTask - 1); (i) >= (0); i--)
			{
				SortSubtask pTask = pSorter.aTask[i];
				int rc2 = (int)(vdbeSorterJoinThread(pTask));
				if ((rc) == (0))
					rc = (int)(rc2);
			}

			return (int)(rc);
		}
		public static int vdbeSorterJoinThread(SortSubtask pTask)
		{
			int rc = (int)(0);
			if ((pTask.pThread) != null)
			{
				void* pRet = ((void*)((long)(1)));
				(void)(sqlite3ThreadJoin(pTask.pThread, &pRet));
				rc = ((int)((long)(pRet)));

				pTask.bDone = (int)(0);
				pTask.pThread = null;
			}

			return (int)(rc);
		}
		public static int vdbeSorterListToPMA(SortSubtask pTask, SorterList* pList)
		{
			sqlite3 db = pTask.pSorter.db;
			int rc = (int)(0);
			PmaWriter writer = new PmaWriter();
			CRuntime.memset(writer, (int)(0), (ulong)(sizeof(PmaWriter)));

			if ((pTask.file.pFd) == (null))
			{
				rc = (int)(vdbeSorterOpenTempFile(db, (long)(0), pTask.file.pFd));



			}

			if ((rc) == (0))
			{
				vdbeSorterExtendFile(db, pTask.file.pFd, (long)(pTask.file.iEof + pList->szPMA + 9));
			}

			if ((rc) == (0))
			{
				rc = (int)(vdbeSorterSort(pTask, pList));
			}

			if ((rc) == (0))
			{
				SorterRecord* p;
				SorterRecord* pNext = null;
				vdbePmaWriterInit(pTask.file.pFd, writer, (int)(pTask.pSorter.pgsz), (long)(pTask.file.iEof));
				pTask.nPMA++;
				vdbePmaWriteVarint(writer, (ulong)(pList->szPMA));
				for (p = pList->pList; p; p = pNext)
				{
					pNext = p->u.pNext;
					vdbePmaWriteVarint(writer, (ulong)(p->nVal));
					vdbePmaWriteBlob(writer, ((void*)((p) + 1)), (int)(p->nVal));
					if ((pList->aMemory) == (null))
						sqlite3_free(p);
				}

				pList->pList = p;
				rc = (int)(vdbePmaWriterFinish(writer, &pTask.file.iEof));
			}



			return (int)(rc);
		}
		public static int vdbeSorterMapFile(SortSubtask pTask, SorterFile pFile, byte** pp)
		{
			int rc = (int)(0);
			if ((pFile.iEof) <= ((long)(pTask.pSorter.db.nMaxSorterMmap)))
			{
				sqlite3_file pFd = pFile.pFd;
				if ((pFd.pMethods.iVersion) >= (3))
				{
					rc = (int)(sqlite3OsFetch(pFd, (long)(0), (int)(pFile.iEof), (void**)(pp)));
				}
			}

			return (int)(rc);
		}
		public static SorterRecord* vdbeSorterMerge(SortSubtask pTask, SorterRecord* p1, SorterRecord* p2)
		{
			SorterRecord* pFinal = null;
			SorterRecord** pp = &pFinal;
			int bCached = (int)(0);

			for (; ; )
			{
				int res = 0;
				res = (int)(pTask.xCompare(pTask, &bCached, ((void*)((p1) + 1)), (int)(p1->nVal), ((void*)((p2) + 1)), (int)(p2->nVal)));
				if ((res) <= (0))
				{
					*pp = p1;
					pp = &p1->u.pNext;
					p1 = p1->u.pNext;
					if ((p1) == (null))
					{
						*pp = p2;
						break;
					}
				}
				else
				{
					*pp = p2;
					pp = &p2->u.pNext;
					p2 = p2->u.pNext;
					bCached = (int)(0);
					if ((p2) == (null))
					{
						*pp = p1;
						break;
					}
				}
			}

			return pFinal;
		}
		public static int vdbeSorterMergeTreeBuild(VdbeSorter pSorter, MergeEngine ppOut)
		{
			MergeEngine pMain = null;
			int rc = (int)(0);
			int iTask = 0;

			if ((pSorter.nTask) > (1))
			{
				pMain = vdbeMergeEngineNew((int)(pSorter.nTask));
				if ((pMain) == (null))
					rc = (int)(7);
			}

			for (iTask = (int)(0); ((rc) == (0)) && ((iTask) < (pSorter.nTask)); iTask++)
			{
				SortSubtask pTask = pSorter.aTask[iTask];

				if (((8) == (0)) || ((pTask.nPMA) != 0))
				{
					MergeEngine pRoot = null;
					int nDepth = (int)(vdbeSorterTreeDepth((int)(pTask.nPMA)));
					long iReadOff = (long)(0);
					if ((pTask.nPMA) <= (16))
					{
						rc = (int)(vdbeMergeEngineLevel0(pTask, (int)(pTask.nPMA), &iReadOff, pRoot));
					}
					else
					{
						int i = 0;
						int iSeq = (int)(0);
						pRoot = vdbeMergeEngineNew((int)(16));
						if ((pRoot) == (null))
							rc = (int)(7);
						for (i = (int)(0); ((i) < (pTask.nPMA)) && ((rc) == (0)); i += (int)(16))
						{
							MergeEngine pMerger = null;
							int nReader = 0;
							nReader = (int)((pTask.nPMA - i) < (16) ? (pTask.nPMA - i) : (16));
							rc = (int)(vdbeMergeEngineLevel0(pTask, (int)(nReader), &iReadOff, pMerger));
							if ((rc) == (0))
							{
								rc = (int)(vdbeSorterAddToTree(pTask, (int)(nDepth), (int)(iSeq++), pRoot, pMerger));
							}
						}
					}

					if ((rc) == (0))
					{
						if (pMain != null)
						{
							rc = (int)(vdbeIncrMergerNew(pTask, pRoot, pMain.aReadr[iTask].pIncr));
						}
						else
						{

							pMain = pRoot;
						}
					}
					else
					{
						vdbeMergeEngineFree(pRoot);
					}
				}
			}

			if (rc != 0)
			{
				vdbeMergeEngineFree(pMain);
				pMain = null;
			}

			ppOut = pMain;
			return (int)(rc);
		}
		public static int vdbeSorterOpenTempFile(sqlite3 db, long nExtend, sqlite3_file ppFd)
		{
			int rc = 0;
			if ((sqlite3FaultSim((int)(202))) != 0)
				return (int)(10 | (13 << 8));
			rc = (int)(sqlite3OsOpenMalloc(db.pVfs, null, ppFd, (int)(0x00001000 | 0x00000002 | 0x00000004 | 0x00000010 | 0x00000008), &rc));
			if ((rc) == (0))
			{
				long max = (long)(0x7fff0000);
				sqlite3OsFileControlHint(ppFd, (int)(18), (void*)(&max));
				if ((nExtend) > (0))
				{
					vdbeSorterExtendFile(db, ppFd, (long)(nExtend));
				}
			}

			return (int)(rc);
		}
		public static void vdbeSorterRecordFree(sqlite3 db, SorterRecord* pRecord)
		{
			SorterRecord* p;
			SorterRecord* pNext;
			for (p = pRecord; p; p = pNext)
			{
				pNext = p->u.pNext;
				sqlite3DbFree(db, p);
			}
		}
		public static void* vdbeSorterRowkey(VdbeSorter pSorter, int* pnKey)
		{
			void* pKey;
			if ((pSorter.bUsePMA) != 0)
			{
				PmaReader pReader;
				if ((pSorter.bUseThreads) != 0)
				{
					pReader = pSorter.pReader;
				}
				else
				{
					pReader = pSorter.pMerger.aReadr[pSorter.pMerger.aTree[1]];
				}

				*pnKey = (int)(pReader.nKey);
				pKey = pReader.aKey;
			}
			else
			{
				*pnKey = (int)(pSorter.list.pList->nVal);
				pKey = ((void*)((pSorter.list.pList) + 1));
			}

			return pKey;
		}
		public static int vdbeSorterSetupMerge(VdbeSorter pSorter)
		{
			int rc = 0;
			SortSubtask pTask0 = pSorter.aTask[0];
			MergeEngine pMain = null;
			sqlite3 db = pTask0.pSorter.db;
			int i = 0;
			delegate79 xCompare = vdbeSorterGetCompare(pSorter);
			for (i = (int)(0); (i) < (pSorter.nTask); i++)
			{
				pSorter.aTask[i].xCompare = xCompare;
			}

			rc = (int)(vdbeSorterMergeTreeBuild(pSorter, pMain));
			if ((rc) == (0))
			{

				if ((pSorter.bUseThreads) != 0)
				{
					int iTask = 0;
					PmaReader pReadr = null;
					SortSubtask pLast = pSorter.aTask[pSorter.nTask - 1];
					rc = (int)(vdbeSortAllocUnpacked(pLast));
					if ((rc) == (0))
					{
						pReadr = (PmaReader)(sqlite3DbMallocZero(db, (ulong)(sizeof(PmaReader))));
						pSorter.pReader = pReadr;
						if ((pReadr) == (null))
							rc = (int)(7);
					}

					if ((rc) == (0))
					{
						rc = (int)(vdbeIncrMergerNew(pLast, pMain, pReadr.pIncr));
						if ((rc) == (0))
						{
							vdbeIncrMergerSetThreads(pReadr.pIncr);
							for (iTask = (int)(0); (iTask) < (pSorter.nTask - 1); iTask++)
							{
								IncrMerger pIncr;
								if ((pIncr = pMain.aReadr[iTask].pIncr))
								{
									vdbeIncrMergerSetThreads(pIncr);

								}
							}

							for (iTask = (int)(0); ((rc) == (0)) && ((iTask) < (pSorter.nTask)); iTask++)
							{
								PmaReader p = pMain.aReadr[iTask];

								rc = (int)(vdbePmaReaderIncrInit(p, (int)(1)));
							}
						}

						pMain = null;
					}

					if ((rc) == (0))
					{
						rc = (int)(vdbePmaReaderIncrMergeInit(pReadr, (int)(2)));
					}
				}
				else
				{
					rc = (int)(vdbeMergeEngineInit(pTask0, pMain, (int)(0)));
					pSorter.pMerger = pMain;
					pMain = null;
				}
			}

			if (rc != 0)
			{
				vdbeMergeEngineFree(pMain);
			}

			return (int)(rc);
		}
		public static int vdbeSorterSort(SortSubtask pTask, SorterList* pList)
		{
			int i = 0;
			SorterRecord* p;
			int rc = 0;
			SorterRecord** aSlot = stackalloc SorterRecord[64];
			rc = (int)(vdbeSortAllocUnpacked(pTask));
			if (rc != 0)
				return (int)(rc);
			p = pList->pList;
			pTask.xCompare = vdbeSorterGetCompare(pTask.pSorter);
			CRuntime.memset(aSlot, (int)(0), (ulong)(64 * sizeof(SorterRecord)));
			while ((p) != null)
			{
				SorterRecord* pNext;
				if ((pList->aMemory) != null)
				{
					if (((byte*)(p)) == (pList->aMemory))
					{
						pNext = null;
					}
					else
					{

						pNext = (SorterRecord*)(&pList->aMemory[p->u.iNext]);
					}
				}
				else
				{
					pNext = p->u.pNext;
				}

				p->u.pNext = null;
				for (i = (int)(0); aSlot[i]; i++)
				{
					p = vdbeSorterMerge(pTask, p, aSlot[i]);
					aSlot[i] = null;
				}

				aSlot[i] = p;
				p = pNext;
			}

			p = null;
			for (i = (int)(0); (i) < ((int)(64 * sizeof(SorterRecord) / sizeof(SorterRecord*))); i++)
			{
				if ((aSlot[i]) == (null))
					continue;
				p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
			}

			pList->pList = p;

			return (int)(pTask.pUnpacked.errCode);
		}
		public static int vdbeSorterTreeDepth(int nPMA)
		{
			int nDepth = (int)(0);
			long nDiv = (long)(16);
			while ((nDiv) < ((long)(nPMA)))
			{
				nDiv = (long)(nDiv * 16);
				nDepth++;
			}

			return (int)(nDepth);
		}
		public static void vdbeSortSubtaskCleanup(sqlite3 db, SortSubtask pTask)
		{
			sqlite3DbFree(db, pTask.pUnpacked);
			if ((pTask.list.aMemory) != null)
			{
				sqlite3_free(pTask.list.aMemory);
			}
			else
			{

				vdbeSorterRecordFree(null, pTask.list.pList);
			}

			if ((pTask.file.pFd) != null)
			{
				sqlite3OsCloseFree(pTask.file.pFd);
			}

			if ((pTask.file2.pFd) != null)
			{
				sqlite3OsCloseFree(pTask.file2.pFd);
			}

			CRuntime.memset(pTask, (int)(0), (ulong)(sizeof(SortSubtask)));
		}
		public static int vdbeUnbind(Vdbe p, int i)
		{
			sqlite3_value pVar;
			if ((vdbeSafetyNotNull(p)) != 0)
			{
				return (int)(sqlite3MisuseError((int)(86465)));
			}

			sqlite3_mutex_enter(p.db.mutex);
			if ((p.iVdbeMagic != 0x2df20da3) || ((p.pc) >= (0)))
			{
				sqlite3Error(p.db, (int)(21));
				sqlite3_mutex_leave(p.db.mutex);
				sqlite3_log((int)(21), "bind on a busy prepared statement: [%s]", p.zSql);
				return (int)(sqlite3MisuseError((int)(86473)));
			}

			if (((i) < (1)) || ((i) > (p.nVar)))
			{
				sqlite3Error(p.db, (int)(25));
				sqlite3_mutex_leave(p.db.mutex);
				return (int)(25);
			}

			i--;
			pVar = p.aVar[i];
			sqlite3VdbeMemRelease(pVar);
			pVar.flags = (ushort)(0x0001);
			p.db.errCode = (int)(0);

			if ((p.expmask != 0) && ((p.expmask & ((i) >= (31) ? 0x80000000 : (uint)(1) << i)) != 0))
			{
				p.expired = (uint)(1);
			}

			return (int)(0);
		}
		public static void versionFunc(sqlite3_context context, int NotUsed, sqlite3_value NotUsed2)
		{
			(void)(NotUsed) ,  (void)(NotUsed2);
			sqlite3_result_text(context, sqlite3_libversion(), (int)(-1), null);
		}
		public static void vfsUnlink(sqlite3_vfs pVfs)
		{

			if ((pVfs) == (null))
			{
			}
			else if ((vfsList) == (pVfs))
			{
				vfsList = pVfs.pNext;
			}
			else if ((vfsList) != null)
			{
				sqlite3_vfs p = vfsList;
				while (((p.pNext) != null) && (p.pNext != pVfs))
				{
					p = p.pNext;
				}

				if ((p.pNext) == (pVfs))
				{
					p.pNext = pVfs.pNext;
				}
			}
		}
		public static int vtabBestIndex(Parse pParse, Table pTab, sqlite3_index_info* p)
		{
			sqlite3_vtab pVtab = sqlite3GetVTable(pParse.db, pTab).pVtab;
			int rc = 0;
			pParse.db.nSchemaLock++;
			rc = (int)(pVtab.pModule.xBestIndex(pVtab, p));
			pParse.db.nSchemaLock--;
			if ((rc != 0) && (rc != 19))
			{
				if ((rc) == (7))
				{
					sqlite3OomFault(pParse.db);
				}
				else if (pVtab.zErrMsg == null)
				{
					sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr((int)(rc)));
				}
				else
				{
					sqlite3ErrorMsg(pParse, "%s", pVtab.zErrMsg);
				}
			}

			sqlite3_free(pVtab.zErrMsg);
			pVtab.zErrMsg = null;
			return (int)(rc);
		}
		public static int vtabCallConstructor(sqlite3 db, Table pTab, Module pMod, delegate21 xConstruct, sbyte** pzErr)
		{
			VtabCtx sCtx = new VtabCtx();
			VTable pVTable;
			int rc = 0;
			sbyte** azArg;
			int nArg = (int)(pTab.u.vtab.nArg);
			sbyte* zErr = null;
			sbyte* zModuleName;
			int iDb = 0;
			VtabCtx pCtx;

			azArg = pTab.u.vtab.azArg;
			for (pCtx = db.pVtabCtx; pCtx; pCtx = pCtx.pPrior)
			{
				if ((pCtx.pTab) == (pTab))
				{
					*pzErr = sqlite3MPrintf(db, "vtable constructor called recursively: %s", pTab.zName);
					return (int)(6);
				}
			}

			zModuleName = sqlite3DbStrDup(db, pTab.zName);
			if (zModuleName == null)
			{
				return (int)(7);
			}

			pVTable = sqlite3MallocZero((ulong)(sizeof(VTable)));
			if (pVTable == null)
			{
				sqlite3OomFault(db);
				sqlite3DbFree(db, zModuleName);
				return (int)(7);
			}

			pVTable.db = db;
			pVTable.pMod = pMod;
			pVTable.eVtabRisk = (byte)(1);
			iDb = (int)(sqlite3SchemaToIndex(db, pTab.pSchema));
			pTab.u.vtab.azArg[1] = db.aDb[iDb].zDbSName;


			sCtx.pTab = pTab;
			sCtx.pVTable = pVTable;
			sCtx.pPrior = db.pVtabCtx;
			sCtx.bDeclared = (int)(0);
			db.pVtabCtx = sCtx;
			rc = (int)(xConstruct(db, pMod.pAux, (int)(nArg), azArg, pVTable.pVtab, &zErr));
			db.pVtabCtx = sCtx.pPrior;
			if ((rc) == (7))
				sqlite3OomFault(db);

			if (0 != rc)
			{
				if ((zErr) == (null))
				{
					*pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
				}
				else
				{
					*pzErr = sqlite3MPrintf(db, "%s", zErr);
					sqlite3_free(zErr);
				}

				sqlite3DbFree(db, pVTable);
			}
			else if ((pVTable.pVtab) != null)
			{
				CRuntime.memset(pVTable.pVtab, (int)(0), (ulong)(sizeof(sqlite3_vtab)));
				pVTable.pVtab.pModule = pMod.pModule;
				pMod.nRefModule++;
				pVTable.nRef = (int)(1);
				if ((sCtx.bDeclared) == (0))
				{
					sbyte* zFormat = "vtable constructor did not declare schema: %s";
					*pzErr = sqlite3MPrintf(db, zFormat, pTab.zName);
					sqlite3VtabUnlock(pVTable);
					rc = (int)(1);
				}
				else
				{
					int iCol = 0;
					ushort oooHidden = (ushort)(0);
					pVTable.pNext = pTab.u.vtab.p;
					pTab.u.vtab.p = pVTable;
					for (iCol = (int)(0); (iCol) < (pTab.nCol); iCol++)
					{
						sbyte* zType = sqlite3ColumnType(&pTab.aCol[iCol], "");
						int nType = 0;
						int i = (int)(0);
						nType = (int)(sqlite3Strlen30(zType));
						for (i = (int)(0); (i) < (nType); i++)
						{
							if ((((0) == (sqlite3_strnicmp("hidden", &zType[i], (int)(6)))) && (((i) == (0)) || ((zType[i - 1]) == (32)))) && (((zType[i + 6]) == (0)) || ((zType[i + 6]) == (32))))
							{
								break;
							}
						}

						if ((i) < (nType))
						{
							int j = 0;
							int nDel = (int)(6 + ((zType[i + 6]) != 0 ? 1 : 0));
							for (j = (int)(i); (j + nDel) <= (nType); j++)
							{
								zType[j] = (sbyte)(zType[j + nDel]);
							}

							if (((zType[i]) == (0)) && ((i) > (0)))
							{

								zType[i - 1] = (sbyte)(0);
							}

							pTab.aCol[iCol].colFlags |= (ushort)(0x0002);
							pTab.tabFlags |= (uint)(0x00000002);
							oooHidden = (ushort)(0x00000400);
						}
						else
						{
							pTab.tabFlags |= (uint)(oooHidden);
						}
					}
				}
			}

			sqlite3DbFree(db, zModuleName);
			return (int)(rc);
		}
		public static VTable vtabDisconnectAll(sqlite3 db, Table p)
		{
			VTable pRet = null;
			VTable pVTable;

			pVTable = p.u.vtab.p;
			p.u.vtab.p = null;

			while ((pVTable) != null)
			{
				sqlite3 db2 = pVTable.db;
				VTable pNext = pVTable.pNext;

				if ((db2) == (db))
				{
					pRet = pVTable;
					p.u.vtab.p = pRet;
					pRet.pNext = null;
				}
				else
				{
					pVTable.pNext = db2.pDisconnect;
					db2.pDisconnect = pVTable;
				}

				pVTable = pNext;
			}


			return pRet;
		}
		public static int walBeginShmUnreliable(Wal pWal, int* pChanged)
		{
			long szWal = 0;
			long iOffset = 0;
			byte* aBuf = stackalloc byte[32];
			byte* aFrame = null;
			int szFrame = 0;
			byte* aData;
			void* pDummy;
			int rc = 0;
			uint* aSaveCksum = stackalloc uint[2];



			rc = (int)(walLockShared(pWal, (int)(3 + (0))));
			if (rc != 0)
			{
				if ((rc) == (5))
					rc = (int)(-1);
				goto begin_unreliable_shm_out;
			}

			pWal.readLock = (short)(0);
			rc = (int)(sqlite3OsShmMap(pWal.pDbFd, (int)(0), (int)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)), (int)(0), &pDummy));

			if (rc != (8 | (5 << 8)))
			{
				rc = (int)((rc) == (8) ? (-1) : rc);
				goto begin_unreliable_shm_out;
			}

			CRuntime.memcpy(&pWal.hdr, (void*)(walIndexHdr(pWal)), (ulong)(sizeof(WalIndexHdr)));
			rc = (int)(sqlite3OsFileSize(pWal.pWalFd, &szWal));
			if (rc != 0)
			{
				goto begin_unreliable_shm_out;
			}

			if ((szWal) < (32))
			{
				*pChanged = (int)(1);
				rc = (int)((pWal.hdr.mxFrame) == (0) ? 0 : (-1));
				goto begin_unreliable_shm_out;
			}

			rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(32), (long)(0)));
			if (rc != 0)
			{
				goto begin_unreliable_shm_out;
			}

			if ((memcmp(&pWal.hdr.aSalt, &aBuf[16], (ulong)(8))) != 0)
			{
				rc = (int)(-1);
				goto begin_unreliable_shm_out;
			}



			szFrame = (int)(pWal.szPage + 24);
			aFrame = (byte*)(sqlite3_malloc64((ulong)(szFrame)));
			if ((aFrame) == (null))
			{
				rc = (int)(7);
				goto begin_unreliable_shm_out;
			}

			aData = &aFrame[24];
			aSaveCksum[0] = (uint)(pWal.hdr.aFrameCksum[0]);
			aSaveCksum[1] = (uint)(pWal.hdr.aFrameCksum[1]);
			for (iOffset = (long)(32 + ((pWal.hdr.mxFrame + 1) - 1) * (long)((pWal.szPage) + 24)); (iOffset + szFrame) <= (szWal); iOffset += (long)(szFrame))
			{
				uint pgno = 0;
				uint nTruncate = 0;
				rc = (int)(sqlite3OsRead(pWal.pWalFd, aFrame, (int)(szFrame), (long)(iOffset)));
				if (rc != 0)
					break;
				if (walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) == 0)
					break;
				if ((nTruncate) != 0)
				{
					rc = (int)(-1);
					break;
				}
			}

			pWal.hdr.aFrameCksum[0] = (uint)(aSaveCksum[0]);
			pWal.hdr.aFrameCksum[1] = (uint)(aSaveCksum[1]);
		begin_unreliable_shm_out:
			; sqlite3_free(aFrame);
			if (rc != 0)
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWal.nWiData); i++)
				{
					sqlite3_free((void*)(pWal.apWiData[i]));
					pWal.apWiData[i] = null;
				}

				pWal.bShmUnreliable = (byte)(0);
				sqlite3WalEndReadTransaction(pWal);
				*pChanged = (int)(1);
			}

			return (int)(rc);
		}
		public static int walBusyLock(Wal pWal, delegate19 xBusy, void* pBusyArg, int lockIdx, int n)
		{
			int rc = 0;
			do
			{
				rc = (int)(walLockExclusive(pWal, (int)(lockIdx), (int)(n)));
			}
			while ((((xBusy) != null) && ((rc) == (5))) && ((xBusy(pBusyArg)) != 0));
			return (int)(rc);
		}
		public static int walCheckpoint(Wal pWal, sqlite3 db, int eMode, delegate19 xBusy, void* pBusyArg, int sync_flags, byte* zBuf)
		{
			int rc = (int)(0);
			int szPage = 0;
			WalIterator pIter = null;
			uint iDbpage = (uint)(0);
			uint iFrame = (uint)(0);
			uint mxSafeFrame = 0;
			uint mxPage = 0;
			int i = 0;
			volatile WalCkptInfo* pInfo;
			szPage = (int)(walPagesize(pWal));
			pInfo = walCkptInfo(pWal);
			if ((pInfo->nBackfill) < (pWal.hdr.mxFrame))
			{

				mxSafeFrame = (uint)(pWal.hdr.mxFrame);
				mxPage = (uint)(pWal.hdr.nPage);
				for (i = (int)(1); (i) < (8 - 3); i++)
				{
					uint y = (uint)(0);
					if ((mxSafeFrame) > (y))
					{

						rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (i)), (int)(1)));
						if ((rc) == (0))
						{
							uint iMark = (uint)((i) == (1) ? mxSafeFrame : 0xffffffff);
							(iMark);
							walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1));
						}
						else if ((rc) == (5))
						{
							mxSafeFrame = (uint)(y);
							xBusy = null;
						}
						else
						{
							goto walcheckpoint_out;
						}
					}
				}

				if ((pInfo->nBackfill) < (mxSafeFrame))
				{
					rc = (int)(walIteratorInit(pWal, (uint)(pInfo->nBackfill), pIter));

				}

				if (((pIter) != null) && ((rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (0)), (int)(1)))) == (0)))
				{
					uint nBackfill = (uint)(pInfo->nBackfill);
					pInfo->nBackfillAttempted = (uint)(mxSafeFrame);
					rc = (int)(sqlite3OsSync(pWal.pWalFd, (int)(((sync_flags) >> 2) & 0x03)));
					if ((rc) == (0))
					{
						long nReq = (long)((long)(mxPage) * szPage);
						long nSize = 0;
						sqlite3OsFileControl(pWal.pDbFd, (int)(39), null);
						rc = (int)(sqlite3OsFileSize(pWal.pDbFd, &nSize));
						if (((rc) == (0)) && ((nSize) < (nReq)))
						{
							if ((nSize + 65536 + (long)(pWal.hdr.mxFrame) * szPage) < (nReq))
							{
								rc = (int)(sqlite3CorruptError((int)(63070)));
							}
							else
							{
								sqlite3OsFileControlHint(pWal.pDbFd, (int)(5), &nReq);
							}
						}
					}

					while (((rc) == (0)) && ((0) == (walIteratorNext(pIter, &iDbpage, &iFrame))))
					{
						long iOffset = 0;

						if ((0) != 0)
						{
							rc = (int)((db.mallocFailed) != 0 ? 7 : 9);
							break;
						}

						if ((((iFrame) <= (nBackfill)) || ((iFrame) > (mxSafeFrame))) || ((iDbpage) > (mxPage)))
						{
							continue;
						}

						iOffset = (long)((32 + ((iFrame) - 1) * (long)((szPage) + 24)) + 24);
						rc = (int)(sqlite3OsRead(pWal.pWalFd, zBuf, (int)(szPage), (long)(iOffset)));
						if (rc != 0)
							break;
						iOffset = (long)((iDbpage - 1) * (long)(szPage));
						rc = (int)(sqlite3OsWrite(pWal.pDbFd, zBuf, (int)(szPage), (long)(iOffset)));
						if (rc != 0)
							break;
					}

					sqlite3OsFileControl(pWal.pDbFd, (int)(37), null);
					if ((rc) == (0))
					{
						if ((mxSafeFrame) == (walIndexHdr(pWal)->mxFrame))
						{
							long szDb = (long)(pWal.hdr.nPage * (long)(szPage));
							rc = (int)(sqlite3OsTruncate(pWal.pDbFd, (long)(szDb)));
							if ((rc) == (0))
							{
								rc = (int)(sqlite3OsSync(pWal.pDbFd, (int)(((sync_flags) >> 2) & 0x03)));
							}
						}

						if ((rc) == (0))
						{
							(mxSafeFrame);
						}
					}

					walUnlockExclusive(pWal, (int)(3 + (0)), (int)(1));
				}

				if ((rc) == (5))
				{
					rc = (int)(0);
				}
			}

			if (((rc) == (0)) && (eMode != 0))
			{

				if ((pInfo->nBackfill) < (pWal.hdr.mxFrame))
				{
					rc = (int)(5);
				}
				else if ((eMode) >= (2))
				{
					uint salt1 = 0;
					sqlite3_randomness((int)(4), &salt1);

					rc = (int)(walBusyLock(pWal, xBusy, pBusyArg, (int)(3 + (1)), (int)((8 - 3) - 1)));
					if ((rc) == (0))
					{
						if ((eMode) == (3))
						{
							walRestartHdr(pWal, (uint)(salt1));
							rc = (int)(sqlite3OsTruncate(pWal.pWalFd, (long)(0)));
						}

						walUnlockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1));
					}
				}
			}

		walcheckpoint_out:
			; walIteratorFree(pIter);
			return (int)(rc);
		}
		public static void walChecksumBytes(int nativeCksum, byte* a, int nByte, uint* aIn, uint* aOut)
		{
			uint s1 = 0; uint s2 = 0;
			uint* aData = (uint*)(a);
			uint* aEnd = (uint*)(&a[nByte]);
			if ((aIn) != null)
			{
				s1 = (uint)(aIn[0]);
				s2 = (uint)(aIn[1]);
			}
			else
			{
				s1 = (uint)(s2 = (uint)(0));
			}




			if ((nativeCksum) != 0)
			{
				do
				{
					s1 += (uint)(*aData++ + s2);
					s2 += (uint)(*aData++ + s1);
				}
				while ((aData) < (aEnd));
			}
			else
			{
				do
				{
					s1 += (uint)(((((aData[0]) & 0x000000FF) << 24) + (((aData[0]) & 0x0000FF00) << 8) + (((aData[0]) & 0x00FF0000) >> 8) + (((aData[0]) & 0xFF000000) >> 24)) + s2);
					s2 += (uint)(((((aData[1]) & 0x000000FF) << 24) + (((aData[1]) & 0x0000FF00) << 8) + (((aData[1]) & 0x00FF0000) >> 8) + (((aData[1]) & 0xFF000000) >> 24)) + s1);
					aData += 2;
				}
				while ((aData) < (aEnd));
			}

			aOut[0] = (uint)(s1);
			aOut[1] = (uint)(s2);
		}
		public static volatile WalCkptInfo* walCkptInfo(Wal pWal)
		{

			return ( volatile WalCkptInfo* ) (&(pWal.apWiData[0][sizeof(WalIndexHdr) / 2]));
		}
		public static void walCleanupHash(Wal pWal)
		{
			WalHashLoc sLoc = new WalHashLoc();
			int iLimit = (int)(0);
			int nByte = 0;
			int i = 0;

			if ((pWal.hdr.mxFrame) == (0))
				return;


			i = (int)(walHashGet(pWal, (int)(walFramePage((uint)(pWal.hdr.mxFrame))), &sLoc));
			if ((i) != 0)
				return;
			iLimit = (int)(pWal.hdr.mxFrame - sLoc.iZero);

			for (i = (int)(0); (i) < (4096 * 2); i++)
			{
				if ((sLoc.aHash[i]) > (iLimit))
				{
					sLoc.aHash[i] = (ushort)(0);
				}
			}

			nByte = ((int)((sbyte*)(sLoc.aHash) - (sbyte*)(&sLoc.aPgno[iLimit])));

			CRuntime.memset((void*)(&sLoc.aPgno[iLimit]), (int)(0), (ulong)(nByte));
		}
		public static int walDecodeFrame(Wal pWal, uint* piPage, uint* pnTruncate, byte* aData, byte* aFrame)
		{
			int nativeCksum = 0;
			uint* aCksum = pWal.hdr.aFrameCksum;
			uint pgno = 0;

			if (memcmp(&pWal.hdr.aSalt, &aFrame[8], (ulong)(8)) != 0)
			{
				return (int)(0);
			}

			pgno = (uint)(sqlite3Get4byte(&aFrame[0]));
			if ((pgno) == (0))
			{
				return (int)(0);
			}

			nativeCksum = (int)((pWal.hdr.bigEndCksum) == (0) ? 1 : 0);
			walChecksumBytes((int)(nativeCksum), aFrame, (int)(8), aCksum, aCksum);
			walChecksumBytes((int)(nativeCksum), aData, (int)(pWal.szPage), aCksum, aCksum);
			if ((aCksum[0] != sqlite3Get4byte(&aFrame[16])) || (aCksum[1] != sqlite3Get4byte(&aFrame[20])))
			{
				return (int)(0);
			}

			*piPage = (uint)(pgno);
			*pnTruncate = (uint)(sqlite3Get4byte(&aFrame[4]));
			return (int)(1);
		}
		public static void walEncodeFrame(Wal pWal, uint iPage, uint nTruncate, byte* aData, byte* aFrame)
		{
			int nativeCksum = 0;
			uint* aCksum = pWal.hdr.aFrameCksum;

			sqlite3Put4byte(&aFrame[0], (uint)(iPage));
			sqlite3Put4byte(&aFrame[4], (uint)(nTruncate));
			if ((pWal.iReCksum) == (0))
			{
				CRuntime.memcpy(&aFrame[8], pWal.hdr.aSalt, (ulong)(8));
				nativeCksum = (int)((pWal.hdr.bigEndCksum) == (0) ? 1 : 0);
				walChecksumBytes((int)(nativeCksum), aFrame, (int)(8), aCksum, aCksum);
				walChecksumBytes((int)(nativeCksum), aData, (int)(pWal.szPage), aCksum, aCksum);
				sqlite3Put4byte(&aFrame[16], (uint)(aCksum[0]));
				sqlite3Put4byte(&aFrame[20], (uint)(aCksum[1]));
			}
			else
			{
				CRuntime.memset(&aFrame[8], (int)(0), (ulong)(16));
			}
		}
		public static int walFramePage(uint iFrame)
		{
			int iHash = (int)((iFrame + 4096 - (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) - 1) / 4096);


			return (int)(iHash);
		}
		public static uint walFramePgno(Wal pWal, uint iFrame)
		{
			int iHash = (int)(walFramePage((uint)(iFrame)));
			if ((iHash) == (0))
			{
				return (uint)(pWal.apWiData[0][(sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint) + iFrame - 1]);
			}

			return (uint)(pWal.apWiData[iHash][(iFrame - 1 - (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint)))) % 4096]);
		}
		public static int walHash(uint iPage)
		{


			return (int)((iPage * 383) & ((4096 * 2) - 1));
		}
		public static int walHashGet(Wal pWal, int iHash, WalHashLoc* pLoc)
		{
			int rc = 0;
			rc = (int)(walIndexPage(pWal, (int)(iHash), &pLoc->aPgno));

			if ((pLoc->aPgno) != null)
			{
				pLoc->aHash = (ushort*)(&pLoc->aPgno[4096]);
				if ((iHash) == (0))
				{
					pLoc->aPgno = &pLoc->aPgno[(sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint)];
					pLoc->iZero = (uint)(0);
				}
				else
				{
					pLoc->iZero = (uint)((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + (iHash - 1) * 4096);
				}
			}
			else if (((rc) == (0)))
			{
				rc = (int)(1);
			}

			return (int)(rc);
		}
		public static int walIndexAppend(Wal pWal, uint iFrame, uint iPage)
		{
			int rc = 0;
			WalHashLoc sLoc = new WalHashLoc();
			rc = (int)(walHashGet(pWal, (int)(walFramePage((uint)(iFrame))), &sLoc));
			if ((rc) == (0))
			{
				int iKey = 0;
				int idx = 0;
				int nCollide = 0;
				idx = (int)(iFrame - sLoc.iZero);

				if ((idx) == (1))
				{
					int nByte = (int)((byte*)(&sLoc.aHash[(4096 * 2)]) - (byte*)(sLoc.aPgno));

					CRuntime.memset((void*)(sLoc.aPgno), (int)(0), (ulong)(nByte));
				}

				if ((sLoc.aPgno[idx - 1]) != 0)
				{
					walCleanupHash(pWal);

				}

				nCollide = (int)(idx);
				for (iKey = (int)(walHash((uint)(iPage))); sLoc.aHash[iKey]; iKey = (int)(walNextHash((int)(iKey))))
				{
					if ((nCollide--) == (0))
						return (int)(sqlite3CorruptError((int)(62124)));
				}

				sLoc.aPgno[idx - 1] = (uint)(iPage);
				((ushort)(idx));
			}

			return (int)(rc);
		}
		public static void walIndexClose(Wal pWal, int isDelete)
		{
			if (((pWal.exclusiveMode) == (2)) || ((pWal.bShmUnreliable) != 0))
			{
				int i = 0;
				for (i = (int)(0); (i) < (pWal.nWiData); i++)
				{
					sqlite3_free((void*)(pWal.apWiData[i]));
					pWal.apWiData[i] = null;
				}
			}

			if (pWal.exclusiveMode != 2)
			{
				sqlite3OsShmUnmap(pWal.pDbFd, (int)(isDelete));
			}
		}
		public static volatile WalIndexHdr* walIndexHdr(Wal pWal)
		{

			return ( volatile WalIndexHdr* ) (pWal.apWiData[0]);
		}
		public static int walIndexPage(Wal pWal, int iPage, uint** ppPage)
		{
			if (((pWal.nWiData) <= (iPage)) || ((*ppPage = pWal.apWiData[iPage]) == (null)))
			{
				return (int)(walIndexPageRealloc(pWal, (int)(iPage), ppPage));
			}

			return (int)(0);
		}
		public static int walIndexPageRealloc(Wal pWal, int iPage, uint** ppPage)
		{
			int rc = (int)(0);
			if ((pWal.nWiData) <= (iPage))
			{
				long nByte = (long)(sizeof(uint) * (iPage + 1));
				uint** apNew;
				apNew = (uint**)(sqlite3Realloc((void*)(pWal.apWiData), (ulong)(nByte)));
				if (apNew == null)
				{
					*ppPage = null;
					return (int)(7);
				}

				CRuntime.memset((void*)(&apNew[pWal.nWiData]), (int)(0), (ulong)(sizeof(uint) * (iPage + 1 - pWal.nWiData)));
				pWal.apWiData = apNew;
				pWal.nWiData = (int)(iPage + 1);
			}


			if ((pWal.exclusiveMode) == (2))
			{
				pWal.apWiData[iPage] = (uint*)(sqlite3MallocZero((ulong)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint))));
				if (pWal.apWiData[iPage] == null)
					rc = (int)(7);
			}
			else
			{
				rc = (int)(sqlite3OsShmMap(pWal.pDbFd, (int)(iPage), (int)(sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)), (int)(pWal.writeLock), (void**)(&pWal.apWiData[iPage])));

				if ((rc) == (0))
				{
					if (((iPage) > (0)) && ((sqlite3FaultSim((int)(600))) != 0))
						rc = (int)(7);
				}
				else if ((rc & 0xff) == (8))
				{
					pWal.readOnly |= (byte)(2);
					if ((rc) == (8))
					{
						rc = (int)(0);
					}
				}
			}

			*ppPage = pWal.apWiData[iPage];

			return (int)(rc);
		}
		public static int walIndexReadHdr(Wal pWal, int* pChanged)
		{
			int rc = 0;
			int badHdr = 0;
			uint* page0;

			rc = (int)(walIndexPage(pWal, (int)(0), &page0));
			if (rc != 0)
			{

				if ((rc) == (8 | (5 << 8)))
				{



					pWal.bShmUnreliable = (byte)(1);
					pWal.exclusiveMode = (byte)(2);
					*pChanged = (int)(1);
				}
				else
				{
					return (int)(rc);
				}
			}
			else
			{
			}


			badHdr = (int)((page0) != 0 ? walIndexTryHdr(pWal, pChanged) : 1);
			if ((badHdr) != 0)
			{
				if (((pWal.bShmUnreliable) == (0)) && ((pWal.readOnly & 2) != 0))
				{
					if ((0) == (rc = (int)(walLockShared(pWal, (int)(0)))))
					{
						walUnlockShared(pWal, (int)(0));
						rc = (int)(8 | (1 << 8));
					}
				}
				else
				{
					int bWriteLock = (int)(pWal.writeLock);
					if (((bWriteLock) != 0) || ((0) == (rc = (int)(walLockExclusive((pWal), (int)(0), (int)(1))))))
					{
						pWal.writeLock = (byte)(1);
						if ((0) == (rc = (int)(walIndexPage(pWal, (int)(0), &page0))))
						{
							badHdr = (int)(walIndexTryHdr(pWal, pChanged));
							if ((badHdr) != 0)
							{
								rc = (int)(walIndexRecover(pWal));
								*pChanged = (int)(1);
							}
						}

						if ((bWriteLock) == (0))
						{
							pWal.writeLock = (byte)(0);
							walUnlockExclusive(pWal, (int)(0), (int)(1));
						}
					}
				}
			}

			if (((badHdr) == (0)) && (pWal.hdr.iVersion != 3007000))
			{
				rc = (int)(sqlite3CantopenError((int)(63419)));
			}

			if ((pWal.bShmUnreliable) != 0)
			{
				if (rc != 0)
				{
					walIndexClose(pWal, (int)(0));
					pWal.bShmUnreliable = (byte)(0);

					if ((rc) == (10 | (2 << 8)))
						rc = (int)(-1);
				}

				pWal.exclusiveMode = (byte)(0);
			}

			return (int)(rc);
		}
		public static int walIndexRecover(Wal pWal)
		{
			int rc = 0;
			long nSize = 0;
			uint* aFrameCksum = stackalloc uint[] { 0, 0 };
			int iLock = 0;




			iLock = (int)(1 + pWal.ckptLock);
			rc = (int)(walLockExclusive(pWal, (int)(iLock), (int)((3 + (0)) - iLock)));
			if ((rc) != 0)
			{
				return (int)(rc);
			}

			CRuntime.memset(&pWal.hdr, (int)(0), (ulong)(sizeof(WalIndexHdr)));
			rc = (int)(sqlite3OsFileSize(pWal.pWalFd, &nSize));
			if (rc != 0)
			{
				goto recovery_error;
			}

			if ((nSize) > (32))
			{
				byte* aBuf = stackalloc byte[32];
				uint* aPrivate = null;
				byte* aFrame = null;
				int szFrame = 0;
				byte* aData;
				int szPage = 0;
				uint magic = 0;
				uint version = 0;
				int isValid = 0;
				uint iPg = 0;
				uint iLastFrame = 0;
				rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(32), (long)(0)));
				if (rc != 0)
				{
					goto recovery_error;
				}

				magic = (uint)(sqlite3Get4byte(&aBuf[0]));
				szPage = (int)(sqlite3Get4byte(&aBuf[8]));
				if (((((magic & 0xFFFFFFFE) != 0x377f0682) || ((szPage & (szPage - 1)) != 0)) || ((szPage) > (65536))) || ((szPage) < (512)))
				{
					goto finished;
				}

				pWal.hdr.bigEndCksum = ((byte)(magic & 0x00000001));
				pWal.szPage = (uint)(szPage);
				pWal.nCkpt = (uint)(sqlite3Get4byte(&aBuf[12]));
				CRuntime.memcpy(&pWal.hdr.aSalt, &aBuf[16], (ulong)(8));
				walChecksumBytes(((pWal.hdr.bigEndCksum) == (0) ? 1 : 0), aBuf, (int)(32 - 2 * 4), null, pWal.hdr.aFrameCksum);
				if ((pWal.hdr.aFrameCksum[0] != sqlite3Get4byte(&aBuf[24])) || (pWal.hdr.aFrameCksum[1] != sqlite3Get4byte(&aBuf[28])))
				{
					goto finished;
				}

				version = (uint)(sqlite3Get4byte(&aBuf[4]));
				if (version != 3007000)
				{
					rc = (int)(sqlite3CantopenError((int)(62256)));
					goto finished;
				}

				szFrame = (int)(szPage + 24);
				aFrame = (byte*)(sqlite3_malloc64((ulong)(szFrame + (sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)))));
				if (aFrame == null)
				{
					rc = (int)(7);
					goto recovery_error;
				}

				aData = &aFrame[24];
				aPrivate = (uint*)(&aData[szPage]);
				iLastFrame = (uint)((nSize - 32) / szFrame);
				for (iPg = (uint)(0); (iPg) <= ((uint)(walFramePage((uint)(iLastFrame)))); iPg++)
				{
					uint* aShare;
					uint iFrame = 0;
					uint iLast = (uint)((iLastFrame) < ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + iPg * 4096) ? (iLastFrame) : ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + iPg * 4096));
					uint iFirst = (uint)(1 + ((iPg) == (0) ? 0 : (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(uint))) + (iPg - 1) * 4096));
					uint nHdr = 0;
					uint nHdr32 = 0;
					rc = (int)(walIndexPage(pWal, (int)(iPg), &aShare));

					if ((aShare) == (null))
						break;
					pWal.apWiData[iPg] = aPrivate;
					for (iFrame = (uint)(iFirst); (iFrame) <= (iLast); iFrame++)
					{
						long iOffset = (long)(32 + ((iFrame) - 1) * (long)((szPage) + 24));
						uint pgno = 0;
						uint nTruncate = 0;
						rc = (int)(sqlite3OsRead(pWal.pWalFd, aFrame, (int)(szFrame), (long)(iOffset)));
						if (rc != 0)
							break;
						isValid = (int)(walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame));
						if (isValid == 0)
							break;
						rc = (int)(walIndexAppend(pWal, (uint)(iFrame), (uint)(pgno)));
						if ((rc != 0))
							break;
						if ((nTruncate) != 0)
						{
							pWal.hdr.mxFrame = (uint)(iFrame);
							pWal.hdr.nPage = (uint)(nTruncate);
							pWal.hdr.szPage = ((ushort)((szPage & 0xff00) | (szPage >> 16)));
							aFrameCksum[0] = (uint)(pWal.hdr.aFrameCksum[0]);
							aFrameCksum[1] = (uint)(pWal.hdr.aFrameCksum[1]);
						}
					}

					pWal.apWiData[iPg] = aShare;
					nHdr = (uint)((iPg) == (0) ? (sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) : 0);
					nHdr32 = (uint)(nHdr / sizeof(uint));
					CRuntime.memcpy(&aShare[nHdr32], &aPrivate[nHdr32], (ulong)((sizeof(ushort) * (4096 * 2) + 4096 * sizeof(uint)) - nHdr));
					if ((iFrame) <= (iLast))
						break;
				}

				sqlite3_free(aFrame);
			}

		finished:
			; if ((rc) == (0)) { volatile WalCkptInfo* pInfo; int i = 0; pWal.hdr.aFrameCksum[0] = (uint)(aFrameCksum[0]); pWal.hdr.aFrameCksum[1] = (uint)(aFrameCksum[1]); walIndexWriteHdr(pWal); pInfo = walCkptInfo(pWal); pInfo->nBackfill = (uint)(0); pInfo->nBackfillAttempted = (uint)(pWal.hdr.mxFrame); pInfo->aReadMark[0] = (uint)(0); for (i = (int)(1); (i) < (8 - 3); i++) { rc = (int)(walLockExclusive(pWal, (int)(3 + (i)), (int)(1))); if ((rc) == (0)) { if (((i) == (1)) && ((pWal.hdr.mxFrame) != 0)) { pInfo->aReadMark[i] = (uint)(pWal.hdr.mxFrame); } else { pInfo->aReadMark[i] = (uint)(0xffffffff); } walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1)); } else if (rc != 5) { goto recovery_error; } } if ((pWal.hdr.nPage) != 0) { sqlite3_log((int)(27 | (1 << 8)), "recovered %d frames from WAL file %s", (uint)(pWal.hdr.mxFrame), pWal.zWalName); } }
		recovery_error:
			;
			walUnlockExclusive(pWal, (int)(iLock), (int)((3 + (0)) - iLock));
			return (int)(rc);
		}
		public static int walIndexTryHdr(Wal pWal, int* pChanged)
		{
			uint* aCksum = stackalloc uint[2];
			WalIndexHdr h1 = new WalIndexHdr(); WalIndexHdr h2 = new WalIndexHdr();
			volatile WalIndexHdr* aHdr;

			aHdr = walIndexHdr(pWal);
			CRuntime.memcpy(&h1, (void*)(&aHdr[0]), (ulong)(sizeof(WalIndexHdr)));
			walShmBarrier(pWal);
			CRuntime.memcpy(&h2, (void*)(&aHdr[1]), (ulong)(sizeof(WalIndexHdr)));
			if (memcmp(&h1, &h2, (ulong)(sizeof(WalIndexHdr))) != 0)
			{
				return (int)(1);
			}

			if ((h1.isInit) == (0))
			{
				return (int)(1);
			}

			walChecksumBytes((int)(1), (byte*)(&h1), (int)(sizeof(WalIndexHdr) - 2 * sizeof(uint)), null, aCksum);
			if ((aCksum[0] != h1.aCksum[0]) || (aCksum[1] != h1.aCksum[1]))
			{
				return (int)(1);
			}

			if ((memcmp(&pWal.hdr, &h1, (ulong)(sizeof(WalIndexHdr)))) != 0)
			{
				*pChanged = (int)(1);
				CRuntime.memcpy(&pWal.hdr, &h1, (ulong)(sizeof(WalIndexHdr)));
				pWal.szPage = (uint)((pWal.hdr.szPage & 0xfe00) + ((pWal.hdr.szPage & 0x0001) << 16));
			}

			return (int)(0);
		}
		public static void walIndexWriteHdr(Wal pWal)
		{
			volatile WalIndexHdr* aHdr = walIndexHdr(pWal);
			int nCksum = (int)((ulong)(&((0)->aCksum)));

			pWal.hdr.isInit = (byte)(1);
			pWal.hdr.iVersion = (uint)(3007000);
			walChecksumBytes((int)(1), (byte*)(&pWal.hdr), (int)(nCksum), null, pWal.hdr.aCksum);
			CRuntime.memcpy((void*)(&aHdr[1]), (void*)(&pWal.hdr), (ulong)(sizeof(WalIndexHdr)));
			walShmBarrier(pWal);
			CRuntime.memcpy((void*)(&aHdr[0]), (void*)(&pWal.hdr), (ulong)(sizeof(WalIndexHdr)));
		}
		public static void walIteratorFree(WalIterator p)
		{
			sqlite3_free(p);
		}
		public static int walIteratorInit(Wal pWal, uint nBackfill, WalIterator pp)
		{
			WalIterator p;
			int nSegment = 0;
			uint iLast = 0;
			long nByte = 0;
			int i = 0;
			ushort* aTmp;
			int rc = (int)(0);

			iLast = (uint)(pWal.hdr.mxFrame);
			nSegment = (int)(walFramePage((uint)(iLast)) + 1);
			nByte = (long)(sizeof(WalIterator) + (nSegment - 1) * sizeof(WalSegment) + iLast * sizeof(ushort));
			p = (WalIterator)(sqlite3_malloc64((ulong)(nByte)));
			if (p == null)
			{
				return (int)(7);
			}

			CRuntime.memset(p, (int)(0), (ulong)(nByte));
			p.nSegment = (int)(nSegment);
			aTmp = (ushort*)(sqlite3_malloc64((ulong)(sizeof(ushort) * ((iLast) > (4096) ? 4096 : iLast))));
			if (aTmp == null)
			{
				rc = (int)(7);
			}

			for (i = (int)(walFramePage((uint)(nBackfill + 1))); ((rc) == (0)) && ((i) < (nSegment)); i++)
			{
				WalHashLoc sLoc = new WalHashLoc();
				rc = (int)(walHashGet(pWal, (int)(i), &sLoc));
				if ((rc) == (0))
				{
					int j = 0;
					int nEntry = 0;
					ushort* aIndex;
					if ((i + 1) == (nSegment))
					{
						nEntry = ((int)(iLast - sLoc.iZero));
					}
					else
					{
						nEntry = ((int)((uint*)(sLoc.aHash) - sLoc.aPgno));
					}

					aIndex = &((ushort*)(&p.aSegment[p.nSegment]))[sLoc.iZero];
					sLoc.iZero++;
					for (j = (int)(0); (j) < (nEntry); j++)
					{
						aIndex[j] = ((ushort)(j));
					}

					walMergesort(sLoc.aPgno, aTmp, aIndex, &nEntry);
					p.aSegment[i].iZero = (int)(sLoc.iZero);
					p.aSegment[i].nEntry = (int)(nEntry);
					p.aSegment[i].aIndex = aIndex;
					p.aSegment[i].aPgno = sLoc.aPgno;
				}
			}

			sqlite3_free(aTmp);
			if (rc != 0)
			{
				walIteratorFree(p);
				p = null;
			}

			pp = p;
			return (int)(rc);
		}
		public static int walIteratorNext(WalIterator p, uint* piPage, uint* piFrame)
		{
			uint iMin = 0;
			uint iRet = (uint)(0xFFFFFFFF);
			int i = 0;
			iMin = (uint)(p.iPrior);

			for (i = (int)(p.nSegment - 1); (i) >= (0); i--)
			{
				WalSegment* pSegment = &p.aSegment[i];
				while ((pSegment->iNext) < (pSegment->nEntry))
				{
					uint iPg = (uint)(pSegment->aPgno[pSegment->aIndex[pSegment->iNext]]);
					if ((iPg) > (iMin))
					{
						if ((iPg) < (iRet))
						{
							iRet = (uint)(iPg);
							*piFrame = (uint)(pSegment->iZero + pSegment->aIndex[pSegment->iNext]);
						}

						break;
					}

					pSegment->iNext++;
				}
			}

			*piPage = (uint)(p.iPrior = (uint)(iRet));
			return (((iRet) == (0xFFFFFFFF)) ? 1 : 0);
		}
		public static int walkExpr(Walker pWalker, Expr pExpr)
		{
			int rc = 0;
			while ((1) != 0)
			{
				rc = (int)(pWalker.xExprCallback(pWalker, pExpr));
				if ((rc) != 0)
					return (int)(rc & 2);
				if (!(((pExpr).flags & (0x004000 | 0x800000)) != 0))
				{

					if (((pExpr.pLeft) != null) && ((walkExpr(pWalker, pExpr.pLeft)) != 0))
						return (int)(2);
					if ((pExpr.pRight) != null)
					{

						pExpr = pExpr.pRight;
						continue;
					}
					else if ((((pExpr).flags & 0x000800) != 0))
					{

						if ((sqlite3WalkSelect(pWalker, pExpr.x.pSelect)) != 0)
							return (int)(2);
					}
					else
					{
						if ((pExpr.x.pList) != null)
						{
							if ((sqlite3WalkExprList(pWalker, pExpr.x.pList)) != 0)
								return (int)(2);
						}

						if ((((pExpr).flags & (0x1000000)) != 0))
						{
							if ((walkWindowList(pWalker, pExpr.y.pWin, (int)(1))) != 0)
								return (int)(2);
						}
					}
				}

				break;
			}

			return (int)(0);
		}
		public static int walkWindowList(Walker pWalker, Window pList, int bOneOnly)
		{
			Window pWin;
			for (pWin = pList; pWin; pWin = pWin.pNextWin)
			{
				int rc = 0;
				rc = (int)(sqlite3WalkExprList(pWalker, pWin.pOrderBy));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExprList(pWalker, pWin.pPartition));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExpr(pWalker, pWin.pFilter));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExpr(pWalker, pWin.pStart));
				if ((rc) != 0)
					return (int)(2);
				rc = (int)(sqlite3WalkExpr(pWalker, pWin.pEnd));
				if ((rc) != 0)
					return (int)(2);
				if ((bOneOnly) != 0)
					break;
			}

			return (int)(0);
		}
		public static void walLimitSize(Wal pWal, long nMax)
		{
			long sz = 0;
			int rx = 0;
			sqlite3BeginBenignMalloc();
			rx = (int)(sqlite3OsFileSize(pWal.pWalFd, &sz));
			if (((rx) == (0)) && ((sz) > (nMax)))
			{
				rx = (int)(sqlite3OsTruncate(pWal.pWalFd, (long)(nMax)));
			}

			sqlite3EndBenignMalloc();
			if ((rx) != 0)
			{
				sqlite3_log((int)(rx), "cannot limit WAL size: %s", pWal.zWalName);
			}
		}
		public static int walLockExclusive(Wal pWal, int lockIdx, int n)
		{
			int rc = 0;
			if ((pWal.exclusiveMode) != 0)
				return (int)(0);
			rc = (int)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(n), (int)(2 | 8)));
			return (int)(rc);
		}
		public static int walLockShared(Wal pWal, int lockIdx)
		{
			int rc = 0;
			if ((pWal.exclusiveMode) != 0)
				return (int)(0);
			rc = (int)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(1), (int)(2 | 4)));
			return (int)(rc);
		}
		public static void walMerge(uint* aContent, ushort* aLeft, int nLeft, ushort** paRight, int* pnRight, ushort* aTmp)
		{
			int iLeft = (int)(0);
			int iRight = (int)(0);
			int iOut = (int)(0);
			int nRight = (int)(*pnRight);
			ushort* aRight = *paRight;

			while (((iRight) < (nRight)) || ((iLeft) < (nLeft)))
			{
				ushort logpage = 0;
				uint dbpage = 0;
				if (((iLeft) < (nLeft)) && (((iRight) >= (nRight)) || ((aContent[aLeft[iLeft]]) < (aContent[aRight[iRight]]))))
				{
					logpage = (ushort)(aLeft[iLeft++]);
				}
				else
				{
					logpage = (ushort)(aRight[iRight++]);
				}

				dbpage = (uint)(aContent[logpage]);
				aTmp[iOut++] = (ushort)(logpage);
				if (((iLeft) < (nLeft)) && ((aContent[aLeft[iLeft]]) == (dbpage)))
					iLeft++;


			}

			*paRight = aLeft;
			*pnRight = (int)(iOut);
			CRuntime.memcpy(aLeft, aTmp, (ulong)(sizeof(ushort) * iOut));
		}
		public static void walMergesort(uint* aContent, ushort* aBuffer, ushort* aList, int* pnList)
		{
			int nList = (int)(*pnList);
			int nMerge = (int)(0);
			ushort* aMerge = null;
			int iList = 0;
			uint iSub = (uint)(0);
			Sublist* aSub = stackalloc Sublist[13];
			CRuntime.memset(aSub, (int)(0), (ulong)(13 * sizeof(Sublist)));


			for (iList = (int)(0); (iList) < (nList); iList++)
			{
				nMerge = (int)(1);
				aMerge = &aList[iList];
				for (iSub = (uint)(0); iList & (1 << iSub); iSub++)
				{
					Sublist* p;

					p = &aSub[iSub];


					walMerge(aContent, p->aList, (int)(p->nList), &aMerge, &nMerge, aBuffer);
				}

				aSub[iSub].aList = aMerge;
				aSub[iSub].nList = (int)(nMerge);
			}

			for (iSub++; (iSub) < ((int)(13 * sizeof(Sublist) / sizeof(Sublist))); iSub++)
			{
				if ((nList & (1 << iSub)) != 0)
				{
					Sublist* p;

					p = &aSub[iSub];


					walMerge(aContent, p->aList, (int)(p->nList), &aMerge, &nMerge, aBuffer);
				}
			}


			*pnList = (int)(nMerge);
		}
		public static int walNextHash(int iPriorHash)
		{
			return (int)((iPriorHash + 1) & ((4096 * 2) - 1));
		}
		public static int walPagesize(Wal pWal)
		{
			return (int)((pWal.hdr.szPage & 0xfe00) + ((pWal.hdr.szPage & 0x0001) << 16));
		}
		public static void walRestartHdr(Wal pWal, uint salt1)
		{
			volatile WalCkptInfo* pInfo = walCkptInfo(pWal);
			int i = 0;
			uint* aSalt = pWal.hdr.aSalt;
			pWal.nCkpt++;
			pWal.hdr.mxFrame = (uint)(0);
			sqlite3Put4byte((byte*)(&aSalt[0]), (uint)(1 + sqlite3Get4byte((byte*)(&aSalt[0]))));
			CRuntime.memcpy(&pWal.hdr.aSalt[1], &salt1, (ulong)(4));
			walIndexWriteHdr(pWal);
			(0);
			pInfo->nBackfillAttempted = (uint)(0);
			pInfo->aReadMark[1] = (uint)(0);
			for (i = (int)(2); (i) < (8 - 3); i++)
			{
				pInfo->aReadMark[i] = (uint)(0xffffffff);
			}


		}
		public static int walRestartLog(Wal pWal)
		{
			int rc = (int)(0);
			int cnt = 0;
			if ((pWal.readLock) == (0))
			{
				volatile WalCkptInfo* pInfo = walCkptInfo(pWal);

				if ((pInfo->nBackfill) > (0))
				{
					uint salt1 = 0;
					sqlite3_randomness((int)(4), &salt1);
					rc = (int)(walLockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1)));
					if ((rc) == (0))
					{
						walRestartHdr(pWal, (uint)(salt1));
						walUnlockExclusive(pWal, (int)(3 + (1)), (int)((8 - 3) - 1));
					}
					else if (rc != 5)
					{
						return (int)(rc);
					}
				}

				walUnlockShared(pWal, (int)(3 + (0)));
				pWal.readLock = (short)(-1);
				cnt = (int)(0);
				do
				{
					int notUsed = 0;
					rc = (int)(walTryBeginRead(pWal, &notUsed, (int)(1), (int)(++cnt)));
				}
				while ((rc) == (-1));

			}

			return (int)(rc);
		}
		public static int walRewriteChecksums(Wal pWal, uint iLast)
		{
			int szPage = (int)(pWal.szPage);
			int rc = (int)(0);
			byte* aBuf;
			byte* aFrame = stackalloc byte[24];
			uint iRead = 0;
			long iCksumOff = 0;
			aBuf = sqlite3_malloc((int)(szPage + 24));
			if ((aBuf) == (null))
				return (int)(7);

			if ((pWal.iReCksum) == (1))
			{
				iCksumOff = (long)(24);
			}
			else
			{
				iCksumOff = (long)((32 + ((pWal.iReCksum - 1) - 1) * (long)((szPage) + 24)) + 16);
			}

			rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(sizeof(uint) * 2), (long)(iCksumOff)));
			pWal.hdr.aFrameCksum[0] = (uint)(sqlite3Get4byte(aBuf));
			pWal.hdr.aFrameCksum[1] = (uint)(sqlite3Get4byte(&aBuf[sizeof(uint)]));
			iRead = (uint)(pWal.iReCksum);
			pWal.iReCksum = (uint)(0);
			for (; ((rc) == (0)) && ((iRead) <= (iLast)); iRead++)
			{
				long iOff = (long)(32 + ((iRead) - 1) * (long)((szPage) + 24));
				rc = (int)(sqlite3OsRead(pWal.pWalFd, aBuf, (int)(szPage + 24), (long)(iOff)));
				if ((rc) == (0))
				{
					uint iPgno = 0;
					uint nDbSize = 0;
					iPgno = (uint)(sqlite3Get4byte(aBuf));
					nDbSize = (uint)(sqlite3Get4byte(&aBuf[4]));
					walEncodeFrame(pWal, (uint)(iPgno), (uint)(nDbSize), &aBuf[24], aFrame);
					rc = (int)(sqlite3OsWrite(pWal.pWalFd, aFrame, (int)(24 * sizeof(byte)), (long)(iOff)));
				}
			}

			sqlite3_free(aBuf);
			return (int)(rc);
		}
		public static void walShmBarrier(Wal pWal)
		{
			if (pWal.exclusiveMode != 2)
			{
				sqlite3OsShmBarrier(pWal.pDbFd);
			}
		}
		public static int walTryBeginRead(Wal pWal, int* pChanged, int useWal, int cnt)
		{
			volatile WalCkptInfo* pInfo;
			uint mxReadMark = 0;
			int mxI = 0;
			int i = 0;
			int rc = (int)(0);
			uint mxFrame = 0;


			if ((cnt) > (5))
			{
				int nDelay = (int)(1);
				if ((cnt) > (100))
				{
					return (int)(15);
				}

				if ((cnt) >= (10))
					nDelay = (int)((cnt - 9) * (cnt - 9) * 39);
				sqlite3OsSleep(pWal.pVfs, (int)(nDelay));
			}

			if (useWal == 0)
			{

				if ((pWal.bShmUnreliable) == (0))
				{
					rc = (int)(walIndexReadHdr(pWal, pChanged));
				}

				if ((rc) == (5))
				{
					if ((pWal.apWiData[0]) == (null))
					{
						rc = (int)(-1);
					}
					else if ((0) == (rc = (int)(walLockShared(pWal, (int)(2)))))
					{
						walUnlockShared(pWal, (int)(2));
						rc = (int)(-1);
					}
					else if ((rc) == (5))
					{
						rc = (int)(5 | (1 << 8));
					}
				}

				if (rc != 0)
				{
					return (int)(rc);
				}
				else if ((pWal.bShmUnreliable) != 0)
				{
					return (int)(walBeginShmUnreliable(pWal, pChanged));
				}
			}



			pInfo = walCkptInfo(pWal);
			if ((useWal == 0) && ((0) == (pWal.hdr.mxFrame)))
			{
				rc = (int)(walLockShared(pWal, (int)(3 + (0))));
				walShmBarrier(pWal);
				if ((rc) == (0))
				{
					if ((memcmp((void*)(walIndexHdr(pWal)), &pWal.hdr, (ulong)(sizeof(WalIndexHdr)))) != 0)
					{
						walUnlockShared(pWal, (int)(3 + (0)));
						return (int)(-1);
					}

					pWal.readLock = (short)(0);
					return (int)(0);
				}
				else if (rc != 5)
				{
					return (int)(rc);
				}
			}

			mxReadMark = (uint)(0);
			mxI = (int)(0);
			mxFrame = (uint)(pWal.hdr.mxFrame);
			for (i = (int)(1); (i) < (8 - 3); i++)
			{
				uint thisMark = (uint)(0);
				if (((mxReadMark) <= (thisMark)) && ((thisMark) <= (mxFrame)))
				{

					mxReadMark = (uint)(thisMark);
					mxI = (int)(i);
				}
			}

			if (((pWal.readOnly & 2) == (0)) && (((mxReadMark) < (mxFrame)) || ((mxI) == (0))))
			{
				for (i = (int)(1); (i) < (8 - 3); i++)
				{
					rc = (int)(walLockExclusive(pWal, (int)(3 + (i)), (int)(1)));
					if ((rc) == (0))
					{
						(mxFrame);
						mxReadMark = (uint)(mxFrame);
						mxI = (int)(i);
						walUnlockExclusive(pWal, (int)(3 + (i)), (int)(1));
						break;
					}
					else if (rc != 5)
					{
						return (int)(rc);
					}
				}
			}

			if ((mxI) == (0))
			{

				return (int)((rc) == (5) ? (-1) : (8 | (5 << 8)));
			}

			rc = (int)(walLockShared(pWal, (int)(3 + (mxI))));
			if ((rc) != 0)
			{
				return (int)((rc) == (5) ? (-1) : rc);
			}

			pWal.minFrame = (uint)(0 + 1);
			walShmBarrier(pWal);
			if ((0 != mxReadMark) || ((memcmp((void*)(walIndexHdr(pWal)), &pWal.hdr, (ulong)(sizeof(WalIndexHdr)))) != 0))
			{
				walUnlockShared(pWal, (int)(3 + (mxI)));
				return (int)(-1);
			}
			else
			{

				pWal.readLock = ((short)(mxI));
			}

			return (int)(rc);
		}
		public static void walUnlockExclusive(Wal pWal, int lockIdx, int n)
		{
			if ((pWal.exclusiveMode) != 0)
				return;
			(void)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(n), (int)(1 | 8)));
		}
		public static void walUnlockShared(Wal pWal, int lockIdx)
		{
			if ((pWal.exclusiveMode) != 0)
				return;
			(void)(sqlite3OsShmLock(pWal.pDbFd, (int)(lockIdx), (int)(1), (int)(1 | 4)));
		}
		public static int walWriteOneFrame(WalWriter p, PgHdr pPage, int nTruncate, long iOffset)
		{
			int rc = 0;
			void* pData;
			byte* aFrame = stackalloc byte[24];
			pData = pPage.pData;
			walEncodeFrame(p.pWal, (uint)(pPage.pgno), (uint)(nTruncate), pData, aFrame);
			rc = (int)(walWriteToLog(p, aFrame, (int)(24 * sizeof(byte)), (long)(iOffset)));
			if ((rc) != 0)
				return (int)(rc);
			rc = (int)(walWriteToLog(p, pData, (int)(p.szPage), (long)(iOffset + 24 * sizeof(byte))));
			return (int)(rc);
		}
		public static int walWriteToLog(WalWriter p, void* pContent, int iAmt, long iOffset)
		{
			int rc = 0;
			if (((iOffset) < (p.iSyncPoint)) && ((iOffset + iAmt) >= (p.iSyncPoint)))
			{
				int iFirstAmt = (int)(p.iSyncPoint - iOffset);
				rc = (int)(sqlite3OsWrite(p.pFd, pContent, (int)(iFirstAmt), (long)(iOffset)));
				if ((rc) != 0)
					return (int)(rc);
				iOffset += (long)(iFirstAmt);
				iAmt -= (int)(iFirstAmt);
				pContent = (void*)(iFirstAmt + (sbyte*)(pContent));

				rc = (int)(sqlite3OsSync(p.pFd, (int)((p.syncFlags) & 0x03)));
				if (((iAmt) == (0)) || ((rc) != 0))
					return (int)(rc);
			}

			rc = (int)(sqlite3OsWrite(p.pFd, pContent, (int)(iAmt), (long)(iOffset)));
			return (int)(rc);
		}
		public static void whereAddLimitExpr(WhereClause pWC, int iReg, Expr pExpr, int iCsr, int eMatchOp)
		{
			Parse pParse = pWC.pWInfo.pParse;
			sqlite3 db = pParse.db;
			Expr pNew;
			int iVal = (int)(0);
			if (((sqlite3ExprIsInteger(pExpr, &iVal)) != 0) && ((iVal) >= (0)))
			{
				Expr pVal = sqlite3Expr(db, (int)(155), null);
				if ((pVal) == (null))
					return;
				(pVal).flags |= (uint)(0x000400);
				pVal.u.iValue = (int)(iVal);
				pNew = sqlite3PExpr(pParse, (int)(46), null, pVal);
			}
			else
			{
				Expr pVal = sqlite3Expr(db, (int)(176), null);
				if ((pVal) == (null))
					return;
				pVal.iTable = (int)(iReg);
				pNew = sqlite3PExpr(pParse, (int)(46), null, pVal);
			}

			if ((pNew) != null)
			{
				WhereTerm pTerm;
				int idx = 0;
				idx = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0001 | 0x0002)));
				pTerm = pWC.a[idx];
				pTerm.leftCursor = (int)(iCsr);
				pTerm.eOperator = (ushort)(0x0040);
				pTerm.eMatchOp = (byte)(eMatchOp);
			}
		}
		public static void whereAndInfoDelete(sqlite3 db, WhereAndInfo p)
		{
			sqlite3WhereClauseClear(p.wc);
			sqlite3DbFree(db, p);
		}
		public static void whereApplyPartialIndexConstraints(Expr pTruth, int iTabCur, WhereClause pWC)
		{
			int i = 0;
			WhereTerm pTerm;
			while ((pTruth.op) == (44))
			{
				whereApplyPartialIndexConstraints(pTruth.pLeft, (int)(iTabCur), pWC);
				pTruth = pTruth.pRight;
			}

			for (i = (int)(0), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				Expr pExpr;
				if ((pTerm.wtFlags & 0x0004) != 0)
					continue;
				pExpr = pTerm.pExpr;
				if ((sqlite3ExprCompare(null, pExpr, pTruth, (int)(iTabCur))) == (0))
				{
					pTerm.wtFlags |= (ushort)(0x0004);
				}
			}
		}
		public static void whereCheckIfBloomFilterIsUseful(WhereInfo pWInfo)
		{
			int i = 0;
			short nSearch = 0;


			nSearch = (short)(pWInfo.a[0].pWLoop.nOut);
			for (i = (int)(1); (i) < (pWInfo.nLevel); i++)
			{
				WhereLoop pLoop = pWInfo.a[i].pWLoop;
				uint reqFlags = (uint)(0x00800000 | 0x00000001);
				if (((pLoop.wsFlags & reqFlags) == (reqFlags)) && ((pLoop.wsFlags & (0x00000100 | 0x00000200)) != 0))
				{
					SrcItem pItem = pWInfo.pTabList.a[pLoop.iTab];
					Table pTab = pItem.pTab;
					pTab.tabFlags |= (uint)(0x00000100);
					if (((nSearch) > (pTab.nRowLogEst)) && ((pTab.tabFlags & 0x00000010) != 0))
					{
						pLoop.wsFlags |= (uint)(0x00400000);
						pLoop.wsFlags &= (uint)(~0x00000040);
					}
				}

				nSearch += (short)(pLoop.nOut);
			}
		}
		public static int whereClauseInsert(WhereClause pWC, Expr p, ushort wtFlags)
		{
			WhereTerm pTerm;
			int idx = 0;
			if ((pWC.nTerm) >= (pWC.nSlot))
			{
				WhereTerm pOld = pWC.a;
				sqlite3 db = pWC.pWInfo.pParse.db;
				pWC.a = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereTerm) * pWC.nSlot * 2));
				if ((pWC.a) == (null))
				{
					if ((wtFlags & 0x0001) != 0)
					{
						sqlite3ExprDelete(db, p);
					}

					pWC.a = pOld;
					return (int)(0);
				}

				CRuntime.memcpy(pWC.a, pOld, (ulong)(sizeof(WhereTerm) * pWC.nTerm));
				if (pOld != pWC.aStatic)
				{
					sqlite3DbFree(db, pOld);
				}

				pWC.nSlot = (int)(sqlite3DbMallocSize(db, pWC.a) / sizeof(WhereTerm));
			}

			pTerm = pWC.a[idx = (int)(pWC.nTerm++)];
			if ((wtFlags & 0x0002) == (0))
				pWC.nBase = (int)(pWC.nTerm);
			if (((p) != null) && (((p).flags & (0x040000)) != 0))
			{
				pTerm.truthProb = (short)(sqlite3LogEst((ulong)(p.iTable)) - 270);
			}
			else
			{
				pTerm.truthProb = (short)(1);
			}

			pTerm.pExpr = sqlite3ExprSkipCollateAndLikely(p);
			pTerm.wtFlags = (ushort)(wtFlags);
			pTerm.pWC = pWC;
			pTerm.iParent = (int)(-1);
			CRuntime.memset(&pTerm.eOperator, (int)(0), (ulong)(sizeof(WhereTerm) - ((ulong)(&((0).eOperator)))));
			return (int)(idx);
		}
		public static void whereCombineDisjuncts(SrcList pSrc, WhereClause pWC, WhereTerm pOne, WhereTerm pTwo)
		{
			ushort eOp = (ushort)(pOne.eOperator | pTwo.eOperator);
			sqlite3 db;
			Expr pNew;
			int op = 0;
			int idxNew = 0;
			if (((pOne.wtFlags | pTwo.wtFlags) & 0x0080) != 0)
				return;
			if ((pOne.eOperator & (0x0002 | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53)) | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) == (0))
				return;
			if ((pTwo.eOperator & (0x0002 | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53)) | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) == (0))
				return;
			if (((eOp & (0x0002 | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53)))) != eOp) && ((eOp & (0x0002 | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) != eOp))
				return;


			if ((sqlite3ExprCompare(null, pOne.pExpr.pLeft, pTwo.pExpr.pLeft, (int)(-1))) != 0)
				return;
			if ((sqlite3ExprCompare(null, pOne.pExpr.pRight, pTwo.pExpr.pRight, (int)(-1))) != 0)
				return;
			if ((eOp & (eOp - 1)) != 0)
			{
				if ((eOp & ((0x0002 << (56 - 53)) | (0x0002 << (55 - 53)))) != 0)
				{
					eOp = (ushort)(0x0002 << (55 - 53));
				}
				else
				{

					eOp = (ushort)(0x0002 << (57 - 53));
				}
			}

			db = pWC.pWInfo.pParse.db;
			pNew = sqlite3ExprDup(db, pOne.pExpr, (int)(0));
			if ((pNew) == (null))
				return;
			for (op = (int)(53); eOp != (0x0002 << (op - 53)); op++)
			{

			}

			pNew.op = (byte)(op);
			idxNew = (int)(whereClauseInsert(pWC, pNew, (ushort)(0x0002 | 0x0001)));
			exprAnalyze(pSrc, pWC, (int)(idxNew));
		}
		public static void whereIndexExprTrans(Index pIdx, int iTabCur, int iIdxCur, WhereInfo pWInfo)
		{
			int iIdxCol = 0;
			ExprList aColExpr;
			Table pTab;
			Walker w = new Walker();
			IdxExprTrans x = new IdxExprTrans();
			aColExpr = pIdx.aColExpr;
			if (((aColExpr) == (null)) && (pIdx.bHasVCol == 0))
			{
				return;
			}

			pTab = pIdx.pTable;
			CRuntime.memset(w, (int)(0), (ulong)(sizeof(Walker)));
			w.u.pIdxTrans = x;
			x.iTabCur = (int)(iTabCur);
			x.iIdxCur = (int)(iIdxCur);
			x.pWInfo = pWInfo;
			x.db = pWInfo.pParse.db;
			for (iIdxCol = (int)(0); (iIdxCol) < (pIdx.nColumn); iIdxCol++)
			{
				short iRef = (short)(pIdx.aiColumn[iIdxCol]);
				if ((iRef) == (-2))
				{

					x.pIdxExpr = aColExpr.a[iIdxCol].pExpr;
					if ((sqlite3ExprIsConstant(x.pIdxExpr)) != 0)
						continue;
					w.xExprCallback = whereIndexExprTransNode;
				}
				else if ((((iRef) >= (0)) && ((pTab.aCol[iRef].colFlags & 0x0020) != 0)) && (((pTab.aCol[iRef].colFlags & 0x0200) == (0)) || ((sqlite3StrICmp(sqlite3ColumnColl(&pTab.aCol[iRef]), sqlite3StrBINARY)) == (0))))
				{
					x.iTabCol = (int)(iRef);
					w.xExprCallback = whereIndexExprTransColumn;
				}
				else
				{
					continue;
				}

				x.iIdxCol = (int)(iIdxCol);
				sqlite3WalkExpr(w, pWInfo.pWhere);
				sqlite3WalkExprList(w, pWInfo.pOrderBy);
				sqlite3WalkExprList(w, pWInfo.pResultSet);
			}
		}
		public static int whereIndexExprTransColumn(Walker p, Expr pExpr)
		{
			if ((pExpr.op) == (167))
			{
				IdxExprTrans pX = p.u.pIdxTrans;
				if (((pExpr.iTable) == (pX.iTabCur)) && ((pExpr.iColumn) == (pX.iTabCol)))
				{

					preserveExpr(pX, pExpr);
					pExpr.affExpr = (sbyte)(sqlite3TableColumnAffinity(pExpr.y.pTab, (int)(pExpr.iColumn)));
					pExpr.iTable = (int)(pX.iIdxCur);
					pExpr.iColumn = (short)(pX.iIdxCol);
					pExpr.y.pTab = null;
				}
			}

			return (int)(0);
		}
		public static int whereIndexExprTransNode(Walker p, Expr pExpr)
		{
			IdxExprTrans pX = p.u.pIdxTrans;
			if ((sqlite3ExprCompare(null, pExpr, pX.pIdxExpr, (int)(pX.iTabCur))) == (0))
			{
				preserveExpr(pX, pExpr);
				pExpr.affExpr = (sbyte)(sqlite3ExprAffinity(pExpr));
				pExpr.op = (byte)(167);
				pExpr.iTable = (int)(pX.iIdxCur);
				pExpr.iColumn = (short)(pX.iIdxCol);
				(pExpr).flags &= (uint)(~(0x001000 | 0x040000 | 0x1000000 | 0x2000000));
				pExpr.y.pTab = null;
				return (int)(1);
			}
			else
			{
				return (int)(0);
			}
		}
		public static void whereInfoFree(sqlite3 db, WhereInfo pWInfo)
		{
			int i = 0;

			for (i = (int)(0); (i) < (pWInfo.nLevel); i++)
			{
				WhereLevel pLevel = pWInfo.a[i];
				if (((pLevel.pWLoop) != null) && ((pLevel.pWLoop.wsFlags & 0x00000800) != 0))
				{

					sqlite3DbFree(db, pLevel.u._in_.aInLoop);
				}
			}

			sqlite3WhereClauseClear(pWInfo.sWC);
			while ((pWInfo.pLoops) != null)
			{
				WhereLoop p = pWInfo.pLoops;
				pWInfo.pLoops = p.pNextLoop;
				whereLoopDelete(db, p);
			}


			sqlite3DbFreeNN(db, pWInfo);
		}
		public static void whereLikeOptimizationStringFixup(Vdbe v, WhereLevel pLevel, WhereTerm pTerm)
		{
			if ((pTerm.wtFlags & 0x0100) != 0)
			{
				VdbeOp* pOp;

				pOp = sqlite3VdbeGetOp(v, (int)(-1));


				pOp->p3 = ((int)(pLevel.iLikeRepCntr >> 1));
				pOp->p5 = (ushort)((byte)(pLevel.iLikeRepCntr & 1));
			}
		}
		public static int whereLoopAddAll(WhereLoopBuilder pBuilder)
		{
			WhereInfo pWInfo = pBuilder.pWInfo;
			ulong mPrereq = (ulong)(0);
			ulong mPrior = (ulong)(0);
			int iTab = 0;
			SrcList pTabList = pWInfo.pTabList;
			SrcItem pItem;
			SrcItem pEnd = pTabList.a[pWInfo.nLevel];
			sqlite3 db = pWInfo.pParse.db;
			int rc = (int)(0);
			WhereLoop pNew;
			pNew = pBuilder.pNew;
			whereLoopInit(pNew);
			pBuilder.iPlanLimit = (uint)(20000);
			for (iTab = (int)(0), pItem = pTabList.a; (pItem) < (pEnd); iTab++, pItem++)
			{
				ulong mUnusable = (ulong)(0);
				pNew.iTab = (byte)(iTab);
				pBuilder.iPlanLimit += (uint)(1000);
				pNew.maskSelf = (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(pItem.iCursor)));
				if ((pItem.fg.jointype & (0x0008 | 0x0002)) != 0)
				{
					mPrereq = (ulong)(mPrior);
				}
				else
				{
					mPrereq = (ulong)(0);
				}

				if ((((pItem.pTab).eTabType) == (1)))
				{
					SrcItem p;
					for (p = pItem[1]; (p) < (pEnd); p++)
					{
						if (((mUnusable) != 0) || ((p.fg.jointype & (0x0008 | 0x0002)) != 0))
						{
							mUnusable |= (ulong)(sqlite3WhereGetMask(&pWInfo.sMaskSet, (int)(p.iCursor)));
						}
					}

					rc = (int)(whereLoopAddVirtual(pBuilder, (ulong)(mPrereq), (ulong)(mUnusable)));
				}
				else
				{
					rc = (int)(whereLoopAddBtree(pBuilder, (ulong)(mPrereq)));
				}

				if (((rc) == (0)) && ((pBuilder.pWC.hasOr) != 0))
				{
					rc = (int)(whereLoopAddOr(pBuilder, (ulong)(mPrereq), (ulong)(mUnusable)));
				}

				mPrior |= (ulong)(pNew.maskSelf);
				if (((rc) != 0) || ((db.mallocFailed) != 0))
				{
					if ((rc) == (101))
					{
						sqlite3_log((int)(28), "abbreviated query algorithm search");
						rc = (int)(0);
					}
					else
					{
						break;
					}
				}
			}

			whereLoopClear(db, pNew);
			return (int)(rc);
		}
		public static int whereLoopAddBtree(WhereLoopBuilder pBuilder, ulong mPrereq)
		{
			WhereInfo pWInfo;
			Index pProbe;
			Index sPk = new Index();
			short* aiRowEstPk = stackalloc short[2];
			short aiColumnPk = (short)(-1);
			SrcList pTabList;
			SrcItem pSrc;
			WhereLoop pNew;
			int rc = (int)(0);
			int iSortIdx = (int)(1);
			int b = 0;
			short rSize = 0;
			WhereClause pWC;
			Table pTab;
			pNew = pBuilder.pNew;
			pWInfo = pBuilder.pWInfo;
			pTabList = pWInfo.pTabList;
			pSrc = pTabList.a[pNew.iTab];
			pTab = pSrc.pTab;
			pWC = pBuilder.pWC;

			if ((pSrc.fg.isIndexedBy) != 0)
			{

				pProbe = pSrc.u2.pIBIndex;
			}
			else if (!(((pTab).tabFlags & 0x00000080) == (0)))
			{
				pProbe = pTab.pIndex;
			}
			else
			{
				Index pFirst;
				CRuntime.memset(sPk, (int)(0), (ulong)(sizeof(Index)));
				sPk.nKeyCol = (ushort)(1);
				sPk.nColumn = (ushort)(1);
				sPk.aiColumn = &aiColumnPk;
				sPk.aiRowLogEst = aiRowEstPk;
				sPk.onError = (byte)(5);
				sPk.pTable = pTab;
				sPk.szIdxRow = (short)(pTab.szTabRow);
				sPk.idxType = (uint)(3);
				aiRowEstPk[0] = (short)(pTab.nRowLogEst);
				aiRowEstPk[1] = (short)(0);
				pFirst = pSrc.pTab.pIndex;
				if ((pSrc.fg.notIndexed) == (0))
				{
					sPk.pNext = pFirst;
				}

				pProbe = sPk;
			}

			rSize = (short)(pTab.nRowLogEst);
			if ((((((((pBuilder.pOrSet == null) && ((pWInfo.wctrlFlags & 0x0020) == (0))) && ((pWInfo.pParse.db.flags & 0x00008000) != 0)) && (pSrc.fg.isIndexedBy == 0)) && (pSrc.fg.notIndexed == 0)) && (((pTab).tabFlags & 0x00000080) == (0))) && (pSrc.fg.isCorrelated == 0)) && (pSrc.fg.isRecursive == 0))
			{
				short rLogSize = 0;
				WhereTerm pTerm;
				WhereTerm pWCEnd = pWC.a[pWC.nTerm];
				rLogSize = (short)(estLog((short)(rSize)));
				for (pTerm = pWC.a; ((rc) == (0)) && ((pTerm) < (pWCEnd)); pTerm++)
				{
					if ((pTerm.prereqRight & pNew.maskSelf) != 0)
						continue;
					if ((termCanDriveIndex(pTerm, pSrc, (ulong)(0))) != 0)
					{
						pNew.u.btree.nEq = (ushort)(1);
						pNew.nSkip = (ushort)(0);
						pNew.u.btree.pIndex = null;
						pNew.nLTerm = (ushort)(1);
						pNew.aLTerm[0] = pTerm;
						pNew.rSetup = (short)(rLogSize + rSize);
						if ((!(((pTab).eTabType) == (2))) && ((pTab.tabFlags & 0x00004000) == (0)))
						{
							pNew.rSetup += (short)(28);
						}
						else
						{
							pNew.rSetup -= (short)(10);
						}

						if ((pNew.rSetup) < (0))
							pNew.rSetup = (short)(0);
						pNew.nOut = (short)(43);

						pNew.rRun = (short)(sqlite3LogEstAdd((short)(rLogSize), (short)(pNew.nOut)));
						pNew.wsFlags = (uint)(0x00004000);
						pNew.prereq = (ulong)(mPrereq | pTerm.prereqRight);
						rc = (int)(whereLoopInsert(pBuilder, pNew));
					}
				}
			}

			for (; ((rc) == (0)) && ((pProbe) != null); pProbe = ((pSrc.fg.isIndexedBy) != 0 ? null : pProbe.pNext), iSortIdx++)
			{
				int isLeft = (int)((pSrc.fg.jointype & 0x0020) != 0);
				if ((pProbe.pPartIdxWhere != null) && (whereUsablePartialIndex((int)(pSrc.iCursor), (int)(isLeft), pWC, pProbe.pPartIdxWhere) == 0))
				{
					continue;
				}

				if ((pProbe.bNoQuery) != 0)
					continue;
				rSize = (short)(pProbe.aiRowLogEst[0]);
				pNew.u.btree.nEq = (ushort)(0);
				pNew.u.btree.nBtm = (ushort)(0);
				pNew.u.btree.nTop = (ushort)(0);
				pNew.nSkip = (ushort)(0);
				pNew.nLTerm = (ushort)(0);
				pNew.iSortIdx = (byte)(0);
				pNew.rSetup = (short)(0);
				pNew.prereq = (ulong)(mPrereq);
				pNew.nOut = (short)(rSize);
				pNew.u.btree.pIndex = pProbe;
				b = (int)(indexMightHelpWithOrderBy(pBuilder, pProbe, (int)(pSrc.iCursor)));

				if ((pProbe.idxType) == (3))
				{
					pNew.wsFlags = (uint)(0x00000100);
					pNew.iSortIdx = (byte)((b) != 0 ? iSortIdx : 0);
					pNew.rRun = (short)(rSize + 16);
					whereLoopOutputAdjust(pWC, pNew, (short)(rSize));
					rc = (int)(whereLoopInsert(pBuilder, pNew));
					pNew.nOut = (short)(rSize);
					if ((rc) != 0)
						break;
				}
				else
				{
					ulong m = 0;
					if ((pProbe.isCovering) != 0)
					{
						pNew.wsFlags = (uint)(0x00000040 | 0x00000200);
						m = (ulong)(0);
					}
					else
					{
						m = (ulong)(pSrc.colUsed & pProbe.colNotIdxed);
						pNew.wsFlags = (uint)(((m) == (0)) ? (0x00000040 | 0x00000200) : 0x00000200);
					}

					if ((((((b) != 0) || (!(((pTab).tabFlags & 0x00000080) == (0)))) || (pProbe.pPartIdxWhere != null)) || ((pSrc.fg.isIndexedBy) != 0)) || (((((((m) == (0)) && ((pProbe.bUnordered) == (0))) && ((pProbe.szIdxRow) < (pTab.szTabRow))) && ((pWInfo.wctrlFlags & 0x0004) == (0))) && ((sqlite3Config.bUseCis) != 0)) && (((pWInfo.pParse.db).dbOptFlags & (0x00000020)) == (0))))
					{
						pNew.iSortIdx = (byte)((b) != 0 ? iSortIdx : 0);
						pNew.rRun = (short)(rSize + 1 + (15 * pProbe.szIdxRow) / pTab.szTabRow);
						if (m != 0)
						{
							short nLookup = (short)(rSize + 16);
							int ii = 0;
							int iCur = (int)(pSrc.iCursor);
							WhereClause pWC2 = pWInfo.sWC;
							for (ii = (int)(0); (ii) < (pWC2.nTerm); ii++)
							{
								WhereTerm pTerm = pWC2.a[ii];
								if (sqlite3ExprCoveredByIndex(pTerm.pExpr, (int)(iCur), pProbe) == 0)
								{
									break;
								}

								if ((pTerm.truthProb) <= (0))
								{
									nLookup += (short)(pTerm.truthProb);
								}
								else
								{
									nLookup--;
									if ((pTerm.eOperator & (0x0002 | 0x0080)) != 0)
										nLookup -= (short)(19);
								}
							}

							pNew.rRun = (short)(sqlite3LogEstAdd((short)(pNew.rRun), (short)(nLookup)));
						}

						whereLoopOutputAdjust(pWC, pNew, (short)(rSize));
						rc = (int)(whereLoopInsert(pBuilder, pNew));
						pNew.nOut = (short)(rSize);
						if ((rc) != 0)
							break;
					}
				}

				pBuilder.bldFlags1 = (byte)(0);
				rc = (int)(whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(0)));
				if ((pBuilder.bldFlags1) == (0x0001))
				{
					pTab.tabFlags |= (uint)(0x00000100);
				}
			}

			return (int)(rc);
		}
		public static int whereLoopAddBtreeIndex(WhereLoopBuilder pBuilder, SrcItem pSrc, Index pProbe, short nInMul)
		{
			WhereInfo pWInfo = pBuilder.pWInfo;
			Parse pParse = pWInfo.pParse;
			sqlite3 db = pParse.db;
			WhereLoop pNew;
			WhereTerm pTerm;
			int opMask = 0;
			WhereScan scan = new WhereScan();
			ulong saved_prereq = 0;
			ushort saved_nLTerm = 0;
			ushort saved_nEq = 0;
			ushort saved_nBtm = 0;
			ushort saved_nTop = 0;
			ushort saved_nSkip = 0;
			uint saved_wsFlags = 0;
			short saved_nOut = 0;
			int rc = (int)(0);
			short rSize = 0;
			short rLogSize = 0;
			WhereTerm pTop = null; WhereTerm pBtm = null;
			pNew = pBuilder.pNew;
			if ((db.mallocFailed) != 0)
				return (int)(7);


			if ((pNew.wsFlags & 0x00000020) != 0)
			{
				opMask = (int)((0x0002 << (56 - 53)) | (0x0002 << (55 - 53)));
			}
			else
			{

				opMask = (int)(0x0002 | 0x0001 | (0x0002 << (54 - 53)) | (0x0002 << (57 - 53)) | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53)) | 0x0100 | 0x0080);
			}

			if ((pProbe.bUnordered) != 0)
				opMask &= (int)(~((0x0002 << (54 - 53)) | (0x0002 << (57 - 53)) | (0x0002 << (56 - 53)) | (0x0002 << (55 - 53))));


			saved_nEq = (ushort)(pNew.u.btree.nEq);
			saved_nBtm = (ushort)(pNew.u.btree.nBtm);
			saved_nTop = (ushort)(pNew.u.btree.nTop);
			saved_nSkip = (ushort)(pNew.nSkip);
			saved_nLTerm = (ushort)(pNew.nLTerm);
			saved_wsFlags = (uint)(pNew.wsFlags);
			saved_prereq = (ulong)(pNew.prereq);
			saved_nOut = (short)(pNew.nOut);
			pTerm = whereScanInit(scan, pBuilder.pWC, (int)(pSrc.iCursor), (int)(saved_nEq), (uint)(opMask), pProbe);
			pNew.rSetup = (short)(0);
			rSize = (short)(pProbe.aiRowLogEst[0]);
			rLogSize = (short)(estLog((short)(rSize)));
			for (; ((rc) == (0)) && (pTerm != null); pTerm = whereScanNext(scan))
			{
				ushort eOp = (ushort)(pTerm.eOperator);
				short rCostIdx = 0;
				short nOutUnadjusted = 0;
				int nIn = (int)(0);
				if ((((eOp) == (0x0100)) || ((pTerm.wtFlags & 0x0080) != 0)) && ((indexColumnNotNull(pProbe, (int)(saved_nEq))) != 0))
				{
					continue;
				}

				if ((pTerm.prereqRight & pNew.maskSelf) != 0)
					continue;
				if (((pTerm.wtFlags & 0x0100) != 0) && ((pTerm.eOperator) == (0x0002 << (56 - 53))))
					continue;
				if (((pSrc.fg.jointype & 0x0008) != 0) && (!(((pTerm.pExpr).flags & (0x000001)) != 0)))
				{
					continue;
				}

				if (((pProbe).onError != 0) && ((saved_nEq) == (pProbe.nKeyCol - 1)))
				{
					pBuilder.bldFlags1 |= (byte)(0x0002);
				}
				else
				{
					pBuilder.bldFlags1 |= (byte)(0x0001);
				}

				pNew.wsFlags = (uint)(saved_wsFlags);
				pNew.u.btree.nEq = (ushort)(saved_nEq);
				pNew.u.btree.nBtm = (ushort)(saved_nBtm);
				pNew.u.btree.nTop = (ushort)(saved_nTop);
				pNew.nLTerm = (ushort)(saved_nLTerm);
				if ((whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1))) != 0)
					break;
				pNew.aLTerm[pNew.nLTerm++] = pTerm;
				pNew.prereq = (ulong)((saved_prereq | pTerm.prereqRight) & ~pNew.maskSelf);

				if ((eOp & 0x0001) != 0)
				{
					Expr pExpr = pTerm.pExpr;
					if ((((pExpr).flags & 0x000800) != 0))
					{
						int i = 0;
						nIn = (int)(46);

						for (i = (int)(0); (i) < (pNew.nLTerm - 1); i++)
						{
							if (((pNew.aLTerm[i]) != null) && ((pNew.aLTerm[i].pExpr) == (pExpr)))
								nIn = (int)(0);
						}
					}
					else if ((((pExpr.x.pList) != null) && ((pExpr.x.pList.nExpr) != 0)))
					{
						nIn = (int)(sqlite3LogEst((ulong)(pExpr.x.pList.nExpr)));
					}

					if (((pProbe.hasStat1) != 0) && ((rLogSize) >= (10)))
					{
						short M = 0;
						short logK = 0;
						short x = 0;
						M = (short)(pProbe.aiRowLogEst[saved_nEq]);
						logK = (short)(estLog((short)(nIn)));
						x = (short)(M + logK + 10 - (nIn + rLogSize));
						if ((x) >= (0))
						{
						}
						else if (((nInMul) < (2)) && (((db).dbOptFlags & (0x00020000)) == (0)))
						{
							pNew.wsFlags |= (uint)(0x00100000);
						}
						else
						{
							continue;
						}
					}

					pNew.wsFlags |= (uint)(0x00000004);
				}
				else if ((eOp & (0x0002 | 0x0080)) != 0)
				{
					int iCol = (int)(pProbe.aiColumn[saved_nEq]);
					pNew.wsFlags |= (uint)(0x00000001);

					if (((iCol) == (-1)) || ((((iCol) >= (0)) && ((nInMul) == (0))) && ((saved_nEq) == (pProbe.nKeyCol - 1))))
					{
						if ((((iCol) == (-1)) || ((pProbe.uniqNotNull) != 0)) || ((((pProbe.nKeyCol) == (1)) && ((pProbe.onError) != 0)) && ((eOp) == (0x0002))))
						{
							pNew.wsFlags |= (uint)(0x00001000);
						}
						else
						{
							pNew.wsFlags |= (uint)(0x00010000);
						}
					}

					if ((scan.iEquiv) > (1))
						pNew.wsFlags |= (uint)(0x00200000);
				}
				else if ((eOp & 0x0100) != 0)
				{
					pNew.wsFlags |= (uint)(0x00000008);
				}
				else if ((eOp & ((0x0002 << (54 - 53)) | (0x0002 << (57 - 53)))) != 0)
				{
					pNew.wsFlags |= (uint)(0x00000002 | 0x00000020);
					pNew.u.btree.nBtm = (ushort)(whereRangeVectorLen(pParse, (int)(pSrc.iCursor), pProbe, (int)(saved_nEq), pTerm));
					pBtm = pTerm;
					pTop = null;
					if ((pTerm.wtFlags & 0x0100) != 0)
					{
						pTop = pTerm[1];



						if ((whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1))) != 0)
							break;
						pNew.aLTerm[pNew.nLTerm++] = pTop;
						pNew.wsFlags |= (uint)(0x00000010);
						pNew.u.btree.nTop = (ushort)(1);
					}
				}
				else
				{

					pNew.wsFlags |= (uint)(0x00000002 | 0x00000010);
					pNew.u.btree.nTop = (ushort)(whereRangeVectorLen(pParse, (int)(pSrc.iCursor), pProbe, (int)(saved_nEq), pTerm));
					pTop = pTerm;
					pBtm = (pNew.wsFlags & 0x00000020) != 0 ? pNew.aLTerm[pNew.nLTerm - 2] : null;
				}


				if ((pNew.wsFlags & 0x00000002) != 0)
				{
					whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
				}
				else
				{
					int nEq = (int)(++pNew.u.btree.nEq);


					if (((pTerm.truthProb) <= (0)) && ((pProbe.aiColumn[saved_nEq]) >= (0)))
					{

						pNew.nOut += (short)(pTerm.truthProb);
						pNew.nOut -= (short)(nIn);
					}
					else
					{
						{
							pNew.nOut += (short)(pProbe.aiRowLogEst[nEq] - pProbe.aiRowLogEst[nEq - 1]);
							if ((eOp & 0x0100) != 0)
							{
								pNew.nOut += (short)(10);
							}
						}
					}
				}


				rCostIdx = (short)(pNew.nOut + 1 + (15 * pProbe.szIdxRow) / pSrc.pTab.szTabRow);
				pNew.rRun = (short)(sqlite3LogEstAdd((short)(rLogSize), (short)(rCostIdx)));
				if ((pNew.wsFlags & (0x00000040 | 0x00000100)) == (0))
				{
					pNew.rRun = (short)(sqlite3LogEstAdd((short)(pNew.rRun), (short)(pNew.nOut + 16)));
				}

				nOutUnadjusted = (short)(pNew.nOut);
				pNew.rRun += (short)(nInMul + nIn);
				pNew.nOut += (short)(nInMul + nIn);
				whereLoopOutputAdjust(pBuilder.pWC, pNew, (short)(rSize));
				rc = (int)(whereLoopInsert(pBuilder, pNew));
				if ((pNew.wsFlags & 0x00000002) != 0)
				{
					pNew.nOut = (short)(saved_nOut);
				}
				else
				{
					pNew.nOut = (short)(nOutUnadjusted);
				}

				if ((((pNew.wsFlags & 0x00000010) == (0)) && ((pNew.u.btree.nEq) < (pProbe.nColumn))) && (((pNew.u.btree.nEq) < (pProbe.nKeyCol)) || (pProbe.idxType != 2)))
				{
					whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(nInMul + nIn));
				}

				pNew.nOut = (short)(saved_nOut);
			}

			pNew.prereq = (ulong)(saved_prereq);
			pNew.u.btree.nEq = (ushort)(saved_nEq);
			pNew.u.btree.nBtm = (ushort)(saved_nBtm);
			pNew.u.btree.nTop = (ushort)(saved_nTop);
			pNew.nSkip = (ushort)(saved_nSkip);
			pNew.wsFlags = (uint)(saved_wsFlags);
			pNew.nOut = (short)(saved_nOut);
			pNew.nLTerm = (ushort)(saved_nLTerm);

			if (((((((((saved_nEq) == (saved_nSkip)) && ((saved_nEq + 1) < (pProbe.nKeyCol))) && ((saved_nEq) == (pNew.nLTerm))) && ((pProbe.noSkipScan) == (0))) && (pProbe.hasStat1 != 0)) && (((db).dbOptFlags & (0x00004000)) == (0))) && ((pProbe.aiRowLogEst[saved_nEq + 1]) >= (42))) && ((rc = (int)(whereLoopResize(db, pNew, (int)(pNew.nLTerm + 1)))) == (0)))
			{
				short nIter = 0;
				pNew.u.btree.nEq++;
				pNew.nSkip++;
				pNew.aLTerm[pNew.nLTerm++] = null;
				pNew.wsFlags |= (uint)(0x00008000);
				nIter = (short)(pProbe.aiRowLogEst[saved_nEq] - pProbe.aiRowLogEst[saved_nEq + 1]);
				pNew.nOut -= (short)(nIter);
				nIter += (short)(5);
				whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, (short)(nIter + nInMul));
				pNew.nOut = (short)(saved_nOut);
				pNew.u.btree.nEq = (ushort)(saved_nEq);
				pNew.nSkip = (ushort)(saved_nSkip);
				pNew.wsFlags = (uint)(saved_wsFlags);
			}

			return (int)(rc);
		}
		public static int whereLoopAddOr(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUnusable)
		{
			return 1;
		}
		public static int whereLoopAddVirtual(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUnusable)
		{
			int rc = (int)(0);
			WhereInfo pWInfo;
			Parse pParse;
			WhereClause pWC;
			SrcItem pSrc;
			sqlite3_index_info* p;
			int nConstraint = 0;
			int bIn = 0;
			WhereLoop pNew;
			ulong mBest = 0;
			ushort mNoOmit = 0;
			int bRetry = (int)(0);

			pWInfo = pBuilder.pWInfo;
			pParse = pWInfo.pParse;
			pWC = pBuilder.pWC;
			pNew = pBuilder.pNew;
			pSrc = pWInfo.pTabList.a[pNew.iTab];

			p = allocateIndexInfo(pWInfo, pWC, (ulong)(mUnusable), pSrc, &mNoOmit);
			if ((p) == (null))
				return (int)(7);
			pNew.rSetup = (short)(0);
			pNew.wsFlags = (uint)(0x00000400);
			pNew.nLTerm = (ushort)(0);
			pNew.u.vtab.needFree = (uint)(0);
			nConstraint = (int)(p->nConstraint);
			if ((whereLoopResize(pParse.db, pNew, (int)(nConstraint))) != 0)
			{
				freeIndexInfo(pParse.db, p);
				return (int)(7);
			}

			rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0), p, (ushort)(mNoOmit), &bIn, &bRetry));
			if ((bRetry) != 0)
			{

				rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0), p, (ushort)(mNoOmit), &bIn, null));
			}

			if (((rc) == (0)) && (((mBest = (ulong)(pNew.prereq & ~mPrereq)) != 0) || ((bIn) != 0)))
			{
				int seenZero = (int)(0);
				int seenZeroNoIN = (int)(0);
				ulong mPrev = (ulong)(0);
				ulong mBestNoIn = (ulong)(0);
				if ((bIn) != 0)
				{
					rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), ((ulong)(-1)), (ushort)(0x0001), p, (ushort)(mNoOmit), &bIn, null));

					mBestNoIn = (ulong)(pNew.prereq & ~mPrereq);
					if ((mBestNoIn) == (0))
					{
						seenZero = (int)(1);
						seenZeroNoIN = (int)(1);
					}
				}

				while ((rc) == (0))
				{
					int i = 0;
					ulong mNext = ((ulong)(-1));

					for (i = (int)(0); (i) < (nConstraint); i++)
					{
						ulong mThis = (ulong)(pWC.a[p->aConstraint[i].iTermOffset].prereqRight & ~mPrereq);
						if (((mThis) > (mPrev)) && ((mThis) < (mNext)))
							mNext = (ulong)(mThis);
					}

					mPrev = (ulong)(mNext);
					if ((mNext) == ((ulong)(-1)))
						break;
					if (((mNext) == (mBest)) || ((mNext) == (mBestNoIn)))
						continue;
					rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mNext | mPrereq), (ushort)(0), p, (ushort)(mNoOmit), &bIn, null));
					if ((pNew.prereq) == (mPrereq))
					{
						seenZero = (int)(1);
						if ((bIn) == (0))
							seenZeroNoIN = (int)(1);
					}
				}

				if (((rc) == (0)) && ((seenZero) == (0)))
				{
					rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mPrereq), (ushort)(0), p, (ushort)(mNoOmit), &bIn, null));
					if ((bIn) == (0))
						seenZeroNoIN = (int)(1);
				}

				if (((rc) == (0)) && ((seenZeroNoIN) == (0)))
				{
					rc = (int)(whereLoopAddVirtualOne(pBuilder, (ulong)(mPrereq), (ulong)(mPrereq), (ushort)(0x0001), p, (ushort)(mNoOmit), &bIn, null));
				}
			}

			if ((p->needToFreeIdxStr) != 0)
				sqlite3_free(p->idxStr);
			freeIndexInfo(pParse.db, p);
			return (int)(rc);
		}
		public static int whereLoopAddVirtualOne(WhereLoopBuilder pBuilder, ulong mPrereq, ulong mUsable, ushort mExclude, sqlite3_index_info* pIdxInfo, ushort mNoOmit, int* pbIn, int* pbRetryLimit)
		{
			WhereClause pWC = pBuilder.pWC;
			HiddenIndexInfo pHidden = (HiddenIndexInfo)(&pIdxInfo[1]);
			sqlite3_index_constraint* pIdxCons;
			sqlite3_index_constraint_usage* pUsage = pIdxInfo->aConstraintUsage;
			int i = 0;
			int mxTerm = 0;
			int rc = (int)(0);
			WhereLoop pNew = pBuilder.pNew;
			Parse pParse = pBuilder.pWInfo.pParse;
			SrcItem pSrc = pBuilder.pWInfo.pTabList.a[pNew.iTab];
			int nConstraint = (int)(pIdxInfo->nConstraint);

			*pbIn = (int)(0);
			pNew.prereq = (ulong)(mPrereq);
			pIdxCons = *&pIdxInfo->aConstraint;
			for (i = (int)(0); (i) < (nConstraint); i++, pIdxCons++)
			{
				WhereTerm pTerm = pWC.a[pIdxCons->iTermOffset];
				pIdxCons->usable = (byte)(0);
				if ((((pTerm.prereqRight & mUsable) == (pTerm.prereqRight)) && ((pTerm.eOperator & mExclude) == (0))) && (((pbRetryLimit) != null) || (isLimitTerm(pTerm) == 0)))
				{
					pIdxCons->usable = (byte)(1);
				}
			}

			CRuntime.memset(pUsage, (int)(0), (ulong)(sizeof(sqlite3_index_constraint_usage) * nConstraint));

			pIdxInfo->idxStr = null;
			pIdxInfo->idxNum = (int)(0);
			pIdxInfo->orderByConsumed = (int)(0);
			pIdxInfo->estimatedCost = (double)((1e99) / (double)(2));
			pIdxInfo->estimatedRows = (long)(25);
			pIdxInfo->idxFlags = (int)(0);
			pIdxInfo->colUsed = (ulong)((long)(pSrc.colUsed));
			pHidden.mHandleIn = (uint)(0);
			rc = (int)(vtabBestIndex(pParse, pSrc.pTab, pIdxInfo));
			if ((rc) != 0)
			{
				if ((rc) == (19))
				{
					return (int)(0);
				}

				return (int)(rc);
			}

			mxTerm = (int)(-1);

			CRuntime.memset(pNew.aLTerm, (int)(0), (ulong)(sizeof(WhereTerm) * nConstraint));
			CRuntime.memset(&pNew.u.vtab, (int)(0), (ulong)(sizeof(WhereLoop::(unnamed at sqlite3.c : 146964 : 5))) ) ;
			pIdxCons = *&pIdxInfo->aConstraint;
			for (i = (int)(0); (i) < (nConstraint); i++, pIdxCons++)
			{
				int iTerm = 0;
				if ((iTerm = (int)(pUsage[i].argvIndex - 1)) >= (0))
				{
					WhereTerm pTerm;
					int j = (int)(pIdxCons->iTermOffset);
					if ((((((iTerm) >= (nConstraint)) || ((j) < (0))) || ((j) >= (pWC.nTerm))) || (pNew.aLTerm[iTerm] != null)) || ((pIdxCons->usable) == (0)))
					{
						sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc.pTab.zName);
						return (int)(1);
					}

					pTerm = pWC.a[j];
					pNew.prereq |= (ulong)(pTerm.prereqRight);

					pNew.aLTerm[iTerm] = pTerm;
					if ((iTerm) > (mxTerm))
						mxTerm = (int)(iTerm);
					if ((pUsage[i].omit) != 0)
					{
						if (((i) < (16)) && (((1 << i) & mNoOmit) == (0)))
						{
							pNew.u.vtab.omitMask |= (ushort)(1 << iTerm);
						}
						else
						{
						}

						if ((pTerm.eMatchOp) == (74))
						{
							pNew.u.vtab.bOmitOffset = (uint)(1);
						}
					}

					if ((((i) <= (31) ? ((uint)(1)) << (i) : 0) & pHidden.mHandleIn) != 0)
					{
						pNew.u.vtab.mHandleIn |= (uint)(((uint)(1)) << (iTerm));
					}
					else if ((pTerm.eOperator & 0x0001) != 0)
					{
						pIdxInfo->orderByConsumed = (int)(0);
						pIdxInfo->idxFlags &= (int)(~1);
						*pbIn = (int)(1);

					}

					if (((isLimitTerm(pTerm)) != 0) && ((*pbIn) != 0))
					{
						if ((pIdxInfo->needToFreeIdxStr) != 0)
						{
							sqlite3_free(pIdxInfo->idxStr);
							pIdxInfo->idxStr = null;
							pIdxInfo->needToFreeIdxStr = (int)(0);
						}

						*pbRetryLimit = (int)(1);
						return (int)(0);
					}
				}
			}

			pNew.nLTerm = (ushort)(mxTerm + 1);
			for (i = (int)(0); (i) <= (mxTerm); i++)
			{
				if ((pNew.aLTerm[i]) == (null))
				{
					sqlite3ErrorMsg(pParse, "%s.xBestIndex malfunction", pSrc.pTab.zName);
					return (int)(1);
				}
			}


			pNew.u.vtab.idxNum = (int)(pIdxInfo->idxNum);
			pNew.u.vtab.needFree = (uint)(pIdxInfo->needToFreeIdxStr);
			pIdxInfo->needToFreeIdxStr = (int)(0);
			pNew.u.vtab.idxStr = pIdxInfo->idxStr;
			pNew.u.vtab.isOrdered = ((sbyte)((pIdxInfo->orderByConsumed) != 0 ? pIdxInfo->nOrderBy : 0));
			pNew.rSetup = (short)(0);
			pNew.rRun = (short)(sqlite3LogEstFromDouble((double)(pIdxInfo->estimatedCost)));
			pNew.nOut = (short)(sqlite3LogEst((ulong)(pIdxInfo->estimatedRows)));
			if ((pIdxInfo->idxFlags & 1) != 0)
			{
				pNew.wsFlags |= (uint)(0x00001000);
			}
			else
			{
				pNew.wsFlags &= (uint)(~0x00001000);
			}

			rc = (int)(whereLoopInsert(pBuilder, pNew));
			if ((pNew.u.vtab.needFree) != 0)
			{
				sqlite3_free(pNew.u.vtab.idxStr);
				pNew.u.vtab.needFree = (uint)(0);
			}

			return (int)(rc);
		}
		public static void whereLoopAdjustCost(WhereLoop p, WhereLoop pTemplate)
		{
			if ((pTemplate.wsFlags & 0x00000200) == (0))
				return;
			for (p; ; p = p.pNextLoop)
			{
				if (p.iTab != pTemplate.iTab)
					continue;
				if ((p.wsFlags & 0x00000200) == (0))
					continue;
				if ((whereLoopCheaperProperSubset(p, pTemplate)) != 0)
				{
					pTemplate.rRun = (short)((p.rRun) < (pTemplate.rRun) ? (p.rRun) : (pTemplate.rRun));
					pTemplate.nOut = (short)((p.nOut - 1) < (pTemplate.nOut) ? (p.nOut - 1) : (pTemplate.nOut));
				}
				else if ((whereLoopCheaperProperSubset(pTemplate, p)) != 0)
				{
					pTemplate.rRun = (short)((p.rRun) > (pTemplate.rRun) ? (p.rRun) : (pTemplate.rRun));
					pTemplate.nOut = (short)((p.nOut + 1) > (pTemplate.nOut) ? (p.nOut + 1) : (pTemplate.nOut));
				}
			}
		}
		public static int whereLoopCheaperProperSubset(WhereLoop pX, WhereLoop pY)
		{
			int i = 0; int j = 0;
			if ((pX.nLTerm - pX.nSkip) >= (pY.nLTerm - pY.nSkip))
			{
				return (int)(0);
			}

			if (((pX.rRun) > (pY.rRun)) && ((pX.nOut) > (pY.nOut)))
				return (int)(0);
			if ((pY.nSkip) > (pX.nSkip))
				return (int)(0);
			for (i = (int)(pX.nLTerm - 1); (i) >= (0); i--)
			{
				if ((pX.aLTerm[i]) == (null))
					continue;
				for (j = (int)(pY.nLTerm - 1); (j) >= (0); j--)
				{
					if ((pY.aLTerm[j]) == (pX.aLTerm[i]))
						break;
				}

				if ((j) < (0))
					return (int)(0);
			}

			if (((pX.wsFlags & 0x00000040) != 0) && ((pY.wsFlags & 0x00000040) == (0)))
			{
				return (int)(0);
			}

			return (int)(1);
		}
		public static void whereLoopClear(sqlite3 db, WhereLoop p)
		{
			if (p.aLTerm != p.aLTermSpace)
				sqlite3DbFreeNN(db, p.aLTerm);
			whereLoopClearUnion(db, p);
			whereLoopInit(p);
		}
		public static void whereLoopClearUnion(sqlite3 db, WhereLoop p)
		{
			if ((p.wsFlags & (0x00000400 | 0x00004000)) != 0)
			{
				if (((p.wsFlags & 0x00000400) != 0) && ((p.u.vtab.needFree) != 0))
				{
					sqlite3_free(p.u.vtab.idxStr);
					p.u.vtab.needFree = (uint)(0);
					p.u.vtab.idxStr = null;
				}
				else if (((p.wsFlags & 0x00004000) != 0) && (p.u.btree.pIndex != null))
				{
					sqlite3DbFree(db, p.u.btree.pIndex.zColAff);
					sqlite3DbFreeNN(db, p.u.btree.pIndex);
					p.u.btree.pIndex = null;
				}
			}
		}
		public static void whereLoopDelete(sqlite3 db, WhereLoop p)
		{
			whereLoopClear(db, p);
			sqlite3DbFreeNN(db, p);
		}
		public static WhereLoop whereLoopFindLesser(WhereLoop ppPrev, WhereLoop pTemplate)
		{
			WhereLoop p;
			for (p = (ppPrev); p; ppPrev = p.pNextLoop, p = ppPrev)
			{
				if ((p.iTab != pTemplate.iTab) || (p.iSortIdx != pTemplate.iSortIdx))
				{
					continue;
				}



				if ((((((p.wsFlags & 0x00004000) != 0) && ((pTemplate.nSkip) == (0))) && ((pTemplate.wsFlags & 0x00000200) != 0)) && ((pTemplate.wsFlags & 0x00000001) != 0)) && ((p.prereq & pTemplate.prereq) == (pTemplate.prereq)))
				{
					break;
				}

				if (((((p.prereq & pTemplate.prereq) == (p.prereq)) && ((p.rSetup) <= (pTemplate.rSetup))) && ((p.rRun) <= (pTemplate.rRun))) && ((p.nOut) <= (pTemplate.nOut)))
				{
					return null;
				}

				if ((((p.prereq & pTemplate.prereq) == (pTemplate.prereq)) && ((p.rRun) >= (pTemplate.rRun))) && ((p.nOut) >= (pTemplate.nOut)))
				{

					break;
				}
			}

			return ppPrev;
		}
		public static void whereLoopInit(WhereLoop p)
		{
			p.aLTerm = p.aLTermSpace;
			p.nLTerm = (ushort)(0);
			p.nLSlot = (ushort)((int)(3 * sizeof(WhereTerm) / sizeof(WhereTerm)));
			p.wsFlags = (uint)(0);
		}
		public static int whereLoopInsert(WhereLoopBuilder pBuilder, WhereLoop pTemplate)
		{
			WhereLoop ppPrev; WhereLoop p;
			WhereInfo pWInfo = pBuilder.pWInfo;
			sqlite3 db = pWInfo.pParse.db;
			int rc = 0;
			if ((pBuilder.iPlanLimit) == (0))
			{
				if ((pBuilder.pOrSet) != null)
					pBuilder.pOrSet.n = (ushort)(0);
				return (int)(101);
			}

			pBuilder.iPlanLimit--;
			whereLoopAdjustCost(pWInfo.pLoops, pTemplate);
			if (pBuilder.pOrSet != null)
			{
				if ((pTemplate.nLTerm) != 0)
				{
					whereOrInsert(pBuilder.pOrSet, (ulong)(pTemplate.prereq), (short)(pTemplate.rRun), (short)(pTemplate.nOut));
				}

				return (int)(0);
			}

			ppPrev = whereLoopFindLesser(pWInfo.pLoops, pTemplate);
			if ((ppPrev) == (null))
			{
				return (int)(0);
			}
			else
			{
				p = ppPrev;
			}

			if ((p) == (null))
			{
				ppPrev = p = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereLoop)));
				if ((p) == (null))
					return (int)(7);
				whereLoopInit(p);
				p.pNextLoop = null;
			}
			else
			{
				WhereLoop ppTail = p.pNextLoop;
				WhereLoop pToDel;
				while ((ppTail) != null)
				{
					ppTail = whereLoopFindLesser(ppTail, pTemplate);
					if ((ppTail) == (null))
						break;
					pToDel = ppTail;
					if ((pToDel) == (null))
						break;
					ppTail = pToDel.pNextLoop;
					whereLoopDelete(db, pToDel);
				}
			}

			rc = (int)(whereLoopXfer(db, p, pTemplate));
			if ((p.wsFlags & 0x00000400) == (0))
			{
				Index pIndex = p.u.btree.pIndex;
				if (((pIndex) != null) && ((pIndex.idxType) == (3)))
				{
					p.u.btree.pIndex = null;
				}
			}

			return (int)(rc);
		}
		public static void whereLoopOutputAdjust(WhereClause pWC, WhereLoop pLoop, short nRow)
		{
			WhereTerm pTerm; WhereTerm pX;
			ulong notAllowed = (ulong)(~(pLoop.prereq | pLoop.maskSelf));
			int i = 0; int j = 0;
			short iReduce = (short)(0);

			for (i = (int)(pWC.nBase), pTerm = pWC.a; (i) > (0); i--, pTerm++)
			{

				if ((pTerm.prereqAll & notAllowed) != 0)
					continue;
				if ((pTerm.prereqAll & pLoop.maskSelf) == (0))
					continue;
				if ((pTerm.wtFlags & 0x0002) != 0)
					continue;
				for (j = (int)(pLoop.nLTerm - 1); (j) >= (0); j--)
				{
					pX = pLoop.aLTerm[j];
					if ((pX) == (null))
						continue;
					if ((pX) == (pTerm))
						break;
					if (((pX.iParent) >= (0)) && ((pWC.a[pX.iParent]) == (pTerm)))
						break;
				}

				if ((j) < (0))
				{
					if ((pLoop.maskSelf) == (pTerm.prereqAll))
					{
						if (((pTerm.eOperator & 0x3f) != 0) || ((pWC.pWInfo.pTabList.a[pLoop.iTab].fg.jointype & 0x0008) == (0)))
						{
							pLoop.wsFlags |= (uint)(0x00800000);
						}
					}

					if ((pTerm.truthProb) <= (0))
					{
						pLoop.nOut += (short)(pTerm.truthProb);
					}
					else
					{
						pLoop.nOut--;
						if (((pTerm.eOperator & (0x0002 | 0x0080)) != 0) && ((pTerm.wtFlags & 0) == (0)))
						{
							Expr pRight = pTerm.pExpr.pRight;
							int k = (int)(0);
							if ((((sqlite3ExprIsInteger(pRight, &k)) != 0) && ((k) >= (-1))) && ((k) <= (1)))
							{
								k = (int)(10);
							}
							else
							{
								k = (int)(20);
							}

							if ((iReduce) < (k))
							{
								pTerm.wtFlags |= (ushort)(0x2000);
								iReduce = (short)(k);
							}
						}
					}
				}
			}

			if ((pLoop.nOut) > (nRow - iReduce))
			{
				pLoop.nOut = (short)(nRow - iReduce);
			}
		}
		public static int whereLoopResize(sqlite3 db, WhereLoop p, int n)
		{
			WhereTerm paNew;
			if ((p.nLSlot) >= (n))
				return (int)(0);
			n = (int)((n + 7) & ~7);
			paNew = sqlite3DbMallocRawNN(db, (ulong)(sizeof(WhereTerm) * n));
			if ((paNew) == (null))
				return (int)(7);
			CRuntime.memcpy(paNew, p.aLTerm, (ulong)(sizeof(WhereTerm) * p.nLSlot));
			if (p.aLTerm != p.aLTermSpace)
				sqlite3DbFreeNN(db, p.aLTerm);
			p.aLTerm = paNew;
			p.nLSlot = (ushort)(n);
			return (int)(0);
		}
		public static int whereLoopXfer(sqlite3 db, WhereLoop pTo, WhereLoop pFrom)
		{
			whereLoopClearUnion(db, pTo);
			if ((whereLoopResize(db, pTo, (int)(pFrom.nLTerm))) != 0)
			{
				CRuntime.memset(pTo, (int)(0), ((ulong)(&((0).nLSlot))));
				return (int)(7);
			}

			CRuntime.memcpy(pTo, pFrom, ((ulong)(&((0).nLSlot))));
			CRuntime.memcpy(pTo.aLTerm, pFrom.aLTerm, (ulong)(pTo.nLTerm * sizeof(WhereTerm)));
			if ((pFrom.wsFlags & 0x00000400) != 0)
			{
				pFrom.u.vtab.needFree = (uint)(0);
			}
			else if ((pFrom.wsFlags & 0x00004000) != 0)
			{
				pFrom.u.btree.pIndex = null;
			}

			return (int)(0);
		}
		public static WhereTerm whereNthSubterm(WhereTerm pTerm, int N)
		{
			if (pTerm.eOperator != 0x0400)
			{
				return (N) == (0) ? pTerm : null;
			}

			if ((N) < (pTerm.u.pAndInfo.wc.nTerm))
			{
				return pTerm.u.pAndInfo.wc.a[N];
			}

			return null;
		}
		public static ulong whereOmitNoopJoin(WhereInfo pWInfo, ulong notReady)
		{
			int i = 0;
			ulong tabUsed = 0;




			tabUsed = (ulong)(sqlite3WhereExprListUsage(&pWInfo.sMaskSet, pWInfo.pResultSet));
			if ((pWInfo.pOrderBy) != null)
			{
				tabUsed |= (ulong)(sqlite3WhereExprListUsage(&pWInfo.sMaskSet, pWInfo.pOrderBy));
			}

			for (i = (int)(pWInfo.nLevel - 1); (i) >= (1); i--)
			{
				WhereTerm pTerm;
				WhereTerm pEnd;
				SrcItem pItem;
				WhereLoop pLoop;
				pLoop = pWInfo.a[i].pWLoop;
				pItem = pWInfo.pTabList.a[pLoop.iTab];
				if ((pItem.fg.jointype & 0x0008) == (0))
					continue;
				if (((pWInfo.wctrlFlags & 0x0100) == (0)) && ((pLoop.wsFlags & 0x00001000) == (0)))
				{
					continue;
				}

				if ((tabUsed & pLoop.maskSelf) != 0)
					continue;
				pEnd = pWInfo.sWC.a[pWInfo.sWC.nTerm];
				for (pTerm = pWInfo.sWC.a; (pTerm) < (pEnd); pTerm++)
				{
					if ((pTerm.prereqAll & pLoop.maskSelf) != 0)
					{
						if ((!(((pTerm.pExpr).flags & (0x000001)) != 0)) || (pTerm.pExpr.w.iRightJoinTable != pItem.iCursor))
						{
							break;
						}
					}
				}

				if ((pTerm) < (pEnd))
					continue;
				notReady &= (ulong)(~pLoop.maskSelf);
				for (pTerm = pWInfo.sWC.a; (pTerm) < (pEnd); pTerm++)
				{
					if ((pTerm.prereqAll & pLoop.maskSelf) != 0)
					{
						pTerm.wtFlags |= (ushort)(0x0004);
					}
				}

				if (i != pWInfo.nLevel - 1)
				{
					int nByte = (int)((pWInfo.nLevel - 1 - i) * sizeof(WhereLevel));
					CRuntime.memmove(pWInfo.a[i], pWInfo.a[i + 1], (ulong)(nByte));
				}

				pWInfo.nLevel--;

			}

			return (ulong)(notReady);
		}
		public static void whereOrInfoDelete(sqlite3 db, WhereOrInfo p)
		{
			sqlite3WhereClauseClear(p.wc);
			sqlite3DbFree(db, p);
		}
		public static int whereOrInsert(WhereOrSet pSet, ulong prereq, short rRun, short nOut)
		{
			ushort i = 0;
			WhereOrCost* p;
			for (i = (ushort)(pSet.n), p = pSet.a; (i) > (0); i--, p++)
			{
				if (((rRun) <= (p->rRun)) && ((prereq & p->prereq) == (prereq)))
				{
					goto whereOrInsert_done;
				}

				if (((p->rRun) <= (rRun)) && ((p->prereq & prereq) == (p->prereq)))
				{
					return (int)(0);
				}
			}

			if ((pSet.n) < (3))
			{
				p = &pSet.a[pSet.n++];
				p->nOut = (short)(nOut);
			}
			else
			{
				p = pSet.a;
				for (i = (ushort)(1); (i) < (pSet.n); i++)
				{
					if ((p->rRun) > (pSet.a[i].rRun))
						p = pSet.a + i;
				}

				if ((p->rRun) <= (rRun))
					return (int)(0);
			}

		whereOrInsert_done:
			; p->prereq = (ulong)(prereq);
			p->rRun = (short)(rRun);
			if ((p->nOut) > (nOut))
				p->nOut = (short)(nOut);
			return (int)(1);
		}
		public static void whereOrMove(WhereOrSet pDest, WhereOrSet pSrc)
		{
			pDest.n = (ushort)(pSrc.n);
			CRuntime.memcpy(pDest.a, pSrc.a, (ulong)(pDest.n * sizeof(WhereOrCost)));
		}
		public static sbyte wherePathSatisfiesOrderBy(WhereInfo pWInfo, ExprList pOrderBy, WherePath pPath, ushort wctrlFlags, ushort nLoop, WhereLoop pLast, ulong* pRevMask)
		{
			byte revSet = 0;
			byte rev = 0;
			byte revIdx = 0;
			byte isOrderDistinct = 0;
			byte distinctColumns = 0;
			byte isMatch = 0;
			ushort eqOpMask = 0;
			ushort nKeyCol = 0;
			ushort nColumn = 0;
			ushort nOrderBy = 0;
			int iLoop = 0;
			int i = 0; int j = 0;
			int iCur = 0;
			int iColumn = 0;
			WhereLoop pLoop = null;
			WhereTerm pTerm;
			Expr pOBExpr;
			CollSeq pColl;
			Index pIndex;
			sqlite3 db = pWInfo.pParse.db;
			ulong obSat = (ulong)(0);
			ulong obDone = 0;
			ulong orderDistinctMask = 0;
			ulong ready = 0;

			if (((nLoop) != 0) && (((db).dbOptFlags & (0x00000040)) != 0))
				return (sbyte)(0);
			nOrderBy = (ushort)(pOrderBy.nExpr);
			if ((nOrderBy) > (((int)(sizeof(ulong) * 8)) - 1))
				return (sbyte)(0);
			isOrderDistinct = (byte)(1);
			obDone = (ulong)((((ulong)(1)) << (nOrderBy)) - 1);
			orderDistinctMask = (ulong)(0);
			ready = (ulong)(0);
			eqOpMask = (ushort)(0x0002 | 0x0080 | 0x0100);
			if ((wctrlFlags & (0x0800 | 0x0002 | 0x0001)) != 0)
			{
				eqOpMask |= (ushort)(0x0001);
			}

			for (iLoop = (int)(0); (((isOrderDistinct) != 0) && ((obSat) < (obDone))) && ((iLoop) <= (nLoop)); iLoop++)
			{
				if ((iLoop) > (0))
					ready |= (ulong)(pLoop.maskSelf);
				if ((iLoop) < (nLoop))
				{
					pLoop = pPath.aLoop[iLoop];
					if ((wctrlFlags & 0x0800) != 0)
						continue;
				}
				else
				{
					pLoop = pLast;
				}

				if ((pLoop.wsFlags & 0x00000400) != 0)
				{
					if (((pLoop.u.vtab.isOrdered) != 0) && ((wctrlFlags & 0x0080) == (0)))
					{
						obSat = (ulong)(obDone);
					}

					break;
				}
				else if ((wctrlFlags & 0x0080) != 0)
				{
					pLoop.u.btree.nDistinctCol = (ushort)(0);
				}

				iCur = (int)(pWInfo.pTabList.a[pLoop.iTab].iCursor);
				for (i = (int)(0); (i) < (nOrderBy); i++)
				{
					if (((((ulong)(1)) << (i)) & obSat) != 0)
						continue;
					pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy.a[i].pExpr);
					if (((pOBExpr) == (null)))
						continue;
					if ((pOBExpr.op != 167) && (pOBExpr.op != 169))
						continue;
					if (pOBExpr.iTable != iCur)
						continue;
					pTerm = sqlite3WhereFindTerm(pWInfo.sWC, (int)(iCur), (int)(pOBExpr.iColumn), (ulong)(~ready), (uint)(eqOpMask), null);
					if ((pTerm) == (null))
						continue;
					if ((pTerm.eOperator) == (0x0001))
					{

						for (j = (int)(0); ((j) < (pLoop.nLTerm)) && (pTerm != pLoop.aLTerm[j]); j++)
						{
						}

						if ((j) >= (pLoop.nLTerm))
							continue;
					}

					if (((pTerm.eOperator & (0x0002 | 0x0080)) != 0) && ((pOBExpr.iColumn) >= (0)))
					{
						Parse pParse = pWInfo.pParse;
						CollSeq pColl1 = sqlite3ExprNNCollSeq(pParse, pOrderBy.a[i].pExpr);
						CollSeq pColl2 = sqlite3ExprCompareCollSeq(pParse, pTerm.pExpr);

						if (((pColl2) == (null)) || ((sqlite3StrICmp(pColl1.zName, pColl2.zName)) != 0))
						{
							continue;
						}
					}

					obSat |= (ulong)(((ulong)(1)) << (i));
				}

				if ((pLoop.wsFlags & 0x00001000) == (0))
				{
					if ((pLoop.wsFlags & 0x00000100) != 0)
					{
						pIndex = null;
						nKeyCol = (ushort)(0);
						nColumn = (ushort)(1);
					}
					else if (((pIndex = pLoop.u.btree.pIndex) == (null)) || ((pIndex.bUnordered) != 0))
					{
						return (sbyte)(0);
					}
					else
					{
						nKeyCol = (ushort)(pIndex.nKeyCol);
						nColumn = (ushort)(pIndex.nColumn);


						isOrderDistinct = (byte)(((pIndex).onError != 0) && ((pLoop.wsFlags & 0x00008000) == (0)));
					}

					rev = (byte)(revSet = (byte)(0));
					distinctColumns = (byte)(0);
					for (j = (int)(0); (j) < (nColumn); j++)
					{
						byte bOnce = (byte)(1);

						if (((j) < (pLoop.u.btree.nEq)) && ((j) >= (pLoop.nSkip)))
						{
							ushort eOp = (ushort)(pLoop.aLTerm[j].eOperator);
							if ((eOp & eqOpMask) != 0)
							{
								if ((eOp & (0x0100 | 0x0080)) != 0)
								{
									isOrderDistinct = (byte)(0);
								}

								continue;
							}
							else if ((eOp & 0x0001) != 0)
							{
								Expr pX = pLoop.aLTerm[j].pExpr;
								for (i = (int)(j + 1); (i) < (pLoop.u.btree.nEq); i++)
								{
									if ((pLoop.aLTerm[i].pExpr) == (pX))
									{

										bOnce = (byte)(0);
										break;
									}
								}
							}
						}

						if ((pIndex) != null)
						{
							iColumn = (int)(pIndex.aiColumn[j]);
							revIdx = (byte)(pIndex.aSortOrder[j] & 0x01);
							if ((iColumn) == (pIndex.pTable.iPKey))
								iColumn = (int)(-1);
						}
						else
						{
							iColumn = (int)(-1);
							revIdx = (byte)(0);
						}

						if ((isOrderDistinct) != 0)
						{
							if ((((iColumn) >= (0)) && ((j) >= (pLoop.u.btree.nEq))) && ((pIndex.pTable.aCol[iColumn].notNull) == (0)))
							{
								isOrderDistinct = (byte)(0);
							}

							if ((iColumn) == (-2))
							{
								isOrderDistinct = (byte)(0);
							}
						}

						isMatch = (byte)(0);
						for (i = (int)(0); ((bOnce) != 0) && ((i) < (nOrderBy)); i++)
						{
							if (((((ulong)(1)) << (i)) & obSat) != 0)
								continue;
							pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy.a[i].pExpr);
							if (((pOBExpr) == (null)))
								continue;
							if ((wctrlFlags & (0x0040 | 0x0080)) == (0))
								bOnce = (byte)(0);
							if ((iColumn) >= (-1))
							{
								if ((pOBExpr.op != 167) && (pOBExpr.op != 169))
									continue;
								if (pOBExpr.iTable != iCur)
									continue;
								if (pOBExpr.iColumn != iColumn)
									continue;
							}
							else
							{
								Expr pIdxExpr = pIndex.aColExpr.a[j].pExpr;
								if ((sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, (int)(iCur))) != 0)
								{
									continue;
								}
							}

							if (iColumn != (-1))
							{
								pColl = sqlite3ExprNNCollSeq(pWInfo.pParse, pOrderBy.a[i].pExpr);
								if (sqlite3StrICmp(pColl.zName, pIndex.azColl[j]) != 0)
									continue;
							}

							if ((wctrlFlags & 0x0080) != 0)
							{
								pLoop.u.btree.nDistinctCol = (ushort)(j + 1);
							}

							isMatch = (byte)(1);
							break;
						}

						if (((isMatch) != 0) && ((wctrlFlags & 0x0040) == (0)))
						{
							if ((revSet) != 0)
							{
								if ((rev ^ revIdx) != (pOrderBy.a[i].sortFlags & 0x01))
								{
									isMatch = (byte)(0);
								}
							}
							else
							{
								rev = (byte)(revIdx ^ (pOrderBy.a[i].sortFlags & 0x01));
								if ((rev) != 0)
									*pRevMask |= (ulong)(((ulong)(1)) << (iLoop));
								revSet = (byte)(1);
							}
						}

						if (((isMatch) != 0) && ((pOrderBy.a[i].sortFlags & 0x02) != 0))
						{
							if ((j) == (pLoop.u.btree.nEq))
							{
								pLoop.wsFlags |= (uint)(0x00080000);
							}
							else
							{
								isMatch = (byte)(0);
							}
						}

						if ((isMatch) != 0)
						{
							if ((iColumn) == (-1))
							{
								distinctColumns = (byte)(1);
							}

							obSat |= (ulong)(((ulong)(1)) << (i));
						}
						else
						{
							if (((j) == (0)) || ((j) < (nKeyCol)))
							{
								isOrderDistinct = (byte)(0);
							}

							break;
						}
					}

					if ((distinctColumns) != 0)
					{
						isOrderDistinct = (byte)(1);
					}
				}

				if ((isOrderDistinct) != 0)
				{
					orderDistinctMask |= (ulong)(pLoop.maskSelf);
					for (i = (int)(0); (i) < (nOrderBy); i++)
					{
						Expr p;
						ulong mTerm = 0;
						if (((((ulong)(1)) << (i)) & obSat) != 0)
							continue;
						p = pOrderBy.a[i].pExpr;
						mTerm = (ulong)(sqlite3WhereExprUsage(&pWInfo.sMaskSet, p));
						if (((mTerm) == (0)) && (sqlite3ExprIsConstant(p) == 0))
							continue;
						if ((mTerm & ~orderDistinctMask) == (0))
						{
							obSat |= (ulong)(((ulong)(1)) << (i));
						}
					}
				}
			}

			if ((obSat) == (obDone))
				return (sbyte)(nOrderBy);
			if (isOrderDistinct == 0)
			{
				for (i = (int)(nOrderBy - 1); (i) > (0); i--)
				{
					ulong m = (ulong)(((i) < ((int)(sizeof(ulong) * 8))) ? (((ulong)(1)) << (i)) - 1 : 0);
					if ((obSat & m) == (m))
						return (sbyte)(i);
				}

				return (sbyte)(0);
			}

			return (sbyte)(-1);
		}
		public static int wherePathSolver(WhereInfo pWInfo, short nRowEst)
		{
			int mxChoice = 0;
			int nLoop = 0;
			Parse pParse;
			sqlite3 db;
			int iLoop = 0;
			int ii = 0; int jj = 0;
			int mxI = (int)(0);
			int nOrderBy = 0;
			short mxCost = (short)(0);
			short mxUnsorted = (short)(0);
			int nTo = 0; int nFrom = 0;
			WherePath aFrom;
			WherePath aTo;
			WherePath pFrom;
			WherePath pTo;
			WhereLoop pWLoop;
			WhereLoop pX;
			short* aSortCost = null;
			sbyte* pSpace;
			int nSpace = 0;
			pParse = pWInfo.pParse;
			db = pParse.db;
			nLoop = (int)(pWInfo.nLevel);
			mxChoice = (int)(((nLoop) <= (1)) ? 1 : ((nLoop) == (2) ? 5 : 10));

			if (((pWInfo.pOrderBy) == (null)) || ((nRowEst) == (0)))
			{
				nOrderBy = (int)(0);
			}
			else
			{
				nOrderBy = (int)(pWInfo.pOrderBy.nExpr);
			}

			nSpace = (int)((sizeof(WherePath) + sizeof(WhereLoop) * nLoop) * mxChoice * 2);
			nSpace += (int)(sizeof(short) * nOrderBy);
			pSpace = sqlite3DbMallocRawNN(db, (ulong)(nSpace));
			if ((pSpace) == (null))
				return (int)(7);
			aTo = (WherePath)(pSpace);
			aFrom = aTo[mxChoice];
			CRuntime.memset(aFrom, (int)(0), (ulong)(sizeof(WherePath)));
			pX = (WhereLoop)(aFrom[mxChoice]);
			for (ii = (int)(mxChoice * 2), pFrom = aTo; (ii) > (0); ii--, pFrom++, pX += nLoop)
			{
				pFrom.aLoop = pX;
			}

			if ((nOrderBy) != 0)
			{
				aSortCost = (short*)(pX);
				CRuntime.memset(aSortCost, (int)(0), (ulong)(sizeof(short) * nOrderBy));
			}



			aFrom[0].nRow = (short)((pParse.nQueryLoop) < (48) ? (pParse.nQueryLoop) : (48));

			nFrom = (int)(1);

			if ((nOrderBy) != 0)
			{
				aFrom[0].isOrdered = (sbyte)((nLoop) > (0) ? -1 : nOrderBy);
			}

			for (iLoop = (int)(0); (iLoop) < (nLoop); iLoop++)
			{
				nTo = (int)(0);
				for (ii = (int)(0), pFrom = aFrom; (ii) < (nFrom); ii++, pFrom++)
				{
					for (pWLoop = pWInfo.pLoops; pWLoop; pWLoop = pWLoop.pNextLoop)
					{
						short nOut = 0;
						short rCost = 0;
						short rUnsorted = 0;
						sbyte isOrdered = (sbyte)(pFrom.isOrdered);
						ulong maskNew = 0;
						ulong revMask = (ulong)(0);
						if ((pWLoop.prereq & ~pFrom.maskLoop) != 0)
							continue;
						if ((pWLoop.maskSelf & pFrom.maskLoop) != 0)
							continue;
						if (((pWLoop.wsFlags & 0x00004000) != 0) && ((pFrom.nRow) < (3)))
						{

							continue;
						}

						rUnsorted = (short)(sqlite3LogEstAdd((short)(pWLoop.rSetup), (short)(pWLoop.rRun + pFrom.nRow)));
						rUnsorted = (short)(sqlite3LogEstAdd((short)(rUnsorted), (short)(pFrom.rUnsorted)));
						nOut = (short)(pFrom.nRow + pWLoop.nOut);
						maskNew = (ulong)(pFrom.maskLoop | pWLoop.maskSelf);
						if ((isOrdered) < (0))
						{
							isOrdered = (sbyte)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, (ushort)(pWInfo.wctrlFlags), (ushort)(iLoop), pWLoop, &revMask));
						}
						else
						{
							revMask = (ulong)(pFrom.revLoop);
						}

						if (((isOrdered) >= (0)) && ((isOrdered) < (nOrderBy)))
						{
							if ((aSortCost[isOrdered]) == (0))
							{
								aSortCost[isOrdered] = (short)(whereSortingCost(pWInfo, (short)(nRowEst), (int)(nOrderBy), (int)(isOrdered)));
							}

							rCost = (short)(sqlite3LogEstAdd((short)(rUnsorted), (short)(aSortCost[isOrdered])) + 5);
						}
						else
						{
							rCost = (short)(rUnsorted);
							rUnsorted -= (short)(2);
						}

						for (jj = (int)(0), pTo = aTo; (jj) < (nTo); jj++, pTo++)
						{
							if (((pTo.maskLoop) == (maskNew)) && (((pTo.isOrdered ^ isOrdered) & 0x80) == (0)))
							{
								break;
							}
						}

						if ((jj) >= (nTo))
						{
							if (((nTo) >= (mxChoice)) && (((rCost) > (mxCost)) || (((rCost) == (mxCost)) && ((rUnsorted) >= (mxUnsorted)))))
							{
								continue;
							}

							if ((nTo) < (mxChoice))
							{
								jj = (int)(nTo++);
							}
							else
							{
								jj = (int)(mxI);
							}

							pTo = aTo[jj];
						}
						else
						{
							if (((pTo.rCost) < (rCost)) || (((pTo.rCost) == (rCost)) && (((pTo.nRow) < (nOut)) || (((pTo.nRow) == (nOut)) && ((pTo.rUnsorted) <= (rUnsorted))))))
							{
								continue;
							}
						}

						pTo.maskLoop = (ulong)(pFrom.maskLoop | pWLoop.maskSelf);
						pTo.revLoop = (ulong)(revMask);
						pTo.nRow = (short)(nOut);
						pTo.rCost = (short)(rCost);
						pTo.rUnsorted = (short)(rUnsorted);
						pTo.isOrdered = (sbyte)(isOrdered);
						CRuntime.memcpy(pTo.aLoop, pFrom.aLoop, (ulong)(sizeof(WhereLoop) * iLoop));
						pTo.aLoop[iLoop] = pWLoop;
						if ((nTo) >= (mxChoice))
						{
							mxI = (int)(0);
							mxCost = (short)(aTo[0].rCost);
							mxUnsorted = (short)(aTo[0].nRow);
							for (jj = (int)(1), pTo = aTo[1]; (jj) < (mxChoice); jj++, pTo++)
							{
								if (((pTo.rCost) > (mxCost)) || (((pTo.rCost) == (mxCost)) && ((pTo.rUnsorted) > (mxUnsorted))))
								{
									mxCost = (short)(pTo.rCost);
									mxUnsorted = (short)(pTo.rUnsorted);
									mxI = (int)(jj);
								}
							}
						}
					}
				}

				pFrom = aTo;
				aTo = aFrom;
				aFrom = pFrom;
				nFrom = (int)(nTo);
			}

			if ((nFrom) == (0))
			{
				sqlite3ErrorMsg(pParse, "no query solution");
				sqlite3DbFreeNN(db, pSpace);
				return (int)(1);
			}

			pFrom = aFrom;
			for (ii = (int)(1); (ii) < (nFrom); ii++)
			{
				if ((pFrom.rCost) > (aFrom[ii].rCost))
					pFrom = aFrom[ii];
			}


			for (iLoop = (int)(0); (iLoop) < (nLoop); iLoop++)
			{
				WhereLevel pLevel = pWInfo.a[iLoop];
				pLevel.pWLoop = pWLoop = pFrom.aLoop[iLoop];
				pLevel.iFrom = (byte)(pWLoop.iTab);
				pLevel.iTabCur = (int)(pWInfo.pTabList.a[pLevel.iFrom].iCursor);
			}

			if (((((pWInfo.wctrlFlags & 0x0100) != 0) && ((pWInfo.wctrlFlags & 0x0080) == (0))) && ((pWInfo.eDistinct) == (0))) && ((nRowEst) != 0))
			{
				ulong notUsed = 0;
				int rc = (int)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pResultSet, pFrom, (ushort)(0x0080), (ushort)(nLoop - 1), pFrom.aLoop[nLoop - 1], &notUsed));
				if ((rc) == (pWInfo.pResultSet.nExpr))
				{
					pWInfo.eDistinct = (byte)(2);
				}
			}

			pWInfo.bOrderedInnerLoop = (uint)(0);
			if ((pWInfo.pOrderBy) != null)
			{
				if ((pWInfo.wctrlFlags & 0x0080) != 0)
				{
					if ((pFrom.isOrdered) == (pWInfo.pOrderBy.nExpr))
					{
						pWInfo.eDistinct = (byte)(2);
					}
				}
				else
				{
					pWInfo.nOBSat = (sbyte)(pFrom.isOrdered);
					pWInfo.revMask = (ulong)(pFrom.revLoop);
					if ((pWInfo.nOBSat) <= (0))
					{
						pWInfo.nOBSat = (sbyte)(0);
						if ((nLoop) > (0))
						{
							uint wsFlags = (uint)(pFrom.aLoop[nLoop - 1].wsFlags);
							if (((wsFlags & 0x00001000) == (0)) && ((wsFlags & (0x00000100 | 0x00000004)) != (0x00000100 | 0x00000004)))
							{
								ulong m = (ulong)(0);
								int rc = (int)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, (ushort)(0x0800), (ushort)(nLoop - 1), pFrom.aLoop[nLoop - 1], &m));
								if ((rc) == (pWInfo.pOrderBy.nExpr))
								{
									pWInfo.bOrderedInnerLoop = (uint)(1);
									pWInfo.revMask = (ulong)(m);
								}
							}
						}
					}
					else if ((((nLoop) != 0) && ((pWInfo.nOBSat) == (1))) && ((pWInfo.wctrlFlags & (0x0001 | 0x0002)) != 0))
					{
						pWInfo.bOrderedInnerLoop = (uint)(1);
					}
				}

				if ((((pWInfo.wctrlFlags & 0x0200) != 0) && ((pWInfo.nOBSat) == (pWInfo.pOrderBy.nExpr))) && ((nLoop) > (0)))
				{
					ulong revMask = (ulong)(0);
					int nOrder = (int)(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, (ushort)(0), (ushort)(nLoop - 1), pFrom.aLoop[nLoop - 1], &revMask));

					if ((nOrder) == (pWInfo.pOrderBy.nExpr))
					{
						pWInfo.sorted = (uint)(1);
						pWInfo.revMask = (ulong)(revMask);
					}
				}
			}

			pWInfo.nRowOut = (short)(pFrom.nRow);
			sqlite3DbFreeNN(db, pSpace);
			return (int)(0);
		}
		public static short whereRangeAdjust(WhereTerm pTerm, short nNew)
		{
			short nRet = (short)(nNew);
			if ((pTerm) != null)
			{
				if ((pTerm.truthProb) <= (0))
				{
					nRet += (short)(pTerm.truthProb);
				}
				else if ((pTerm.wtFlags & 0x0080) == (0))
				{
					nRet -= (short)(20);

				}
			}

			return (short)(nRet);
		}
		public static int whereRangeScanEst(Parse pParse, WhereLoopBuilder pBuilder, WhereTerm pLower, WhereTerm pUpper, WhereLoop pLoop)
		{
			int rc = (int)(0);
			int nOut = (int)(pLoop.nOut);
			short nNew = 0;
			(void)(pParse);
			(void)(pBuilder);


			nNew = (short)(whereRangeAdjust(pLower, (short)(nOut)));
			nNew = (short)(whereRangeAdjust(pUpper, (short)(nNew)));
			if (((((pLower) != null) && ((pLower.truthProb) > (0))) && ((pUpper) != null)) && ((pUpper.truthProb) > (0)))
			{
				nNew -= (short)(20);
			}

			nOut -= (int)((pLower != null) + (pUpper != null));
			if ((nNew) < (10))
				nNew = (short)(10);
			if ((nNew) < (nOut))
				nOut = (int)(nNew);
			pLoop.nOut = ((short)(nOut));
			return (int)(rc);
		}
		public static int whereRangeVectorLen(Parse pParse, int iCur, Index pIdx, int nEq, WhereTerm pTerm)
		{
			int nCmp = (int)(sqlite3ExprVectorSize(pTerm.pExpr.pLeft));
			int i = 0;
			nCmp = (int)((nCmp) < (pIdx.nColumn - nEq) ? (nCmp) : (pIdx.nColumn - nEq));
			for (i = (int)(1); (i) < (nCmp); i++)
			{
				sbyte aff = 0;
				sbyte idxaff = (sbyte)(0);
				CollSeq pColl;
				Expr pLhs;
				Expr pRhs;

				pLhs = pTerm.pExpr.pLeft.x.pList.a[i].pExpr;
				pRhs = pTerm.pExpr.pRight;
				if ((((pRhs).flags & 0x000800) != 0))
				{
					pRhs = pRhs.x.pSelect.pEList.a[i].pExpr;
				}
				else
				{
					pRhs = pRhs.x.pList.a[i].pExpr;
				}

				if ((((pLhs.op != 167) || (pLhs.iTable != iCur)) || (pLhs.iColumn != pIdx.aiColumn[i + nEq])) || (pIdx.aSortOrder[i + nEq] != pIdx.aSortOrder[nEq]))
				{
					break;
				}

				aff = (sbyte)(sqlite3CompareAffinity(pRhs, (sbyte)(sqlite3ExprAffinity(pLhs))));
				idxaff = (sbyte)(sqlite3TableColumnAffinity(pIdx.pTable, (int)(pLhs.iColumn)));
				if (aff != idxaff)
					break;
				pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
				if ((pColl) == (null))
					break;
				if ((sqlite3StrICmp(pColl.zName, pIdx.azColl[i + nEq])) != 0)
					break;
			}

			return (int)(i);
		}
		public static Expr whereRightSubexprIsColumn(Expr p)
		{
			p = sqlite3ExprSkipCollateAndLikely(p.pRight);
			if (((p != null) && ((p.op) == (167))) && (!(((p).flags & (0x000008)) != 0)))
			{
				return p;
			}

			return null;
		}
		public static WhereTerm whereScanInit(WhereScan pScan, WhereClause pWC, int iCur, int iColumn, uint opMask, Index pIdx)
		{
			pScan.pOrigWC = pWC;
			pScan.pWC = pWC;
			pScan.pIdxExpr = null;
			pScan.idxaff = (sbyte)(0);
			pScan.zCollName = null;
			pScan.opMask = (uint)(opMask);
			pScan.k = (int)(0);
			pScan.aiCur[0] = (int)(iCur);
			pScan.nEquiv = (byte)(1);
			pScan.iEquiv = (byte)(1);
			if ((pIdx) != null)
			{
				int j = (int)(iColumn);
				iColumn = (int)(pIdx.aiColumn[j]);
				if ((iColumn) == (pIdx.pTable.iPKey))
				{
					iColumn = (int)(-1);
				}
				else if ((iColumn) >= (0))
				{
					pScan.idxaff = (sbyte)(pIdx.pTable.aCol[iColumn].affinity);
					pScan.zCollName = pIdx.azColl[j];
				}
				else if ((iColumn) == (-2))
				{
					pScan.pIdxExpr = pIdx.aColExpr.a[j].pExpr;
					pScan.zCollName = pIdx.azColl[j];
					pScan.aiColumn[0] = (short)(-2);
					return whereScanInitIndexExpr(pScan);
				}
			}
			else if ((iColumn) == (-2))
			{
				return null;
			}

			pScan.aiColumn[0] = (short)(iColumn);
			return whereScanNext(pScan);
		}
		public static WhereTerm whereScanInitIndexExpr(WhereScan pScan)
		{
			pScan.idxaff = (sbyte)(sqlite3ExprAffinity(pScan.pIdxExpr));
			return whereScanNext(pScan);
		}
		public static WhereTerm whereScanNext(WhereScan pScan)
		{
			int iCur = 0;
			short iColumn = 0;
			Expr pX;
			WhereClause pWC;
			WhereTerm pTerm;
			int k = (int)(pScan.k);

			pWC = pScan.pWC;
			while ((1) != 0)
			{
				iColumn = (short)(pScan.aiColumn[pScan.iEquiv - 1]);
				iCur = (int)(pScan.aiCur[pScan.iEquiv - 1]);


				do
				{
					for (pTerm = pWC.a[k]; (k) < (pWC.nTerm); k++, pTerm++)
					{

						if (((((pTerm.leftCursor) == (iCur)) && ((pTerm.u.x.leftColumn) == (iColumn))) && ((iColumn != (-2)) || ((sqlite3ExprCompareSkip(pTerm.pExpr.pLeft, pScan.pIdxExpr, (int)(iCur))) == (0)))) && (((pScan.iEquiv) <= (1)) || (!(((pTerm.pExpr).flags & (0x000001)) != 0))))
						{
							if ((((pTerm.eOperator & 0x0800) != 0) && ((pScan.nEquiv) < ((int)(11 * sizeof(int) / sizeof(int))))) && ((pX = whereRightSubexprIsColumn(pTerm.pExpr)) != null))
							{
								int j = 0;
								for (j = (int)(0); (j) < (pScan.nEquiv); j++)
								{
									if (((pScan.aiCur[j]) == (pX.iTable)) && ((pScan.aiColumn[j]) == (pX.iColumn)))
									{
										break;
									}
								}

								if ((j) == (pScan.nEquiv))
								{
									pScan.aiCur[j] = (int)(pX.iTable);
									pScan.aiColumn[j] = (short)(pX.iColumn);
									pScan.nEquiv++;
								}
							}

							if ((pTerm.eOperator & pScan.opMask) != 0)
							{
								if (((pScan.zCollName) != null) && ((pTerm.eOperator & 0x0100) == (0)))
								{
									CollSeq pColl;
									Parse pParse = pWC.pWInfo.pParse;
									pX = pTerm.pExpr;
									if (sqlite3IndexAffinityOk(pX, (sbyte)(pScan.idxaff)) == 0)
									{
										continue;
									}


									pColl = sqlite3ExprCompareCollSeq(pParse, pX);
									if ((pColl) == (null))
										pColl = pParse.db.pDfltColl;
									if ((sqlite3StrICmp(pColl.zName, pScan.zCollName)) != 0)
									{
										continue;
									}
								}

								if ((((((pTerm.eOperator & (0x0002 | 0x0080)) != 0) && (pX = pTerm.pExpr.pRight, (pX != null))) && ((pX.op) == (167))) && ((pX.iTable) == (pScan.aiCur[0]))) && ((pX.iColumn) == (pScan.aiColumn[0])))
								{
									continue;
								}

								pScan.pWC = pWC;
								pScan.k = (int)(k + 1);
								return pTerm;
							}
						}
					}

					pWC = pWC.pOuter;
					k = (int)(0);
				}
				while (pWC != null);
				if ((pScan.iEquiv) >= (pScan.nEquiv))
					break;
				pWC = pScan.pOrigWC;
				k = (int)(0);
				pScan.iEquiv++;
			}

			return null;
		}
		public static int whereShortCut(WhereLoopBuilder pBuilder)
		{
			WhereInfo pWInfo;
			SrcItem pItem;
			WhereClause pWC;
			WhereTerm pTerm;
			WhereLoop pLoop;
			int iCur = 0;
			int j = 0;
			Table pTab;
			Index pIdx;
			WhereScan scan = new WhereScan();
			pWInfo = pBuilder.pWInfo;
			if ((pWInfo.wctrlFlags & 0x0020) != 0)
				return (int)(0);

			pItem = pWInfo.pTabList.a;
			pTab = pItem.pTab;
			if ((((pTab).eTabType) == (1)))
				return (int)(0);
			if ((pItem.fg.isIndexedBy) != 0)
				return (int)(0);
			iCur = (int)(pItem.iCursor);
			pWC = pWInfo.sWC;
			pLoop = pBuilder.pNew;
			pLoop.wsFlags = (uint)(0);
			pLoop.nSkip = (ushort)(0);
			pTerm = whereScanInit(scan, pWC, (int)(iCur), (int)(-1), (uint)(0x0002 | 0x0080), null);
			while (((pTerm) != null) && ((pTerm.prereqRight) != 0))
			{
				pTerm = whereScanNext(scan);
			}

			if ((pTerm) != null)
			{
				pLoop.wsFlags = (uint)(0x00000001 | 0x00000100 | 0x00001000);
				pLoop.aLTerm[0] = pTerm;
				pLoop.nLTerm = (ushort)(1);
				pLoop.u.btree.nEq = (ushort)(1);
				pLoop.rRun = (short)(33);
			}
			else
			{
				for (pIdx = pTab.pIndex; pIdx; pIdx = pIdx.pNext)
				{
					int opMask = 0;

					if (((!((pIdx).onError != 0)) || (pIdx.pPartIdxWhere != null)) || ((pIdx.nKeyCol) > ((int)(3 * sizeof(WhereTerm) / sizeof(WhereTerm)))))
						continue;
					opMask = (int)((pIdx.uniqNotNull) != 0 ? (0x0002 | 0x0080) : 0x0002);
					for (j = (int)(0); (j) < (pIdx.nKeyCol); j++)
					{
						pTerm = whereScanInit(scan, pWC, (int)(iCur), (int)(j), (uint)(opMask), pIdx);
						while (((pTerm) != null) && ((pTerm.prereqRight) != 0))
						{
							pTerm = whereScanNext(scan);
						}

						if ((pTerm) == (null))
							break;
						pLoop.aLTerm[j] = pTerm;
					}

					if (j != pIdx.nKeyCol)
						continue;
					pLoop.wsFlags = (uint)(0x00000001 | 0x00001000 | 0x00000200);
					if (((pIdx.isCovering) != 0) || ((pItem.colUsed & pIdx.colNotIdxed) == (0)))
					{
						pLoop.wsFlags |= (uint)(0x00000040);
					}

					pLoop.nLTerm = (ushort)(j);
					pLoop.u.btree.nEq = (ushort)(j);
					pLoop.u.btree.pIndex = pIdx;
					pLoop.rRun = (short)(39);
					break;
				}
			}

			if ((pLoop.wsFlags) != 0)
			{
				pLoop.nOut = ((short)(1));
				pWInfo.a[0].pWLoop = pLoop;

				pLoop.maskSelf = (ulong)(1);
				pWInfo.a[0].iTabCur = (int)(iCur);
				pWInfo.nRowOut = (short)(1);
				if ((pWInfo.pOrderBy) != null)
					pWInfo.nOBSat = (sbyte)(pWInfo.pOrderBy.nExpr);
				if ((pWInfo.wctrlFlags & 0x0100) != 0)
				{
					pWInfo.eDistinct = (byte)(1);
				}

				if ((scan.iEquiv) > (1))
					pLoop.wsFlags |= (uint)(0x00200000);
				return (int)(1);
			}

			return (int)(0);
		}
		public static short whereSortingCost(WhereInfo pWInfo, short nRow, int nOrderBy, int nSorted)
		{
			short rScale = 0; short rSortCost = 0;

			rScale = (short)(sqlite3LogEst((ulong)((nOrderBy - nSorted) * 100 / nOrderBy)) - 66);
			rSortCost = (short)(nRow + rScale + 16);
			if (((pWInfo.wctrlFlags & 0x4000) != 0) && ((pWInfo.iLimit) < (nRow)))
			{
				nRow = (short)(pWInfo.iLimit);
			}
			else if ((pWInfo.wctrlFlags & 0x0100) != 0)
			{
				if ((nRow) > (10))
				{
					nRow -= (short)(10);

				}
			}

			rSortCost += (short)(estLog((short)(nRow)));
			return (short)(rSortCost);
		}
		public static void whereUndoExprMods(WhereInfo pWInfo)
		{
			while ((pWInfo.pExprMods) != null)
			{
				WhereExprMod p = pWInfo.pExprMods;
				pWInfo.pExprMods = p.pNext;
				CRuntime.memcpy(p.pExpr, p.orig, (ulong)(sizeof(Expr)));
				sqlite3DbFree(pWInfo.pParse.db, p);
			}
		}
		public static int whereUsablePartialIndex(int iTab, int isLeft, WhereClause pWC, Expr pWhere)
		{
			int i = 0;
			WhereTerm pTerm;
			Parse pParse = pWC.pWInfo.pParse;
			while ((pWhere.op) == (44))
			{
				if (whereUsablePartialIndex((int)(iTab), (int)(isLeft), pWC, pWhere.pLeft) == 0)
					return (int)(0);
				pWhere = pWhere.pRight;
			}

			if ((pParse.db.flags & 0x00800000) != 0)
				pParse = null;
			for (i = (int)(0), pTerm = pWC.a; (i) < (pWC.nTerm); i++, pTerm++)
			{
				Expr pExpr;
				pExpr = pTerm.pExpr;
				if (((((!(((pExpr).flags & (0x000001)) != 0)) || ((pExpr.w.iRightJoinTable) == (iTab))) && (((isLeft) == (0)) || (((pExpr).flags & (0x000001)) != 0))) && ((sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, (int)(iTab))) != 0)) && ((pTerm.wtFlags & 0x0080) == (0)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static int winAccess(sqlite3_vfs pVfs, sbyte* zFilename, int flags, int* pResOut)
		{
			return 0;
		}
		public static int winCheckReservedLock(sqlite3_file id, int* pResOut)
		{
			int res = 0;
			winFile pFile = (winFile)(id);

			if ((pFile.locktype) >= (2))
			{
				res = (int)(1);
			}
			else
			{
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001), (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0)));
				if ((res) != 0)
				{
					winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0));
				}

				res = (int)(!res);
			}

			*pResOut = (int)(res);
			return (int)(0);
		}
		public static int winClose(sqlite3_file id)
		{
			int rc = 0; int cnt = (int)(0);
			winFile pFile = (winFile)(id);



			winUnmapfile(pFile);
			do
			{
				rc = (int)((Int(Void * ))(aSyscall[3].pCurrent)(pFile.h));
			}
			while ((((rc) == (0)) && ((++cnt) < (3))) && (sqlite3_win32_sleep((uint)(100)), 1));
			if ((rc) != 0)
			{
				pFile.h = null;
			}

			return (int)((rc) != 0 ? 0 : winLogErrorAtLine((int)(10 | (16 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winClose", pFile.zPath, (int)(45624)));
		}
		public static void* winConvertFromUtf8Filename(sbyte* zFilename)
		{
			void* zConverted = null;
			if ((1) != 0)
			{
				zConverted = winUtf8ToUnicode(zFilename);
			}
			else
			{
				zConverted = winUtf8ToMbcs(zFilename, (int)((Int())(aSyscall[0].pCurrent)()));
			}

			return zConverted;
		}
		public static int winCurrentTime(sqlite3_vfs pVfs, double* prNow)
		{
			int rc = 0;
			long i = 0;
			rc = (int)(winCurrentTimeInt64(pVfs, &i));
			if (rc == 0)
			{
				*prNow = (double)(i / 86400000.0);
			}

			return (int)(rc);
		}
		public static int winCurrentTimeInt64(sqlite3_vfs pVfs, long* piNow)
		{
			_FILETIME ft = new _FILETIME();
			(Void(_FILETIME * ))(aSyscall[30].pCurrent)(&ft);
			*piNow = (long)(winCurrentTimeInt64_winFiletimeEpoch + ((((long)(ft.dwHighDateTime)) * winCurrentTimeInt64_max32BitValue) + (long)(ft.dwLowDateTime)) / (long)(10000));
			(void)(pVfs);
			return (int)(0);
		}
		public static int winDelete(sqlite3_vfs pVfs, sbyte* zFilename, int syncDir)
		{
			int cnt = (int)(0);
			int rc = 0;
			uint attr = 0;
			uint lastErrno = (uint)(0);
			void* zConverted;
			(void)(pVfs);
			(void)(syncDir);
			zConverted = winConvertFromUtf8Filename(zFilename);
			if ((zConverted) == (null))
			{
				return (int)(10 | (12 << 8));
			}

			if ((1) != 0)
			{
				do
				{
					attr = (uint)((Uint(UShort * ))(aSyscall[21].pCurrent)(zConverted));
					if ((attr) == ((uint)(-1)))
					{
						lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
						if (((lastErrno) == (2L)) || ((lastErrno) == (3L)))
						{
							rc = (int)(10 | (23 << 8));
						}
						else
						{
							rc = (int)(1);
						}

						break;
					}

					if ((attr & 0x00000010) != 0)
					{
						rc = (int)(1);
						break;
					}

					if (((Int(UShort * ))(aSyscall[10].pCurrent)(zConverted)) != 0)
					{
						rc = (int)(0);
						break;
					}

					if (winRetryIoerr(&cnt, &lastErrno) == 0)
					{
						rc = (int)(1);
						break;
					}
				}
				while ((1) != 0);
			}
			else
			{
				do
				{
					attr = (uint)((Uint(Sbyte * ))(aSyscall[20].pCurrent)(zConverted));
					if ((attr) == ((uint)(-1)))
					{
						lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
						if (((lastErrno) == (2L)) || ((lastErrno) == (3L)))
						{
							rc = (int)(10 | (23 << 8));
						}
						else
						{
							rc = (int)(1);
						}

						break;
					}

					if ((attr & 0x00000010) != 0)
					{
						rc = (int)(1);
						break;
					}

					if (((Int(Sbyte * ))(aSyscall[9].pCurrent)(zConverted)) != 0)
					{
						rc = (int)(0);
						break;
					}

					if (winRetryIoerr(&cnt, &lastErrno) == 0)
					{
						rc = (int)(1);
						break;
					}
				}
				while ((1) != 0);
			}

			if (((rc) != 0) && (rc != (10 | (23 << 8))))
			{
				rc = (int)(winLogErrorAtLine((int)(10 | (10 << 8)), (uint)(lastErrno), "winDelete", zFilename, (int)(48328)));
			}
			else
			{
				winLogIoerr((int)(cnt), (int)(48330));
			}

			sqlite3_free(zConverted);
			return (int)(rc);
		}
		public static int winDeviceCharacteristics(sqlite3_file id)
		{
			winFile p = (winFile)(id);
			return (int)(0x00000800 | ((p.ctrlFlags & 0x10) ? 0x00001000 : 0));
		}
		public static void winDlClose(sqlite3_vfs pVfs, void* pHandle)
		{
			(void)(pVfs);
			(Int(HINSTANCE__ * ))(aSyscall[16].pCurrent)(pHandle);
		}
		public static void winDlError(sqlite3_vfs pVfs, int nBuf, sbyte* zBufOut)
		{
			(void)(pVfs);
			winGetLastErrorMsg((uint)((Uint())(aSyscall[26].pCurrent)()), (int)(nBuf), zBufOut);
		}
		public static void* winDlOpen(sqlite3_vfs pVfs, sbyte* zFilename)
		{
			void* h;
			void* zConverted = winConvertFromUtf8Filename(zFilename);
			(void)(pVfs);
			if ((zConverted) == (null))
			{
				return null;
			}

			if ((1) != 0)
			{
				h = (HINSTANCE__ * (UShort*))(aSyscall[45].pCurrent)((ushort*)(zConverted));
			}
			else
			{
				h = (HINSTANCE__ * (Sbyte*))(aSyscall[44].pCurrent)((sbyte*)(zConverted));
			}

			sqlite3_free(zConverted);
			return h;
		}
		public static Void()winDlSym(sqlite3_vfs pVfs, void* pH, sbyte* zSym)
		{
			long  long() * proc;
			(void)(pVfs);
			proc = (longlong() * (HINSTANCE__ * , HINSTANCE__ * ))(aSyscall[27].pCurrent)(pH, zSym);
			return (Void())(proc);
		}
		public static void windowAggFinal(WindowCodeArg p, int bFin)
		{
			Parse pParse = p.pParse;
			Window pMWin = p.pMWin;
			Vdbe v = sqlite3GetVdbe(pParse);
			Window pWin;
			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				if ((((pMWin.regStartRowid) == (0)) && ((pWin.pFunc.funcFlags & 0x1000) != 0)) && (pWin.eStart != 90))
				{
					sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regResult));
					sqlite3VdbeAddOp1(v, (int)(34), (int)(pWin.csrApp));
					sqlite3VdbeAddOp3(v, (int)(93), (int)(pWin.csrApp), (int)(0), (int)(pWin.regResult));
					sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
				}
				else if ((pWin.regApp) != 0)
				{

				}
				else
				{
					int nArg = (int)(windowArgCount(pWin));
					if ((bFin) != 0)
					{
						sqlite3VdbeAddOp2(v, (int)(164), (int)(pWin.regAccum), (int)(nArg));
						sqlite3VdbeAppendP4(v, pWin.pFunc, (int)(-8));
						sqlite3VdbeAddOp2(v, (int)(79), (int)(pWin.regAccum), (int)(pWin.regResult));
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
					}
					else
					{
						sqlite3VdbeAddOp3(v, (int)(163), (int)(pWin.regAccum), (int)(nArg), (int)(pWin.regResult));
						sqlite3VdbeAppendP4(v, pWin.pFunc, (int)(-8));
					}
				}
			}
		}
		public static void windowAggStep(WindowCodeArg p, Window pMWin, int csr, int bInverse, int reg)
		{
			Parse pParse = p.pParse;
			Vdbe v = sqlite3GetVdbe(pParse);
			Window pWin;
			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				FuncDef pFunc = pWin.pFunc;
				int regArg = 0;
				int nArg = (int)((pWin.bExprArgs) != 0 ? 0 : windowArgCount(pWin));
				int i = 0;


				for (i = (int)(0); (i) < (nArg); i++)
				{
					if ((i != 1) || (pFunc.zName != nth_valueName))
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol + i), (int)(reg + i));
					}
					else
					{
						sqlite3VdbeAddOp3(v, (int)(93), (int)(pMWin.iEphCsr), (int)(pWin.iArgCol + i), (int)(reg + i));
					}
				}

				regArg = (int)(reg);
				if ((((pMWin.regStartRowid) == (0)) && ((pFunc.funcFlags & 0x1000) != 0)) && (pWin.eStart != 90))
				{
					int addrIsNull = (int)(sqlite3VdbeAddOp1(v, (int)(50), (int)(regArg)));
					if ((bInverse) == (0))
					{
						sqlite3VdbeAddOp2(v, (int)(85), (int)(pWin.regApp + 1), (int)(1));
						sqlite3VdbeAddOp2(v, (int)(80), (int)(regArg), (int)(pWin.regApp));
						sqlite3VdbeAddOp3(v, (int)(96), (int)(pWin.regApp), (int)(2), (int)(pWin.regApp + 2));
						sqlite3VdbeAddOp2(v, (int)(137), (int)(pWin.csrApp), (int)(pWin.regApp + 2));
					}
					else
					{
						sqlite3VdbeAddOp4Int(v, (int)(25), (int)(pWin.csrApp), (int)(0), (int)(regArg), (int)(1));
						sqlite3VdbeAddOp1(v, (int)(129), (int)(pWin.csrApp));
						sqlite3VdbeJumpHere(v, (int)(sqlite3VdbeCurrentAddr(v) - 2));
					}

					sqlite3VdbeJumpHere(v, (int)(addrIsNull));
				}
				else if ((pWin.regApp) != 0)
				{


					sqlite3VdbeAddOp2(v, (int)(85), (int)(pWin.regApp + 1 - bInverse), (int)(1));
				}
				else if (pFunc.xSFunc != noopStepFunc)
				{
					int addrIf = (int)(0);
					if ((pWin.pFilter) != null)
					{
						int regTmp = 0;



						regTmp = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol + nArg), (int)(regTmp));
						addrIf = (int)(sqlite3VdbeAddOp3(v, (int)(20), (int)(regTmp), (int)(0), (int)(1)));
						sqlite3ReleaseTempReg(pParse, (int)(regTmp));
					}

					if ((pWin.bExprArgs) != 0)
					{
						int iOp = (int)(sqlite3VdbeCurrentAddr(v));
						int iEnd = 0;

						nArg = (int)(pWin.pOwner.x.pList.nExpr);
						regArg = (int)(sqlite3GetTempRange(pParse, (int)(nArg)));
						sqlite3ExprCodeExprList(pParse, pWin.pOwner.x.pList, (int)(regArg), (int)(0), (byte)(0));
						for (iEnd = (int)(sqlite3VdbeCurrentAddr(v)); (iOp) < (iEnd); iOp++)
						{
							VdbeOp* pOp = sqlite3VdbeGetOp(v, (int)(iOp));
							if (((pOp->opcode) == (93)) && ((pOp->p1) == (pWin.iEphCsr)))
							{
								pOp->p1 = (int)(csr);
							}
						}
					}

					if ((pFunc.funcFlags & 0x0020) != 0)
					{
						CollSeq pColl;


						pColl = sqlite3ExprNNCollSeq(pParse, pWin.pOwner.x.pList.a[0].pExpr);
						sqlite3VdbeAddOp4(v, (int)(84), (int)(0), (int)(0), (int)(0), (sbyte*)(pColl), (int)(-2));
					}

					sqlite3VdbeAddOp3(v, (int)((bInverse) != 0 ? 160 : 161), (int)(bInverse), (int)(regArg), (int)(pWin.regAccum));
					sqlite3VdbeAppendP4(v, pFunc, (int)(-8));
					sqlite3VdbeChangeP5(v, (ushort)((byte)(nArg)));
					if ((pWin.bExprArgs) != 0)
					{
						sqlite3ReleaseTempRange(pParse, (int)(regArg), (int)(nArg));
					}

					if ((addrIf) != 0)
						sqlite3VdbeJumpHere(v, (int)(addrIf));
				}
			}
		}
		public static int windowArgCount(Window pWin)
		{
			ExprList pList;

			pList = pWin.pOwner.x.pList;
			return (int)(pList ? pList.nExpr : 0);
		}
		public static int windowCacheFrame(Window pMWin)
		{
			Window pWin;
			if ((pMWin.regStartRowid) != 0)
				return (int)(1);
			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				FuncDef pFunc = pWin.pFunc;
				if (((((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName))) || ((pFunc.zName) == (leadName))) || ((pFunc.zName) == (lagName)))
				{
					return (int)(1);
				}
			}

			return (int)(0);
		}
		public static void windowCheckValue(Parse pParse, int reg, int eCond)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			int regZero = (int)(sqlite3GetTempReg(pParse));

			sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(regZero));
			if ((eCond) >= (3))
			{
				int regString = (int)(sqlite3GetTempReg(pParse));
				sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(regString), (int)(0), "", (int)(-1));
				sqlite3VdbeAddOp3(v, (int)(57), (int)(regString), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(reg));
				sqlite3VdbeChangeP5(v, (ushort)(0x43 | 0x10));

			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(15), (int)(reg), (int)(sqlite3VdbeCurrentAddr(v) + 2));

			}

			sqlite3VdbeAddOp3(v, (int)(windowCheckValue_aOp[eCond]), (int)(regZero), (int)(sqlite3VdbeCurrentAddr(v) + 2), (int)(reg));
			sqlite3VdbeChangeP5(v, (ushort)(0x43));
			sqlite3MayAbort(pParse);
			sqlite3VdbeAddOp2(v, (int)(70), (int)(1), (int)(2));
			sqlite3VdbeAppendP4(v, (void*)(windowCheckValue_azErr[eCond]), (int)(-1));
			sqlite3ReleaseTempReg(pParse, (int)(regZero));
		}
		public static int windowCodeOp(WindowCodeArg p, int op, int regCountdown, int jumpOnEof)
		{
			int csr = 0; int reg = 0;
			Parse pParse = p.pParse;
			Window pMWin = p.pMWin;
			int ret = (int)(0);
			Vdbe v = p.pVdbe;
			int addrContinue = (int)(0);
			int bPeer = (int)(pMWin.eFrmType != 76);
			int lblDone = (int)(sqlite3VdbeMakeLabel(pParse));
			int addrNextRange = (int)(0);
			if (((op) == (2)) && ((pMWin.eStart) == (90)))
			{

				return (int)(0);
			}

			if ((regCountdown) > (0))
			{
				if ((pMWin.eFrmType) == (89))
				{
					addrNextRange = (int)(sqlite3VdbeCurrentAddr(v));

					if ((op) == (2))
					{
						if ((pMWin.eStart) == (86))
						{
							windowCodeRangeTest(p, (int)(55), (int)(p.current.csr), (int)(regCountdown), (int)(p.start.csr), (int)(lblDone));
						}
						else
						{
							windowCodeRangeTest(p, (int)(57), (int)(p.start.csr), (int)(regCountdown), (int)(p.current.csr), (int)(lblDone));
						}
					}
					else
					{
						windowCodeRangeTest(p, (int)(54), (int)(p.end.csr), (int)(regCountdown), (int)(p.current.csr), (int)(lblDone));
					}
				}
				else
				{
					sqlite3VdbeAddOp3(v, (int)(49), (int)(regCountdown), (int)(lblDone), (int)(1));
				}
			}

			if (((op) == (1)) && ((pMWin.regStartRowid) == (0)))
			{
				windowAggFinal(p, (int)(0));
			}

			addrContinue = (int)(sqlite3VdbeCurrentAddr(v));
			if ((((pMWin.eStart) == (pMWin.eEnd)) && ((regCountdown) != 0)) && ((pMWin.eFrmType) == (89)))
			{
				int regRowid1 = (int)(sqlite3GetTempReg(pParse));
				int regRowid2 = (int)(sqlite3GetTempReg(pParse));
				if ((op) == (2))
				{
					sqlite3VdbeAddOp2(v, (int)(134), (int)(p.start.csr), (int)(regRowid1));
					sqlite3VdbeAddOp2(v, (int)(134), (int)(p.end.csr), (int)(regRowid2));
					sqlite3VdbeAddOp3(v, (int)(57), (int)(regRowid2), (int)(lblDone), (int)(regRowid1));
				}
				else if ((p.regRowid) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(134), (int)(p.end.csr), (int)(regRowid1));
					sqlite3VdbeAddOp3(v, (int)(57), (int)(p.regRowid), (int)(lblDone), (int)(regRowid1));
				}

				sqlite3ReleaseTempReg(pParse, (int)(regRowid1));
				sqlite3ReleaseTempReg(pParse, (int)(regRowid2));

			}

			switch (op)
			{
				case 1:
					csr = (int)(p.current.csr);
					reg = (int)(p.current.reg);
					windowReturnOneRow(p);
					break;
				case 2:
					csr = (int)(p.start.csr);
					reg = (int)(p.start.reg);
					if ((pMWin.regStartRowid) != 0)
					{

						sqlite3VdbeAddOp2(v, (int)(85), (int)(pMWin.regStartRowid), (int)(1));
					}
					else
					{
						windowAggStep(p, pMWin, (int)(csr), (int)(1), (int)(p.regArg));
					}

					break;
				default:

					csr = (int)(p.end.csr);
					reg = (int)(p.end.reg);
					if ((pMWin.regStartRowid) != 0)
					{

						sqlite3VdbeAddOp2(v, (int)(85), (int)(pMWin.regEndRowid), (int)(1));
					}
					else
					{
						windowAggStep(p, pMWin, (int)(csr), (int)(0), (int)(p.regArg));
					}

					break;
			}

			if ((op) == (p.eDelete))
			{
				sqlite3VdbeAddOp1(v, (int)(129), (int)(csr));
				sqlite3VdbeChangeP5(v, (ushort)(0x02));
			}

			if ((jumpOnEof) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(csr), (int)(sqlite3VdbeCurrentAddr(v) + 2));
				ret = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(5), (int)(csr), (int)(sqlite3VdbeCurrentAddr(v) + 1 + bPeer));
				if ((bPeer) != 0)
				{
					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblDone));
				}
			}

			if ((bPeer) != 0)
			{
				int nReg = (int)(pMWin.pOrderBy ? pMWin.pOrderBy.nExpr : 0);
				int regTmp = (int)((nReg) != 0 ? sqlite3GetTempRange(pParse, (int)(nReg)) : 0);
				windowReadPeerValues(p, (int)(csr), (int)(regTmp));
				windowIfNewPeer(pParse, pMWin.pOrderBy, (int)(regTmp), (int)(reg), (int)(addrContinue));
				sqlite3ReleaseTempRange(pParse, (int)(regTmp), (int)(nReg));
			}

			if ((addrNextRange) != 0)
			{
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrNextRange));
			}

			sqlite3VdbeResolveLabel(v, (int)(lblDone));
			return (int)(ret);
		}
		public static void windowCodeRangeTest(WindowCodeArg p, int op, int csr1, int regVal, int csr2, int lbl)
		{
			Parse pParse = p.pParse;
			Vdbe v = sqlite3GetVdbe(pParse);
			ExprList pOrderBy = p.pMWin.pOrderBy;
			int reg1 = (int)(sqlite3GetTempReg(pParse));
			int reg2 = (int)(sqlite3GetTempReg(pParse));
			int regString = (int)(++pParse.nMem);
			int arith = (int)(106);
			int addrGe = 0;
			int addrDone = (int)(sqlite3VdbeMakeLabel(pParse));
			CollSeq pColl;
			windowReadPeerValues(p, (int)(csr1), (int)(reg1));
			windowReadPeerValues(p, (int)(csr2), (int)(reg2));


			if ((pOrderBy.a[0].sortFlags & 0x01) != 0)
			{
				switch (op)
				{
					case 57:
						op = (int)(55);
						break;
					case 54:
						op = (int)(56);
						break;
					default:

						op = (int)(57);
						break;
				}

				arith = (int)(107);
			}

			if ((pOrderBy.a[0].sortFlags & 0x02) != 0)
			{
				int addr = (int)(sqlite3VdbeAddOp1(v, (int)(51), (int)(reg1)));
				switch (op)
				{
					case 57:
						sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lbl));
						break;
					case 54:
						sqlite3VdbeAddOp2(v, (int)(51), (int)(reg2), (int)(lbl));
						break;
					case 55:
						sqlite3VdbeAddOp2(v, (int)(50), (int)(reg2), (int)(lbl));
						break;
					default:

						break;
				}

				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addrDone));
				sqlite3VdbeJumpHere(v, (int)(addr));
				sqlite3VdbeAddOp2(v, (int)(50), (int)(reg2), (int)(lbl));
				if (((op) == (54)) || ((op) == (57)))
				{
					sqlite3VdbeChangeP2(v, (int)(-1), (int)(addrDone));
				}
			}

			sqlite3VdbeAddOp4(v, (int)(117), (int)(0), (int)(regString), (int)(0), "", (int)(-1));
			addrGe = (int)(sqlite3VdbeAddOp3(v, (int)(57), (int)(regString), (int)(0), (int)(reg1)));
			if ((((op) == (57)) && ((arith) == (106))) || (((op) == (55)) && ((arith) == (107))))
			{
				sqlite3VdbeAddOp3(v, (int)(op), (int)(reg2), (int)(lbl), (int)(reg1));
			}

			sqlite3VdbeAddOp3(v, (int)(arith), (int)(regVal), (int)(reg1), (int)(reg1));
			sqlite3VdbeJumpHere(v, (int)(addrGe));
			sqlite3VdbeAddOp3(v, (int)(op), (int)(reg2), (int)(lbl), (int)(reg1));
			pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy.a[0].pExpr);
			sqlite3VdbeAppendP4(v, (void*)(pColl), (int)(-2));
			sqlite3VdbeChangeP5(v, (ushort)(0x80));
			sqlite3VdbeResolveLabel(v, (int)(addrDone));

			sqlite3ReleaseTempReg(pParse, (int)(reg1));
			sqlite3ReleaseTempReg(pParse, (int)(reg2));
		}
		public static int windowExprGtZero(Parse pParse, Expr pExpr)
		{
			int ret = (int)(0);
			sqlite3 db = pParse.db;
			sqlite3_value pVal = null;
			sqlite3ValueFromExpr(db, pExpr, (byte)(db.enc), (byte)(0x43), pVal);
			if (((pVal) != null) && ((sqlite3_value_int(pVal)) > (0)))
			{
				ret = (int)(1);
			}

			sqlite3ValueFree(pVal);
			return (int)(ret);
		}
		public static Window windowFind(Parse pParse, Window pList, sbyte* zName)
		{
			Window p;
			for (p = pList; p; p = p.pNextWin)
			{
				if ((sqlite3StrICmp(p.zName, zName)) == (0))
					break;
			}

			if ((p) == (null))
			{
				sqlite3ErrorMsg(pParse, "no such window: %s", zName);
			}

			return p;
		}
		public static void windowFullScan(WindowCodeArg p)
		{
			Window pWin;
			Parse pParse = p.pParse;
			Window pMWin = p.pMWin;
			Vdbe v = p.pVdbe;
			int regCRowid = (int)(0);
			int regCPeer = (int)(0);
			int regRowid = (int)(0);
			int regPeer = (int)(0);
			int nPeer = 0;
			int lblNext = 0;
			int lblBrk = 0;
			int addrNext = 0;
			int csr = 0;

			csr = (int)(pMWin.csrApp);
			nPeer = (int)(pMWin.pOrderBy ? pMWin.pOrderBy.nExpr : 0);
			lblNext = (int)(sqlite3VdbeMakeLabel(pParse));
			lblBrk = (int)(sqlite3VdbeMakeLabel(pParse));
			regCRowid = (int)(sqlite3GetTempReg(pParse));
			regRowid = (int)(sqlite3GetTempReg(pParse));
			if ((nPeer) != 0)
			{
				regCPeer = (int)(sqlite3GetTempRange(pParse, (int)(nPeer)));
				regPeer = (int)(sqlite3GetTempRange(pParse, (int)(nPeer)));
			}

			sqlite3VdbeAddOp2(v, (int)(134), (int)(pMWin.iEphCsr), (int)(regCRowid));
			windowReadPeerValues(p, (int)(pMWin.iEphCsr), (int)(regCPeer));
			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
			}

			sqlite3VdbeAddOp3(v, (int)(25), (int)(csr), (int)(lblBrk), (int)(pMWin.regStartRowid));
			addrNext = (int)(sqlite3VdbeCurrentAddr(v));
			sqlite3VdbeAddOp2(v, (int)(134), (int)(csr), (int)(regRowid));
			sqlite3VdbeAddOp3(v, (int)(54), (int)(pMWin.regEndRowid), (int)(lblBrk), (int)(regRowid));
			if ((pMWin.eExclude) == (85))
			{
				sqlite3VdbeAddOp3(v, (int)(53), (int)(regCRowid), (int)(lblNext), (int)(regRowid));
			}
			else if (pMWin.eExclude != 66)
			{
				int addr = 0;
				int addrEq = (int)(0);
				KeyInfo pKeyInfo = null;
				if ((pMWin.pOrderBy) != null)
				{
					pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin.pOrderBy, (int)(0), (int)(0));
				}

				if ((pMWin.eExclude) == (94))
				{
					addrEq = (int)(sqlite3VdbeAddOp3(v, (int)(53), (int)(regCRowid), (int)(0), (int)(regRowid)));
				}

				if ((pKeyInfo) != null)
				{
					windowReadPeerValues(p, (int)(csr), (int)(regPeer));
					sqlite3VdbeAddOp3(v, (int)(89), (int)(regPeer), (int)(regCPeer), (int)(nPeer));
					sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
					addr = (int)(sqlite3VdbeCurrentAddr(v) + 1);
					sqlite3VdbeAddOp3(v, (int)(16), (int)(addr), (int)(lblNext), (int)(addr));
				}
				else
				{
					sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(lblNext));
				}

				if ((addrEq) != 0)
					sqlite3VdbeJumpHere(v, (int)(addrEq));
			}

			windowAggStep(p, pMWin, (int)(csr), (int)(0), (int)(p.regArg));
			sqlite3VdbeResolveLabel(v, (int)(lblNext));
			sqlite3VdbeAddOp2(v, (int)(5), (int)(csr), (int)(addrNext));
			sqlite3VdbeJumpHere(v, (int)(addrNext - 1));
			sqlite3VdbeJumpHere(v, (int)(addrNext + 1));
			sqlite3ReleaseTempReg(pParse, (int)(regRowid));
			sqlite3ReleaseTempReg(pParse, (int)(regCRowid));
			if ((nPeer) != 0)
			{
				sqlite3ReleaseTempRange(pParse, (int)(regPeer), (int)(nPeer));
				sqlite3ReleaseTempRange(pParse, (int)(regCPeer), (int)(nPeer));
			}

			windowAggFinal(p, (int)(1));
		}
		public static void windowIfNewPeer(Parse pParse, ExprList pOrderBy, int regNew, int regOld, int addr)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			if ((pOrderBy) != null)
			{
				int nVal = (int)(pOrderBy.nExpr);
				KeyInfo pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, (int)(0), (int)(0));
				sqlite3VdbeAddOp3(v, (int)(89), (int)(regOld), (int)(regNew), (int)(nVal));
				sqlite3VdbeAppendP4(v, (void*)(pKeyInfo), (int)(-9));
				sqlite3VdbeAddOp3(v, (int)(16), (int)(sqlite3VdbeCurrentAddr(v) + 1), (int)(addr), (int)(sqlite3VdbeCurrentAddr(v) + 1));
				sqlite3VdbeAddOp3(v, (int)(79), (int)(regNew), (int)(regOld), (int)(nVal - 1));
			}
			else
			{
				sqlite3VdbeAddOp2(v, (int)(11), (int)(0), (int)(addr));
			}
		}
		public static int windowInitAccum(Parse pParse, Window pMWin)
		{
			Vdbe v = sqlite3GetVdbe(pParse);
			int regArg = 0;
			int nArg = (int)(0);
			Window pWin;
			for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
			{
				FuncDef pFunc = pWin.pFunc;

				sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regAccum));
				nArg = (int)((nArg) > (windowArgCount(pWin)) ? (nArg) : (windowArgCount(pWin)));
				if ((pMWin.regStartRowid) == (0))
				{
					if (((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName)))
					{
						sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
					}

					if (((pFunc.funcFlags & 0x1000) != 0) && ((pWin.csrApp) != 0))
					{

						sqlite3VdbeAddOp1(v, (int)(145), (int)(pWin.csrApp));
						sqlite3VdbeAddOp2(v, (int)(71), (int)(0), (int)(pWin.regApp + 1));
					}
				}
			}

			regArg = (int)(pParse.nMem + 1);
			pParse.nMem += (int)(nArg);
			return (int)(regArg);
		}
		public static void windowReadPeerValues(WindowCodeArg p, int csr, int reg)
		{
			Window pMWin = p.pMWin;
			ExprList pOrderBy = pMWin.pOrderBy;
			if ((pOrderBy) != null)
			{
				Vdbe v = sqlite3GetVdbe(p.pParse);
				ExprList pPart = pMWin.pPartition;
				int iColOff = (int)(pMWin.nBufferCol + (pPart ? pPart.nExpr : 0));
				int i = 0;
				for (i = (int)(0); (i) < (pOrderBy.nExpr); i++)
				{
					sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(iColOff + i), (int)(reg + i));
				}
			}
		}
		public static void windowRemoveExprFromSelect(Select pSelect, Expr pExpr)
		{
			if ((pSelect.pWin) != null)
			{
				Walker sWalker = new Walker();
				CRuntime.memset(sWalker, (int)(0), (ulong)(sizeof(Walker)));
				sWalker.xExprCallback = resolveRemoveWindowsCb;
				sWalker.u.pSelect = pSelect;
				sqlite3WalkExpr(sWalker, pExpr);
			}
		}
		public static void windowReturnOneRow(WindowCodeArg p)
		{
			Window pMWin = p.pMWin;
			Vdbe v = p.pVdbe;
			if ((pMWin.regStartRowid) != 0)
			{
				windowFullScan(p);
			}
			else
			{
				Parse pParse = p.pParse;
				Window pWin;
				for (pWin = pMWin; pWin; pWin = pWin.pNextWin)
				{
					FuncDef pFunc = pWin.pFunc;

					if (((pFunc.zName) == (nth_valueName)) || ((pFunc.zName) == (first_valueName)))
					{
						int csr = (int)(pWin.csrApp);
						int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
						int tmpReg = (int)(sqlite3GetTempReg(pParse));
						sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regResult));
						if ((pFunc.zName) == (nth_valueName))
						{
							sqlite3VdbeAddOp3(v, (int)(93), (int)(pMWin.iEphCsr), (int)(pWin.iArgCol + 1), (int)(tmpReg));
							windowCheckValue(pParse, (int)(tmpReg), (int)(2));
						}
						else
						{
							sqlite3VdbeAddOp2(v, (int)(71), (int)(1), (int)(tmpReg));
						}

						sqlite3VdbeAddOp3(v, (int)(106), (int)(tmpReg), (int)(pWin.regApp), (int)(tmpReg));
						sqlite3VdbeAddOp3(v, (int)(54), (int)(pWin.regApp + 1), (int)(lbl), (int)(tmpReg));
						sqlite3VdbeAddOp3(v, (int)(32), (int)(csr), (int)(0), (int)(tmpReg));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol), (int)(pWin.regResult));
						sqlite3VdbeResolveLabel(v, (int)(lbl));
						sqlite3ReleaseTempReg(pParse, (int)(tmpReg));
					}
					else if (((pFunc.zName) == (leadName)) || ((pFunc.zName) == (lagName)))
					{
						int nArg = (int)(pWin.pOwner.x.pList.nExpr);
						int csr = (int)(pWin.csrApp);
						int lbl = (int)(sqlite3VdbeMakeLabel(pParse));
						int tmpReg = (int)(sqlite3GetTempReg(pParse));
						int iEph = (int)(pMWin.iEphCsr);
						if ((nArg) < (3))
						{
							sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(pWin.regResult));
						}
						else
						{
							sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(pWin.iArgCol + 2), (int)(pWin.regResult));
						}

						sqlite3VdbeAddOp2(v, (int)(134), (int)(iEph), (int)(tmpReg));
						if ((nArg) < (2))
						{
							int val = (int)((pFunc.zName) == (leadName) ? 1 : -1);
							sqlite3VdbeAddOp2(v, (int)(85), (int)(tmpReg), (int)(val));
						}
						else
						{
							int op = (int)((pFunc.zName) == (leadName) ? 106 : 107);
							int tmpReg2 = (int)(sqlite3GetTempReg(pParse));
							sqlite3VdbeAddOp3(v, (int)(93), (int)(iEph), (int)(pWin.iArgCol + 1), (int)(tmpReg2));
							sqlite3VdbeAddOp3(v, (int)(op), (int)(tmpReg2), (int)(tmpReg), (int)(tmpReg));
							sqlite3ReleaseTempReg(pParse, (int)(tmpReg2));
						}

						sqlite3VdbeAddOp3(v, (int)(32), (int)(csr), (int)(lbl), (int)(tmpReg));
						sqlite3VdbeAddOp3(v, (int)(93), (int)(csr), (int)(pWin.iArgCol), (int)(pWin.regResult));
						sqlite3VdbeResolveLabel(v, (int)(lbl));
						sqlite3ReleaseTempReg(pParse, (int)(tmpReg));
					}
				}
			}

			sqlite3VdbeAddOp2(v, (int)(12), (int)(p.regGosub), (int)(p.addrGosub));
		}
		public static int winFetch(sqlite3_file fd, long iOff, int nAmt, void** pp)
		{
			winFile pFd = (winFile)(fd);
			*pp = null;
			if ((pFd.mmapSizeMax) > (0))
			{
				if ((pFd.pMapRegion) == (null))
				{
					int rc = (int)(winMapfile(pFd, (long)(-1)));
					if (rc != 0)
					{
						return (int)(rc);
					}
				}

				if ((pFd.mmapSize) >= (iOff + nAmt))
				{

					*pp = &((byte*)(pFd.pMapRegion))[iOff];
					pFd.nFetchOut++;
				}
			}

			return (int)(0);
		}
		public static int winFileControl(sqlite3_file id, int op, void* pArg)
		{
			winFile pFile = (winFile)(id);
			switch (op)
			{
				case 1:
					{
						*(int*)(pArg) = (int)(pFile.locktype);
						return (int)(0);
					}

				case 4:
					{
						*(int*)(pArg) = ((int)(pFile.lastErrno));
						return (int)(0);
					}

				case 6:
					{
						pFile.szChunk = (int)(*(int*)(pArg));
						return (int)(0);
					}

				case 5:
					{
						if ((pFile.szChunk) > (0))
						{
							long oldSz = 0;
							int rc = (int)(winFileSize(id, &oldSz));
							if ((rc) == (0))
							{
								long newSz = (long)(*(long*)(pArg));
								if ((newSz) > (oldSz))
								{
									rc = (int)(winTruncate(id, (long)(newSz)));
								}
							}

							return (int)(rc);
						}

						return (int)(0);
					}

				case 10:
					{
						winModeBit(pFile, (byte)(0x04), (int*)(pArg));
						return (int)(0);
					}

				case 13:
					{
						winModeBit(pFile, (byte)(0x10), (int*)(pArg));
						return (int)(0);
					}

				case 12:
					{
						*(sbyte**)(pArg) = sqlite3_mprintf("%s", pFile.pVfs.zName);
						return (int)(0);
					}

				case 9:
					{
						int* a = (int*)(pArg);
						if ((a[0]) > (0))
						{
							winIoerrRetry = (int)(a[0]);
						}
						else
						{
							a[0] = (int)(winIoerrRetry);
						}

						if ((a[1]) > (0))
						{
							winIoerrRetryDelay = (int)(a[1]);
						}
						else
						{
							a[1] = (int)(winIoerrRetryDelay);
						}

						return (int)(0);
					}

				case 29:
					{
						void** phFile = (void**)(pArg);
						*phFile = pFile.h;
						return (int)(0);
					}

				case 16:
					{
						sbyte* zTFile = null;
						int rc = (int)(winGetTempname(pFile.pVfs, &zTFile));
						if ((rc) == (0))
						{
							*(sbyte**)(pArg) = zTFile;
						}

						return (int)(rc);
					}

				case 18:
					{
						long newLimit = (long)(*(long*)(pArg));
						int rc = (int)(0);
						if ((newLimit) > (sqlite3Config.mxMmap))
						{
							newLimit = (long)(sqlite3Config.mxMmap);
						}

						if (((newLimit) > (0)) && ((sizeof(ulong)) < (8)))
						{
							newLimit = (long)(newLimit & 0x7FFFFFFF);
						}

						*(long*)(pArg) = (long)(pFile.mmapSizeMax);
						if ((((newLimit) >= (0)) && (newLimit != pFile.mmapSizeMax)) && ((pFile.nFetchOut) == (0)))
						{
							pFile.mmapSizeMax = (long)(newLimit);
							if ((pFile.mmapSize) > (0))
							{
								winUnmapfile(pFile);
								rc = (int)(winMapfile(pFile, (long)(-1)));
							}
						}

						return (int)(rc);
					}
			}

			return (int)(12);
		}
		public static int winFileSize(sqlite3_file id, long* pSize)
		{
			winFile pFile = (winFile)(id);
			int rc = (int)(0);


			{
				uint upperBits = 0;
				uint lowerBits = 0;
				uint lastErrno = 0;
				lowerBits = (uint)((Uint(Void * , Void * ))(aSyscall[23].pCurrent)(pFile.h, &upperBits));
				*pSize = (long)((((long)(upperBits)) << 32) + lowerBits);
				if (((lowerBits) == (0xFFFFFFFF)) && ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 0L))
				{
					pFile.lastErrno = (uint)(lastErrno);
					rc = (int)(winLogErrorAtLine((int)(10 | (7 << 8)), (uint)(pFile.lastErrno), "winFileSize", pFile.zPath, (int)(46028)));
				}
			}

			return (int)(rc);
		}
		public static int winFullPathname(sqlite3_vfs pVfs, sbyte* zRelative, int nFull, sbyte* zFull)
		{
			uint nByte = 0;
			void* zConverted;
			sbyte* zOut;
			if (((zRelative[0]) == (47)) && (((winIsDriveLetterAndColon(zRelative + 1)) != 0) || ((winIsLongPathPrefix(zRelative + 1)) != 0)))
			{
				zRelative++;
			}

			if (((sqlite3_data_directory) != null) && (winIsVerbatimPathname(zRelative) == 0))
			{
				sqlite3_snprintf((int)((nFull) < (pVfs.mxPathname) ? (nFull) : (pVfs.mxPathname)), zFull, "%s%c%s", sqlite3_data_directory, (int)(92), zRelative);
				return (int)(0);
			}

			zConverted = winConvertFromUtf8Filename(zRelative);
			if ((zConverted) == (null))
			{
				return (int)(10 | (12 << 8));
			}

			if ((1) != 0)
			{
				ushort* zTemp;
				nByte = (uint)((Uint(UShort * , UShort * , UShort * , UShort * ))(aSyscall[25].pCurrent)((ushort*)(zConverted), (uint)(0), null, null));
				if ((nByte) == (0))
				{
					sqlite3_free(zConverted);
					return (int)(winLogErrorAtLine((int)(14 | (3 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname1", zRelative, (int)(48601)));
				}

				nByte += (uint)(3);
				zTemp = sqlite3MallocZero((ulong)(nByte * sizeof(ushort)));
				if ((zTemp) == (null))
				{
					sqlite3_free(zConverted);
					return (int)(10 | (12 << 8));
				}

				nByte = (uint)((Uint(UShort * , UShort * , UShort * , UShort * ))(aSyscall[25].pCurrent)((ushort*)(zConverted), (uint)(nByte), zTemp, null));
				if ((nByte) == (0))
				{
					sqlite3_free(zConverted);
					sqlite3_free(zTemp);
					return (int)(winLogErrorAtLine((int)(14 | (3 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname2", zRelative, (int)(48614)));
				}

				sqlite3_free(zConverted);
				zOut = winUnicodeToUtf8(zTemp);
				sqlite3_free(zTemp);
			}
			else
			{
				sbyte* zTemp;
				nByte = (uint)((Uint(Sbyte * , Sbyte * , Sbyte * , Sbyte * ))(aSyscall[24].pCurrent)((sbyte*)(zConverted), (uint)(0), null, null));
				if ((nByte) == (0))
				{
					sqlite3_free(zConverted);
					return (int)(winLogErrorAtLine((int)(14 | (3 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname3", zRelative, (int)(48627)));
				}

				nByte += (uint)(3);
				zTemp = sqlite3MallocZero((ulong)(nByte * sizeof(sbyte)));
				if ((zTemp) == (null))
				{
					sqlite3_free(zConverted);
					return (int)(10 | (12 << 8));
				}

				nByte = (uint)((Uint(Sbyte * , Sbyte * , Sbyte * , Sbyte * ))(aSyscall[24].pCurrent)((sbyte*)(zConverted), (uint)(nByte), zTemp, null));
				if ((nByte) == (0))
				{
					sqlite3_free(zConverted);
					sqlite3_free(zTemp);
					return (int)(winLogErrorAtLine((int)(14 | (3 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winFullPathname4", zRelative, (int)(48640)));
				}

				sqlite3_free(zConverted);
				zOut = winMbcsToUtf8(zTemp, (int)((Int())(aSyscall[0].pCurrent)()));
				sqlite3_free(zTemp);
			}

			if ((zOut) != null)
			{
				sqlite3_snprintf((int)((nFull) < (pVfs.mxPathname) ? (nFull) : (pVfs.mxPathname)), zFull, "%s", zOut);
				sqlite3_free(zOut);
				return (int)(0);
			}
			else
			{
				return (int)(10 | (12 << 8));
			}
		}
		public static int winGetLastError(sqlite3_vfs pVfs, int nBuf, sbyte* zBuf)
		{
			uint e = (uint)((Uint())(aSyscall[26].pCurrent)());
			(void)(pVfs);
			if ((nBuf) > (0))
				winGetLastErrorMsg((uint)(e), (int)(nBuf), zBuf);
			return (int)(e);
		}
		public static int winGetLastErrorMsg(uint lastErrno, int nBuf, sbyte* zBuf)
		{
			uint dwLen = (uint)(0);
			sbyte* zOut = null;
			if ((1) != 0)
			{
				ushort* zTempWide = null;
				dwLen = (uint)((Uint(Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[15].pCurrent)((uint)(0x00000100 | 0x00001000 | 0x00000200), null, (uint)(lastErrno), (uint)(0), (ushort*)(&zTempWide), (uint)(0), null));
				if ((dwLen) > (0))
				{
					sqlite3BeginBenignMalloc();
					zOut = winUnicodeToUtf8(zTempWide);
					sqlite3EndBenignMalloc();
					(Void * (Void*))(aSyscall[46].pCurrent)(zTempWide);
				}
			}
			else
			{
				sbyte* zTemp = null;
				dwLen = (uint)((Uint(Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[14].pCurrent)((uint)(0x00000100 | 0x00001000 | 0x00000200), null, (uint)(lastErrno), (uint)(0), (sbyte*)(&zTemp), (uint)(0), null));
				if ((dwLen) > (0))
				{
					sqlite3BeginBenignMalloc();
					zOut = winMbcsToUtf8(zTemp, (int)((Int())(aSyscall[0].pCurrent)()));
					sqlite3EndBenignMalloc();
					(Void * (Void*))(aSyscall[46].pCurrent)(zTemp);
				}
			}

			if ((0) == (dwLen))
			{
				sqlite3_snprintf((int)(nBuf), zBuf, "OsError 0x%lx (%lu)", (uint)(lastErrno), (uint)(lastErrno));
			}
			else
			{
				sqlite3_snprintf((int)(nBuf), zBuf, "%s", zOut);
				sqlite3_free(zOut);
			}

			return (int)(0);
		}
		public static int winGetReadLock(winFile pFile)
		{
			int res = 0;
			if ((1) != 0)
			{
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001), (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
			}
			else
			{
				int lk = 0;
				sqlite3_randomness((int)(sizeof(int)), &lk);
				pFile.sharedLockByte = ((short)((lk & 0x7fffffff) % (510 - 1)));
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)((sqlite3PendingByte + 2) + pFile.sharedLockByte), (uint)(0), (uint)(1), (uint)(0)));
			}

			if ((res) == (0))
			{
				pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
			}

			return (int)(res);
		}
		public static Void()winGetSystemCall(sqlite3_vfs pNotUsed, sbyte* zName)
		{
			uint i = 0;
			(void)(pNotUsed);
			for (i = (uint)(0); (i) < (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
			{
				if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
					return aSyscall[i].pCurrent;
			}

			return null;
		}
		public static int winGetTempname(sqlite3_vfs pVfs, sbyte** pzBuf)
		{
			ulong i = 0; ulong j = 0;
			int nPre = (int)(sqlite3Strlen30("etilqs_"));
			int nMax = 0; int nBuf = 0; int nDir = 0; int nLen = 0;
			sbyte* zBuf;
			nMax = (int)(pVfs.mxPathname);
			nBuf = (int)(nMax + 2);
			zBuf = sqlite3MallocZero((ulong)(nBuf));
			if (zBuf == null)
			{
				return (int)(10 | (12 << 8));
			}

			nDir = (int)(nMax - (nPre + 15));

			if ((sqlite3_temp_directory) != null)
			{
				int nDirLen = (int)(sqlite3Strlen30(sqlite3_temp_directory));
				if ((nDirLen) > (0))
				{
					if (!(((sqlite3_temp_directory[nDirLen - 1]) == (47)) || ((sqlite3_temp_directory[nDirLen - 1]) == (92))))
					{
						nDirLen++;
					}

					if ((nDirLen) > (nDir))
					{
						sqlite3_free(zBuf);
						return (int)(winLogErrorAtLine((int)(1), (uint)(0), "winGetTempname1", null, (int)(47684)));
					}

					sqlite3_snprintf((int)(nMax), zBuf, "%s", sqlite3_temp_directory);
				}
			}
			else if ((1) != 0)
			{
				sbyte* zMulti;
				ushort* zWidePath = sqlite3MallocZero((ulong)(nMax * sizeof(ushort)));
				if (zWidePath == null)
				{
					sqlite3_free(zBuf);
					return (int)(10 | (12 << 8));
				}

				if (((Uint(Uint, Uint))(aSyscall[32].pCurrent)((uint)(nMax), zWidePath)) == (0))
				{
					sqlite3_free(zWidePath);
					sqlite3_free(zBuf);
					return (int)(winLogErrorAtLine((int)(10 | (25 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winGetTempname2", null, (int)(47783)));
				}

				zMulti = winUnicodeToUtf8(zWidePath);
				if ((zMulti) != null)
				{
					sqlite3_snprintf((int)(nMax), zBuf, "%s", zMulti);
					sqlite3_free(zMulti);
					sqlite3_free(zWidePath);
				}
				else
				{
					sqlite3_free(zWidePath);
					sqlite3_free(zBuf);
					return (int)(10 | (12 << 8));
				}
			}
			else
			{
				sbyte* zUtf8;
				sbyte* zMbcsPath = sqlite3MallocZero((ulong)(nMax));
				if (zMbcsPath == null)
				{
					sqlite3_free(zBuf);
					return (int)(10 | (12 << 8));
				}

				if (((Uint(Uint, Uint))(aSyscall[31].pCurrent)((uint)(nMax), zMbcsPath)) == (0))
				{
					sqlite3_free(zBuf);
					return (int)(winLogErrorAtLine((int)(10 | (25 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winGetTempname3", null, (int)(47810)));
				}

				zUtf8 = winMbcsToUtf8(zMbcsPath, (int)((Int())(aSyscall[0].pCurrent)()));
				if ((zUtf8) != null)
				{
					sqlite3_snprintf((int)(nMax), zBuf, "%s", zUtf8);
					sqlite3_free(zUtf8);
				}
				else
				{
					sqlite3_free(zBuf);
					return (int)(10 | (12 << 8));
				}
			}

			if (winMakeEndInDirSep((int)(nDir + 1), zBuf) == 0)
			{
				sqlite3_free(zBuf);
				return (int)(winLogErrorAtLine((int)(1), (uint)(0), "winGetTempname4", null, (int)(47833)));
			}

			nLen = (int)(sqlite3Strlen30(zBuf));
			if ((nLen + nPre + 17) > (nBuf))
			{
				sqlite3_free(zBuf);
				return (int)(winLogErrorAtLine((int)(1), (uint)(0), "winGetTempname5", null, (int)(47851)));
			}

			sqlite3_snprintf((int)(nBuf - 16 - nLen), zBuf + nLen, "etilqs_");
			j = (ulong)(sqlite3Strlen30(zBuf));
			sqlite3_randomness((int)(15), &zBuf[j]);
			for (i = (ulong)(0); (i) < (15); i++, j++)
			{
				zBuf[j] = (sbyte)(winGetTempname_zChars[((byte)(zBuf[j])) % (63 * sizeof(sbyte) - 1)]);
			}

			zBuf[j] = (sbyte)(0);
			zBuf[j + 1] = (sbyte)(0);
			*pzBuf = zBuf;
			return (int)(0);
		}
		public static int winIsDir(void* zConverted)
		{
			return (int)(0);
		}
		public static int winLock(sqlite3_file id, int locktype)
		{
			int rc = (int)(0);
			int res = (int)(1);
			int newLocktype = 0;
			int gotPendingLock = (int)(0);
			winFile pFile = (winFile)(id);
			uint lastErrno = (uint)(0L);

			if ((pFile.locktype) >= (locktype))
			{
				return (int)(0);
			}

			if (((pFile.ctrlFlags & 0x02) != 0) && ((locktype) >= (2)))
			{
				return (int)(10 | (15 << 8));
			}




			newLocktype = (int)(pFile.locktype);
			if (((pFile.locktype) == (0)) || (((locktype) == (4)) && ((pFile.locktype) <= (2))))
			{
				int cnt = (int)(3);
				while (((cnt--) > (0)) && ((res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0)))) == (0)))
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					if ((lastErrno) == (6L))
					{
						pFile.lastErrno = (uint)(lastErrno);
						rc = (int)(10 | (15 << 8));
						return (int)(rc);
					}

					if ((cnt) != 0)
						sqlite3_win32_sleep((uint)(1));
				}

				gotPendingLock = (int)(res);
				if (res == 0)
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				}
			}

			if (((locktype) == (1)) && ((res) != 0))
			{

				res = (int)(winGetReadLock(pFile));
				if ((res) != 0)
				{
					newLocktype = (int)(1);
				}
				else
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				}
			}

			if (((locktype) == (2)) && ((res) != 0))
			{

				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0)));
				if ((res) != 0)
				{
					newLocktype = (int)(2);
				}
				else
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				}
			}

			if (((locktype) == (4)) && ((res) != 0))
			{
				newLocktype = (int)(3);
				gotPendingLock = (int)(0);
			}

			if (((locktype) == (4)) && ((res) != 0))
			{

				res = (int)(winUnlockReadLock(pFile));
				res = (int)(winLockFile(&pFile.h, (uint)(0x00000001 | 0x00000002), (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
				if ((res) != 0)
				{
					newLocktype = (int)(4);
				}
				else
				{
					lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					winGetReadLock(pFile);
				}
			}

			if (((gotPendingLock) != 0) && ((locktype) == (1)))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0));
			}

			if ((res) != 0)
			{
				rc = (int)(0);
			}
			else
			{
				pFile.lastErrno = (uint)(lastErrno);
				rc = (int)(5);
			}

			pFile.locktype = ((byte)(newLocktype));
			return (int)(rc);
		}
		public static int winLockFile(void** phFile, uint flags, uint offsetLow, uint offsetHigh, uint numBytesLow, uint numBytesHigh)
		{
			if ((1) != 0)
			{
				_OVERLAPPED ovlp = new _OVERLAPPED();
				CRuntime.memset(&ovlp, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
				ovlp..Offset = (uint)(offsetLow);
				ovlp..OffsetHigh = (uint)(offsetHigh);
				return (int)((Int(Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[48].pCurrent)(*phFile, (uint)(flags), (uint)(0), (uint)(numBytesLow), (uint)(numBytesHigh), &ovlp));
			}
			else
			{
				return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[47].pCurrent)(*phFile, (uint)(offsetLow), (uint)(offsetHigh), (uint)(numBytesLow), (uint)(numBytesHigh)));
			}
		}
		public static int winLockSharedMemory(winShmNode pShmNode)
		{
			int rc = (int)(winShmSystemLock(pShmNode, (int)(3), (int)(((22 + 8) * 4) + 8), (int)(1)));
			if ((rc) == (0))
			{
				if ((pShmNode.isReadonly) != 0)
				{
					pShmNode.isUnlocked = (byte)(1);
					winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
					return (int)(8 | (5 << 8));
				}
				else if ((winTruncate((sqlite3_file)(pShmNode.hFile), (long)(0))) != 0)
				{
					winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
					return (int)(winLogErrorAtLine((int)(10 | (18 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winLockSharedMemory", pShmNode.zFilename, (int)(46815)));
				}
			}

			if ((rc) == (0))
			{
				winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
			}

			return (int)(winShmSystemLock(pShmNode, (int)(2), (int)(((22 + 8) * 4) + 8), (int)(1)));
		}
		public static int winLogErrorAtLine(int errcode, uint lastErrno, sbyte* zFunc, sbyte* zPath, int iLine)
		{
			sbyte* zMsg = stackalloc sbyte[500];
			int i = 0;
			zMsg[0] = (sbyte)(0);
			winGetLastErrorMsg((uint)(lastErrno), (int)(500 * sizeof(sbyte)), zMsg);

			if ((zPath) == (null))
				zPath = "";
			for (i = (int)(0); (((zMsg[i]) != 0) && (zMsg[i] != 13)) && (zMsg[i] != 10); i++)
			{
			}

			zMsg[i] = (sbyte)(0);
			sqlite3_log((int)(errcode), "os_win.c:%d: (%lu) %s(%s) - %s", (int)(iLine), (uint)(lastErrno), zFunc, zPath, zMsg);
			return (int)(errcode);
		}
		public static void winLogIoerr(int nRetry, int lineno)
		{
			if ((nRetry) != 0)
			{
				sqlite3_log((int)(27), "delayed %dms for lock/sharing conflict at line %d", (int)(winIoerrRetryDelay * nRetry * (nRetry + 1) / 2), (int)(lineno));
			}
		}
		public static int winMakeEndInDirSep(int nBuf, sbyte* zBuf)
		{
			if ((zBuf) != null)
			{
				int nLen = (int)(sqlite3Strlen30(zBuf));
				if ((nLen) > (0))
				{
					if ((((zBuf[nLen - 1]) == (47)) || ((zBuf[nLen - 1]) == (92))))
					{
						return (int)(1);
					}
					else if ((nLen + 1) < (nBuf))
					{
						zBuf[nLen] = (sbyte)(92);
						zBuf[nLen + 1] = (sbyte)(0);
						return (int)(1);
					}
				}
			}

			return (int)(0);
		}
		public static int winMapfile(winFile pFd, long nByte)
		{
			long nMap = (long)(nByte);
			int rc = 0;

			if ((pFd.nFetchOut) > (0))
				return (int)(0);
			if ((nMap) < (0))
			{
				rc = (int)(winFileSize((sqlite3_file)(pFd), &nMap));
				if ((rc) != 0)
				{
					return (int)(10 | (7 << 8));
				}
			}

			if ((nMap) > (pFd.mmapSizeMax))
			{
				nMap = (long)(pFd.mmapSizeMax);
			}

			nMap &= (long)(~(long)(winSysInfo.dwPageSize - 1));
			if (((nMap) == (0)) && ((pFd.mmapSize) > (0)))
			{
				winUnmapfile(pFd);
			}

			if (nMap != pFd.mmapSize)
			{
				void* pNew = null;
				uint protect = (uint)(0x02);
				uint flags = (uint)(0x0004);
				winUnmapfile(pFd);
				pFd.hMap = (Void * (Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[7].pCurrent)(pFd.h, null, (uint)(protect), (uint)((nMap >> 32) & 0xffffffff), (uint)(nMap & 0xffffffff), null);
				if ((pFd.hMap) == null)
				{
					pFd.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					rc = (int)(winLogErrorAtLine((int)(10 | (24 << 8)), (uint)(pFd.lastErrno), "winMapfile1", pFd.zPath, (int)(47379)));
					return (int)(0);
				}



				pNew = (Void * (Void * , Void * , Void * , Void * , Void * ))(aSyscall[49].pCurrent)(pFd.hMap, (uint)(flags), (uint)(0), (uint)(0), (ulong)(nMap));
				if ((pNew) == null)
				{
					(Int(Void * ))(aSyscall[3].pCurrent)(pFd.hMap);
					pFd.hMap = null;
					pFd.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					rc = (int)(winLogErrorAtLine((int)(10 | (24 << 8)), (uint)(pFd.lastErrno), "winMapfile2", pFd.zPath, (int)(47397)));
					return (int)(0);
				}

				pFd.pMapRegion = pNew;
				pFd.mmapSize = (long)(nMap);
			}

			return (int)(0);
		}
		public static ushort* winMbcsToUnicode(sbyte* zText, int useAnsi)
		{
			int nByte = 0;
			ushort* zMbcsText;
			int codepage = (int)((useAnsi) != 0 ? 0 : 1);
			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(codepage), (uint)(0), zText, (int)(-1), null, (int)(0)) * sizeof(ushort));
			if ((nByte) == (0))
			{
				return null;
			}

			zMbcsText = sqlite3MallocZero((ulong)(nByte * sizeof(ushort)));
			if ((zMbcsText) == (null))
			{
				return null;
			}

			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(codepage), (uint)(0), zText, (int)(-1), zMbcsText, (int)(nByte)));
			if ((nByte) == (0))
			{
				sqlite3_free(zMbcsText);
				zMbcsText = null;
			}

			return zMbcsText;
		}
		public static sbyte* winMbcsToUtf8(sbyte* zText, int useAnsi)
		{
			sbyte* zTextUtf8;
			ushort* zTmpWide;
			zTmpWide = winMbcsToUnicode(zText, (int)(useAnsi));
			if ((zTmpWide) == (null))
			{
				return null;
			}

			zTextUtf8 = winUnicodeToUtf8(zTmpWide);
			sqlite3_free(zTmpWide);
			return zTextUtf8;
		}
		public static void winModeBit(winFile pFile, byte mask, int* pArg)
		{
			if ((*pArg) < (0))
			{
				*pArg = (int)((pFile.ctrlFlags & mask) != 0);
			}
			else if ((*pArg) == (0))
			{
				pFile.ctrlFlags &= (byte)(~mask);
			}
			else
			{
				pFile.ctrlFlags |= (byte)(mask);
			}
		}
		public static sqlite3_mutex* winMutexAlloc(int iType)
		{
			sqlite3_mutex* p;
			switch (iType)
			{
				case 0:
				case 1:
					{
						p = sqlite3MallocZero((ulong)(sizeof(sqlite3_mutex)));
						if ((p) != null)
						{
							p->id = (int)(iType);
							InitializeCriticalSection(&p->mutex);
						}

						break;
					}

				default:
					{
						p = &winMutex_staticMutexes[iType - 2];
						break;
					}
			}


			return p;
		}
		public static int winMutexEnd()
		{
			if ((_InterlockedCompareExchange(&winMutex_lock, (int)(0), (int)(1))) == (1))
			{
				if ((winMutex_isInit) == (1))
				{
					int i = 0;
					for (i = (int)(0); (i) < ((int)(12 * sizeof(sqlite3_mutex) / sizeof(sqlite3_mutex))); i++)
					{
						DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);
					}

					winMutex_isInit = (int)(0);
				}
			}

			return (int)(0);
		}
		public static void winMutexEnter(sqlite3_mutex* p)
		{


			EnterCriticalSection(&p->mutex);
		}
		public static void winMutexFree(sqlite3_mutex* p)
		{


			if (((p->id) == (0)) || ((p->id) == (1)))
			{
				DeleteCriticalSection(&p->mutex);
				sqlite3_free(p);
			}
			else
			{
			}
		}
		public static int winMutexInit()
		{
			if ((_InterlockedCompareExchange(&winMutex_lock, (int)(1), (int)(0))) == (0))
			{
				int i = 0;
				for (i = (int)(0); (i) < ((int)(12 * sizeof(sqlite3_mutex) / sizeof(sqlite3_mutex))); i++)
				{
					InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);
				}

				winMutex_isInit = (int)(1);
			}
			else
			{
				while (winMutex_isInit == 0)
				{
					sqlite3_win32_sleep((uint)(1));
				}
			}

			return (int)(0);
		}
		public static void winMutexLeave(sqlite3_mutex* p)
		{


			LeaveCriticalSection(&p->mutex);
		}
		public static int winMutexTry(sqlite3_mutex* p)
		{
			int rc = (int)(5);




			if ((winMutex_isNt) < (0))
			{
				winMutex_isNt = (int)(sqlite3_win32_is_nt());
			}


			if (((winMutex_isNt) != 0) && ((TryEnterCriticalSection(&p->mutex)) != 0))
			{
				rc = (int)(0);
			}

			return (int)(rc);
		}
		public static sbyte* winNextSystemCall(sqlite3_vfs p, sbyte* zName)
		{
			int i = (int)(-1);
			(void)(p);
			if ((zName) != null)
			{
				for (i = (int)(0); (i) < (((int)(80 * sizeof(win_syscall) / sizeof(win_syscall))) - 1); i++)
				{
					if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
						break;
				}
			}

			for (i++; (i) < ((int)(80 * sizeof(win_syscall) / sizeof(win_syscall))); i++)
			{
				if (aSyscall[i].pCurrent != null)
					return aSyscall[i].zName;
			}

			return null;
		}
		public static int winNolockCheckReservedLock(sqlite3_file id, int* pResOut)
		{
			(void)(id);
			(void)(pResOut);
			return (int)(0);
		}
		public static int winNolockLock(sqlite3_file id, int locktype)
		{
			(void)(id);
			(void)(locktype);
			return (int)(0);
		}
		public static int winNolockUnlock(sqlite3_file id, int locktype)
		{
			(void)(id);
			(void)(locktype);
			return (int)(0);
		}
		public static int winOpen(sqlite3_vfs pVfs, sbyte* zName, sqlite3_file id, int flags, int* pOutFlags)
		{
			void* h;
			uint lastErrno = (uint)(0);
			uint dwDesiredAccess = 0;
			uint dwShareMode = 0;
			uint dwCreationDisposition = 0;
			uint dwFlagsAndAttributes = (uint)(0);
			winVfsAppData pAppData;
			winFile pFile = (winFile)(id);
			void* zConverted;
			sbyte* zUtf8Name = zName;
			int cnt = (int)(0);
			sbyte* zTmpname = null;
			int rc = (int)(0);
			int isExclusive = (int)(flags & 0x00000010);
			int isDelete = (int)(flags & 0x00000008);
			int isCreate = (int)(flags & 0x00000004);
			int isReadonly = (int)(flags & 0x00000001);
			int isReadWrite = (int)(flags & 0x00000002);










			CRuntime.memset(pFile, (int)(0), (ulong)(sizeof(winFile)));
			pFile.h = ((void*)((long)(-1)));
			if (zUtf8Name == null)
			{

				rc = (int)(winGetTempname(pVfs, &zTmpname));
				if (rc != 0)
				{
					return (int)(rc);
				}

				zUtf8Name = zTmpname;
			}


			zConverted = winConvertFromUtf8Filename(zUtf8Name);
			if ((zConverted) == (null))
			{
				sqlite3_free(zTmpname);
				return (int)(10 | (12 << 8));
			}

			if ((winIsDir(zConverted)) != 0)
			{
				sqlite3_free(zConverted);
				sqlite3_free(zTmpname);
				return (int)(14 | (2 << 8));
			}

			if ((isReadWrite) != 0)
			{
				dwDesiredAccess = (uint)((0x80000000L) | (0x40000000L));
			}
			else
			{
				dwDesiredAccess = (uint)(0x80000000L);
			}

			if ((isExclusive) != 0)
			{
				dwCreationDisposition = (uint)(1);
			}
			else if ((isCreate) != 0)
			{
				dwCreationDisposition = (uint)(4);
			}
			else
			{
				dwCreationDisposition = (uint)(3);
			}

			if ((0) == (sqlite3_uri_boolean(zName, "exclusive", (int)(0))))
			{
				dwShareMode = (uint)(0x00000001 | 0x00000002);
			}
			else
			{
				dwShareMode = (uint)(0);
			}

			if ((isDelete) != 0)
			{
				dwFlagsAndAttributes = (uint)(0x00000100 | 0x00000002 | 0x04000000);
			}
			else
			{
				dwFlagsAndAttributes = (uint)(0x00000080);
			}

			if ((1) != 0)
			{
				do
				{
					h = (Void * (UShort * , UShort * , UShort * , UShort * , UShort * , UShort * , UShort * ))(aSyscall[5].pCurrent)((ushort*)(zConverted), (uint)(dwDesiredAccess), (uint)(dwShareMode), null, (uint)(dwCreationDisposition), (uint)(dwFlagsAndAttributes), null);
					if (h != ((void*)((long)(-1))))
						break;
					if ((isReadWrite) != 0)
					{
						int rc2 = 0;
						int isRO = (int)(0);
						sqlite3BeginBenignMalloc();
						rc2 = (int)(winAccess(pVfs, zName, (int)(2), &isRO));
						sqlite3EndBenignMalloc();
						if (((rc2) == (0)) && ((isRO) != 0))
							break;
					}
				}
				while ((winRetryIoerr(&cnt, &lastErrno)) != 0);
			}
			else
			{
				do
				{
					h = (Void * (Sbyte * , Sbyte * , Sbyte * , Sbyte * , Sbyte * , Sbyte * , Sbyte * ))(aSyscall[4].pCurrent)((sbyte*)(zConverted), (uint)(dwDesiredAccess), (uint)(dwShareMode), null, (uint)(dwCreationDisposition), (uint)(dwFlagsAndAttributes), null);
					if (h != ((void*)((long)(-1))))
						break;
					if ((isReadWrite) != 0)
					{
						int rc2 = 0;
						int isRO = (int)(0);
						sqlite3BeginBenignMalloc();
						rc2 = (int)(winAccess(pVfs, zName, (int)(2), &isRO));
						sqlite3EndBenignMalloc();
						if (((rc2) == (0)) && ((isRO) != 0))
							break;
					}
				}
				while ((winRetryIoerr(&cnt, &lastErrno)) != 0);
			}

			winLogIoerr((int)(cnt), (int)(48140));
			if ((h) == ((void*)((long)(-1))))
			{
				sqlite3_free(zConverted);
				sqlite3_free(zTmpname);
				if (((isReadWrite) != 0) && (isExclusive == 0))
				{
					return (int)(winOpen(pVfs, zName, id, (int)((flags | 0x00000001) & ~(0x00000004 | 0x00000002)), pOutFlags));
				}
				else
				{
					pFile.lastErrno = (uint)(lastErrno);
					winLogErrorAtLine((int)(14), (uint)(pFile.lastErrno), "winOpen", zUtf8Name, (int)(48155));
					return (int)(sqlite3CantopenError((int)(48156)));
				}
			}

			if ((pOutFlags) != null)
			{
				if ((isReadWrite) != 0)
				{
					*pOutFlags = (int)(0x00000002);
				}
				else
				{
					*pOutFlags = (int)(0x00000001);
				}
			}

			pAppData = (winVfsAppData)(pVfs.pAppData);
			{
				sqlite3_free(zConverted);
			}

			sqlite3_free(zTmpname);
			id.pMethods = pAppData ? pAppData.pMethod : winIoMethod;
			pFile.pVfs = pVfs;
			pFile.h = h;
			if ((isReadonly) != 0)
			{
				pFile.ctrlFlags |= (byte)(0x02);
			}

			if (((flags & 0x00000100) != 0) && ((sqlite3_uri_boolean(zName, "psow", (int)(1))) != 0))
			{
				pFile.ctrlFlags |= (byte)(0x10);
			}

			pFile.lastErrno = (uint)(0L);
			pFile.zPath = zName;
			pFile.hMap = null;
			pFile.pMapRegion = null;
			pFile.mmapSize = (long)(0);
			pFile.mmapSizeMax = (long)(sqlite3Config.szMmap);
			return (int)(rc);
		}
		public static int winOpenSharedMemory(winFile pDbFd)
		{
			winShm p;
			winShmNode pShmNode = null;
			int rc = (int)(0);
			winShmNode pNew;
			int nName = 0;

			p = sqlite3MallocZero((ulong)(sizeof(winShm)));
			if ((p) == (null))
				return (int)(10 | (12 << 8));
			nName = (int)(sqlite3Strlen30(pDbFd.zPath));
			pNew = sqlite3MallocZero((ulong)(sizeof(winShmNode) + nName + 17));
			if ((pNew) == (null))
			{
				sqlite3_free(p);
				return (int)(10 | (12 << 8));
			}

			pNew.zFilename = (sbyte*)(pNew[1]);
			sqlite3_snprintf((int)(nName + 15), pNew.zFilename, "%s-shm", pDbFd.zPath);
			winShmEnterMutex();
			for (pShmNode = winShmNodeList; pShmNode; pShmNode = pShmNode.pNext)
			{
				if ((sqlite3StrICmp(pShmNode.zFilename, pNew.zFilename)) == (0))
					break;
			}

			if ((pShmNode) != null)
			{
				sqlite3_free(pNew);
			}
			else
			{
				int inFlags = (int)(0x00080000);
				int outFlags = (int)(0);
				pShmNode = pNew;
				pNew = null;
				(pShmNode.hFile).h = ((void*)((long)(-1)));
				pShmNode.pNext = winShmNodeList;
				winShmNodeList = pShmNode;
				if ((sqlite3Config.bCoreMutex) != 0)
				{
					pShmNode.mutex = sqlite3_mutex_alloc((int)(0));
					if ((pShmNode.mutex) == (null))
					{
						rc = (int)(10 | (12 << 8));
						goto shm_open_err;
					}
				}

				if ((0) == (sqlite3_uri_boolean(pDbFd.zPath, "readonly_shm", (int)(0))))
				{
					inFlags |= (int)(0x00000002 | 0x00000004);
				}
				else
				{
					inFlags |= (int)(0x00000001);
				}

				rc = (int)(winOpen(pDbFd.pVfs, pShmNode.zFilename, (sqlite3_file)(pShmNode.hFile), (int)(inFlags), &outFlags));
				if (rc != 0)
				{
					rc = (int)(winLogErrorAtLine((int)(rc), (uint)((Uint())(aSyscall[26].pCurrent)()), "winOpenShm", pShmNode.zFilename, (int)(46897)));
					goto shm_open_err;
				}

				if ((outFlags) == (0x00000001))
					pShmNode.isReadonly = (byte)(1);
				rc = (int)(winLockSharedMemory(pShmNode));
				if ((rc != 0) && (rc != (8 | (5 << 8))))
					goto shm_open_err;
			}

			p.pShmNode = pShmNode;
			pShmNode.nRef++;
			pDbFd.pShm = p;
			winShmLeaveMutex();
			sqlite3_mutex_enter(pShmNode.mutex);
			p.pNext = pShmNode.pFirst;
			pShmNode.pFirst = p;
			sqlite3_mutex_leave(pShmNode.mutex);
			return (int)(rc);
		shm_open_err:
			; winShmSystemLock(pShmNode, (int)(1), (int)(((22 + 8) * 4) + 8), (int)(1));
			winShmPurge(pDbFd.pVfs, (int)(0));
			sqlite3_free(p);
			sqlite3_free(pNew);
			winShmLeaveMutex();
			return (int)(rc);
		}
		public static int winRandomness(sqlite3_vfs pVfs, int nBuf, sbyte* zBuf)
		{
			EntropyGatherer e = new EntropyGatherer();
			(void)(pVfs);
			CRuntime.memset(zBuf, (int)(0), (ulong)(nBuf));
			e.a = (byte*)(zBuf);
			e.na = (int)(nBuf);
			e.nXor = (int)(0);
			e.i = (int)(0);
			{
				_SYSTEMTIME x = new _SYSTEMTIME();
				(Void(_SYSTEMTIME * ))(aSyscall[29].pCurrent)(&x);
				xorMemory(&e, (byte*)(&x), (int)(sizeof(_SYSTEMTIME)));
			}

			{
				uint pid = (uint)((Uint())(aSyscall[17].pCurrent)());
				xorMemory(&e, (byte*)(&pid), (int)(sizeof(uint)));
			}

			{
				uint cnt = (uint)((Uint())(aSyscall[33].pCurrent)());
				xorMemory(&e, (byte*)(&cnt), (int)(sizeof(uint)));
			}

			{
				union _LARGE_INTEGER i = new union _LARGE_INTEGER();
				(Int(union_LARGE_INTEGER * ))(aSyscall[51].pCurrent)(&i);
				xorMemory(&e, (byte*)(&i), (int)(sizeof(union _LARGE_INTEGER) ) )
        ;
			}

			return (int)((e.nXor) > (nBuf) ? nBuf : e.nXor);
		}
		public static int winRead(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			_OVERLAPPED overlapped = new _OVERLAPPED();
			winFile pFile = (winFile)(id);
			uint nRead = 0;
			int nRetry = (int)(0);



			if ((offset) < (pFile.mmapSize))
			{
				if ((offset + amt) <= (pFile.mmapSize))
				{
					CRuntime.memcpy(pBuf, &((byte*)(pFile.pMapRegion))[offset], (ulong)(amt));
					return (int)(0);
				}
				else
				{
					int nCopy = (int)(pFile.mmapSize - offset);
					CRuntime.memcpy(pBuf, &((byte*)(pFile.pMapRegion))[offset], (ulong)(nCopy));
					pBuf = &((byte*)(pBuf))[nCopy];
					amt -= (int)(nCopy);
					offset += (long)(nCopy);
				}
			}

			CRuntime.memset(&overlapped, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
			overlapped..Offset = (uint)((int)(offset & 0xffffffff));
			overlapped..OffsetHigh = (uint)((int)((offset >> 32) & 0x7fffffff));
			while (((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[52].pCurrent)(pFile.h, pBuf, (uint)(amt), &nRead, &overlapped) == 0) && ((Uint())(aSyscall[26].pCurrent)() != 38L))
			{
				uint lastErrno = 0;
				if ((winRetryIoerr(&nRetry, &lastErrno)) != 0)
					continue;
				pFile.lastErrno = (uint)(lastErrno);
				return (int)(winLogErrorAtLine((int)(10 | (1 << 8)), (uint)(pFile.lastErrno), "winRead", pFile.zPath, (int)(45692)));
			}

			winLogIoerr((int)(nRetry), (int)(45694));
			if ((nRead) < ((uint)(amt)))
			{
				CRuntime.memset(&((sbyte*)(pBuf))[nRead], (int)(0), (ulong)(amt - nRead));
				return (int)(10 | (2 << 8));
			}

			return (int)(0);
		}
		public static int winRetryIoerr(int* pnRetry, uint* pError)
		{
			uint e = (uint)((Uint())(aSyscall[26].pCurrent)());
			if ((*pnRetry) >= (winIoerrRetry))
			{
				if ((pError) != null)
				{
					*pError = (uint)(e);
				}

				return (int)(0);
			}

			if (((((((((e) == (5L)) || ((e) == (32L))) || ((e) == (33L))) || ((e) == (55L))) || ((e) == (64L))) || ((e) == (121L))) || ((e) == (1231L))))
			{
				sqlite3_win32_sleep((uint)(winIoerrRetryDelay * (1 + *pnRetry)));
				++*pnRetry;
				return (int)(1);
			}

			if ((pError) != null)
			{
				*pError = (uint)(e);
			}

			return (int)(0);
		}
		public static int winSectorSize(sqlite3_file id)
		{
			(void)(id);
			return (int)(4096);
		}
		public static int winSeekFile(winFile pFile, long iOffset)
		{
			int upperBits = 0;
			int lowerBits = 0;
			uint dwRet = 0;
			uint lastErrno = 0;
			upperBits = ((int)((iOffset >> 32) & 0x7fffffff));
			lowerBits = ((int)(iOffset & 0xffffffff));
			dwRet = (uint)((Uint(Void * , Void * , Void * , Void * ))(aSyscall[54].pCurrent)(pFile.h, (int)(lowerBits), &upperBits, (uint)(0)));
			if ((((dwRet) == ((uint)(-1))) && ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 0L)))
			{
				pFile.lastErrno = (uint)(lastErrno);
				winLogErrorAtLine((int)(10 | (22 << 8)), (uint)(pFile.lastErrno), "winSeekFile", pFile.zPath, (int)(45528));
				return (int)(1);
			}

			return (int)(0);
		}
		public static int winSetSystemCall(sqlite3_vfs pNotUsed, sbyte* zName, delegate73 pNewFunc)
		{
			uint i = 0;
			int rc = (int)(12);
			(void)(pNotUsed);
			if ((zName) == (null))
			{
				rc = (int)(0);
				for (i = (uint)(0); (i) < (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
				{
					if ((aSyscall[i].pDefault) != null)
					{
						aSyscall[i].pCurrent = aSyscall[i].pDefault;
					}
				}
			}
			else
			{
				for (i = (uint)(0); (i) < (80 * sizeof(win_syscall) / sizeof(win_syscall)); i++)
				{
					if ((CRuntime.strcmp(zName, aSyscall[i].zName)) == (0))
					{
						if ((aSyscall[i].pDefault) == (null))
						{
							aSyscall[i].pDefault = aSyscall[i].pCurrent;
						}

						rc = (int)(0);
						if ((pNewFunc) == (null))
							pNewFunc = aSyscall[i].pDefault;
						aSyscall[i].pCurrent = pNewFunc;
						break;
					}
				}
			}

			return (int)(rc);
		}
		public static void winShmBarrier(sqlite3_file fd)
		{
			(void)(fd);
			sqlite3MemoryBarrier();
			winShmEnterMutex();
			winShmLeaveMutex();
		}
		public static void winShmEnterMutex()
		{
			sqlite3_mutex_enter(winBigLock);
		}
		public static void winShmLeaveMutex()
		{
			sqlite3_mutex_leave(winBigLock);
		}
		public static int winShmLock(sqlite3_file fd, int ofst, int n, int flags)
		{
			winFile pDbFd = (winFile)(fd);
			winShm p = pDbFd.pShm;
			winShm pX;
			winShmNode pShmNode;
			int rc = (int)(0);
			ushort mask = 0;
			if ((p) == (null))
				return (int)(10 | (20 << 8));
			pShmNode = p.pShmNode;
			if (((pShmNode) == (null)))
				return (int)(10 | (20 << 8));




			mask = ((ushort)((1U << (ofst + n)) - (1U << ofst)));

			sqlite3_mutex_enter(pShmNode.mutex);
			if ((flags & 1) != 0)
			{
				ushort allMask = (ushort)(0);
				for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
				{
					if ((pX) == (p))
						continue;

					allMask |= (ushort)(pX.sharedMask);
				}

				if ((mask & allMask) == (0))
				{
					rc = (int)(winShmSystemLock(pShmNode, (int)(1), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
				}
				else
				{
					rc = (int)(0);
				}

				if ((rc) == (0))
				{
					p.exclMask &= (ushort)(~mask);
					p.sharedMask &= (ushort)(~mask);
				}
			}
			else if ((flags & 4) != 0)
			{
				ushort allShared = (ushort)(0);
				for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
				{
					if ((pX.exclMask & mask) != 0)
					{
						rc = (int)(5);
						break;
					}

					allShared |= (ushort)(pX.sharedMask);
				}

				if ((rc) == (0))
				{
					if ((allShared & mask) == (0))
					{
						rc = (int)(winShmSystemLock(pShmNode, (int)(2), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
					}
					else
					{
						rc = (int)(0);
					}
				}

				if ((rc) == (0))
				{
					p.sharedMask |= (ushort)(mask);
				}
			}
			else
			{
				for (pX = pShmNode.pFirst; pX; pX = pX.pNext)
				{
					if (((pX.exclMask & mask) != 0) || ((pX.sharedMask & mask) != 0))
					{
						rc = (int)(5);
						break;
					}
				}

				if ((rc) == (0))
				{
					rc = (int)(winShmSystemLock(pShmNode, (int)(3), (int)(ofst + ((22 + 8) * 4)), (int)(n)));
					if ((rc) == (0))
					{

						p.exclMask |= (ushort)(mask);
					}
				}
			}

			sqlite3_mutex_leave(pShmNode.mutex);
			return (int)(rc);
		}
		public static int winShmMap(sqlite3_file fd, int iRegion, int szRegion, int isWrite, void** pp)
		{
			winFile pDbFd = (winFile)(fd);
			winShm pShm = pDbFd.pShm;
			winShmNode pShmNode;
			uint protect = (uint)(0x04);
			uint flags = (uint)(0x0002 | 0x0004);
			int rc = (int)(0);
			if (pShm == null)
			{
				rc = (int)(winOpenSharedMemory(pDbFd));
				if (rc != 0)
					return (int)(rc);
				pShm = pDbFd.pShm;

			}

			pShmNode = pShm.pShmNode;
			sqlite3_mutex_enter(pShmNode.mutex);
			if ((pShmNode.isUnlocked) != 0)
			{
				rc = (int)(winLockSharedMemory(pShmNode));
				if (rc != 0)
					goto shmpage_out;
				pShmNode.isUnlocked = (byte)(0);
			}


			if ((pShmNode.nRegion) <= (iRegion))
			{
				ShmRegion* apNew;
				int nByte = (int)((iRegion + 1) * szRegion);
				long sz = 0;
				pShmNode.szRegion = (int)(szRegion);
				rc = (int)(winFileSize((sqlite3_file)(pShmNode.hFile), &sz));
				if (rc != 0)
				{
					rc = (int)(winLogErrorAtLine((int)(10 | (19 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winShmMap1", pDbFd.zPath, (int)(47168)));
					goto shmpage_out;
				}

				if ((sz) < (nByte))
				{
					if (isWrite == 0)
						goto shmpage_out;
					rc = (int)(winTruncate((sqlite3_file)(pShmNode.hFile), (long)(nByte)));
					if (rc != 0)
					{
						rc = (int)(winLogErrorAtLine((int)(10 | (19 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winShmMap2", pDbFd.zPath, (int)(47183)));
						goto shmpage_out;
					}
				}

				apNew = (ShmRegion*)(sqlite3_realloc64(pShmNode.aRegion, (ulong)((iRegion + 1) * sizeof(ShmRegion))));
				if (apNew == null)
				{
					rc = (int)(10 | (12 << 8));
					goto shmpage_out;
				}

				pShmNode.aRegion = apNew;
				if ((pShmNode.isReadonly) != 0)
				{
					protect = (uint)(0x02);
					flags = (uint)(0x0004);
				}

				while ((pShmNode.nRegion) <= (iRegion))
				{
					void* hMap = null;
					void* pMap = null;
					hMap = (Void * (Void * , Void * , Void * , Void * , Void * , Void * ))(aSyscall[7].pCurrent)(pShmNode.hFile.h, null, (uint)(protect), (uint)(0), (uint)(nByte), null);
					if ((hMap) != null)
					{
						int iOffset = (int)(pShmNode.nRegion * szRegion);
						int iOffsetShift = (int)(iOffset % winSysInfo.dwAllocationGranularity);
						pMap = (Void * (Void * , Void * , Void * , Void * , Void * ))(aSyscall[49].pCurrent)(hMap, (uint)(flags), (uint)(0), (uint)(iOffset - iOffsetShift), (ulong)(szRegion + iOffsetShift));
					}

					if (pMap == null)
					{
						pShmNode.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
						rc = (int)(winLogErrorAtLine((int)(10 | (21 << 8)), (uint)(pShmNode.lastErrno), "winShmMap3", pDbFd.zPath, (int)(47242)));
						if ((hMap) != null)
							(Int(Void * ))(aSyscall[3].pCurrent)(hMap);
						goto shmpage_out;
					}

					pShmNode.aRegion[pShmNode.nRegion].pMap = pMap;
					pShmNode.aRegion[pShmNode.nRegion].hMap = hMap;
					pShmNode.nRegion++;
				}
			}

		shmpage_out:
			; if ((pShmNode.nRegion) > (iRegion)) { int iOffset = (int)(iRegion * szRegion); int iOffsetShift = (int)(iOffset % winSysInfo.dwAllocationGranularity); sbyte* p = (sbyte*)(pShmNode.aRegion[iRegion].pMap); *pp = (void*)(&p[iOffsetShift]); } else { *pp = null; }
			if (((pShmNode.isReadonly) != 0) && ((rc) == (0)))
				rc = (int)(8);
			sqlite3_mutex_leave(pShmNode.mutex);
			return (int)(rc);
		}
		public static void winShmPurge(sqlite3_vfs pVfs, int deleteFlag)
		{
			winShmNode pp;
			winShmNode p;

			pp = winShmNodeList;
			while ((p = pp) != null)
			{
				if ((p.nRef) == (0))
				{
					int i = 0;
					if ((p.mutex) != null)
					{
						sqlite3_mutex_free(p.mutex);
					}

					for (i = (int)(0); (i) < (p.nRegion); i++)
					{
						int bRc = (int)((Int(Void * ))(aSyscall[59].pCurrent)(p.aRegion[i].pMap));
						(void)(bRc);
						bRc = (int)((Int(Void * ))(aSyscall[3].pCurrent)(p.aRegion[i].hMap));
						(void)(bRc);
					}

					if ((p.hFile.h != null) && (p.hFile.h != ((void*)((long)(-1)))))
					{
						winClose((sqlite3_file)(p.hFile));
					}

					if ((deleteFlag) != 0)
					{
						sqlite3BeginBenignMalloc();
						winDelete(pVfs, p.zFilename, (int)(0));
						sqlite3EndBenignMalloc();
					}

					pp = p.pNext;
					sqlite3_free(p.aRegion);
					sqlite3_free(p);
				}
				else
				{
					pp = p.pNext;
				}
			}
		}
		public static int winShmSystemLock(winShmNode pFile, int lockType, int ofst, int nByte)
		{
			int rc = (int)(0);

			if ((lockType) == (1))
			{
				rc = (int)(winUnlockFile(&pFile.hFile.h, (uint)(ofst), (uint)(0), (uint)(nByte), (uint)(0)));
			}
			else
			{
				uint dwFlags = (uint)(0x00000001);
				if ((lockType) == (3))
					dwFlags |= (uint)(0x00000002);
				rc = (int)(winLockFile(&pFile.hFile.h, (uint)(dwFlags), (uint)(ofst), (uint)(0), (uint)(nByte), (uint)(0)));
			}

			if (rc != 0)
			{
				rc = (int)(0);
			}
			else
			{
				pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				rc = (int)(5);
			}

			return (int)(rc);
		}
		public static int winShmUnmap(sqlite3_file fd, int deleteFlag)
		{
			winFile pDbFd;
			winShm p;
			winShmNode pShmNode;
			winShm pp;
			pDbFd = (winFile)(fd);
			p = pDbFd.pShm;
			if ((p) == (null))
				return (int)(0);
			pShmNode = p.pShmNode;
			sqlite3_mutex_enter(pShmNode.mutex);
			for (pp = pShmNode.pFirst; (pp) != p; pp = (pp).pNext)
			{
			}

			pp = p.pNext;
			sqlite3_free(p);
			pDbFd.pShm = null;
			sqlite3_mutex_leave(pShmNode.mutex);
			winShmEnterMutex();

			pShmNode.nRef--;
			if ((pShmNode.nRef) == (0))
			{
				winShmPurge(pDbFd.pVfs, (int)(deleteFlag));
			}

			winShmLeaveMutex();
			return (int)(0);
		}
		public static int winSleep(sqlite3_vfs pVfs, int microsec)
		{
			sqlite3_win32_sleep((uint)((microsec + 999) / 1000));
			(void)(pVfs);
			return (int)(((microsec + 999) / 1000) * 1000);
		}
		public static int winSync(sqlite3_file id, int flags)
		{
			int rc = 0;
			winFile pFile = (winFile)(id);


			(void)(flags);
			if ((pFile.pMapRegion) != null)
			{
				if (((Int(Void * , Void * ))(aSyscall[79].pCurrent)(pFile.pMapRegion, (ulong)(0))) != 0)
				{
				}
				else
				{
					pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					return (int)(winLogErrorAtLine((int)(10 | (24 << 8)), (uint)(pFile.lastErrno), "winSync1", pFile.zPath, (int)(45972)));
				}
			}

			rc = (int)((Int(Void * ))(aSyscall[13].pCurrent)(pFile.h));
			if ((rc) != 0)
			{
				return (int)(0);
			}
			else
			{
				pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
				return (int)(winLogErrorAtLine((int)(10 | (4 << 8)), (uint)(pFile.lastErrno), "winSync2", pFile.zPath, (int)(45987)));
			}
		}
		public static int winTruncate(sqlite3_file id, long nByte)
		{
			winFile pFile = (winFile)(id);
			int rc = (int)(0);
			uint lastErrno = 0;
			long oldMmapSize = 0;
			if ((pFile.nFetchOut) > (0))
			{
				return (int)(0);
			}


			if ((pFile.szChunk) > (0))
			{
				nByte = (long)(((nByte + pFile.szChunk - 1) / pFile.szChunk) * pFile.szChunk);
			}

			if ((pFile.pMapRegion) != null)
			{
				oldMmapSize = (long)(pFile.mmapSize);
			}
			else
			{
				oldMmapSize = (long)(0);
			}

			winUnmapfile(pFile);
			if ((winSeekFile(pFile, (long)(nByte))) != 0)
			{
				rc = (int)(winLogErrorAtLine((int)(10 | (6 << 8)), (uint)(pFile.lastErrno), "winTruncate1", pFile.zPath, (int)(45875)));
			}
			else if (((0) == ((Int(Void * ))(aSyscall[53].pCurrent)(pFile.h))) && ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 1224L))
			{
				pFile.lastErrno = (uint)(lastErrno);
				rc = (int)(winLogErrorAtLine((int)(10 | (6 << 8)), (uint)(pFile.lastErrno), "winTruncate2", pFile.zPath, (int)(45880)));
			}

			if (((rc) == (0)) && ((oldMmapSize) > (0)))
			{
				if ((oldMmapSize) > (nByte))
				{
					winMapfile(pFile, (long)(-1));
				}
				else
				{
					winMapfile(pFile, (long)(oldMmapSize));
				}
			}

			return (int)(rc);
		}
		public static int winUnfetch(sqlite3_file fd, long iOff, void* p)
		{
			winFile pFd = (winFile)(fd);


			if ((p) != null)
			{
				pFd.nFetchOut--;
			}
			else
			{
				winUnmapfile(pFd);
			}


			return (int)(0);
		}
		public static sbyte* winUnicodeToMbcs(ushort* zWideText, int useAnsi)
		{
			int nByte = 0;
			sbyte* zText;
			int codepage = (int)((useAnsi) != 0 ? 0 : 1);
			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(codepage), (uint)(0), zWideText, (int)(-1), null, (int)(0), null, null));
			if ((nByte) == (0))
			{
				return null;
			}

			zText = sqlite3MallocZero((ulong)(nByte));
			if ((zText) == (null))
			{
				return null;
			}

			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(codepage), (uint)(0), zWideText, (int)(-1), zText, (int)(nByte), null, null));
			if ((nByte) == (0))
			{
				sqlite3_free(zText);
				zText = null;
			}

			return zText;
		}
		public static sbyte* winUnicodeToUtf8(ushort* zWideText)
		{
			int nByte = 0;
			sbyte* zText;
			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(65001), (uint)(0), zWideText, (int)(-1), null, (int)(0), null, null));
			if ((nByte) == (0))
			{
				return null;
			}

			zText = sqlite3MallocZero((ulong)(nByte));
			if ((zText) == (null))
			{
				return null;
			}

			nByte = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[60].pCurrent)((uint)(65001), (uint)(0), zWideText, (int)(-1), zText, (int)(nByte), null, null));
			if ((nByte) == (0))
			{
				sqlite3_free(zText);
				zText = null;
			}

			return zText;
		}
		public static int winUnlock(sqlite3_file id, int locktype)
		{
			int type = 0;
			winFile pFile = (winFile)(id);
			int rc = (int)(0);


			type = (int)(pFile.locktype);
			if ((type) >= (4))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0));
				if (((locktype) == (1)) && (winGetReadLock(pFile) == 0))
				{
					rc = (int)(winLogErrorAtLine((int)(10 | (8 << 8)), (uint)((Uint())(aSyscall[26].pCurrent)()), "winUnlock", pFile.zPath, (int)(46349)));
				}
			}

			if ((type) >= (2))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 1), (uint)(0), (uint)(1), (uint)(0));
			}

			if (((locktype) == (0)) && ((type) >= (1)))
			{
				winUnlockReadLock(pFile);
			}

			if ((type) >= (3))
			{
				winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte), (uint)(0), (uint)(1), (uint)(0));
			}

			pFile.locktype = ((byte)(locktype));
			return (int)(rc);
		}
		public static int winUnlockFile(void** phFile, uint offsetLow, uint offsetHigh, uint numBytesLow, uint numBytesHigh)
		{
			if ((1) != 0)
			{
				_OVERLAPPED ovlp = new _OVERLAPPED();
				CRuntime.memset(&ovlp, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
				ovlp..Offset = (uint)(offsetLow);
				ovlp..OffsetHigh = (uint)(offsetHigh);
				return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[58].pCurrent)(*phFile, (uint)(0), (uint)(numBytesLow), (uint)(numBytesHigh), &ovlp));
			}
			else
			{
				return (int)((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[57].pCurrent)(*phFile, (uint)(offsetLow), (uint)(offsetHigh), (uint)(numBytesLow), (uint)(numBytesHigh)));
			}
		}
		public static int winUnlockReadLock(winFile pFile)
		{
			int res = 0;
			uint lastErrno = 0;
			if ((1) != 0)
			{
				res = (int)(winUnlockFile(&pFile.h, (uint)(sqlite3PendingByte + 2), (uint)(0), (uint)(510), (uint)(0)));
			}
			else
			{
				res = (int)(winUnlockFile(&pFile.h, (uint)((sqlite3PendingByte + 2) + pFile.sharedLockByte), (uint)(0), (uint)(1), (uint)(0)));
			}

			if (((res) == (0)) && ((lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)())) != 158L))
			{
				pFile.lastErrno = (uint)(lastErrno);
				winLogErrorAtLine((int)(10 | (8 << 8)), (uint)(pFile.lastErrno), "winUnlockReadLock", pFile.zPath, (int)(46123));
			}

			return (int)(res);
		}
		public static int winUnmapfile(winFile pFile)
		{

			if ((pFile.pMapRegion) != null)
			{
				if ((Int(Void * ))(aSyscall[59].pCurrent)(pFile.pMapRegion) == 0)
				{
					pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					return (int)(winLogErrorAtLine((int)(10 | (24 << 8)), (uint)(pFile.lastErrno), "winUnmapfile1", pFile.zPath, (int)(47291)));
				}

				pFile.pMapRegion = null;
				pFile.mmapSize = (long)(0);
			}

			if (pFile.hMap != null)
			{
				if ((Int(Void * ))(aSyscall[3].pCurrent)(pFile.hMap) == 0)
				{
					pFile.lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
					return (int)(winLogErrorAtLine((int)(10 | (24 << 8)), (uint)(pFile.lastErrno), "winUnmapfile2", pFile.zPath, (int)(47302)));
				}

				pFile.hMap = null;
			}

			return (int)(0);
		}
		public static sbyte* winUtf8ToMbcs(sbyte* zText, int useAnsi)
		{
			sbyte* zTextMbcs;
			ushort* zTmpWide;
			zTmpWide = winUtf8ToUnicode(zText);
			if ((zTmpWide) == (null))
			{
				return null;
			}

			zTextMbcs = winUnicodeToMbcs(zTmpWide, (int)(useAnsi));
			sqlite3_free(zTmpWide);
			return zTextMbcs;
		}
		public static ushort* winUtf8ToUnicode(sbyte* zText)
		{
			int nChar = 0;
			ushort* zWideText;
			nChar = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(65001), (uint)(0), zText, (int)(-1), null, (int)(0)));
			if ((nChar) == (0))
			{
				return null;
			}

			zWideText = sqlite3MallocZero((ulong)(nChar * sizeof(ushort)));
			if ((zWideText) == (null))
			{
				return null;
			}

			nChar = (int)((Int(Uint, Uint, Uint, Uint, Uint, Uint))(aSyscall[50].pCurrent)((uint)(65001), (uint)(0), zText, (int)(-1), zWideText, (int)(nChar)));
			if ((nChar) == (0))
			{
				sqlite3_free(zWideText);
				zWideText = null;
			}

			return zWideText;
		}
		public static int winWrite(sqlite3_file id, void* pBuf, int amt, long offset)
		{
			int rc = (int)(0);
			winFile pFile = (winFile)(id);
			int nRetry = (int)(0);


			{
				_OVERLAPPED overlapped = new _OVERLAPPED();
				byte* aRem = (byte*)(pBuf);
				int nRem = (int)(amt);
				uint nWrite = 0;
				uint lastErrno = (uint)(0L);
				CRuntime.memset(&overlapped, (int)(0), (ulong)(sizeof(_OVERLAPPED)));
				overlapped..Offset = (uint)((int)(offset & 0xffffffff));
				overlapped..OffsetHigh = (uint)((int)((offset >> 32) & 0x7fffffff));
				while ((nRem) > (0))
				{
					if ((Int(Void * , Void * , Void * , Void * , Void * ))(aSyscall[61].pCurrent)(pFile.h, aRem, (uint)(nRem), &nWrite, &overlapped) == 0)
					{
						if ((winRetryIoerr(&nRetry, &lastErrno)) != 0)
							continue;
						break;
					}


					if (((nWrite) == (0)) || ((nWrite) > ((uint)(nRem))))
					{
						lastErrno = (uint)((Uint())(aSyscall[26].pCurrent)());
						break;
					}

					offset += (long)(nWrite);
					overlapped..Offset = (uint)((int)(offset & 0xffffffff));
					overlapped..OffsetHigh = (uint)((int)((offset >> 32) & 0x7fffffff));
					aRem += nWrite;
					nRem -= (int)(nWrite);
				}

				if ((nRem) > (0))
				{
					pFile.lastErrno = (uint)(lastErrno);
					rc = (int)(1);
				}
			}

			if ((rc) != 0)
			{
				if (((pFile.lastErrno) == (39L)) || ((pFile.lastErrno) == (112L)))
				{
					return (int)(winLogErrorAtLine((int)(13), (uint)(pFile.lastErrno), "winWrite1", pFile.zPath, (int)(45804)));
				}

				return (int)(winLogErrorAtLine((int)(10 | (3 << 8)), (uint)(pFile.lastErrno), "winWrite2", pFile.zPath, (int)(45809)));
			}
			else
			{
				winLogIoerr((int)(nRetry), (int)(45811));
			}

			return (int)(0);
		}
		public static int write32bits(sqlite3_file fd, long offset, uint val)
		{
			sbyte* ac = stackalloc sbyte[4];
			sqlite3Put4byte((byte*)(ac), (uint)(val));
			return (int)(sqlite3OsWrite(fd, ac, (int)(4), (long)(offset)));
		}
		public static int writeJournalHdr(Pager pPager)
		{
			int rc = (int)(0);
			sbyte* zHeader = pPager.pTmpSpace;
			uint nHeader = (uint)(pPager.pageSize);
			uint nWrite = 0;
			int ii = 0;

			if ((nHeader) > (pPager.sectorSize))
			{
				nHeader = (uint)(pPager.sectorSize);
			}

			for (ii = (int)(0); (ii) < (pPager.nSavepoint); ii++)
			{
				if ((pPager.aSavepoint[ii].iHdrOffset) == (0))
				{
					pPager.aSavepoint[ii].iHdrOffset = (long)(pPager.journalOff);
				}
			}

			pPager.journalHdr = (long)(pPager.journalOff = (long)(journalHdrOffset(pPager)));

			if ((((pPager.noSync) != 0) || ((pPager.journalMode) == (4))) || ((sqlite3OsDeviceCharacteristics(pPager.fd) & 0x00000200) != 0))
			{
				CRuntime.memcpy(zHeader, aJournalMagic, (ulong)(8 * sizeof(byte)));
				sqlite3Put4byte((byte*)(&zHeader[8 * sizeof(byte)]), (uint)(0xffffffff));
			}
			else
			{
				CRuntime.memset(zHeader, (int)(0), (ulong)(8 * sizeof(byte) + 4));
			}

			sqlite3_randomness((int)(sizeof(uint)), &pPager.cksumInit);
			sqlite3Put4byte((byte*)(&zHeader[8 * sizeof(byte) + 4]), (uint)(pPager.cksumInit));
			sqlite3Put4byte((byte*)(&zHeader[8 * sizeof(byte) + 8]), (uint)(pPager.dbOrigSize));
			sqlite3Put4byte((byte*)(&zHeader[8 * sizeof(byte) + 12]), (uint)(pPager.sectorSize));
			sqlite3Put4byte((byte*)(&zHeader[8 * sizeof(byte) + 16]), (uint)(pPager.pageSize));
			CRuntime.memset(&zHeader[8 * sizeof(byte) + 20], (int)(0), (ulong)(nHeader - (8 * sizeof(byte) + 20)));
			for (nWrite = (uint)(0); ((rc) == (0)) && ((nWrite) < (pPager.sectorSize)); nWrite += (uint)(nHeader))
			{
				rc = (int)(sqlite3OsWrite(pPager.jfd, zHeader, (int)(nHeader), (long)(pPager.journalOff)));

				pPager.journalOff += (long)(nHeader);
			}

			return (int)(rc);
		}
		public static int writeSuperJournal(Pager pPager, sbyte* zSuper)
		{
			int rc = 0;
			int nSuper = 0;
			long iHdrOff = 0;
			long jrnlSize = 0;
			uint cksum = (uint)(0);


			if (((zSuper == null) || ((pPager.journalMode) == (4))) || (!((pPager.jfd).pMethods != null)))
			{
				return (int)(0);
			}

			pPager.setSuper = (byte)(1);

			for (nSuper = (int)(0); zSuper[nSuper]; nSuper++)
			{
				cksum += (uint)(zSuper[nSuper]);
			}

			if ((pPager.fullSync) != 0)
			{
				pPager.journalOff = (long)(journalHdrOffset(pPager));
			}

			iHdrOff = (long)(pPager.journalOff);
			if (((((0 != (rc = (int)(write32bits(pPager.jfd, (long)(iHdrOff), ((uint)((sqlite3PendingByte / ((pPager).pageSize)) + 1)))))) || (0 != (rc = (int)(sqlite3OsWrite(pPager.jfd, zSuper, (int)(nSuper), (long)(iHdrOff + 4)))))) || (0 != (rc = (int)(write32bits(pPager.jfd, (long)(iHdrOff + 4 + nSuper), (uint)(nSuper)))))) || (0 != (rc = (int)(write32bits(pPager.jfd, (long)(iHdrOff + 4 + nSuper + 4), (uint)(cksum)))))) || (0 != (rc = (int)(sqlite3OsWrite(pPager.jfd, aJournalMagic, (int)(8), (long)(iHdrOff + 4 + nSuper + 8))))))
			{
				return (int)(rc);
			}

			pPager.journalOff += (long)(nSuper + 20);
			if (((0) == (rc = (int)(sqlite3OsFileSize(pPager.jfd, &jrnlSize)))) && ((jrnlSize) > (pPager.journalOff)))
			{
				rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(pPager.journalOff)));
			}

			return (int)(rc);
		}
		public static int xferCompatibleIndex(Index pDest, Index pSrc)
		{
			int i = 0;


			if ((pDest.nKeyCol != pSrc.nKeyCol) || (pDest.nColumn != pSrc.nColumn))
			{
				return (int)(0);
			}

			if (pDest.onError != pSrc.onError)
			{
				return (int)(0);
			}

			for (i = (int)(0); (i) < (pSrc.nKeyCol); i++)
			{
				if (pSrc.aiColumn[i] != pDest.aiColumn[i])
				{
					return (int)(0);
				}

				if ((pSrc.aiColumn[i]) == (-2))
				{

					if (sqlite3ExprCompare(null, pSrc.aColExpr.a[i].pExpr, pDest.aColExpr.a[i].pExpr, (int)(-1)) != 0)
					{
						return (int)(0);
					}
				}

				if (pSrc.aSortOrder[i] != pDest.aSortOrder[i])
				{
					return (int)(0);
				}

				if (sqlite3_stricmp(pSrc.azColl[i], pDest.azColl[i]) != 0)
				{
					return (int)(0);
				}
			}

			if ((sqlite3ExprCompare(null, pSrc.pPartIdxWhere, pDest.pPartIdxWhere, (int)(-1))) != 0)
			{
				return (int)(0);
			}

			return (int)(1);
		}
		public static int xferOptimization(Parse pParse, Table pDest, Select pSelect, int onError, int iDbDest)
		{
			sqlite3 db = pParse.db;
			ExprList pEList;
			Table pSrc;
			Index pSrcIdx; Index pDestIdx;
			SrcItem pItem;
			int i = 0;
			int iDbSrc = 0;
			int iSrc = 0; int iDest = 0;
			int addr1 = 0; int addr2 = 0;
			int emptyDestTest = (int)(0);
			int emptySrcTest = (int)(0);
			Vdbe v;
			int regAutoinc = 0;
			int destHasUniqueIdx = (int)(0);
			int regData = 0; int regRowid = 0;

			if (((pParse.pWith) != null) || ((pSelect.pWith) != null))
			{
				return (int)(0);
			}

			if ((((pDest).eTabType) == (1)))
			{
				return (int)(0);
			}

			if ((onError) == (11))
			{
				if ((pDest.iPKey) >= (0))
					onError = (int)(pDest.keyConf);
				if ((onError) == (11))
					onError = (int)(2);
			}


			if (pSelect.pSrc.nSrc != 1)
			{
				return (int)(0);
			}

			if ((pSelect.pSrc.a[0].pSelect) != null)
			{
				return (int)(0);
			}

			if ((pSelect.pWhere) != null)
			{
				return (int)(0);
			}

			if ((pSelect.pOrderBy) != null)
			{
				return (int)(0);
			}

			if ((pSelect.pGroupBy) != null)
			{
				return (int)(0);
			}

			if ((pSelect.pLimit) != null)
			{
				return (int)(0);
			}

			if ((pSelect.pPrior) != null)
			{
				return (int)(0);
			}

			if ((pSelect.selFlags & 0x0000001) != 0)
			{
				return (int)(0);
			}

			pEList = pSelect.pEList;

			if (pEList.nExpr != 1)
			{
				return (int)(0);
			}


			if (pEList.a[0].pExpr.op != 180)
			{
				return (int)(0);
			}

			pItem = pSelect.pSrc.a;
			pSrc = sqlite3LocateTableItem(pParse, (uint)(0), pItem);
			if ((pSrc) == (null))
			{
				return (int)(0);
			}

			if (((pSrc.tnum) == (pDest.tnum)) && ((pSrc.pSchema) == (pDest.pSchema)))
			{
				return (int)(0);
			}

			if ((((pDest).tabFlags & 0x00000080) == (0)) != (((pSrc).tabFlags & 0x00000080) == (0)))
			{
				return (int)(0);
			}

			if (!(((pSrc).eTabType) == (0)))
			{
				return (int)(0);
			}

			if (pDest.nCol != pSrc.nCol)
			{
				return (int)(0);
			}

			if (pDest.iPKey != pSrc.iPKey)
			{
				return (int)(0);
			}

			if (((pDest.tabFlags & 0x00010000) != 0) && ((pSrc.tabFlags & 0x00010000) == (0)))
			{
				return (int)(0);
			}

			for (i = (int)(0); (i) < (pDest.nCol); i++)
			{
				Column* pDestCol = &pDest.aCol[i];
				Column* pSrcCol = &pSrc.aCol[i];
				if ((pDestCol->colFlags & 0x0060) != (pSrcCol->colFlags & 0x0060))
				{
					return (int)(0);
				}

				if ((pDestCol->colFlags & 0x0060) != 0)
				{
					if (sqlite3ExprCompare(null, sqlite3ColumnExpr(pSrc, pSrcCol), sqlite3ColumnExpr(pDest, pDestCol), (int)(-1)) != 0)
					{
						return (int)(0);
					}
				}

				if (pDestCol->affinity != pSrcCol->affinity)
				{
					return (int)(0);
				}

				if (sqlite3_stricmp(sqlite3ColumnColl(pDestCol), sqlite3ColumnColl(pSrcCol)) != 0)
				{
					return (int)(0);
				}

				if (((pDestCol->notNull) != 0) && (pSrcCol->notNull == 0))
				{
					return (int)(0);
				}

				if (((pDestCol->colFlags & 0x0060) == (0)) && ((i) > (0)))
				{
					Expr pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);
					Expr pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);




					if ((((pDestExpr) == (null)) != ((pSrcExpr) == (null))) || ((pDestExpr != null) && (CRuntime.strcmp(pDestExpr.u.zToken, pSrcExpr.u.zToken) != 0)))
					{
						return (int)(0);
					}
				}
			}

			for (pDestIdx = pDest.pIndex; pDestIdx; pDestIdx = pDestIdx.pNext)
			{
				if (((pDestIdx).onError != 0))
				{
					destHasUniqueIdx = (int)(1);
				}

				for (pSrcIdx = pSrc.pIndex; pSrcIdx; pSrcIdx = pSrcIdx.pNext)
				{
					if ((xferCompatibleIndex(pDestIdx, pSrcIdx)) != 0)
						break;
				}

				if ((pSrcIdx) == (null))
				{
					return (int)(0);
				}

				if ((((pSrcIdx.tnum) == (pDestIdx.tnum)) && ((pSrc.pSchema) == (pDest.pSchema))) && ((sqlite3FaultSim((int)(411))) == (0)))
				{
					return (int)(0);
				}
			}

			if (((pDest.pCheck) != null) && ((sqlite3ExprListCompare(pSrc.pCheck, pDest.pCheck, (int)(-1))) != 0))
			{
				return (int)(0);
			}


			if (((db.flags & 0x00004000) != 0) && (pDest.u.tab.pFKey != null))
			{
				return (int)(0);
			}

			if ((db.flags & ((ulong)(0x00001) << 32)) != 0)
			{
				return (int)(0);
			}

			iDbSrc = (int)(sqlite3SchemaToIndex(db, pSrc.pSchema));
			v = sqlite3GetVdbe(pParse);
			sqlite3CodeVerifySchema(pParse, (int)(iDbSrc));
			iSrc = (int)(pParse.nTab++);
			iDest = (int)(pParse.nTab++);
			regAutoinc = (int)(autoIncBegin(pParse, (int)(iDbDest), pDest));
			regData = (int)(sqlite3GetTempReg(pParse));
			sqlite3VdbeAddOp2(v, (int)(74), (int)(0), (int)(regData));
			regRowid = (int)(sqlite3GetTempReg(pParse));
			sqlite3OpenTable(pParse, (int)(iDest), (int)(iDbDest), pDest, (int)(112));

			if (((db.mDbFlags & 0x0004) == (0)) && (((((pDest.iPKey) < (0)) && (pDest.pIndex != null)) || ((destHasUniqueIdx) != 0)) || ((onError != 2) && (onError != 1))))
			{
				addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iDest), (int)(0)));
				emptyDestTest = (int)(sqlite3VdbeAddOp0(v, (int)(11)));
				sqlite3VdbeJumpHere(v, (int)(addr1));
			}

			if ((((pSrc).tabFlags & 0x00000080) == (0)))
			{
				byte insFlags = 0;
				sqlite3OpenTable(pParse, (int)(iSrc), (int)(iDbSrc), pSrc, (int)(101));
				emptySrcTest = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iSrc), (int)(0)));
				if ((pDest.iPKey) >= (0))
				{
					addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iSrc), (int)(regRowid)));
					if ((db.mDbFlags & 0x0004) == (0))
					{
						addr2 = (int)(sqlite3VdbeAddOp3(v, (int)(33), (int)(iDest), (int)(0), (int)(regRowid)));
						sqlite3RowidConstraint(pParse, (int)(onError), pDest);
						sqlite3VdbeJumpHere(v, (int)(addr2));
					}

					autoIncStep(pParse, (int)(regAutoinc), (int)(regRowid));
				}
				else if (((pDest.pIndex) == (null)) && ((db.mDbFlags & 0x0008) == 0))
				{
					addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(126), (int)(iDest), (int)(regRowid)));
				}
				else
				{
					addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(134), (int)(iSrc), (int)(regRowid)));

				}

				if ((db.mDbFlags & 0x0004) != 0)
				{
					sqlite3VdbeAddOp1(v, (int)(136), (int)(iDest));
					insFlags = (byte)(0x08 | 0x10 | 0x80);
				}
				else
				{
					insFlags = (byte)(0x01 | 0x20 | 0x08 | 0x80);
				}

				{
					sqlite3VdbeAddOp3(v, (int)(128), (int)(iDest), (int)(iSrc), (int)(regRowid));
				}

				sqlite3VdbeAddOp3(v, (int)(127), (int)(iDest), (int)(regData), (int)(regRowid));
				if ((db.mDbFlags & 0x0004) == (0))
				{
					sqlite3VdbeChangeP4(v, (int)(-1), (sbyte*)(pDest), (int)(-6));
				}

				sqlite3VdbeChangeP5(v, (ushort)(insFlags));
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iSrc), (int)(addr1));
				sqlite3VdbeAddOp2(v, (int)(121), (int)(iSrc), (int)(0));
				sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
			}
			else
			{
				sqlite3TableLock(pParse, (int)(iDbDest), (uint)(pDest.tnum), (byte)(1), pDest.zName);
				sqlite3TableLock(pParse, (int)(iDbSrc), (uint)(pSrc.tnum), (byte)(0), pSrc.zName);
			}

			for (pDestIdx = pDest.pIndex; pDestIdx; pDestIdx = pDestIdx.pNext)
			{
				byte idxInsFlags = (byte)(0);
				for (pSrcIdx = pSrc.pIndex; (pSrcIdx); pSrcIdx = pSrcIdx.pNext)
				{
					if ((xferCompatibleIndex(pDestIdx, pSrcIdx)) != 0)
						break;
				}


				sqlite3VdbeAddOp3(v, (int)(101), (int)(iSrc), (int)(pSrcIdx.tnum), (int)(iDbSrc));
				sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
				sqlite3VdbeAddOp3(v, (int)(112), (int)(iDest), (int)(pDestIdx.tnum), (int)(iDbDest));
				sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
				sqlite3VdbeChangeP5(v, (ushort)(0x01));
				addr1 = (int)(sqlite3VdbeAddOp2(v, (int)(38), (int)(iSrc), (int)(0)));
				if ((db.mDbFlags & 0x0004) != 0)
				{
					for (i = (int)(0); (i) < (pSrcIdx.nColumn); i++)
					{
						sbyte* zColl = pSrcIdx.azColl[i];
						if ((sqlite3_stricmp(sqlite3StrBINARY, zColl)) != 0)
							break;
					}

					if ((i) == (pSrcIdx.nColumn))
					{
						idxInsFlags = (byte)(0x10 | 0x80);
						sqlite3VdbeAddOp1(v, (int)(136), (int)(iDest));
						sqlite3VdbeAddOp2(v, (int)(128), (int)(iDest), (int)(iSrc));
					}
				}
				else if ((!(((pSrc).tabFlags & 0x00000080) == (0))) && ((pDestIdx.idxType) == (2)))
				{
					idxInsFlags |= (byte)(0x01);
				}

				if (idxInsFlags != (0x10 | 0x80))
				{
					sqlite3VdbeAddOp3(v, (int)(133), (int)(iSrc), (int)(regData), (int)(1));
					if ((((db.mDbFlags & 0x0004) == (0)) && (!(((pDest).tabFlags & 0x00000080) == (0)))) && (((pDestIdx).idxType) == (2)))
					{
					}
				}

				sqlite3VdbeAddOp2(v, (int)(137), (int)(iDest), (int)(regData));
				sqlite3VdbeChangeP5(v, (ushort)(idxInsFlags | 0x08));
				sqlite3VdbeAddOp2(v, (int)(5), (int)(iSrc), (int)(addr1 + 1));
				sqlite3VdbeJumpHere(v, (int)(addr1));
				sqlite3VdbeAddOp2(v, (int)(121), (int)(iSrc), (int)(0));
				sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
			}

			if ((emptySrcTest) != 0)
				sqlite3VdbeJumpHere(v, (int)(emptySrcTest));
			sqlite3ReleaseTempReg(pParse, (int)(regRowid));
			sqlite3ReleaseTempReg(pParse, (int)(regData));
			if ((emptyDestTest) != 0)
			{
				sqlite3AutoincrementEnd(pParse);
				sqlite3VdbeAddOp2(v, (int)(70), (int)(0), (int)(0));
				sqlite3VdbeJumpHere(v, (int)(emptyDestTest));
				sqlite3VdbeAddOp2(v, (int)(121), (int)(iDest), (int)(0));
				return (int)(0);
			}
			else
			{
				return (int)(1);
			}
		}
		public static void xorMemory(EntropyGatherer* p, byte* x, int sz)
		{
			int j = 0; int k = 0;
			for (j = (int)(0), k = (int)(p->i); (j) < (sz); j++)
			{
				p->a[k++] ^= (byte)(x[j]);
				if ((k) >= (p->na))
					k = (int)(0);
			}

			p->i = (int)(k);
			p->nXor += (int)(sz);
		}
		public static void yy_accept(yyParser yypParser)
		{
			Parse pParse = yypParser.pParse;

			yypParser.pParse = pParse;
		}
		public static void yy_destructor(yyParser yypParser, ushort yymajor, YYMINORTYPE* yypminor)
		{
			Parse pParse = yypParser.pParse;
			switch (yymajor)
			{
				case 204:
				case 239:
				case 240:
				case 252:
					{
						sqlite3SelectDelete(pParse.db, (yypminor->yy47));
					}

					break;
				case 216:
				case 217:
				case 246:
				case 248:
				case 260:
				case 267:
				case 278:
				case 280:
				case 283:
				case 290:
				case 295:
				case 311:
					{
						sqlite3ExprDelete(pParse.db, (yypminor->yy528));
					}

					break;
				case 221:
				case 231:
				case 232:
				case 244:
				case 247:
				case 249:
				case 253:
				case 254:
				case 262:
				case 268:
				case 277:
				case 279:
				case 310:
					{
						sqlite3ExprListDelete(pParse.db, (yypminor->yy322));
					}

					break;
				case 238:
				case 245:
				case 256:
				case 257:
				case 263:
					{
						sqlite3SrcListDelete(pParse.db, (yypminor->yy131));
					}

					break;
				case 241:
					{
						sqlite3WithDelete(pParse.db, (yypminor->yy521));
					}

					break;
				case 251:
				case 306:
					{
						sqlite3WindowListDelete(pParse.db, (yypminor->yy41));
					}

					break;
				case 261:
				case 264:
				case 270:
					{
						sqlite3IdListDelete(pParse.db, (yypminor->yy254));
					}

					break;
				case 273:
				case 307:
				case 308:
				case 309:
				case 312:
					{
						sqlite3WindowDelete(pParse.db, (yypminor->yy41));
					}

					break;
				case 286:
				case 291:
					{
						sqlite3DeleteTriggerStep(pParse.db, (yypminor->yy33));
					}

					break;
				case 288:
					{
						sqlite3IdListDelete(pParse.db, (yypminor->yy180).b);
					}

					break;
				case 314:
				case 315:
				case 316:
					{
						sqlite3ExprDelete(pParse.db, (yypminor->yy595).pExpr);
					}

					break;
				default:
					break;
			}
		}
		public static ushort yy_find_reduce_action(ushort stateno, ushort iLookAhead)
		{
			int i = 0;

			i = (int)(yy_reduce_ofst[stateno]);

			i += (int)(iLookAhead);


			return (ushort)(yy_action[i]);
		}
		public static ushort yy_find_shift_action(ushort iLookAhead, ushort stateno)
		{
			int i = 0;
			if ((stateno) > (573))
				return (ushort)(stateno);

			do
			{
				i = (int)(yy_shift_ofst[stateno]);





				i += (int)(iLookAhead);

				if (yy_lookahead[i] != iLookAhead)
				{
					ushort iFallback = 0;

					iFallback = (ushort)(yyFallback[iLookAhead]);
					if (iFallback != 0)
					{

						iLookAhead = (ushort)(iFallback);
						continue;
					}

					{
						int j = (int)(i - iLookAhead + 101);

						if (((yy_lookahead[j]) == (101)) && ((iLookAhead) > (0)))
						{
							return (ushort)(yy_action[j]);
						}
					}

					return (ushort)(yy_default[stateno]);
				}
				else
				{

					return (ushort)(yy_action[i]);
				}
			}
			while ((1) != 0);
		}
		public static void yy_pop_parser_stack(yyParser pParser)
		{
			yyStackEntry* yytos;


			yytos = pParser.yytos--;
			yy_destructor(pParser, (ushort)(yytos->major), &yytos->minor);
		}
		public static ushort yy_reduce(yyParser yypParser, uint yyruleno, int yyLookahead, Token yyLookaheadToken, Parse pParse)
		{
			return 1;
		}
		public static void yy_shift(yyParser yypParser, ushort yyNewState, ushort yyMajor, Token yyMinor)
		{
			yyStackEntry* yytos;
			yypParser.yytos++;
			if ((yypParser.yytos) > (yypParser.yystackEnd))
			{
				yypParser.yytos--;
				yyStackOverflow(yypParser);
				return;
			}

			if ((yyNewState) > (573))
			{
				yyNewState += (ushort)(1236 - 831);
			}

			yytos = yypParser.yytos;
			yytos->stateno = (ushort)(yyNewState);
			yytos->major = (ushort)(yyMajor);
			yytos->minor.yy0 = (Token)(yyMinor);
		}
		public static void yy_syntax_error(yyParser yypParser, int yymajor, Token yyminor)
		{
			Parse pParse = yypParser.pParse;
			(void)(yymajor);
			if ((yyminor.z[0]) != 0)
			{
				sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &yyminor);
			}
			else
			{
				sqlite3ErrorMsg(pParse, "incomplete input");
			}

			yypParser.pParse = pParse;
		}
		public static void yyStackOverflow(yyParser yypParser)
		{
			Parse pParse = yypParser.pParse;
			while ((yypParser.yytos) > (yypParser.yystack))
			{
				yy_pop_parser_stack(yypParser);
			}

			sqlite3ErrorMsg(pParse, "parser stack overflow");
			yypParser.pParse = pParse;
		}
		public static void zeroblobFunc(sqlite3_context context, int argc, sqlite3_value argv)
		{
			long n = 0;
			int rc = 0;


			n = (long)(sqlite3_value_int64(argv[0]));
			if ((n) < (0))
				n = (long)(0);
			rc = (int)(sqlite3_result_zeroblob64(context, (ulong)(n)));
			if ((rc) != 0)
			{
				sqlite3_result_error_code(context, (int)(rc));
			}
		}
		public static int zeroJournalHdr(Pager pPager, int doTruncate)
		{
			int rc = (int)(0);


			if ((pPager.journalOff) != 0)
			{
				long iLimit = (long)(pPager.journalSizeLimit);
				if (((doTruncate) != 0) || ((iLimit) == (0)))
				{
					rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(0)));
				}
				else
				{
					rc = (int)(sqlite3OsWrite(pPager.jfd, zeroJournalHdr_zeroHdr, (int)(28 * sizeof(sbyte)), (long)(0)));
				}

				if (((rc) == (0)) && (pPager.noSync == 0))
				{
					rc = (int)(sqlite3OsSync(pPager.jfd, (int)(0x00010 | pPager.syncFlags)));
				}

				if (((rc) == (0)) && ((iLimit) > (0)))
				{
					long sz = 0;
					rc = (int)(sqlite3OsFileSize(pPager.jfd, &sz));
					if (((rc) == (0)) && ((sz) > (iLimit)))
					{
						rc = (int)(sqlite3OsTruncate(pPager.jfd, (long)(iLimit)));
					}
				}
			}

			return (int)(rc);
		}
		public static void zeroPage(MemPage pPage, int flags)
		{
			byte* data = pPage.aData;
			BtShared pBt = pPage.pBt;
			byte hdr = (byte)(pPage.hdrOffset);
			ushort first = 0;
			if ((pBt.btsFlags & 0x000c) != 0)
			{
				CRuntime.memset(&data[hdr], (int)(0), (ulong)(pBt.usableSize - hdr));
			}

			data[hdr] = (byte)((sbyte)(flags));
			first = (ushort)(hdr + ((flags & 0x08) == (0) ? 12 : 8));
			CRuntime.memset(&data[hdr + 1], (int)(0), (ulong)(4));
			data[hdr + 7] = (byte)(0);
			((&data[hdr + 5])[0] = ((byte)((pBt.usableSize) >> 8)), (&data[hdr + 5])[1] = ((byte)(pBt.usableSize)));
			pPage.nFree = (int)((ushort)(pBt.usableSize - first));
			decodeFlags(pPage, (int)(flags));
			pPage.cellOffset = (ushort)(first);
			pPage.aDataEnd = &data[pBt.pageSize];
			pPage.aCellIdx = &data[first];
			pPage.aDataOfst = &data[pPage.childPtrSize];
			pPage.nOverflow = (byte)(0);

			pPage.maskPage = ((ushort)(pBt.pageSize - 1));
			pPage.nCell = (ushort)(0);
			pPage.isInit = (byte)(1);
		}
	}
}