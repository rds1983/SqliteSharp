// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int allocateBtreePage(BtShared pBt, MemPage ppPage, uint* pPgno, uint nearby, byte eMode)
		{
			MemPage pPage1;
			int rc = 0;
			uint n = 0;
			uint k = 0;
			MemPage pTrunk = null;
			MemPage pPrevTrunk = null;
			uint mxPage = 0;
			pPage1 = pBt.pPage1;
			mxPage = (uint)(btreePagecount(pBt));
			n = (uint)(sqlite3Get4byte(&pPage1.aData[36]));
			if ((n) >= (mxPage))
			{
				return (int)(sqlite3CorruptError((int)(72266)));
			}

			if ((n) > (0))
			{
				uint iTrunk = 0;
				byte searchList = (byte)(0);
				uint nSearch = (uint)(0);
				if ((eMode) == (1))
				{
					if ((nearby) <= (mxPage))
					{
						byte eType = 0;
						rc = (int)(ptrmapGet(pBt, (uint)(nearby), &eType, null));
						if ((rc) != 0)
							return (int)(rc);
						if ((eType) == (2))
						{
							searchList = (byte)(1);
						}
					}
				}
				else if ((eMode) == (2))
				{
					searchList = (byte)(1);
				}

				rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
				if ((rc) != 0)
					return (int)(rc);
				sqlite3Put4byte(&pPage1.aData[36], (uint)(n - 1));
				do
				{
					pPrevTrunk = pTrunk;
					if ((pPrevTrunk) != null)
					{
						iTrunk = (uint)(sqlite3Get4byte(&pPrevTrunk.aData[0]));
					}
					else
					{
						iTrunk = (uint)(sqlite3Get4byte(&pPage1.aData[32]));
					}

					if (((iTrunk) > (mxPage)) || ((nSearch++) > (n)))
					{
						rc = (int)(sqlite3CorruptError((int)(72322)));
					}
					else
					{
						rc = (int)(btreeGetUnusedPage(pBt, (uint)(iTrunk), pTrunk, (int)(0)));
					}

					if ((rc) != 0)
					{
						pTrunk = null;
						goto end_allocate_page;
					}

					k = (uint)(sqlite3Get4byte(&pTrunk.aData[4]));
					if (((k) == (0)) && (searchList == 0))
					{
						rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
						if ((rc) != 0)
						{
							goto end_allocate_page;
						}

						*pPgno = (uint)(iTrunk);
						CRuntime.memcpy(&pPage1.aData[32], &pTrunk.aData[0], (ulong)(4));
						ppPage = pTrunk;
						pTrunk = null;
					}
					else if ((k) > (pBt.usableSize / 4 - 2))
					{
						rc = (int)(sqlite3CorruptError((int)(72351)));
						goto end_allocate_page;
					}
					else if (((searchList) != 0) && (((nearby) == (iTrunk)) || (((iTrunk) < (nearby)) && ((eMode) == (2)))))
					{
						*pPgno = (uint)(iTrunk);
						ppPage = pTrunk;
						searchList = (byte)(0);
						rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
						if ((rc) != 0)
						{
							goto end_allocate_page;
						}

						if ((k) == (0))
						{
							if (pPrevTrunk == null)
							{
								CRuntime.memcpy(&pPage1.aData[32], &pTrunk.aData[0], (ulong)(4));
							}
							else
							{
								rc = (int)(sqlite3PagerWrite(pPrevTrunk.pDbPage));
								if (rc != 0)
								{
									goto end_allocate_page;
								}

								CRuntime.memcpy(&pPrevTrunk.aData[0], &pTrunk.aData[0], (ulong)(4));
							}
						}
						else
						{
							MemPage pNewTrunk;
							uint iNewTrunk = (uint)(sqlite3Get4byte(&pTrunk.aData[8]));
							if ((iNewTrunk) > (mxPage))
							{
								rc = (int)(sqlite3CorruptError((int)(72385)));
								goto end_allocate_page;
							}

							rc = (int)(btreeGetUnusedPage(pBt, (uint)(iNewTrunk), pNewTrunk, (int)(0)));
							if (rc != 0)
							{
								goto end_allocate_page;
							}

							rc = (int)(sqlite3PagerWrite(pNewTrunk.pDbPage));
							if (rc != 0)
							{
								releasePage(pNewTrunk);
								goto end_allocate_page;
							}

							CRuntime.memcpy(&pNewTrunk.aData[0], &pTrunk.aData[0], (ulong)(4));
							sqlite3Put4byte(&pNewTrunk.aData[4], (uint)(k - 1));
							CRuntime.memcpy(&pNewTrunk.aData[8], &pTrunk.aData[12], (ulong)((k - 1) * 4));
							releasePage(pNewTrunk);
							if (pPrevTrunk == null)
							{
								sqlite3Put4byte(&pPage1.aData[32], (uint)(iNewTrunk));
							}
							else
							{
								rc = (int)(sqlite3PagerWrite(pPrevTrunk.pDbPage));
								if ((rc) != 0)
								{
									goto end_allocate_page;
								}

								sqlite3Put4byte(&pPrevTrunk.aData[0], (uint)(iNewTrunk));
							}
						}

						pTrunk = null;
					}
					else if ((k) > (0))
					{
						uint closest = 0;
						uint iPage = 0;
						byte* aData = pTrunk.aData;
						if ((nearby) > (0))
						{
							uint i = 0;
							closest = (uint)(0);
							if ((eMode) == (2))
							{
								for (i = (uint)(0); (i) < (k); i++)
								{
									iPage = (uint)(sqlite3Get4byte(&aData[8 + i * 4]));
									if ((iPage) <= (nearby))
									{
										closest = (uint)(i);
										break;
									}
								}
							}
							else
							{
								int dist = 0;
								dist = (int)(sqlite3AbsInt32((int)(sqlite3Get4byte(&aData[8]) - nearby)));
								for (i = (uint)(1); (i) < (k); i++)
								{
									int d2 = (int)(sqlite3AbsInt32((int)(sqlite3Get4byte(&aData[8 + i * 4]) - nearby)));
									if ((d2) < (dist))
									{
										closest = (uint)(i);
										dist = (int)(d2);
									}
								}
							}
						}
						else
						{
							closest = (uint)(0);
						}

						iPage = (uint)(sqlite3Get4byte(&aData[8 + closest * 4]));
						if (((iPage) > (mxPage)) || ((iPage) < (2)))
						{
							rc = (int)(sqlite3CorruptError((int)(72450)));
							goto end_allocate_page;
						}

						if ((searchList == 0) || (((iPage) == (nearby)) || (((iPage) < (nearby)) && ((eMode) == (2)))))
						{
							int noContent = 0;
							*pPgno = (uint)(iPage);
							rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
							if ((rc) != 0)
								goto end_allocate_page;
							if ((closest) < (k - 1))
							{
								CRuntime.memcpy(&aData[8 + closest * 4], &aData[4 + k * 4], (ulong)(4));
							}

							sqlite3Put4byte(&aData[4], (uint)(k - 1));
							noContent = (int)((!btreeGetHasContent(pBt, (uint)(*pPgno))) != 0 ? 0x01 : 0);
							rc = (int)(btreeGetUnusedPage(pBt, (uint)(*pPgno), ppPage, (int)(noContent)));
							if ((rc) == (0))
							{
								rc = (int)(sqlite3PagerWrite((ppPage).pDbPage));
								if (rc != 0)
								{
									releasePage(ppPage);
									ppPage = null;
								}
							}

							searchList = (byte)(0);
						}
					}

					releasePage(pPrevTrunk);
					pPrevTrunk = null;
				}
				while ((searchList) != 0);
			}
			else
			{
				int bNoContent = (int)(((0) == (pBt.bDoTruncate)) ? 0x01 : 0);
				rc = (int)(sqlite3PagerWrite(pBt.pPage1.pDbPage));
				if ((rc) != 0)
					return (int)(rc);
				pBt.nPage++;
				if ((pBt.nPage) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
					pBt.nPage++;
				if (((pBt.autoVacuum) != 0) && ((ptrmapPageno((pBt), (uint)(pBt.nPage))) == (pBt.nPage)))
				{
					MemPage pPg = null;
					rc = (int)(btreeGetUnusedPage(pBt, (uint)(pBt.nPage), pPg, (int)(bNoContent)));
					if ((rc) == (0))
					{
						rc = (int)(sqlite3PagerWrite(pPg.pDbPage));
						releasePage(pPg);
					}

					if ((rc) != 0)
						return (int)(rc);
					pBt.nPage++;
					if ((pBt.nPage) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
					{
						pBt.nPage++;
					}
				}

				sqlite3Put4byte(28 + pBt.pPage1.aData, (uint)(pBt.nPage));
				*pPgno = (uint)(pBt.nPage);
				rc = (int)(btreeGetUnusedPage(pBt, (uint)(*pPgno), ppPage, (int)(bNoContent)));
				if ((rc) != 0)
					return (int)(rc);
				rc = (int)(sqlite3PagerWrite((ppPage).pDbPage));
				if (rc != 0)
				{
					releasePage(ppPage);
					ppPage = null;
				}
			}

		end_allocate_page:
			; releasePage(pTrunk);
			releasePage(pPrevTrunk);
			return (int)(rc);
		}
		public static int allocateTempSpace(BtShared pBt)
		{
			pBt.pTmpSpace = sqlite3PageMalloc((int)(pBt.pageSize));
			if ((pBt.pTmpSpace) == (null))
			{
				BtCursor pCur = pBt.pCursor;
				pBt.pCursor = pCur.pNext;
				CRuntime.memset(pCur, (int)(0), (ulong)(sizeof(BtCursor)));
				return (int)(7);
			}

			CRuntime.memset(pBt.pTmpSpace, (int)(0), (ulong)(8));
			pBt.pTmpSpace += 4;
			return (int)(0);
		}
		public static void btreeClearHasContent(BtShared pBt)
		{
			sqlite3BitvecDestroy(pBt.pHasContent);
			pBt.pHasContent = null;
		}
		public static int btreeGetHasContent(BtShared pBt, uint pgno)
		{
			Bitvec* p = pBt.pHasContent;
			return (((p) != null) && (((pgno) > (sqlite3BitvecSize(p))) || ((sqlite3BitvecTestNotNull(p, (uint)(pgno))) != 0)) ? 1 : 0);
		}
		public static int btreeGetPage(BtShared pBt, uint pgno, MemPage ppPage, int flags)
		{
			int rc = 0;
			PgHdr pDbPage;
			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(pgno), pDbPage, (int)(flags)));
			if ((rc) != 0)
				return (int)(rc);
			ppPage = btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
			return (int)(0);
		}
		public static int btreeGetUnusedPage(BtShared pBt, uint pgno, MemPage ppPage, int flags)
		{
			int rc = (int)(btreeGetPage(pBt, (uint)(pgno), ppPage, (int)(flags)));
			if ((rc) == (0))
			{
				if ((sqlite3PagerPageRefcount((ppPage).pDbPage)) > (1))
				{
					releasePage(ppPage);
					ppPage = null;
					return (int)(sqlite3CorruptError((int)(68467)));
				}

				(ppPage).isInit = (byte)(0);
			}
			else
			{
				ppPage = null;
			}

			return (int)(rc);
		}
		public static uint btreePagecount(BtShared pBt)
		{
			return (uint)(pBt.nPage);
		}
		public static MemPage btreePageLookup(BtShared pBt, uint pgno)
		{
			PgHdr pDbPage;
			pDbPage = sqlite3PagerLookup(pBt.pPager, (uint)(pgno));
			if ((pDbPage) != null)
			{
				return btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
			}

			return null;
		}
		public static int btreeSetHasContent(BtShared pBt, uint pgno)
		{
			int rc = (int)(0);
			if (pBt.pHasContent == null)
			{
				pBt.pHasContent = sqlite3BitvecCreate((uint)(pBt.nPage));
				if (pBt.pHasContent == null)
				{
					rc = (int)(7);
				}
			}

			if (((rc) == (0)) && ((pgno) <= (sqlite3BitvecSize(pBt.pHasContent))))
			{
				rc = (int)(sqlite3BitvecSet(pBt.pHasContent, (uint)(pgno)));
			}

			return (int)(rc);
		}
		public static void btreeSetNPage(BtShared pBt, MemPage pPage1)
		{
			int nPage = (int)(sqlite3Get4byte(&pPage1.aData[28]));
			if ((nPage) == (0))
				sqlite3PagerPagecount(pBt.pPager, &nPage);
			pBt.nPage = (uint)(nPage);
		}
		public static int clearDatabasePage(BtShared pBt, uint pgno, int freePageFlag, long* pnChange)
		{
			MemPage pPage;
			int rc = 0;
			byte* pCell;
			int i = 0;
			int hdr = 0;
			CellInfo info = new CellInfo();
			if ((pgno) > (btreePagecount(pBt)))
			{
				return (int)(sqlite3CorruptError((int)(75785)));
			}

			rc = (int)(getAndInitPage(pBt, (uint)(pgno), pPage, null, (int)(0)));
			if ((rc) != 0)
				return (int)(rc);
			if (((pBt.openFlags & 4) == (0)) && (sqlite3PagerPageRefcount(pPage.pDbPage) != (1 + ((pgno) == (1)))))
			{
				rc = (int)(sqlite3CorruptError((int)(75792)));
				goto cleardatabasepage_out;
			}

			hdr = (int)(pPage.hdrOffset);
			for (i = (int)(0); (i) < (pPage.nCell); i++)
			{
				pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (i)])))));
				if (pPage.leaf == 0)
				{
					rc = (int)(clearDatabasePage(pBt, (uint)(sqlite3Get4byte(pCell)), (int)(1), pnChange));
					if ((rc) != 0)
						goto cleardatabasepage_out;
				}

				pPage.xParseCell(pPage, pCell, &info);
				if (info.nLocal != info.nPayload)
				{
					rc = (int)(clearCellOverflow(pPage, pCell, &info));
				}
				else
				{
					rc = (int)(0);
				}

				if ((rc) != 0)
					goto cleardatabasepage_out;
			}

			if (pPage.leaf == 0)
			{
				rc = (int)(clearDatabasePage(pBt, (uint)(sqlite3Get4byte(&pPage.aData[hdr + 8])), (int)(1), pnChange));
				if ((rc) != 0)
					goto cleardatabasepage_out;
				if ((pPage.intKey) != 0)
					pnChange = null;
			}

			if ((pnChange) != null)
			{
				*pnChange += (long)(pPage.nCell);
			}

			if ((freePageFlag) != 0)
			{
				freePage(pPage, &rc);
			}
			else if ((rc = (int)(sqlite3PagerWrite(pPage.pDbPage))) == (0))
			{
				zeroPage(pPage, (int)(pPage.aData[hdr] | 0x08));
			}

		cleardatabasepage_out:
			; releasePage(pPage);
			return (int)(rc);
		}
		public static uint finalDbSize(BtShared pBt, uint nOrig, uint nFree)
		{
			int nEntry = 0;
			uint nPtrmap = 0;
			uint nFin = 0;
			nEntry = (int)(pBt.usableSize / 5);
			nPtrmap = (uint)((nFree - nOrig + ptrmapPageno(pBt, (uint)(nOrig)) + nEntry) / nEntry);
			nFin = (uint)(nOrig - nFree - nPtrmap);
			if (((nOrig) > ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) && ((nFin) < ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
			{
				nFin--;
			}

			while (((ptrmapPageno((pBt), (uint)(nFin))) == (nFin)) || ((nFin) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
			{
				nFin--;
			}

			return (uint)(nFin);
		}
		public static int freePage2(BtShared pBt, MemPage pMemPage, uint iPage)
		{
			MemPage pTrunk = null;
			uint iTrunk = (uint)(0);
			MemPage pPage1 = pBt.pPage1;
			MemPage pPage;
			int rc = 0;
			uint nFree = 0;
			if (((iPage) < (2)) || ((iPage) > (pBt.nPage)))
			{
				return (int)(sqlite3CorruptError((int)(72577)));
			}

			if ((pMemPage) != null)
			{
				pPage = pMemPage;
				sqlite3PagerRef(pPage.pDbPage);
			}
			else
			{
				pPage = btreePageLookup(pBt, (uint)(iPage));
			}

			rc = (int)(sqlite3PagerWrite(pPage1.pDbPage));
			if ((rc) != 0)
				goto freepage_out;
			nFree = (uint)(sqlite3Get4byte(&pPage1.aData[36]));
			sqlite3Put4byte(&pPage1.aData[36], (uint)(nFree + 1));
			if ((pBt.btsFlags & 0x0004) != 0)
			{
				if (((pPage == null) && ((rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0)))) != 0)) || ((rc = (int)(sqlite3PagerWrite(pPage.pDbPage))) != 0))
				{
					goto freepage_out;
				}

				CRuntime.memset(pPage.aData, (int)(0), (ulong)(pPage.pBt.pageSize));
			}

			if ((pBt.autoVacuum) != 0)
			{
				ptrmapPut(pBt, (uint)(iPage), (byte)(2), (uint)(0), &rc);
				if ((rc) != 0)
					goto freepage_out;
			}

			if (nFree != 0)
			{
				uint nLeaf = 0;
				iTrunk = (uint)(sqlite3Get4byte(&pPage1.aData[32]));
				if ((iTrunk) > (btreePagecount(pBt)))
				{
					rc = (int)(sqlite3CorruptError((int)(72624)));
					goto freepage_out;
				}

				rc = (int)(btreeGetPage(pBt, (uint)(iTrunk), pTrunk, (int)(0)));
				if (rc != 0)
				{
					goto freepage_out;
				}

				nLeaf = (uint)(sqlite3Get4byte(&pTrunk.aData[4]));
				if ((nLeaf) > (pBt.usableSize / 4 - 2))
				{
					rc = (int)(sqlite3CorruptError((int)(72635)));
					goto freepage_out;
				}

				if ((nLeaf) < (pBt.usableSize / 4 - 8))
				{
					rc = (int)(sqlite3PagerWrite(pTrunk.pDbPage));
					if ((rc) == (0))
					{
						sqlite3Put4byte(&pTrunk.aData[4], (uint)(nLeaf + 1));
						sqlite3Put4byte(&pTrunk.aData[8 + nLeaf * 4], (uint)(iPage));
						if (((pPage) != null) && ((pBt.btsFlags & 0x0004) == (0)))
						{
							sqlite3PagerDontWrite(pPage.pDbPage);
						}

						rc = (int)(btreeSetHasContent(pBt, (uint)(iPage)));
					}

					goto freepage_out;
				}
			}

			if (((pPage) == (null)) && (0 != (rc = (int)(btreeGetPage(pBt, (uint)(iPage), pPage, (int)(0))))))
			{
				goto freepage_out;
			}

			rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
			if (rc != 0)
			{
				goto freepage_out;
			}

			sqlite3Put4byte(pPage.aData, (uint)(iTrunk));
			sqlite3Put4byte(&pPage.aData[4], (uint)(0));
			sqlite3Put4byte(&pPage1.aData[32], (uint)(iPage));
		freepage_out:
			; if ((pPage) != null) { pPage.isInit = (byte)(0); }
			releasePage(pPage);
			releasePage(pTrunk);
			return (int)(rc);
		}
		public static void freeTempSpace(BtShared pBt)
		{
			if ((pBt.pTmpSpace) != null)
			{
				pBt.pTmpSpace -= 4;
				sqlite3PageFree(pBt.pTmpSpace);
				pBt.pTmpSpace = null;
			}
		}
		public static int getAndInitPage(BtShared pBt, uint pgno, MemPage ppPage, BtCursor pCur, int bReadOnly)
		{
			int rc = 0;
			PgHdr pDbPage;
			if ((pgno) > (btreePagecount(pBt)))
			{
				rc = (int)(sqlite3CorruptError((int)(68380)));
				goto getAndInitPage_error1;
			}

			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(pgno), pDbPage, (int)(bReadOnly)));
			if ((rc) != 0)
			{
				goto getAndInitPage_error1;
			}

			ppPage = (MemPage)(sqlite3PagerGetExtra(pDbPage));
			if (((ppPage).isInit) == (0))
			{
				btreePageFromDbPage(pDbPage, (uint)(pgno), pBt);
				rc = (int)(btreeInitPage(ppPage));
				if (rc != 0)
				{
					goto getAndInitPage_error2;
				}
			}

			if (((pCur) != null) && ((((ppPage).nCell) < (1)) || ((ppPage).intKey != pCur.curIntKey)))
			{
				rc = (int)(sqlite3CorruptError((int)(68401)));
				goto getAndInitPage_error2;
			}

			return (int)(0);
		getAndInitPage_error2:
			; releasePage(ppPage);
		getAndInitPage_error1:
			; if ((pCur) != null) { pCur.iPage--; pCur.pPage = pCur.apPage[pCur.iPage]; }
			return (int)(rc);
		}
		public static int getOverflowPage(BtShared pBt, uint ovfl, MemPage ppPage, uint* pPgnoNext)
		{
			uint next = (uint)(0);
			MemPage pPage = null;
			int rc = (int)(0);
			if ((pBt.autoVacuum) != 0)
			{
				uint pgno = 0;
				uint iGuess = (uint)(ovfl + 1);
				byte eType = 0;
				while (((ptrmapPageno((pBt), (uint)(iGuess))) == (iGuess)) || ((iGuess) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
				{
					iGuess++;
				}

				if ((iGuess) <= (btreePagecount(pBt)))
				{
					rc = (int)(ptrmapGet(pBt, (uint)(iGuess), &eType, &pgno));
					if ((((rc) == (0)) && ((eType) == (4))) && ((pgno) == (ovfl)))
					{
						next = (uint)(iGuess);
						rc = (int)(101);
					}
				}
			}

			if ((rc) == (0))
			{
				rc = (int)(btreeGetPage(pBt, (uint)(ovfl), pPage, (int)(((ppPage) == (null)) ? 0x02 : 0)));
				if ((rc) == (0))
				{
					next = (uint)(sqlite3Get4byte(pPage.aData));
				}
			}

			*pPgnoNext = (uint)(next);
			if ((ppPage) != null)
			{
				ppPage = pPage;
			}
			else
			{
				releasePage(pPage);
			}

			return (int)((rc) == (101) ? 0 : rc);
		}
		public static int incrVacuumStep(BtShared pBt, uint nFin, uint iLastPg, int bCommit)
		{
			uint nFreeList = 0;
			int rc = 0;
			if ((!((ptrmapPageno((pBt), (uint)(iLastPg))) == (iLastPg))) && (iLastPg != ((sqlite3PendingByte / ((pBt).pageSize)) + 1)))
			{
				byte eType = 0;
				uint iPtrPage = 0;
				nFreeList = (uint)(sqlite3Get4byte(&pBt.pPage1.aData[36]));
				if ((nFreeList) == (0))
				{
					return (int)(101);
				}

				rc = (int)(ptrmapGet(pBt, (uint)(iLastPg), &eType, &iPtrPage));
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((eType) == (1))
				{
					return (int)(sqlite3CorruptError((int)(69993)));
				}

				if ((eType) == (2))
				{
					if ((bCommit) == (0))
					{
						uint iFreePg = 0;
						MemPage pFreePg;
						rc = (int)(allocateBtreePage(pBt, pFreePg, &iFreePg, (uint)(iLastPg), (byte)(1)));
						if (rc != 0)
						{
							return (int)(rc);
						}

						releasePage(pFreePg);
					}
				}
				else
				{
					uint iFreePg = 0;
					MemPage pLastPg;
					byte eMode = (byte)(0);
					uint iNear = (uint)(0);
					rc = (int)(btreeGetPage(pBt, (uint)(iLastPg), pLastPg, (int)(0)));
					if (rc != 0)
					{
						return (int)(rc);
					}

					if ((bCommit) == (0))
					{
						eMode = (byte)(2);
						iNear = (uint)(nFin);
					}

					do
					{
						MemPage pFreePg;
						rc = (int)(allocateBtreePage(pBt, pFreePg, &iFreePg, (uint)(iNear), (byte)(eMode)));
						if (rc != 0)
						{
							releasePage(pLastPg);
							return (int)(rc);
						}

						releasePage(pFreePg);
					}
					while (((bCommit) != 0) && ((iFreePg) > (nFin)));
					rc = (int)(relocatePage(pBt, pLastPg, (byte)(eType), (uint)(iPtrPage), (uint)(iFreePg), (int)(bCommit)));
					releasePage(pLastPg);
					if (rc != 0)
					{
						return (int)(rc);
					}
				}
			}

			if ((bCommit) == (0))
			{
				do
				{
					iLastPg--;
				}
				while (((iLastPg) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1)) || ((ptrmapPageno((pBt), (uint)(iLastPg))) == (iLastPg)));
				pBt.bDoTruncate = (byte)(1);
				pBt.nPage = (uint)(iLastPg);
			}

			return (int)(0);
		}
		public static void invalidateAllOverflowCache(BtShared pBt)
		{
			BtCursor p;
			for (p = pBt.pCursor; p; p = p.pNext)
			{
				(p.curFlags &= (byte)(~0x04));
			}
		}
		public static int lockBtree(BtShared pBt)
		{
			int rc = 0;
			MemPage pPage1;
			uint nPage = 0;
			uint nPageFile = (uint)(0);
			rc = (int)(sqlite3PagerSharedLock(pBt.pPager));
			if (rc != 0)
				return (int)(rc);
			rc = (int)(btreeGetPage(pBt, (uint)(1), pPage1, (int)(0)));
			if (rc != 0)
				return (int)(rc);
			nPage = (uint)(sqlite3Get4byte(28 + pPage1.aData));
			sqlite3PagerPagecount(pBt.pPager, (int*)(&nPageFile));
			if (((nPage) == (0)) || (memcmp(24 + pPage1.aData, 92 + pPage1.aData, (ulong)(4)) != 0))
			{
				nPage = (uint)(nPageFile);
			}

			if ((pBt.db.flags & 0x02000000) != 0)
			{
				nPage = (uint)(0);
			}

			if ((nPage) > (0))
			{
				uint pageSize = 0;
				uint usableSize = 0;
				byte* page1 = pPage1.aData;
				rc = (int)(26);
				if (memcmp(page1, zMagicHeader, (ulong)(16)) != 0)
				{
					goto page1_init_failed;
				}

				if ((page1[18]) > (2))
				{
					pBt.btsFlags |= (ushort)(0x0001);
				}

				if ((page1[19]) > (2))
				{
					goto page1_init_failed;
				}

				if (((page1[19]) == (2)) && ((pBt.btsFlags & 0x0020) == (0)))
				{
					int isOpen = (int)(0);
					rc = (int)(sqlite3PagerOpenWal(pBt.pPager, &isOpen));
					if (rc != 0)
					{
						goto page1_init_failed;
					}
					else
					{
						if ((isOpen) == (0))
						{
							releasePageOne(pPage1);
							return (int)(0);
						}
					}

					rc = (int)(26);
				}
				else
				{
				}

				if (memcmp(&page1[21], "@  ", (ulong)(3)) != 0)
				{
					goto page1_init_failed;
				}

				pageSize = (uint)((page1[16] << 8) | (page1[17] << 16));
				if (((((pageSize - 1) & pageSize) != 0) || ((pageSize) > (65536))) || ((pageSize) <= (256)))
				{
					goto page1_init_failed;
				}

				pBt.btsFlags |= (ushort)(0x0002);
				usableSize = (uint)(pageSize - page1[20]);
				if (pageSize != pBt.pageSize)
				{
					releasePageOne(pPage1);
					pBt.usableSize = (uint)(usableSize);
					pBt.pageSize = (uint)(pageSize);
					freeTempSpace(pBt);
					rc = (int)(sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, (int)(pageSize - usableSize)));
					return (int)(rc);
				}

				if ((nPage) > (nPageFile))
				{
					if ((sqlite3WritableSchema(pBt.db)) == (0))
					{
						rc = (int)(sqlite3CorruptError((int)(69402)));
						goto page1_init_failed;
					}
					else
					{
						nPage = (uint)(nPageFile);
					}
				}

				if ((usableSize) < (480))
				{
					goto page1_init_failed;
				}

				pBt.pageSize = (uint)(pageSize);
				pBt.usableSize = (uint)(usableSize);
				pBt.autoVacuum = (byte)((sqlite3Get4byte(&page1[36 + 4 * 4])) != 0 ? 1 : 0);
				pBt.incrVacuum = (byte)((sqlite3Get4byte(&page1[36 + 7 * 4])) != 0 ? 1 : 0);
			}

			pBt.maxLocal = ((ushort)((pBt.usableSize - 12) * 64 / 255 - 23));
			pBt.minLocal = ((ushort)((pBt.usableSize - 12) * 32 / 255 - 23));
			pBt.maxLeaf = ((ushort)(pBt.usableSize - 35));
			pBt.minLeaf = ((ushort)((pBt.usableSize - 12) * 32 / 255 - 23));
			if ((pBt.maxLocal) > (127))
			{
				pBt.max1bytePayload = (byte)(127);
			}
			else
			{
				pBt.max1bytePayload = ((byte)(pBt.maxLocal));
			}

			pBt.pPage1 = pPage1;
			pBt.nPage = (uint)(nPage);
			return (int)(0);
		page1_init_failed:
			; releasePageOne(pPage1);
			pBt.pPage1 = null;
			return (int)(rc);
		}
		public static int newDatabase(BtShared pBt)
		{
			MemPage pP1;
			byte* data;
			int rc = 0;
			if ((pBt.nPage) > (0))
			{
				return (int)(0);
			}

			pP1 = pBt.pPage1;
			data = pP1.aData;
			rc = (int)(sqlite3PagerWrite(pP1.pDbPage));
			if ((rc) != 0)
				return (int)(rc);
			CRuntime.memcpy(data, zMagicHeader, (ulong)(16 * sizeof(sbyte)));
			data[16] = ((byte)((pBt.pageSize >> 8) & 0xff));
			data[17] = ((byte)((pBt.pageSize >> 16) & 0xff));
			data[18] = (byte)(1);
			data[19] = (byte)(1);
			data[20] = ((byte)(pBt.pageSize - pBt.usableSize));
			data[21] = (byte)(64);
			data[22] = (byte)(32);
			data[23] = (byte)(32);
			CRuntime.memset(&data[24], (int)(0), (ulong)(100 - 24));
			zeroPage(pP1, (int)(0x01 | 0x08 | 0x04));
			pBt.btsFlags |= (ushort)(0x0002);
			sqlite3Put4byte(&data[36 + 4 * 4], (uint)(pBt.autoVacuum));
			sqlite3Put4byte(&data[36 + 7 * 4], (uint)(pBt.incrVacuum));
			pBt.nPage = (uint)(1);
			data[31] = (byte)(1);
			return (int)(0);
		}
		public static int ptrmapGet(BtShared pBt, uint key, byte* pEType, uint* pPgno)
		{
			PgHdr pDbPage;
			int iPtrmap = 0;
			byte* pPtrmap;
			int offset = 0;
			int rc = 0;
			iPtrmap = (int)(ptrmapPageno(pBt, (uint)(key)));
			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(iPtrmap), pDbPage, (int)(0)));
			if (rc != 0)
			{
				return (int)(rc);
			}

			pPtrmap = (byte*)(sqlite3PagerGetData(pDbPage));
			offset = (int)(5 * (key - iPtrmap - 1));
			if ((offset) < (0))
			{
				sqlite3PagerUnref(pDbPage);
				return (int)(sqlite3CorruptError((int)(67235)));
			}

			*pEType = (byte)(pPtrmap[offset]);
			if ((pPgno) != null)
				*pPgno = (uint)(sqlite3Get4byte(&pPtrmap[offset + 1]));
			sqlite3PagerUnref(pDbPage);
			if (((*pEType) < (1)) || ((*pEType) > (5)))
				return (int)(sqlite3CorruptError((int)(67243)));
			return (int)(0);
		}
		public static uint ptrmapPageno(BtShared pBt, uint pgno)
		{
			int nPagesPerMapPage = 0;
			uint iPtrMap = 0; uint ret = 0;
			if ((pgno) < (2))
				return (uint)(0);
			nPagesPerMapPage = (int)((pBt.usableSize / 5) + 1);
			iPtrMap = (uint)((pgno - 2) / nPagesPerMapPage);
			ret = (uint)((iPtrMap * nPagesPerMapPage) + 2);
			if ((ret) == ((sqlite3PendingByte / ((pBt).pageSize)) + 1))
			{
				ret++;
			}

			return (uint)(ret);
		}
		public static void ptrmapPut(BtShared pBt, uint key, byte eType, uint parent, int* pRC)
		{
			PgHdr pDbPage;
			byte* pPtrmap;
			uint iPtrmap = 0;
			int offset = 0;
			int rc = 0;
			if ((*pRC) != 0)
				return;
			if ((key) == (0))
			{
				*pRC = (int)(sqlite3CorruptError((int)(67172)));
				return;
			}

			iPtrmap = (uint)(ptrmapPageno(pBt, (uint)(key)));
			rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(iPtrmap), pDbPage, (int)(0)));
			if (rc != 0)
			{
				*pRC = (int)(rc);
				return;
			}

			if (((sbyte*)(sqlite3PagerGetExtra(pDbPage)))[0] != 0)
			{
				*pRC = (int)(sqlite3CorruptError((int)(67185)));
				goto ptrmap_exit;
			}

			offset = (int)(5 * (key - iPtrmap - 1));
			if ((offset) < (0))
			{
				*pRC = (int)(sqlite3CorruptError((int)(67190)));
				goto ptrmap_exit;
			}

			pPtrmap = (byte*)(sqlite3PagerGetData(pDbPage));
			if ((eType != pPtrmap[offset]) || (sqlite3Get4byte(&pPtrmap[offset + 1]) != parent))
			{
				*pRC = (int)(rc = (int)(sqlite3PagerWrite(pDbPage)));
				if ((rc) == (0))
				{
					pPtrmap[offset] = (byte)(eType);
					sqlite3Put4byte(&pPtrmap[offset + 1], (uint)(parent));
				}
			}

		ptrmap_exit:
			; sqlite3PagerUnref(pDbPage);
		}
		public static int relocatePage(BtShared pBt, MemPage pDbPage, byte eType, uint iPtrPage, uint iFreePage, int isCommit)
		{
			MemPage pPtrPage;
			uint iDbPage = (uint)(pDbPage.pgno);
			Pager pPager = pBt.pPager;
			int rc = 0;
			if ((iDbPage) < (3))
				return (int)(sqlite3CorruptError((int)(69895)));
			rc = (int)(sqlite3PagerMovepage(pPager, pDbPage.pDbPage, (uint)(iFreePage), (int)(isCommit)));
			if (rc != 0)
			{
				return (int)(rc);
			}

			pDbPage.pgno = (uint)(iFreePage);
			if (((eType) == (5)) || ((eType) == (1)))
			{
				rc = (int)(setChildPtrmaps(pDbPage));
				if (rc != 0)
				{
					return (int)(rc);
				}
			}
			else
			{
				uint nextOvfl = (uint)(sqlite3Get4byte(pDbPage.aData));
				if (nextOvfl != 0)
				{
					ptrmapPut(pBt, (uint)(nextOvfl), (byte)(4), (uint)(iFreePage), &rc);
					if (rc != 0)
					{
						return (int)(rc);
					}
				}
			}

			if (eType != 1)
			{
				rc = (int)(btreeGetPage(pBt, (uint)(iPtrPage), pPtrPage, (int)(0)));
				if (rc != 0)
				{
					return (int)(rc);
				}

				rc = (int)(sqlite3PagerWrite(pPtrPage.pDbPage));
				if (rc != 0)
				{
					releasePage(pPtrPage);
					return (int)(rc);
				}

				rc = (int)(modifyPagePointer(pPtrPage, (uint)(iDbPage), (uint)(iFreePage), (byte)(eType)));
				releasePage(pPtrPage);
				if ((rc) == (0))
				{
					ptrmapPut(pBt, (uint)(iFreePage), (byte)(eType), (uint)(iPtrPage), &rc);
				}
			}

			return (int)(rc);
		}
		public static int removeFromSharingList(BtShared pBt)
		{
			sqlite3_mutex* pMainMtx;
			BtShared pList;
			int removed = (int)(0);
			pMainMtx = sqlite3MutexAlloc((int)(2));
			sqlite3_mutex_enter(pMainMtx);
			pBt.nRef--;
			if ((pBt.nRef) <= (0))
			{
				if ((sqlite3SharedCacheList) == (pBt))
				{
					sqlite3SharedCacheList = pBt.pNext;
				}
				else
				{
					pList = sqlite3SharedCacheList;
					while (((pList) != null) && (pList.pNext != pBt))
					{
						pList = pList.pNext;
					}

					if ((pList) != null)
					{
						pList.pNext = pBt.pNext;
					}
				}

				if ((1) != 0)
				{
					sqlite3_mutex_free(pBt.mutex);
				}

				removed = (int)(1);
			}

			sqlite3_mutex_leave(pMainMtx);
			return (int)(removed);
		}
		public static int saveAllCursors(BtShared pBt, uint iRoot, BtCursor pExcept)
		{
			BtCursor p;
			for (p = pBt.pCursor; p; p = p.pNext)
			{
				if ((p != pExcept) && (((0) == (iRoot)) || ((p.pgnoRoot) == (iRoot))))
					break;
			}

			if ((p) != null)
				return (int)(saveCursorsOnList(p, (uint)(iRoot), pExcept));
			if ((pExcept) != null)
				pExcept.curFlags &= (byte)(~0x20);
			return (int)(0);
		}
		public static void unlockBtreeIfUnused(BtShared pBt)
		{
			if (((pBt.inTransaction) == (0)) && (pBt.pPage1 != null))
			{
				MemPage pPage1 = pBt.pPage1;
				pBt.pPage1 = null;
				releasePageOne(pPage1);
			}
		}
	}
}