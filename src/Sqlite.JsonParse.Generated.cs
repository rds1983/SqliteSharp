// Generated by Hebron at 4/3/2022 2:10:11 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int jsonParse(JsonParse* pParse, sqlite3_context pCtx, sbyte* zJson)
		{
			int i = 0;
			CRuntime.memset(pParse, (int)(0), (ulong)(sizeof(JsonParse)));
			if ((zJson) == (null))
				return (int)(1);
			pParse->zJson = zJson;
			i = (int)(jsonParseValue(pParse, (uint)(0)));
			if ((pParse->oom) != 0)
				i = (int)(-1);
			if ((i) > (0))
			{
				while ((jsonIsSpace[(byte)(zJson[i])]) != 0)
				{
					i++;
				}

				if ((zJson[i]) != 0)
					i = (int)(-1);
			}

			if ((i) <= (0))
			{
				if (pCtx != null)
				{
					if ((pParse->oom) != 0)
					{
						sqlite3_result_error_nomem(pCtx);
					}
					else
					{
						sqlite3_result_error(pCtx, "malformed JSON", (int)(-1));
					}
				}

				jsonParseReset(pParse);
				return (int)(1);
			}

			return (int)(0);
		}
		public static int jsonParseAddNode(JsonParse* pParse, uint eType, uint n, sbyte* zContent)
		{
			JsonNode* p;
			if (((pParse->aNode) == (null)) || ((pParse->nNode) >= (pParse->nAlloc)))
			{
				return (int)(jsonParseAddNodeExpand(pParse, (uint)(eType), (uint)(n), zContent));
			}

			p = &pParse->aNode[pParse->nNode];
			p->eType = ((byte)(eType));
			p->jnFlags = (byte)(0);
			p->n = (uint)(n);
			p->u.zJContent = zContent;
			return (int)(pParse->nNode++);
		}
		public static int jsonParseAddNodeExpand(JsonParse* pParse, uint eType, uint n, sbyte* zContent)
		{
			uint nNew = 0;
			JsonNode* pNew;
			if ((pParse->oom) != 0)
				return (int)(-1);
			nNew = (uint)(pParse->nAlloc * 2 + 10);
			pNew = sqlite3_realloc64(pParse->aNode, (ulong)(sizeof(JsonNode) * nNew));
			if ((pNew) == (null))
			{
				pParse->oom = (byte)(1);
				return (int)(-1);
			}

			pParse->nAlloc = (uint)(nNew);
			pParse->aNode = pNew;
			return (int)(jsonParseAddNode(pParse, (uint)(eType), (uint)(n), zContent));
		}
		public static void jsonParseFillInParentage(JsonParse* pParse, uint i, uint iParent)
		{
			JsonNode* pNode = &pParse->aNode[i];
			uint j = 0;
			pParse->aUp[i] = (uint)(iParent);
			switch (pNode->eType)
			{
				case 6:
					{
						for (j = (uint)(1); (j) <= (pNode->n); j += (uint)(jsonNodeSize(pNode + j)))
						{
							jsonParseFillInParentage(pParse, (uint)(i + j), (uint)(i));
						}

						break;
					}

				case 7:
					{
						for (j = (uint)(1); (j) <= (pNode->n); j += (uint)(jsonNodeSize(pNode + j + 1) + 1))
						{
							pParse->aUp[i + j] = (uint)(i);
							jsonParseFillInParentage(pParse, (uint)(i + j + 1), (uint)(i));
						}

						break;
					}

				default:
					{
						break;
					}
			}
		}
		public static int jsonParseFindParents(JsonParse* pParse)
		{
			uint* aUp;
			aUp = pParse->aUp = sqlite3_malloc64((ulong)(sizeof(uint) * pParse->nNode));
			if ((aUp) == (null))
			{
				pParse->oom = (byte)(1);
				return (int)(7);
			}

			jsonParseFillInParentage(pParse, (uint)(0), (uint)(0));
			return (int)(0);
		}
		public static void jsonParseFree(JsonParse* pParse)
		{
			jsonParseReset(pParse);
			sqlite3_free(pParse);
		}
		public static void jsonParseReset(JsonParse* pParse)
		{
			sqlite3_free(pParse->aNode);
			pParse->aNode = null;
			pParse->nNode = (uint)(0);
			pParse->nAlloc = (uint)(0);
			sqlite3_free(pParse->aUp);
			pParse->aUp = null;
		}
		public static int jsonParseValue(JsonParse* pParse, uint i)
		{
			sbyte c = 0;
			uint j = 0;
			int iThis = 0;
			int x = 0;
			JsonNode* pNode;
			sbyte* z = pParse->zJson;
			while ((jsonIsSpace[(byte)(z[i])]) != 0)
			{
				i++;
			}

			if ((c = (sbyte)(z[i])) == (123))
			{
				iThis = (int)(jsonParseAddNode(pParse, (uint)(7), (uint)(0), null));
				if ((iThis) < (0))
					return (int)(-1);
				for (j = (uint)(i + 1); ; j++)
				{
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					if ((++pParse->iDepth) > (2000))
						return (int)(-1);
					x = (int)(jsonParseValue(pParse, (uint)(j)));
					if ((x) < (0))
					{
						pParse->iDepth--;
						if (((x) == (-2)) && ((pParse->nNode) == ((uint)(iThis) + 1)))
							return (int)(j + 1);
						return (int)(-1);
					}

					if ((pParse->oom) != 0)
						return (int)(-1);
					pNode = &pParse->aNode[pParse->nNode - 1];
					if (pNode->eType != 5)
						return (int)(-1);
					pNode->jnFlags |= (byte)(0x40);
					j = (uint)(x);
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					if (z[j] != 58)
						return (int)(-1);
					j++;
					x = (int)(jsonParseValue(pParse, (uint)(j)));
					pParse->iDepth--;
					if ((x) < (0))
						return (int)(-1);
					j = (uint)(x);
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					c = (sbyte)(z[j]);
					if ((c) == (44))
						continue;
					if (c != 125)
						return (int)(-1);
					break;
				}

				pParse->aNode[iThis].n = (uint)(pParse->nNode - (uint)(iThis) - 1);
				return (int)(j + 1);
			}
			else if ((c) == (91))
			{
				iThis = (int)(jsonParseAddNode(pParse, (uint)(6), (uint)(0), null));
				if ((iThis) < (0))
					return (int)(-1);
				CRuntime.memset(&pParse->aNode[iThis].u, (int)(0), (ulong)(sizeof(union JsonNode::(unnamed at sqlite3.c : 193298 : 3)) ) )
        ;
				for (j = (uint)(i + 1); ; j++)
				{
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					if ((++pParse->iDepth) > (2000))
						return (int)(-1);
					x = (int)(jsonParseValue(pParse, (uint)(j)));
					pParse->iDepth--;
					if ((x) < (0))
					{
						if (((x) == (-3)) && ((pParse->nNode) == ((uint)(iThis) + 1)))
							return (int)(j + 1);
						return (int)(-1);
					}

					j = (uint)(x);
					while ((jsonIsSpace[(byte)(z[j])]) != 0)
					{
						j++;
					}

					c = (sbyte)(z[j]);
					if ((c) == (44))
						continue;
					if (c != 93)
						return (int)(-1);
					break;
				}

				pParse->aNode[iThis].n = (uint)(pParse->nNode - (uint)(iThis) - 1);
				return (int)(j + 1);
			}
			else if ((c) == (34))
			{
				byte jnFlags = (byte)(0);
				j = (uint)(i + 1);
				for (; ; )
				{
					c = (sbyte)(z[j]);
					if ((c & ~0x1f) == (0))
					{
						return (int)(-1);
					}

					if ((c) == (92))
					{
						c = (sbyte)(z[++j]);
						if ((((((((((c) == (34)) || ((c) == (92))) || ((c) == (47))) || ((c) == (98))) || ((c) == (102))) || ((c) == (110))) || ((c) == (114))) || ((c) == (116))) || (((c) == (117)) && ((jsonIs4Hex(z + j + 1)) != 0)))
						{
							jnFlags = (byte)(0x02);
						}
						else
						{
							return (int)(-1);
						}
					}
					else if ((c) == (34))
					{
						break;
					}

					j++;
				}

				jsonParseAddNode(pParse, (uint)(5), (uint)(j + 1 - i), &z[i]);
				if (pParse->oom == 0)
					pParse->aNode[pParse->nNode - 1].jnFlags = (byte)(jnFlags);
				return (int)(j + 1);
			}
			else if ((((c) == (110)) && ((CRuntime.strncmp(z + i, "null", (ulong)(4))) == (0))) && ((sqlite3CtypeMap[(byte)(z[i + 4])] & 0x06) == 0))
			{
				jsonParseAddNode(pParse, (uint)(0), (uint)(0), null);
				return (int)(i + 4);
			}
			else if ((((c) == (116)) && ((CRuntime.strncmp(z + i, "true", (ulong)(4))) == (0))) && ((sqlite3CtypeMap[(byte)(z[i + 4])] & 0x06) == 0))
			{
				jsonParseAddNode(pParse, (uint)(1), (uint)(0), null);
				return (int)(i + 4);
			}
			else if ((((c) == (102)) && ((CRuntime.strncmp(z + i, "false", (ulong)(5))) == (0))) && ((sqlite3CtypeMap[(byte)(z[i + 5])] & 0x06) == 0))
			{
				jsonParseAddNode(pParse, (uint)(2), (uint)(0), null);
				return (int)(i + 5);
			}
			else if (((c) == (45)) || (((c) >= (48)) && ((c) <= (57))))
			{
				byte seenDP = (byte)(0);
				byte seenE = (byte)(0);
				if ((c) <= (48))
				{
					j = (uint)((c) == (45) ? i + 1 : i);
					if ((((z[j]) == (48)) && ((z[j + 1]) >= (48))) && ((z[j + 1]) <= (57)))
						return (int)(-1);
				}

				j = (uint)(i + 1);
				for (; ; j++)
				{
					c = (sbyte)(z[j]);
					if (((c) >= (48)) && ((c) <= (57)))
						continue;
					if ((c) == (46))
					{
						if ((z[j - 1]) == (45))
							return (int)(-1);
						if ((seenDP) != 0)
							return (int)(-1);
						seenDP = (byte)(1);
						continue;
					}

					if (((c) == (101)) || ((c) == (69)))
					{
						if ((z[j - 1]) < (48))
							return (int)(-1);
						if ((seenE) != 0)
							return (int)(-1);
						seenDP = (byte)(seenE = (byte)(1));
						c = (sbyte)(z[j + 1]);
						if (((c) == (43)) || ((c) == (45)))
						{
							j++;
							c = (sbyte)(z[j + 1]);
						}

						if (((c) < (48)) || ((c) > (57)))
							return (int)(-1);
						continue;
					}

					break;
				}

				if ((z[j - 1]) < (48))
					return (int)(-1);
				jsonParseAddNode(pParse, (uint)((seenDP) != 0 ? 4 : 3), (uint)(j - i), &z[i]);
				return (int)(j);
			}
			else if ((c) == (125))
			{
				return (int)(-2);
			}
			else if ((c) == (93))
			{
				return (int)(-3);
			}
			else if ((c) == (0))
			{
				return (int)(0);
			}
			else
			{
				return (int)(-1);
			}
		}
	}
}