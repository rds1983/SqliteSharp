// Generated by Hebron at 4/3/2022 2:10:10 AM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace SqliteSharp
{
	unsafe partial class Sqlite
	{
		public static int accessPayload(BtCursor pCur, uint offset, uint amt, byte* pBuf, int eOp)
		{
			byte* aPayload;
			int rc = (int)(0);
			int iIdx = (int)(0);
			MemPage pPage = pCur.pPage;
			BtShared pBt = pCur.pBt;
			if ((pCur.ix) >= (pPage.nCell))
			{
				return (int)(sqlite3CorruptError((int)(71057)));
			}

			getCellInfo(pCur);
			aPayload = pCur.info.pPayload;
			if (((ulong)(aPayload - pPage.aData)) > (pBt.usableSize - pCur.info.nLocal))
			{
				return (int)(sqlite3CorruptError((int)(71072)));
			}

			if ((offset) < (pCur.info.nLocal))
			{
				int a = (int)(amt);
				if ((a + offset) > (pCur.info.nLocal))
				{
					a = (int)(pCur.info.nLocal - offset);
				}

				rc = (int)(copyPayload(&aPayload[offset], pBuf, (int)(a), (int)(eOp), pPage.pDbPage));
				offset = (uint)(0);
				pBuf += a;
				amt -= (uint)(a);
			}
			else
			{
				offset -= (uint)(pCur.info.nLocal);
			}

			if (((rc) == (0)) && ((amt) > (0)))
			{
				uint ovflSize = (uint)(pBt.usableSize - 4);
				uint nextPage = 0;
				nextPage = (uint)(sqlite3Get4byte(&aPayload[pCur.info.nLocal]));
				if ((pCur.curFlags & 0x04) == (0))
				{
					int nOvfl = (int)((pCur.info.nPayload - pCur.info.nLocal + ovflSize - 1) / ovflSize);
					if (((pCur.aOverflow) == (null)) || ((nOvfl * (int)(sizeof(uint))) > (sqlite3MallocSize(pCur.aOverflow))))
					{
						uint* aNew = (uint*)(sqlite3Realloc(pCur.aOverflow, (ulong)(nOvfl * 2 * sizeof(uint))));
						if ((aNew) == (null))
						{
							return (int)(7);
						}
						else
						{
							pCur.aOverflow = aNew;
						}
					}

					CRuntime.memset(pCur.aOverflow, (int)(0), (ulong)(nOvfl * sizeof(uint)));
					pCur.curFlags |= (byte)(0x04);
				}
				else
				{
					if ((pCur.aOverflow[offset / ovflSize]) != 0)
					{
						iIdx = (int)(offset / ovflSize);
						nextPage = (uint)(pCur.aOverflow[iIdx]);
						offset = (uint)(offset % ovflSize);
					}
				}

				while ((nextPage) != 0)
				{
					if ((nextPage) > (pBt.nPage))
						return (int)(sqlite3CorruptError((int)(71134)));
					pCur.aOverflow[iIdx] = (uint)(nextPage);
					if ((offset) >= (ovflSize))
					{
						if ((pCur.aOverflow[iIdx + 1]) != 0)
						{
							nextPage = (uint)(pCur.aOverflow[iIdx + 1]);
						}
						else
						{
							rc = (int)(getOverflowPage(pBt, (uint)(nextPage), null, &nextPage));
						}

						offset -= (uint)(ovflSize);
					}
					else
					{
						int a = (int)(amt);
						if ((a + offset) > (ovflSize))
						{
							a = (int)(ovflSize - offset);
						}

						{
							PgHdr pDbPage;
							rc = (int)(sqlite3PagerGet(pBt.pPager, (uint)(nextPage), pDbPage, (int)((eOp) == (0) ? 0x02 : 0)));
							if ((rc) == (0))
							{
								aPayload = sqlite3PagerGetData(pDbPage);
								nextPage = (uint)(sqlite3Get4byte(aPayload));
								rc = (int)(copyPayload(&aPayload[offset + 4], pBuf, (int)(a), (int)(eOp), pDbPage));
								sqlite3PagerUnref(pDbPage);
								offset = (uint)(0);
							}
						}

						amt -= (uint)(a);
						if ((amt) == (0))
							return (int)(rc);
						pBuf += a;
					}

					if ((rc) != 0)
						break;
					iIdx++;
				}
			}

			if (((rc) == (0)) && ((amt) > (0)))
			{
				return (int)(sqlite3CorruptError((int)(71219)));
			}

			return (int)(rc);
		}
		public static int accessPayloadChecked(BtCursor pCur, uint offset, uint amt, void* pBuf)
		{
			int rc = 0;
			if ((pCur.eState) == (1))
			{
				return (int)(4);
			}

			rc = (int)(btreeRestoreCursorPosition(pCur));
			return (int)((rc) != 0 ? rc : accessPayload(pCur, (uint)(offset), (uint)(amt), pBuf, (int)(0)));
		}
		public static int anotherValidCursor(BtCursor pCur)
		{
			BtCursor pOther;
			for (pOther = pCur.pBt.pCursor; pOther; pOther = pOther.pNext)
			{
				if (((pOther != pCur) && ((pOther.eState) == (0))) && ((pOther.pPage) == (pCur.pPage)))
				{
					return (int)(sqlite3CorruptError((int)(74730)));
				}
			}

			return (int)(0);
		}
		public static int balance(BtCursor pCur)
		{
			int rc = (int)(0);
			int nMin = (int)(pCur.pBt.usableSize * 2 / 3);
			byte* aBalanceQuickSpace = stackalloc byte[13];
			byte* pFree = null;
			do
			{
				int iPage = 0;
				MemPage pPage = pCur.pPage;
				if (((pPage.nFree) < (0)) && ((btreeComputeFreeSpace(pPage)) != 0))
					break;
				if (((pPage.nOverflow) == (0)) && ((pPage.nFree) <= (nMin)))
				{
					break;
				}
				else if ((iPage = (int)(pCur.iPage)) == (0))
				{
					if (((pPage.nOverflow) != 0) && ((rc = (int)(anotherValidCursor(pCur))) == (0)))
					{
						rc = (int)(balance_deeper(pPage, pCur.apPage[1]));
						if ((rc) == (0))
						{
							pCur.iPage = (sbyte)(1);
							pCur.ix = (ushort)(0);
							pCur.aiIdx[0] = (ushort)(0);
							pCur.apPage[0] = pPage;
							pCur.pPage = pCur.apPage[1];
						}
					}
					else
					{
						break;
					}
				}
				else
				{
					MemPage pParent = pCur.apPage[iPage - 1];
					int iIdx = (int)(pCur.aiIdx[iPage - 1]);
					rc = (int)(sqlite3PagerWrite(pParent.pDbPage));
					if (((rc) == (0)) && ((pParent.nFree) < (0)))
					{
						rc = (int)(btreeComputeFreeSpace(pParent));
					}

					if ((rc) == (0))
					{
						if ((((((pPage.intKeyLeaf) != 0) && ((pPage.nOverflow) == (1))) && ((pPage.aiOvfl[0]) == (pPage.nCell))) && (pParent.pgno != 1)) && ((pParent.nCell) == (iIdx)))
						{
							rc = (int)(balance_quick(pParent, pPage, aBalanceQuickSpace));
						}
						else
						{
							byte* pSpace = sqlite3PageMalloc((int)(pCur.pBt.pageSize));
							rc = (int)(balance_nonroot(pParent, (int)(iIdx), pSpace, ((iPage) == (1) ? 1 : 0), (int)(pCur.hints & 0x00000001)));
							if ((pFree) != null)
							{
								sqlite3PageFree(pFree);
							}

							pFree = pSpace;
						}
					}

					pPage.nOverflow = (byte)(0);
					releasePage(pPage);
					pCur.iPage--;
					pCur.pPage = pCur.apPage[pCur.iPage];
				}
			}
			while ((rc) == (0));
			if ((pFree) != null)
			{
				sqlite3PageFree(pFree);
			}

			return (int)(rc);
		}
		public static int btreeMoveto(BtCursor pCur, void* pKey, long nKey, int bias, int* pRes)
		{
			int rc = 0;
			UnpackedRecord pIdxKey;
			if ((pKey) != null)
			{
				KeyInfo pKeyInfo = pCur.pKeyInfo;
				pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
				if ((pIdxKey) == (null))
					return (int)(7);
				sqlite3VdbeRecordUnpack(pKeyInfo, (int)(nKey), pKey, pIdxKey);
				if (((pIdxKey.nField) == (0)) || ((pIdxKey.nField) > (pKeyInfo.nAllField)))
				{
					rc = (int)(sqlite3CorruptError((int)(66991)));
				}
				else
				{
					rc = (int)(sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes));
				}

				sqlite3DbFree(pCur.pKeyInfo.db, pIdxKey);
			}
			else
			{
				pIdxKey = null;
				rc = (int)(sqlite3BtreeTableMoveto(pCur, (long)(nKey), (int)(bias), pRes));
			}

			return (int)(rc);
		}
		public static int btreeNext(BtCursor pCur)
		{
			int rc = 0;
			int idx = 0;
			MemPage pPage;
			if (pCur.eState != 0)
			{
				rc = (int)((pCur.eState) >= (3) ? btreeRestoreCursorPosition(pCur) : 0);
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((1) == (pCur.eState))
				{
					return (int)(101);
				}

				if ((pCur.eState) == (2))
				{
					pCur.eState = (byte)(0);
					if ((pCur.skipNext) > (0))
						return (int)(0);
				}
			}

			pPage = pCur.pPage;
			idx = (int)(++pCur.ix);
			if ((pPage.isInit == 0) || ((sqlite3FaultSim((int)(412))) != 0))
			{
				return (int)(sqlite3CorruptError((int)(72086)));
			}

			if ((idx) >= (pPage.nCell))
			{
				if (pPage.leaf == 0)
				{
					rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]))));
					if ((rc) != 0)
						return (int)(rc);
					return (int)(moveToLeftmost(pCur));
				}

				do
				{
					if ((pCur.iPage) == (0))
					{
						pCur.eState = (byte)(1);
						return (int)(101);
					}

					moveToParent(pCur);
					pPage = pCur.pPage;
				}
				while ((pCur.ix) >= (pPage.nCell));
				if ((pPage.intKey) != 0)
				{
					return (int)(sqlite3BtreeNext(pCur, (int)(0)));
				}
				else
				{
					return (int)(0);
				}
			}

			if ((pPage.leaf) != 0)
			{
				return (int)(0);
			}
			else
			{
				return (int)(moveToLeftmost(pCur));
			}
		}
		public static int btreeOverwriteCell(BtCursor pCur, BtreePayload pX)
		{
			int iOffset = 0;
			int nTotal = (int)(pX.nData + pX.nZero);
			int rc = 0;
			MemPage pPage = pCur.pPage;
			BtShared pBt;
			uint ovflPgno = 0;
			uint ovflPageSize = 0;
			if (((pCur.info.pPayload + pCur.info.nLocal) > (pPage.aDataEnd)) || ((pCur.info.pPayload) < (pPage.aData + pPage.cellOffset)))
			{
				return (int)(sqlite3CorruptError((int)(74927)));
			}

			rc = (int)(btreeOverwriteContent(pPage, pCur.info.pPayload, pX, (int)(0), (int)(pCur.info.nLocal)));
			if ((rc) != 0)
				return (int)(rc);
			if ((pCur.info.nLocal) == (nTotal))
				return (int)(0);
			iOffset = (int)(pCur.info.nLocal);
			ovflPgno = (uint)(sqlite3Get4byte(pCur.info.pPayload + iOffset));
			pBt = pPage.pBt;
			ovflPageSize = (uint)(pBt.usableSize - 4);
			do
			{
				rc = (int)(btreeGetPage(pBt, (uint)(ovflPgno), pPage, (int)(0)));
				if ((rc) != 0)
					return (int)(rc);
				if ((sqlite3PagerPageRefcount(pPage.pDbPage) != 1) || ((pPage.isInit) != 0))
				{
					rc = (int)(sqlite3CorruptError((int)(74946)));
				}
				else
				{
					if ((iOffset + ovflPageSize) < ((uint)(nTotal)))
					{
						ovflPgno = (uint)(sqlite3Get4byte(pPage.aData));
					}
					else
					{
						ovflPageSize = (uint)(nTotal - iOffset);
					}

					rc = (int)(btreeOverwriteContent(pPage, pPage.aData + 4, pX, (int)(iOffset), (int)(ovflPageSize)));
				}

				sqlite3PagerUnref(pPage.pDbPage);
				if ((rc) != 0)
					return (int)(rc);
				iOffset += (int)(ovflPageSize);
			}
			while ((iOffset) < (nTotal));
			return (int)(0);
		}
		public static int btreePrevious(BtCursor pCur)
		{
			int rc = 0;
			MemPage pPage;
			if (pCur.eState != 0)
			{
				rc = (int)((pCur.eState) >= (3) ? btreeRestoreCursorPosition(pCur) : 0);
				if (rc != 0)
				{
					return (int)(rc);
				}

				if ((1) == (pCur.eState))
				{
					return (int)(101);
				}

				if ((2) == (pCur.eState))
				{
					pCur.eState = (byte)(0);
					if ((pCur.skipNext) < (0))
						return (int)(0);
				}
			}

			pPage = pCur.pPage;
			if (pPage.leaf == 0)
			{
				int idx = (int)(pCur.ix);
				rc = (int)(moveToChild(pCur, (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))))))));
				if ((rc) != 0)
					return (int)(rc);
				rc = (int)(moveToRightmost(pCur));
			}
			else
			{
				while ((pCur.ix) == (0))
				{
					if ((pCur.iPage) == (0))
					{
						pCur.eState = (byte)(1);
						return (int)(101);
					}

					moveToParent(pCur);
				}

				pCur.ix--;
				pPage = pCur.pPage;
				if (((pPage.intKey) != 0) && (pPage.leaf == 0))
				{
					rc = (int)(sqlite3BtreePrevious(pCur, (int)(0)));
				}
				else
				{
					rc = (int)(0);
				}
			}

			return (int)(rc);
		}
		public static void btreeReleaseAllCursorPages(BtCursor pCur)
		{
			int i = 0;
			if ((pCur.iPage) >= (0))
			{
				for (i = (int)(0); (i) < (pCur.iPage); i++)
				{
					releasePageNotNull(pCur.apPage[i]);
				}

				releasePageNotNull(pCur.pPage);
				pCur.iPage = (sbyte)(-1);
			}
		}
		public static int btreeRestoreCursorPosition(BtCursor pCur)
		{
			int rc = 0;
			int skipNext = (int)(0);
			if ((pCur.eState) == (4))
			{
				return (int)(pCur.skipNext);
			}

			pCur.eState = (byte)(1);
			if ((sqlite3FaultSim((int)(410))) != 0)
			{
				rc = (int)(10);
			}
			else
			{
				rc = (int)(btreeMoveto(pCur, pCur.pKey, (long)(pCur.nKey), (int)(0), &skipNext));
			}

			if ((rc) == (0))
			{
				sqlite3_free(pCur.pKey);
				pCur.pKey = null;
				if ((skipNext) != 0)
					pCur.skipNext = (int)(skipNext);
				if (((pCur.skipNext) != 0) && ((pCur.eState) == (0)))
				{
					pCur.eState = (byte)(2);
				}
			}

			return (int)(rc);
		}
		public static void getCellInfo(BtCursor pCur)
		{
			if ((pCur.info.nSize) == (0))
			{
				pCur.curFlags |= (byte)(0x02);
				btreeParseCell(pCur.pPage, (int)(pCur.ix), &pCur.info);
			}
			else
			{
			}
		}
		public static int moveToChild(BtCursor pCur, uint newPgno)
		{
			BtShared pBt = pCur.pBt;
			if ((pCur.iPage) >= (20 - 1))
			{
				return (int)(sqlite3CorruptError((int)(71358)));
			}

			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x02 | 0x04));
			pCur.aiIdx[pCur.iPage] = (ushort)(pCur.ix);
			pCur.apPage[pCur.iPage] = pCur.pPage;
			pCur.ix = (ushort)(0);
			pCur.iPage++;
			return (int)(getAndInitPage(pBt, (uint)(newPgno), pCur.pPage, pCur, (int)(pCur.curPagerFlags)));
		}
		public static int moveToLeftmost(BtCursor pCur)
		{
			uint pgno = 0;
			int rc = (int)(0);
			MemPage pPage;
			while (((rc) == (0)) && ((pPage = pCur.pPage).leaf == 0))
			{
				pgno = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (pCur.ix)])))))));
				rc = (int)(moveToChild(pCur, (uint)(pgno)));
			}

			return (int)(rc);
		}
		public static void moveToParent(BtCursor pCur)
		{
			MemPage pLeaf;
			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x02 | 0x04));
			pCur.ix = (ushort)(pCur.aiIdx[pCur.iPage - 1]);
			pLeaf = pCur.pPage;
			pCur.pPage = pCur.apPage[--pCur.iPage];
			releasePageNotNull(pLeaf);
		}
		public static int moveToRightmost(BtCursor pCur)
		{
			uint pgno = 0;
			int rc = (int)(0);
			MemPage pPage = null;
			while ((pPage = pCur.pPage).leaf == 0)
			{
				pgno = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				pCur.ix = (ushort)(pPage.nCell);
				rc = (int)(moveToChild(pCur, (uint)(pgno)));
				if ((rc) != 0)
					return (int)(rc);
			}

			pCur.ix = (ushort)(pPage.nCell - 1);
			return (int)(0);
		}
		public static int moveToRoot(BtCursor pCur)
		{
			MemPage pRoot;
			int rc = (int)(0);
			if ((pCur.iPage) >= (0))
			{
				if ((pCur.iPage) != 0)
				{
					releasePageNotNull(pCur.pPage);
					while ((--pCur.iPage) != 0)
					{
						releasePageNotNull(pCur.apPage[pCur.iPage]);
					}

					pRoot = pCur.pPage = pCur.apPage[0];
					goto skip_init;
				}
			}
			else if ((pCur.pgnoRoot) == (0))
			{
				pCur.eState = (byte)(1);
				return (int)(16);
			}
			else
			{
				if ((pCur.eState) >= (3))
				{
					if ((pCur.eState) == (4))
					{
						return (int)(pCur.skipNext);
					}

					sqlite3BtreeClearCursor(pCur);
				}

				rc = (int)(getAndInitPage(pCur.pBtree.pBt, (uint)(pCur.pgnoRoot), pCur.pPage, null, (int)(pCur.curPagerFlags)));
				if (rc != 0)
				{
					pCur.eState = (byte)(1);
					return (int)(rc);
				}

				pCur.iPage = (sbyte)(0);
				pCur.curIntKey = (byte)(pCur.pPage.intKey);
			}

			pRoot = pCur.pPage;
			if (((pRoot.isInit) == (0)) || (((pCur.pKeyInfo) == (null)) != pRoot.intKey))
			{
				return (int)(sqlite3CorruptError((int)(71496)));
			}

		skip_init:
			; pCur.ix = (ushort)(0);
			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x08 | 0x02 | 0x04));
			if ((pRoot.nCell) > (0))
			{
				pCur.eState = (byte)(0);
			}
			else if (pRoot.leaf == 0)
			{
				uint subpage = 0;
				if (pRoot.pgno != 1)
					return (int)(sqlite3CorruptError((int)(71508)));
				subpage = (uint)(sqlite3Get4byte(&pRoot.aData[pRoot.hdrOffset + 8]));
				pCur.eState = (byte)(0);
				rc = (int)(moveToChild(pCur, (uint)(subpage)));
			}
			else
			{
				pCur.eState = (byte)(1);
				rc = (int)(16);
			}

			return (int)(rc);
		}
		public static int saveCursorKey(BtCursor pCur)
		{
			int rc = (int)(0);
			if ((pCur.curIntKey) != 0)
			{
				pCur.nKey = (long)(sqlite3BtreeIntegerKey(pCur));
			}
			else
			{
				void* pKey;
				pCur.nKey = (long)(sqlite3BtreePayloadSize(pCur));
				pKey = sqlite3Malloc((ulong)(pCur.nKey + 9 + 8));
				if ((pKey) != null)
				{
					rc = (int)(sqlite3BtreePayload(pCur, (uint)(0), (uint)((int)(pCur.nKey)), pKey));
					if ((rc) == (0))
					{
						CRuntime.memset(((byte*)(pKey)) + pCur.nKey, (int)(0), (ulong)(9 + 8));
						pCur.pKey = pKey;
					}
					else
					{
						sqlite3_free(pKey);
					}
				}
				else
				{
					rc = (int)(7);
				}
			}

			return (int)(rc);
		}
		public static int saveCursorPosition(BtCursor pCur)
		{
			int rc = 0;
			if ((pCur.curFlags & 0x40) != 0)
			{
				return (int)(19 | (11 << 8));
			}

			if ((pCur.eState) == (2))
			{
				pCur.eState = (byte)(0);
			}
			else
			{
				pCur.skipNext = (int)(0);
			}

			rc = (int)(saveCursorKey(pCur));
			if ((rc) == (0))
			{
				btreeReleaseAllCursorPages(pCur);
				pCur.eState = (byte)(3);
			}

			pCur.curFlags &= (byte)(~(0x02 | 0x04 | 0x08));
			return (int)(rc);
		}
		public static int saveCursorsOnList(BtCursor p, uint iRoot, BtCursor pExcept)
		{
			do
			{
				if ((p != pExcept) && (((0) == (iRoot)) || ((p.pgnoRoot) == (iRoot))))
				{
					if (((p.eState) == (0)) || ((p.eState) == (2)))
					{
						int rc = (int)(saveCursorPosition(p));
						if (0 != rc)
						{
							return (int)(rc);
						}
					}
					else
					{
						btreeReleaseAllCursorPages(p);
					}
				}

				p = p.pNext;
			}
			while ((p) != null);
			return (int)(0);
		}
		public static void sqlite3BtreeClearCursor(BtCursor pCur)
		{
			sqlite3_free(pCur.pKey);
			pCur.pKey = null;
			pCur.eState = (byte)(1);
		}
		public static int sqlite3BtreeClearTableOfCursor(BtCursor pCur)
		{
			return (int)(sqlite3BtreeClearTable(pCur.pBtree, (int)(pCur.pgnoRoot), null));
		}
		public static int sqlite3BtreeCloseCursor(BtCursor pCur)
		{
			Btree pBtree = pCur.pBtree;
			if ((pBtree) != null)
			{
				BtShared pBt = pCur.pBt;
				sqlite3BtreeEnter(pBtree);
				if ((pBt.pCursor) == (pCur))
				{
					pBt.pCursor = pCur.pNext;
				}
				else
				{
					BtCursor pPrev = pBt.pCursor;
					do
					{
						if ((pPrev.pNext) == (pCur))
						{
							pPrev.pNext = pCur.pNext;
							break;
						}

						pPrev = pPrev.pNext;
					}
					while ((pPrev) != null);
				}

				btreeReleaseAllCursorPages(pCur);
				unlockBtreeIfUnused(pBt);
				sqlite3_free(pCur.aOverflow);
				sqlite3_free(pCur.pKey);
				if (((pBt.openFlags & 4) != 0) && ((pBt.pCursor) == (null)))
				{
					sqlite3BtreeClose(pBtree);
				}
				else
				{
					sqlite3BtreeLeave(pBtree);
				}

				pCur.pBtree = null;
			}

			return (int)(0);
		}
		public static int sqlite3BtreeCursorHasHint(BtCursor pCsr, uint mask)
		{
			return (int)((pCsr.hints & mask) != 0);
		}
		public static int sqlite3BtreeCursorHasMoved(BtCursor pCur)
		{
			return (int)(0 != *(byte*)(pCur));
		}
		public static void sqlite3BtreeCursorHintFlags(BtCursor pCur, uint x)
		{
			pCur.hints = (byte)(x);
		}
		public static int sqlite3BtreeCursorIsValidNN(BtCursor pCur)
		{
			return ((pCur.eState) == (0) ? 1 : 0);
		}
		public static void sqlite3BtreeCursorPin(BtCursor pCur)
		{
			pCur.curFlags |= (byte)(0x40);
		}
		public static int sqlite3BtreeCursorRestore(BtCursor pCur, int* pDifferentRow)
		{
			int rc = 0;
			rc = (int)((pCur.eState) >= (3) ? btreeRestoreCursorPosition(pCur) : 0);
			if ((rc) != 0)
			{
				*pDifferentRow = (int)(1);
				return (int)(rc);
			}

			if (pCur.eState != 0)
			{
				*pDifferentRow = (int)(1);
			}
			else
			{
				*pDifferentRow = (int)(0);
			}

			return (int)(0);
		}
		public static void sqlite3BtreeCursorUnpin(BtCursor pCur)
		{
			pCur.curFlags &= (byte)(~0x40);
		}
		public static void sqlite3BtreeCursorZero(BtCursor p)
		{
			CRuntime.memset(p, (int)(0), ((ulong)((0).pBt)));
		}
		public static int sqlite3BtreeDelete(BtCursor pCur, byte flags)
		{
			Btree p = pCur.pBtree;
			BtShared pBt = p.pBt;
			int rc = 0;
			MemPage pPage;
			byte* pCell;
			int iCellIdx = 0;
			int iCellDepth = 0;
			CellInfo info = new CellInfo();
			byte bPreserve = 0;
			if (pCur.eState != 0)
			{
				if ((pCur.eState) >= (3))
				{
					rc = (int)(btreeRestoreCursorPosition(pCur));
					if (((rc) != 0) || (pCur.eState != 0))
						return (int)(rc);
				}
				else
				{
					return (int)(sqlite3CorruptError((int)(75436)));
				}
			}

			iCellDepth = (int)(pCur.iPage);
			iCellIdx = (int)(pCur.ix);
			pPage = pCur.pPage;
			if ((pPage.nCell) <= (iCellIdx))
			{
				return (int)(sqlite3CorruptError((int)(75445)));
			}

			pCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (iCellIdx)])))));
			if (((pPage.nFree) < (0)) && ((btreeComputeFreeSpace(pPage)) != 0))
			{
				return (int)(sqlite3CorruptError((int)(75449)));
			}

			bPreserve = (byte)((flags & 0x02) != 0);
			if ((bPreserve) != 0)
			{
				if (((pPage.leaf == 0) || ((pPage.nFree + cellSizePtr(pPage, pCell) + 2) > ((int)(pBt.usableSize * 2 / 3)))) || ((pPage.nCell) == (1)))
				{
					rc = (int)(saveCursorKey(pCur));
					if ((rc) != 0)
						return (int)(rc);
				}
				else
				{
					bPreserve = (byte)(2);
				}
			}

			if (pPage.leaf == 0)
			{
				rc = (int)(sqlite3BtreePrevious(pCur, (int)(0)));
				if ((rc) != 0)
					return (int)(rc);
			}

			if ((pCur.curFlags & 0x20) != 0)
			{
				rc = (int)(saveAllCursors(pBt, (uint)(pCur.pgnoRoot), pCur));
				if ((rc) != 0)
					return (int)(rc);
			}

			if (((pCur.pKeyInfo) == (null)) && ((p.hasIncrblobCur) != 0))
			{
				invalidateIncrblobCursors(p, (uint)(pCur.pgnoRoot), (long)(pCur.info.nKey), (int)(0));
			}

			rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
			if ((rc) != 0)
				return (int)(rc);
			pPage.xParseCell(pPage, pCell, &info);
			if (info.nLocal != info.nPayload)
			{
				rc = (int)(clearCellOverflow(pPage, pCell, &info));
			}
			else
			{
				rc = (int)(0);
			}

			dropCell(pPage, (int)(iCellIdx), (int)(info.nSize), &rc);
			if ((rc) != 0)
				return (int)(rc);
			if (pPage.leaf == 0)
			{
				MemPage pLeaf = pCur.pPage;
				int nCell = 0;
				uint n = 0;
				byte* pTmp;
				if ((pLeaf.nFree) < (0))
				{
					rc = (int)(btreeComputeFreeSpace(pLeaf));
					if ((rc) != 0)
						return (int)(rc);
				}

				if ((iCellDepth) < (pCur.iPage - 1))
				{
					n = (uint)(pCur.apPage[iCellDepth + 1].pgno);
				}
				else
				{
					n = (uint)(pCur.pPage.pgno);
				}

				pCell = ((pLeaf).aData + ((pLeaf).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pLeaf).aCellIdx[2 * (pLeaf.nCell - 1)])))));
				if ((pCell) < (&pLeaf.aData[4]))
					return (int)(sqlite3CorruptError((int)(75539)));
				nCell = (int)(pLeaf.xCellSize(pLeaf, pCell));
				pTmp = pBt.pTmpSpace;
				rc = (int)(sqlite3PagerWrite(pLeaf.pDbPage));
				if ((rc) == (0))
				{
					insertCell(pPage, (int)(iCellIdx), pCell - 4, (int)(nCell + 4), pTmp, (uint)(n), &rc);
				}

				dropCell(pLeaf, (int)(pLeaf.nCell - 1), (int)(nCell), &rc);
				if ((rc) != 0)
					return (int)(rc);
			}

			rc = (int)(balance(pCur));
			if (((rc) == (0)) && ((pCur.iPage) > (iCellDepth)))
			{
				releasePageNotNull(pCur.pPage);
				pCur.iPage--;
				while ((pCur.iPage) > (iCellDepth))
				{
					releasePage(pCur.apPage[pCur.iPage--]);
				}

				pCur.pPage = pCur.apPage[pCur.iPage];
				rc = (int)(balance(pCur));
			}

			if ((rc) == (0))
			{
				if ((bPreserve) > (1))
				{
					pCur.eState = (byte)(2);
					if ((iCellIdx) >= (pPage.nCell))
					{
						pCur.skipNext = (int)(-1);
						pCur.ix = (ushort)(pPage.nCell - 1);
					}
					else
					{
						pCur.skipNext = (int)(1);
					}
				}
				else
				{
					rc = (int)(moveToRoot(pCur));
					if ((bPreserve) != 0)
					{
						btreeReleaseAllCursorPages(pCur);
						pCur.eState = (byte)(3);
					}

					if ((rc) == (16))
						rc = (int)(0);
				}
			}

			return (int)(rc);
		}
		public static void sqlite3BtreeEnterCursor(BtCursor pCur)
		{
			sqlite3BtreeEnter(pCur.pBtree);
		}
		public static int sqlite3BtreeEof(BtCursor pCur)
		{
			return (int)(0 != pCur.eState);
		}
		public static int sqlite3BtreeFirst(BtCursor pCur, int* pRes)
		{
			int rc = 0;
			rc = (int)(moveToRoot(pCur));
			if ((rc) == (0))
			{
				*pRes = (int)(0);
				rc = (int)(moveToLeftmost(pCur));
			}
			else if ((rc) == (16))
			{
				*pRes = (int)(1);
				rc = (int)(0);
			}

			return (int)(rc);
		}
		public static void sqlite3BtreeIncrblobCursor(BtCursor pCur)
		{
			pCur.curFlags |= (byte)(0x10);
			pCur.pBtree.hasIncrblobCur = (byte)(1);
		}
		public static int sqlite3BtreeIndexMoveto(BtCursor pCur, UnpackedRecord pIdxKey, int* pRes)
		{
			int rc = 0;
			delegate157 xRecordCompare;
			xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
			pIdxKey.errCode = (byte)(0);
			rc = (int)(moveToRoot(pCur));
			if ((rc) != 0)
			{
				if ((rc) == (16))
				{
					*pRes = (int)(-1);
					return (int)(0);
				}

				return (int)(rc);
			}

			for (; ; )
			{
				int lwr = 0;
				int upr = 0;
				int idx = 0;
				int c = 0;
				uint chldPg = 0;
				MemPage pPage = pCur.pPage;
				byte* pCell;
				lwr = (int)(0);
				upr = (int)(pPage.nCell - 1);
				idx = (int)(upr >> 1);
				for (; ; )
				{
					int nCell = 0;
					pCell = ((pPage).aDataOfst + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))));
					nCell = (int)(pCell[0]);
					if ((nCell) <= (pPage.max1bytePayload))
					{
						c = (int)(xRecordCompare((int)(nCell), (void*)(&pCell[1]), pIdxKey));
					}
					else if (((pCell[1] & 0x80) == 0) && ((nCell = (int)(((nCell & 0x7f) << 7) + pCell[1])) <= (pPage.maxLocal)))
					{
						c = (int)(xRecordCompare((int)(nCell), (void*)(&pCell[2]), pIdxKey));
					}
					else
					{
						void* pCellKey;
						byte* pCellBody = pCell - pPage.childPtrSize;
						int nOverrun = (int)(18);
						pPage.xParseCell(pPage, pCellBody, &pCur.info);
						nCell = ((int)(pCur.info.nKey));
						if (((nCell) < (2)) || ((nCell / pCur.pBt.usableSize) > (pCur.pBt.nPage)))
						{
							rc = (int)(sqlite3CorruptError((int)(71931)));
							goto moveto_index_finish;
						}

						pCellKey = sqlite3Malloc((ulong)(nCell + nOverrun));
						if ((pCellKey) == (null))
						{
							rc = (int)(7);
							goto moveto_index_finish;
						}

						pCur.ix = ((ushort)(idx));
						rc = (int)(accessPayload(pCur, (uint)(0), (uint)(nCell), (byte*)(pCellKey), (int)(0)));
						CRuntime.memset(((byte*)(pCellKey)) + nCell, (int)(0), (ulong)(nOverrun));
						pCur.curFlags &= (byte)(~0x04);
						if ((rc) != 0)
						{
							sqlite3_free(pCellKey);
							goto moveto_index_finish;
						}

						c = (int)(sqlite3VdbeRecordCompare((int)(nCell), pCellKey, pIdxKey));
						sqlite3_free(pCellKey);
					}

					if ((c) < (0))
					{
						lwr = (int)(idx + 1);
					}
					else if ((c) > (0))
					{
						upr = (int)(idx - 1);
					}
					else
					{
						*pRes = (int)(0);
						rc = (int)(0);
						pCur.ix = ((ushort)(idx));
						if ((pIdxKey.errCode) != 0)
							rc = (int)(sqlite3CorruptError((int)(71963)));
						goto moveto_index_finish;
					}

					if ((lwr) > (upr))
						break;
					idx = (int)((lwr + upr) >> 1);
				}

				if ((pPage.leaf) != 0)
				{
					pCur.ix = ((ushort)(idx));
					*pRes = (int)(c);
					rc = (int)(0);
					goto moveto_index_finish;
				}

				if ((lwr) >= (pPage.nCell))
				{
					chldPg = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				}
				else
				{
					chldPg = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (lwr)])))))));
				}

				pCur.ix = ((ushort)(lwr));
				rc = (int)(moveToChild(pCur, (uint)(chldPg)));
				if ((rc) != 0)
					break;
			}

		moveto_index_finish:
			; pCur.info.nSize = (ushort)(0);
			return (int)(rc);
		}
		public static int sqlite3BtreeInsert(BtCursor pCur, BtreePayload pX, int flags, int seekResult)
		{
			int rc = 0;
			int loc = (int)(seekResult);
			int szNew = (int)(0);
			int idx = 0;
			MemPage pPage;
			Btree p = pCur.pBtree;
			BtShared pBt = p.pBt;
			byte* oldCell;
			byte* newCell = null;
			if ((pCur.curFlags & 0x20) != 0)
			{
				rc = (int)(saveAllCursors(pBt, (uint)(pCur.pgnoRoot), pCur));
				if ((rc) != 0)
					return (int)(rc);
				if (((loc) != 0) && ((pCur.iPage) < (0)))
				{
					return (int)(sqlite3CorruptError((int)(75033)));
				}
			}

			if ((pCur.eState) >= (3))
			{
				rc = (int)(moveToRoot(pCur));
				if (((rc) != 0) && (rc != 16))
					return (int)(rc);
			}

			if ((pCur.pKeyInfo) == (null))
			{
				if ((p.hasIncrblobCur) != 0)
				{
					invalidateIncrblobCursors(p, (uint)(pCur.pgnoRoot), (long)(pX.nKey), (int)(0));
				}

				if (((pCur.curFlags & 0x02) != 0) && ((pX.nKey) == (pCur.info.nKey)))
				{
					if ((pCur.info.nSize != 0) && ((pCur.info.nPayload) == ((uint)(pX.nData) + pX.nZero)))
					{
						return (int)(btreeOverwriteCell(pCur, pX));
					}
				}
				else if ((loc) == (0))
				{
					rc = (int)(sqlite3BtreeTableMoveto(pCur, (long)(pX.nKey), (int)((flags & 0x08) != 0), &loc));
					if ((rc) != 0)
						return (int)(rc);
				}
			}
			else
			{
				if (((loc) == (0)) && ((flags & 0x02) == (0)))
				{
					if ((pX.nMem) != 0)
					{
						UnpackedRecord r = new UnpackedRecord();
						r.pKeyInfo = pCur.pKeyInfo;
						r.aMem = pX.aMem;
						r.nField = (ushort)(pX.nMem);
						r.default_rc = (sbyte)(0);
						r.eqSeen = (byte)(0);
						rc = (int)(sqlite3BtreeIndexMoveto(pCur, r, &loc));
					}
					else
					{
						rc = (int)(btreeMoveto(pCur, pX.pKey, (long)(pX.nKey), (int)((flags & 0x08) != 0), &loc));
					}

					if ((rc) != 0)
						return (int)(rc);
				}

				if ((loc) == (0))
				{
					getCellInfo(pCur);
					if ((pCur.info.nKey) == (pX.nKey))
					{
						BtreePayload x2 = new BtreePayload();
						x2.pData = pX.pKey;
						x2.nData = (int)(pX.nKey);
						x2.nZero = (int)(0);
						return (int)(btreeOverwriteCell(pCur, x2));
					}
				}
			}

			pPage = pCur.pPage;
			if ((pPage.nFree) < (0))
			{
				if ((pCur.eState) > (1))
				{
					rc = (int)(sqlite3CorruptError((int)(75150)));
				}
				else
				{
					rc = (int)(btreeComputeFreeSpace(pPage));
				}

				if ((rc) != 0)
					return (int)(rc);
			}

			newCell = pBt.pTmpSpace;
			if ((flags & 0x80) != 0)
			{
				rc = (int)(0);
				szNew = (int)(pBt.nPreformatSize);
				if ((szNew) < (4))
					szNew = (int)(4);
				if (((pBt.autoVacuum) != 0) && ((szNew) > (pPage.maxLocal)))
				{
					CellInfo info = new CellInfo();
					pPage.xParseCell(pPage, newCell, &info);
					if (info.nPayload != info.nLocal)
					{
						uint ovfl = (uint)(sqlite3Get4byte(&newCell[szNew - 4]));
						ptrmapPut(pBt, (uint)(ovfl), (byte)(3), (uint)(pPage.pgno), &rc);
					}
				}
			}
			else
			{
				rc = (int)(fillInCell(pPage, newCell, pX, &szNew));
			}

			if ((rc) != 0)
				goto end_insert;
			idx = (int)(pCur.ix);
			if ((loc) == (0))
			{
				CellInfo info = new CellInfo();
				if ((idx) >= (pPage.nCell))
				{
					return (int)(sqlite3CorruptError((int)(75186)));
				}

				rc = (int)(sqlite3PagerWrite(pPage.pDbPage));
				if ((rc) != 0)
				{
					goto end_insert;
				}

				oldCell = ((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))));
				if (pPage.leaf == 0)
				{
					CRuntime.memcpy(newCell, oldCell, (ulong)(4));
				}

				pPage.xParseCell(pPage, oldCell, &info);
				if (info.nLocal != info.nPayload)
				{
					rc = (int)(clearCellOverflow(pPage, oldCell, &info));
				}
				else
				{
					rc = (int)(0);
				}

				(pCur.curFlags &= (byte)(~0x04));
				if ((((info.nSize) == (szNew)) && ((info.nLocal) == (info.nPayload))) && (((pBt.autoVacuum) == 0) || ((szNew) < (pPage.minLocal))))
				{
					if ((oldCell) < (pPage.aData + pPage.hdrOffset + 10))
					{
						return (int)(sqlite3CorruptError((int)(75213)));
					}

					if ((oldCell + szNew) > (pPage.aDataEnd))
					{
						return (int)(sqlite3CorruptError((int)(75216)));
					}

					CRuntime.memcpy(oldCell, newCell, (ulong)(szNew));
					return (int)(0);
				}

				dropCell(pPage, (int)(idx), (int)(info.nSize), &rc);
				if ((rc) != 0)
					goto end_insert;
			}
			else if (((loc) < (0)) && ((pPage.nCell) > (0)))
			{
				idx = (int)(++pCur.ix);
				pCur.curFlags &= (byte)(~0x02);
			}
			else
			{
			}

			insertCell(pPage, (int)(idx), newCell, (int)(szNew), null, (uint)(0), &rc);
			pCur.info.nSize = (ushort)(0);
			if ((pPage.nOverflow) != 0)
			{
				pCur.curFlags &= (byte)(~(0x02));
				rc = (int)(balance(pCur));
				pCur.pPage.nOverflow = (byte)(0);
				pCur.eState = (byte)(1);
				if (((flags & 0x02) != 0) && ((rc) == (0)))
				{
					btreeReleaseAllCursorPages(pCur);
					if ((pCur.pKeyInfo) != null)
					{
						pCur.pKey = sqlite3Malloc((ulong)(pX.nKey));
						if ((pCur.pKey) == (null))
						{
							rc = (int)(7);
						}
						else
						{
							CRuntime.memcpy(pCur.pKey, pX.pKey, (ulong)(pX.nKey));
						}
					}

					pCur.eState = (byte)(3);
					pCur.nKey = (long)(pX.nKey);
				}
			}

		end_insert:
			; return (int)(rc);
		}
		public static long sqlite3BtreeIntegerKey(BtCursor pCur)
		{
			getCellInfo(pCur);
			return (long)(pCur.info.nKey);
		}
		public static int sqlite3BtreeLast(BtCursor pCur, int* pRes)
		{
			int rc = 0;
			if (((0) == (pCur.eState)) && ((pCur.curFlags & 0x08) != 0))
			{
				*pRes = (int)(0);
				return (int)(0);
			}

			rc = (int)(moveToRoot(pCur));
			if ((rc) == (0))
			{
				*pRes = (int)(0);
				rc = (int)(moveToRightmost(pCur));
				if ((rc) == (0))
				{
					pCur.curFlags |= (byte)(0x08);
				}
				else
				{
					pCur.curFlags &= (byte)(~0x08);
				}
			}
			else if ((rc) == (16))
			{
				*pRes = (int)(1);
				rc = (int)(0);
			}

			return (int)(rc);
		}
		public static void sqlite3BtreeLeaveCursor(BtCursor pCur)
		{
			sqlite3BtreeLeave(pCur.pBtree);
		}
		public static long sqlite3BtreeMaxRecordSize(BtCursor pCur)
		{
			return (long)(pCur.pBt.pageSize * (long)(pCur.pBt.nPage));
		}
		public static int sqlite3BtreeNext(BtCursor pCur, int flags)
		{
			MemPage pPage;
			pCur.info.nSize = (ushort)(0);
			pCur.curFlags &= (byte)(~(0x02 | 0x04));
			if (pCur.eState != 0)
				return (int)(btreeNext(pCur));
			pPage = pCur.pPage;
			if ((++pCur.ix) >= (pPage.nCell))
			{
				pCur.ix--;
				return (int)(btreeNext(pCur));
			}

			if ((pPage.leaf) != 0)
			{
				return (int)(0);
			}
			else
			{
				return (int)(moveToLeftmost(pCur));
			}
		}
		public static int sqlite3BtreePayload(BtCursor pCur, uint offset, uint amt, void* pBuf)
		{
			return (int)(accessPayload(pCur, (uint)(offset), (uint)(amt), (byte*)(pBuf), (int)(0)));
		}
		public static int sqlite3BtreePayloadChecked(BtCursor pCur, uint offset, uint amt, void* pBuf)
		{
			if ((pCur.eState) == (0))
			{
				return (int)(accessPayload(pCur, (uint)(offset), (uint)(amt), pBuf, (int)(0)));
			}
			else
			{
				return (int)(accessPayloadChecked(pCur, (uint)(offset), (uint)(amt), pBuf));
			}
		}
		public static uint sqlite3BtreePayloadSize(BtCursor pCur)
		{
			getCellInfo(pCur);
			return (uint)(pCur.info.nPayload);
		}
		public static int sqlite3BtreePrevious(BtCursor pCur, int flags)
		{
			pCur.curFlags &= (byte)(~(0x08 | 0x04 | 0x02));
			pCur.info.nSize = (ushort)(0);
			if (((pCur.eState != 0) || ((pCur.ix) == (0))) || ((pCur.pPage.leaf) == (0)))
			{
				return (int)(btreePrevious(pCur));
			}

			pCur.ix--;
			return (int)(0);
		}
		public static int sqlite3BtreePutData(BtCursor pCsr, uint offset, uint amt, void* z)
		{
			int rc = 0;
			rc = (int)((pCsr.eState) >= (3) ? btreeRestoreCursorPosition(pCsr) : 0);
			if (rc != 0)
			{
				return (int)(rc);
			}

			if (pCsr.eState != 0)
			{
				return (int)(4);
			}

			saveAllCursors(pCsr.pBt, (uint)(pCsr.pgnoRoot), pCsr);
			if ((pCsr.curFlags & 0x01) == (0))
			{
				return (int)(8);
			}

			return (int)(accessPayload(pCsr, (uint)(offset), (uint)(amt), (byte*)(z), (int)(1)));
		}
		public static long sqlite3BtreeRowCountEst(BtCursor pCur)
		{
			long n = 0;
			byte i = 0;
			if ((pCur.eState != 0))
				return (long)(-1);
			if (((pCur.pPage.leaf) == (0)))
				return (long)(-1);
			n = (long)(pCur.pPage.nCell);
			for (i = (byte)(0); (i) < (pCur.iPage); i++)
			{
				n *= (long)(pCur.apPage[i].nCell);
			}

			return (long)(n);
		}
		public static int sqlite3BtreeTableMoveto(BtCursor pCur, long intKey, int biasRight, int* pRes)
		{
			int rc = 0;
			if (((pCur.eState) == (0)) && ((pCur.curFlags & 0x02) != 0))
			{
				if ((pCur.info.nKey) == (intKey))
				{
					*pRes = (int)(0);
					return (int)(0);
				}

				if ((pCur.info.nKey) < (intKey))
				{
					if ((pCur.curFlags & 0x08) != 0)
					{
						*pRes = (int)(-1);
						return (int)(0);
					}

					if ((pCur.info.nKey + 1) == (intKey))
					{
						*pRes = (int)(0);
						rc = (int)(sqlite3BtreeNext(pCur, (int)(0)));
						if ((rc) == (0))
						{
							getCellInfo(pCur);
							if ((pCur.info.nKey) == (intKey))
							{
								return (int)(0);
							}
						}
						else if (rc != 101)
						{
							return (int)(rc);
						}
					}
				}
			}

			rc = (int)(moveToRoot(pCur));
			if ((rc) != 0)
			{
				if ((rc) == (16))
				{
					*pRes = (int)(-1);
					return (int)(0);
				}

				return (int)(rc);
			}

			for (; ; )
			{
				int lwr = 0;
				int upr = 0;
				int idx = 0;
				int c = 0;
				uint chldPg = 0;
				MemPage pPage = pCur.pPage;
				byte* pCell;
				lwr = (int)(0);
				upr = (int)(pPage.nCell - 1);
				idx = (int)(upr >> (1 - biasRight));
				for (; ; )
				{
					long nCellKey = 0;
					pCell = ((pPage).aDataOfst + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (idx)])))));
					if ((pPage.intKeyLeaf) != 0)
					{
						while ((0x80) <= (*(pCell++)))
						{
							if ((pCell) >= (pPage.aDataEnd))
							{
								return (int)(sqlite3CorruptError((int)(71750)));
							}
						}
					}

					sqlite3GetVarint(pCell, (ulong*)(&nCellKey));
					if ((nCellKey) < (intKey))
					{
						lwr = (int)(idx + 1);
						if ((lwr) > (upr))
						{
							c = (int)(-1);
							break;
						}
					}
					else if ((nCellKey) > (intKey))
					{
						upr = (int)(idx - 1);
						if ((lwr) > (upr))
						{
							c = (int)(+1);
							break;
						}
					}
					else
					{
						pCur.ix = ((ushort)(idx));
						if (pPage.leaf == 0)
						{
							lwr = (int)(idx);
							goto moveto_table_next_layer;
						}
						else
						{
							pCur.curFlags |= (byte)(0x02);
							pCur.info.nKey = (long)(nCellKey);
							pCur.info.nSize = (ushort)(0);
							*pRes = (int)(0);
							return (int)(0);
						}
					}

					idx = (int)((lwr + upr) >> 1);
				}

				if ((pPage.leaf) != 0)
				{
					pCur.ix = ((ushort)(idx));
					*pRes = (int)(c);
					rc = (int)(0);
					goto moveto_table_finish;
				}

			moveto_table_next_layer:
				;
				if ((lwr) >= (pPage.nCell))
				{
					chldPg = (uint)(sqlite3Get4byte(&pPage.aData[pPage.hdrOffset + 8]));
				}
				else
				{
					chldPg = (uint)(sqlite3Get4byte(((pPage).aData + ((pPage).maskPage & _byteswap_ushort((ushort)(*(ushort*)(&(pPage).aCellIdx[2 * (lwr)])))))));
				}

				pCur.ix = ((ushort)(lwr));
				rc = (int)(moveToChild(pCur, (uint)(chldPg)));
				if ((rc) != 0)
					break;
			}

		moveto_table_finish:
			; pCur.info.nSize = (ushort)(0);
			return (int)(rc);
		}
		public static int sqlite3BtreeTransferRow(BtCursor pDest, BtCursor pSrc, long iKey)
		{
			int rc = (int)(0);
			BtShared pBt = pDest.pBt;
			byte* aOut = pBt.pTmpSpace;
			byte* aIn;
			uint nIn = 0;
			uint nRem = 0;
			getCellInfo(pSrc);
			aOut += (byte)(((pSrc.info.nPayload) < ((uint)(0x80))) ? (*(aOut) = ((byte)(pSrc.info.nPayload))), 1 :  sqlite3PutVarint((aOut), (ulong)(pSrc.info.nPayload)) ) ;
			if ((pDest.pKeyInfo) == (null))
				aOut += sqlite3PutVarint(aOut, (ulong)(iKey));
			nIn = (uint)(pSrc.info.nLocal);
			aIn = pSrc.info.pPayload;
			if ((aIn + nIn) > (pSrc.pPage.aDataEnd))
			{
				return (int)(sqlite3CorruptError((int)(75316)));
			}

			nRem = (uint)(pSrc.info.nPayload);
			if (((nIn) == (nRem)) && ((nIn) < (pDest.pPage.maxLocal)))
			{
				CRuntime.memcpy(aOut, aIn, (ulong)(nIn));
				pBt.nPreformatSize = (int)(nIn + (aOut - pBt.pTmpSpace));
			}
			else
			{
				Pager pSrcPager = pSrc.pBt.pPager;
				byte* pPgnoOut = null;
				uint ovflIn = (uint)(0);
				PgHdr pPageIn = null;
				MemPage pPageOut = null;
				uint nOut = 0;
				nOut = (uint)(btreePayloadToLocal(pDest.pPage, (long)(pSrc.info.nPayload)));
				pBt.nPreformatSize = (int)(nOut + (aOut - pBt.pTmpSpace));
				if ((nOut) < (pSrc.info.nPayload))
				{
					pPgnoOut = &aOut[nOut];
					pBt.nPreformatSize += (int)(4);
				}

				if ((nRem) > (nIn))
				{
					if ((aIn + nIn + 4) > (pSrc.pPage.aDataEnd))
					{
						return (int)(sqlite3CorruptError((int)(75339)));
					}

					ovflIn = (uint)(sqlite3Get4byte(&pSrc.info.pPayload[nIn]));
				}

				do
				{
					nRem -= (uint)(nOut);
					do
					{
						if ((nIn) > (0))
						{
							int nCopy = (int)((nOut) < (nIn) ? (nOut) : (nIn));
							CRuntime.memcpy(aOut, aIn, (ulong)(nCopy));
							nOut -= (uint)(nCopy);
							nIn -= (uint)(nCopy);
							aOut += nCopy;
							aIn += nCopy;
						}

						if ((nOut) > (0))
						{
							sqlite3PagerUnref(pPageIn);
							pPageIn = null;
							rc = (int)(sqlite3PagerGet(pSrcPager, (uint)(ovflIn), pPageIn, (int)(0x02)));
							if ((rc) == (0))
							{
								aIn = (byte*)(sqlite3PagerGetData(pPageIn));
								ovflIn = (uint)(sqlite3Get4byte(aIn));
								aIn += 4;
								nIn = (uint)(pSrc.pBt.usableSize - 4);
							}
						}
					}
					while (((rc) == (0)) && ((nOut) > (0)));
					if ((((rc) == (0)) && ((nRem) > (0))) && ((pPgnoOut) != null))
					{
						uint pgnoNew = 0;
						MemPage pNew = null;
						rc = (int)(allocateBtreePage(pBt, pNew, &pgnoNew, (uint)(0), (byte)(0)));
						sqlite3Put4byte(pPgnoOut, (uint)(pgnoNew));
						if (((pBt.autoVacuum) != 0) && ((pPageOut) != null))
						{
							ptrmapPut(pBt, (uint)(pgnoNew), (byte)(4), (uint)(pPageOut.pgno), &rc);
						}

						releasePage(pPageOut);
						pPageOut = pNew;
						if ((pPageOut) != null)
						{
							pPgnoOut = pPageOut.aData;
							sqlite3Put4byte(pPgnoOut, (uint)(0));
							aOut = &pPgnoOut[4];
							nOut = (uint)((pBt.usableSize - 4) < (nRem) ? (pBt.usableSize - 4) : (nRem));
						}
					}
				}
				while (((nRem) > (0)) && ((rc) == (0)));
				releasePage(pPageOut);
				sqlite3PagerUnref(pPageIn);
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeMemFromBtree(BtCursor pCur, uint offset, uint amt, sqlite3_value pMem)
		{
			int rc = 0;
			pMem.flags = (ushort)(0x0001);
			if ((sqlite3BtreeMaxRecordSize(pCur)) < (offset + amt))
			{
				return (int)(sqlite3CorruptError((int)(79076)));
			}

			if ((0) == (rc = (int)(sqlite3VdbeMemClearAndResize(pMem, (int)(amt + 1)))))
			{
				rc = (int)(sqlite3BtreePayload(pCur, (uint)(offset), (uint)(amt), pMem.z));
				if ((rc) == (0))
				{
					pMem.z[amt] = (sbyte)(0);
					pMem.flags = (ushort)(0x0010);
					pMem.n = ((int)(amt));
				}
				else
				{
					sqlite3VdbeMemRelease(pMem);
				}
			}

			return (int)(rc);
		}
		public static int sqlite3VdbeMemFromBtreeZeroOffset(BtCursor pCur, uint amt, sqlite3_value pMem)
		{
			uint available = (uint)(0);
			int rc = (int)(0);
			pMem.z = (sbyte*)(sqlite3BtreePayloadFetch(pCur, &available));
			if ((amt) <= (available))
			{
				pMem.flags = (ushort)(0x0010 | 0x1000);
				pMem.n = ((int)(amt));
			}
			else
			{
				rc = (int)(sqlite3VdbeMemFromBtree(pCur, (uint)(0), (uint)(amt), pMem));
			}

			return (int)(rc);
		}
	}
}